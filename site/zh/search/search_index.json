{"config": {"lang": ["zh"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"], "fields": {"title": {"boost": 1000.0}, "text": {"boost": 1.0}, "tags": {"boost": 1000000.0}}}, "docs": [{"location": "ai-resources/ai-resources/", "title": "AI 资源", "text": "<p>Moonbeam 提供了 <code>.txt</code> 文件，其中包含文档内容和导航结构，这些文件经过优化，可与大型语言模型 (LLM) 和 AI 工具配合使用。这些资源有助于构建 AI 助手、增强代码搜索功能，或支持基于 Moonbeam 文档训练的自定义工具。</p> <p>每个类别文件都包含来自基础知识和参考类别的基础内容，以确保 LLM 具有必要的上下文。</p>"}, {"location": "ai-resources/ai-resources/#llm", "title": "下载 LLM 文件", "text": "类别 描述 文件 操作 索引 所有 Moonbeam 文档页面的导航索引 <code>llms.txt</code> 完整文档 所有文档页面的完整内容 <code>llms-full.txt</code> 基础 Moonbeam 的框架、架构和核心组件 <code>llms-basics.txt</code> 参考 参考资料，包括网络端点、JSON-RPC 方法以及合约或代币地址 <code>llms-reference.txt</code> Ethereum 工具包 用于处理 Moonbeam EVM 的实用工具和智能合约 <code>llms-ethereum-toolkit.txt</code> Substrate 工具包 用于处理 Substrate 的实用工具和智能合约 <code>llms-substrate-toolkit.txt</code> GMP 提供者 如何使用通用消息传递 (GMP) 进行跨链通信 <code>llms-gmp-providers.txt</code> XCM 了解和使用跨共识消息传递 (XCM) <code>llms-xcm.txt</code> XC-20 与 XC-20 代币交互的指南 <code>llms-xc-20.txt</code> XCM 远程执行 如何使用 XCM 进行跨链调用 <code>llms-xcm-remote-execution.txt</code> 预编译 使用 Moonbeam 预编译的指南 <code>llms-precompiles.txt</code> 库和 SDK 常用库和 SDK 的资源 <code>llms-libraries-and-sdks.txt</code> 开发环境 如何设置 Hardhat 和 Foundry 等开发环境 <code>llms-dev-environments.txt</code> JSON-RPC API RPC 使用和追踪 <code>llms-json-rpc-apis.txt</code> 节点运营商和整理人 如何运行完整节点或区块生成整理人 <code>llms-node-operators-and-collators.txt</code> Oracle 节点 如何与 oracle 节点提供商集成 <code>llms-oracle-nodes.txt</code> 索引器和查询 如何与索引器和查询节点提供商集成 <code>llms-indexers-and-queries.txt</code> 代币和账户 如何在 Moonbeam 上管理代币和账户 <code>llms-tokens-and-accounts.txt</code> 质押 委托和整理指南 <code>llms-staking.txt</code> 治理 治理指南，包括投票和财务 <code>llms-governance.txt</code> 集成 将 Moonbeam 与各种工具（如钱包和分析工具）集成的指南 <code>llms-integrations.txt</code> 教程 全面、逐步的项目构建指导 <code>llms-tutorials.txt</code> <p>Note</p> <p><code>llms-full.txt</code> 文件可能因其大小而超出某些语言模型的输入限制。如果遇到限制，请考虑按类别使用文件。</p>"}, {"location": "builders/build/historical-updates/", "title": "历史更新", "text": ""}, {"location": "builders/build/historical-updates/#introduction", "title": "简介", "text": "<p>本页面概述了 Moonbeam 和 Moonriver 上的历史更新，例如 Moonbeam 源代码的错误修复和应用的数据迁移。</p> <p>本页面旨在提供与需要强制数据迁移的更新相关的意外行为或数据不一致的信息。</p>"}, {"location": "builders/build/historical-updates/#invalid-transactions-stored", "title": "存储的无效交易", "text": "<p>对于交易成本无法支付的无效交易，EVM pallet 将交易元数据插入到存储中，而不是丢弃它，因为没有交易成本验证。因此，运行时存储不必要地因无效交易数据而膨胀。</p> <p>此错误仅影响 Moonriver 和 Moonbase Alpha，并且存在于以下运行时和区块范围内：</p> 网络 引入 修复 受影响的区块范围 Moonriver RT49 RT600 0 - 455106 Moonbase Alpha RT40 RT600 0 - 675175 <p>有关更多信息，您可以查看 GitHub 上的相关 Frontier PR。</p>"}, {"location": "builders/build/historical-updates/#ethereum-fees-to-treasury", "title": "以太坊费用未发送至国库", "text": "<p>在 Runtime 3401 之前和MB101 通过之前，Moonbeam 交易费用模型规定将 20% 的费用分配给链上国库，80% 作为通货紧缩力量销毁。但是，在 runtime 800 之前，以太坊交易未正确地将 20% 的交易费用分配给链上国库。</p> <p>此错误仅影响 Moonriver 和 Moonbase Alpha，并存在于以下运行时和区块范围中：</p> 网络 引入 修复 受影响的区块范围 Moonriver RT49 RT800 0 - 684728 Moonbase Alpha RT40 RT800 0 - 915684 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#missing-refunds", "title": "缺少退款", "text": "<p>Moonbeam 配置为将存在性存款设置为 0，这意味着帐户不需要最低余额即可被视为有效。对于具有此配置的基于 Substrate 的链，由于帐户被解释为不存在，因此某些清除帐户的退款丢失了。</p> <p>此错误存在于以下运行时和区块范围：</p> 网络 引入 修复 受影响的区块范围 Moonbeam RT900 RT1001 0 - 5164 Moonriver RT49 RT1001 0 - 1052241 Moonbase Alpha RT40 RT1001 0 - 1285915 <p>有关更多信息，您可以查看相关的 Frontier PR和 GitHub 上的相关 Substrate PR。</p>"}, {"location": "builders/build/historical-updates/#incorrect-collator-selection", "title": "不正确的整理人选择", "text": "<p>当通过 <code>delegatorBondMore</code> extrinsic 增加委托时，整理人候选人的总委托未正确更新。这导致增加的委托金额未包含在候选人的总绑定金额中，而总绑定金额用于确定哪些候选人在整理人的活动集中。因此，一些候选人可能未被选择进入活动集中，尽管他们本应被选中，这影响了他们自己及其委托人的奖励。</p> <p>此错误存在于以下运行时和区块范围中：</p> 网络 引入 修复 受影响的区块范围 Moonbeam RT900 RT1300 0 - 524762 Moonriver RT49 RT1300 0 - 1541735 Moonbase Alpha RT40 RT1300 0 - 1761128 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#new-account-event", "title": "新账户事件错误", "text": "<p>当创建新账户时，会发出 <code>System.NewAccount</code> 事件。但是，一个错误阻止了在创建时为某些账户发出此事件。应用了一个热修复程序，该程序修补了受影响的帐户，并在稍后发出了 <code>System.NewAccount</code>。</p> <p>该热修复程序应用于以下区块范围：</p> 网络 区块范围 Moonbeam 1041355 - 1041358 和 1100752 Moonriver 1835760 - 1835769 Moonbase Alpha 2097782 - 2097974 <p>此错误存在于以下运行时和区块范围期间：</p> 网络 引入 修复 受影响的区块范围 Moonbeam RT900 RT1401 0 - 915320 Moonriver RT49 RT1401 0 - 1705939 Moonbase Alpha RT40 RT1400 0 - 1962557 <p>有关更多信息，您可以查看 GitHub 上的相关 Frontier PR。</p>"}, {"location": "builders/build/historical-updates/#incorrect-timestamp-units", "title": "不正确的时间戳单位", "text": "<p>EIP-2612 和以太坊区块处理的时间戳以秒为单位；但是，Moonbeam 实现的 Substrate 时间戳 pallet 使用的是毫秒。这只影响了 EIP-2612 的实现，而没有影响 <code>block.timestamp</code> 值。</p> <p>以下运行时和区块范围存在此错误：</p> 网络 引入 已修复 受影响的区块范围 Moonbeam RT900 RT1606 0 - 1326697 Moonriver RT49 RT1605 0 - 2077598 Moonbase Alpha RT40 RT1603 0 - 2285346 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#substrate-tips", "title": "Substrate 小费缺失 Treasury 分配", "text": "<p>基于 Substrate 的交易的小费没有得到正确的处理。因为小费没有在运行时代码中处理，导致整个小费部分都被销毁了。我们应用了一个修复方案，将 20% 的小费支付给 Treasury，80% 的小费被销毁，这与当时所有其他的费用行为一致。</p> <p>请注意，RT3401 引入了一个参数 pallet 费用配置，允许治理调整费用在 Treasury 和销毁之间的分配方式。在该运行时升级与 MB101 通过后，Moonbeam 和 Moonriver 上的所有交易费用现在 100% 都会被销毁。</p> <p>此错误存在于以下运行时和区块范围中：</p> 网络 引入版本 修复版本 影响的区块范围 Moonbeam RT900 RT2403 0 - 4163078 Moonriver RT49 RT2401 0 - 4668844 Moonbase Alpha RT40 RT2401 0 - 4591616 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#incorrect-delegation-reward-calculation", "title": "错误的委托奖励计算", "text": "<p>每当有待处理的请求时，所有委托和整理者的奖励支出都被低估了。委托奖励是根据每个委托者绑定的代币数量与给定整理者的总股权相关的。通过计算待处理请求的委托数量，整理者及其委托的奖励低于应有的水平。</p> <p>此错误存在于以下运行时和区块范围内：</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1001 RT1802 5165 - 1919457 Moonriver RT1001 RT1801 1052242 - 2572555 Moonbase Alpha RT1001 RT1800 1285916 - 2748785 <p>您可以查看 GitHub 上的相关 PR 以获取更多信息。</p>"}, {"location": "builders/build/historical-updates/#block-parent-hash-calculated-incorrectly", "title": "区块父哈希计算不正确", "text": "<p>在引入 EIP-1559 支持（包括过渡到新的以太坊交易类型）后，区块头的父哈希被错误地计算为 <code>H256::default</code>。</p> <p>此错误仅影响 Moonbase Alpha，并且仅影响以下区块：</p> 网络 引入 修复 受影响的区块 Moonbase Alpha RT1200 RT1201 1648995 <p>虽然根本问题已在 RT1201 中修复，但错误的哈希已在 RT2601 中更正。</p> <p>有关根本修复的更多信息，您可以查看GitHub 上的相关 Frontier PR。要查看父哈希的更正，请查看相应的 GitHub 上的 Moonbeam PR。</p>"}, {"location": "builders/build/historical-updates/#incorrect-gas-fees-eip1559", "title": "EIP-1559 Gas 费的错误处理", "text": "<p>随着 EIP-1559 支持的引入，处理 <code>maxFeePerGas</code> 和 <code>maxPriorityFeePerGas</code> 的逻辑实现不正确。因此，即使总金额超过 <code>maxFeePerGas</code>，<code>maxPriorityFeePerGas</code> 也会被添加到 <code>baseFee</code> 中。</p> <p>此错误存在于以下运行时和区块范围中：</p> 网络 引入 修复 受影响的区块范围 Moonbeam RT1201 RT1401 415946 - 915320 Moonriver RT1201 RT1401 1471037 - 1705939 Moonbase Alpha RT1200 RT1400 1648994 - 1962557 <p>有关更多信息，您可以查看相关的 Frontier PR。</p>"}, {"location": "builders/build/historical-updates/#transaction-fees-paid-to-collators", "title": "支付给收集人的交易费用", "text": "<p>对于包含应用了优先级费用的 EIP-1559 交易的区块，交易费用的计算不正确，并分配给了区块的收集人。Moonbeam 上交易和智能合约执行的费用模型之前是这样处理的：20% 的费用进入链上财政库，80% 被销毁以作为通货紧缩的力量。由于此错误，受影响交易的交易费用未按预期销毁。</p> <p>请注意，RT3401 引入了一个参数 pallet 费用配置，允许治理调整费用在财政库和销毁之间如何分配。在此运行时升级与 MB101 的通过相结合后，Moonbeam 和 Moonriver 上的所有交易费用现在 100% 都会被销毁。</p> <p>此错误存在于以下运行时和区块范围内：</p> 网络 引入 已修复 受影响的区块范围 Moonbeam RT1201 RT1504 415946 - 1117309 Moonriver RT1201 RT1504 1471037 - 1910639 Moonbase Alpha RT1200 RT1504 1648994 - 2221772 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#incorrect-state-root-hash", "title": "错误的 State Root Hash", "text": "<p>由于未考虑交易类型字节，因此非旧式交易的 State Root Hash 计算错误。在支持 EIP-2930 和 EIP-1559 的情况下，引入的交易类型分别为 <code>0x01</code> (1) 和 <code>0x02</code> (2)。这些交易类型在 State Root Hash 的计算中被省略。</p> <p>此错误存在于以下运行时和区块范围中：</p> 网络 引入时间 修复时间 受影响的区块范围 Moonbeam RT1201 RT1701 415946 - 1581456 Moonriver RT1201 RT1701 1471037 - 2281722 Moonbase Alpha RT1200 RT1700 1648994 - 2529735 <p>如需更多信息，您可以查看 相关的 Frontier PR 和 GitHub 上的 Moonbeam PR。</p>"}, {"location": "builders/build/historical-updates/#ethereum-transactions-duplicated-in-storage", "title": "Ethereum 交易在儲存中重複", "text": "<p>以太坊 Pallet 的 Frontier 中引入了一個上游錯誤，導致在運行時升級期間存在的待處理交易在兩個不同的區塊中儲存中重複。這僅影響到引入此錯誤的運行時升級之後的前兩個區塊。</p> <p>只有 Moonriver 和 Moonbase Alpha 受到了影響。此錯誤在以下運行時中引入，並影響了以下區塊：</p> 網路 引入 受影響的區塊 Moonriver RT1605 2077599 和 2077600 Moonbase Alpha RT1603 2285347 和 2285348 <p>以下交易被重複：</p> MoonriverMoonbase Alpha <pre><code>'0x2cceda1436e32ae3b3a2194a8cb5bc4188259600c714789bae1fedc0bbc5125f',\n'0x3043660e35e89cafd7b0e0dce9636f5fcc218fce2a57d1104cf21aabbff9a1c0',\n'0x514411fb5c08f7c5aa6c61c38f33edfa74ff7e160831f6140e8dd3783648dbca',\n'0xf1647c357d8e1b05c522d11cff1f5090a4df114595d0f4b9e4ac5bb746473eea',\n'0x4be94803fe7839d5ef13ddd2633a293b4a7dddbe526839c15c1646c72e7b0b23',\n'0x15fceb009bd49692b598859f9146303ed4d8204b38e35c147fcdb18956679dbe',\n'0xa7460d23d5c633feec3d8e8f4382240d9b71a0d770f7541c3c32504b5403b70c',\n'0x1c838b4c4e7796a9db5edfd0377aee6e0d89b623bf1d7803f766f4cf71daefb9',\n'0xfb233a893e62d717ed627585f14b1ee8b3e300ac4e2c3016eb63e546a60820f0',\n'0xfaf8908838683ad51894eb3c68196afb99ba2e2bb698a40108960ee55417b56a',\n'0xa53973acbeac9fe948015dcfad6e0cb28d91b93c8115347c178333e73fd332d3',\n'0x9df769c96c5fdd505c67fee27eaff3714bf8f3d45a2afc02dd2984884b3cecac',\n'0x8f912ae91b408f082026992a87060ed245dac6e382a84288bd38fc08dbac30fe',\n'0xb22af459d24cb25bc53785bdd0ae6a573e24f226c94fd8d2e4663b87d3b07a88',\n'0x8ab9cd2bde7d679f798528b0c75325787f5fc7997e00589445b35b3954a815aa',\n'0xd08a1f82f4d3dc553b4b559925f997ef8bb85cb24cb4d0b893f017129fb33b78',\n'0xa1d40bce7cc607c19ca4b37152b6d8d3a408e3de6b9789c5977fcdef7ef14d97',\n'0xe442227634db10f5d0e8c1da09f8721c2a57267edbf97c4325c4f8432fd48ade',\n'0x0b4f5d8338a7c2b1604c1c42e96b12dc2a9d5ab264eb74ff730354e9765de13f',\n'0x0b00fc907701003aad75560d8b1a33cbf4b75f76c81d776b8b92d20e1d2e9d31',\n'0x9c18bd783f28427d873970ff9deaf1549db2f9a76e3edd6bdeae11358e447ef4',\n'0x8b2523f163989969dd0ebcac85d14805756bc0075b89da1274fd2c53ccaa396a',\n'0x47e80a0c533265974a55ea62131814e31b10f42895709f7e531e3e7b69f1387c'\n</code></pre> <pre><code>'0x006a6843eb35ad35a9ea9a99affa8d81f1ed500253c98cc9c080d84171a0afb3',\n'0x64c102f664eb435206ad4fcb49b526722176bcf74801c79473c3b5b2c281a243',\n'0xf546335453b6e35ce7e236ee873c96ba3a22602b3acc4f45f5d68b33a76d79ca',\n'0x4ed713ccd474fc33d2022a802f064cc012e3e37cd22891d4a89c7ba3d776f2db',\n'0xa5355f86844bb23fe666b10b509543fa377a9e324513eb221e0a2c926a64cae4',\n'0xc14791a3a392018fc3438f39cac1d572e8baadd4ed350e0355d1ca874a169e6a'\n</code></pre> <p>重複的交易屬於第一個區塊。 因此，在 Moonriver 上，交易屬於區塊 2077599，而在 Moonbase Alpha 上，受影響的交易屬於區塊 2285347。</p> <p>如需更多資訊，您可以查看 GitHub 上的相關 Frontier PR。</p>"}, {"location": "builders/build/historical-updates/#gas-limit-too-high-for-non-transactional-calls", "title": "非事务性调用的 Gas Limit 过高", "text": "<p>当发出非事务性调用（例如 <code>eth_call</code> 或 <code>eth_estimateGas</code>）时，如果没有为过去的区块指定 gas limit，客户端将默认使用 gas limit 乘数 (10x)，这会导致 gas limit 验证失败，因为它正在根据区块 gas limit 的上限进行验证。因此，如果给定调用的 gas limit 大于区块 gas limit，则会返回 gas limit 过高的错误。</p> <p>此错误存在于以下运行时和区块范围内：</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1701 RT1802 1581457 - 1919457 Moonriver RT1701 RT1802 2281723 - 2616189 Moonbase Alpha RT1700 RT1802 2529736 - 2879402 <p>您可以查看 GitHub 上的相关 Frontier PR 以了解更多信息。</p>"}, {"location": "builders/build/historical-updates/#remote-evm-calls-return-identical-tx-hashes", "title": "远程 EVM 调用返回相同的交易哈希", "text": "<p>当从具有相同交易负载和 nonce 的不同账户发送多个远程 EVM 调用时，每次调用都返回相同的交易哈希。这是因为远程 EVM 调用是从无密钥账户执行的，因此如果发送者都具有相同的 nonce 并且发送的是相同的交易对象，则在计算交易哈希时没有差异。通过向 Ethereum XCM Pallet 添加全局 nonce 解决了这个问题，该 pallet 使远程 EVM 调用成为可能。</p> <p>此错误仅在以下运行时和区块范围内的 Moonbase Alpha 上存在：</p> Network Introduced Fixed Impacted Block Range Moonbase Alpha RT1700 RT1900 2529736 - 3069634 <p>您可以查看 GitHub 上的相关 PR 以获取更多信息。</p>"}, {"location": "builders/build/historical-updates/#gas-estimation-discrepancy", "title": "Gas 估计差异", "text": "<p>在使用非交易调用（如 <code>eth_call</code>）估算交易的 Gas 与在链上执行交易之间存在差异。造成这种差异的原因是非交易调用没有正确计算 <code>maxFeePerGas</code> 和 <code>maxPriorityFeePerGas</code>，因此，Ethereum 交易消耗的（有效性证明）的计算方式不同。通过在估算链上交易规模时正确计算这些字段，此问题已得到修复。</p> <p>此错误存在于以下运行时和区块范围内：</p> 网络 引入 修复 受影响的区块范围 Moonbeam RT1201 RT2501 415946 - 4543267 Moonriver RT1201 RT2500 1471037 - 5175574 Moonbase Alpha RT1200 RT2500 1648994 - 5053547 <p>您可以查看 GitHub 上的相关 PR 以获取更多信息。</p>"}, {"location": "builders/build/historical-updates/#incorrect-effective-gas-price", "title": "交易回执中不正确的有效 Gas 价格", "text": "<p>由于基本费计算不正确，<code>eth_getTransactionReceipt</code> 返回的 <code>effectiveGasPrice</code> 值与链上值不同。具体来说，交易回执的值是使用交易所在的区块中的 <code>NextFeeMultiplier</code> 计算的，而不是前一个区块，前一个区块是计算基本费的正确来源。</p> <p>此错误存在于以下运行时和区块范围内：</p> 网络 引入 修复 受影响的区块范围 Moonbeam RT1201 RT2801 415946 - 5899847 Moonriver RT1201 RT2801 1471037 - 6411588 Moonbase Alpha RT1200 RT2801 1648994 - 6209638 <p>您可以查看 相关的 Frontier PR 和 GitHub 上的 Moonbeam PR 以获取更多信息。</p>"}, {"location": "builders/build/historical-updates/#skipped-ethereum-transaction-traces", "title": "跳过的以太坊交易追踪", "text": "<p>启用了 <code>evm-tracing</code> 功能的运行时引入了额外的 <code>ref_time</code> 开销，这是由于追踪以太坊交易的特殊逻辑（为每个组件发出事件：gasometer、runtime、EVM），用于填充 RPC 调用（如 <code>debug_traceTransaction</code> 和 <code>trace_filter</code>）的信息。</p> <p>由于生产运行时中的实际 <code>ref_time</code> 较小，这可能导致在 EVM 追踪运行时中重放区块时达到区块权重限制，从而导致跳过交易追踪。这在 Moonbeam 区块 9770044 中观察到。</p> <p>修复方法是在追踪每个以太坊交易之前重置先前消耗的权重。重要的是要注意，此问题仅影响 <code>evm-tracing</code> 下的代码，该代码未包含在任何生产运行时中。</p> <p>此错误已在以下运行时中修复：</p> 网络 已修复 受影响的区块 Moonbeam RT3501 9770044 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#notify-inactive-collator-fails", "title": "长时间不活跃的整理人通知失败问题", "text": "<p><code>notifyInactiveCollator</code> 外部函数旨在将最近两轮没有生成任何区块的整理人从池中移除，但对于已长时间不活跃的整理人，该函数执行失败。该交易仅在新一轮的前几个区块中才会成功。</p> <p>以下运行时和区块范围内存在此错误：</p> 网络 引入时间 修复时间 受影响的区块范围 Moonbase Alpha RT2601 RT3500 5474345 – 10750816 Moonriver RT2602 RT3501 5638536 – 10665393 Moonbeam RT2602 RT3501 4977160 – 10056989"}, {"location": "builders/build/historical-updates/#github-pr", "title": "有关更多信息，您可以查看 GitHub 上的相关 PR。", "text": ""}, {"location": "builders/build/historical-updates/#migrations", "title": "迁移", "text": "<p>当存储项目更改或添加并且需要填充数据时，迁移是必需的。下面列出的迁移已按受影响的 pallet(s) 组织。</p>"}, {"location": "builders/build/historical-updates/#author-mapping", "title": "作者映射 Pallet", "text": ""}, {"location": "builders/build/historical-updates/#update-mapping-storage-item", "title": "更新映射存储项", "text": "<p>此迁移更新了作者映射 pallet 中现已弃用的 <code>Mapping</code> 存储项，以使用更安全的哈希类型。哈希类型已更新为 Blake2_128Concat 而不是 Twox64Concat。</p> <p>此迁移仅应用于 Moonriver 和 Moonbase Alpha，并在以下运行时和区块中执行：</p> 网络 执行的运行时 应用的区块 Moonriver RT800 684728 Moonbase Alpha RT800 915684 <p>如需更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#add-support-for-vrf-keys", "title": "添加对 VRF 密钥的支持", "text": "<p>当引入 VRF 密钥支持时，作者映射 pallet 的 <code>MappingWithDeposit</code> 存储项已更新，以包含 <code>keys</code> 字段，从而支持可以通过 Nimbus ID 查找的 VRF 密钥。应用了一项迁移，以使用此新字段更新现有存储项。</p> <p>此迁移在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1502 1107285 Moonriver RT1502 1814458 Moonbase Alpha RT1502 2112058 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#one-nimbus-id-per-account-id", "title": "每个账户 ID 对应一个 Nimbus ID", "text": "<p>已应用迁移，以确保一个账户 ID 只能拥有一个 Nimbus ID。此迁移接受了给定账户拥有的第一个 Nimbus ID，并清除了与该账户关联的任何其他 Nimbus ID。对于任何已清除的关联，都会退还该关联的保证金。</p> <p>此迁移在以下运行时和区块中执行：</p> 网络 执行的运行时 应用区块 Moonbeam RT1606 1326697 Moonriver RT1605 2077599 Moonbase Alpha RT1603 2285347 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#base-fee", "title": "基本费用 Pallet", "text": ""}, {"location": "builders/build/historical-updates/#set-elasticity", "title": "设置弹性存储项值", "text": "<p>此迁移将基本费用 pallet 的 <code>Elasticity</code> 存储项设置为零，从而产生恒定的 <code>BaseFeePerGas</code>。</p> <p>此迁移在以下运行时和区块中执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1300 524762 Moonriver RT1300 1541735 Moonbase Alpha RT1300 1761128 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#preimage-preimage-pallet", "title": "Preimage 存储已移至新的 Preimage Pallet", "text": "<p>已应用迁移，该迁移将存储在 democracy pallet 中的 preimage 移动到新的 preimage pallet。由于 Polkadot 的上游更改，因此需要在 Moonbeam 上进行此迁移。</p> <p>Moonbeam 中有一个 preimage 受到了影响，该 preimage 从调度队列中删除且从未执行：<code>0x14262a42aa6ccb3cae0a169b939ca5b185bc317bb7c449ca1741a0600008d306</code>。此 preimage 已由最初提交该 preimage 的帐户手动删除。</p> <p>此迁移在以下运行时和区块中执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT2000 3310369 Moonriver RT2000 3202604 Moonbase Alpha RT2000 2673234 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#remove-gov-v1-collectives", "title": "移除 Governance V1 集體", "text": "<p>已應用遷移來移除 governance V1 集體，其中包括理事會和技術委員會。 governance V1 集體已替換為 OpenGov (governance V2) 技術委員會。</p> <p>此遷移在以下運行時和區塊中執行：</p> 網路 執行的運行時 應用的區塊 Moonbeam RT2801 5899847 Moonriver RT2801 6411588 Moonbase Alpha RT2801 6209638 <p>如需更多資訊，您可以查看 GitHub 上的相關 PR。</p> <p>需要進行後續遷移，以正確清除與 governance V1 集體關聯的存儲條目，該遷移在以下運行時和區塊中執行：</p> 網路 執行的運行時 應用的區塊 Moonbeam RT2901 6197065 Moonriver RT2901 6699589 Moonbase Alpha RT2901 6710531 <p>如需更多資訊，您可以查看 GitHub 上的相關 PR。</p>"}, {"location": "builders/build/historical-updates/#remove-gov-v1-collectives", "title": "移除 Governance V1 Democracy Pallet", "text": "<p>已应用迁移来删除与 governance V1 中使用的 Democracy Pallet 关联的存储。Democracy Pallet 已被 Preimage、Referenda 和 Collective Voting OpenGov (governance V2) 托盘取代。</p> <p>此迁移在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT2901 6197065 Moonriver RT2901 6699589 Moonbase Alpha RT2901 6710531 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#evm", "title": "EVM 合约元数据", "text": "<p>引入了一项迁移，以自动执行为两年前部署的合约设置 EVM 合约元数据的手动过程，这些合约在引入元数据存储项后未进行交互。此迁移取代了在这些合约上手动调用 <code>createContractMetadata(address)</code> 以使其与当前运行时兼容的需求。</p> <p>此迁移在以下运行时和区块执行：</p> Network Executed Runtime Block Applied Moonbeam RT3200 7985204 Moonriver RT3200 8519187"}, {"location": "builders/build/historical-updates/#remove-orbiter-minimum-bond", "title": "移除 Orbiter Collator 的最低保证金要求", "text": "<p>已将一个迁移应用到 Moonbeam Orbiter Pallet，该迁移将现有 orbiter collator 的保证金设置为零。此更改使未来的 orbiter 计划扩展能够实现均匀的支出。</p> <p>此迁移在以下运行时和区块中执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT2602 4977160 Moonriver RT2602 5638536 Moonbase Alpha RT2601 5474345 <p>如需了解更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#update-collator-state-storage-item", "title": "更新整理人状态存储项目", "text": "<p>已应用一项迁移，该迁移将平行链质押 pallet 的 <code>Collator</code> 存储项目更新为新的 <code>Collator2</code> 存储项目。此更改更新了整理人状态，以包括以下项目：</p> <ul> <li><code>nominators</code> 集是所有提名人（委托人）帐户 ID 的列表，不包括其各自的绑定余额</li> <li>新的 <code>top_nominators</code> 存储项目，返回所有顶级提名人的列表，按最大绑定金额到最小排序</li> <li>新的 <code>bottom_nominators</code> 存储项目，返回所有底部提名人的列表，按最小绑定金额到最大排序</li> <li><code>total</code> 存储项目已替换为 <code>total_counted</code> 和 <code>total_backing</code>。<code>total_counted</code> 项目返回顶级提名和整理人自绑定之和，而 <code>total_backing</code> 项目返回所有提名和整理人自绑定之和</li> </ul> <p>此迁移仅应用于 Moonriver 和 Moonbase Alpha，并在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonriver RT53 9696 Moonbase Alpha RT52 238827 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#patch-total-staked-amount", "title": "修复总质押金额", "text": "<p>由于一个潜在的错误可能导致金额不正确，因此对平行链 Staking Pallet 中 <code>CollatorState</code> 存储项的 <code>total</code> 质押金额应用了一项迁移。</p> <p>此迁移仅应用于 Moonriver 和 Moonbase Alpha，并在以下运行时和区块中执行：</p> 网络 执行的运行时 应用的区块 Moonriver RT53 9696 Moonbase Alpha RT52 238827 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#support-delayed-nominator-exits", "title": "支持延迟提名人 (Delegator) 退出", "text": "<p>用于处理候选人退出的退出队列已更新，包括支持延迟提名人（委托人）退出和撤销，这需要迁移以将 <code>ExitQueue</code> 平行链质押 pallet 存储项更新为 <code>ExitQueue2</code>。<code>NominatorState</code> 存储项也已迁移到 <code>NominatorState2</code>，以防止提名人在已经安排退出时执行更多提名。</p> <p>这些迁移仅应用于 Moonriver 和 Moonbase Alpha，并在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonriver RT200 259002 Moonbase Alpha RT200 457614 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#purge-staking-storage-bloat", "title": "清除 Staking 存储膨胀", "text": "<p>已应用迁移来清除平行链 Staking 托盘的 <code>Points</code> 和 <code>AtStake</code> 存储项中超过两轮的 Staking 存储膨胀。</p> <p>此迁移在以下运行时和区块中执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1001 5165 Moonriver RT1001 1052242 Moonbase Alpha RT1001 1285916 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#support-manual-exits-dpos-terminology", "title": "支持手动退出和 DPoS 术语", "text": "<p>Parachain 质押 pallet 已更新，包含手动退出。如果候选人或委托人想要减少或撤销他们的保证金或者离开候选人或委托人池，他们需要先安排一个请求，等待一段延迟期过去，然后手动执行请求。因此，应用了一个迁移来替换自动退出队列，包括 <code>ExitQueue2</code> 存储项，并使用手动退出 API。</p> <p>此外，还进行了一项更改，将提名权益证明 (NPoS) 切换为委托权益证明 (DPoS) 术语；这标志着从“提名”到“委托”的全面更改。这需要迁移以下 parachain 质押 pallet 存储项：</p> <ul> <li><code>CollatorState2</code> 迁移到 <code>CandidateState</code></li> <li><code>NominatorState2</code> 迁移到 <code>DelegatorState</code></li> </ul> <p>这些迁移在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1001 5165 Moonriver RT1001 1052242 Moonbase Alpha RT1001 1285916 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#increase-max-delegations-per-candidate", "title": "增加每个候选人的最大委托数", "text": "<p>已应用迁移来增加平行链质押 pallet 中每个候选人的最大委托数。它将 Moonbase Alpha 和 Moonriver 上的委托数从 100 增加到 500，并将 Moonbeam 上的委托数从 100 增加到 1000。</p> <p>此迁移在以下运行时和区块中执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1101 171061 Moonriver RT1101 1188000 Moonbase Alpha RT1100 1426319 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#split-candidate-delegations-top-bottom", "title": "将候选人委托拆分为顶部和底部", "text": "<p>此迁移将平行链质押 pallet 中已弃用的 <code>CandidateState</code> 存储项拆分为以下三个新的存储项，以避免不必要的存储读取：</p> <ul> <li><code>CandidateInfo</code></li> <li><code>TopDelegations</code></li> <li><code>BottomDelegations</code></li> </ul> <p>此迁移在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1201 415946 Moonriver RT1201 1471037 Moonbase Alpha RT1200 1648994 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#patch-incorrect-total-delegations", "title": "修复不正确的总委托数", "text": "<p>已应用迁移来修复不正确的排序器选择错误并修复所有候选人的委托总数。</p> <p>此迁移在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1300 524762 Moonriver RT1300 1541735 Moonbase Alpha RT1300 1761128 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#split-delegator-state", "title": "将委托人状态拆分为委托计划请求", "text": "<p>已应用一项迁移，该迁移将待处理的委托人请求从平行链质押 pallet 的 <code>DelegatorState</code> 存储项移动到新的 <code>DelegationScheduledRequests</code> 存储项中。</p> <p>此迁移在以下运行时和区块中执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1502 1107285 Moonriver RT1502 1814458 Moonbase Alpha RT1502 2112058 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#replace-staking-reserves", "title": "使用锁仓替换质押预留", "text": "<p>已应用一项迁移，将用户的质押预留余额更改为锁仓余额。锁仓余额与 democracy 锁定的资金类型相同，允许用户使用其质押的资金参与 democracy。</p> <p>此迁移在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1701 1581457 Moonriver RT1701 2281723 Moonbase Alpha RT1700 2529736 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#auto-compounding-support", "title": "自动复利支持", "text": "<p>为了支持自动复利，对平行链质押 pallet 中的 <code>AtStake</code> 存储项目应用了两个迁移：</p> <ul> <li><code>RemovePaidRoundsFromAtStake</code> - 用于删除与未产生任何区块的候选轮次已支付的轮次相关的任何陈旧的 <code>AtStake</code> 条目。此迁移是 <code>MigrateAtStakeAutoCompound</code> 迁移的先决条件</li> <li><code>MigrateAtStakeAutoCompound</code> - 迁移 <code>AtStake</code> 条目的未支付轮次的快照</li> </ul> <p>这些迁移在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1901 2317683 Moonriver RT1901 2911863 Moonbase Alpha RT1900 3069635 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#block-based-staking-rounds", "title": "切换到基于区块的抵押轮次", "text": "<p>已应用迁移，以从基于时间的抵押轮次切换到固定的基于区块的轮次。</p> <p>此迁移在以下运行时和区块中执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT2801 5899847 Moonriver RT2801 6411588 Moonbase Alpha RT2801 6209638 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#renaming-of-parachain-bond-reserve-events", "title": "重命名平行链 Bond 储备事件", "text": "<p>在 Runtime 3300 之前，每个回合都会发出一次 <code>ReservedForParachainBond</code> 事件，以指示通过通货膨胀为平行链 Bond 储备金提供资金。在 Runtime 3300 中，此同一事件已重命名为 <code>InflationDistributed</code>。</p> <p>此更改在以下运行时和区块中生效：</p> 网络 执行的运行时 应用的区块 Moonbeam RT3300 8381443 Moonriver RT3300 8894417 Moonbase Alpha RT3300 9062316 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#parachainstaking-currency-to-fungible", "title": "ParachainStaking：货币 → 同质化代币迁移", "text": "<p>已应用迁移，将 <code>ParachainStaking</code> pallet 从已弃用的 Currency 特征迁移到现代 Fungible 特征。在操作上，staking“锁”已替换为余额“冻结”：先前使用标识符 [<code>stkngcol</code>, <code>stkngdel</code>]读取 <code>Balances.Locks</code> 的查询现在必须使用冻结原因 [<code>StakingCollator</code>, <code>StakingDelegator</code>]读取 <code>Balances.Freezes</code>。<code>System.Account</code> 中显示的冻结余额在此迁移中未更改。</p> <p>此迁移在以下运行时和区块上执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT4000 - Moonriver RT4000 - Moonbase Alpha RT4000 14191989"}, {"location": "builders/build/historical-updates/#refunds-for-submission-deposits", "title": "提交保证金退款", "text": "<p>引入了一项迁移，以支持对已关闭的全民投票的提交保证金进行退款，该全民投票更新了 <code>ReferendumInfo</code> 类型。<code>ReferendumInfo</code> 的以下不变性已更改，以便第二个参数 <code>Deposit&lt;AccountId, Balance&gt;</code> 现在是可选的 <code>Option&lt;Deposit&lt;AccountId, Balance&gt;&gt;</code>：<code>Approved</code>、<code>Rejected</code>、<code>Cancelled</code> 和 <code>TimedOut</code>。</p> <p>这源于对 Substrate 存储库的上游更改。</p> <p>此迁移在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT2302 3456477 Moonriver RT2302 4133065 Moonbase Alpha RT2301 4172407 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#referenda", "title": "恢复损坏的 Referenda 保证金", "text": "<p>引入了一项迁移，以支持恢复受损坏存储值影响的 referenda 保证金。当由于 pallet 版本错误而导致迁移应用两次时，就会出现此问题，从而导致无效值和不可退还的提交保证金。由于要更正的值的数量是有限且较小的，因此此迁移创建了一个列表以手动更新它们。</p> <p>此迁移仅应用于 Moonbeam，并在以下运行时和区块中执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT3100 7303601"}, {"location": "builders/build/historical-updates/#xcm-related-pallets", "title": "XCM 相关 Pallets", "text": ""}, {"location": "builders/build/historical-updates/#update-transaction-info", "title": "更新交易信息存储项", "text": "<p>XCM 交易器 Pallet 的 <code>TransactInfo</code> 存储项已应用迁移，更改了以下项目：</p> <ul> <li>添加了 <code>max_weight</code>，以防止交易人在目标链中阻塞队列</li> <li>删除了 <code>fee_per_byte</code>、<code>metadata_size</code> 和 <code>base_weight</code>，因为这些项目对于 XCM 交易不是必需的</li> <li><code>fee_per_second</code> 替换了 <code>fee_per_weight</code>，以更好地反映 <code>fee_per_weight</code> 单位低于 1 的情况（如 Kusama）</li> </ul> <p>此迁移在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1201 415946 Moonriver RT1201 1471037 Moonbase Alpha RT1200 1648994 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#add-support-statemine-prefix", "title": "添加对 Kusama Asset Hub (Statemine) 前缀重大更改的支持", "text": "<p>资产管理器 pallet 中添加了以下三个迁移，以避免 Kusama Asset Hub（之前称为 Statemine）对其资产表示方式的重大更改 以及未来可能发生的重大更改导致的问题：</p> <ul> <li><code>UnitsWithAssetType</code> - 将 <code>AssetTypeUnitsPerSecond</code> 存储项目更新为 <code>AssetType</code> 到 <code>units_per_second</code> 的映射，而不是 <code>AssetId</code> 到 <code>units_per_second</code> 的映射。这样做是为了避免在发生重大更改时进行额外的迁移</li> <li><code>PopulateAssetTypeIdStorage</code> - 创建一个新的 <code>AssetTypeId</code> 存储项目，该项目保存 <code>AssetType</code> 到 <code>AssetId</code> 的映射，从而可以将 <code>assetIds</code> 和 <code>AssetTypes</code> 解耦</li> <li><code>ChangeStateminePrefixes</code> - 将已注册的 Kusama Asset Hub (Statemine) 资产更新为其新形式</li> </ul> <p>这些迁移在以下运行时和区块中执行：</p> Network Executed Runtime Block Applied Moonbeam RT1201 415946 Moonriver RT1201 1471037 Moonbase Alpha RT1200 1648994 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#add-supported-fee-payment-assets", "title": "添加新支持的费用支付资产存储项目", "text": "<p>已将迁移应用到资产管理器 pallet，通过从 <code>AssetTypeUnitsPerSecond</code> 存储项目中读取支持的资产数据来创建新的 <code>SupportedFeePaymentAssets</code> 存储项目。此存储项目将保存我们接受的所有用于 XCM 费用支付的资产。当收到传入的 XCM 消息时，将读取该存储项目，如果资产不在存储中，则不会处理该消息。</p> <p>此迁移在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1300 524762 Moonriver RT1300 1541735 Moonbase Alpha RT1300 1761128 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#update-xcm-transactor", "title": "将 XCM 交易器存储从 V2 更新到 V3", "text": "<p>在 XCM V3 的支持下，应用了一个迁移来更新 XCM 交易器 pallet 的存储，从 XCM V2 更新到 V3。<code>transactInfoWithWeightLimit</code> 和 <code>destinationAssetFeePerSecond</code> 存储项已更新，以支持 XCM V3 多重定位。</p> <p>此迁移在以下运行时和区块中执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT2302 3456477 Moonriver RT2302 4133065 Moonbase Alpha RT2301 4172407 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#remove-local-assets", "title": "删除可铸造的 XC-20", "text": "<p>可铸造的 XC-20 已被弃用，转而支持启用 XCM 的 ERC-20；因此，应用了一个迁移来删除本地资产 pallet 并清除存储中的资产。</p> <p>此迁移在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT2801 5899847 Moonriver RT2801 6411588 Moonbase Alpha RT2801 6209638 <p>有关更多信息，您可以查看 GitHub 上的相关 PR。</p>"}, {"location": "builders/build/historical-updates/#foreign-assets-migration", "title": "通过智能合约管理外部资产", "text": "<p>已应用迁移，将现有外部资产转换为新设计，该设计通过 EVM 智能合约在 Moonbeam 上管理 XCM 衍生资产，而不是之前使用资产和资产管理器 Pallet 的实现。迁移过程涉及 Moonbeam Lazy Migration Pallet 中的几个 extrinsic：</p> <ul> <li><code>approve_assets_to_migrate</code> - 设置批准迁移的资产 ID 列表</li> <li><code>start_foreign_asset_migration</code> - 通过冻结原始资产并创建新的 EVM 智能合约来启动特定外部资产的迁移</li> <li><code>migrate_foreign_asset_balances</code> - 将资产余额分批从旧资产 Pallet 迁移到新系统</li> <li><code>migrate_foreign_asset_approvals</code> - 在取消预留旧批准系统的存款时，分批迁移资产批准</li> <li><code>finish_foreign_asset_migration</code> - 在迁移所有余额和批准后完成迁移，并执行最终清理</li> </ul> <p>此迁移通过使用与之前相同的 AssetID 整数识别每个外部资产，从而保持与现有外部资产的兼容性。此迁移在以下运行时和区块中执行：</p> 网络 执行运行时 应用区块 Moonbeam RT3501 10056989 Moonriver RT3501 10665393 Moonbase Alpha RT3500 10750816 <p>有关更多信息，您可以在 GitHub 上查看相关的 PR：2869 和 3020。</p>"}, {"location": "builders/build/historical-updates/#nimbus", "title": "Nimbus 作者过滤器托盘", "text": ""}, {"location": "builders/build/historical-updates/#replace-eligible-ratio", "title": "将合格率替换为合格计数", "text": "<p>Nimbus 存储库应用了一项重大更改，弃用了 <code>EligibleRatio</code>，转而使用 <code>EligibleCount</code> 配置。因此，在 Moonbeam 存储库上应用了迁移，如果存在 <code>EligibleRatio</code> 值，则将新的 <code>EligibleCount</code> 值填充为在该区块高度定义的潜在作者的百分比。否则，该值将设置为默认值 <code>50</code>。</p> <p>此迁移在以下运行时和区块执行：</p> 网络 执行的运行时 应用的区块 Moonbeam RT1502 1107285 Moonriver RT1502 1814458 Moonbase Alpha RT1502 2112058 <p>有关更多信息，您可以查看相关的 Nimbus PR 和 GitHub 上的 Moonbeam PR。</p>"}, {"location": "builders/build/runtime-upgrades/", "title": "运行时升级", "text": ""}, {"location": "builders/build/runtime-upgrades/#introduction", "title": "简介", "text": "<p>Moonbeam 运行时升级允许维护和发展链逻辑，而无需硬分叉。这些运行时升级可以引入新功能、提高性能、修复错误并响应不断变化的需求。</p> <p>本页提供了基于 Moonbeam 的每个网络的按区块运行时升级的历史记录。</p>"}, {"location": "builders/ethereum/canonical-contracts/", "title": "规范合约", "text": ""}, {"location": "builders/ethereum/canonical-contracts/#common-goods-contracts", "title": "公共利益合约", "text": "<p>已建立以下合约地址：</p> Moonbeam 合约 地址 WGLMR 0xAcc15dC74880C9944775448304B263D191c6077F Multicall 0x83e3b61886770de2F64AAcaD2724ED4f08F7f36B Multicall2 0x6477204E12A7236b9619385ea453F370aD897bb2 Multicall3 0xcA11bde05977b3631167028862bE2a173976CA11 Multisig Factory 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2 EIP-1820 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24 Moonriver 合约 地址 WMOVR 0x98878B06940aE243284CA214f92Bb71a2b032B8A Multicall* 0x30f283Cc0284482e9c29dFB143bd483B5C19954b Multicall2 0xaef00a0cf402d9dedd54092d9ca179be6f9e5ce3 Multicall3 0xcA11bde05977b3631167028862bE2a173976CA11 Multisig Factory 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2 EIP-1820 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24 <pre><code>_*由 SushiSwap 部署_\n</code></pre> Moonbase Alpha 合约 地址 WDEV 0xD909178CC99d318e4D46e7E66a972955859670E1 Multicall* 0x4E2cfca20580747AdBA58cd677A998f8B261Fc21 Multicall2 0x37084d0158C68128d6Bc3E5db537Be996f7B6979 Multicall3 0xcA11bde05977b3631167028862bE2a173976CA11 Multisig Factory 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2 EIP-1820 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24 <pre><code>_*部署在 [UniswapV2 Demo Repo](https://github.com/papermoonio/moonbeam-uniswap/tree/main/uniswap-contracts-moonbeam){target=\\_blank} 中_\n</code></pre>"}, {"location": "builders/ethereum/canonical-contracts/#precompiled-contracts", "title": "预编译合约", "text": "<p>Moonbeam、Moonriver 和 Moonbase Alpha 上包含一组预编译合约，这些合约按地址分类并基于原始网络。如果您要将预编译地址转换为十进制格式，并按数值将它们分为几类，则这些类别如下：</p> <ul> <li>0-1023 - 以太坊主网预编译</li> <li>1024-2047 - 不在以太坊中且不是 Moonbeam 特定的预编译</li> <li>2048-4095 - Moonbeam 特定的预编译</li> </ul>"}, {"location": "builders/ethereum/canonical-contracts/#moonbeam-specific-precompiles", "title": "Moonbeam特定预编译", "text": "MoonbeamMoonriver 合约 地址 平行链质押 0x0000000000000000000000000000000000000800 ERC-20 接口 0x0000000000000000000000000000000000000802 民主 [已移除] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 中继编码器 0x0000000000000000000000000000000000000805 XCM 交易器 V1 0x0000000000000000000000000000000000000806 作者映射 0x0000000000000000000000000000000000000807 批量处理 0x0000000000000000000000000000000000000808 随机性 0x0000000000000000000000000000000000000809 调用许可 0x000000000000000000000000000000000000080a 代理 0x000000000000000000000000000000000000080b XCM 实用程序 0x000000000000000000000000000000000000080C XCM 交易器 V2 0x000000000000000000000000000000000000080d 理事会集体 [已移除] 0x000000000000000000000000000000000000080e 技术委员会集体 [已移除] 0x000000000000000000000000000000000000080f 财务委员会集体 0x0000000000000000000000000000000000000810 公民投票 0x0000000000000000000000000000000000000811 确信投票 0x0000000000000000000000000000000000000812 预映像 0x0000000000000000000000000000000000000813 OpenGov 技术委员会 0x0000000000000000000000000000000000000814 预编译注册表 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM 交易器 V3 0x0000000000000000000000000000000000000817 身份 0x0000000000000000000000000000000000000818 XCM 接口 0x000000000000000000000000000000000000081A 合约 地址 平行链质押 0x0000000000000000000000000000000000000800 ERC-20 接口 0x0000000000000000000000000000000000000802 民主 [已移除] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 中继编码器 0x0000000000000000000000000000000000000805 XCM 交易器 V1 0x0000000000000000000000000000000000000806 作者映射 0x0000000000000000000000000000000000000807 批量处理 0x0000000000000000000000000000000000000808 随机性 0x0000000000000000000000000000000000000809 调用许可 0x000000000000000000000000000000000000080a 代理 0x000000000000000000000000000000000000080b XCM 实用程序 0x000000000000000000000000000000000000080C XCM 交易器 V2 0x000000000000000000000000000000000000080d 理事会集体 [已移除] 0x000000000000000000000000000000000000080e 技术委员会集体 [已移除] 0x000000000000000000000000000000000000080f 财务委员会集体 0x0000000000000000000000000000000000000810 公民投票 0x0000000000000000000000000000000000000811 确信投票 0x0000000000000000000000000000000000000812 预映像 0x0000000000000000000000000000000000000813 OpenGov 技术委员会 0x0000000000000000000000000000000000000814 预编译注册表 0x0000000000000000000000000000000000000815 [GMP](https://github.com/moonbeam-foundation/moonbeam/blob/master/precomp"}, {"location": "builders/ethereum/dev-env/foundry/", "title": "使用 Foundry 部署到 Moonbeam", "text": ""}, {"location": "builders/ethereum/dev-env/foundry/#introduction", "title": "简介", "text": "<p>Foundry 是一个用 Rust 编写的以太坊开发环境，可帮助开发人员管理依赖项、编译项目、运行测试、部署合约以及从命令行与区块链进行交互。Foundry 可以直接与 Moonbeam 的以太坊 API 交互，因此可用于将智能合约部署到 Moonbeam 中。</p> <p>Foundry 由四个工具组成：</p> <ul> <li>Forge - 编译、测试和部署合约</li> <li>Cast - 用于与合约交互的命令行界面</li> <li>Anvil - 用于开发目的的本地 TestNet 节点，可以 Fork 预先存在的网络</li> <li>Chisel - 一个 Solidity REPL，用于快速测试 Solidity 代码片段</li> </ul> <p>本指南将介绍如何使用 Foundry 在 Moonbase Alpha 测试网上编译、部署和调试以太坊智能合约。本指南也适用于 Moonbeam、Moonriver 或 Moonbeam 开发节点。</p>"}, {"location": "builders/ethereum/dev-env/foundry/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要开始，您将需要以下内容：</p> <ul> <li>拥有一个有资金的帐户。</li> </ul> <p>You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</p> <ul> <li> <p>--8&lt;-- 'text/_common/endpoint-examples-list-item.md'</p> </li> <li> <p>安装了Foundry</p> </li> </ul>"}, {"location": "builders/ethereum/dev-env/foundry/#creating-a-foundry-project", "title": "创建 Foundry 项目", "text": "<p>如果还没有 Foundry 项目，您需要创建一个。 您可以通过完成以下步骤来创建一个：</p> <ol> <li> <p>如果您还没有安装 Foundry，请安装它。 如果在 Linux 或 MacOS 上，您可以运行以下命令：</p> <pre><code>curl -L https://foundry.paradigm.xyz | bash\nfoundryup\n</code></pre> <p>如果在 Windows 上，您必须先安装 Rust，然后从源代码构建 Foundry：</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs/ | sh\ncargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked\n</code></pre> </li> <li> <p>创建项目，这将创建一个包含三个文件夹的文件夹，并打开它：</p> <pre><code>forge init foundry &amp;&amp; cd foundry\n</code></pre> </li> </ol> <p>创建默认项目后，您应该看到三个文件夹。</p> <ul> <li><code>lib</code> - 项目的所有依赖项，以 git 子模块的形式存在</li> <li><code>src</code> - 放置智能合约（带有功能）的位置</li> <li><code>test</code> - 放置项目的 forge 测试的位置，这些测试是用 Solidity 编写的</li> </ul> <p>除了这三个文件夹之外，还将创建一个 git 项目，以及一个预先编写的 <code>.gitignore</code> 文件，其中忽略了相关的文件类型和文件夹。</p>"}, {"location": "builders/ethereum/dev-env/foundry/#deploying-the-contract", "title": "部署合约", "text": "<p>使用 Foundry 部署合约主要有两种方式。第一种是直接使用命令 <code>forge create</code>。还有一种更灵活、更强大的方式是使用 Foundry 脚本，它可以在部署前运行模拟。在以下章节中，将介绍 <code>forge create</code> 和 Foundry 脚本。</p>"}, {"location": "builders/ethereum/dev-env/foundry/#using-forge-create", "title": "使用 Forge Create", "text": "<p>在部署之前，您需要通过导入您的私钥来设置您的密钥库。您可以使用 <code>cast wallet import</code> 命令，如下所示：</p> <pre><code>cast wallet import deployer --interactive\n</code></pre> <p>这将提示您：</p> <ol> <li>输入您的私钥</li> <li>输入密码以加密密钥库</li> </ol> <p>该帐户将以“deployer”的名称保存在您的密钥库中。然后，您可以在部署命令中使用此帐户名。在部署合约或发送交易时，系统将提示您输入密钥库密码。</p> <p>使用 <code>forge create</code> 部署合约只需要一个命令，但您必须包含 RPC 端点和构造函数参数。<code>MyToken.sol</code> 在其构造函数中要求提供初始令牌供应量，因此以下每个命令都包含 100 作为构造函数参数。 您可以使用以下命令为正确的网络部署 <code>MyToken.sol</code> 合约：</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>forge create src/MyToken.sol:MyToken \\\n--rpc-url INSERT_RPC_API_ENDPOINT \\\n--broadcast \\\n--account deployer \\\n--constructor-args 100\n</code></pre> <pre><code>forge create src/MyToken.sol:MyToken \\\n--rpc-url INSERT_RPC_API_ENDPOINT \\\n--broadcast \\\n--account deployer \\\n--constructor-args 100\n</code></pre> <pre><code>forge create src/MyToken.sol:MyToken \\\n--rpc-url https://rpc.api.moonbase.moonbeam.network \\\n--broadcast \\\n--account deployer \\\n--constructor-args 100\n</code></pre> <pre><code>forge create src/MyToken.sol:MyToken \\\n--rpc-url http://127.0.0.1:9944 \\\n--broadcast \\\n--account deployer \\\n--constructor-args 100\n</code></pre> <p>部署合约并在几秒钟后，您应该在终端中看到该地址。</p> forge create src/MyToken.sol:MyToken \\ --rpc-url https://rpc.api.moonbase.moonbeam.network \\ --account deployer \\ --constructor-args 100 [⠒] Compiling... No files changed, compilation skipped Deployer: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Deployed to: 0xc111402Aa1136ff6224106709ae51864512eC68f Transaction hash: 0xd77fc26aa296e81f35718b5878cda98e8371f6bf33b0f57e7d92997a36cf6465 <p>恭喜！您的合约已上线！保存该地址，您将在下一步中使用它与此合约实例进行交互。</p>"}, {"location": "builders/ethereum/dev-env/foundry/#interacting-with-the-contract", "title": "与合约交互", "text": "<p>Foundry 包含 cast，这是一个用于执行以太坊 RPC 调用的 CLI。</p> <p>尝试使用 Cast 检索您的令牌名称，其中 <code>INSERT_YOUR_CONTRACT_ADDRESS</code> 是您在上一节中部署的合约的地址：</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url https://rpc.api.moonbase.moonbeam.network\n</code></pre> <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url http://127.0.0.1:9944\n</code></pre> <p>您应该以十六进制格式获取此数据：</p> <p>text 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000</p> <p>这远非可读，但您可以使用 Cast 将其转换为所需的格式。 在这种情况下，数据是文本，因此您可以将其转换为 ASCII 字符以查看“My Token”：</p> cast --to-ascii 0x000000000000000000000000000000000000000000000000000000000000002000     000000000000000000000000000000000000000000000000000000000000074d7954     6f6b656e00000000000000000000000000000000000000000000000000  MyToken <pre><code>cast --to-ascii 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000\n</code></pre> <p>您也可以使用 cast 改变数据。 尝试通过将令牌发送到零地址来销毁令牌。</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n  --rpc-url INSERT_RPC_API_ENDPOINT \\\n  --chain 1284 \\\n  INSERT_YOUR_CONTRACT_ADDRESS \\\n  \"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n  --rpc-url INSERT_RPC_API_ENDPOINT \\\n  --chain 1285 \\\n  INSERT_YOUR_CONTRACT_ADDRESS \\\n  \"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n  --rpc-url https://rpc.api.moonbase.moonbeam.network \\\n  --chain 1287 \\\n  INSERT_YOUR_CONTRACT_ADDRESS \\\n  \"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n  --rpc-url http://127.0.0.1:9944 \\\n  --chain 1281 \\\n  INSERT_YOUR_CONTRACT_ADDRESS \\\n  \"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <p>该事务将由您的 Moonbase 帐户签名并广播到网络。 输出应类似于：</p> cast send --private-key INSERT_PRIVATE_KEY \\ --rpc-url https://rpc.api.moonbase.moonbeam.network \\ --chain 1287 \\ INSERT_CONTRACT_ADDRESS \\ \"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1 blockHash               0x6f99fac1bb49feccb7b0476e0ffcd3cef4c456aa9111e193ce11c7a1ab62314e blockNumber             5892860 contractAddress cumulativeGasUsed       51332 effectiveGasPrice       3125000000 gasUsed                 51332 logs                    [{\"address\":\"0xc111402aa1136ff6224106709ae51864512ec68f\",\"topics\":[\"0xddf252ad1be2c89b69     c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",     \"0x0000000000000000000000003b939fead155     7c741ff06492fd0127bd287a421e\",     \"0x0000000000000000000000000000000000000000000000000000000000000001\"],     \"data\":\"0x0000000000000000000000000000000000000     000000000000000000000000001\",     \"blockHash\":\"0x6f99fac1bb49feccb7b0476e0ffcd3cef4c4     56aa9111e193ce11c7a1ab62314e\",     \"blockNumber\":\"0x59eafc\",     \"transactionHash\":\"0xdd5f11be68d5     2967356ccf34b9a4b2632d0d5ac8932ff27e72c544320dec33e3\",     \"transactionIndex\":\"0x0\",\"logIndex\":\"0x0\",\"transactionLogIndex\":\"0x0\",\"removed\":false}] logsBloom               0x000000000000000000000000000000000000000000000000000000000000000000000000000000004     00000000000000000000000000000000000000000040000000000000000000000000008000000000000     00000004000000000000000000000000000000000000000100000000000000000000000000000000001     00000010000000000000000000000000000000000000000000000000000000002000000040000000000     00000000000000000000000000000000000000000000000000000000002000000000000000000000000     00000000000000000000000000004000000000000000000000000000000000000000000000000000000     0001000000 root status                  1 transactionHash         0xdd5f11be68d52967356ccf34b9a4b2632d0d5ac8932ff27e72c544320dec33e3 transactionIndex        0 type                    2 <p>恭喜，您已使用 Foundry 成功部署并与合约交互！</p>"}, {"location": "builders/ethereum/dev-env/foundry/#forking-with-cast-anvil", "title": "使用 Anvil 进行 Fork", "text": "<p>如前所述，Anvil 是一个用于开发目的的本地 TestNet 节点，可以 fork 预先存在的网络。Fork Moonbeam 允许您与部署在网络上的实时合约进行交互。</p> <p>使用 Anvil 进行 fork 时，需要注意一些限制。由于 Anvil 基于 EVM 实现，因此您无法与任何 Moonbeam 预编译合约及其功能进行交互。预编译是 Substrate 实现的一部分，因此无法在模拟的 EVM 环境中复制。这禁止您与 Moonbeam 上的跨链资产以及基于 Substrate 的功能（如质押和治理）进行交互。</p> <p>要 fork Moonbeam 或 Moonriver，您需要拥有自己的端点和 API 密钥，您可以从支持的端点提供商之一处获得。</p> <p>要从命令行 fork Moonbeam，您可以从 Foundry 项目目录中运行以下命令：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>anvil --fork-url INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>anvil --fork-url INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>anvil --fork-url https://rpc.api.moonbase.moonbeam.network\n</code></pre> <p>您的 fork 实例将拥有 10 个预先注资 10,000 个测试 token 的开发账户。fork 实例可在 <code>http://127.0.0.1:8545/</code> 上使用。终端中的输出应类似于以下内容：</p> anvil --fork-url https://rpc.api.moonbase.moonbeam.network Available Accounts ================== (0) \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\" (10000.000000000000000000 ETH) (1) \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\" (10000.000000000000000000 ETH) (2) \"0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC\" (10000.000000000000000000 ETH) (3) \"0x90F79bf6EB2c4f870365E785982E1f101E93b906\" (10000.000000000000000000 ETH) (4) \"0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65\" (10000.000000000000000000 ETH) (5) \"0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc\" (10000.000000000000000000 ETH) (6) \"0x976EA74026E726554dB657fA54763abd0C3a0aa9\" (10000.000000000000000000 ETH) (7) \"0x14dC79964da2C08b23698B3D3cc7Ca32193d9955\" (10000.000000000000000000 ETH) (8) \"0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f\" (10000.000000000000000000 ETH) (9) \"0xa0Ee7A142d267C1f36714E4a8F75612F20a79720\" (10000.000000000000000000 ETH) Private Keys ================== (0) 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 (1) 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d (2) 0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a (3) 0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6 (4) 0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a (5) 0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba (6) 0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e (7) 0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356 (8) 0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97 (9) 0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6 Wallet ================== Mnemonic: test test test test test test test test test test test junk Derivation path: m/44'/60'/0'/0/ Fork ================== Endpoint: https://rpc.api.moonbase.moonbeam.network Block number: 5892944 Block hash: 0xc9579299f55d507c305d5357d4c1b9d9c550788ddb471b0231d8d0146e7144b7 Chain ID: 1287 Base Fee ================== 125000000 Gas Limit ================== 30000000 Genesis Timestamp ================== 1705278817 Listening on 127.0.0.1:8545 <p>要验证您是否已 fork 网络，可以查询最新的区块号：</p> <pre><code>curl --data '{\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}' -H \"Content-Type: application/json\" -X POST localhost:8545 \n</code></pre> <p>如果您将 <code>result</code> 从 十六进制转换为十进制，您应该获得从您 fork 网络时开始的最新区块号。您可以使用 区块浏览器 交叉引用区块号。</p> <p>从这里，您可以将新合约部署到您的 Moonbeam fork 实例，或者与已经部署的合约进行交互。在此指南的前一个示例的基础上，您可以使用 Cast 进行调用，以检查您部署合约的账户中已铸造的 MYTOK token 的余额：</p> <pre><code>cast call INSERT_CONTRACT_ADDRESS  \"balanceOf(address)(uint256)\" INSERT_YOUR_ADDRESS --rpc-url http://localhost:8545\n</code></pre>"}, {"location": "builders/ethereum/dev-env/hardhat/", "title": "使用 Hardhat 部署到 Moonbeam", "text": ""}, {"location": "builders/ethereum/dev-env/hardhat/#introduction", "title": "简介", "text": "<p>Hardhat 是一个灵活且可扩展的以太坊开发环境，可以简化智能合约的开发过程。由于 Moonbeam 与以太坊兼容，因此您可以使用 Hardhat 在 Moonbeam 上开发和部署智能合约。</p> <p>Hardhat 采用基于任务的开发方法，您可以在其中定义和执行任务，以执行特定操作。这些操作包括编译和部署合约、运行测试等等。任务是高度可配置的，因此您可以创建、自定义和执行适合您需求的任务。</p> <p>您还可以通过使用插件来扩展 Hardhat 的功能。插件是与 Hardhat 集成的外部扩展，可为您的工作流程提供额外的功能和工具。例如，有一些用于常见以太坊库的插件，例如 Ethers.js 和 viem，一个扩展 Chai 断言库以包含以太坊特定功能的插件等等。所有这些插件都可用于扩展您在 Moonbeam 上的 Hardhat 项目。</p> <p>本指南将简要介绍 Hardhat，并向您展示如何使用 Hardhat 在 Moonbase Alpha 测试网上编译、部署和调试以太坊智能合约。本指南也适用于 Moonbeam、Moonriver 或 Moonbeam 开发节点。以下内容针对的是 Hardhat 3（当前版本：3.0.17）。</p> <p>请注意，虽然 Hardhat 附带一个 Hardhat Network 组件，该组件提供本地开发环境，但您应该改用本地 Moonbeam 开发节点。您可以像连接任何其他网络一样，将 Moonbeam 开发节点连接到 Hardhat。</p>"}, {"location": "builders/ethereum/dev-env/hardhat/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要开始，您需要以下内容：</p> <ul> <li>拥有 Node.js 22.10.0 或更高版本（Hardhat 3 仅支持偶数编号的 LTS 版本）和 npm</li> <li>已安装MetaMask并连接到Moonbase Alpha。</li> <li>拥有一个有资金的帐户。   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>--8&lt;-- 'text/_common/endpoint-examples-list-item.md'</li> </ul>"}, {"location": "builders/ethereum/dev-env/hardhat/#creating-a-hardhat-project", "title": "创建 Hardhat 项目", "text": "<p>如果您还没有 Hardhat 项目，您需要创建一个。您可以通过完成以下步骤来创建一个：</p> <ol> <li> <p>为您的项目创建一个目录。</p> <pre><code>mkdir hardhat &amp;&amp; cd hardhat\n</code></pre> </li> <li> <p>初始化项目，这将创建一个 <code>package.json</code> 文件。</p> <pre><code>npm init -y\n</code></pre> </li> <li> <p>安装 Hardhat。</p> <pre><code>npm install --save-dev hardhat\n</code></pre> </li> <li> <p>创建一个 Hardhat 项目。</p> <pre><code>npx hardhat --init\n</code></pre> <p>Note</p> <p><code>npx</code> 用于运行本地安装在项目中的可执行文件。虽然 Hardhat 可以全局安装，但建议在每个项目中本地安装，以便您可以按项目控制版本。</p> </li> <li> <p>系统将提示您一系列问题来设置您的项目：</p> <ul> <li>选择 Hardhat 3 Beta (推荐用于新项目) 而不是 Hardhat 2。</li> <li>选择初始化项目的位置（默认为当前目录）。</li> <li>确认转换为 ESM（Hardhat v3 需要）。</li> <li>选择要初始化的项目类型：<ul> <li>一个使用 Node Test Runner 和 viem 的 TypeScript Hardhat 项目</li> <li>一个使用 Mocha 和 Ethers.js 的 TypeScript Hardhat 项目</li> </ul> </li> </ul> <p>对于此示例，您可以根据自己的偏好选择任一选项。如果您选择 Mocha 和 Ethers.js 选项，您将获得一个具有以下结构的项目：</p> <ul> <li><code>contracts/Counter.sol</code> 中的示例合约</li> <li><code>test/Counter.ts</code> 中的测试文件</li> <li>TypeScript 配置</li> <li>Mocha 和 Ethers.js 依赖项</li> </ul> <p>该项目将设置为所有必要的依赖项和配置，以便您可以开始开发。</p> </li> </ol> npx hardhat init 888    888                      888 888               888 888    888                      888 888               888 888    888                      888 888               888 8888888888  8888b.  888d888 .d88888 88888b.   8888b.  888888 888    888     \"88b 888P\"  d88\" 888 888 \"88b     \"88b 888 888    888 .d888888 888    888  888 888  888 .d888888 888 888    888 888  888 888    Y88b 888 888  888 888  888 Y88b. 888    888 \"Y888888 888     \"Y88888 888  888 \"Y888888  \"Y888 👷 Welcome to Hardhat v3.0.17 👷‍  Which version of Hardhat would you like to use? …  Hardhat 3 Beta (recommended for new projects)   Hardhat 2 (older version)  Where would you like to initialize the project?  .  Hardhat only supports ESM projects. Would you like to change \"package.json\" to turn your project into ESM? (Y/n) · true  What type of project would you like to initialize? …   A TypeScript Hardhat project using Node Test Runner and Viem  A TypeScript Hardhat project using Mocha and Ethers.js"}, {"location": "builders/ethereum/dev-env/hardhat/#hardhat-configuration-file", "title": "Hardhat 配置文件", "text": "<p>Hardhat 配置文件是进入 Hardhat 项目的入口点。它定义了 Hardhat 项目的各种设置和选项，例如要使用的 Solidity 编译器版本以及可以将合约部署到的网络。</p> <p>如果您正在使用 JavaScript，请在您的 <code>package.json</code> 中保留 <code>\"type\": \"module\"</code>。一个最小的 <code>hardhat.config.js</code> 看起来像这样：</p> <pre><code>import { defineConfig } from 'hardhat/config';\n\nexport default defineConfig({\n  solidity: '0.8.28',\n});\n</code></pre> <p>如果您选择了 TypeScript 模板，则该文件将为 <code>hardhat.config.ts</code>，并且配置内容将相同。对于此示例，您可以将 Solidity 编译器版本保持在 <code>0.8.28</code>；但是，如果您正在使用需要更高版本的合约，请不要忘记在此处更新它。</p> <p>如果您的项目模板未添加本指南中使用的插件和库，请安装它们：</p> <pre><code>npm install --save-dev @nomicfoundation/hardhat-ethers @nomicfoundation/hardhat-ignition-ethers @nomicfoundation/hardhat-keystore ethers\n</code></pre> <p>接下来，您需要修改您的配置文件以添加要将合约部署到的网络的网络配置。对于 Moonbeam 网络，您需要指定以下内容：</p> <ul> <li><code>url</code>: 节点的 RPC 端点。</li> <li><code>chainId</code>: 链 ID，用于验证网络。</li> <li><code>accounts</code>: 可用于部署和与合约交互的帐户。您可以输入帐户私钥的数组，也可以使用 HD 钱包。</li> <li><code>type</code>: 对于 Moonbeam 上的外部 RPC 网络，请设置 <code>type: 'http'</code>。</li> <li><code>chainType</code>: 对于 Moonbeam 网络，请设置 <code>chainType: 'l1'</code>。</li> </ul> <p>Hardhat 通过 <code>@nomicfoundation/hardhat-keystore</code> 插件包含一个加密的密钥管理器，它可以将敏感数据保存在源代码控制之外。安装并导入插件后，使用密钥库设置您的密钥：</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev <pre><code>npx hardhat keystore set MOONBEAM_RPC_URL\nnpx hardhat keystore set MOONBEAM_PRIVATE_KEY\n</code></pre> <pre><code>npx hardhat keystore set MOONRIVER_RPC_URL\nnpx hardhat keystore set MOONRIVER_PRIVATE_KEY\n</code></pre> <pre><code>npx hardhat keystore set MOONBASE_RPC_URL\nnpx hardhat keystore set MOONBASE_PRIVATE_KEY\n</code></pre> <pre><code>npx hardhat keystore set DEV_RPC_URL\nnpx hardhat keystore set DEV_PRIVATE_KEY\n</code></pre> <p>Warning</p> <p>Hardhat 控制台任务当前不会提示输入密钥库密码。在运行 <code>npx hardhat console</code> 之前，请为您的配置变量使用环境变量，或者在使用密钥库时，通过脚本/任务而不是控制台进行交互。</p> <p>然后，更新您的配置文件以使用加密的密钥和 ESM 语法：</p> Moonbeam <pre><code>import hardhatEthers from '@nomicfoundation/hardhat-ethers';\nimport hardhatIgnitionEthers from '@nomicfoundation/hardhat-ignition-ethers';\nimport hardhatKeystore from '@nomicfoundation/hardhat-keystore';\nimport { configVariable, defineConfig } from 'hardhat/config';\n\nexport default defineConfig({\n  plugins: [hardhatEthers, hardhatIgnitionEthers, hardhatKeystore],\n  solidity: '0.8.28',\n  networks: {\n    moonbeam: {\n      type: 'http',\n      chainType: 'l1',\n      url: configVariable('MOONBEAM_RPC_URL'),\n      chainId: 1284, // (hex: 0x504),\n      accounts: [configVariable('MOONBEAM_PRIVATE_KEY')],\n    },\n  },\n});\n</code></pre> Moonriver <pre><code>import hardhatEthers from '@nomicfoundation/hardhat-ethers';\nimport hardhatIgnitionEthers from '@nomicfoundation/hardhat-ignition-ethers';\nimport hardhatKeystore from '@nomicfoundation/hardhat-keystore';\nimport { configVariable, defineConfig } from 'hardhat/config';\n\nexport default defineConfig({\n  plugins: [hardhatEthers, hardhatIgnitionEthers, hardhatKeystore],\n  solidity: '0.8.28',\n  networks: {\n    moonriver: {\n      type: 'http',\n      chainType: 'l1',\n      url: configVariable('MOONRIVER_RPC_URL'),\n      chainId: 1285, // (hex: 0x505),\n      accounts: [configVariable('MOONRIVER_PRIVATE_KEY')],\n    },\n  },\n});\n</code></pre> Moonbase Alpha <pre><code>import hardhatEthers from '@nomicfoundation/hardhat-ethers';\nimport hardhatIgnitionEthers from '@nomicfoundation/hardhat-ignition-ethers';\nimport hardhatKeystore from '@nomicfoundation/hardhat-keystore';\nimport { configVariable, defineConfig } from 'hardhat/config';\n\nexport default defineConfig({\n  plugins: [hardhatEthers, hardhatIgnitionEthers, hardhatKeystore],\n  solidity: '0.8.28',\n  networks: {\n    moonbase: {\n      type: 'http',\n      chainType: 'l1',\n      url: configVariable('MOONBASE_RPC_URL'),\n      chainId: 1287, // (hex: 0x507),\n      accounts: [configVariable('MOONBASE_PRIVATE_KEY')],\n    },\n  },\n});\n</code></pre> Moonbeam Dev <pre><code>import hardhatEthers from '@nomicfoundation/hardhat-ethers';\nimport hardhatIgnitionEthers from '@nomicfoundation/hardhat-ignition-ethers';\nimport hardhatKeystore from '@nomicfoundation/hardhat-keystore';\nimport { configVariable, defineConfig } from 'hardhat/config';\n\nexport default defineConfig({\n  plugins: [hardhatEthers, hardhatIgnitionEthers, hardhatKeystore],\n  solidity: '0.8.28',\n  networks: {\n    dev: {\n      type: 'http',\n      chainType: 'l1',\n      url: configVariable('DEV_RPC_URL'),\n      chainId: 1281, // (hex: 0x501),\n      accounts: [configVariable('DEV_PRIVATE_KEY')],\n    },\n  },\n});\n</code></pre> <p>当您运行需要这些密钥的任务时，Hardhat 将提示您输入密码以解密它们。密钥仅在需要时才会被解密，这意味着只有当 Hardhat 任务使用密钥时，您才需要输入密码。</p> <p>如果您计划在您的项目中使用任何插件，您需要安装该插件并将其导入到您的 Hardhat 配置文件 (<code>hardhat.config.ts</code> 或 <code>hardhat.config.js</code>) 中。一旦导入了插件，它就会成为 Hardhat 运行时环境 的一部分，并且您可以在任务、脚本等中利用该插件的功能。</p> <p>有关可用配置选项的更多信息，请参阅 Hardhat 关于 配置 的文档。</p>"}, {"location": "builders/ethereum/dev-env/hardhat/#the-contract-file", "title": "合约文件", "text": "<p>现在您已经配置了您的项目，您可以通过创建智能合约来开始开发过程。该合约将是一个简单的合约，允许您存储一个可以稍后检索的值，称为 <code>Box</code>。</p> <p>要添加合约，您将采取以下步骤：</p> <ol> <li> <p>更改到 <code>contracts</code> 目录。</p> <pre><code>cd contracts\n</code></pre> </li> <li> <p>创建一个 <code>Box.sol</code> 文件。</p> <pre><code>touch Box.sol\n</code></pre> </li> <li> <p>打开文件并将以下合约添加到其中：</p> <pre><code>// contracts/Box.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\ncontract Box {\n    uint256 private value;\n\n    // Emitted when the stored value changes\n    event ValueChanged(uint256 newValue);\n\n    // Stores a new value in the contract\n    function store(uint256 newValue) public {\n        value = newValue;\n        emit ValueChanged(newValue);\n    }\n\n    // Reads the last stored value\n    function retrieve() public view returns (uint256) {\n        return value;\n    }\n}\n</code></pre> </li> </ol>"}, {"location": "builders/ethereum/dev-env/hardhat/#compiling-solidity", "title": "编译合约", "text": "<p>下一步是编译 <code>Box.sol</code> 智能合约。为此，您可以使用内置的 <code>compile</code> 任务，该任务将在 <code>contracts</code> 目录中查找 Solidity 文件，并使用 Hardhat 配置文件中定义的版本和编译器设置来编译它们。</p> <p>要使用 <code>compile</code> 任务，您只需运行：</p> <pre><code>npx hardhat compile\n</code></pre> npx hardhat compile Compiled 2 Solidity files with solc 0.8.28 (evm target: cancun) Compiled 1 Solidity test file with solc 0.8.28 (evm target: cancun) <p>编译后，将创建一个 <code>artifacts</code> 目录，其中包含合约的字节码和元数据，它们是 <code>.json</code> 文件。最好将此目录添加到 <code>.gitignore</code> 文件中。</p> <p>如果在编译合约后对其进行了更改，则可以使用相同的命令再次编译它。Hardhat 将查找任何更改并重新编译合约。如果未找到任何更改，则不会编译任何内容。如果需要，您可以使用 <code>clean</code> 任务强制编译，这将清除缓存并删除旧的构件。</p>"}, {"location": "builders/ethereum/dev-env/hardhat/#deploying-the-contract", "title": "部署合约", "text": "<p>要部署合约，您将使用 Hardhat Ignition，这是一个用于部署智能合约的声明式框架。Hardhat Ignition 旨在简化智能合约部署和测试相关的重复性任务的管理。有关更多信息，请务必查看 Hardhat Ignition 文档。</p> <p>要为您的 Ignition 模块设置正确的文件结构，请创建一个名为 <code>ignition</code> 的文件夹和一个名为 <code>modules</code> 的子目录。然后，在其中添加一个名为 <code>Box.js</code> 的新文件。您可以使用以下命令执行所有这三个步骤：</p> <pre><code>cd ignition/modules &amp;&amp; touch Box.js\n</code></pre> <p>接下来，您可以编写 Hardhat Ignition 模块。要开始，请执行以下步骤：</p> <ol> <li>从 Hardhat Ignition 模块导入 <code>buildModule</code> 函数。</li> <li>使用 <code>buildModule</code> 导出模块。</li> <li>使用 <code>getAccount</code> 方法选择部署者账户。</li> <li>部署 <code>Box</code> 合约。</li> <li>从模块返回一个对象。这使得 <code>Box</code> 合约可以在 Hardhat 测试和脚本中进行交互。</li> </ol> <pre><code>// 1. Import the `buildModule` function from the Hardhat Ignition module\nimport { buildModule } from '@nomicfoundation/hardhat-ignition/modules';\n\n// 2. Export a module using `buildModule`\n// Use `export default` instead of `module.exports`\nexport default buildModule('BoxModule', (m) =&gt; {\n  // 3. Use the `getAccount` method to select the deployer account\n  const deployer = m.getAccount(0);\n\n  // 4. Deploy the `Box` contract\n  const box = m.contract('Box', [], {\n    from: deployer,\n  });\n\n  // 5. Return an object from the module\n  return { box };\n});\n</code></pre> <p>要运行脚本并部署 <code>Box.sol</code> 合约，请使用以下命令，该命令要求您指定在 Hardhat 配置文件中定义的网络名称。如果您未指定网络，则 hardhat 默认会将合约部署到本地 Hardhat 网络。</p> <pre><code>npx hardhat ignition deploy ./ignition/modules/Box.js --network moonbase\n</code></pre> <p>Note</p> <p>如果您使用的是另一个 Moonbeam 网络，请确保指定正确的网络。网络名称需要与 Hardhat 配置文件中定义的名称匹配。</p> <p>系统将提示您输入 Hardhat secrets manager 的密码。接下来，系统将提示您确认要部署到的网络。确认后几秒钟，合约将被部署，您将在终端中看到合约地址。</p>  npx hardhat ignition deploy ./ignition/modules/Box.js --network moonbase ✅ Confirm deploy to network moonbase (1287)? … yes Hardhat Ignition 🚀 Deploying [ BoxModule ] Batch #1 Executed BoxModule#Box [ BoxModule ] successfully deployed 🚀 Deployed Addresses BoxModule#Box - 0xfBD78CE8C9E1169851119754C4Ea2f70AB159289 <p>恭喜，您的合约已上线！保存该地址，您将在下一步中使用它与此合约实例进行交互。</p>"}, {"location": "builders/ethereum/dev-env/hardhat/#interacting-with-the-contract", "title": "与合约交互", "text": "<p>您可以使用 Hardhat 通过两种方式与新部署的合约进行交互：从辅助脚本运行控制台样式的命令（推荐用于 Hardhat 3），或重用该脚本以通过 <code>run</code> 任务自动执行交互。</p>"}, {"location": "builders/ethereum/dev-env/hardhat/#run-the-script", "title": "运行脚本", "text": "<p>使用 <code>run</code> 任务对已部署的 <code>Box</code> 合约执行辅助脚本，以便您可以验证密钥库解锁流程是否正常，并确认合约将新值存储在 Moonbase Alpha 上。</p> <p>sh npx hardhat run --network moonbase scripts/box-console.ts</p> <p>系统将提示您输入 Hardhat 密钥库密码（如果您使用的是加密密钥），之后脚本将连接到 Moonbase Alpha，附加到您部署的 <code>Box</code> 合约，并记录调用 <code>store(5n)</code> 前后存储的值。 运行后，您应该看到类似于以下的输出：</p> npx hardhat run --network moonbase scripts/box-console.ts [hardhat-keystore] Enter the password: ********** Using signer 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Attaching to Box at INSERT_CONTRACT_ADDRESS Current stored value: 4 Calling store(5)... Submitted tx 0xdb0a7bfe9caeae5fb590cde27ad156f9b2788434aa4a94b95d1c3a8ce3d58b30, waiting for confirmation... Updated stored value: 5 % <p>该脚本会打印正在使用的签名者、交易前存储的值、提交的交易哈希以及调用 <code>store(5n)</code> 后更新的值。</p>"}, {"location": "builders/ethereum/dev-env/hardhat/#hardhat-forking", "title": "Hardhat 分叉", "text": "<p>您可以使用 Hardhat 分叉 任何与 EVM 兼容的链，包括 Moonbeam。分叉在本地模拟实时 Moonbeam 网络，使您能够在本地测试环境中与 Moonbeam 上部署的合约进行交互。由于 Hardhat 分叉基于 EVM 实现，您可以使用 Moonbeam 支持的标准 Ethereum JSON-RPC 方法 和 Hardhat 与分叉进行交互。</p> <p>使用 Hardhat 分叉时，需要注意一些限制。您无法与任何 Moonbeam 预编译合约或其函数进行交互。预编译是 Substrate 实现的一部分，因此无法在模拟的 EVM 环境中复制。这禁止您与 Moonbeam 上的跨链资产以及基于 Substrate 的功能（如质押和治理）进行交互。</p>"}, {"location": "builders/ethereum/dev-env/hardhat/#forking-moonbeam", "title": "分叉 Moonbeam", "text": "<p>您可以从命令行分叉 Moonbeam，或配置您的 Hardhat 项目以始终从您的 Hardhat 配置文件运行分叉。要分叉 Moonbeam 或 Moonriver，您需要拥有自己的端点和 API 密钥，您可以从支持的端点提供商之一获取。</p> <p>要从命令行分叉 Moonbeam，您可以从 Hardhat 项目目录中运行以下命令：</p> <p>===</p> <pre><code>```sh\n</code></pre> <p>npx hardhat node --fork INSERT_RPC_API_ENDPOINT     ```</p> <p>===</p> <pre><code>```sh\n</code></pre> <p>npx hardhat node --fork INSERT_RPC_API_ENDPOINT     ```</p> <p>===</p> <pre><code>```sh\n</code></pre> <p>npx hardhat node --fork https://rpc.api.moonbase.moonbeam.network     ```</p> <p>如果您喜欢配置您的 Hardhat 项目，您可以使用以下配置更新您的 Hardhat 配置文件：</p> <p>===</p> <pre><code>```js\n</code></pre> <p>... networks: {   hardhat: {     forking: {       url: 'INSERT_RPC_API_ENDPOINT',     },   }, }, ...     ```</p> <p>===</p> <pre><code>```js\n</code></pre> <p>... networks: {   hardhat: {     forking: {       url: 'INSERT_RPC_API_ENDPOINT',     },   }, }, ...     ```</p> <p>===</p> <pre><code>```js\n</code></pre> <p>... networks: {   hardhat: {     forking: {       url: 'https://rpc.api.moonbase.moonbeam.network',     },   }, }, ...     ```</p> <p>当您启动 Hardhat 分叉时，您将拥有 20 个预先存入 10,000 个测试代币的开发帐户。 分叉实例可在 <code>http://127.0.0.1:8545/</code> 上找到。 终端中的输出应类似于以下内容：</p> Private Key: Oxdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97 Account #9: Oxa0Ee7A142d267C1f36714E4a8F75612F20a79720 (10000 ETH) Private Key: 0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6 Account #10: OxBcd4042DE499D14e55001CcbB24a551F3b954096 (10000 ETH) Private Key: Oxf214f2b2cd398c806f84e317254e0f0b801d0643303237d97a22a48e01628897 Account #11: 0x71bE63f3384f5fb98995898A86B02Fb2426c5788 (10000 ETH) Private Key: 0x701b615bbdfb9de65240bc28bd21bbc0d996645a3dd57e7b12bc2bdf6f192c82 Account #12: OxFABBOac9d68B0B445fB7357272F202C5651694a (10000 ETH) Private Key: Oxa267530f49f8280200edf313ee7af6b827f2a8bce2897751d06a843f644967b1 Account #13: 0x1CBd3b2770909D4e10f157cABC84C7264073C9Ec (10000 ETH) Private Key: 0x47c99abed3324a2707c28affff1267e45918ec8c3f20b8aa892e8b065d2942dd Account #14: OxdF3e18d64BC6A983f673Ab319CCaE4f1a5707097 (10000 ETH) Private Key: Oxc526ee95bf44d8fc405a158bb884d9d1238d990612e9f33d006bb0789009aaa Account #15: Oxcd3B766CCDd6AE721141F452C550Ca635964ce71 (10000 ETH) Private Key: 0x8166f546bab6da521a8369cab06c5d2b9e46670292d85c875ee9ec20e84ffb61 Account #16: 0×2546BcD3c84621e976D8185a91A922aE77ECEc30 (10000 ETH) Private Key: Oxea6c44ac03bff858b476bba40716402b03e41b8e97e276d1baec7c37d42484a0 Account #17: OxbDA5747bFD65F08deb54cb465eB87D40e51B197E (10000 ETH) Private Key: 0x689af8efa8c651a91ad287602527f3af2fe9f6501a7ac4b06166765a93e037fd Account #18: OxdD2FD4581271e230360230F9337D5c0430Bf44C0 (10000 ETH) Private Key: Oxde9be858da4a475276426320d5e9262ecfc3ba460bfac56360bfa6c4c28b4ee0 Account #19: 0×8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199 (10000 ETH) Private Key: Oxdf57089febbacf7ba0bc227dafbffa9fc08a93fdc68e1e42411a14efcf23656e WARNING: These accounts, and their private keys, are publicly known.Any funds sent to them on Mainnet or any other live network WILL BE LOST. <p>要验证您是否已分叉网络，您可以查询最新的区块号：</p> <pre><code>curl --data '{\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}' -H \"Content-Type: application/json\" -X POST localhost:8545 \n</code></pre> <p>如果您将 <code>result</code> 从 十六进制转换为十进制，您应该从分叉网络的时间获取最新的区块号。 您可以使用区块浏览器交叉引用区块号。</p> <p>从这里，您可以将新合约部署到 Moonbeam 的分叉实例，或通过创建已部署合约的本地实例来与已部署的合约进行交互。</p> <p>要与已部署的合约进行交互，您可以使用 <code>ethers</code> 在 <code>scripts</code> 目录中创建一个新脚本。 因为您将使用 Hardhat 运行它，所以您可以直接从 Hardhat 运行时导入 <code>ethers</code>，而无需额外的设置。 在脚本中，您可以使用以下代码段访问网络上的实时合约：</p> <pre><code>import { ethers } from 'hardhat';\n\nasync function main() {\n  const provider = new ethers.JsonRpcProvider('http://127.0.0.1:8545/');\n\n  const contract = new ethers.Contract(\n    'INSERT_CONTRACT_ADDRESS',\n    'INSERT_CONTRACT_ABI',\n    provider\n  );\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/ethereum/dev-env/remix/", "title": "使用 Remix 部署到 Moonbeam", "text": ""}, {"location": "builders/ethereum/dev-env/remix/#introduction", "title": "简介", "text": "<p>Remix 是一个集成开发环境 (IDE)，用于在 Ethereum 和与 Ethereum 兼容的链上开发智能合约。它提供了一个易于使用的界面，用于编写、编译和部署智能合约。 鉴于 Moonbeam 的 Ethereum 兼容性功能，你可以直接将 Remix 与任何 Moonbeam 网络一起使用。</p> <p>本指南将引导你完成使用 Remix IDE 创建 Solidity 智能合约并将其部署到 Moonbeam 开发节点 的过程。 本指南可以适用于 Moonbeam、Moonriver 或 Moonbase Alpha。</p> <p>如果你熟悉 Remix，则可以跳到 将 Remix 连接到 Moonbeam 部分，了解如何将 Remix 与 Moonbeam 一起使用。</p>"}, {"location": "builders/ethereum/dev-env/remix/#checking-prerequisites", "title": "检查先决条件", "text": "<p>为了本指南的目的，您需要具备以下条件：</p> <ul> <li>本地运行的 Moonbeam 开发节点</li> <li>MetaMask 已安装并连接 到您的开发节点</li> </ul> <p>如果您按照上述指南操作，您应该拥有一个本地 Moonbeam 节点，该节点将在交易到达时开始创建区块。</p> ./target/release/moonbeam --dev 2025-10-03 20:17:18 ⚡ Idle (0 peers), best: #0 (0x28cd...88a6), finalized #0 (0x28cd...88a6), ⬇ 0 ⬆ 1 ⬇ 0 2025-10-03 20:17:23 ⚡ Idle (0 peers), best: #0 (0x28cd...88a6), finalized #0 (0x28cd...88a6), ⬇ 0 ⬆ 1 ⬇ 0 2025-10-03 20:17:28 ⚡ Idle (0 peers), best: #0 (0x28cd...88a6), finalized #0 (0x28cd...88a6), ⬇ 0 ⬆ 1 ⬇ 0 <p>您的开发节点附带 10 个预先注资的账户。您应该将 MetaMask 连接到您的 Moonbeam 开发节点，并导入至少一个预先注资的账户。您可以参考 MetaMask 文档的 导入账户 部分，获取关于如何导入开发账户的分步说明。</p> <p></p> <p>如果您正在为 Moonbeam、Moonriver 或 Moonbase Alpha 调整本指南，请确保您已连接到正确的网络，并且拥有一个有资金的帐户。 You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet.</p>"}, {"location": "builders/ethereum/dev-env/remix/#get-familiar-with-remix", "title": "熟悉 Remix", "text": "<p>如果您导航到 https://remix.ethereum.org/，您会看到 Remix 的布局分为四个部分：</p> <ol> <li>插件面板</li> <li>侧面板</li> <li>主面板</li> <li>终端</li> </ol> <p></p> <p>插件面板显示每个预加载插件、插件管理器和设置菜单的图标。您将在此处看到每个预加载插件的一些图标，这些插件是文件浏览器、在文件中搜索、Solidity 编译器和部署和运行交易插件。随着其他插件被激活，它们的图标将出现在此面板中。</p> <p>侧面板显示当前正在查看的插件的内容。默认情况下，您将看到文件浏览器插件，它显示默认工作区和一些预加载的文件和文件夹。但是，如果您从插件面板中选择其他图标之一，您将看到所选插件的内容。</p> <p>主面板会自动加载 Home 选项卡，其中包含指向各种资源的链接。您可以随时关闭此选项卡，并通过单击插件面板左上角的蓝色 Remix 图标重新打开它。在主面板中，您将能够看到您正在处理的每个文件。例如，您可以双击文件浏览器侧面板中的任何文件，它将作为主面板中的选项卡出现。</p> <p>终端面板类似于您在操作系统上拥有的标准终端；您可以从中执行脚本，并将日志打印到其中。所有交易和合约交互都会自动记录到终端。您还可以直接从终端与 Ethers JavaScript 库进行交互。</p>"}, {"location": "builders/ethereum/dev-env/remix/#compile-a-solidity-smart-contract", "title": "编译 Solidity 智能合约", "text": "<p>在编译合约之前，请确保您已从文件资源管理器选项卡中选择了合约文件。然后，从插件面板中选择 Solidity Compiler 选项。</p> <p>确保左上角的编译器版本符合您的合约中定义的版本以及 OpenZeppelin 的 <code>ERC20.sol</code> 合约 中定义的版本。例如，<code>MyToken.sol</code> 合约需要 Solidity ^0.8.30，并且 OpenZeppelin 的 <code>ERC20.sol</code> 合约与 ^0.8.30 兼容，因此编译器需要设置为 0.8.30 或更新的版本。</p> <p>Solidity 编译器插件还允许您更改一些设置并为编译器应用高级配置。如果您计划迭代智能合约，您可以选中自动编译框，这样每当您进行更改时，合约将自动重新编译。</p> <p>此外，在高级配置菜单中，您可以更改 EVM 版本、启用优化并设置整个合约生命周期内字节码预计运行的次数；默认设置为 200 次。有关合约优化的更多信息，请参阅 Solidity 文档中的优化器。</p> <p>在此示例中，不需要其他配置。要编译 <code>MyToken.sol</code> 合约，只需单击编译 MyToken.sol 合约。如果编译成功，您将在插件面板中 Solidity compiler 插件旁边看到一个绿色的勾号。</p> <p></p>"}, {"location": "builders/ethereum/dev-env/remix/#debug-compilation-errors", "title": "调试编译错误", "text": "<p>如果您尝试编译智能合约但出现错误或警告，您可以直接通过 Remix 中 Solidity 编译器插件的 ChatGPT 轻松调试问题。</p> <p>例如，如果您只向 ERC-20 构造函数提供了令牌名称，但忘记了令牌符号并尝试编译合约，则错误将显示在侧面板中。您可以向下滚动以阅读错误，并且您会看到还有一个ASK GPT按钮。要获得调试问题的帮助，您可以单击ASK GPT，Remix 终端将返回一个响应，该响应将指导您朝着正确的方向尝试修复问题。如果您需要其他帮助，您可以直接访问源并询问 ChatGPT。</p> <p></p> <p>成功修复问题并重新编译合约后，您将在插件面板中 Solidity 编译器 插件旁边看到一个绿色复选标记。</p> <p></p>"}, {"location": "builders/ethereum/dev-env/remix/#deploy-a-solidity-smart-contract", "title": "部署 Solidity 智能合约", "text": "<p>部署和运行交易 插件使您能够配置合约部署选项、部署合约以及与已部署的合约交互。</p> <p>侧面板包含以下部署选项：</p> <ul> <li>Environment - 允许您选择部署的执行环境</li> <li>Account - 将从中发送部署交易的帐户</li> <li>Gas Limit - 部署交易可以消耗的最大 gas 量</li> <li>Value - 要随部署交易一起发送的本地资产数量</li> <li>Contract - 要部署的合约</li> <li>Deploy - 使用所选帐户、gas 限制、value 以及任何构造函数参数的值，将部署交易发送到指定的环境</li> <li>At Address - 允许您通过指定现有合约的地址来与它交互</li> </ul> <p>以下部分将介绍如何配置部署到 Moonbeam 的环境。</p>"}, {"location": "builders/ethereum/dev-env/remix/#connect-remix-to-moonbeam", "title": "将 Remix 连接到 Moonbeam", "text": "<p>要将智能合约部署到 Moonbeam，您需要确保已将钱包连接到您的 Moonbeam 开发节点或您选择的 Moonbeam 网络。然后，从 Deploy and run transactions（部署和运行交易） 选项卡中，您可以通过从 ENVIRONMENT（环境） 下拉菜单中选择您的钱包来将 Remix 连接到您的钱包。例如，如果您安装了 Trust Wallet，您将从下拉菜单中看到 Injected Provider - TrustWallet（注入的提供商 - TrustWallet）。除了注入的提供商之外，您还可以通过 WalletConnect 连接到 Moonbeam。</p> <p>对于此示例，将使用 MetaMask。您应该已经安装了 MetaMask 并连接到本地 Moonbeam 开发节点。如果未连接，请参阅 使用 MetaMask 与 Moonbeam 交互 指南，以获取分步说明。</p> <p>从 ENVIRONMENT（环境） 下拉菜单中，选择 Injected Provider - MetaMask（注入的提供商 - MetaMask）。</p> <p></p> <p>MetaMask 将自动弹出并提示您连接到 Remix。您需要：</p> <ol> <li>选择您要连接到 Remix 的帐户</li> <li>点击 Next（下一步）</li> <li>点击 Connect（连接） 以将您的帐户连接到 Remix</li> </ol> <p></p> <p>将 MetaMask 连接到 Remix 后，侧面板将更新以显示您连接到的网络和帐户。对于 Moonbeam 开发节点，您应该会看到 Custom (1281) network（自定义（1281）网络）。</p> <p></p>"}, {"location": "builders/ethereum/dev-env/remix/#deploy-the-contract-to-moonbeam", "title": "将合约部署到 Moonbeam", "text": "<p>现在您已经连接了您的钱包，您可以部署合约了。由于您部署的是一个简单的 ERC-20 代币智能合约，Remix 设置的默认 gas 限制为 300 万，这已经足够了，您不需要指定一个随部署一起发送的值。因此，您可以按照以下步骤部署合约：</p> <ol> <li>确保 ENVIRONMENT 设置为 Injected Provider - MetaMask</li> <li>确保连接的帐户是您要从中部署交易的帐户</li> <li>使用默认的 GAS LIMIT <code>3000000</code></li> <li>将 VALUE 保持为 <code>0</code></li> <li>确保 <code>MyToken.sol</code> 是选定的合约</li> <li>展开 DEPLOY 下拉列表</li> <li>指定初始供应量。对于本例，您可以将其设置为 800 万个代币。由于此合约使用默认的 18 位小数，因此在框中输入的值为 <code>8000000000000000000000000</code></li> <li>单击 transact 以发送部署交易</li> <li>MetaMask 将会弹出，您可以单击 Confirm 以部署合约</li> </ol> <p></p> <p>部署交易完成后，您将在 Remix 终端中看到有关部署交易的详细信息。此外，该合约将出现在侧面板的 Deployed Contracts 部分下。</p>"}, {"location": "builders/ethereum/dev-env/remix/#interact-with-deployed-smart-contracts", "title": "与已部署的智能合约交互", "text": "<p>一旦您部署了一个智能合约，或者通过“At Address”按钮访问了一个现有的合约，该合约将出现在侧面板的“已部署合约”部分下。您可以展开合约来查看所有您可以与之交互的合约函数。</p> <p>要与给定的函数交互，您可以单击函数名称，该名称将包含在橙色、红色或蓝色按钮中。橙色按钮用于写入区块链且不可支付的函数；红色按钮用于写入区块链且可支付的函数；蓝色按钮用于从区块链读取数据的函数。</p> <p>根据您交互的函数，您可能需要输入参数值。如果该函数需要输入，您可以通过展开该函数并为每个参数输入一个值来输入它们。</p> <p>如果您交互的函数是可支付的，您可以在侧面板顶部的“VALUE”字段中输入金额，该字段与具有可支付的构造函数的合约使用的值字段相同。</p>"}, {"location": "builders/ethereum/dev-env/remix/#call-the-smart-contract-functions", "title": "调用智能合约函数", "text": "<p>如果您展开 MYTOKEN 合约下拉菜单，您将能够看到所有可以与之交互的可用函数。要与给定的函数交互，您可以根据需要提供任何输入，然后单击包含要交互的函数名称的按钮。</p> <p>例如，如果您想调用 <code>totalSupply</code> 函数，您无需签署交易，因为您会立即得到响应。</p> <p></p> <p>另一方面，如果您调用 <code>approve</code> 函数，该函数将批准一个帐户作为给定数量的 MYTOK 代币的消费方，您需要在 MetaMask 中提交批准。要对此进行测试，您可以采取以下步骤：</p> <ol> <li>将 spender 设置为您希望能够代表您消费代币的帐户。对于此示例，您可以使用 Bob 的帐户（预先资助的开发帐户之一）：<code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>输入消费方可以消费的数量。对于此示例，您可以通过输入 <code>10000000000000000000</code> 来批准 Bob 消费 10 个 MYTOK</li> <li>按 transact</li> <li>MetaMask 将会弹出，您需要查看批准的详细信息并提交批准</li> </ol> <p></p> <p>要查看您的余额或批准，或转移 MYTOK，您可以将 MYTOK 添加到您的钱包。有关如何将代币添加到 MetaMask 的信息，您可以参考添加 ERC-20 代币部分中的我们的 MetaMask 文档。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/ethereum/dev-env/tenderly/", "title": "在 Moonbeam 上使用 Tenderly", "text": ""}, {"location": "builders/ethereum/dev-env/tenderly/#introduction", "title": "简介", "text": "<p>Tenderly 是一个 Web3 开发平台，包含一套旨在帮助开发者完成 DApp 开发生命周期的工具。借助 Tenderly，您可以构建、调试、测试、优化、监控、设置警报以及查看 Moonbeam 和 Moonriver 上智能合约的分析。</p> <p>Tenderly 平台提供以下功能：</p> <ul> <li> <p>合约验证 - 验证智能合约对于充分利用 Tenderly 的所有功能至关重要，因此 Tenderly 提供了几种验证方法。您可以通过 Tenderly 仪表板、Tenderly CLI 和 Foundry 或 Tenderly Hardhat 插件 验证智能合约</p> </li> <li> <p>调试器 - 使用可视化调试器检查交易，并更深入地了解代码的行为。借助调试器，您可以查看交易的堆栈跟踪、查看交易中进行的调用、单步执行合约以及查看解码后的输入、输出和状态变量。您可以在 Tenderly 仪表板或 Tenderly 调试器 Chrome 扩展程序 上使用调试器</p> </li> <li> <p>Gas 分析器 - 查看您在细粒度级别上花费了多少 gas，以便您可以优化智能合约并降低交易 gas 成本</p> </li> <li> <p>模拟器 - 在 TestNet 开发环境中模拟交易，以了解您的交易在不必将其发送到链上的情况下将如何运行。这样，您就可以知道交易的结果，并确保它在发送到网络之前按预期工作。您可以尝试不同的参数，模拟历史和当前交易，以及编辑合约源代码。您可以从 Tenderly 仪表板访问模拟器，也可以使用 Tenderly 模拟 API 以编程方式利用模拟器</p> </li> <li> <p>虚拟 TestNets - 在隔离的环境中模拟实时 Moonbeam 网络，以与已部署的合约和实时链上数据进行交互。这些测试环境支持跨智能合约、UI、后端和数据索引的受控开发、测试和调试。它们支持复杂场景的顺序交易模拟。使用此功能时，需要注意一些限制。Moonbeam 预编译合约 不受支持，因为它们是 Substrate 实现的一部分，并且无法在模拟的 EVM 环境中复制，从而禁止您与跨链资产、质押和治理进行交互。</p> </li> <li> <p>警报 - 配置实时警报，以便在发生特定事件时通知您，使您随时了解智能合约的运行情况</p> </li> <li> <p>Web3 操作 - 在 JavaScript 或 TypeScript 中创建可编程函数，这些函数在发生特定智能合约或链事件时由 Tenderly 自动执行</p> </li> </ul> <p>Note</p> <p>Tenderly 支持 Moonbeam、Moonriver 和 Moonbase Alpha，但 Web3 网关除外。有关更多信息，请查看 Tenderly 关于 支持的网络 的文档。</p>"}, {"location": "builders/ethereum/dev-env/tenderly/#_1", "title": "开始使用", "text": "<p>Tenderly 仪表板提供对一体化 Web3 开发平台的访问。要开始使用该仪表板，您需要注册一个帐户。注册后，您就可以开始浏览您的 Tenderly 仪表板。</p> <p></p> <p>如果您不想设置帐户，您还可以使用 Tenderly 的浏览器访问有限的功能。没有帐户，您仍然可以深入了解合约和交易。但是，您将无法模拟交易或创建虚拟测试网。</p> <p>要以编程方式与 Tenderly 的功能交互，您可以查看 Tenderly CLI GitHub 存储库以获取更多信息。</p> <p>以下部分将向您展示如何在 Moonbeam 上开始使用 Tenderly。有关更详细的文档，请参阅 Tenderly 的文档站点。</p>"}, {"location": "builders/ethereum/dev-env/tenderly/#add-a-contract", "title": "添加合约", "text": "<p>开始使用 Tenderly 仪表板的一个好方法是添加已部署的智能合约。添加合约后，您将能够创建交易模拟和虚拟测试网，使用调试器，设置监控和警报等等。</p> <p>要添加新合约，您可以单击左侧面板上的 合约，然后单击 添加合约。将出现一个弹出窗口，您可以按照以下步骤操作：</p> <ol> <li>输入合约地址</li> <li>（可选）您可以为您的合约命名</li> <li>根据您将智能合约部署到的网络，选择 Moonbeam、Moonriver 或 Moonbase Alpha 作为网络</li> <li>（可选）切换 添加更多 滑块，以在初始合约之后添加其他合约</li> <li>最后，要将合约添加到仪表板，请单击 保存</li> </ol> <p></p> <p>添加合约后，它将显示在 合约 仪表板上的合约列表中。如果合约尚未验证，仪表板将显示 未验证 状态以及 验证 按钮。</p> <p></p> <p>为了充分利用 Tenderly 工具集，建议您验证您的智能合约，您可以通过单击 验证 来完成。您可以选择通过上传合约的 JSON、ABI 或源代码来验证您的合约。有关更多信息，请参阅 Tenderly 关于 智能合约验证 的文档。</p>"}, {"location": "builders/ethereum/dev-env/tenderly/#virtual-testnets-moonbeam", "title": "创建虚拟测试网", "text": "<p>Tenderly 的虚拟测试网功能在隔离环境中模拟了 Moonbeam 实时网络，使您能够与已部署的合约和实时链上数据进行交互。</p> <p>使用此功能时，需要注意一些限制。您无法与任何 Moonbeam 预编译合约 及其函数进行交互。预编译是 Substrate 实现的一部分，因此无法在模拟的 EVM 环境中复制。这禁止您与 Moonbeam 上的跨链资产和基于 Substrate 的功能（如质押和治理）进行交互。</p> <p>Tenderly 使通过仪表板创建测试网非常简单。要开始使用，请单击左侧菜单上的 Virtual TestNets（虚拟测试网），然后单击 Create Virtual TestNet（创建虚拟测试网）。从那里，您可以按照以下步骤操作：</p> <ol> <li>从 Parent network（父网络） 下拉菜单中选择 Moonbeam、Moonriver 或 Moonbase Alpha</li> <li>（可选）为您的测试网命名</li> <li>选择您的 Chain ID（链 ID）；您可以使用自定义 ID 或原始网络 ID。建议设置自定义链 ID，以防止重放攻击，并避免在将虚拟测试网添加到钱包时出现问题</li> <li>选择是否打开或关闭 Public Explorer（公共浏览器）</li> <li>如果您希望您的虚拟测试网与父网络实时保持更新，请启用 State Sync（状态同步）</li> <li>要限制数据，请禁用 Use latest block（使用最新区块） 并输入区块号，或者保持启用以包含所有区块</li> <li>单击 Create（创建）</li> </ol> <p></p> <p>创建虚拟测试网后，您可以通过部署合约或创建交易模拟来开始使用它。</p> <p>要部署合约，请转到左侧菜单中的“合约”。使用 Watched Contracts（已监视的合约） 中的一个，或通过 Watch Contract（监视合约） 添加一个新合约。添加后，它将出现在 Contracts（合约） 中，您可以在其中查看其详细信息。</p> <p>要创建模拟，请单击 Simulation（模拟） 按钮，然后输入模拟的配置。有关模拟的更多信息，请参阅 Tenderly 的 Simulator UI Overview（模拟器用户界面概述） 文档。</p> <p></p> <p>既然您已经了解了如何在 Moonbeam 上开始使用 Tenderly 的一些功能，请随时深入了解并查看其开发平台中提供的其他工具。您可以访问 Tenderly 的文档站点 以获取更多信息。您还可以查看 Moonbeam 关于 使用 Tenderly 模拟和调试交易 的教程。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/ethereum/json-rpc/debug-trace/", "title": "调试 API &amp; 追踪模块", "text": ""}, {"location": "builders/ethereum/json-rpc/debug-trace/#introduction", "title": "介绍", "text": "<p>Geth 的 debug 和 txpool API 以及 OpenEthereum 的 trace 模块提供了非标准的 RPC 方法，以便更深入地了解交易处理。作为 Moonbeam 为开发者提供无缝以太坊体验的目标的一部分，我们支持其中一些非标准的 RPC 方法。支持这些 RPC 方法是一个重要的里程碑，因为许多项目（如 The Graph）依赖它们来索引区块链数据。</p> <p>本指南将介绍 Moonbeam 上可用的受支持 RPC 方法，以及如何使用 curl 命令针对启用了 debug、txpool 和 tracing 标志的追踪节点调用它们。您可以通过两种方式访问追踪节点：通过受支持的追踪 RPC 提供商或启动您自己的追踪节点。</p> <p>要查看追踪 RPC 提供商的列表，请查看 网络端点 页面。</p> <p>如果您希望设置自己的追踪节点，您可以按照 运行追踪节点 指南进行操作。您的追踪节点的 RPC HTTP 端点应位于 <code>http://127.0.0.1:9944</code>，并且您的节点应显示与以下内容类似的日志：</p> docker run --network host  \\     -u $(id -u ${USER}):$(id -g ${USER}) \\         moonbeamfoundation/moonbeam-tracing:v0.49.2-4100-4d7b \\     --name=\"Moonbeam-Tracing-Tutorial\" \\     --unsafe-rpc-external \\     --ethapi=debug,trace,txpool \\     --wasm-runtime-overrides=/moonbeam/moonbase-substitutes-tracing \\     --runtime-cache-size 64 \\     --dev     2025-07-10 09:04:26 Moonbeam Parachain Collator      2025-07-10 09:04:26 ✌️  version 0.49.2      2025-07-10 09:04:26 ❤️  by PureStake, 2019-2025      2025-07-10 09:04:26 📋 Chain specification: Moonbase Development Testnet      2025-07-10 09:04:26 🏷  Node name: Moonbeam-Tracing-Tutorial      2025-07-10 09:04:26 👤 Role: AUTHORITY      2025-07-10 09:04:26 💾 Database: RocksDb at /tmp/substrateO3YeRz/chains/moonbase_dev/db/full      2025-07-10 09:04:26 Found wasm override. version=moonbase-300 (moonbase-0.tx2.au3) file=/moonbeam/moonbase-substitutes-tracing/moonbase-runtime-300-substitute-tracing.wasm      ...      2025-07-10 09:04:26 💤 Idle (0 peers), best: #0 (0x18e6…2eb1), finalized #0 (0x18e6…2eb1), ⬇ 0 ⬆ 0"}, {"location": "builders/ethereum/json-rpc/eth-rpc/", "title": "支持的以太坊 RPC 方法", "text": ""}, {"location": "builders/ethereum/json-rpc/eth-rpc/#introduction", "title": "简介", "text": "<p>Moonbeam 团队与 Parity 紧密合作，共同开发了 Frontier，这是一个用于基于 Substrate 链的以太坊兼容层。该层使开发人员能够在 Moonbeam 上无缝运行未经修改的以太坊 dApp。</p> <p>尽管如此，并非所有以太坊 JSON-RPC 方法都受支持；其中一些受支持的方法会返回默认值（尤其是与以太坊 PoW 共识机制相关的方法）。本指南提供了 Moonbeam 上支持的以太坊 JSON-RPC 方法的完整列表。开发人员可以快速参考此列表，以了解可用于与 Moonbeam 的以太坊兼容区块链交互的功能。</p>"}, {"location": "builders/ethereum/json-rpc/eth-rpc/#basic-rpc-methods", "title": "标准以太坊 JSON-RPC 方法", "text": "<p>Moonbeam 支持的以太坊 API 中的基本 JSON-RPC 方法包括：</p> <ul> <li>eth_protocolVersion — 默认返回 <code>1</code></li> <li>eth_syncing — 返回一个包含同步状态数据的对象，或者 <code>false</code></li> <li>eth_hashrate — 默认返回 <code>\"0x0\"</code></li> <li>eth_coinbase — 返回最新的区块作者。不一定是最终确定的区块</li> <li>eth_mining — 默认返回 <code>false</code></li> <li>eth_chainId — 返回用于在当前区块进行签名的链 ID</li> <li>eth_gasPrice — 返回每单位 gas 使用量的基本费用。目前是每个网络的最低 gas 价格</li> <li>eth_accounts — 返回客户端拥有的地址列表</li> <li>eth_blockNumber — 返回可用的最高区块号</li> <li>eth_getBalance — 返回给定地址的余额。您可以提供默认区块参数来代替提供区块号作为参数</li> <li>eth_getStorageAt — 返回给定地址的存储内容。您可以提供默认区块参数来代替提供区块号作为参数</li> <li>eth_getBlockByHash — 返回给定哈希的区块信息，包括伦敦升级后的区块的 <code>baseFeePerGas</code></li> <li>eth_getBlockByNumber — 返回由区块号指定的区块信息，包括伦敦升级后的区块的 <code>baseFeePerGas</code>。您可以提供默认区块参数来代替提供区块号作为第一个参数</li> <li>eth_getBlockReceipts — 返回给定区块的所有交易回执</li> <li>eth_getTransactionCount — 返回从给定地址发送的交易数量 (nonce)。您可以提供默认区块参数来代替提供区块号作为参数</li> <li>eth_getBlockTransactionCountByHash — 返回具有给定区块哈希的区块中的交易数量</li> <li>eth_getBlockTransactionCountByNumber — 返回具有给定区块号的区块中的交易数量</li> <li>eth_getUncleCountByBlockHash — 默认返回 <code>\"0x0\"</code></li> <li>eth_getUncleCountByBlockNumber — 默认返回 <code>\"0x0\"</code></li> <li>eth_getCode — 返回给定区块号处给定地址的代码。您可以提供默认区块参数来代替提供区块号作为参数</li> <li>eth_sendTransaction — 创建一个新的消息调用交易或合约创建，如果数据字段包含代码。如果交易尚不可用，则返回交易哈希或零哈希</li> <li>eth_sendRawTransaction — 为已签名的交易创建新的消息调用交易或合约创建。如果交易尚不可用，则返回交易哈希或零哈希</li> <li>eth_call — 立即执行新的消息调用，而不在区块链上创建交易，并返回已执行调用的值<ul> <li>Moonbeam 支持使用可选的 状态覆盖集 对象。此地址到状态的映射对象允许用户指定一些状态，以便在执行 <code>eth_call</code> 调用之前以临时方式覆盖。状态覆盖集通常用于调试智能合约等任务。请访问 go-ethereum 文档以了解更多信息</li> <li>您可以提供默认区块参数来代替提供区块号作为参数</li> </ul> </li> <li>eth_estimateGas — 返回给定交易成功所需的估计 gas 量。您可以选择指定 <code>gasPrice</code> 或 <code>maxFeePerGas</code> 和 <code>maxPriorityFeePerGas</code>。您可以提供默认区块参数来代替提供区块号作为参数</li> <li>eth_maxPriorityFeePerGas - 返回一个估算值，即包含在一个区块中所需的优先费（以 Wei 为单位）</li> <li>eth_feeHistory — 返回指定范围内最多 1024 个区块的 <code>baseFeePerGas</code>、<code>gasUsedRatio</code>、<code>oldestBlock</code> 和 <code>reward</code></li> <li>eth_getTransactionByHash — 返回有关具有给定哈希的交易的信息。EIP-1559 交易具有 <code>maxPriorityFeePerGas</code> 和 <code>maxFeePerGas</code> 字段</li> <li>eth_getTransactionByBlockHashAndIndex — 返回有关在给定区块哈希和给定索引位置的交易的信息。EIP-1559 交易具有 <code>maxPriorityFeePerGas</code> 和 <code>maxFeePerGas</code> 字段</li> <li>eth_getTransactionByBlockNumberAndIndex — 返回有关在给定区块号和给定索引位置的交易的信息。EIP-1559 交易具有 <code>maxPriorityFeePerGas</code> 和 <code>maxFeePerGas</code> 字段。您可以提供默认区块参数来代替提供区块号作为参数</li> <li>eth_getTransactionReceipt — 返回给定交易哈希的交易回执</li> <li>eth_getUncleByBlockHashAndIndex — 默认返回 <code>null</code></li> <li>eth_getUncleByBlockNumberAndIndex — 默认返回 <code>null</code></li> <li>eth_getLogs — 返回与给定筛选器对象匹配的所有日志的数组。您可以提供默认区块参数来代替提供区块号作为参数</li> <li>eth_newFilter — 基于提供的输入创建一个筛选器对象。返回筛选器 ID</li> <li>eth_newBlockFilter — 在节点中创建一个筛选器，以便在新区块到达时发出通知。返回筛选器 ID</li> <li>eth_newPendingTransactionFilter - 在节点中创建一个筛选器，以便在新挂起交易到达时发出通知。返回筛选器 ID</li> <li>eth_getFilterChanges — 筛选器的轮询方法（参见上述方法）。返回自上次轮询以来发生的日志数组</li> <li>eth_getFilterLogs — 返回与具有给定 ID 的筛选器匹配的所有日志的数组</li> <li>eth_uninstallFilter — 卸载具有给定 ID 的筛选器。当不再需要轮询时，应使用此方法。如果一段时间后未使用 <code>eth_getFilterChanges</code> 请求筛选器，则筛选器将超时</li> </ul>"}, {"location": "builders/ethereum/json-rpc/eth-rpc/#default-block-parameters", "title": "默认区块参数", "text": "<p>Moonbeam支持多个默认区块参数，允许您在重要的区块高度查询JSON-RPC方法的一个子集。Moonbeam支持以下默认区块参数：</p> <ul> <li><code>finalized</code> - 指的是Polkadot验证者已最终确定的最新区块</li> <li><code>safe</code> - 在Moonbeam中与<code>finalized</code>同义。在以太坊中，<code>safe</code>指的是网络认为安全的最新区块，这意味着它不太可能被回滚，但尚未最终确定。凭借Moonbeam快速且确定性的最终性，<code>finalized</code>和<code>safe</code>指的是相同的区块。</li> <li><code>earliest</code> - 指的是区块链的创世区块</li> <li><code>pending</code> - 代表最新状态，包括尚未被挖掘到区块中的待处理交易。这是内存池的实时视图</li> <li><code>latest</code> - 指的是区块链中最新确认的区块，该区块可能尚未最终确定</li> </ul>"}, {"location": "builders/ethereum/json-rpc/eth-rpc/#unsupported-rpc-methods", "title": "不支持的以太坊 JSON-RPC 方法", "text": "<p>Moonbeam 不支持以下以太坊 API JSON-RPC 方法：</p> <ul> <li>eth_getProof - 返回指定账户的账户和存储值，包括 Merkle 证明</li> <li>eth_blobBaseFee - 返回下一个区块中 blob 的预期基础费用</li> <li>eth_createAccessList - 基于给定的交易对象创建一个 EIP-2930 类型的 <code>accessList</code></li> <li>eth_sign - 允许用户签署一个任意哈希，以便稍后发送。存在安全风险，因为任意哈希可能被欺诈性地应用于其他交易</li> <li>eth_signTransaction - 允许用户签署一个交易，以便稍后发送。由于相关的安全风险，它很少被使用</li> </ul>"}, {"location": "builders/ethereum/json-rpc/eth-rpc/#additional-rpc-methods", "title": "附加 RPC 方法", "text": "<p>查看一些非标准的以太坊和 Moonbeam 特定的 RPC 方法：</p> <ul> <li>调试和追踪</li> <li>事件订阅</li> <li>自定义 Moonbeam</li> </ul>"}, {"location": "builders/ethereum/json-rpc/moonbeam-custom-api/", "title": "Moonbeam 自定义 API", "text": ""}, {"location": "builders/ethereum/json-rpc/moonbeam-custom-api/#introduction", "title": "简介", "text": "<p>Moonbeam 节点包括对自定义 JSON-RPC 端点的支持：</p> <ul> <li><code>moon_isBlockFinalized</code></li> <li><code>moon_isTxFinalized</code></li> <li><code>moon_getEthSyncBlockRange</code></li> </ul> <p>这些端点为检查链上事件的最终性提供了有价值的功能。</p> <p>要开始探索 Moonbeam 的自定义 JSON-RPC 端点，您可以尝试下面提供的 curl 示例。这些示例演示了如何查询 Moonbase Alpha 的公共 RPC 端点。但是，您可以通过更改 URL 和 API 密钥轻松地修改它们，以便与您自己的 Moonbeam 或 Moonriver 端点一起使用。如果您还没有这样做，您可以从我们支持的端点提供商处获取您的端点和 API 密钥。</p>"}, {"location": "builders/ethereum/json-rpc/moonbeam-custom-api/#rpc-methods", "title": "支持的自定义 RPC 方法", "text": "moon_isBlockFinalized <p>检查给定区块哈希的区块是否已最终确定。</p> 参数返回值示例 <ul> <li><code>block_hash</code> string - 区块的哈希值，接受 Substrate 风格或 Ethereum 风格的区块哈希作为输入</li> </ul> <p>返回一个布尔值：如果区块已最终确定，则返回 <code>true</code>；如果区块未最终确定或未找到，则返回 <code>false</code>。</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"moon_isBlockFinalized\",\n  \"params\": [\"INSERT_BLOCK_HASH\"]\n}' https://rpc.api.moonbase.moonbeam.network\n</code></pre> moon_isTxFinalized <p>检查给定 EVM 交易哈希的交易是否已最终确定。</p> 参数返回值示例 <ul> <li><code>tx_hash</code> string - 交易的 EVM 交易哈希</li> </ul> <p>返回一个布尔值：如果交易已最终确定，则返回 <code>true</code>；如果交易未最终确定或未找到，则返回 <code>false</code>。</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"moon_isTxFinalized\",\n  \"params\": [\"INSERT_TRANSACTION_HASH\"]\n}' https://rpc.api.moonbase.moonbeam.network\n</code></pre> moon_getEthSyncBlockRange <p>返回 Frontier 后端中完全索引的区块范围。</p> 参数返回值示例 <p>无</p> <p>返回 Frontier 后端中完全索引的区块范围。以下示例响应包括区块 <code>0</code> 和最新完全索引区块的 Substrate 区块哈希：</p> <p>[ \"0x91bc6e169807aaa54802737e1c504b2577d4fafedd5a02c10293b1cd60e39527\", \"0xb1b49bd709ca9fe0e751b8648951ffbb2173e1258b8de8228cfa0ab27003f612\" ]</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"moon_getEthSyncBlockRange\",\n  \"params\": []\n}' https://rpc.api.moonbase.moonbeam.network\n</code></pre>"}, {"location": "builders/ethereum/json-rpc/pubsub/", "title": "订阅事件", "text": ""}, {"location": "builders/ethereum/json-rpc/pubsub/#introduction", "title": "简介", "text": "<p>Moonbeam 支持以太坊风格的事件订阅，允许您等待事件并相应地处理它们，而不是轮询它们。</p> <p>它的工作原理是订阅特定事件；每个订阅都会返回一个 ID。对于每个与订阅匹配的事件，都会发送包含相关数据的通知以及订阅 ID。</p> <p>在本指南中，您将学习如何在 Moonbase Alpha 上订阅事件日志、传入的待处理交易和传入的区块头。本指南也适用于 Moonbeam 或 Moonriver。</p>"}, {"location": "builders/ethereum/json-rpc/pubsub/#filter-rpc-methods", "title": "支持的 Pubsub JSON-RPC 方法", "text": "<p>请注意，本节中的示例需要安装 wscat。</p> eth_subscribe <p>为给定的订阅名称创建订阅。</p> 参数返回值示例 <ul> <li><code>subscription_name</code> string - 要订阅的事件类型。支持的订阅 类型有：<ul> <li><code>newHeads</code> — 每次将新标头附加到链时触发通知</li> <li><code>logs</code> — 返回包含在新的导入块中并符合给定筛选标准的日志</li> <li><code>newPendingTransactions</code> — 返回添加到挂起状态的所有交易的哈希值</li> <li><code>syncing</code> — 指示节点何时开始或停止与网络同步</li> </ul> </li> </ul> <p><code>result</code> 返回订阅 ID。</p> <pre><code>wscat -c wss://wss.api.moonbase.moonbeam.network -x '\n  {\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"eth_subscribe\",\n    \"params\": [\"INSERT_SUBSCRIPTION_NAME\"]\n  }'\n</code></pre> eth_unsubscribe <p>取消给定订阅 ID 的现有订阅。</p> 参数返回值示例 <ul> <li><code>subscription_id</code> string - 订阅 ID</li> </ul> <p><code>result</code> 返回一个布尔值，指示是否成功取消订阅。</p> <pre><code>wscat -c wss://wss.api.moonbase.moonbeam.network -x '\n  {\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"eth_unsubscribe\",\n    \"params\": [\"INSERT_SUBSCRIPTION_ID\"]\n  }'\n</code></pre>"}, {"location": "builders/ethereum/json-rpc/pubsub/#subscribe-to-events", "title": "使用以太坊库订阅事件", "text": "<p>本节将向您展示如何使用以太坊库（如Ethers.js）以编程方式订阅 Moonbeam 上的事件。</p>"}, {"location": "builders/ethereum/json-rpc/pubsub/#checking-prerequisites", "title": "检查先决条件", "text": "<p>本指南中的示例基于 Ubuntu 22.04 环境。您还需要以下内容：</p> <ul> <li>安装 MetaMask 并连接到 Moonbase Alpha</li> <li>一个有资金的帐户。   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>在 Moonbase Alpha 上部署您自己的 ERC-20 代币。您可以通过按照我们的 Remix 教程，同时首先将 MetaMask 指向 Moonbase Alpha 来做到这一点</li> <li> <p>安装 Ethers.js 或您选择的 Ethereum 库。您可以通过 npm 安装 Ethers.js：</p> <pre><code>npm install ethers\n</code></pre> </li> </ul>"}, {"location": "builders/ethereum/json-rpc/pubsub/#subscribing-to-event-logs-in-moonbase-alpha", "title": "订阅事件日志", "text": "<p>任何遵循 ERC-20 代币标准的合约都会发出与代币转移相关的事件，即 <code>event Transfer(address indexed from, address indexed to, uint256 value)</code>。在本节中，您将学习如何使用 Ethers.js 库订阅这些事件。</p> <p>使用以下代码片段来设置一个订阅，以侦听代币转移事件：</p> <pre><code>const { ethers } = require('ethers');\n\nconst provider = new ethers.WebSocketProvider(\n  'wss://wss.api.moonbase.moonbeam.network'\n);\n\nconst tokenAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = [\n  'event Transfer(address indexed from, address indexed to, uint256 value)',\n];\nconst iface = new ethers.Interface(abi);\nconst transferTopic = ethers.id('Transfer(address,address,uint256)');\n\nconst filter = {\n  address: tokenAddress,\n  topics: [transferTopic],\n};\n\nconst main = async () =&gt; {\n  console.log('🕔 Subscription set up. Waiting for new logs');\n\n  provider.on(filter, (log) =&gt; {\n    const parsed = iface.parseLog(log);\n\n    console.log({\n      from: parsed.args.from,\n      to: parsed.args.to,\n      value: parsed.args.value.toString(),\n      blockNumber: log.blockNumber,\n      txHash: log.transactionHash,\n    });\n  });\n};\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre> <p>Note</p> <p>请务必将 <code>'INSERT_CONTRACT_ADDRESS'</code> 替换为您应该已经部署的 ERC-20 代币合约的实际地址（作为前提条件）。</p> <p>在提供的代码中：</p> <ul> <li>WebSocket 提供程序用于侦听 <code>Transfer</code> 事件，并使用合约 ABI 解析日志</li> <li> <p>侦听器通过签名来过滤 <code>Transfer</code> 事件，签名可以按如下方式计算：</p> <pre><code>EventSignature = keccak256(Transfer(address,address,uint256))\n</code></pre> <p>这转换为 <code>0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</code>，并用作订阅过滤器中的第一个主题。</p> </li> </ul> <p>如果您不提供任何主题，您将订阅合约发出的所有事件。有关主题的更多信息，请参见 了解以太坊区块链上的事件日志 Medium 文章。</p> <p>通过执行此代码，您将建立一个订阅来监视 Moonbeam 上的 ERC-20 代币转移事件。新事件发生时将记录到终端。</p>  node contract-events.js 0x35547a6f7777444f35306f5353556271"}, {"location": "builders/ethereum/json-rpc/pubsub/#understanding-event-logs", "title": "理解事件日志", "text": "<p>为了说明这个过程，假设一个 ERC-20 代币转移已发送，参数如下：</p> <ul> <li>From 地址 - <code>0x44236223aB4291b93EEd10E4B511B37a398DEE55</code></li> <li>To 地址 - <code>0x8841701Dba3639B254D9CEe712E49D188A1e941e</code></li> <li>Value（代币） - <code>1000000000000000000</code> (1 DEV in Wei)</li> </ul> <p>该交易发出的事件日志如下：</p>  node contract-events.js 0x35547a6f7777444f35306f5353556271 {   address: '0xCc17F1FAEAab9Fe70Dc2D616Ea768a4336f3c506',   blockHash: '0x12d1f37db14f8d4efa2540ecb63d7f8b95236bb11c405e58691a45070d2c7e7f',   blockNumber: 16736,   data: '0x0000000000000000000000000000000000000000000000000d0b6b3a7640000',   logIndex: 0,   removed: false,   topics: [     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',     '0x00000000000000000000000044236223ab4291b93eed10e4b511b37a398dee55',     '0x0000000000000000000000008841701dba3639b254d9cee712e49d188a1e941e'   ],   transactionHash: '0xd53891693a731e0bca3287adc6375d04fe3b6605d00b186a669c6bbc8d22e88d',   transactionIndex: 0,   transactionLogIndex: '0x0',   id: 'log_83c933b0' } <p>如果您查看 <code>topics</code> 数组，则总共有三个主题（按此顺序）：</p> <ol> <li><code>Transfer</code> 事件的事件签名</li> <li><code>from</code> 地址</li> <li><code>to</code> 地址</li> </ol> <p>由于总共有三个主题（最大值为四个），因此这对应于 LOG3 操作码：</p> <p></p> <p>索引主题（例如 <code>from</code> 和 <code>to</code> 地址）通常由 256 位（64 个十六进制字符）值表示。如有必要，它们会用零填充以达到完整长度。</p> <p>未索引的数据（例如转移的代币值）不包含在 <code>topics</code> 数组中。相反，它在日志的 <code>data</code> 字段中以 bytes32/hex 格式返回。要解码它，您可以使用例如这个 Web3 类型转换器工具 并验证 <code>data</code> 是以 Wei 格式格式化的 1 DEV 代币。</p> <p>如果事件返回多个未索引的值，它们将按照事件发出它们的相同顺序一个接一个地附加。因此，每个值都是通过将数据解构为单独的 32 字节（或 64 个十六进制字符长）的部分来获得的。</p>"}, {"location": "builders/ethereum/json-rpc/pubsub/#using-wildcards-and-conditional-formatting", "title": "使用通配符和条件格式", "text": "<p>使用与上一节相同的示例，您可以通过以下代码订阅 Transfer 事件，同时按特定发送者进行过滤：</p> <p>js const { ethers } = require('ethers');</p> <p>const provider = new ethers.WebSocketProvider(   'wss://wss.api.moonbase.moonbeam.network' );</p> <p>const tokenAddress = 'INSERT_CONTRACT_ADDRESS'; const abi = [   'event Transfer(address indexed from, address indexed to, uint256 value)', ]; const contract = new ethers.Contract(tokenAddress, abi, provider);</p> <p>// Listen for Transfer events where the \"from\" address matches either entry below const fromAddresses = [   '0x44236223aB4291b93EEd10E4B511B37a398DEE55',   '0x8841701Dba3639B254D9CEe712E49D188A1e941e', ];</p> <p>const filter = contract.filters.Transfer(fromAddresses, null);</p> <p>const main = async () =&gt; {   console.log('🕔 Subscription set up. Waiting for new logs');</p> <p>contract.on(filter, (from, to, value, event) =&gt; {     console.log({       from,       to,       value: value.toString(),       blockNumber: event.blockNumber,       txHash: event.transactionHash,     });   }); };</p> <p>main().catch((error) =&gt; {   console.error(error);   process.exitCode = 1; });</p> <p>在此，第一个索引参数 (<code>from</code>) 被过滤到提供的地址列表，而 <code>to</code> 设置为 <code>null</code> 以充当通配符。合约过滤器会为您处理主题格式，因此您无需手动填充地址。</p>  node contract-events.js 0x51583364703338703441507476516675 {   address: '0xCc17F1FAEAab9Fe70Dc2D616Ea768a4336f3c506',   blockHash: '0xc7fa1139a35fb7a634514907feeb771e6aac7717906922a8589f029f709dcaef',   blockNumber: 16739,   data: '0x0000000000000000000000000000000000000000000000000de0b6b3a7640000',   logIndex: 0,   removed: false,   topics: [     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',     '0x00000000000000000000000044236223ab4291b93eed10e4b511b37a398dee55',     '0x0000000000000000000000008841701dba3639b254d9cee712e49d188a1e941e'   ],   transactionHash: '0x84154ea6ee44a4ffc446acd17579966691105694ce370f01de09d3a9f1b9506',   transactionIndex: 0,   transactionLogIndex: '0x0',   id: 'log_188dbef1' } {   address: '0xCc17F1FAEAab9Fe70Dc2D616Ea768a4336f3c506',   blockHash: '0xf21ded1bc724d2be74bc97c2045e31754d5326f3964796d62a1cba3e1d06203',   blockNumber: 16740,   data: '0x0000000000000000000000000000000000000000000000000de0b6b3a7640000',   logIndex: 0,   removed: false,   topics: [     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',     '0x0000000000000000000000008841701dba3639b254d9cee712e49d188a1e941e',     '0x00000000000000000000000044236223ab4291b93eed10e4b511b37a398dee55'   ],   transactionHash: '0x091b736bd31457a9b0725a98926dc3ebfb0608e71197c10d4d9ccb80de6d9ac3',   transactionIndex: 0,   transactionLogIndex: '0x0',   id: 'log_401c7925' } <p>如图所示，在您提供具有条件格式的两个地址后，您应该收到两个具有相同订阅的日志。来自不同地址的交易发出的事件不会向此订阅抛出任何日志。</p> <p>此示例展示了如何仅订阅特定合约的事件日志，但相同的方法适用于以下各节中介绍的其他订阅类型。</p>"}, {"location": "builders/ethereum/json-rpc/pubsub/#subscribe-to-incoming-pending-transactions", "title": "订阅传入的待处理交易", "text": "<p>要使用 Ethers.js 订阅待处理交易，您可以使用 WebSocket 提供程序和 <code>provider.on('pending')</code> 事件。将返回待处理交易的交易哈希，您可以选择使用 <code>provider.getTransaction(hash)</code> 获取完整的交易详细信息。</p>  node pending-tx.js 0x3350757676747651354e4553724e7269 0x5e3870e2c38274f4344cb86f3719dad84193b610a13b7e60c7ee65868b7ebc9a 0x54a28da6915df1ec83af4aafeab57364bbf4239d5ba71b596faabc76ba355eab <p>您可以尝试发送一笔交易，并验证订阅返回的交易哈希是否与您使用的开发工具或钱包返回的交易哈希相同。</p>"}, {"location": "builders/ethereum/json-rpc/pubsub/#subscribe-to-incoming-block-headers", "title": "订阅传入的区块头", "text": "<p>您还可以使用 <code>provider.on('block')</code> 订阅新的区块头，然后使用 <code>provider.getBlock(blockNumber)</code> 获取区块。此订阅提供传入的区块头，可用于跟踪区块链中的更改。</p>  node block-headers.js 0x6472456d30776b636c615a317158514e {   author: '0x0000000000000000000000000000000000000000',   difficulty: '0',   extraData: '0x',   gasLimit: 0,   gasUsed: 0,   hash: '0x1a28a9a7a176ed0d627f1bc521bda4eaca1e8186bf6642f089578067b713da43',   logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',   miner: '0x0000000000000000000000000000000000000000',   number: 16756,   parentHash: '0x89401a45d6226a5eb509fd3abfd90cb74aa5d7b5f747ef2506013d1afa36a418',   receiptsRoot: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',   sealFields: [     '0x0000000000000000000000000000000000000000000000000000000000000000',     '0x0000000000000000'   ],   sha3Uncles: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',   size: 509,   stateRoot: '0x92f3417ed90a81fecb2587fd820c1479f88f27228b8f508dfde601061d14371d',   timestamp: 1607710710159,   transactionsRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421' } <p>请注意，图像中仅显示了一个区块头。 这些消息是为每个生成的块显示的，因此它们可以快速填满终端。</p>"}, {"location": "builders/ethereum/json-rpc/pubsub/#check-if-a-node-is-synchronized-with-the-network", "title": "检查节点是否与网络同步", "text": "<p>使用 pubsub，还可以检查特定节点当前是否与网络同步。您可以使用首选库的底层 WebSocket 请求助手调用带有 <code>syncing</code> 的 <code>eth_subscribe</code> RPC。当 <code>syncing</code> 为 false 时，此订阅将返回一个布尔值；当 <code>syncing</code> 为 true 时，将返回一个描述同步进度的对象，如下所示。</p>  node syncing.js 0x3252615570630563274436770446371 {   syncing: true,   startingBlock: 120237,   currentBlock: 146952,   highestBlock: 2553484 } <p>Note</p> <p>Frontier 中的 pubsub 实现仍在积极开发中。当前版本允许用户订阅特定事件类型，但可能仍然存在一些限制。</p>"}, {"location": "builders/ethereum/libraries/ethersjs/", "title": "Ethers.js JavaScript 库", "text": ""}, {"location": "builders/ethereum/libraries/ethersjs/#introduction", "title": "简介", "text": "<p>Ethers.js 库提供了一组使用 JavaScript 与以太坊节点交互的工具，类似于 Web3.js。Moonbeam 有一个类似以太坊的 API，它与以太坊风格的 JSON-RPC 调用完全兼容。因此，开发人员可以利用这种兼容性，并使用 Ethers.js 库与 Moonbeam 节点交互，就像在以太坊上进行操作一样。有关 Ethers.js 的更多信息，请查看其文档站点。</p> <p>在本指南中，您将学习如何使用 Ethers.js 库在 Moonbase Alpha 上发送交易和部署合约。本指南适用于 Moonbeam、Moonriver 或 Moonbeam 开发节点。</p>"}, {"location": "builders/ethereum/libraries/ethersjs/#checking-prerequisites", "title": "检查先决条件", "text": "<p>对于本指南中的示例，您需要具备以下条件：</p> <ul> <li>一个有资金的帐户。     You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>--8&lt;-- 'text/_common/endpoint-examples-list-item.md'</li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"}, {"location": "builders/ethereum/libraries/ethersjs/#install-ethersjs", "title": "安装 Ethers.js", "text": "<p>要开始使用，你需要启动一个基本的 JavaScript 项目。首先，创建一个目录来存储你将在本指南中创建的所有文件，并使用以下命令初始化项目：</p> <pre><code>mkdir ethers-examples &amp;&amp; cd ethers-examples &amp;&amp; npm init --y\n</code></pre> <p>对于本指南，你需要安装 Ethers.js 库和 Solidity 编译器。要安装这两个 NPM 包，你可以运行以下命令：</p> npmyarn <pre><code>npm install ethers solc@0.8.30\n</code></pre> <pre><code>yarn add ethers solc@0.8.30\n</code></pre>"}, {"location": "builders/ethereum/libraries/ethersjs/#setting-up-the-ethers-provider", "title": "设置 Ethers Provider", "text": "<p>在本指南中，您将创建许多脚本，这些脚本提供不同的功能，例如发送交易、部署合约以及与已部署的合约进行交互。在大多数这些脚本中，您需要创建一个 Ethers 提供程序 以与网络进行交互。</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>要创建提供程序，您可以按照以下步骤操作：</p> <ol> <li>导入 <code>ethers</code> 库</li> <li>定义 <code>providerRPC</code> 对象，该对象可以包括您想要在上面发送交易的任何网络的网络配置。您将包括每个网络的 <code>name</code>、<code>rpc</code> 和 <code>chainId</code></li> <li>使用 <code>ethers.JsonRpcProvider</code> 方法创建 <code>provider</code></li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>// 1. Import ethers\nconst ethers = require('ethers');\n\n// 2. Define network configurations\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT', // Insert your RPC URL here\n    chainId: 1284, // 0x504 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n</code></pre> <pre><code>// 1. Import ethers\nconst ethers = require('ethers');\n\n// 2. Define network configurations\nconst providerRPC = {\n  moonriver: {\n    name: 'moonriver',\n    rpc: 'INSERT_RPC_API_ENDPOINT', // Insert your RPC URL here\n    chainId: 1285, // 0x505 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonriver.rpc, {\n  chainId: providerRPC.moonriver.chainId,\n  name: providerRPC.moonriver.name,\n});\n</code></pre> <pre><code>// 1. Import ethers\nconst ethers = require('ethers');\n\n// 2. Define network configurations\nconst providerRPC = {\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287, // 0x507 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n});\n</code></pre> <pre><code>// 1. Import ethers\nconst ethers = require('ethers');\n\n// 2. Define network configurations\nconst providerRPC = {\n  dev: {\n    name: 'moonbeam-development',\n    rpc: 'http://127.0.0.1:9944',\n    chainId: 1281, // 0x501 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.dev.rpc, {\n  chainId: providerRPC.dev.chainId,\n  name: providerRPC.dev.name,\n});\n</code></pre> <p>保存此代码段，因为您将在以下各节中使用的脚本中需要它。</p>"}, {"location": "builders/ethereum/libraries/ethersjs/#send-a-transaction", "title": "发送交易", "text": "<p>在本节中，您将创建几个脚本。第一个是检查您的帐户余额，然后再尝试发送交易。第二个脚本实际上会发送交易。</p> <p>您还可以使用余额脚本来检查交易发送后的帐户余额。</p>"}, {"location": "builders/ethereum/libraries/ethersjs/#deploy-a-contract", "title": "部署合约", "text": "<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (the default is <code>0</code>). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only and does not handle values wrapping around.</p>"}, {"location": "builders/ethereum/libraries/ethersjs/#compile-contract-script", "title": "编译合约脚本", "text": "<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.js</code> file by running:</p> <pre><code>touch compile.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>fs</code> and <code>solc</code> packages</li> <li>Using the <code>fs.readFileSync</code> function, you'll read and save the file contents of <code>Incrementer.sol</code> to <code>source</code></li> <li>Build the <code>input</code> object for the Solidity compiler by specifying the <code>language</code>, <code>sources</code>, and <code>settings</code> to be used</li> <li>Using the <code>input</code> object, you can compile the contract using <code>solc.compile</code></li> <li>Extract the compiled contract file and export it to be used in the deployment script</li> </ol> <p>// 1. Import packages const fs = require('fs'); const solc = require('solc');</p> <p>// 2. Get path and load contract const source = fs.readFileSync('Incrementer.sol', 'utf8');</p> <p>// 3. Create input object const input = {    language: 'Solidity',    sources: {       'Incrementer.sol': {          content: source,       },    },    settings: {       outputSelection: {          '': {             '': ['*'],          },       },    }, }; // 4. Compile the contract const tempFile = JSON.parse(solc.compile(JSON.stringify(input))); const contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];</p> <p>// 5. Export contract data module.exports = contractFile;</p>"}, {"location": "builders/ethereum/libraries/ethersjs/#deploy-contract-script", "title": "部署合约脚本", "text": "<p>有了编译 <code>Incrementer.sol</code> 合约的脚本，您就可以使用结果发送一个已签名的交易来部署它。为此，您可以创建一个名为 <code>deploy.js</code> 的部署脚本文件：</p> <pre><code>touch deploy.js\n</code></pre> <p>接下来，您将创建这个文件的脚本并完成以下步骤：</p> <ol> <li>从 <code>compile.js</code> 导入合约文件</li> <li>设置 Ethers 提供程序</li> <li>定义源账户的 <code>privateKey</code>。创建钱包实例需要私钥。注意：这仅用于示例目的。切勿将您的私钥存储在 JavaScript 文件中</li> <li>使用前面步骤中的 <code>privateKey</code> 和 <code>provider</code> 创建一个钱包。钱包实例用于签署交易</li> <li>加载已编译合约的合约 <code>bytecode</code> 和 <code>abi</code></li> <li>使用 <code>ethers.ContractFactory</code> 函数创建一个带有签名者的合约实例，提供 <code>abi</code>、<code>bytecode</code> 和 <code>wallet</code> 作为参数</li> <li>创建将用于部署合约的异步 <code>deploy</code> 函数</li> <li>在 <code>deploy</code> 函数中，使用 <code>incrementer</code> 合约实例调用 <code>deploy</code> 并传入初始值。对于此示例，您可以将初始值设置为 <code>5</code>。这将发送用于合约部署的交易。要等待交易收据，您可以使用合约部署交易的 <code>deployed</code> 方法</li> <li>最后，运行 <code>deploy</code> 函数</li> </ol> <pre><code>// 1. Import the contract file\nconst contractFile = require('./compile');\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\n\n// 4. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Load contract information\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// 6. Create contract instance with signer\nconst incrementer = new ethers.ContractFactory(abi, bytecode, wallet);\n\n// 7. Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${wallet.address}`);\n\n  // 8. Send tx (initial value set to 5) and wait for receipt\n  const contract = await incrementer.deploy(5);\n  const txReceipt = await contract.deploymentTransaction().wait();\n\n  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);\n};\n\n// 9. Call the deploy function\ndeploy();\n</code></pre> 查看完整脚本 <p>// Import ethers and compile const ethers = require('ethers'); const contractFile = require('./compile');</p> <p>// Define network configurations const providerRPC = {   development: {     name: 'moonbeam-development',     rpc: 'http://localhost:9944',     chainId: 1281,   },   moonbase: {     name: 'moonbase-alpha',     rpc: 'https://rpc.api.moonbase.moonbeam.network',     chainId: 1287,   }, };</p> <p>// Create ethers provider const provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {   chainId: providerRPC.moonbase.chainId,   name: providerRPC.moonbase.name, }); // Change to correct network</p> <p>// Define accounts and wallet const accountFrom = {   privateKey: 'INSERT_YOUR_PRIVATE_KEY', }; let wallet = new ethers.Wallet(accountFrom.privateKey, provider);</p> <p>// Load contract info const bytecode = contractFile.evm.bytecode.object; const abi = contractFile.abi;</p> <p>// Create contract instance with signer const incrementer = new ethers.ContractFactory(abi, bytecode, wallet);</p> <p>// Create deploy function const deploy = async () =&gt; {   console.log(<code>Attempting to deploy from account: ${wallet.address}</code>);</p> <p>// Send tx (initial value set to 5) and wait for receipt   const contract = await incrementer.deploy(5);   const txReceipt = await contract.deploymentTransaction().wait();</p> <p>console.log(<code>Contract deployed at address: ${txReceipt.contractAddress}</code>); };</p> <p>// Call the deploy function deploy();</p> <p>要运行该脚本，您可以在终端中输入以下命令：</p> <pre><code>node deploy.js\n</code></pre> <p>如果成功，合约的地址将显示在终端中。</p> node deploy.js Attempting to deploy from account: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Contract deployed at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A"}, {"location": "builders/ethereum/libraries/ethersjs/#read-contract-data", "title": "读取合约数据（调用方法）{: #read-contract-data }", "text": "<p>调用方法是一种不会修改合约存储（更改变量）的交互类型，这意味着不需要发送交易。它们只是读取已部署合约的各种存储变量。</p> <p>要开始，您可以创建一个文件并将其命名为 <code>get.js</code>：</p> <pre><code>touch get.js\n</code></pre> <p>然后，您可以按照以下步骤创建脚本：</p> <ol> <li>从 <code>compile.js</code> 文件导入 <code>abi</code></li> <li>设置 Ethers 提供程序</li> <li>使用已部署合约的地址创建 <code>contractAddress</code> 变量</li> <li>使用 <code>ethers.Contract</code> 函数创建一个合约实例，并传入 <code>contractAddress</code>、<code>abi</code> 和 <code>provider</code></li> <li>创建异步 <code>get</code> 函数</li> <li>使用合约实例调用合约的其中一个方法，并在必要时传入任何输入。对于此示例，您将调用不需要任何输入的 <code>number</code> 方法。您可以使用 <code>await</code>，它将在请求 promise resolve 后返回请求的值</li> <li>最后，调用 <code>get</code> 函数</li> </ol> <pre><code>// 1. Import the ABI\nconst { abi } = require('./compile');\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Contract address variable\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create contract instance\nconst incrementer = new ethers.Contract(contractAddress, abi, provider);\n\n// 5. Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // 6. Call contract\n  const data = await incrementer.number();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 7. Call get function\nget();\n</code></pre> 查看完整脚本 <p>// Import ethers and compile const ethers = require('ethers'); const { abi } = require('./compile');</p> <p>// Define network configurations const providerRPC = {   development: {     name: 'moonbeam-development',     rpc: 'http://localhost:9944',     chainId: 1281,   },   moonbase: {     name: 'moonbase-alpha',     rpc: 'https://rpc.api.moonbase.moonbeam.network',     chainId: 1287,   }, };</p> <p>const provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {   chainId: providerRPC.moonbase.chainId,   name: providerRPC.moonbase.name, }); // Change to correct network</p> <p>// Contract address variable const contractAddress = 'INSERT_CONTRACT_ADDRESS';</p> <p>// Create contract instance const incrementer = new ethers.Contract(contractAddress, abi, provider);</p> <p>// Create get function const get = async () =&gt; {   console.log(<code>Making a call to contract at address: ${contractAddress}</code>);</p> <p>// Call contract   const data = await incrementer.number();</p> <p>console.log(<code>The current number stored is: ${data}</code>); };</p> <p>// Call get function get();</p> <p>要运行该脚本，您可以在终端中输入以下命令：</p> <pre><code>node get.js\n</code></pre> <p>如果成功，该值将显示在终端中。</p>"}, {"location": "builders/ethereum/libraries/ethersjs/#interact-with-contract", "title": "与合约交互（发送方法）{: #interact-with-contract }", "text": "<p>发送方法是修改合约存储（更改变量）的交互类型，这意味着需要签名并发送交易。在本节中，您将创建两个脚本：一个用于递增，一个用于重置递增器。要开始，您可以为每个脚本创建一个文件，并将它们命名为 <code>increment.js</code> 和 <code>reset.js</code>：</p> <pre><code>touch increment.js reset.js\n</code></pre> <p>打开 <code>increment.js</code> 文件，并按照以下步骤创建脚本：</p> <ol> <li>从 <code>compile.js</code> 文件导入 <code>abi</code></li> <li>设置 Ethers 提供程序</li> <li>定义原始帐户的 <code>privateKey</code>、已部署合约的 <code>contractAddress</code> 和要递增的 <code>_value</code>。需要私钥来创建钱包实例。注意：这仅用于示例目的。切勿将您的私钥存储在 JavaScript 文件中</li> <li>使用上一步骤中的 <code>privateKey</code> 和 <code>provider</code> 创建一个钱包。钱包实例用于对交易进行签名</li> <li>使用 <code>ethers.Contract</code> 函数创建一个合约实例，并传入 <code>contractAddress</code>、<code>abi</code> 和 <code>provider</code></li> <li>创建异步 <code>increment</code> 函数</li> <li>使用合约实例调用合约的方法之一，并在必要时传入任何输入。对于此示例，您将调用 <code>increment</code> 方法，该方法需要要递增的值作为输入。您可以使用 <code>await</code>，它将在请求 promise 解析后返回所请求的值</li> <li>最后，调用 <code>increment</code> 函数</li> </ol> <pre><code>// 1. Import the contract ABI\nconst { abi } = require('./compile');\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// 4. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Create contract instance with signer\nconst incrementer = new ethers.Contract(contractAddress, abi, wallet);\n\n// 6. Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // 7. Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.increment(_value);\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// 8. Call the increment function\nincrement();\n</code></pre> 查看完整脚本 <p>// Import ethers and compile const ethers = require('ethers'); const { abi } = require('./compile');</p> <p>// Define network configurations const providerRPC = {   development: {     name: 'moonbeam-development',     rpc: 'http://localhost:9944',     chainId: 1281,   },   moonbase: {     name: 'moonbase-alpha',     rpc: 'https://rpc.api.moonbase.moonbeam.network',     chainId: 1287,   }, };</p> <p>// Create ethers provider const provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {   chainId: providerRPC.moonbase.chainId,   name: providerRPC.moonbase.name, }); // Change to correct network</p> <p>// Create variables const accountFrom = {   privateKey: 'INSERT_YOUR_PRIVATE_KEY', }; const contractAddress = 'INSERT_CONTRACT_ADDRESS'; const _value = 3;</p> <p>// Create wallet let wallet = new ethers.Wallet(accountFrom.privateKey, provider);</p> <p>// Create contract instance with signer const incrementer = new ethers.Contract(contractAddress, abi, wallet);</p> <p>// Create reset function const increment = async () =&gt; {   console.log(     <code>Calling the increment by ${_value} function in contract at address: ${contractAddress}</code>   );</p> <p>// Sign and send tx and wait for receipt   const createReceipt = await incrementer.increment(_value);   await createReceipt.wait();</p> <p>console.log(<code>Tx successful with hash: ${createReceipt.hash}</code>); };</p> <p>// Call the reset function increment();</p> <p>要运行该脚本，您可以在终端中输入以下命令：</p> <pre><code>node increment.js\n</code></pre> <p>如果成功，交易哈希将显示在终端中。您可以将 <code>get.js</code> 脚本与 <code>increment.js</code> 脚本一起使用，以确保值按预期更改：</p> node get.js Making a call to contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A The current number stored is: 5 node increment.js Calling the increment by 3 function in contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A Tx successful with hash: 0xc7fe935db03cfacf56c5649cd79a566d1a7b68417f904f0095a1b1c203875bf2 node get.js Making a call to contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A The current number stored is: 8 <p>接下来，您可以打开 <code>reset.js</code> 文件，并按照以下步骤创建脚本：</p> <ol> <li>从 <code>compile.js</code> 文件导入 <code>abi</code></li> <li>设置 Ethers 提供程序</li> <li>定义原始帐户的 <code>privateKey</code> 和已部署合约的 <code>contractAddress</code>。需要私钥来创建钱包实例。注意：这仅用于示例目的。切勿将您的私钥存储在 JavaScript 文件中</li> <li>使用上一步骤中的 <code>privateKey</code> 和 <code>provider</code> 创建一个钱包。钱包实例用于对交易进行签名</li> <li>使用 <code>ethers.Contract</code> 函数创建一个合约实例，并传入 <code>contractAddress</code>、<code>abi</code> 和 <code>provider</code></li> <li>创建异步 <code>reset</code> 函数</li> <li>使用合约实例调用合约的方法之一，并在必要时传入任何输入。对于此示例，您将调用 <code>reset</code> 方法，该方法不需要任何输入。您可以使用 <code>await</code>，它将在请求 promise 解析后返回所请求的值</li> <li>最后，调用 <code>reset</code> 函数</li> </ol> <pre><code>// 1. Import the contract ABI\nconst { abi } = require('./compile');\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Create variables\nconst accountFrom = {\nprivateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Create contract instance with signer\nconst incrementer = new ethers.Contract(contractAddress, abi, wallet);\n\n// 6. Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // 7. sign and send tx and wait for receipt\n  const createReceipt = await incrementer.reset();\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// 8. Call the reset function\nreset();\n</code></pre> 查看完整脚本 <pre><code>// Import ethers and compile\nconst ethers = require('ethers');\nconst { abi } = require('./compile');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create contract instance with signer\nconst incrementer = new ethers.Contract(contractAddress, abi, wallet);\n\n// Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.reset();\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the reset function\nreset();\n</code></pre> <p>要运行该脚本，您可以在终端中输入以下命令：</p> <pre><code>node reset.js\n</code></pre> <p>如果成功，交易哈希将显示在终端中。您可以将 <code>get.js</code> 脚本与 <code>reset.js</code> 脚本一起使用，以确保值按预期更改：</p> node get.js Making a call to contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A The current number stored is: 8 node reset.js Calling the reset function in contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A Tx successful with hash: 0xc452d21d8c2be6b81aadab7414103d68149c94a6399149ab8b79a58f0a3b5db7 node get.js Making a call to contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A The current number stored is: 0    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/ethereum/libraries/viem/", "title": "viem TypeScript Ethereum库", "text": ""}, {"location": "builders/ethereum/libraries/viem/#introduction", "title": "介绍", "text": "<p>viem 是一个模块化的 TypeScript 库，允许开发人员通过 JSON-RPC API 与抽象进行交互，从而轻松地与 Ethereum 节点进行交互。由于 Moonbeam 具有类似于 Ethereum 的 API，并且完全兼容 Ethereum 风格的 JSON RPC 调用，因此开发人员可以利用此兼容性与 Moonbeam 节点进行交互。有关 viem 的更多信息，请查看他们的文档站点。</p> <p>在本指南中，您将学习如何使用 viem 在 Moonbase Alpha TestNet 上发送交易和部署合约。本指南适用于 Moonbeam、Moonriver 或 Moonbeam 开发节点。</p>"}, {"location": "builders/ethereum/libraries/viem/#checking-prerequisites", "title": "检查先决条件", "text": "<p>对于本指南中的示例，您需要具备以下条件：</p> <ul> <li>拥有资金的帐户。     You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>--8&lt;-- 'text/_common/endpoint-examples-list-item.md'</li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"}, {"location": "builders/ethereum/libraries/viem/#installing-viem", "title": "安装 viem", "text": "<p>要开始使用，您需要创建一个基本的 TypeScript 项目。首先，创建一个目录来存储您将在本指南中创建的所有文件，并使用以下命令初始化项目：</p> <pre><code>mkdir viem-examples &amp;&amp; cd viem-examples &amp;&amp; npm init --y\n</code></pre> <p>对于本指南，您需要安装 viem 库和 Solidity 编译器。要安装这两个软件包，您可以运行以下命令：</p> npmyarn <pre><code>npm install typescript ts-node viem solc@0.8.30\n</code></pre> <pre><code>yarn add typescript ts-node viem solc@0.8.30\n</code></pre> <p>您可以通过运行以下命令来创建 TypeScript 配置文件：</p> <pre><code>npx tsc --init\n</code></pre> <p>Note</p> <p>本教程是使用 Node.js v18.18.0 创建的。</p>"}, {"location": "builders/ethereum/libraries/viem/#setting-up-a-viem-provider", "title": "设置 viem 客户端（Provider）", "text": "<p>在本指南中，你将创建许多提供不同功能的脚本，例如发送交易、部署合约以及与已部署的合约进行交互。在大多数这些脚本中，你需要创建一个 viem 客户端 以与网络进行交互。</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>你可以使用 <code>createPublicClient</code> 函数创建一个 viem 客户端来读取链数据，例如余额或合约数据，或者你可以使用 <code>createWalletClient</code> 函数创建一个 viem 客户端来写入链数据，例如发送交易。</p>"}, {"location": "builders/ethereum/libraries/viem/#for-reading-chain-data", "title": "用于读取链数据", "text": "<p>要创建用于读取链数据的客户端，您可以采取以下步骤：</p> <ol> <li>从 <code>viem</code> 导入 <code>createPublicClient</code> 和 <code>http</code> 函数，并从 <code>viem/chains</code> 导入您要与之交互的网络。链可以是以下任何一种：<code>moonbeam</code>、<code>moonriver</code> 或 <code>moonbaseAlpha</code></li> <li>使用 <code>createPublicClient</code> 函数创建 <code>client</code>，并传入网络和 HTTP RPC 端点</li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>import { createPublicClient, http } from 'viem';\nimport { moonbeam } from 'viem/chains';\n\nconst rpcUrl = 'INSERT_RPC_API_ENDPOINT'\nconst publicClient = createPublicClient({\n  chain: moonbeam,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createPublicClient, http } from 'viem';\nimport { moonriver } from 'viem/chains';\n\nconst rpcUrl = 'INSERT_RPC_API_ENDPOINT'\nconst publicClient = createPublicClient({\n  chain: moonriver,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createPublicClient, http } from 'viem';\nimport { moonbaseAlpha } from 'viem/chains';\n\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network'\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createPublicClient, http } from 'viem';\nimport { moonbeamDev } from 'viem/chains';\n\nconst rpcUrl = 'http://127.0.0.1:9944'\nconst publicClient = createPublicClient({\n  chain: moonbeamDev,\n  transport: http(rpcUrl),\n})\n</code></pre>"}, {"location": "builders/ethereum/libraries/viem/#for-writing-chain-data", "title": "用于写入链数据", "text": "<p>要创建一个用于写入链数据的客户端，您可以采取以下步骤：</p> <ol> <li>从 <code>viem</code> 导入 <code>createWalletClient</code> 和 <code>http</code> 函数，从 <code>viem/accounts</code> 导入 <code>privateKeyToAccount</code> 函数以通过私钥加载您的帐户，并从 <code>viem/chains</code> 导入您要与之交互的网络。链可以是以下任何一种：<code>moonbeam</code>、<code>moonriver</code> 或 <code>moonbaseAlpha</code></li> <li>使用 <code>privateKeyToAccount</code> 函数创建您的帐户</li> <li>使用 <code>createWalletClient</code> 函数创建 <code>client</code>，并传入帐户、网络和 HTTP RPC 端点</li> </ol> <p>Remember</p> <p>这仅用于演示目的。切勿将您的私钥存储在 TypeScript 文件中。</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>import { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbeam } from 'viem/chains';\n\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'INSERT_RPC_API_ENDPOINT'\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbeam,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonriver } from 'viem/chains';\n\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'INSERT_RPC_API_ENDPOINT'\nconst walletClient = createWalletClient({\n  account,\n  chain: moonriver,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbaseAlpha } from 'viem/chains';\n\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network'\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbeamDev } from 'viem/chains';\n\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'http://127.0.0.1:9944'\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbeamDev,\n  transport: http(rpcUrl),\n});\n</code></pre> <p>Note</p> <p>要与基于浏览器的钱包进行交互，您可以使用以下代码创建一个帐户：</p> <pre><code>const [account] = await window.ethereum.request({\n  method: 'eth_requestAccounts',\n});\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbeam,\n  transport: custom(window.ethereum),\n});\n</code></pre>"}, {"location": "builders/ethereum/libraries/viem/#send-transaction", "title": "发送交易", "text": "<p>在本节中，您将创建几个脚本。第一个脚本用于在尝试发送交易之前检查您帐户的余额。第二个脚本实际上将发送交易。</p> <p>您还可以使用余额脚本来检查交易发送后的帐户余额。</p>"}, {"location": "builders/ethereum/libraries/viem/#check-balances-script", "title": "检查余额脚本", "text": "<p>您只需要一个文件即可在发送交易之前和之后检查两个地址的余额。要开始，您可以通过运行以下命令创建一个 <code>balances.ts</code> 文件：</p> <pre><code>touch balances.ts\n</code></pre> <p>接下来，您将为此文件创建脚本并完成以下步骤：</p> <ol> <li>更新您的导入，以包括来自 <code>viem</code> 的 <code>createPublicClient</code>、<code>http</code> 和 <code>formatEther</code> 函数，以及您想要从 <code>viem/chains</code> 交互的网络</li> <li>设置一个公共 viem 客户端，该客户端可用于读取链数据，例如帐户余额</li> <li>定义 <code>addressFrom</code> 和 <code>addressTo</code> 变量</li> <li>创建包装 <code>publicClient.getBalance</code> 方法的异步 <code>balances</code> 函数</li> <li>使用 <code>publicClient.getBalance</code> 函数获取 <code>addressFrom</code> 和 <code>addressTo</code> 地址的余额。您还可以利用 <code>formatEther</code> 函数将余额转换为更易于阅读的数字（以 GLMR、MOVR 或 DEV 为单位）</li> <li>最后，运行 <code>balances</code> 函数</li> </ol> <p>// 1. Imports import { createPublicClient, http, formatEther } from 'viem'; import { moonbaseAlpha } from 'viem/chains';</p> <p>// 2. Create a public client for reading chain data const rpcUrl = 'https://rpc.api.moonbase.moonbeam.network'; const publicClient = createPublicClient({   chain: moonbaseAlpha,   transport: http(rpcUrl), });</p> <p>// 3. Create address variables const addressFrom = 'INSERT_FROM_ADDRESS'; const addressTo = 'INSERT_TO_ADDRESS';</p> <p>// 4. Create balances function const balances = async () =&gt; {   // 5. Fetch balances   const balanceFrom = formatEther(     await publicClient.getBalance({ address: addressFrom })   );   const balanceTo = formatEther(     await publicClient.getBalance({ address: addressTo })   );</p> <p>console.log(<code>The balance of ${addressFrom} is: ${balanceFrom} DEV</code>);   console.log(<code>The balance of ${addressTo} is: ${balanceTo} DEV</code>); };</p> <p>// 6. Call the balances function balances();</p> <p>要运行脚本并获取帐户余额，您可以运行以下命令：</p> <pre><code>npx ts-node balances.ts\n</code></pre> <p>如果成功，则原始地址和接收地址的余额将以 DEV 形式显示在您的终端中。</p> npx ts-node balances.ts The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3601.72 DEV The balance of 0x78F34038c82638E0563b974246D421154C26b004 is: 0 DEV"}, {"location": "builders/ethereum/libraries/viem/#deploy-contract", "title": "部署合约", "text": "<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (the default is <code>0</code>). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only and does not handle values wrapping around.</p>"}, {"location": "builders/ethereum/libraries/viem/#compile-contract-script", "title": "编译合约脚本", "text": "<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.ts</code> file by running:</p> <pre><code>touch compile.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>fs</code> and <code>solc</code> packages</li> <li>Using the <code>fs.readFileSync</code> function, you'll read and save the file contents of <code>Incrementer.sol</code> to <code>source</code></li> <li>Build the <code>input</code> object for the Solidity compiler by specifying the <code>language</code>, <code>sources</code>, and <code>settings</code> to be used</li> <li>Using the <code>input</code> object, you can compile the contract using <code>solc.compile</code></li> <li>Extract the compiled contract file and export it to be used in the deployment script</li> </ol> <p>// 1. Import packages const fs = require('fs'); const solc = require('solc');</p> <p>// 2. Get path and load contract const source = fs.readFileSync('Incrementer.sol', 'utf8');</p> <p>// 3. Create input object const input = {    language: 'Solidity',    sources: {       'Incrementer.sol': {          content: source,       },    },    settings: {       outputSelection: {          '': {             '': ['*'],          },       },    }, }; // 4. Compile the contract const tempFile = JSON.parse(solc.compile(JSON.stringify(input))); const contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];</p> <p>// 5. Export contract data export default contractFile;</p>"}, {"location": "builders/ethereum/libraries/viem/#deploy-contract-script", "title": "部署合约脚本", "text": "<p>有了用于编译 <code>Incrementer.sol</code> 合约的脚本，您就可以使用结果发送已签名的交易来部署它。为此，您可以创建一个名为 <code>deploy.ts</code> 的部署脚本文件：</p> <pre><code>touch deploy.ts\n</code></pre> <p>接下来，您将为此文件创建脚本并完成以下步骤：</p> <ol> <li>更新您的导入，以包括来自 <code>viem</code> 的 <code>createPublicClient</code>、<code>createWalletClient</code> 和 <code>http</code> 函数，来自 <code>viem/accounts</code> 的 <code>privateKeyToAccount</code> 函数，您要与之交互的来自 <code>viem/chains</code> 的网络，以及您在 编译合约脚本 部分中创建的 <code>compile.ts</code> 文件中的 <code>contractFile</code>。</li> <li>设置一个 viem 钱包客户端 以写入链数据，该客户端将与您的私钥一起用于部署 <code>Incrementer</code> 合约。注意：这仅用于示例目的。切勿在 TypeScript 文件中存储您的私钥</li> <li>设置一个公共 viem 客户端 以读取链数据，该客户端将用于读取部署的交易收据</li> <li>加载已编译合约的合约 <code>bytecode</code> 和 <code>abi</code></li> <li>创建异步 <code>deploy</code> 函数，该函数将用于通过 <code>walletClient.deployContract</code> 方法部署合约</li> <li>使用 <code>walletClient.deployContract</code> 函数来签名和发送交易。您需要传入合约的 ABI 和字节码、用于部署交易的帐户以及增量器的初始值。使用 <code>await</code> 等待，直到处理完交易并返回交易哈希</li> <li>使用 <code>publicClient.readContract</code> 函数获取部署的交易收据。使用 <code>await</code> 等待，直到处理完交易并返回合约地址</li> <li>最后，运行 <code>deploy</code> 函数</li> </ol> <p>// 1. Update imports import { createPublicClient, createWalletClient, http } from 'viem'; import { privateKeyToAccount } from 'viem/accounts'; import { moonbaseAlpha } from 'viem/chains'; import contractFile from './compile';</p> <p>// 2. Create a wallet client for writing chain data // The private key must be prepended with <code>0x</code> to avoid errors const account = privateKeyToAccount('INSERT_PRIVATE_KEY'); const rpcUrl = 'https://rpc.api.moonbase.moonbeam.network'; const walletClient = createWalletClient({   account,   chain: moonbaseAlpha,   transport: http(rpcUrl), }); // 3. Create a public client for reading chain data const publicClient = createPublicClient({   chain: moonbaseAlpha,   transport: http(rpcUrl), });</p> <p>// 4. Load contract information const bytecode = contractFile.evm.bytecode.object; const abi = contractFile.abi; const _initialNumber = 5;</p> <p>// 5. Create deploy function const deploy = async () =&gt; {   console.log(<code>Attempting to deploy from account: ${account.address}</code>);</p> <p>// 6. Send tx (initial value set to 5)   const contract = await walletClient.deployContract({     abi,     account,     bytecode,     args: [_initialNumber],   });</p> <p>// 7. Get the transaction receipt for the deployment   const transaction = await publicClient.waitForTransactionReceipt({     hash: contract,   });</p> <p>console.log(<code>Contract deployed at address: ${transaction.contractAddress}</code>); };</p> <p>// 8. Call the deploy function deploy();</p> <p>要运行脚本，您可以在终端中输入以下命令：</p> <pre><code>npx ts-node deploy.ts\n</code></pre> <p>如果成功，合约的地址将显示在终端中。</p> npx ts-node deploy.ts Attempting to deploy from account: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Contract deployed at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9"}, {"location": "builders/ethereum/libraries/viem/#interact-with-contract", "title": "与合约交互（发送方法）{: #interact-with-contract }", "text": "<p>发送方法是修改合约存储（更改变量）的交互类型，这意味着需要签名并发送交易。在本节中，您将创建两个脚本：一个用于递增，一个用于重置递增器。要开始，您可以为每个脚本创建一个文件，并将它们命名为 <code>increment.ts</code> 和 <code>reset.ts</code>：</p> <pre><code>touch increment.ts reset.ts\n</code></pre> <p>打开 <code>increment.ts</code> 文件，并按照以下步骤创建脚本：</p> <ol> <li>更新您的导入，以包括来自 <code>viem</code> 的 <code>createWalletClient</code> 和 <code>http</code> 函数、您想要与之交互的来自 <code>viem/chains</code> 的网络，以及您在 编译合约脚本 部分中创建的 <code>compile.ts</code> 文件中的 <code>contractFile</code></li> <li>设置一个 viem 钱包客户端 用于写入链数据，它将与您的私钥一起用于发送交易。注意：这仅用于示例目的。切勿将您的私钥存储在 TypeScript 文件中</li> <li>设置一个公共 viem 客户端 用于读取链数据，它将用于等待交易收据</li> <li>使用已部署合约的地址创建 <code>contractAddress</code> 变量，使用 <code>compile.ts</code> 文件中的 <code>contractFile</code> 创建 <code>abi</code> 变量，并创建 <code>_value</code> 以按其递增合约</li> <li>创建异步 <code>increment</code> 函数</li> <li>使用 <code>walletClient.writeContract</code> 函数调用合约，传入 <code>abi</code>、函数名称、<code>contractAddress</code> 和 <code>_value</code>。您可以使用 <code>await</code>，它将在请求 Promise 解析后返回交易哈希</li> <li>使用 <code>publicClient.waitForTransactionReceipt</code> 函数等待交易收据，表示交易已完成。如果您需要交易收据，或者如果您在此脚本之后直接运行 <code>get.ts</code> 脚本以检查当前数字是否已按预期更新，这将特别有用</li> <li>最后，调用 <code>increment</code> 函数</li> </ol> <p>// 1. Update imports import { createPublicClient, createWalletClient, http } from 'viem'; import { privateKeyToAccount } from 'viem/accounts'; import { moonbaseAlpha } from 'viem/chains'; import contractFile from './compile';</p> <p>// 2. Create a wallet client for writing chain data const account = privateKeyToAccount('INSERT_PRIVATE_KEY'); const rpcUrl = 'https://rpc.api.moonbase.moonbeam.network'; const walletClient = createWalletClient({   account,   chain: moonbaseAlpha,   transport: http(rpcUrl), });</p> <p>// 3. Create a public client for reading chain data const publicClient = createPublicClient({   chain: moonbaseAlpha,   transport: http(rpcUrl), });</p> <p>// 4. Create contract variables const contractAddress = 'INSERT_CONTRACT_ADDRESS'; const abi = contractFile.abi; const _value = 3;</p> <p>// 5. Create increment function const increment = async () =&gt; {   console.log(     <code>Calling the increment by ${_value} function in contract at address: ${contractAddress}</code>   );   // 6. Call contract   const hash = await walletClient.writeContract({     abi,     functionName: 'increment',     address: contractAddress,     args: [_value],   });</p> <p>// 7. Wait for the transaction receipt   await publicClient.waitForTransactionReceipt({     hash,   });</p> <p>console.log(<code>Tx successful with hash: ${hash}</code>); };</p> <p>// 8. Call increment function increment();</p> <p>要运行脚本，您可以在终端中输入以下命令：</p> <pre><code>npx ts-node increment.ts\n</code></pre> <p>如果成功，交易哈希将显示在终端中。您可以将 <code>get.ts</code> 脚本与 <code>increment.ts</code> 脚本一起使用，以确保该值按预期更改。</p> npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 5 npx ts-node increment.ts Calling the increment by 3 function in contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 Tx successful with hash: 0x041c9767e7a96f60f372341647430560569fd6ff64a27b4b9c6241e55dde57e1 npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 8 <p>接下来，您可以打开 <code>reset.ts</code> 文件，并按照以下步骤创建脚本：</p> <ol> <li>更新您的导入，以包括来自 <code>viem</code> 的 <code>createWalletClient</code> 和 <code>http</code> 函数、您想要与之交互的来自 <code>viem/chains</code> 的网络，以及您在 编译合约脚本 部分中创建的 <code>compile.ts</code> 文件中的 <code>contractFile</code></li> <li>设置一个 viem 钱包客户端 用于写入链数据，它将与您的私钥一起用于发送交易。注意：这仅用于示例目的。切勿将您的私钥存储在 TypeScript 文件中</li> <li>设置一个公共 viem 客户端 用于读取链数据，它将用于等待交易收据</li> <li>使用已部署合约的地址创建 <code>contractAddress</code> 变量，并使用 <code>compile.ts</code> 文件中的 <code>contractFile</code> 创建 <code>abi</code> 变量，以按其递增合约</li> <li>创建异步 <code>reset</code> 函数</li> <li>使用 <code>walletClient.writeContract</code> 函数调用合约，传入 <code>abi</code>、函数名称、<code>contractAddress</code> 和一个空数组作为参数。您可以使用 <code>await</code>，它将在请求 Promise 解析后返回交易哈希</li> <li>使用 <code>publicClient.waitForTransactionReceipt</code> 函数等待交易收据，表示交易已完成。如果您需要交易收据，或者如果您在此脚本之后直接运行 <code>get.ts</code> 脚本以检查当前数字是否已重置为 <code>0</code>，这将特别有用</li> <li>最后，调用 <code>reset</code> 函数</li> </ol> <p>// 1. Update imports import { createPublicClient, createWalletClient, http } from 'viem'; import { privateKeyToAccount } from 'viem/accounts'; import { moonbaseAlpha } from 'viem/chains'; import contractFile from './compile';</p> <p>// 2. Create a wallet client for writing chain data const account = privateKeyToAccount('INSERT_PRIVATE_KEY'); const rpcUrl = 'https://rpc.api.moonbase.moonbeam.network'; const walletClient = createWalletClient({   account,   chain: moonbaseAlpha,   transport: http(rpcUrl), });</p> <p>// 3. Create a public client for reading chain data const publicClient = createPublicClient({   chain: moonbaseAlpha,   transport: http(rpcUrl), });</p> <p>// 4. Create contract variables const contractAddress = 'INSERT_CONTRACT_ADDRESS'; const abi = contractFile.abi;</p> <p>// 5. Create reset function const reset = async () =&gt; {   console.log(     <code>Calling the reset function in contract at address: ${contractAddress}</code>   );</p> <p>// 6. Call contract   const hash = await walletClient.writeContract({     abi,     functionName: 'reset',     address: contractAddress,     args: [],   });</p> <p>// 7. Wait for the transaction receipt   await publicClient.waitForTransactionReceipt({     hash,   });</p> <p>console.log(<code>Tx successful with hash: ${hash}</code>); };</p> <p>// 8. Call reset function reset();</p> <p>要运行脚本，您可以在终端中输入以下命令：</p> <pre><code>npx ts-node reset.ts\n</code></pre> <p>如果成功，交易哈希将显示在终端中。您可以将 <code>get.ts</code> 脚本与 <code>reset.ts</code> 脚本一起使用，以确保该值按预期更改。</p> npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 8 npx ts-node reset.ts Calling the reset function in contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 Tx successful with hash: 0xc1a772131ccf6a03675ff3e88798a6e70a99e145eeb0e98170ff2e3345ee14a7 npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 0    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/ethereum/libraries/web3py/", "title": "Web3.py Python库", "text": ""}, {"location": "builders/ethereum/libraries/web3py/#introduction", "title": "介绍", "text": "<p>Web3.py 是一组库，允许开发人员使用 Python 通过 HTTP、IPC 或 WebSocket 协议与以太坊节点进行交互。Moonbeam 有一个类似于以太坊的 API 可用，它与以太坊风格的 JSON-RPC 调用完全兼容。因此，开发人员可以利用这种兼容性，并使用 Web3.py 库与 Moonbeam 节点交互，就像在以太坊上进行交互一样。</p> <p>在本指南中，您将学习如何使用 Web3.py 库在 Moonbase Alpha 上发送交易和部署合约。本指南可以适用于 Moonbeam、Moonriver 或 Moonbeam 开发节点。</p>"}, {"location": "builders/ethereum/libraries/web3py/#checking-prerequisites", "title": "检查先决条件", "text": "<p>对于本指南中的示例，您需要具备以下条件：</p> <ul> <li>一个有资金的帐户。</li> </ul> <p>You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</p> <ul> <li>--8&lt;-- 'text/_common/endpoint-examples-list-item.md'</li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"}, {"location": "builders/ethereum/libraries/web3py/#create-a-python-project", "title": "创建 Python 项目", "text": "<p>首先，您可以创建一个目录来存储您将在本指南中创建的所有文件：</p> <pre><code>mkdir web3-examples &amp;&amp; cd web3-examples\n</code></pre> <p>对于本指南，您需要安装 Web3.py 库和 Solidity 编译器。 要安装这两个软件包，您可以运行以下命令：</p> <pre><code>pip3 install web3 py-solc-x solc-select\n</code></pre>"}, {"location": "builders/ethereum/libraries/web3py/#setup-web3-with-moonbeam", "title": "使用 Moonbeam 设置 Web3.py", "text": "<p>在本指南中，您将创建许多提供不同功能的脚本，例如发送交易、部署合约以及与已部署的合约进行交互。在大多数这些脚本中，您需要创建一个 Web3.py provider 来与网络交互。</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>要创建一个提供程序，您可以按照以下步骤操作：</p> <ol> <li>导入 <code>web3</code> 库</li> <li>使用 <code>Web3(Web3.HTTPProvider())</code> 方法创建 <code>web3</code> 提供程序，并提供端点 URL</li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nweb3 = Web3(Web3.HTTPProvider(\"INSERT_RPC_API_ENDPOINT\")) # Insert your RPC URL here\n</code></pre> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nweb3 = Web3(Web3.HTTPProvider(\"INSERT_RPC_API_ENDPOINT\")) # Insert your RPC URL here\n</code></pre> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n</code></pre> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nweb3 = Web3(Web3.HTTPProvider(\"http://127.0.0.1:9944\"))\n</code></pre> <p>保存此代码段，因为您将在以下部分中使用的脚本中用到它。</p>"}, {"location": "builders/ethereum/libraries/web3py/#send-a-transaction", "title": "发送交易", "text": "<p>在本节中，您将创建几个脚本。第一个脚本是在尝试发送交易之前检查您的帐户余额。第二个脚本将实际发送交易。</p> <p>您还可以使用余额脚本在发送交易后检查帐户余额。</p>"}, {"location": "builders/ethereum/libraries/web3py/#check-balances-script", "title": "检查余额脚本", "text": "<p>您只需要一个文件来检查交易发送前后两个地址的余额。要开始，您可以运行以下命令创建一个 <code>balances.py</code> 文件：</p> <pre><code>touch balances.py\n</code></pre> <p>接下来，您将为此文件创建脚本并完成以下步骤：</p> <ol> <li>设置 Web3 提供程序</li> <li>定义 <code>address_from</code> 和 <code>address_to</code> 变量</li> <li>使用 <code>web3.eth.get_balance</code> 函数获取帐户余额，并使用 <code>web3.from_wei</code> 格式化结果</li> </ol> <p>from web3 import Web3</p>"}, {"location": "builders/ethereum/libraries/web3py/#1-add-the-web3-provider-logic-here", "title": "1. Add the Web3 provider logic here:", "text": "<p>provider_rpc = {     \"development\": \"http://localhost:9944\",     \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\", } web3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network</p>"}, {"location": "builders/ethereum/libraries/web3py/#2-create-address-variables", "title": "2. Create address variables", "text": "<p>address_from = 'INSERT_FROM_ADDRESS' address_to = 'INSERT_TO_ADDRESS'</p>"}, {"location": "builders/ethereum/libraries/web3py/#3-fetch-balance-data", "title": "3. Fetch balance data", "text": "<p>balance_from = web3.from_wei(     web3.eth.get_balance(Web3.to_checksum_address(address_from)), \"ether\" ) balance_to = web3.from_wei(     web3.eth.get_balance(Web3.to_checksum_address(address_to)), \"ether\" )</p> <p>print(f\"The balance of { address_from } is: { balance_from } DEV\") print(f\"The balance of { address_to } is: { balance_to } DEV\")</p> <p>要运行脚本并获取帐户余额，您可以运行以下命令：</p> <pre><code>python3 balances.py\n</code></pre> <p>如果成功，原始地址和接收地址的余额将以 ETH 显示在您的终端中。</p>"}, {"location": "builders/ethereum/libraries/web3py/#deploy-a-contract", "title": "部署合约", "text": "<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (the default is <code>0</code>). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only and does not handle values wrapping around.</p>"}, {"location": "builders/ethereum/libraries/web3py/#deploy-contract-script", "title": "部署合约脚本", "text": "<p>有了用于编译 <code>Incrementer.sol</code> 合约的脚本，您可以使用结果发送一个已签名的交易来部署它。为此，您可以创建一个名为 <code>deploy.py</code> 的部署脚本文件：</p> <pre><code>touch deploy.py\n</code></pre> <p>接下来，您将为该文件创建脚本并完成以下步骤：</p> <ol> <li>添加导入，包括 Web3.py 以及 <code>Incrementer.sol</code> 合约的 ABI 和字节码</li> <li>设置 Web3 提供程序</li> <li>定义 <code>account_from</code>，包括 <code>private_key</code>。私钥是签署交易的必需项。注意：这仅用于示例目的。切勿将您的私钥存储在 Python 文件中</li> <li>使用 <code>web3.eth.contract</code> 函数创建一个合约实例，并传入合约的 ABI 和字节码</li> <li>使用合约实例构建一个构造函数交易，并传入要递增的值。对于此示例，您可以使用 <code>5</code>。然后，您将使用 <code>build_transaction</code> 函数传入交易信息，包括 <code>from</code> 地址和发送者的 <code>nonce</code>。要获取 <code>nonce</code>，您可以使用 <code>web3.eth.get_transaction_count</code> 函数</li> <li>使用 <code>web3.eth.account.sign_transaction</code> 函数签署交易，并传入构造函数交易和发送者的 <code>private_key</code></li> <li>使用已签名的交易，您可以使用 <code>web3.eth.send_raw_transaction</code> 函数发送它，并使用 <code>web3.eth.wait_for_transaction_receipt</code> 函数等待交易回执</li> </ol>"}, {"location": "builders/ethereum/libraries/web3py/#1-add-imports", "title": "1. Add imports", "text": "<p>from compile import abi, bytecode from web3 import Web3</p>"}, {"location": "builders/ethereum/libraries/web3py/#2-add-the-web3-provider-logic-here", "title": "2. Add the Web3 provider logic here:", "text": "<p>provider_rpc = {     \"development\": \"http://localhost:9944\",     \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\", } web3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network</p>"}, {"location": "builders/ethereum/libraries/web3py/#3-create-address-variable", "title": "3. Create address variable", "text": "<p>account_from = {     'private_key': 'INSERT_YOUR_PRIVATE_KEY',     'address': 'INSERT_PUBLIC_ADDRESS_OF_PK', }</p> <p>print(f'Attempting to deploy from account: { account_from[\"address\"] }')</p>"}, {"location": "builders/ethereum/libraries/web3py/#4-create-contract-instance", "title": "4. Create contract instance", "text": "<p>Incrementer = web3.eth.contract(abi=abi, bytecode=bytecode)</p>"}, {"location": "builders/ethereum/libraries/web3py/#5-build-constructor-tx", "title": "5. Build constructor tx", "text": "<p>construct_txn = Incrementer.constructor(5).build_transaction(     {         \"from\": Web3.to_checksum_address(account_from[\"address\"]),         \"nonce\": web3.eth.get_transaction_count(             Web3.to_checksum_address(account_from[\"address\"])         ),     } )</p>"}, {"location": "builders/ethereum/libraries/web3py/#6-sign-tx-with-pk", "title": "6. Sign tx with PK", "text": "<p>tx_create = web3.eth.account.sign_transaction(     construct_txn, account_from[\"private_key\"] )</p>"}, {"location": "builders/ethereum/libraries/web3py/#7-send-tx-and-wait-for-receipt", "title": "7. Send tx and wait for receipt", "text": "<p>tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction) tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)</p> <p>print(f\"Contract deployed at address: { tx_receipt.contractAddress }\")</p> <p>要运行该脚本，您可以在终端中输入以下命令：</p> <pre><code>python3 deploy.py\n</code></pre> <p>如果成功，合约的地址将显示在终端中。</p> python3 deploy.py Attempting to deploy from account: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Contract deployed at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08"}, {"location": "builders/ethereum/libraries/web3py/#interact-with-contract", "title": "与合约交互（发送方法）{: #interact-with-contract }", "text": "<p>发送方法是修改合约存储（更改变量）的交互类型，这意味着需要签名并发送交易。在本节中，您将创建两个脚本：一个用于递增，另一个用于重置递增器。要开始，您可以为每个脚本创建一个文件，并将它们命名为 <code>increment.py</code> 和 <code>reset.py</code>：</p> <pre><code>touch increment.py reset.py\n</code></pre> <p>打开 <code>increment.py</code> 文件，并按照以下步骤创建脚本：</p> <ol> <li>添加导入项，包括 Web3.py 和 <code>Incrementer.sol</code> 合约的 ABI</li> <li>设置 Web3 提供程序</li> <li>定义 <code>account_from</code>，包括 <code>private_key</code>、已部署合约的 <code>contract_address</code> 和要递增的 <code>value</code>。私钥是签名交易所必需的。注意：这仅用于示例目的。切勿将您的私钥存储在 Python 文件中</li> <li>使用 <code>web3.eth.contract</code> 函数创建合约实例，并传入已部署合约的 ABI 和地址</li> <li>使用合约实例构建递增交易，并传入要递增的值。然后，您将使用 <code>build_transaction</code> 函数传入交易信息，包括 <code>from</code> 地址和发送方的 <code>nonce</code>。要获取 <code>nonce</code>，您可以使用 <code>web3.eth.get_transaction_count</code> 函数</li> <li>使用 <code>web3.eth.account.sign_transaction</code> 函数签署交易，并传入递增交易和发送方的 <code>private_key</code></li> <li>使用已签名的交易，您可以使用 <code>web3.eth.send_raw_transaction</code> 函数发送它，并使用 <code>web3.eth.wait_for_transaction_receipt</code> 函数等待交易收据</li> </ol>"}, {"location": "builders/ethereum/libraries/web3py/#1-add-imports_1", "title": "1. Add imports", "text": "<p>from compile import abi from web3 import Web3</p>"}, {"location": "builders/ethereum/libraries/web3py/#2-add-the-web3-provider-logic-here_1", "title": "2. Add the Web3 provider logic here:", "text": "<p>provider_rpc = {     \"development\": \"http://localhost:9944\",     \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\", } web3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network</p>"}, {"location": "builders/ethereum/libraries/web3py/#3-create-variables", "title": "3. Create variables", "text": "<p>account_from = {     'private_key': 'INSERT_YOUR_PRIVATE_KEY',     'address': 'INSERT_PUBLIC_ADDRESS_OF_PK', } contract_address = 'INSERT_CONTRACT_ADDRESS' value = 3</p> <p>print(     f\"Calling the increment by { value } function in contract at address: { contract_address }\" )</p>"}, {"location": "builders/ethereum/libraries/web3py/#4-create-contract-instance_1", "title": "4. Create contract instance", "text": "<p>Incrementer = web3.eth.contract(address=contract_address, abi=abi)</p>"}, {"location": "builders/ethereum/libraries/web3py/#5-build-increment-tx", "title": "5. Build increment tx", "text": "<p>increment_tx = Incrementer.functions.increment(value).build_transaction(     {         \"from\": Web3.to_checksum_address(account_from[\"address\"]),         \"nonce\": web3.eth.get_transaction_count(             Web3.to_checksum_address(account_from[\"address\"])         ),     } )</p>"}, {"location": "builders/ethereum/libraries/web3py/#6-sign-tx-with-pk_1", "title": "6. Sign tx with PK", "text": "<p>tx_create = web3.eth.account.sign_transaction(increment_tx, account_from[\"private_key\"])</p>"}, {"location": "builders/ethereum/libraries/web3py/#7-send-tx-and-wait-for-receipt_1", "title": "7. Send tx and wait for receipt", "text": "<p>tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction) tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)</p> <p>print(f\"Tx successful with hash: { tx_receipt.transactionHash.hex() }\")</p> <p>要运行该脚本，您可以在终端中输入以下命令：</p> <pre><code>python3 increment.py\n</code></pre> <p>如果成功，交易哈希将显示在终端中。您可以将 <code>get.py</code> 脚本与 <code>increment.py</code> 脚本一起使用，以确保该值按预期更改：</p> python get.py Making a call to contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 The current number stored is: 5 python increment.py Calling the increment by 3 function in contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 Tx successful with hash: 0x47757fd97e3ef8db973e335d1f2d19c46b37d0dbd53fea1636ec559ccf119a13 python get.py Making a call to contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 The current number stored is: 8 <p>接下来，您可以打开 <code>reset.py</code> 文件，并按照以下步骤创建脚本：</p> <ol> <li>添加导入项，包括 Web3.py 和 <code>Incrementer.sol</code> 合约的 ABI</li> <li>设置 Web3 提供程序</li> <li>定义 <code>account_from</code>，包括 <code>private_key</code> 和已部署合约的 <code>contract_address</code>。私钥是签名交易所必需的。注意：这仅用于示例目的。切勿将您的私钥存储在 Python 文件中</li> <li>使用 <code>web3.eth.contract</code> 函数创建合约实例，并传入已部署合约的 ABI 和地址</li> <li>使用合约实例构建重置交易。然后，您将使用 <code>build_transaction</code> 函数传入交易信息，包括 <code>from</code> 地址和发送方的 <code>nonce</code>。要获取 <code>nonce</code>，您可以使用 <code>web3.eth.get_transaction_count</code> 函数</li> <li>使用 <code>web3.eth.account.sign_transaction</code> 函数签署交易，并传入重置交易和发送方的 <code>private_key</code></li> <li>使用已签名的交易，您可以使用 <code>web3.eth.send_raw_transaction</code> 函数发送它，并使用 <code>web3.eth.wait_for_transaction_receipt</code> 函数等待交易收据</li> </ol>"}, {"location": "builders/ethereum/libraries/web3py/#1-add-imports_2", "title": "1. Add imports", "text": "<p>from compile import abi from web3 import Web3</p>"}, {"location": "builders/ethereum/libraries/web3py/#2-add-the-web3-provider-logic-here_2", "title": "2. Add the Web3 provider logic here:", "text": "<p>provider_rpc = {     \"development\": \"http://localhost:9944\",     \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\", } web3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network</p>"}, {"location": "builders/ethereum/libraries/web3py/#3-create-variables_1", "title": "3. Create variables", "text": "<p>account_from = {     'private_key': 'INSERT_YOUR_PRIVATE_KEY',     'address': 'INSERT_PUBLIC_ADDRESS_OF_PK', } contract_address = 'INSERT_CONTRACT_ADDRESS'</p> <p>print(f\"Calling the reset function in contract at address: { contract_address }\")</p>"}, {"location": "builders/ethereum/libraries/web3py/#4-create-contract-instance_2", "title": "4. Create contract instance", "text": "<p>Incrementer = web3.eth.contract(address=contract_address, abi=abi)</p>"}, {"location": "builders/ethereum/libraries/web3py/#5-build-reset-tx", "title": "5. Build reset tx", "text": "<p>reset_tx = Incrementer.functions.reset().build_transaction(     {         \"from\": Web3.to_checksum_address(account_from[\"address\"]),         \"nonce\": web3.eth.get_transaction_count(             Web3.to_checksum_address(account_from[\"address\"])         ),     } )</p>"}, {"location": "builders/ethereum/libraries/web3py/#6-sign-tx-with-pk_2", "title": "6. Sign tx with PK", "text": "<p>tx_create = web3.eth.account.sign_transaction(reset_tx, account_from[\"private_key\"])</p>"}, {"location": "builders/ethereum/libraries/web3py/#7-send-tx-and-wait-for-receipt_2", "title": "7. Send tx and wait for receipt", "text": "<p>tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction) tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)</p> <p>print(f\"Tx successful with hash: { tx_receipt.transactionHash.hex() }\")</p> <p>要运行该脚本，您可以在终端中输入以下命令：</p> <pre><code>python3 reset.py\n</code></pre> <p>如果成功，交易哈希将显示在终端中。您可以将 <code>get.py</code> 脚本与 <code>reset.py</code> 脚本一起使用，以确保该值按预期更改：</p> python get.py Making a call to contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 The current number stored is: 8 python reset.py Calling the reset function in contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 Tx successful with hash: 0x152f07430b524838da848b44d58577db252681fba6fbeaf117b2f9d432e301b2 python get.py Making a call to contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 The current number stored is: 0    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/ethereum/precompiles/overview/", "title": "Moonbeam 预编译合约概览", "text": ""}, {"location": "builders/ethereum/precompiles/overview/#introduction", "title": "概述", "text": "<p>在 Moonbeam 上，预编译合约是具有以太坊风格地址的原生 Substrate 代码，可以使用以太坊 API 调用，就像任何其他智能合约一样。预编译允许您直接调用 Substrate 运行时，这通常无法从 Moonbeam 的以太坊端访问。</p> <p>负责实现预编译的 Substrate 代码可以在 EVM pallet 中找到。EVM pallet 包括 以太坊上的标准预编译和一些特定于以太坊的附加预编译。它还提供了通过通用 <code>Precompiles</code> trait 创建和执行自定义预编译的能力。已经创建了几个自定义的 Moonbeam 特定的预编译，所有这些都可以在 Moonbeam 代码库 中找到。重要的是要强调，此列表中的 <code>CallableByContract</code> 检查的预编译无法在合约构造函数内部调用。</p> <p>以太坊预编译合约包含计算密集型的复杂功能，例如哈希和加密。Moonbeam 上的自定义预编译合约提供对基于 Substrate 的功能的访问，例如 Staking、治理、XCM 相关功能等。</p> <p>Moonbeam 特定的预编译可以通过使用以太坊 API 的熟悉且易于使用的 Solidity 接口进行交互，这些接口最终用于与底层 Substrate 接口进行交互。此流程如下图所示：</p> <p></p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/overview/#precompiled-contract-addresses", "title": "预编译合约地址", "text": "<p>预编译合约按地址和原始网络进行分类。如果您要将预编译地址转换为十进制格式，并按数值将其分为几类，则这些类别如下：</p> <ul> <li>0-1023 - 以太坊主网预编译</li> <li>1024-2047 - 不在以太坊中且不是 Moonbeam 特有的预编译</li> <li>2048-4095 - Moonbeam 特有的预编译</li> </ul>"}, {"location": "builders/ethereum/precompiles/account/identity/", "title": "Moonbeam 上的身份预编译", "text": ""}, {"location": "builders/ethereum/precompiles/account/identity/#introduction", "title": "简介", "text": "<p>身份预编译是一个 Solidity 接口，允许您创建、管理和检索链上身份信息。身份信息与帐户关联，包括个人信息，例如您的法定姓名、显示名称、网站、Twitter 账号、Riot（现在称为 Element）名称等。您还可以利用自定义字段来包含任何其他相关信息。</p> <p>身份预编译直接与 Moonbeam 底层的 Substrate 身份运行时逻辑交互，以提供创建和管理身份所需的功能。此 pallet 用 Rust 编写，通常无法从 Moonbeam 的 Ethereum 端访问。但是，身份预编译允许您直接从 Solidity 接口访问此功能。</p> <p>身份预编译位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p><code>0x0000000000000000000000000000000000000818</code></p> <p><code>0x0000000000000000000000000000000000000818</code></p> <p><code>0x0000000000000000000000000000000000000818</code></p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/account/identity/#the-solidity-interface", "title": "Identity Precompile Solidity接口", "text": "<p><code>Identity.sol</code> 是一个Solidity接口，允许开发人员与预编译的方法进行交互。</p> Identity.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Identity contract's address.\naddress constant IDENTITY_ADDRESS = 0x0000000000000000000000000000000000000818;\n\n/// @dev The Identity contract's instance.\nIdentity constant IDENTITY_CONTRACT = Identity(IDENTITY_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Pallet Identity Interface\n/// @title The interface through which solidity contracts will interact with the Identity pallet\n/// @custom:address 0x0000000000000000000000000000000000000818\ninterface Identity {\n    /// @dev Associated raw data.\n    struct Data {\n        /// Is `true` if it represents data, else the absence of data is represented by `false`.\n        bool hasData;\n        /// The contained value.\n        bytes value;\n    }\n\n    /// @dev The super-identity of an alternative \"sub\" identity.\n    struct SuperOf {\n        /// Is `true` if the struct is valid, `false` otherwise.\n        bool isValid;\n        /// The super account.\n        address account;\n        /// The associated data.\n        Data data;\n    }\n\n    /// @dev Alternative \"sub\" identities of an account.\n    struct SubsOf {\n        /// The deposit against this identity.\n        uint256 deposit;\n        /// The sub accounts\n        address[] accounts;\n    }\n\n    /// @dev Registrar judgements are limited to attestations on these fields.\n    struct IdentityFields {\n        /// Set to `true` if the display field is supported, `false` otherwise.\n        bool display;\n        /// Set to `true` if the legal field is supported, `false` otherwise.\n        bool legal;\n        /// Set to `true` if the web field is supported, `false` otherwise.\n        bool web;\n        /// Set to `true` if the riot field is supported, `false` otherwise.\n        bool riot;\n        /// Set to `true` if the email field is supported, `false` otherwise.\n        bool email;\n        /// Set to `true` if the PGP Fingerprint field is supported, `false` otherwise.\n        bool pgpFingerprint;\n        /// Set to `true` if the image field is supported, `false` otherwise.\n        bool image;\n        /// Set to `true` if the twitter field is supported, `false` otherwise.\n        bool twitter;\n    }\n\n    /// @dev Registrar info.\n    struct Registrar {\n        /// Is `true` if the struct is valid, `false` otherwise.\n        bool isValid;\n        /// The registrar's index.\n        uint32 index;\n        /// The account address.\n        address account;\n        /// Amount required to be given to the registrar for them to provide judgement.\n        uint256 fee;\n        /// Relevant fields for this registrar.\n        IdentityFields fields;\n    }\n\n    /// @dev Represents an additional field in identity info.\n    struct Additional {\n        /// The assciated key.\n        Data key;\n        /// The assciated value.\n        Data value;\n    }\n\n    /// @dev The identity information set for an account.\n    struct IdentityInfo {\n        /// Represents the additional fields for the identity.\n        Additional[] additional;\n        /// Represents the display info for the identity.\n        Data display;\n        /// Represents the legal info for the identity.\n        Data legal;\n        /// Represents the web info for the identity.\n        Data web;\n        /// Represents the riot info for the identity.\n        Data riot;\n        /// Represents the email info for the identity.\n        Data email;\n        /// Set to `true` if `pgpFingerprint` is set, `false` otherwise.\n        bool hasPgpFingerprint;\n        /// Represents a 20-byte the PGP fingerprint info for the identity.\n        bytes pgpFingerprint;\n        /// Represents the image info for the identity.\n        Data image;\n        /// Represents the twitter info for the identity.\n        Data twitter;\n    }\n\n    /// @dev Judgement provided by a registrar.\n    struct Judgement {\n        /// The default value; no opinion is held.\n        bool isUnknown;\n        /// No judgement is yet in place, but a deposit is reserved as payment for providing one.\n        bool isFeePaid;\n        /// The deposit reserved for providing a judgement.\n        uint256 feePaidDeposit;\n        /// The data appears to be reasonably acceptable in terms of its accuracy.\n        bool isReasonable;\n        /// The target is known directly by the registrar and the registrar can fully attest to it.\n        bool isKnownGood;\n        /// The data was once good but is currently out of date.\n        bool isOutOfDate;\n        /// The data is imprecise or of sufficiently low-quality to be problematic.\n        bool isLowQuality;\n        /// The data is erroneous. This may be indicative of malicious intent.\n        bool isErroneous;\n    }\n\n    /// @dev Judgement item provided by a registrar.\n    struct JudgementInfo {\n        /// The registrar's index that provided this judgement.\n        uint32 registrarIndex;\n        /// The registrar's provided judgement.\n        Judgement judgement;\n    }\n\n    /// @dev Registrar info.\n    struct Registration {\n        /// Is `true` if the struct is valid, `false` otherwise.\n        bool isValid;\n        /// The judgments provided on this identity.\n        JudgementInfo[] judgements;\n        /// Amount required to be given to the registrar for them to provide judgement.\n        uint256 deposit;\n        /// The associated identity info.\n        IdentityInfo info;\n    }\n\n    /// @dev Alternative \"sub\" identity of an account.\n    struct SubAccount {\n        /// The account address.\n        address account;\n        /// The associated data.\n        Data data;\n    }\n\n    /// @dev Retrieve identity information for an account.\n    /// @custom:selector f0eb5e54\n    /// @param who The requested account\n    function identity(address who) external view returns (Registration memory);\n\n    /// @dev Retrieve super account for an account.\n    /// @custom:selector c18110d6\n    /// @param who The requested account\n    function superOf(address who) external view returns (SuperOf memory);\n\n    /// @dev Retrieve sub accounts for an account.\n    /// @custom:selector 3f08986b\n    /// @param who The requested account\n    function subsOf(address who) external view returns (SubsOf memory);\n\n    /// @dev Retrieve the registrars.\n    /// @custom:selector e88e512e\n    function registrars() external view returns (Registrar[] memory);\n\n    /// @dev Set identity info for the caller.\n    /// @custom:selector 7e08b4cb\n    /// @param info The identity info\n    function setIdentity(IdentityInfo memory info) external;\n\n    /// @dev Set sub accounts for the caller.\n    /// @custom:selector 5a5a3591\n    /// @param subs The sub accounts\n    function setSubs(SubAccount[] memory subs) external;\n\n    /// @dev Clears identity of the caller.\n    /// @custom:selector 7a6a10c7\n    function clearIdentity() external;\n\n    /// @dev Requests registrar judgement on caller's identity.\n    /// @custom:selector d523ceb9\n    /// @param regIndex The registrar's index\n    /// @param maxFee The maximum fee the caller is willing to pay\n    function requestJudgement(uint32 regIndex, uint256 maxFee) external;\n\n    /// @dev Cancels the caller's request for judgement from a registrar.\n    /// @custom:selector c79934a5\n    /// @param regIndex The registrar's index\n    function cancelRequest(uint32 regIndex) external;\n\n    /// @dev Sets the registrar's fee for providing a judgement. Caller must be the account at the index.\n    /// @custom:selector a541b37d\n    /// @param regIndex The registrar's index\n    /// @param fee The fee the registrar will charge\n    function setFee(uint32 regIndex, uint256 fee) external;\n\n    /// @dev Sets the registrar's account. Caller must be the account at the index.\n    /// @custom:selector 889bc198\n    /// @param regIndex The registrar's index\n    /// @param newAccount The new account to set\n    function setAccountId(uint32 regIndex, address newAccount) external;\n\n    /// @dev Sets the registrar's identity fields. Caller must be the account at the index.\n    /// @custom:selector 05297450\n    /// @param regIndex The registrar's index\n    /// @param fields The identity fields\n    function setFields(uint32 regIndex, IdentityFields memory fields) external;\n\n    /// @dev Provides judgement on an accounts identity.\n    /// @custom:selector cd7663a4\n    /// @param regIndex The registrar's index\n    /// @param target The target account to provide judgment for\n    /// @param judgement The judgement to provide\n    /// @param identity The hash of the identity info\n    function provideJudgement(\n        uint32 regIndex,\n        address target,\n        Judgement memory judgement,\n        bytes32 identity\n    ) external;\n\n    /// @dev Add a \"sub\" identity account for the caller.\n    /// @custom:selector 98717196\n    /// @param sub The sub account\n    /// @param data The associated data\n    function addSub(address sub, Data memory data) external;\n\n    /// @dev Rename a \"sub\" identity account of the caller.\n    /// @custom:selector 452df561\n    /// @param sub The sub account\n    /// @param data The new associated data\n    function renameSub(address sub, Data memory data) external;\n\n    /// @dev Removes a \"sub\" identity account of the caller.\n    /// @custom:selector b0a323e0\n    /// @param sub The sub account\n    function removeSub(address sub) external;\n\n    /// @dev Removes the sender as a sub-account.\n    /// @custom:selector d5a3c2c4\n    function quitSub() external;\n\n    /// @dev An identity was set or reset (which will remove all judgements).\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param who Address of the target account\n    event IdentitySet(address who);\n\n    /// @dev An identity was cleared, and the given balance returned.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param who Address of the target account\n    event IdentityCleared(address who);\n\n    /// @dev A judgement was asked from a registrar.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param who Address of the requesting account\n    /// @param registrarIndex The registrar's index\n    event JudgementRequested(address who, uint32 registrarIndex);\n\n    /// @dev A judgement request was retracted.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param who Address of the target account.\n    /// @param registrarIndex The registrar's index\n    event JudgementUnrequested(address who, uint32 registrarIndex);\n\n    /// @dev A judgement was given by a registrar.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param target Address of the target account\n    /// @param registrarIndex The registrar's index\n    event JudgementGiven(address target, uint32 registrarIndex);\n\n    /// @dev A sub-identity was added to an identity and the deposit paid.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param sub Address of the sub account\n    /// @param main Address of the main account\n    event SubIdentityAdded(address sub, address main);\n\n    /// @dev A sub-identity was removed from an identity and the deposit freed.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param sub Address of the sub account\n    /// @param main Address of the main account\n    event SubIdentityRemoved(address sub, address main);\n\n    /// @dev A sub-identity was cleared and the given deposit repatriated from the main identity account to the sub-identity account\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param sub Address of the sub account\n    event SubIdentityRevoked(address sub);\n}\n</code></pre> <p>Identity Precompile包含一些可以由任何人调用的函数，以及一些只能由注册员调用的与判断相关的函数。可以由任何人调用的函数如下：</p> identity(address who) - 返回给定帐户的注册信息 Parameters <ul> <li><code>who</code> - 要查询身份信息的帐户地址</li> </ul> superOf(address who) - 检索子帐户的超级帐户。如果给定的帐户不是子帐户，则返回的地址是 <code>0x0000000000000000000000000000000000000000</code> Parameters <ul> <li><code>who</code> - 要查询超级帐户的帐户地址</li> </ul> subsOf(address who) - 返回给定帐户的子帐户。如果给定的帐户没有任何子帐户，则返回一个空数组 (<code>[]</code>) Parameters <ul> <li><code>who</code> - 要查询子帐户的帐户地址</li> </ul> registrars() - 返回注册员的列表 Parameters <p>无。</p> setIdentity(IdentityInfo memory info) - 为调用者设置身份 Parameters <ul> <li><code>info</code> - 包含要设置的身份信息的IdentityInfo memory结构体</li> </ul> setSubs(SubAccount[] memory subs) - 为调用者设置子帐户 Parameters <ul> <li><code>subs</code> - 包含要设置的子帐户的 SubAccount[] memory 数组</li> </ul> clearIdentity() - 清除调用者的身份 Parameters <p>无。</p> requestJudgement(uint32 regIndex, uint256 maxFee) - 从给定的注册员处请求判断，并提供调用者愿意支付的最高费用 Parameters <ul> <li><code>regIndex</code> - 要从中请求判断的注册员的uint32索引</li> <li><code>maxFee</code> - 调用者愿意为判断支付的uint256最高费用</li> </ul> cancelRequest(uint32 regIndex) - 取消调用者从给定注册员处发出的判断请求 Parameters <ul> <li><code>regIndex</code> - 要从中取消判断请求的注册员的uint32索引</li> </ul> addSub(address sub, Data memory data) - 为调用者添加子身份帐户 Parameters <ul> <li><code>sub</code> - 要添加的子帐户地址</li> <li><code>data</code> - 包含子帐户信息的 Data memory结构体</li> </ul> renameSub(address sub, Data memory data) - 为调用者重命名子身份帐户 Parameters <ul> <li><code>sub</code> - 要重命名的子帐户地址</li> <li><code>data</code> - 包含新的子帐户信息的 Data memory结构体</li> </ul> removeSub(address sub) - 为调用者删除子身份帐户 Parameters <ul> <li><code>sub</code> - 要删除的子帐户地址</li> </ul> quitSub(address sub) - 删除作为子身份帐户的调用者 Parameters <ul> <li><code>sub</code> - 要退出的子帐户地址</li> </ul> <p>必须由注册员调用的与判断相关的函数，并且调用者必须是与 <code>regIndex</code> 对应的注册员帐户，如下所示：</p> setFee(uint32 regIndex, uint256 fee) - 设置注册员的费用 Parameters <ul> <li><code>regIndex</code> - 设置费用的注册员的uint32索引</li> <li><code>fee</code> - 要为注册员设置的uint256新费用金额</li> </ul> setAccountId(uint32 regIndex, address newAccount) - 为注册员设置一个新帐户 Parameters <ul> <li><code>regIndex</code> - 被更新的注册员的uint32索引</li> <li><code>newAccount</code> - 要为注册员设置的新帐户地址</li> </ul> setFields(uint32 regIndex, IdentityFields memory fields) - 设置注册员的身份 Parameters <ul> <li><code>regIndex</code> - 设置其身份字段的注册员的uint32索引</li> <li><code>fields</code> - 包含要设置的身份字段的IdentityFields memory结构体</li> </ul> provideJudgement(uint32 regIndex, address target, Judgement memory judgement, bytes32 identity) - 提供关于帐户身份的判断 Parameters <ul> <li><code>regIndex</code> - 提供判断的注册员的uint32索引</li> <li><code>target</code> - 接收判断的帐户地址</li> <li><code>judgement</code> - 包含判断详细信息的 Judgement memory结构体</li> <li><code>identity</code> - 被判断的身份信息的bytes32哈希值</li> </ul>"}, {"location": "builders/ethereum/precompiles/account/identity/#interact-with-interface", "title": "与Solidity接口交互", "text": "<p>以下部分将介绍如何使用以太坊库（例如Ethers.js和Web3.py）与身份预编译进行交互。</p> <p>本指南中的示例将在Moonbase Alpha上进行。 To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"}, {"location": "builders/ethereum/precompiles/account/identity/#use-ethereum-libraries", "title": "使用以太坊库", "text": "<p>要使用以太坊库与 Identity Precompile 的 Solidity 接口进行交互，您需要 Identity Precompile 的 ABI。</p> Identity Precompile ABI <pre><code>[\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"IdentityCleared\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"IdentitySet\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"target\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint32\",\n                \"name\": \"registrarIndex\",\n                \"type\": \"uint32\"\n            }\n        ],\n        \"name\": \"JudgementGiven\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint32\",\n                \"name\": \"registrarIndex\",\n                \"type\": \"uint32\"\n            }\n        ],\n        \"name\": \"JudgementRequested\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint32\",\n                \"name\": \"registrarIndex\",\n                \"type\": \"uint32\"\n            }\n        ],\n        \"name\": \"JudgementUnrequested\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"main\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"SubIdentityAdded\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"main\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"SubIdentityRemoved\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"SubIdentityRevoked\",\n        \"type\": \"event\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            },\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"hasData\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bytes\",\n                        \"name\": \"value\",\n                        \"type\": \"bytes\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Data\",\n                \"name\": \"data\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"name\": \"addSub\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            }\n        ],\n        \"name\": \"cancelRequest\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"clearIdentity\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"identity\",\n        \"outputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isValid\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"uint32\",\n                                \"name\": \"registrarIndex\",\n                                \"type\": \"uint32\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isUnknown\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isFeePaid\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"uint256\",\n                                        \"name\": \"feePaidDeposit\",\n                                        \"type\": \"uint256\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isReasonable\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isKnownGood\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isOutOfDate\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isLowQuality\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isErroneous\",\n                                        \"type\": \"bool\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Judgement\",\n                                \"name\": \"judgement\",\n                                \"type\": \"tuple\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.JudgementInfo[]\",\n                        \"name\": \"judgements\",\n                        \"type\": \"tuple[]\"\n                    },\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"deposit\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"components\": [\n                                    {\n                                        \"components\": [\n                                            {\n                                                \"internalType\": \"bool\",\n                                                \"name\": \"hasData\",\n                                                \"type\": \"bool\"\n                                            },\n                                            {\n                                                \"internalType\": \"bytes\",\n                                                \"name\": \"value\",\n                                                \"type\": \"bytes\"\n                                            }\n                                        ],\n                                        \"internalType\": \"struct Identity.Data\",\n                                        \"name\": \"key\",\n                                        \"type\": \"tuple\"\n                                    },\n                                    {\n                                        \"components\": [\n                                            {\n                                                \"internalType\": \"bool\",\n                                                \"name\": \"hasData\",\n                                                \"type\": \"bool\"\n                                            },\n                                            {\n                                                \"internalType\": \"bytes\",\n                                                \"name\": \"value\",\n                                                \"type\": \"bytes\"\n                                            }\n                                        ],\n                                        \"internalType\": \"struct Identity.Data\",\n                                        \"name\": \"value\",\n                                        \"type\": \"tuple\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Additional[]\",\n                                \"name\": \"additional\",\n                                \"type\": \"tuple[]\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"display\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"legal\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"web\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"riot\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"email\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasPgpFingerprint\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"pgpFingerprint\",\n                                \"type\": \"bytes\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"image\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"twitter\",\n                                \"type\": \"tuple\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.IdentityInfo\",\n                        \"name\": \"info\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Registration\",\n                \"name\": \"\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"target\",\n                \"type\": \"address\"\n            },\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isUnknown\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isFeePaid\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"feePaidDeposit\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isReasonable\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isKnownGood\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isOutOfDate\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isLowQuality\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isErroneous\",\n                        \"type\": \"bool\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Judgement\",\n                \"name\": \"judgement\",\n                \"type\": \"tuple\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"identity\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"provideJudgement\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"quitSub\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"registrars\",\n        \"outputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isValid\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"uint32\",\n                        \"name\": \"index\",\n                        \"type\": \"uint32\"\n                    },\n                    {\n                        \"internalType\": \"address\",\n                        \"name\": \"account\",\n                        \"type\": \"address\"\n                    },\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"fee\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"display\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"legal\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"web\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"riot\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"email\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"pgpFingerprint\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"image\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"twitter\",\n                                \"type\": \"bool\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.IdentityFields\",\n                        \"name\": \"fields\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Registrar[]\",\n                \"name\": \"\",\n                \"type\": \"tuple[]\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"removeSub\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            },\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"hasData\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bytes\",\n                        \"name\": \"value\",\n                        \"type\": \"bytes\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Data\",\n                \"name\": \"data\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"name\": \"renameSub\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"maxFee\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"requestJudgement\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"newAccount\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"setAccountId\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"fee\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"setFee\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"display\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"legal\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"web\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"riot\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"email\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"pgpFingerprint\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"image\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"twitter\",\n                        \"type\": \"bool\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.IdentityFields\",\n                \"name\": \"fields\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"name\": \"setFields\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"components\": [\n                    {\n                        \"components\": [\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"key\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"value\",\n                                \"type\": \"tuple\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Additional[]\",\n                        \"name\": \"additional\",\n                        \"type\": \"tuple[]\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"display\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"legal\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"web\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"riot\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"email\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"hasPgpFingerprint\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bytes\",\n                        \"name\": \"pgpFingerprint\",\n                        \"type\": \"bytes\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"image\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"twitter\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.IdentityInfo\",\n                \"name\": \"info\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"name\": \"setIdentity\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"address\",\n                        \"name\": \"account\",\n                        \"type\": \"address\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"data\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.SubAccount[]\",\n                \"name\": \"subs\",\n                \"type\": \"tuple[]\"\n            }\n        ],\n        \"name\": \"setSubs\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"subsOf\",\n        \"outputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"deposit\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"internalType\": \"address[]\",\n                        \"name\": \"accounts\",\n                        \"type\": \"address[]\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.SubsOf\",\n                \"name\": \"\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"superOf\",\n        \"outputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isValid\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"address\",\n                        \"name\": \"account\",\n                        \"type\": \"address\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"data\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.SuperOf\",\n                \"name\": \"\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    }\n]\n</code></pre> <p>获得 ABI 后，您可以使用您选择的以太坊库与预编译合约进行交互。一般来说，您需要执行以下步骤：</p> <ol> <li>创建一个 provider</li> <li>创建 Identity Precompile 的合约实例</li> <li>与 Identity Precompile 的函数进行交互</li> </ol> <p>在下面的示例中，您将学习如何组装设置身份所需的数据，如何设置身份，以及如何在设置身份后检索身份信息。</p> <p>Remember</p> <p>以下代码段仅用于演示目的。切勿将您的私钥存储在 JavaScript 或 Python 文件中。</p> Ethers.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport ABI from './identityPrecompileABI.js'; // Import Identity Precompile ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst identityPrecompileAddress = '0x0000000000000000000000000000000000000818';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n// Create interface for the Identity Precompile\nconst identityPrecompile = new ethers.Contract(\n  identityPrecompileAddress,\n  ABI,\n  signer\n);\n\n// Interact with the Precompile Registry\nconst setIdentity = async () =&gt; {\n  // Assemble identity info\n  const identityInfo = {\n    additional: [],\n    display: {\n      hasData: true,\n      value: '0x416c696365', // Alice in hex\n    },\n    legal: {\n      hasData: false,\n      value: '0x',\n    },\n    web: {\n      hasData: false,\n      value: '0x',\n    },\n    riot: {\n      hasData: false,\n      value: '0x',\n    },\n    email: {\n      hasData: false,\n      value: '0x',\n    },\n    hasPgpFingerprint: false,\n    pgpFingerprint: '0x',\n    image: {\n      hasData: false,\n      value: '0x',\n    },\n    twitter: {\n      hasData: false,\n      value: '0x',\n    },\n  };\n\n  // Set the identity\n  const submitIdentity = await identityPrecompile.setIdentity(identityInfo);\n  console.log(`Identity set. Transaction hash: ${submitIdentity.hash}`);\n\n  // Retrieve the identity\n  const identity = await identityPrecompile.identity(signer.address);\n  console.log(`Identity is valid: ${identity[0]}`);\n  console.log(`Judgements provided for this identity: ${identity[1]}`);\n  console.log(`Deposit paid for this identity: ${identity[2]}`);\n  console.log(`Identity information: ${identity[3]}`);\n  console.log(`Display name: ${ethers.toUtf8String(identity[3][1][1])}`);\n};\n\nsetIdentity();\n</code></pre> <pre><code>from web3 import Web3\n\n# Paste or import the Identity Precompile ABI\nabi = \"INSERT_IDENTITY_PRECOMPILE_ABI\"\naccount_from = {\n    \"private_key\": \"INSERT_PRIVATE_KEY\",\n    \"address\": \"INSERT_ADDRESS\",\n}\nidentity_precompile_address = \"0x0000000000000000000000000000000000000818\"\n\n# Create provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create interface for the Precompile Registry\nidentity_precompile = web3.eth.contract(address=identity_precompile_address, abi=abi)\n\n\ndef set_identity():\n    # Assemble identity info\n    identity_info = {\n        \"additional\": [],\n        \"display\": {\n            \"hasData\": True,\n            \"value\": \"0x416c696365\",  # Alice in hex\n        },\n        \"legal\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"web\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"riot\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"email\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"hasPgpFingerprint\": False,\n        \"pgpFingerprint\": \"0x\",\n        \"image\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"twitter\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n    }\n\n    # Set the identity\n    submit_identity = identity_precompile.functions.setIdentity(\n        identity_info\n    ).build_transaction(\n        {\n            \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n            \"nonce\": web3.eth.get_transaction_count(\n                Web3.to_checksum_address(account_from[\"address\"])\n            ),\n        }\n    )\n    # Sign and send the transaction to set the identity\n    tx_create = web3.eth.account.sign_transaction(\n        submit_identity, account_from[\"private_key\"]\n    )\n    tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\n    tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n    print(f\"Identity set. Transaction hash: { tx_receipt.transactionHash.hex() }\")\n\n    # Retrieve the identity\n    identity = identity_precompile.functions.identity(account_from[\"address\"]).call()\n    print(f\"Identity is valid: { identity[0] }\")\n    print(f\"Judgements provided for this identity: { identity[1] }\")\n    print(f\"Deposit paid for this identity: { identity[2] }\")\n    print(f\"Identity information: { identity[3] }\")\n    print(f\"Display name: { web3.to_text(identity[3][1][1]) }\")\n\n\nset_identity()\n</code></pre>"}, {"location": "builders/ethereum/precompiles/account/proxy/", "title": "与代理预编译交互", "text": ""}, {"location": "builders/ethereum/precompiles/account/proxy/#introduction", "title": "简介", "text": "<p>Moonbeam 上的代理预编译允许帐户设置代理帐户，该帐户可以代表他们执行特定的受限操作，例如治理、质押或余额转移。</p> <p>如果用户想要向第二个用户提供代表他们执行有限数量操作的权限，传统上唯一的方法是将第一个帐户的私钥提供给第二个用户。但是，Moonbeam 在运行时包含原生代理功能，从而启用代理帐户。由于代理帐户提供了额外的安全层，因此应使用代理帐户，其中许多帐户可以为主帐户执行操作。例如，如果用户希望将其钱包安全地保存在冷存储中，但仍希望访问钱包的部分功能（如治理或质押），则最好这样做。</p> <p>代理预编译只能从外部拥有帐户 (EOA) 或通过 批量预编译 调用。</p> <p>要了解有关代理帐户的更多信息，以及如何在不使用代理预编译的情况下为自己的目的设置代理帐户，请查看设置代理帐户 页面。</p> <p>代理预编译位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p>text  0x000000000000000000000000000000000000080b</p> <p>text  0x000000000000000000000000000000000000080b</p> <p>text  0x000000000000000000000000000000000000080b</p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/account/proxy/#the-proxy-solidity-interface", "title": "Proxy Solidity 接口", "text": "<p><code>Proxy.sol</code> 是一个接口，Solidity 合约可以通过它与 Proxy Pallet 交互。您无需熟悉 Substrate API，因为您可以使用您熟悉的 Ethereum 接口与之交互。</p> <p>该接口包括以下函数：</p> addProxy(address delegate, ProxyType proxyType, uint32 delay) - 在指定的 <code>delay</code> 块数（通常为零）后，为发送者注册一个代理帐户。如果调用者的代理已存在，则会失败 参数 <ul> <li><code>delegate</code> - 要注册为代理的帐户地址</li> <li><code>proxyType</code> - 指定要注册的代理类型的 ProxyType 枚举</li> <li><code>delay</code> - 代理注册生效前的 uint32 块数</li> </ul> removeProxy(address delegate, ProxyType proxyType, uint32 delay) - 删除发送者的已注册代理 参数 <ul> <li><code>delegate</code> - 要删除的代理帐户地址</li> <li><code>proxyType</code> - 要删除的代理类型的 ProxyType 枚举</li> <li><code>delay</code> - 要删除的代理的 uint32 延迟值</li> </ul> removeProxies() - 删除所有委托给发送者的代理帐户 参数 <p>无。</p> isProxy(address real, address delegate, ProxyType proxyType, uint32 delay) - 返回一个布尔值，如果委托地址是地址 <code>real</code> 的 <code>proxyType</code> 类型的代理，且具有指定的 <code>delay</code>，则返回 <code>true</code> 参数 <ul> <li><code>real</code> - 可能由代理代表的帐户地址</li> <li><code>delegate</code> - 潜在的代理帐户地址</li> <li><code>proxyType</code> - 要检查的代理类型的 ProxyType 枚举</li> <li><code>delay</code> - 要检查的 uint32 延迟值</li> </ul> <p><code>proxyType</code> 参数由以下 <code>ProxyType</code> 枚举定义，其中值从 <code>0</code> 开始，代表最宽松的代理类型，并表示为 <code>uint8</code> 值：</p> <pre><code>enum ProxyType {\n    Any,\n    NonTransfer,\n    Governance,\n    Staking,\n    CancelProxy,\n    Balances,\n    AuthorMapping,\n    IdentityJudgement\n}\n</code></pre>"}, {"location": "builders/ethereum/precompiles/account/proxy/#proxy-types", "title": "代理类型", "text": "<p>可以委派给账户的代理角色有多种类型，这些角色通过 <code>Proxy.sol</code> 中的 <code>ProxyType</code> 枚举来表示。以下列表包括所有可能的代理以及它们可以代表主账户进行的交易类型：</p> <ul> <li>Any — any 代理允许代理账户进行 <code>Governance</code>、<code>Staking</code>、<code>Balances</code> 和 <code>AuthorMapping</code> 代理类型可以执行的任何类型的交易。请注意，余额转移仅允许给 EOA，不允许给合约或预编译合约</li> <li>NonTransfer — non-transfer 代理允许代理账户通过 <code>Governance</code>、<code>Staking</code> 和 <code>AuthorMapping</code> 预编译合约进行任何类型的交易，其中 <code>msg.value</code> 必须为零</li> <li>Governance - governance 代理允许代理账户进行任何类型的治理相关交易（包括民主或议会 pallet）</li> <li>Staking - staking 代理允许代理账户通过 <code>Staking</code> 预编译合约进行与 staking 相关的交易，包括调用 <code>AuthorMapping</code> 预编译合约</li> <li>CancelProxy - cancel 代理允许代理账户拒绝和删除延迟的代理声明（主账户的）。目前，Proxy 预编译合约不支持此操作</li> <li>Balances - balances 代理允许代理账户仅进行余额转移到 EOA</li> <li>AuthorMapping - 这种类型的代理账户被收集者用来将服务从一台服务器迁移到另一台服务器</li> <li>IdentityJudgement - identity judgement 代理允许代理账户判断和证明与 Polkadot 账户相关的个人信息。目前，Proxy 预编译合约不支持此操作</li> </ul>"}, {"location": "builders/ethereum/precompiles/account/proxy/#interact-with-the-solidity-interface", "title": "与Solidity接口交互", "text": "<p>以下部分将介绍如何从Remix与Proxy Precompile进行交互。请注意，Proxy Precompile只能从EOA或Batch Precompile调用。</p>"}, {"location": "builders/ethereum/precompiles/account/proxy/#checking-prerequisites", "title": "检查先决条件", "text": "<p>以下示例在 Moonbase Alpha 上演示，但类似的步骤也可用于 Moonbeam 和 Moonriver。您应该：</p> <ul> <li>安装 MetaMask 并连接到 Moonbase Alpha</li> <li>拥有一个包含一些 DEV 代币的帐户。   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>拥有您控制的第二个帐户以用作代理帐户（资金可选）</li> </ul>"}, {"location": "builders/ethereum/precompiles/account/proxy/#remix-set-up", "title": "Remix 设置", "text": "<p>首先，获取 <code>Proxy.sol</code> 的副本，并按照以下步骤操作：</p> <ol> <li>点击 文件浏览器 选项卡</li> <li>将文件内容复制并粘贴到名为 <code>Proxy.sol</code> 的 Remix 文件 中</li> </ol> <p></p>"}, {"location": "builders/ethereum/precompiles/account/proxy/#compile-the-contract", "title": "编译合约", "text": "<ol> <li>点击顶部的第二个 Compile 选项卡</li> <li>然后编译接口，点击 Compile Proxy.sol</li> </ol>"}, {"location": "builders/ethereum/precompiles/account/proxy/#access-the-contract", "title": "访问合约", "text": "<ol> <li>点击Remix中Compile选项卡正下方的Deploy and Run选项卡。注意：您不是在此处部署合约，而是访问已经部署的预编译合约</li> <li>确保在ENVIRONMENT下拉菜单中选择Injected Provider - Metamask</li> <li>确保在CONTRACT下拉菜单中选择Proxy.sol。由于这是一个预编译合约，因此无需部署，而是要在At Address字段中提供预编译的地址</li> <li>提供Moonbase Alpha的Proxy预编译地址：<code>0x000000000000000000000000000000000000080b</code>，然后点击At Address</li> <li>Proxy预编译将出现在Deployed Contracts列表中</li> </ol>"}, {"location": "builders/ethereum/precompiles/account/proxy/#add-proxy", "title": "添加代理", "text": "<p>如果您的帐户还没有代理，您可以通过代理预编译为您的帐户添加一个代理。在本例中，您将通过以下步骤向帐户添加一个 余额 代理：</p> <ol> <li>展开代理预编译合约以查看可用的函数</li> <li>找到 addProxy 函数，然后按下按钮展开该部分</li> <li>将您的第二个帐户地址作为 delegate 插入，<code>5</code> 作为 proxyType，<code>0</code> 作为 delay</li> <li>按下 transact 并在 MetaMask 中确认交易</li> </ol> <p>Note</p> <p>在 Remix 中构造交易时，proxyType 表示为 <code>uint8</code>，而不是预期的枚举 <code>ProxyType</code>。在 Solidity 中，枚举被编译为 <code>uint8</code>，因此当您为 proxyType 传入 <code>5</code> 时，您表示 <code>ProxyType</code> 枚举中的第六个元素，即余额代理。</p> <p></p>"}, {"location": "builders/ethereum/precompiles/account/proxy/#check-proxy", "title": "检查代理是否存在", "text": "<p>您可以确定一个账户是否是主账户的代理账户。在本例中，您将插入先前添加的代理的参数，以确定是否成功添加了代理账户：</p> <ol> <li>找到 isProxy 函数并按下按钮展开该部分</li> <li>将您的主账户地址作为 real 插入，将您的第二个账户地址作为 delegate 插入，将 <code>5</code> 作为 proxyType 插入，将 <code>0</code> 作为 delay 插入</li> <li>按下 call</li> </ol> <p>如果一切正常，输出应为 <code>true</code>。</p> <p></p>"}, {"location": "builders/ethereum/precompiles/account/proxy/#remove-proxy", "title": "移除代理", "text": "<p>您可以通过代理预编译从您的帐户中移除代理。在此示例中，您将通过以下步骤移除先前添加到委托帐户的余额代理：</p> <ol> <li>展开代理预编译合约以查看可用功能</li> <li>找到 removeProxy 函数，然后按按钮展开该部分</li> <li>插入您的第二个帐户地址作为 delegate，<code>5</code> 作为 proxyType，<code>0</code> 作为 delay</li> <li>按 transact 并在 MetaMask 中确认交易</li> </ol> <p>交易确认后，如果您重复这些步骤来检查代理是否存在，结果应为 <code>false</code>。</p> <p></p> <p>就这样！您已完成代理预编译的介绍。有关设置代理的其他信息，请访问设置代理帐户页面和 Polkadot 文档中的代理帐户页面。如果您对代理预编译的任何方面有任何疑问，请随时在 Discord 上联系我们。</p>"}, {"location": "builders/ethereum/precompiles/features/randomness/", "title": "与随机性预编译交互", "text": ""}, {"location": "builders/ethereum/precompiles/features/randomness/#introduction", "title": "简介", "text": "<p>Moonbeam 利用可验证随机函数 (VRF) 生成可在链上验证的随机性。VRF 是一种加密函数，它接受一些输入并生成随机值，以及证明这些随机值是由提交者生成的真实性证明。任何人都可以验证该证明，以确保正确计算了生成的随机值。</p> <p>目前有两种可用的随机性来源，它们根据区块生产者的 VRF 密钥和过去的随机性结果提供随机输入：本地 VRF 和 BABE 纪元随机性。本地 VRF 直接在 Moonbeam 中确定，使用区块整理人的 VRF 密钥和上一个区块的 VRF 输出。另一方面，BABE 纪元随机性基于中继链验证人在完整纪元期间生成的所有 VRF。</p> <p>有关随机性的两种来源、请求和履行过程如何运作以及安全注意事项的更多信息，请参阅 Moonbeam 上的随机性 页面。</p> <p>Moonbeam 提供了一个随机性预编译合约，它是一个 Solidity 接口，使智能合约开发者能够使用 Ethereum API 通过本地 VRF 或 BABE 纪元随机性生成随机性。Moonbeam 还提供了一个随机性消费者 Solidity 合约，您的合约必须继承该合约才能使用已履行的随机性请求。</p> <p>本指南将向您展示如何使用随机性预编译合约和随机性消费者合约创建一个抽奖活动，其中获奖者将被随机选择。您还将学习如何直接与随机性预编译合约交互，以执行诸如清除过期的随机性请求之类的操作。</p> <p>随机性预编译合约位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p><code>0x0000000000000000000000000000000000000809</code></p> <p><code>0x0000000000000000000000000000000000000809</code></p> <p><code>0x0000000000000000000000000000000000000809</code></p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#the-randomness-interface", "title": "随机数Solidity接口", "text": "<p>Randomness.sol 是一个Solidity接口，允许开发者与预编译的方法进行交互。</p> Randomness.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Randomness contract's address.\naddress constant RANDOMNESS_ADDRESS = 0x0000000000000000000000000000000000000809;\n\n/// @dev The Randomness contract's instance.\nRandomness constant RANDOMNESS_CONTRACT = Randomness(RANDOMNESS_ADDRESS);\n\n/// @dev Maximum number of random words being requested\nuint32 constant MAX_RANDOM_WORDS = 100;\n/// @dev Minimum number of blocks before a request can be fulfilled for Local VRF Request\nuint32 constant MIN_VRF_BLOCKS_DELAY = 2;\n/// @dev Maximum number of blocks before a request can be fulfilled for Local VRF Request\nuint32 constant MAX_VRF_BLOCKS_DELAY = 2000;\n/// @dev The deposit amount needed to request random words. There is 1 deposit per request\nuint256 constant REQUEST_DEPOSIT_AMOUNT = 1000000000000000000;\n\n/// @author The Moonbeam Team\n/// @title Pallet Randomness Interface\n/// @dev The interface through which solidity contracts will interact with Randomness\n/// @custom:address 0x0000000000000000000000000000000000000809\ninterface Randomness {\n    /// @notice Event emitted when the request has been successfully executed\n    event FulFillmentSucceeded();\n    /// @notice Event emitted when the request has failed to execute fulfillment\n    event FulFillmentFailed();\n\n    /// @notice The status of the request\n    /// @param DoesNotExist The request doesn't exist\n    /// @param Pending The request cannot be fulfilled yet\n    /// @param Ready The request is ready to be fulfilled\n    /// @param Expired The request has expired\n    enum RequestStatus {\n        DoesNotExist,\n        Pending,\n        Ready,\n        Expired\n    }\n\n    /// @notice The type of randomness source\n    /// @param LocalVRF Randomness VRF using the parachain material as seed\n    /// @param RelayBabeEpoch Randomness VRF using relay material from previous epoch\n    enum RandomnessSource {\n        LocalVRF,\n        RelayBabeEpoch\n    }\n\n    /// @notice The request details\n    /// @param id The id of the request (is always &lt; 2**64)\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param contractAddress The address of the contract being called back during fulfillment\n    /// @param fee The amount to set aside to pay for the fulfillment\n    /// @param gasLimit The gas limit to use for the fulfillment\n    /// @param salt A string being mixed with the randomness seed to obtain different random words. This should be as unique as possible; using the same salt will lead to same randomness result.\n    /// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n    /// @param randomnessSource The type of randomness source used to generate the random words\n    /// @param fulfillmentBlock The parachain block number at which the request can be fulfilled (for LocalVRF only)\n    /// @param fulfillmentEpochIndex The relay epoch index at which the request can be fulfilled (for RelayBabeEpoch)\n    /// @param expirationBlock The parachain block number at which the request expires (for LocalVRF only)\n    /// @param expirationEpochIndex The relay epoch index at which the request expires (for RelayBabeEpoch)\n    /// @param status The current status of the request\n    struct Request {\n        uint256 id;\n        address refundAddress;\n        address contractAddress;\n        uint256 fee;\n        uint256 gasLimit;\n        bytes32 salt;\n        uint32 numWords;\n        RandomnessSource randomnessSource;\n        uint32 fulfillmentBlock;\n        uint64 fulfillmentEpochIndex;\n        uint32 expirationBlock;\n        uint64 expirationEpochIndex;\n        RequestStatus status;\n    }\n\n    /// Return the current relay epoch index\n    /// @dev An epoch represents real time and not a block number\n    /// @dev Currently, time between epoch changes cannot be longer than:\n    /// @dev  - Kusama/Westend/Rococo: 600 relay blocks (1 hour)\n    /// @dev  - Polkadot: 2400 relay blocks (4 hours)\n    /// @custom:selector 81797566\n    function relayEpochIndex() external view returns (uint64);\n\n    /// Return the deposit required to perform a request\n    /// @dev Each request will need a deposit.\n    /// @custom:selector fb7cfdd7\n    function requiredDeposit() external view returns (uint256);\n\n    /// @notice Returns the request status\n    /// @param requestId The id of the request to check (must be &lt; 2**64)\n    /// @return status Status of the request\n    /// @custom:selector d8a4676f\n    function getRequestStatus(uint256 requestId)\n        external\n        view\n        returns (RequestStatus status);\n\n    /// @notice Returns the request or revert\n    /// @param requestId The id of the request to check (must be &lt; 2**64)\n    /// @return request The request\n    /// @custom:selector c58343ef\n    function getRequest(uint256 requestId)\n        external\n        view\n        returns (Request memory request);\n\n    /// @notice Request random words generated from the parachain VRF\n    /// @dev This is using pseudo-random VRF executed by the collator at the fulfillment\n    /// @dev Warning:\n    /// @dev The collator in charge of producing the block at fulfillment can decide to skip\n    /// @dev producing the block in order to have a different random word generated by the next\n    /// @dev collator, at the cost of a block reward. It is therefore economically viable to use\n    /// @dev this randomness source only if the financial reward at stake is lower than the block\n    /// @dev reward.\n    /// @dev In order to reduce the risk of a collator being able to predict the random words\n    /// @dev when the request is performed, it is possible to increase the delay to multiple blocks\n    /// @dev The higher the delay is, the less likely the collator will be able to know which\n    /// @dev collator will be in charge of fulfilling the request.\n    /// @dev Fulfillment is manual and can be executed by anyone (for free) after the given delay\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param fee The amount to set aside to pay for the fulfillment\n    /// @param gasLimit The gas limit to use for the fulfillment\n    /// @param salt A string being mixed with the randomness seed to obtain different random words\n    /// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n    /// @param delay The number of blocks until the request can be fulfilled (between MIN_DELAY_BLOCKS and MAX_DELAY_BLOCKS)\n    /// @return requestId The id of the request requestLocalVRFRandomWords\n    /// @custom:selector 9478430c\n    function requestLocalVRFRandomWords(\n        address refundAddress,\n        uint256 fee,\n        uint64 gasLimit,\n        bytes32 salt,\n        uint8 numWords,\n        uint64 delay\n    ) external returns (uint256);\n\n    /// @notice Request random words generated from the relaychain Babe consensus\n    /// @dev The random words are generated from the hash of the all the VRF provided by the\n    /// @dev relaychain validator during 1 epoch.\n    /// @dev It requires a delay of at least 1 epoch after the current epoch to be unpredictable\n    /// @dev at the time the request is performed.\n    /// @dev Warning:\n    /// @dev The validator (on the relaychain) of the last block of an epoch can decide to skip\n    /// @dev producing the block in order to choose the previous generated epoch random number\n    /// @dev at the cost of a relaychain block rewards. It is therefore economically viable to use\n    /// @dev this randomness source only if the financial reward at stake is lower than the relaychain\n    /// @dev block reward.\n    /// @dev (see https://crates.parity.io/pallet_babe/struct.RandomnessFromOneEpochAgo.html)\n    /// @dev Fulfillment is manual and can be executed by anyone (for free) at\n    /// @dev the beginning of the 2nd relay epoch following the current one\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param fee Amount to set aside to pay for the fulfillment. Those fees are taken from the contract\n    /// @param gasLimit Gas limit for the fulfillment\n    /// @param salt Salt to be mixed with raw randomness to get output\n    /// @param numWords Number of random words to be returned (limited to MAX_RANDOM_WORDS)\n    /// @return requestId The id of the request\n    /// @custom:selector 33c14a63\n    function requestRelayBabeEpochRandomWords(\n        address refundAddress,\n        uint256 fee,\n        uint64 gasLimit,\n        bytes32 salt,\n        uint8 numWords\n    ) external returns (uint256);\n\n    /// @dev fulFill the request which will call the contract method \"fulfillRandomWords\"\n    /// @dev Fees of the caller are refunded if the request is fulfillable\n    /// @param requestId Request to be fulfilled (must be &lt; 2**64)\n    /// @custom:selector 9a91eb0d\n    function fulfillRequest(uint256 requestId) external;\n\n    /// @param requestId Request receiving the additional fees (must be &lt; 2**64)\n    /// @param feeIncrease Amount to increase\n    /// @custom:selector d0408a7f\n    function increaseRequestFee(uint256 requestId, uint256 feeIncrease)\n        external;\n\n    /// @param requestId Request to be purged (must be &lt; 2**64)\n    /// @custom:selector 1d26cbab\n    function purgeExpiredRequest(uint256 requestId) external;\n}\n</code></pre> <p>该接口包括函数、常量、事件和枚举，详见以下章节。</p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#functions", "title": "函数", "text": "<p>该接口包括以下函数：</p> relayEpochIndex() - 返回当前的中继纪元索引，其中一个纪元代表实际时间，而不是区块号 参数返回值 <p>无。</p> <ul> <li><code>uint256</code> 当前中继纪元索引</li> </ul> requiredDeposit() - 返回执行随机数请求所需的押金 参数返回值 <p>无。</p> <ul> <li><code>uint256</code> 所需的押金金额</li> </ul> getRequestStatus(uint256 requestId) - 返回给定随机数请求的请求状态 参数返回值 <ul> <li><code>requestId</code> - 随机数请求的 uint256 ID</li> </ul> <ul> <li><code>uint8</code> 请求的状态代码</li> </ul> getRequest(uint256 requestId) - 返回给定随机数请求的请求详情 参数返回值 <ul> <li><code>requestId</code> - 随机数请求的 uint256 ID</li> </ul> <ul> <li><code>bool</code> 请求是否准备就绪</li> <li><code>bool</code> 请求是否已过期</li> <li><code>uint256</code> 押金金额</li> <li><code>uint256</code> 手续费金额</li> </ul> requestLocalVRFRandomWords(address refundAddress, uint256 fee, uint64 gasLimit, bytes32 salt, uint8 numWords, uint64 delay) - 请求从平行链 VRF 生成的随机词 参数返回值 <ul> <li><code>refundAddress</code> - 接收完成后的剩余费用的地址</li> <li><code>fee</code> - uint256 金额，用于预留支付完成费用</li> <li><code>gasLimit</code> - 用于完成的 uint64 gas 限制</li> <li><code>salt</code> - 与随机种子混合以获得不同随机词的 bytes32 字符串</li> <li><code>numWords</code> - 请求的随机词数量的 uint8，最多为最大随机词数量</li> <li><code>delay</code> - 请求可以完成之前必须经过的区块数的 uint64。此值需要在本地 VRF 请求可以完成之前的最小和最大区块数之间</li> </ul> <ul> <li><code>uint256</code> 创建的请求的 ID</li> </ul> requestRelayBabeEpochRandomWords(address refundAddress, uint256 fee, uint64 gasLimit, bytes32 salt, uint8 numWords) - 请求从中继链 BABE 共识生成的随机词 参数返回值 <ul> <li><code>refundAddress</code> - 接收完成后的剩余费用的地址</li> <li><code>fee</code> - uint256 金额，用于预留支付完成费用</li> <li><code>gasLimit</code> - 用于完成的 uint64 gas 限制</li> <li><code>salt</code> - 与随机种子混合以获得不同随机词的 bytes32 字符串</li> <li><code>numWords</code> - 请求的随机词数量的 uint8，最多为最大随机词数量</li> </ul> <ul> <li><code>uint256</code> 创建的请求的 ID</li> </ul> fulfillRequest(uint256 requestId) - 完成请求，这将调用消费者合约方法 <code>fulfillRandomWords</code>。如果请求可以完成，则调用者的费用将被退还 参数返回值 <ul> <li><code>requestId</code> - 随机数请求的 uint256 ID</li> </ul> <p>无。</p> increaseRequestFee(uint256 requestId, uint256 feeIncrease) - 增加与给定随机数请求关联的费用。如果在请求完成之前，gas 价格显著上涨，则需要这样做 参数返回值 <ul> <li><code>requestId</code> - 随机数请求的 uint256 ID</li> <li><code>feeIncrease</code> - 费用增加的 uint256 金额</li> </ul> <p>无。</p> purgeExpiredRequest(uint256 requestId) - 从存储中删除给定的过期请求，并将请求费用转移给调用者，并将押金返还给原始请求者 参数返回值 <ul> <li><code>requestId</code> - 随机数请求的 uint256 ID</li> </ul> <p>无。</p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#constants", "title": "常量", "text": "<p>该接口包含以下常量：</p> <ul> <li>maxRandomWords - 请求的最大随机字数</li> <li>minBlockDelay - 本地 VRF 请求可以满足的最小区块数</li> <li>maxBlockDelay - 本地 VRF 请求可以满足的最大区块数</li> <li>deposit - 请求随机字所需的存款金额。 每个请求都有一笔存款</li> </ul> MoonbeamMoonriverMoonbase Alpha Variable Value MAX_RANDOM_WORDS 100 words MIN_VRF_BLOCKS_DELAY 2 blocks MAX_VRF_BLOCKS_DELAY 2000 blocks REQUEST_DEPOSIT_AMOUNT 100 GLMR Variable Value MAX_RANDOM_WORDS 100 words MIN_VRF_BLOCKS_DELAY 2 blocks MAX_VRF_BLOCKS_DELAY 2000 blocks REQUEST_DEPOSIT_AMOUNT 1 MOVR Variable Value MAX_RANDOM_WORDS 100 words MIN_VRF_BLOCKS_DELAY 2 blocks MAX_VRF_BLOCKS_DELAY 2000 blocks REQUEST_DEPOSIT_AMOUNT 1 DEV"}, {"location": "builders/ethereum/precompiles/features/randomness/#events", "title": "事件", "text": "<p>该接口包括以下事件：</p> <ul> <li>FulfillmentSucceeded() - 请求已成功执行时发出</li> <li>FulfillmentFailed() - 请求未能执行 fulfillment 时发出</li> </ul>"}, {"location": "builders/ethereum/precompiles/features/randomness/#enums", "title": "枚举", "text": "<p>该接口包括以下枚举：</p> <ul> <li>RequestStatus - 请求的状态，可以是 <code>DoesNotExist</code> (0)、<code>Pending</code> (1)、<code>Ready</code> (2) 或 <code>Expired</code> (3)</li> <li>RandomnessSource - 随机源的类型，可以是 <code>LocalVRF</code> (0) 或 <code>RelayBabeEpoch</code> (1)</li> </ul>"}, {"location": "builders/ethereum/precompiles/features/randomness/#randomness-consumer-solidity-interface", "title": "随机数消费者Solidity接口", "text": "<p><code>RandomnessConsumer.sol</code> Solidity接口使智能合约可以轻松地与随机数预编译进行交互。使用随机数消费者可确保实现来自随机数预编译。</p> RandomnessConsumer.sol <p>solidity // SPDX-License-Identifier: GPL-3.0-only pragma solidity &gt;=0.8.3;</p> <p>/// @dev The Randomness contract's address. address constant RANDOMNESS_ADDRESS = 0x0000000000000000000000000000000000000809;</p> <p>/// @dev The Randomness contract's instance. Randomness constant RANDOMNESS_CONTRACT = Randomness(RANDOMNESS_ADDRESS);</p> <p>/// @dev Maximum number of random words being requested uint32 constant MAX_RANDOM_WORDS = 100; /// @dev Minimum number of blocks before a request can be fulfilled for Local VRF Request uint32 constant MIN_VRF_BLOCKS_DELAY = 2; /// @dev Maximum number of blocks before a request can be fulfilled for Local VRF Request uint32 constant MAX_VRF_BLOCKS_DELAY = 2000; /// @dev The deposit amount needed to request random words. There is 1 deposit per request uint256 constant REQUEST_DEPOSIT_AMOUNT = 1000000000000000000;</p> <p>/// @author The Moonbeam Team /// @title Pallet Randomness Interface /// @dev The interface through which solidity contracts will interact with Randomness /// @custom:address 0x0000000000000000000000000000000000000809 interface Randomness {     /// @notice Event emitted when the request has been successfully executed     event FulFillmentSucceeded();     /// @notice Event emitted when the request has failed to execute fulfillment     event FulFillmentFailed();</p> <pre><code>/// @notice The status of the request\n/// @param DoesNotExist The request doesn't exist\n/// @param Pending The request cannot be fulfilled yet\n/// @param Ready The request is ready to be fulfilled\n/// @param Expired The request has expired\nenum RequestStatus {\n    DoesNotExist,\n    Pending,\n    Ready,\n    Expired\n}\n\n/// @notice The type of randomness source\n/// @param LocalVRF Randomness VRF using the parachain material as seed\n/// @param RelayBabeEpoch Randomness VRF using relay material from previous epoch\nenum RandomnessSource {\n    LocalVRF,\n    RelayBabeEpoch\n}\n\n/// @notice The request details\n/// @param id The id of the request (is always &lt; 2**64)\n/// @param refundAddress The address receiving the left-over fees after the fulfillment\n/// @param contractAddress The address of the contract being called back during fulfillment\n/// @param fee The amount to set aside to pay for the fulfillment\n/// @param gasLimit The gas limit to use for the fulfillment\n/// @param salt A string being mixed with the randomness seed to obtain different random words. This should be as unique as possible; using the same salt will lead to same randomness result.\n/// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n/// @param randomnessSource The type of randomness source used to generate the random words\n/// @param fulfillmentBlock The parachain block number at which the request can be fulfilled (for LocalVRF only)\n/// @param fulfillmentEpochIndex The relay epoch index at which the request can be fulfilled (for RelayBabeEpoch)\n/// @param expirationBlock The parachain block number at which the request expires (for LocalVRF only)\n/// @param expirationEpochIndex The relay epoch index at which the request expires (for RelayBabeEpoch)\n/// @param status The current status of the request\nstruct Request {\n    uint256 id;\n    address refundAddress;\n    address contractAddress;\n    uint256 fee;\n    uint256 gasLimit;\n    bytes32 salt;\n    uint32 numWords;\n    RandomnessSource randomnessSource;\n    uint32 fulfillmentBlock;\n    uint64 fulfillmentEpochIndex;\n    uint32 expirationBlock;\n    uint64 expirationEpochIndex;\n    RequestStatus status;\n}\n\n/// Return the current relay epoch index\n/// @dev An epoch represents real time and not a block number\n/// @dev Currently, time between epoch changes cannot be longer than:\n/// @dev  - Kusama/Westend/Rococo: 600 relay blocks (1 hour)\n/// @dev  - Polkadot: 2400 relay blocks (4 hours)\n/// @custom:selector 81797566\nfunction relayEpochIndex() external view returns (uint64);\n\n/// Return the deposit required to perform a request\n/// @dev Each request will need a deposit.\n/// @custom:selector fb7cfdd7\nfunction requiredDeposit() external view returns (uint256);\n\n/// @notice Returns the request status\n/// @param requestId The id of the request to check (must be &lt; 2**64)\n/// @return status Status of the request\n/// @custom:selector d8a4676f\nfunction getRequestStatus(uint256 requestId)\n    external\n    view\n    returns (RequestStatus status);\n\n/// @notice Returns the request or revert\n/// @param requestId The id of the request to check (must be &lt; 2**64)\n/// @return request The request\n/// @custom:selector c58343ef\nfunction getRequest(uint256 requestId)\n    external\n    view\n    returns (Request memory request);\n\n/// @notice Request random words generated from the parachain VRF\n/// @dev This is using pseudo-random VRF executed by the collator at the fulfillment\n/// @dev Warning:\n/// @dev The collator in charge of producing the block at fulfillment can decide to skip\n/// @dev producing the block in order to have a different random word generated by the next\n/// @dev collator, at the cost of a block reward. It is therefore economically viable to use\n/// @dev this randomness source only if the financial reward at stake is lower than the block\n/// @dev reward.\n/// @dev In order to reduce the risk of a collator being able to predict the random words\n/// @dev when the request is performed, it is possible to increase the delay to multiple blocks\n/// @dev The higher the delay is, the less likely the collator will be able to know which\n/// @dev collator will be in charge of fulfilling the request.\n/// @dev Fulfillment is manual and can be executed by anyone (for free) after the given delay\n/// @param refundAddress The address receiving the left-over fees after the fulfillment\n/// @param fee The amount to set aside to pay for the fulfillment\n/// @param gasLimit The gas limit to use for the fulfillment\n/// @param salt A string being mixed with the randomness seed to obtain different random words\n/// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n/// @param delay The number of blocks until the request can be fulfilled (between MIN_DELAY_BLOCKS and MAX_DELAY_BLOCKS)\n/// @return requestId The id of the request requestLocalVRFRandomWords\n/// @custom:selector 9478430c\nfunction requestLocalVRFRandomWords(\n    address refundAddress,\n    uint256 fee,\n    uint64 gasLimit,\n    bytes32 salt,\n    uint8 numWords,\n    uint64 delay\n) external returns (uint256);\n\n/// @notice Request random words generated from the relaychain Babe consensus\n/// @dev The random words are generated from the hash of the all the VRF provided by the\n/// @dev relaychain validator during 1 epoch.\n/// @dev It requires a delay of at least 1 epoch after the current epoch to be unpredictable\n/// @dev at the time the request is performed.\n/// @dev Warning:\n/// @dev The validator (on the relaychain) of the last block of an epoch can decide to skip\n/// @dev producing the block in order to choose the previous generated epoch random number\n/// @dev at the cost of a relaychain block rewards. It is therefore economically viable to use\n/// @dev this randomness source only if the financial reward at stake is lower than the relaychain\n/// @dev block reward.\n/// @dev (see https://crates.parity.io/pallet_babe/struct.RandomnessFromOneEpochAgo.html)\n/// @dev Fulfillment is manual and can be executed by anyone (for free) at\n/// @dev the beginning of the 2nd relay epoch following the current one\n/// @param refundAddress The address receiving the left-over fees after the fulfillment\n/// @param fee Amount to set aside to pay for the fulfillment. Those fees are taken from the contract\n/// @param gasLimit Gas limit for the fulfillment\n/// @param salt Salt to be mixed with raw randomness to get output\n/// @param numWords Number of random words to be returned (limited to MAX_RANDOM_WORDS)\n/// @return requestId The id of the request\n/// @custom:selector 33c14a63\nfunction requestRelayBabeEpochRandomWords(\n    address refundAddress,\n    uint256 fee,\n    uint64 gasLimit,\n    bytes32 salt,\n    uint8 numWords\n) external returns (uint256);\n\n/// @dev fulFill the request which will call the contract method \"fulfillRandomWords\"\n/// @dev Fees of the caller are refunded if the request is fulfillable\n/// @param requestId Request to be fulfilled (must be &lt; 2**64)\n/// @custom:selector 9a91eb0d\nfunction fulfillRequest(uint256 requestId) external;\n\n/// @param requestId Request receiving the additional fees (must be &lt; 2**64)\n/// @param feeIncrease Amount to increase\n/// @custom:selector d0408a7f\nfunction increaseRequestFee(uint256 requestId, uint256 feeIncrease)\n    external;\n\n/// @param requestId Request to be purged (must be &lt; 2**64)\n/// @custom:selector 1d26cbab\nfunction purgeExpiredRequest(uint256 requestId) external;\n</code></pre> <p>}</p> <p>消费者接口包括以下函数：</p> <ul> <li>fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) - 处理给定请求的VRF响应。此方法由对 <code>rawFulfillRandomWords</code> 的调用触发</li> <li>rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) - 在调用随机数预编译的 <code>fulfillRequest</code> 函数 时执行。验证调用的来源，确保随机数预编译是来源，然后调用 <code>fulfillRandomWords</code> 方法</li> </ul>"}, {"location": "builders/ethereum/precompiles/features/randomness/#request-and-fulfill-process", "title": "请求与完成过程", "text": "<p>要使用随机性，您必须拥有一个执行以下操作的合约：</p> <ul> <li>导入 <code>Randomness.sol</code> 预编译合约和 <code>RandomnessConsumer.sol</code> 接口</li> <li>继承自 <code>RandomnessConsumer.sol</code> 接口</li> <li>根据您要使用的随机性来源，通过预编译合约的 <code>requestLocalVRFRandomWords</code> 方法 或 <code>requestRelayBabeEpochRandomWords</code> 方法 请求随机性</li> <li>通过预编译合约的 <code>fulfillRequest</code> 方法 请求完成</li> <li>通过具有与 <code>RandomnessConsumer.sol</code> 合约的 <code>fulfillRandomWords</code> 方法 相同签名的 <code>fulfillRandomWords</code> 方法 使用随机性</li> </ul> <p>通过预编译合约的 <code>requestLocalVRFRandomWords</code> 或 <code>requestRelayBabeEpochRandomWords</code> 方法请求随机性时，会预留一笔费用来支付请求的完成费用。使用本地 VRF 时，为了提高不可预测性，必须经过指定的延迟期（以区块为单位），然后才能完成请求。至少，延迟期必须大于一个区块。对于 BABE epoch 随机性，您无需指定延迟，但可以在当前 epoch 之后的第二个 epoch 开始时完成请求。</p> <p>延迟后，任何人都可以通过 <code>fulfillRequest</code> 方法手动执行请求的完成，费用是最初为请求预留的费用。</p> <p>通过预编译合约的 <code>fulfillRequest</code> 方法完成随机性请求时，将调用 <code>RandomnessConsumer.sol</code> 合约中的 <code>rawFulfillRandomWords</code> 函数，该函数将验证发送者是否为随机性预编译合约。然后，调用 <code>fulfillRandomWords</code>，并使用当前区块的随机性结果和给定的 salt 计算请求的随机词数并返回。如果完成成功，将发出 <code>FulfillmentSucceeded</code> 事件；否则，将发出 <code>FulfillmentFailed</code> 事件。</p> <p>对于已完成的请求，执行成本将从请求费用中退还给 <code>fulfillRequest</code> 的调用者。然后，任何多余的费用和请求保证金将转入指定的退款地址。</p> <p>您的合约的 <code>fulfillRandomWords</code> 回调负责处理完成。例如，在彩票合约中，回调将使用随机词来选择获胜者并支付奖金。</p> <p>如果请求过期，可以通过预编译合约的 <code>purgeExpiredRequest</code> 函数 清除它。调用此函数时，请求费用将支付给调用者，保证金将退还给原始请求者。</p> <p>以下图表显示了随机性请求的理想路径：</p> <p></p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#interact-with-the-solidity-interfaces", "title": "使用随机性预编译生成随机数", "text": "<p>在本教程的以下部分中，您将学习如何创建使用随机性预编译和随机性消费者生成随机数的智能合约。如果您只想了解随机性预编译的一些功能，您可以跳到使用 Remix 直接与随机性预编译交互部分。</p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#checking-prerequisites", "title": "检查先决条件", "text": "<p>在本指南中，您需要具备以下条件：</p> <ul> <li>已安装MetaMask并连接到Moonbase Alpha</li> <li>一个有DEV代币的账户。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"}, {"location": "builders/ethereum/precompiles/features/randomness/#create-random-generator-contract", "title": "创建随机数生成器合约", "text": "<p>本节将要创建的合约包含您请求随机性以及使用满足随机性请求的结果所需的最低限度的函数。</p> <p>此合约仅用于教育目的，不适用于生产用途。</p> <p>此合约将包含以下函数：</p> <ul> <li>接受请求随机性所需的存款的构造函数</li> <li>提交随机性请求的函数。在此示例中，随机性来源将是本地 VRF，但您可以轻松修改合约以使用 BABE 时间片随机性</li> <li>通过调用 Randomness Precompile 的 <code>fulfillRequest</code> 函数来满足请求的函数。此函数将是 <code>payable</code>，因为履行费用需要在请求随机性时提交</li> <li>使用履行结果的函数。此函数的签名必须与 Randomness Consumer 合约的 <code>fulfillRandomWords</code> 方法的签名 匹配</li> </ul> <p>事不宜迟，合约如下：</p> <p>solidity // SPDX-License-Identifier: GPL-3.0-only pragma solidity ^0.8.30;</p> <p>import \"https://github.com/moonbeam-foundation/moonbeam/blob/master/precompiles/randomness/Randomness.sol\"; import {RandomnessConsumer} from \"https://github.com/moonbeam-foundation/moonbeam/blob/master/precompiles/randomness/RandomnessConsumer.sol\";</p> <p>contract RandomNumber is RandomnessConsumer {     // The Randomness Precompile Interface     Randomness public randomness =         Randomness(0x0000000000000000000000000000000000000809);</p> <pre><code>// Variables required for randomness requests\nuint256 public requiredDeposit = randomness.requiredDeposit();\nuint64 public FULFILLMENT_GAS_LIMIT = 100000;\n// The fee can be set to any value as long as it is enough to cover\n// the fulfillment costs. Any leftover fees will be refunded to the\n// refund address specified in the requestRandomness function below.\n// 150 Gwei should be sufficient for all networks.\n// For Moonbase Alpha and Moonriver, you can specify 5 Gwei \nuint256 public MIN_FEE = FULFILLMENT_GAS_LIMIT * 150 gwei; \nuint32 public VRF_BLOCKS_DELAY = MIN_VRF_BLOCKS_DELAY;\nbytes32 public SALT_PREFIX = \"INSERT_ANY_STRING_FOR_SALT\";\n\n// Storage variables for the current request\nuint256 public requestId;\nuint256[] public random;\n\nconstructor() payable RandomnessConsumer() {\n    // Because this contract can only perform 1 random request at a time,\n    // We only need to have 1 required deposit\n    require(msg.value &gt;= requiredDeposit);\n}\n\nfunction requestRandomness() public payable {\n    // Make sure that the value sent is enough\n    require(msg.value &gt;= MIN_FEE);\n    // Request local VRF randomness\n    requestId = randomness.requestLocalVRFRandomWords(\n        msg.sender, // Refund address\n        msg.value, // Fulfillment fee\n        FULFILLMENT_GAS_LIMIT, // Gas limit for the fulfillment\n        SALT_PREFIX ^ bytes32(requestId++), // A salt to generate unique results\n        1, // Number of random words\n        VRF_BLOCKS_DELAY // Delay before request can be fulfilled\n    );\n}\n\nfunction fulfillRequest() public {\n    randomness.fulfillRequest(requestId);\n}\n\nfunction fulfillRandomWords(\n    uint256, // requestId\n    uint256[] memory randomWords\n) internal override {\n    // Save the randomness results\n    random = randomWords;\n}\n</code></pre> <p>}</p> <p>如您所见，合约中还有一些常量可以根据您的需要进行编辑，尤其是 <code>SALT_PREFIX</code>，它可以用于生成唯一的结果。</p> <p>在以下各节中，您将使用 Remix 来部署合约并与之交互。</p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#remix-set-up", "title": "Remix设置", "text": "<p>若要将合约添加到Remix并遵循本教程的这一部分，您需要在Remix中创建一个名为 <code>RandomnessNumber.sol</code> 的新文件，并将 <code>RandomNumber</code> 合约粘贴到该文件中。</p> <p></p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#compile-deploy-random-number", "title": "编译和部署随机数生成器合约", "text": "<p>要在 Remix 中编译 <code>RandomNumber.sol</code> 合约，您需要执行以下步骤：</p> <ol> <li>点击从顶部数第二个的 Compile（编译） 选项卡</li> <li>点击 Compile RandomNumber.sol（编译 RandomNumber.sol） 按钮</li> </ol> <p>如果合约编译成功，您将在 Compile（编译） 选项卡旁边看到一个绿色复选标记。</p> <p></p> <p>现在，您可以按照以下步骤继续部署合约：</p> <ol> <li>点击 Compile（编译） 选项卡正下方的 Deploy and Run（部署和运行） 选项卡</li> <li>确保在 ENVIRONMENT（环境） 下拉菜单中选择了 Injected Provider - Metamask（注入提供程序 - Metamask）。选择 Injected Provider - Metamask（注入提供程序 - Metamask） 后，MetaMask 可能会提示您将您的帐户连接到 Remix</li> <li>确保在 ACCOUNT（帐户） 下显示了正确的帐户</li> <li>在 VALUE（值） 字段中输入存款金额，即 <code>1000000000000000000</code> Wei（<code>1</code> 以太币）</li> <li>确保在 CONTRACT（合约） 下拉菜单中选择了 RandomNumber - RandomNumber.sol</li> <li>点击 Deploy（部署）</li> <li>点击 Confirm（确认） 以确认出现的 MetaMask 交易</li> </ol> <p></p> <p>RANDOMNUMBER 合约将出现在 Deployed Contracts（已部署的合约） 列表中。</p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#request-randomness", "title": "提交生成随机数的请求", "text": "<p>要请求随机数，您需要使用合约的 <code>requestRandomness</code> 函数，这将要求您提交由随机数预编译定义的押金。您可以通过以下步骤提交随机数请求并支付押金：</p> <ol> <li>在 VALUE 字段中输入履行费的金额，它必须等于或大于 <code>RandomNumber</code> 合约中指定的最低费用，即 <code>15000000</code> Gwei。</li> <li>展开 RANDOMNUMBER 合约</li> <li>单击 requestRandomness 按钮</li> <li>在 MetaMask 中确认交易</li> </ol> <p></p> <p>提交交易后，<code>requestId</code> 将使用请求的 ID 进行更新。您可以使用随机数合约的 <code>requestId</code> 调用来获取请求 ID，并使用随机数预编译的 <code>getRequestStatus</code> 函数来检查此请求 ID 的状态。</p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#fulfill-request-save-number", "title": "履行请求并保存随机数", "text": "<p>提交随机性请求后，您需要等待延迟时间才能履行请求。对于 <code>RandomNumber.sol</code> 合约，延迟设置为随机性预编译中定义的最小区块延迟，即 2 个区块。您还必须在为时过晚之前履行请求。对于本地 VRF，请求在 10000 个区块后过期，对于 BABE epoch 随机性，请求在 10000 个 epoch 后过期。</p> <p>假设您已等待了最小区块数（如果您使用的是 BABE epoch 随机性，则为 epoch 数）并且请求尚未过期，您可以按照以下步骤履行请求：</p> <ol> <li>点击 fulfillRequest 按钮</li> <li>在 MetaMask 中确认交易</li> </ol> <p></p> <p>一旦请求被履行，您可以检查生成的随机数：</p> <ol> <li>展开 random 函数</li> <li>由于合约只请求了一个随机词，您可以通过访问 <code>random</code> 数组的 <code>0</code> 索引来获取随机数</li> <li>点击 call</li> <li>随机数将出现在 call 按钮下方</li> </ol> <p></p> <p>成功履行后，多余的费用和存款将发送到指定的退款地址。</p> <p>如果请求在可以履行之前过期，您可以直接与 Randomness Precompile 交互以清除请求并解锁存款和费用。请参阅以下部分，了解如何执行此操作的说明。</p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#interact-directly", "title": "使用 Remix 直接与随机数预编译合约交互", "text": "<p>除了通过智能合约与随机数预编译合约交互之外，您还可以在 Remix 中直接与它交互，以执行诸如创建随机数请求、检查请求状态和清除过期请求等操作。请记住，您需要有一个继承自消费者合约的合约才能满足请求，因此，如果您使用预编译合约直接满足请求，将无法使用结果。</p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#remix-set-up", "title": "Remix 设置", "text": "<p>要将接口添加到 Remix 并按照本教程的这一部分进行操作，您需要：</p> <ol> <li>获取 <code>Randomness.sol</code> 的副本</li> <li>将文件内容粘贴到名为 Randomness.sol 的 Remix 文件中</li> </ol> <p></p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#compile-randomness", "title": "编译与访问随机数预编译", "text": "<p>接下来，您需要在 Remix 中编译 <code>Randomness.sol</code> 文件。首先，请确保您已打开 Randomness.sol 文件，并按照以下步骤操作：</p> <ol> <li>点击从上往下的第二个 Compile 选项卡</li> <li>要编译合约，请点击 Compile Randomness.sol</li> </ol> <p>如果合约编译成功，您将在 Compile 选项卡旁边看到一个绿色对勾。</p> <p>您将通过预编译合约的地址访问接口，而不是部署随机数预编译：</p> <ol> <li>点击 Remix 中 Compile 选项卡正下方的 Deploy and Run 选项卡。请注意，预编译合约已经部署</li> <li>确保在 ENVIRONMENT 下拉菜单中选中 Injected Provider - Metamask。选择后，MetaMask 可能会提示您将您的帐户连接到 Remix</li> <li>确保在 ACCOUNT 下显示正确的帐户</li> <li>确保在 CONTRACT 下拉菜单中选中 Randomness - Randomness.sol。由于这是一个预编译合约，因此无需部署任何代码。相反，我们将在 At Address 字段中提供预编译的地址</li> <li>提供批量预编译的地址：<code>0x0000000000000000000000000000000000000809</code>，然后点击 At Address</li> </ol> <p></p> <p>RANDOMNESS 预编译将显示在 Deployed Contracts 列表中。您将使用它来满足本教程后面从彩票合约发出的随机性请求。</p>"}, {"location": "builders/ethereum/precompiles/features/randomness/#get-request-status-and-purge", "title": "获取请求状态和清除过期请求", "text": "<p>任何人都可以清除过期的请求。您不需要是请求随机数的人就可以清除它。当您清除过期的请求时，请求费用将转移给您，并且请求的存款将退还给原始请求者。</p> <p>要清除请求，首先必须确保请求已过期。为此，您可以使用预编译的 <code>getRequestStatus</code> 函数来验证请求的状态。从该调用返回的数字对应于 <code>RequestStatus</code> 枚举中值的索引。因此，您需要验证返回的数字是否为 <code>3</code>，表示 <code>Expired</code>（已过期）。</p> <p>验证请求已过期后，您可以调用 <code>purgeExpiredRequest</code> 函数来清除该请求。</p> <p>要验证和清除请求，您可以采取以下步骤：</p> <ol> <li>展开 RANDOMNESS 合约</li> <li>输入您要验证是否过期的请求的请求 ID，然后单击 getRequestStatus</li> <li>响应将显示在函数正下方。验证您是否收到 <code>3</code></li> <li>展开 purgeExpiredRequest 函数并输入请求 ID</li> <li>点击 transact</li> <li>MetaMask 将弹出，您可以确认交易</li> </ol> <p></p> <p>交易完成后，您可以通过使用相同的请求 ID 再次调用 getRequestStatus 函数来验证请求是否已被清除。您应该收到状态 <code>0</code>，即 <code>DoesNotExist</code>（不存在）。您还可以期望请求费用的金额转移到您的帐户。</p>"}, {"location": "builders/ethereum/precompiles/features/staking/", "title": "与 Staking 预编译交互", "text": ""}, {"location": "builders/ethereum/precompiles/features/staking/#introduction", "title": "简介", "text": "<p>Moonbeam 通过 Parachain Staking Pallet 使用委托权益证明系统，允许 Token 持有者（委托人）准确表达他们想要支持哪些整理人候选人以及支持多少权益。Parachain Staking Pallet 的设计理念是，它在链上强制实施委托人和候选人之间的共同风险/回报。有关 Staking 的一般信息，例如通用术语、Staking 变量等，请参阅 Moonbeam 上的 Staking 页面。</p> <p>Staking 模块是用 Rust 编写的，它是 pallet 的一部分，通常无法从 Moonbeam 的 Ethereum 端访问。但是，staking 预编译允许开发人员使用位于以下地址的预编译合约中的 Ethereum API 访问 Staking 功能：</p> MoonbeamMoonriverMoonbase Alpha <p><code>0x0000000000000000000000000000000000000800</code></p> <p><code>0x0000000000000000000000000000000000000800</code></p> <p><code>0x0000000000000000000000000000000000000800</code></p> <p>本指南将介绍 staking 预编译接口中可用的方法。此外，它还将向您展示如何通过 staking 预编译和 Ethereum API 与 Parachain Staking Pallet 交互。本指南中的示例是在 Moonbase Alpha 上完成的，但它们可以适应 Moonbeam 或 Moonriver。</p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/features/staking/#exit-delays", "title": "退出延迟", "text": "<p>一些 Parachain Staking Pallet 的外部调用包含退出延迟，您必须等待才能执行请求。需要注意的退出延迟如下：</p> MoonbeamMoonriverMoonbase Alpha Variable Value Decrease candidate bond 28 rounds (168 hours) Decrease delegator bond 28 rounds (168 hours) Revoke delegation 28 rounds (168 hours) Leave candidates 28 rounds (168 hours) Leave delegators 28 rounds (168 hours) Variable Value Decrease candidate bond 24 rounds (48 hours) Decrease delegator bond 24 rounds (48 hours) Revoke delegation 24 rounds (48 hours) Leave candidates 24 rounds (48 hours) Leave delegators 24 rounds (48 hours) Variable Value Decrease candidate bond 2 rounds (4 hours) Decrease delegator bond 2 rounds (4 hours) Revoke delegation 2 rounds (4 hours) Leave candidates 2 rounds (4 hours) Leave delegators 2 rounds (4 hours)"}, {"location": "builders/ethereum/precompiles/features/staking/#interact-with-solidity-interface", "title": "与 Solidity 接口交互", "text": ""}, {"location": "builders/ethereum/precompiles/features/staking/#checking-prerequisites", "title": "检查先决条件", "text": "<p>下面的例子是在 Moonbase Alpha 上演示的，但是，类似的步骤也可以在 Moonbeam 和 Moonriver 上进行。</p> <ul> <li>安装 MetaMask 并连接到 Moonbase Alpha</li> <li>拥有至少 <code>1</code> 代币的账户。</li> </ul> <p>You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</p> <p>Note</p> <p>由于最低委托金额加上 gas 费用，下面的示例需要超过 <code>1</code> 代币。如果您需要的比水龙头分配的更多，请在 Discord 上联系我们，我们将很乐意为您提供帮助。</p>"}, {"location": "builders/ethereum/precompiles/features/staking/#remix-set-up", "title": "Remix 设置", "text": "<ol> <li>点击 文件浏览器 选项卡</li> <li>获取 <code>StakingInterface.sol</code> 的副本，并将文件内容粘贴到名为 <code>StakingInterface.sol</code> 的 Remix 文件中</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/staking/#compile-the-contract", "title": "编译合约", "text": "<ol> <li>点击顶部的第二个 Compile 选项卡</li> <li>然后要编译接口，点击 Compile StakingInterface.sol</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/staking/#access-the-contract", "title": "访问合约", "text": "<ol> <li>点击 Remix 中编译选项卡下方的 部署和运行 选项卡。注意：您不需要在此处部署合约，而是访问已经部署的预编译合约</li> <li>确保在 ENVIRONMENT 下拉菜单中选择 注入提供者 - Metamask</li> <li>确保在 CONTRACT 下拉菜单中选择 ParachainStaking - StakingInterface.sol。由于这是一个预编译合约，因此无需部署，而是需要在 At Address 字段中提供预编译的地址</li> <li>提供 Moonbase Alpha 的 staking 预编译合约地址：<code>0x0000000000000000000000000000000000000800</code> 并点击 At Address</li> <li>Parachain Staking 预编译合约将出现在 Deployed Contracts 列表中</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/staking/#delegate-a-collator", "title": "使用自动复利委托整理人", "text": "<p>在此示例中，您将委托一个整理人，并设置在 Moonbase Alpha 上自动复利的奖励百分比。委托人是质押代币并为特定候选人担保的代币持有者。任何在其可用余额中持有至少 1 个代币的用户都可以成为委托人。委托候选人时，您可以同时设置自动复利。您可以指定一定百分比的奖励自动应用于您的总委托额。您不必立即设置自动复利，您可以稍后随时进行设置。</p> <p>您可以进行自己的研究并选择您想要的候选人。在本指南中，将使用以下候选人地址：<code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>。</p> <p>为了委托候选人，您需要确定候选人当前的委托计数、他们的自动复利委托计数以及您自己的委托计数。</p> <p>被选人委托计数是支持特定被选人的委托数。要获取候选人委托人计数，您可以调用 staking 预编译提供的函数。展开已部署合约列表下的 PARACHAINSTAKING 合约，然后：</p> <ol> <li>找到并展开 candidateDelegationCount 函数</li> <li>输入候选人地址 (<code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>)</li> <li>点击 call</li> <li>调用完成后，将显示结果</li> </ol> <p></p> <p>自动复利委托计数是已配置自动复利的委托数。要确定已设置自动复利的委托数，您可以</p> <ol> <li>找到并展开 candidateAutoCompoundingDelegationCount 函数</li> <li>输入候选人地址 (<code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>)</li> <li>点击 call</li> <li>调用完成后，将显示结果</li> </ol> <p></p> <p>您需要检索的最后一项是您的委托计数。如果您不知道您现有的委托数，您可以按照以下步骤轻松获取它们：</p> <ol> <li>找到并展开 delegatorDelegationCount 函数</li> <li>输入您的地址</li> <li>点击 call</li> <li>调用完成后，将显示结果</li> </ol> <p></p> <p>现在您已经获得了候选人委托人计数，自动复利委托计数以及您的现有委托数，您拥有委托候选人并设置自动复利所需的所有信息。要开始使用：</p> <ol> <li>找到并展开 delegateWithAutoCompound 函数</li> <li>输入您要委托的候选人地址。在此示例中，您可以使用 <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>以 Wei 为单位提供要委托的数量。委托最少需要 <code>1</code> 个代币，因此 Wei 的最低金额为 <code>1000000000000000000</code></li> <li>输入一个介于 0-100 之间的整数（无小数）以表示自动复利的奖励百分比</li> <li>输入候选人的委托计数</li> <li>输入候选人的自动复利委托计数</li> <li>输入您的委托计数</li> <li>按 transact</li> <li>MetaMask 将弹出，您可以查看详细信息并确认交易</li> </ol> <p></p> <p>如果您想在不设置自动复利的情况下进行委托，您可以按照前面的步骤操作，但不要使用 delegateWithAutoCompound，而可以使用 delegate extrinsic。</p>"}, {"location": "builders/ethereum/precompiles/features/staking/#verify-delegation", "title": "验证委托", "text": "<p>要验证您的委托是否成功，您可以在 Polkadot.js Apps 中检查链状态。首先，将您的 MetaMask 地址添加到 Polkadot.js Apps 中的地址簿。</p> <p>导航至 Accounts，然后导航至 Address Book，点击 Add contact，并输入以下信息：</p> <ol> <li>添加您的 MetaMask 地址</li> <li>提供该帐户的昵称</li> <li>点击 Save</li> </ol> <p></p> <p>要验证您的委托是否成功，请前往 Polkadot.js Apps 并导航至 Developer，然后导航至 Chain State</p> <ol> <li>选择 parachainStaking pallet</li> <li>选择 delegatorState 查询</li> <li>输入您的地址</li> <li>（可选）如果您想提供特定的区块哈希进行查询，您可以启用 include option 滑块</li> <li>点击 + 按钮以返回结果并验证您的委托</li> </ol> <p>Note</p> <p>如果您正在寻找委托的概述，则不必在 blockhash to query at 字段中输入任何内容。</p> <p></p>"}, {"location": "builders/ethereum/precompiles/features/staking/#confirm-auto-compounding", "title": "确认自动复利百分比", "text": "<p>您可以使用Solidity接口的<code>delegationAutoCompound</code>函数在Remix中确认您设置的自动复利奖励百分比：</p> <ol> <li>找到并展开 delegationAutoCompound 函数</li> <li>输入您用于委托的帐户</li> <li>输入您已委托的候选人</li> <li>点击 call</li> <li>响应将出现在 call 按钮下方</li> </ol> <p></p>"}, {"location": "builders/ethereum/precompiles/features/staking/#set-or-change-auto-compounding", "title": "设置或更改自动复利百分比", "text": "<p>如果您最初在设置委托时没有设置自动复利，或者您想要更新现有已设置自动复利的委托的百分比，您可以使用 Solidity 界面的 <code>setAutoCompound</code> 函数。</p> <p>您需要获取要设置或更新自动复利的候选人的已设置自动复利的委托数量。您还需要检索您自己的委托计数。您可以按照使用自动复利委托验证人部分中的说明获取这两个项目。</p> <p>获得必要的信息后，您可以在 Remix 中执行以下步骤：</p> <ol> <li>找到并展开 setAutoCompound 函数</li> <li>输入您要为其设置或更新自动复利的候选人的帐户</li> <li>输入一个 0-100 之间的数字，以表示您要自动复利的奖励百分比</li> <li>输入候选人的自动复利委托计数</li> <li>输入您的委托计数</li> <li>按 transact</li> <li>MetaMask 将会弹出，您可以查看详细信息并确认交易</li> </ol> <p></p>"}, {"location": "builders/ethereum/precompiles/features/staking/#revoke-a-delegation", "title": "撤销委托", "text": "<p>从 运行时版本 1001 开始，用户与各种 Staking 功能交互的方式发生了重大变化。包括处理 Staking 退出的方式。</p> <p>现在，退出需要您安排一个退出或撤销委托的请求，等待一段延迟期，然后执行该请求。</p> <p>要撤销对特定候选人的委托并收回您的代币，您可以使用 <code>scheduleRevokeDelegation</code> extrinsic。安排请求不会自动撤销您的委托，您必须等待一个 退出延迟，然后使用 <code>executeDelegationRequest</code> 方法执行该请求。</p> <p>要撤销委托并收回您的代币，请返回 Remix，然后：</p> <ol> <li>找到并展开 scheduleRevokeDelegation 函数</li> <li>输入您要撤销委托的候选人地址</li> <li>点击 transact</li> <li>MetaMask 将弹出，您可以查看交易详情，然后点击 Confirm</li> </ol> <p></p> <p>交易确认后，您必须等待退出延迟的持续时间，才能执行和撤销委托请求。如果您尝试在退出延迟结束前撤销它，您的 extrinsic 将会失败。</p> <p>退出延迟结束后，您可以返回 Remix 并按照以下步骤执行到期请求：</p> <ol> <li>找到并展开 executeDelegationRequest 函数</li> <li>输入您要撤销委托的委托人地址</li> <li>输入您要从中撤销委托的候选人地址</li> <li>点击 transact</li> <li>MetaMask 将弹出，您可以查看交易详情，然后点击 Confirm</li> </ol> <p>调用完成后，将显示结果，并且将为给定的委托人撤销来自指定候选人的委托。您还可以在 Polkadot.js Apps 上再次检查您的委托人状态以进行确认。</p> <p>如果由于任何原因您需要取消待处理的计划请求以撤销委托，您可以通过在 Remix 中按照以下步骤操作来完成：</p> <ol> <li>找到并展开 cancelDelegationRequest 函数</li> <li>输入您要取消待处理请求的候选人地址</li> <li>点击 transact</li> <li>MetaMask 将弹出，您可以查看交易详情，然后点击 Confirm</li> </ol> <p>您可以在 Polkadot.js Apps 上再次检查您的委托人状态，以确认您的委托仍然完好无损。</p>"}, {"location": "builders/ethereum/precompiles/features/governance/collective/", "title": "与集体预编译交互", "text": ""}, {"location": "builders/ethereum/precompiles/features/governance/collective/#introduction", "title": "简介", "text": "<p>通过 Collective Precompile，用户可以直接从 Solidity 接口与 Substrate 的 collective pallet 进行交互。</p> <p>Collective 是由一组负责特定民主相关操作的成员组成，例如提案、投票、执行和结束动议。每个集体都可以执行具有不同来源的不同操作。因此，可以创建具有非常具体范围的集体。目前有两个集体：财政委员会集体和 OpenGov 技术委员会集体。因此，每个集体都有一个预编译合约。有关 OpenGov 技术委员会的更多信息，请参阅 Moonbeam 上的治理 页面，有关财政委员会的更多信息，请参阅 Moonbeam 上的财政 页面。</p> <p>本指南将向您展示如何使用 Collective Precompile 提出、投票和结束提案。</p> <p>Collective Precompile 位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha Collective 地址 财政委员会 0x0000000000000000000000000000000000000810 OpenGov 技术委员会 0x0000000000000000000000000000000000000814 Collective 地址 财政委员会 0x0000000000000000000000000000000000000810 OpenGov 技术委员会 0x0000000000000000000000000000000000000814 Collective 地址 财政委员会 0x0000000000000000000000000000000000000810 OpenGov 技术委员会 0x0000000000000000000000000000000000000814 <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/features/governance/collective/#the-call-permit-interface", "title": "集体 Solidity 接口", "text": "<p><code>Collective.sol</code> 是一个 Solidity 接口，允许开发人员与预编译的五个方法进行交互。</p> <p>该接口包括以下函数：</p> execute(bytes memory proposal) - 以集体的一个成员的身份执行提案。发送者必须是集体的成员。如果 Substrate 提案已分派但失败，则不会恢复 参数 <ul> <li><code>proposal</code> - bytes memory 包含 SCALE 编码 的 Substrate 调用，该调用建议一项操作</li> </ul> propose(uint32 threshold, bytes memory proposal) - 添加一个新的提案以供投票。发送者必须是集体的成员。如果阈值小于 2，则将直接分派和执行提案，并将提案者作为分派者。如果满足阈值，则返回新提案的索引 参数 <ul> <li><code>threshold</code> - uint32 分派提案所需的成员数量</li> <li><code>proposal</code> - bytes memory 包含 SCALE 编码 的 Substrate 调用，该调用建议一项操作</li> </ul> vote(bytes32 proposalHash, uint32 proposalIndex, bool approve) - 对提案进行投票。发送者必须是集体的成员 参数 <ul> <li><code>proposalHash</code> - bytes32 提案的哈希值</li> <li><code>proposalIndex</code> - uint32 提案的索引</li> <li><code>approve</code> - bool 指示投票是否批准提案</li> </ul> close(bytes32 proposalHash, uint32 proposalIndex, uint64 proposalWeightBound, uint32 lengthBound) - 关闭提案。一旦有足够的投票，任何人都可以调用。返回一个布尔值，指示提案是否已执行或删除 参数 <ul> <li><code>proposalHash</code> - bytes32 提案的哈希值</li> <li><code>proposalIndex</code> - uint32 提案的索引</li> <li><code>proposalWeightBound</code> - uint64 提案可以使用的 Substrate 权重的最大量。如果提案调用使用更多，则调用将恢复</li> <li><code>lengthBound</code> - uint32 大于或等于 SCALE 编码的提案长度（以字节为单位）的值</li> </ul> proposalHash(bytes memory proposal) - 计算提案的哈希值 参数 <ul> <li><code>proposal</code> - bytes memory 包含 SCALE 编码 的 Substrate 调用，该调用建议一项操作</li> </ul> <p>该接口包括以下事件：</p> <ul> <li>Executed(bytes32 proposalHash) - 在执行提案时发出</li> <li>Proposed(address indexed who, uint32 indexed proposalIndex, bytes32 indexed proposalHash, uint32 threshold) - 当提案已成功提出并且可以执行或投票时发出</li> <li>Voted(address indexed who, bytes32 indexed proposalHash, bool* voted) - 在对提案进行投票时发出</li> <li>Closed(bytes32 indexed proposalHash) - 在提案已关闭时发出</li> </ul>"}, {"location": "builders/ethereum/precompiles/features/governance/collective/#interacting-with-the-solidity-interface", "title": "与Solidity接口交互", "text": "<p>本节的示例将向您展示如何使用 Treasury Council Collective Precompile 提交 Treasury 提案。因此，该提案将受到满足 Treasury Council 投票要求的约束。接受 Treasury 提案的门槛是至少五分之三的 Treasury Council 成员。另一方面，拒绝提案的门槛是至少二分之一的 Treasury Council 成员。请记住，为了提出提案并对其进行投票，您必须是 Treasury Council 的成员。</p> <p>如果您不是 Moonbeam、Moonriver 或 Moonbase Alpha 上的 Treasury Council 成员，您可以使用 Moonbeam 开发节点 测试 Collective Precompile 的功能。Moonbeam 开发节点带有十个预先资助的帐户，其中 Baltathar、Charleth 和 Dorothy 会自动设置为 Treasury Council 集体的成员。您可以使用这三个帐户中的任何一个来按照本指南的其余部分进行操作。</p>"}, {"location": "builders/ethereum/precompiles/features/governance/collective/#checking-prerequisites", "title": "检查先决条件", "text": "<p>本指南中的示例将在 Moonbeam 开发节点上展示，但它可以适用于任何基于 Moonbeam 的网络。</p> <p>要开始使用，您需要具备以下条件：</p> <ul> <li>安装 MetaMask 并连接到基于 Moonbeam 的网络之一</li> <li>拥有一个有资金的账户。如果使用 Moonbeam 开发节点，则开发账户已预先充值。对于 Moonbeam、Moonriver 或 Moonbase Alpha，您需要为您的账户充值。   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul> <p>如果您使用的是 Moonbeam 开发节点和开发账户，您还需要执行以下操作：</p> <ul> <li>将您的开发节点设置为按时间间隔（例如每 6 秒（6000 毫秒））使用 <code>--sealing 6000</code> 标志来密封区块</li> <li>将 Polkadot.js 应用程序连接到您的本地 Moonbeam 开发节点</li> <li>将 Baltathar、Charleth 和/或 Dorothy 的账户导入到 Polkadot.js 应用程序 和 MetaMask</li> </ul>"}, {"location": "builders/ethereum/precompiles/features/governance/collective/#remix-set-up", "title": "Remix 设置", "text": "<ol> <li>获取 <code>Collective.sol</code> 的副本</li> <li>将文件内容复制并粘贴到名为 <code>Collective.sol</code> 的 Remix 文件中</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/governance/collective/#compile-the-contract", "title": "编译合约", "text": "<ol> <li>点击顶部的第二个 Compile 选项卡</li> <li>然后要编译接口，点击 Compile Collective.sol</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/governance/collective/#access-the-contract", "title": "访问合约", "text": "<ol> <li>点击 Remix 中Compile选项卡正下方的 Deploy and Run 选项卡。注意：您不是在此处部署合约； 而是访问已部署的预编译合约</li> <li>确保在 ENVIRONMENT 下拉菜单中选择了 Injected Provider - Metamask</li> <li>确保在 CONTRACT 下拉菜单中选择了 Collective - Collective.sol。 由于这是一个预编译合约，因此无需部署，而是需要在 At Address 字段中提供预编译的地址</li> <li>提供 Collective 预编译的地址，<code>0x0000000000000000000000000000000000000810</code>，然后点击 At Address</li> <li>Collective 预编译将出现在 Deployed Contracts 的列表中</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/governance/collective/#create-a-proposal", "title": "创建提案", "text": "<p>为了提交一份提案以供财政委员会集体投票，您必须首先创建一个财政提案。如果您想要投票的财政提案已经存在，并且您拥有提案索引，则可以跳到下一节。</p> <p>要提交财政提案，您可以通过 Polkadot.js Apps 财政页面进行提交。 对于此示例，您可以创建一个简单的提案，向 Alith 发送 10 个 DEV 代币，这些代币可用于举办社区活动。 要开始使用，请单击提交提案，然后填写以下信息：</p> <ol> <li>从使用帐户提交下拉列表中，选择您要用来提交提案的帐户。 提案的保证金将从该帐户中扣除</li> <li>选择受益人，在此示例中可以是 Alith</li> <li>输入 <code>10</code> 作为值</li> <li>单击提交提案，然后签名并提交提案</li> </ol> <p></p> <p>您应该会看到提案出现在提案部分中。 如果这是创建的第一个提案，它将具有 <code>0</code> 的提案索引，这在下一节中将需要。 要查看所有提案，您可以导航到开发者选项卡，选择链状态，然后执行以下步骤：</p> <ol> <li>从选定的状态查询下拉列表中，选择 treasury</li> <li>选择 proposals 外部函数</li> <li>关闭包括选项滑块</li> <li>单击 + 提交查询</li> <li>结果将显示在下方，其中包含提案索引和提案详细信息</li> </ol> <p></p> <p>现在您有了提案和提案索引，您将能够在以下部分中使用集体预编译来批准该提案。</p>"}, {"location": "builders/ethereum/precompiles/features/governance/collective/#propose-the-proposal", "title": "提议提案", "text": "<p>为了使用 Collective Precompile 提出一个提案，以便相应的集体可以对其进行投票，您需要获取要由提案执行的调用的编码调用数据。 您可以从 Polkadot.js Apps 获取编码的调用数据。 对于此示例，您需要提议 treasury pallet 的 approveProposal extrinsic。 为此，请导航到“Developer”选项卡，选择“Extrinsics”，然后执行以下步骤：</p> <ol> <li>选择一个帐户（任何帐户都可以，因为您无需在此处提交任何交易）</li> <li>选择 treasury pallet</li> <li>选择 approveProposal extrinsic</li> <li>输入集体将投票批准的提案索引</li> <li>复制提案的 encoded call data</li> </ol> <p></p> <p>在此示例中，此示例中提案的 extrinsic 编码调用数据为 <code>0x110200</code>。</p> <p>有了编码的提案后，您可以返回到 Remix 并在“Deployed Contracts”部分下展开 COLLECTIVE 预编译合约。 确保您已连接到作为财政委员会成员的帐户，并按照以下步骤提议批准：</p> <ol> <li>展开 propose 函数</li> <li>输入 threshold。 请记住，要批准 Treasury 提案，需要至少五分之三的财政委员会成员投票批准。 因此，在此示例中，您可以将阈值设置为 <code>2</code></li> <li>对于 proposal 字段，您可以粘贴从 Polkadot.js Apps 检索到的编码提案</li> <li>点击 transact</li> <li>MetaMask 将会弹出，您可以确认交易</li> </ol> <p></p>"}, {"location": "builders/ethereum/precompiles/features/governance/collective/#vote-on-a-proposal", "title": "对提案进行投票", "text": "<p>要对提案进行投票，您需要通过将编码后的提案传递到 proposalHash 函数中来获取提案哈希值。</p> <p></p> <p>获得提案哈希后，请确保您已连接到作为财政委员会成员的帐户，并按照以下步骤对提案进行投票：</p> <ol> <li>在 Remix 中展开 vote 函数</li> <li>输入 proposalHash</li> <li>输入 proposalIndex</li> <li>在 approve 字段中输入 <code>true</code></li> <li>点击 transact</li> <li>MetaMask 将会弹出，您可以确认交易</li> </ol> <p></p> <p>将阈值设置为 <code>2</code>，您需要在 MetaMask 中切换帐户到财政委员会集体的另一个成员，并重复上述步骤进行投票并达到阈值。一旦达到阈值，您就可以关闭提案，这将自动执行它，如果获得批准，提案将进入队列，放置到一个支出周期中，在该周期内，所提议的金额将分配给受益人。在这种情况下，一旦提案被放入支出周期，10 个 DEV 代币将被分配给 Alith。</p>"}, {"location": "builders/ethereum/precompiles/features/governance/collective/#close-a-proposal", "title": "关闭提案", "text": "<p>如果提案获得足够的票数，任何人都可以关闭提案。您不需要成为财政委员会的成员才能关闭提案。要关闭提案，您可以采取以下步骤：</p> <ol> <li>展开 close 函数</li> <li>输入 proposalHash</li> <li>输入 proposalIndex</li> <li>输入 proposalWeightBound，在此示例中可以为 <code>1000000000</code></li> <li>输入 lengthBound，它可以是等于或大于提案的编码调用数据长度的值。对于此示例，编码的调用数据为 <code>0x110200</code>，因此，您可以将此值设置为 <code>8</code></li> <li>点击 transact</li> <li>MetaMask 将会弹出，您可以确认交易</li> </ol> <p></p> <p>您可以使用 Polkadot.js Apps 验证提案是否已获得批准。从 Developer 选项卡中，选择 Chain State，然后执行以下步骤：</p> <ol> <li>选择 treasury pallet</li> <li>选择 approvals extrinsic</li> <li>点击 + 以提交查询</li> <li>提案将出现在批准列表中</li> </ol> <p></p> <p>一旦提案进入支出期，资金将分配给受益人，原始保证金将返还给提案人。如果财政部资金耗尽，已批准的提案将保留在存储中，直到下一个支出期财政部再次拥有足够的资金。</p>"}, {"location": "builders/ethereum/precompiles/features/governance/conviction-voting/", "title": "与信念投票预编译交互", "text": ""}, {"location": "builders/ethereum/precompiles/features/governance/conviction-voting/#introduction", "title": "简介", "text": "<p>作为 Polkadot 平行链和去中心化网络，Moonbeam 具有原生的链上治理功能，使利益相关者能够参与网络的发展方向。随着 OpenGov（也称为 Governance v2）的引入，确信投票 Pallet 允许代币持有者对提案进行、委托和管理确信加权的投票。要了解有关 Moonbeam 治理系统的更多信息，例如相关术语、原则、机制等的概述，请参阅 Moonbeam 上的治理 页面。</p> <p>确信投票预编译直接与 Substrate 的确信投票 Pallet 交互。此 Pallet 以 Rust 编写，通常无法从 Moonbeam 的 Ethereum API 端访问。但是，确信投票预编译允许您直接从 Solidity 接口访问 Substrate 确信投票 Pallet 的治理相关功能。此外，这还实现了大大改善的最终用户体验。例如，代币持有者可以直接从 MetaMask 对提案进行投票或委托投票，而无需在 Polkadot.js Apps 中导入帐户并浏览复杂的 UI。</p> <p>确信投票预编译位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p>text  0x0000000000000000000000000000000000000812</p> <p>text  0x0000000000000000000000000000000000000812</p> <p>text  0x0000000000000000000000000000000000000812</p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/features/governance/conviction-voting/#the-conviction-voting-solidity-interface", "title": "置信投票 Solidity 接口", "text": "<p><code>ConvictionVoting.sol</code> 是一个 Solidity 接口，允许开发人员与预编译的方法进行交互。</p> <p>该接口包含一个 <code>Conviction</code> 枚举，用于定义 置信乘数 类型。该枚举具有以下变量：</p> <ul> <li>None - 0.1 倍投票，已解锁</li> <li>Locked1x - 1 倍投票，在成功投票后的一个执行期内锁定</li> <li>Locked2x - 2 倍投票，在成功投票后的 2 倍执行期内锁定</li> <li>Locked3x - 4 倍投票，在成功投票后的 4 倍执行期内锁定</li> <li>Locked4x - 8 倍投票，在成功投票后的 8 倍执行期内锁定</li> <li>Locked5x - 16 倍投票，在成功投票后的 16 倍执行期内锁定</li> <li>Locked6x - 32 倍投票，在成功投票后的 32 倍执行期内锁定</li> </ul> <p>该接口包含以下函数：</p> votingFor(address who, uint16 trackId) - 返回给定账户和 Track 的投票 参数 <ul> <li><code>who</code> - 要查询投票的账户地址</li> <li><code>trackId</code> - 需要进行请求更改的 uint16 Track ID</li> </ul> classLocksFor(address who) - 返回给定账户的类锁 参数 <ul> <li><code>who</code> - 要查询类锁的账户地址</li> </ul> voteYes(uint32 pollIndex, uint256 voteAmount, Conviction conviction) - 对投票（公民投票）投置信加权的“赞成”票 参数 <ul> <li><code>pollIndex</code> - 投票（公民投票）的 uint32 索引</li> <li><code>voteAmount</code> - 要锁定以进行投票的 uint256 余额</li> <li><code>conviction</code> - Conviction 代表上述 <code>Conviction</code> 枚举中的一个值</li> </ul> voteNo(uint32 pollIndex, uint256 voteAmount, Conviction conviction) - 对投票（公民投票）投置信加权的“反对”票 参数 <ul> <li><code>pollIndex</code> - 投票（公民投票）的 uint32 索引</li> <li><code>voteAmount</code> - 要锁定以进行投票的 uint256 余额</li> <li><code>conviction</code> - Conviction 代表上述 <code>Conviction</code> 枚举中的一个值</li> </ul> voteSplit(uint32 pollIndex, uint256 aye, uint256 nay) - 投拆分票，在投票（公民投票）中，给定数量锁定为“赞成”，给定数量锁定为“反对” 参数 <ul> <li><code>pollIndex</code> - 投票（公民投票）的 uint32 索引</li> <li><code>aye</code> - 要锁定以进行“赞成”票的 uint256 余额</li> <li><code>nay</code> - 要锁定以进行“反对”票的 uint256 余额</li> </ul> voteSplitAbstain(uint32 pollIndex, uint256 aye, uint256 nay) - 投弃权拆分票，在投票（公民投票）中，给定数量锁定为“赞成”，给定数量锁定为“反对”，给定数量锁定为（支持）弃权票 参数 <ul> <li><code>pollIndex</code> - 投票（公民投票）的 uint32 索引</li> <li><code>aye</code> - 要锁定以进行“赞成”票的 uint256 余额</li> <li><code>nay</code> - 要锁定以进行“反对”票的 uint256 余额</li> </ul> removeVote(uint32 pollIndex) - 移除投票（公民投票）中的投票。 参数 <ul> <li><code>pollIndex</code> - 投票（公民投票）的 uint32 索引</li> </ul> removeVoteForTrack(uint32 pollIndex, uint16 trackId) - 从投票（公民投票）中特定 track 移除投票。 参数 <ul> <li><code>pollIndex</code> - 投票（公民投票）的 uint32 索引</li> <li><code>trackId</code> - 需要进行请求更改的 uint16 Track ID</li> </ul> removeOtherVote(address target, uint16 trackId, uint32 pollIndex) - 为另一个投票者移除投票（公民投票）中的投票。 参数 <ul> <li><code>target</code> - 具有要移除或解锁的投票或代币的地址</li> <li><code>trackId</code> - 需要进行请求更改的 uint16 Track ID</li> <li><code>pollIndex</code> - 投票（公民投票）的 uint32 索引</li> </ul> delegate(uint16 trackId, address representative, Conviction conviction, uint256 amount) - 委托另一个账户为代表，代表发送账户为特定 Track 投置信加权的投票 参数 <ul> <li><code>trackId</code> - 需要进行请求更改的 uint16 Track ID</li> <li><code>representative</code> - 要委托为代表的账户地址</li> <li><code>conviction</code> - Conviction 代表上述 <code>Conviction</code> 枚举中的一个值</li> <li><code>amount</code> - 要委托的 uint256 余额</li> </ul> undelegate(uint16 trackId) - 移除调用者对特定 Track 的投票委托 参数 <ul> <li><code>trackId</code> - 需要进行请求更改的 uint16 Track ID</li> </ul> unlock(uint16 trackId, address target) - 解锁特定 Track 的特定账户的已锁定代币 参数 <ul> <li><code>trackId</code> - 需要进行请求更改的 uint16 Track ID</li> <li><code>target</code> - 具有要移除或解锁的投票或代币的地址</li> </ul> <p>该接口还包含以下事件：</p> <ul> <li>Voted(uint32 indexed pollIndex, address voter, bool aye, uint256 voteAmount, uint8 conviction) - 当账户进行投票时发出</li> <li>VoteSplit(uint32 indexed pollIndex, address voter, uin256 aye, uint256 nay) - 当账户进行拆分投票时发出</li> <li>VoteSplitAbstained(uint32 indexed pollIndex, address voter, uin256 aye, uint256 nay, uint256 nay) - 当账户进行弃权拆分投票时发出</li> <li>VoteRemoved(uint32 indexed pollIndex, address voter) - 当账户 (<code>voter</code>) 的投票已从正在进行的投票（公民投票）中移除时发出</li> <li>VoteRemovedForTrack(uint32 indexed pollIndex, uint16 trackId, address voter) - 当账户 (<code>voter</code>) 的投票已从特定 Track 的正在进行的投票（公民投票）中移除时发出</li> <li>VoteRemovedOther(uint32 indexed pollIndex, address caller, address target, uint16 trackId) - 当账户 (<code>caller</code>) 移除了另一个账户 (<code>target</code>) 的投票时发出</li> <li>Delegated(uint16 indexed trackId, address from, address to, uint256 delegatedAmount, uint8 conviction) - 当账户 (<code>from</code>) 将给定数量的置信加权投票委托给另一个账户 (<code>to</code>) 时发出</li> <li>Undelegated(uint16 indexed trackId, address caller) - 当账户 (<code>caller</code>) 的委托被移除为特定 Track 时发出</li> <li>Unlocked(uint16 indexed trackId, address caller) - 当账户 (<code>caller</code>) 的锁定代币被解锁为特定 Track 时发出</li> </ul>"}, {"location": "builders/ethereum/precompiles/features/governance/conviction-voting/#interact-with-the-solidity-interface", "title": "与 Solidity 接口交互", "text": ""}, {"location": "builders/ethereum/precompiles/features/governance/conviction-voting/#checking-prerequisites", "title": "检查先决条件", "text": "<p>以下示例在 Moonbase Alpha 上演示，但是，对于 Moonriver，可以采取类似的步骤。要遵循本指南中的步骤，您需要具备以下条件：</p> <ul> <li>安装 MetaMask 并连接到 Moonbase Alpha</li> <li>具有一些 DEV 代币的帐户。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"}, {"location": "builders/ethereum/precompiles/features/governance/conviction-voting/#remix-set-up", "title": "Remix 设置", "text": "<ol> <li>点击文件资源管理器选项卡</li> <li>将 <code>ConvictionVoting.sol</code> 的副本粘贴到名为 <code>ConvictionVoting.sol</code> 的 Remix 文件 中</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/governance/conviction-voting/#compile-the-contract", "title": "编译合约", "text": "<ol> <li>点击顶部的第二个 Compile 选项卡</li> <li>然后要编译接口，点击 Compile ConvictionVoting.sol</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/governance/conviction-voting/#access-the-contract", "title": "访问合约", "text": "<ol> <li>点击Remix中Compile标签正下方的Deploy and Run标签。注意：您不是在此处部署合约，而是访问已部署的预编译合约</li> <li>确保在ENVIRONMENT下拉菜单中选择了Injected Provider - Metamask</li> <li>确保在CONTRACT下拉菜单中选择了ConvictionVoting.sol。由于这是一个预编译合约，因此无需部署，而是需要在At Address字段中提供预编译的地址</li> <li>提供 Moonbase Alpha 的 Conviction Voting Precompile 地址：<code>0x0000000000000000000000000000000000000812</code>，然后点击 At Address</li> <li>Conviction Voting Precompile 将出现在 Deployed Contracts 列表中</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/governance/conviction-voting/#vote-on-a-referendum", "title": "投票表决", "text": "<p>您可以在引导期或决定期的任何时间锁定代币并对全民公投进行投票。为了使全民公投获得通过，它需要获得最低的批准和支持，这因轨道而异。有关每个相关期间以及各轨道批准和支持要求的更多信息，请参阅治理概述页面的 OpenGov 部分。</p> <p>首先，您需要获取要投票的全民公投的索引。要获取全民公投的索引，请前往 Polkadot.js Apps 并执行以下步骤：</p> <ol> <li>从治理选项卡下拉菜单中，选择全民公投</li> <li>找到您想要投票的全民公投。您可以通过单击三角形图标查看有关特定全民公投的更多详细信息。如果没有三角形图标，则表示仅提交了提案哈希，尚未提交提案的预映像</li> <li>记下全民公投索引</li> </ol> <p></p> <p>现在，您可以返回 Remix 以通过信念投票预编译合约对全民公投进行投票。您可以使用两种方法对全民公投进行投票：<code>voteYes</code> 或 <code>voteNo</code>。您可能已经发现，如果您同意该提案，您将使用 <code>voteYes</code>，如果不同意，您将使用 <code>voteNo</code>。您将指定您想要通过投票锁定的代币数量和信念，使用您想要在前面提到的 <code>Conviction</code> 枚举中投票的信念的索引。例如，如果您想在一个成功的投票后锁定您的代币两个颁布期，您将在 <code>Locked2x</code> 信念中输入 <code>2</code>。有关信念的更多信息，您可以查看Governance v2 文档的信念乘数部分。</p> <p>要提交您的投票，您可以采取以下步骤：</p> <ol> <li>展开信念投票预编译合约以查看可用的函数（如果尚未打开）</li> <li>找到 voteYes 或 voteNo 函数（无论您想如何投票），然后按按钮展开该部分</li> <li>输入要投票的全民公投的索引</li> <li>输入要以 Wei 锁定的代币数量。避免在此处输入您的全部余额，因为您需要支付交易费用</li> <li>输入您想要投票的信念</li> <li>按交易并在 MetaMask 中确认交易</li> </ol> <p></p> <p>全民公投结束后，您可以使用信念投票预编译合约来删除您的投票并解锁您的代币。</p>"}, {"location": "builders/ethereum/precompiles/features/governance/conviction-voting/#delegate-a-vote", "title": "委托投票", "text": "<p>除了自己对全民公投进行投票外，您还可以将具有信念权重的投票委托给在特定主题上更了解的人代表您投票，这个过程称为投票委托。您甚至可以为每个 Track 委托一个不同的帐户。</p> <p>要开始，您可以采取以下步骤：</p> <ol> <li>找到 delegate 函数并按下按钮以展开该部分</li> <li>输入您希望委托使用的 Track 的 Track ID。Track ID 可以在 Polkadot.js Apps 的 Referenda 页面 中找到</li> <li>输入将有权代表您投票的委托帐户</li> <li>输入他们可以使用的 Wei 中的代币数量。避免在此处输入您的全部余额，因为您需要支付交易手续费</li> <li>输入他们可以使用的信念</li> <li>按下 transact 并在 MetaMask 中确认交易</li> </ol> <p></p> <p>现在，委托帐户可以代表您投票！如果您不再希望委托投票存在，您可以使用信念投票预编译的 <code>undelegate</code> 函数将其删除。</p> <p>就这样！您已完成对 Conviction Voting Precompile 的介绍。<code>ConvictionVoting.sol</code> 中记录了更多功能 — 如果您对这些功能或信念投票预编译的任何其他方面有任何疑问，请随时通过 Discord 与我们联系。</p>"}, {"location": "builders/ethereum/precompiles/features/governance/preimage/", "title": "与 Preimage 预编译合约交互", "text": ""}, {"location": "builders/ethereum/precompiles/features/governance/preimage/#introduction", "title": "介绍", "text": "<p>作为一个 Polkadot 平行链和去中心化网络，Moonbeam 具有原生的链上治理功能，使利益相关者能够参与到网络的发展方向中。随着 OpenGov（也称为 Governance v2）的引入，Preimage Pallet 允许代币持有者通过提交 preimage 来创建提案，preimage 是提案中要执行的操作，在链上。提交提案需要 preimage 的哈希值。要了解更多关于 Moonbeam 治理系统的信息，例如相关术语的概述、提案的路线图等等，请参阅 Moonbeam 上的治理 页面。</p> <p>Preimage Precompile 直接与 Substrate 的 Preimage Pallet 交互。该 pallet 是用 Rust 编写的，通常无法从 Moonbeam 的以太坊端访问。但是，Preimage Precompile 允许您访问创建和管理 preimage 所需的函数，所有这些函数都是 Substrate Preimage Pallet 的一部分，直接从 Solidity 接口访问。</p> <p>Preimage Precompile 位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p>text  0x0000000000000000000000000000000000000813</p> <p>text  0x0000000000000000000000000000000000000813</p> <p>text  0x0000000000000000000000000000000000000813</p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/features/governance/preimage/#the-preimage-solidity-interface", "title": "预映像Solidity接口", "text": "<p><code>Preimage.sol</code> 是一个 Solidity 接口，允许开发人员与预编译的两种方法进行交互：</p> notePreimage(bytes memory encodedProposal) - 在链上注册即将到来的提案的预映像。这不需要提案在调度队列中，但确实需要一旦颁布就会退还的存款。 参数 <ul> <li><code>encodedProposal</code> - 包含要注册的编码提案的字节内存。返回预映像哈希</li> </ul> unnotePreimage(bytes32 hash) - 从存储中清除未请求的预映像。 参数 <ul> <li><code>hash</code> - 要从存储中移除的预映像的 bytes32 哈希</li> </ul> <p>该接口还包括以下事件：</p> <ul> <li>PreimageNoted(bytes32 hash) - 在链上注册预映像时发出</li> <li>PreimageUnnoted(bytes32 hash) - 在链上取消注册预映像时发出</li> </ul>"}, {"location": "builders/ethereum/precompiles/features/governance/preimage/#interact-with-the-solidity-interface", "title": "与 Solidity 接口交互", "text": ""}, {"location": "builders/ethereum/precompiles/features/governance/preimage/#checking-prerequisites", "title": "检查先决条件", "text": "<p>以下示例在 Moonbase Alpha 上演示，但是，也可以对 Moonriver 采取类似的步骤。要按照本指南中的步骤进行操作，您需要具备以下条件：</p> <ul> <li>安装了 MetaMask 并连接到 Moonbase Alpha</li> <li>一个包含一些 DEV 代币的帐户。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"}, {"location": "builders/ethereum/precompiles/features/governance/preimage/#remix-set-up", "title": "Remix 设置", "text": "<ol> <li>点击文件资源管理器选项卡</li> <li>将<code>Preimage.sol</code>的副本粘贴到名为 <code>Preimage.sol</code> 的 Remix 文件中</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/governance/preimage/#compile-the-contract", "title": "编译合约", "text": "<ol> <li>点击顶部第二个 Compile 选项卡</li> <li>然后编译接口，点击 Compile Preimage.sol</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/governance/preimage/#access-the-contract", "title": "访问合约", "text": "<ol> <li>点击 Remix 中编译选项卡正下方的部署和运行选项卡。注意：您不是在此处部署合约，而是访问已部署的预编译合约</li> <li>确保在ENVIRONMENT下拉菜单中选择了注入提供程序 - Metamask</li> <li>确保在CONTRACT下拉菜单中选择了Preimage.sol。由于这是一个预编译合约，因此无需部署，而是要在“At Address”字段中提供预编译的地址</li> <li>提供 Moonbase Alpha 的 Preimage 预编译地址：<code>0x0000000000000000000000000000000000000813</code>，然后点击“At Address”</li> <li>Preimage 预编译将出现在已部署合约列表中</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/governance/preimage/#submit-a-preimage", "title": "提交提案的预映像", "text": "<p>为了提交提案，您首先需要提交该提案的预映像，该预映像本质上定义了链上的拟议操作。您可以使用 Preimage 预编译的 <code>notePreimage</code> 函数提交预映像。<code>notePreimage</code> 函数接受编码后的提案，因此您需要采取的第一个步骤是获取编码后的提案，这可以使用 Polkadot.js Apps 轻松完成。</p> <p>在本节中，您将获取提案的预映像哈希和编码后的提案数据。要获取预映像哈希，您首先需要导航到 Polkadot.js Apps 的 Preimage 页面：</p> <ol> <li>导航到 Governance 选项卡</li> <li>从下拉列表中选择 Preimages</li> <li>在 Preimages 页面中，单击 + Add preimage</li> </ol> <p></p> <p>然后按照以下步骤操作：</p> <ol> <li>选择一个帐户（任何帐户都可以，因为您在此处未提交任何交易）</li> <li>选择要与之交互的 pallet 和要提议的可分派函数（或操作）。您选择的操作将决定需要在以下步骤中填写的字段。在此示例中，它是 system pallet 和 remark 函数</li> <li>输入备注的文本，确保它是唯一的。重复的提案（如“Hello World!”）将不被接受</li> <li>单击 Submit preimage 按钮，但不要在下一页上签名或确认交易</li> </ol> <p></p> <p>在下一个屏幕上，按照以下步骤操作：</p> <ol> <li>按下三角形图标以显示字节中的编码提案</li> <li>复制 bytes（编码提案）— 在调用 <code>notePreimage</code> 函数时需要用到它</li> </ol> <p></p> <p>Note</p> <p>您不应在此处签名并提交交易。您将在下一步中通过 <code>notePreimage</code> 函数提交此信息。</p> <p>现在，您可以获取从 Polkadot.js Apps 获取的编码提案的 bytes，并通过 Preimage 预编译的 <code>notePreimage</code> 函数提交它。要通过 <code>notePreimage</code> 函数提交预映像，请按照以下步骤操作：</p> <ol> <li>展开 Preimage 预编译合约以查看可用的函数</li> <li>找到 notePreimage 函数，然后按下按钮以展开该部分</li> <li>提供您在前一节中记下的编码提案的 bytes。注意，编码提案与预映像哈希不同。确保您在此字段中输入正确的值</li> <li>按 transact 并在 MetaMask 中确认交易</li> </ol> <p></p> <p>现在您已经提交了提案的预映像，您的提案就可以提交了！前往 Referenda 预编译文档 了解如何提交您的提案。</p> <p>如果您希望删除预映像，您可以按照上面记录的相同步骤操作，除了使用 <code>unnotePreimage</code> 函数并传入预映像哈希而不是编码提案。</p>"}, {"location": "builders/ethereum/precompiles/features/governance/referenda/", "title": "与Referenda预编译交互", "text": ""}, {"location": "builders/ethereum/precompiles/features/governance/referenda/#introduction", "title": "简介", "text": "<p>作为 Polkadot 平行链和去中心化网络，Moonbeam 具有原生的链上治理功能，使利益相关者能够参与到网络的发展方向中。随着 OpenGov（也称为 Governance v2）的推出，Referenda Pallet 允许代币持有者获取有关现有公投的信息、提交提案以供公投，并管理与决策保证金相关的操作，决策保证金是决定公投所需的内容。要了解有关 Moonbeam 治理系统的更多信息，例如相关术语、原则、机制等的概述，请参阅Moonbeam 上的治理页面。</p> <p>Referenda Precompile 直接与 Substrate 的 Referenda Pallet 交互。此 pallet 以 Rust 编写，通常无法从 Moonbeam 的以太坊端访问。但是，它允许您访问查看公投、提交公投和管理所需决策保证金所需的功能。这些功能是 Substrate Referenda Pallet 的一部分，可以直接从 Solidity 接口访问。</p> <p>Referenda Precompile 位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p>text  0x0000000000000000000000000000000000000811</p> <p>text  0x0000000000000000000000000000000000000811</p> <p>text  0x0000000000000000000000000000000000000811</p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/features/governance/referenda/#the-referenda-solidity-interface", "title": "Referenda Solidity接口", "text": "<p><code>Referenda.sol</code> 是一个Solidity接口，允许开发者与预编译的方法进行交互。</p> <p>方法如下：</p> referendumCount() - 一个只读函数，返回全民公投总数 参数返回 <p>无。</p> <ul> <li><code>uint256</code> 全民公投总数</li> </ul> submissionDeposit() - 一个只读函数，返回每次全民公投所需的提交保证金 参数返回 <p>无。</p> <ul> <li><code>uint256</code> 所需提交保证金的金额</li> </ul> decidingCount(uint16 trackId) - 一个只读函数，返回给定Track的正在决定的全民公投总数 参数返回 <ul> <li><code>trackId</code> - 要查询决定计数的uint16 Track ID</li> </ul> <ul> <li><code>uint256</code> 指定Track的决定全民公投的计数</li> </ul> trackIds() - 一个只读函数，返回所有Track（和Origin）的Track ID列表 参数返回 <p>无。</p> <ul> <li><code>uint16[]</code> Track ID数组</li> </ul> trackInfo(uint16 trackId) - 一个只读函数，返回为给定Track ID配置的以下治理参数 参数返回 <ul> <li><code>trackId</code> - 要查询参数的uint16 Track ID</li> </ul> <ul> <li><code>string</code> name - Track的名称</li> <li><code>uint256</code> maxDeciding - 一次可以决定的全民公投的最大数量</li> <li><code>uint256</code> decisionDeposit - 决策保证金的金额</li> <li><code>uint256</code> preparePeriod - 准备期的持续时间</li> <li><code>uint256</code> decisionPeriod - 决策期的持续时间</li> <li><code>uint256</code> confirmPeriod - 确认期的持续时间</li> <li><code>uint256</code> minEnactmentPeriod - 实施期必须的最小时间量</li> <li><code>bytes</code> minApproval - 批准所需的最小“赞成”票数，占总体信念加权票数的百分比</li> <li><code>bytes</code> minSupport - 批准所需的最小“赞成”票数，不考虑信念加权票，占总供应量的百分比</li> </ul> referendumStatus(uint32 referendumIndex) - 一个只读函数，返回给定全民公投的状态 参数返回 <ul> <li><code>referendumIndex</code> - 要查询状态的全民公投的uint32索引</li> </ul> <p>ReferendumStatus枚举： <pre><code>enum ReferendumStatus {\n     Ongoing,\n     Approved,\n     Rejected,\n     Cancelled,\n     TimedOut,\n     Killed\n}\n</code></pre></p> ongoingReferendumInfo(uint32 referendumIndex) - 一个只读函数，返回与正在进行的全民公投有关的信息 参数返回 <ul> <li><code>referendumIndex</code> - 要查询的正在进行中的全民公投的uint32索引</li> </ul> <ul> <li><code>uint16</code> trackId - 此全民公投的Track</li> <li><code>bytes</code> origin - 此全民公投的Origin</li> <li><code>bytes</code> proposal - 全民公投的提案哈希</li> <li><code>bool</code> enactmentType - 如果提案计划在颁布时分派，则为<code>true</code>；如果在颁布时间之后分派，则为<code>false</code></li> <li><code>uint256</code> enactmentTime - 提案应计划颁布的时间</li> <li><code>uint256</code> submissionTime - 提交时间</li> <li><code>address</code> submissionDepositor - 提交保证金的存款人地址</li> <li><code>uint256</code> submissionDeposit - 提交保证金的金额</li> <li><code>address</code> decisionDepositor - 决策保证金的存款人地址</li> <li><code>uint256</code> decisionDeposit - 决策保证金的金额</li> <li><code>uint256</code> decidingSince - 此全民公投进入决策期的时间</li> <li><code>uint256</code> decidingConfirmingEnd - 此全民公投计划离开确认期的时间</li> <li><code>uint256</code> ayes - “赞成”票数，以信念锁定投票后的形式表示</li> <li><code>uint32</code> support - “赞成”票的百分比，以总投票类别中信念锁定前的形式表示</li> <li><code>uint32</code> approval - “赞成”和“反对”票中“赞成”票的百分比</li> <li><code>bool</code> inQueue - 如果此全民公投已放入队列中以供决定，则为<code>true</code></li> <li><code>uint256</code> alarmTime - 下一个计划的唤醒时间</li> <li><code>bytes</code> taskAddress - 如果计划了，则为调度程序任务地址</li> </ul> closedReferendumInfo(uint32 referendumIndex) - 一个只读函数，返回与已结束的全民公投有关的信息 参数返回 <ul> <li><code>referendumIndex</code> - 要查询的已结束的全民公投的uint32索引</li> </ul> <ul> <li><code>uint256</code> end - 全民公投结束的时间</li> <li><code>address</code> submissionDepositor - 提交保证金的存款人地址</li> <li><code>uint256</code> submissionDeposit - 提交保证金的金额</li> <li><code>address</code> decisionDepositor - 决策保证金的存款人地址</li> <li><code>uint256</code> decisionDeposit - 决策保证金的金额</li> </ul> killedReferendumBlock(uint32 referendumIndex) - 一个只读函数，返回给定全民公投被终止的区块 参数返回 <ul> <li><code>referendumIndex</code> - 要查询的已终止的全民公投的uint32索引</li> </ul> <ul> <li><code>uint256</code> 全民公投被终止的区块号</li> </ul> submitAt(uint16 trackId, bytes32 proposalHash, uint32 proposalLen, uint32 block) - 提交全民公投，指定一个Track ID，该ID对应于要从中分派提案的来源。返回提交的全民公投的公民投票索引 参数返回 <ul> <li><code>trackId</code> - uint16 Track ID，对应于要从中分派提案的来源</li> <li><code>proposalHash</code> - 建议的运行时调用的bytes32前像哈希</li> <li><code>proposalLen</code> - 提案的uint32长度</li> <li><code>block</code> - 在执行此操作的uint32区块号</li> </ul> <ul> <li><code>uint32</code> 提交的全民公投的索引</li> </ul> submitAfter(uint16 trackId, bytes32 proposalHash, uint32 proposalLen, uint32 block) - 提交全民公投，指定一个Track ID，该ID对应于要从中分派提案的来源。返回提交的全民公投的公民投票索引 参数返回 <ul> <li><code>trackId</code> - uint16 Track ID，对应于要从中分派提案的来源</li> <li><code>proposalHash</code> - 建议的运行时调用的bytes32前像哈希</li> <li><code>proposalLen</code> - 提案的uint32长度</li> <li><code>block</code> - 之后将执行此操作的uint32区块号</li> </ul> <ul> <li><code>uint32</code> 提交的全民公投的索引</li> </ul> placeDecisionDeposit(uint32 index) - 给定正在进行的全民公投的索引，发布全民公投的决策保证金 参数返回 <ul> <li><code>index</code> - 要放置决策保证金的正在进行中的全民公投的uint32索引</li> </ul> <p>无。</p> refundDecisionDeposit(uint32 index) - 将已结束的全民公投的决策保证金退还给存款人 参数返回 <ul> <li><code>index</code> - 决策保证金仍被锁定的已结束的全民公投的uint32索引</li> </ul> <p>无。</p> refundSubmissionDeposit(uint32 index) - 将已结束的全民公投的提交保证金退还给存款人 参数返回 <ul> <li><code>index</code> - 要退还提交保证金的已结束的全民公投的uint32索引</li> </ul> <p>无。</p> <p>该接口还包括以下事件：</p> <ul> <li>SubmittedAt(uint16 indexed trackId, uint32 referendumIndex, bytes32 hash) - 当全民公投在给定区块被提交时，会发出此事件</li> <li>SubmittedAfter(uint16 indexed trackId, uint32 referendumIndex, bytes32 hash) - 当全民公投在给定区块后被提交时，会发出此事件</li> <li>DecisionDepositPlaced(uint32 index, address caller, uint256 depositedAmount) - 当全民公投的决策保证金被放置时，会发出此事件</li> <li>DecisionDepositRefunded(uint32 index, address caller, uint256 refundedAmount) - 当已结束的全民公投的决策保证金被退还时，会发出此事件</li> <li>SubmissionDepositRefunded(uint32 index, address caller, uint256 refundedAmount) - 当有效全民公投的提交保证金被退还时，会发出此事件</li> </ul>"}, {"location": "builders/ethereum/precompiles/features/governance/referenda/#interact-with-the-solidity-interface", "title": "与Solidity接口交互", "text": ""}, {"location": "builders/ethereum/precompiles/features/governance/referenda/#checking-prerequisites", "title": "检查先决条件", "text": "<p>以下示例在 Moonbase Alpha 上演示，但是，类似步骤也可用于 Moonriver。要遵循本指南中的步骤，您需要具备以下条件：</p> <ul> <li>安装了 MetaMask 并连接到 Moonbase Alpha</li> <li>一个拥有一些 DEV 代币的帐户。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"}, {"location": "builders/ethereum/precompiles/features/governance/referenda/#remix-set-up", "title": "Remix 设置", "text": "<ol> <li>点击文件浏览器标签</li> <li>将<code>Referenda.sol</code>的副本粘贴到名为<code>Referenda.sol</code>的 Remix 文件中</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/governance/referenda/#compile-the-contract", "title": "编译合约", "text": "<ol> <li>点击顶部的第二个 Compile 选项卡</li> <li>然后要编译接口，请点击 Compile Referenda.sol</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/governance/referenda/#access-the-contract", "title": "访问合约", "text": "<ol> <li>点击 Remix 中Compile选项卡正下方的Deploy and Run选项卡。注意：您无需在此处部署合约，而是访问一个已部署的预编译合约</li> <li>确保在 ENVIRONMENT 下拉菜单中选择了 Injected Provider - Metamask</li> <li>确保在 CONTRACT 下拉菜单中选择了 Referenda.sol。由于这是一个预编译的合约，因此无需部署，而是要在 At Address 字段中提供预编译的地址</li> <li>提供 Moonbase Alpha 的 Referenda 预编译地址：<code>0x0000000000000000000000000000000000000811</code>，然后点击 At Address</li> <li>Referenda 预编译将出现在 Deployed Contracts 列表中</li> </ol>"}, {"location": "builders/ethereum/precompiles/features/governance/referenda/#submit-a-proposal", "title": "提交提案", "text": "<p>为了提交提案，您应该已经提交了提案的预映像哈希值。如果您还没有这样做，请按照预映像预编译文档中概述的步骤进行操作。有两种方法可以用来提交提案：<code>submitAt</code> 和 <code>submitAfter</code>。<code>submitAt</code> 函数提交一个提案，以便在给定的区块执行，而 <code>submitAfter</code> 函数提交一个提案，以便在特定的区块之后执行。在本示例中，将使用 <code>submitAt</code> ，但是如果您想使用 <code>submitAfter</code> ，也可以应用相同的步骤。</p> <p>要提交提案，您需要确定您的提案属于哪个 Track 以及该 Track 的 Track ID。如需这些要求的帮助，您可以参考治理概述页面的 OpenGov 部分。</p> <p>您还需要确保您手头有预映像哈希和预映像的长度，这两者都应该从遵循预映像预编译文档中的步骤获得。如果您不确定，您可以从 Polkadot.js Apps 的预映像页面找到您的预映像，并复制预映像哈希。要获得预映像的长度，您可以从 Polkadot.js Apps Chain State 页面使用 <code>preimageFor</code> 方法查询 <code>preimage</code> pallet。</p> <p>一旦您有了 Track ID、预映像哈希和预映像长度，您就可以使用 Referenda Precompile 提交提案了。从 Remix 中，您可以采取以下步骤：</p> <ol> <li>展开 Referenda Precompile 合约以查看可用的函数</li> <li>找到 submitAt 函数，然后按按钮展开该部分</li> <li>输入您的提案将通过处理的 Track ID</li> <li>输入预映像哈希。您应该已经从遵循预映像预编译文档中的步骤获得</li> <li>输入预映像的长度</li> <li>输入您希望提案执行的区块</li> <li>按 transact 并在 MetaMask 中确认交易</li> </ol> <p></p> <p>在您的交易被确认后，您将能够在 Polkadot.js Apps 的 Referenda 页面上看到列出的提案。您还可以在 Polkassembly 上查看您的提案，该网站按提案所属的 Track 对提案进行排序。</p>"}, {"location": "builders/ethereum/precompiles/features/governance/referenda/#submit-decision-deposit", "title": "提交决策保证金", "text": "<p>既然您已经提交了提案，下一步是提交决策保证金。决策保证金是指提案在导入期结束时进入决策阶段所需的最低保证金金额。有关决策保证金的更多信息，请参阅治理概述页面的 OpenGov 部分。</p> <p>您可以使用 Referenda Precompile 的 <code>placeDecisionDeposit</code> 函数提交决策保证金。您只需要拥有提案的索引和足够的资金即可。决策保证金因 Track 而异，要查找所需的最低金额，您可以查看治理概述页面上的按 Track 常规参数表。</p> <p>要提交保证金，您可以按照以下步骤操作：</p> <ol> <li>找到 placeDecisionDeposit 函数，然后按按钮展开该部分</li> <li>输入提案的索引</li> <li>按 transact 并在 MetaMask 中确认交易</li> </ol> <p></p> <p>现在已经放置了决策保证金，提案离进入决策期又近了一步。还需要在指定的 Track 中有足够的容量，并且必须经过准备期的持续时间才能进入决策期。</p> <p>要对提案进行投票，您可以按照 Conviction Voting Precompile 文档中概述的步骤进行操作。</p>"}, {"location": "builders/ethereum/precompiles/features/governance/referenda/#refund-decision-deposit", "title": "退还决策保证金", "text": "<p>一旦全民投票被批准或拒绝，决策保证金即可退还。只要全民投票没有因提案具有恶意而被取消，情况就是如此。如果提案被认为是恶意的，并通过 Root Track 或 Emergency Killer Track 终止，则决策保证金将被削减。</p> <p>要退还决策保证金，您可以使用 Referenda 预编译的 <code>refundDecisionDeposit</code> 函数。为此，您可以采取以下步骤：</p> <ol> <li>找到 refundDecisionDeposit 函数，然后按按钮展开该部分</li> <li>输入全民投票的索引</li> <li>按 transact，然后在 MetaMask 中确认交易</li> </ol> <p></p> <p>就是这样！您已完成 Referenda 预编译的介绍。<code>Referenda.sol</code> 中记录了更多函数 — 如果您对这些函数或 Referenda 预编译的任何其他方面有任何疑问，请随时通过 Discord 联系。</p>"}, {"location": "builders/ethereum/precompiles/interoperability/gmp/", "title": "与 GMP 预编译交互", "text": ""}, {"location": "builders/ethereum/precompiles/interoperability/gmp/#introduction", "title": "简介", "text": "<p>Moonbeam 路由流动性 (MRL) 是指 Moonbeam 作为始发链的流动性进入其他 Polkadot 平行链的端口平行链的用例。这可以通过通用消息传递 (GMP) 实现，其中具有任意数据和代币的消息可以通过链无关 GMP 协议跨非平行链区块链发送。这些 GMP 协议可以与 Polkadot 的 XCM 消息传递系统 结合使用，以实现无缝的流动性路由。</p> <p>GMP 预编译充当 Moonbeam 路由流动性的接口，充当来自 GMP 协议的携带代币的消息与通过 XCMP 连接到 Moonbeam 的平行链之间的中间人。目前，GMP 预编译仅支持通过 Wormhole GMP 协议 中继流动性。</p> <p>GMP 预编译位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p>text  0x0000000000000000000000000000000000000816</p> <p>text  0x0000000000000000000000000000000000000816</p> <p>text  0x0000000000000000000000000000000000000816</p> <p>在实践中，开发人员不太可能直接与预编译交互。GMP 协议的中继器与预编译交互以完成跨链操作，因此跨链操作发起的始发链是开发人员有责任确保最终使用 GMP 预编译的地方。</p>"}, {"location": "builders/ethereum/precompiles/interoperability/gmp/#the-gmp-solidity-interface", "title": "GMP Solidity 接口", "text": "<p><code>Gmp.sol</code> 是一个 Solidity 接口，允许开发人员与预编译进行交互。</p> Gmp.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Gmp contract's address.\naddress constant GMP_ADDRESS = 0x0000000000000000000000000000000000000816;\n\n/// @dev The Gmp contract's instance.\nGmp constant GMP_CONTRACT = Gmp(GMP_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Gmp precompile\n/// @dev Provides an endpoint to Gmp protocols which can automatically forward to XCM\n/// @custom:address 0x0000000000000000000000000000000000000816\ninterface Gmp {\n    // TODO: Here we would specify the endpoints for each GMP protocol on a case by case basis.\n    //       These endpoints are basically the hand offs for each protocol -- where they delegate to\n    //       the target contract.\n    //\n    //       This design should allow users to interact with this precompile with no changes to the\n    //       underlying GMP protocols by simply specifying the correct precompile as the target.\n\n    /// Receive a wormhole VAA and process it\n    ///\n    /// @custom:selector f53774ab\n    function wormholeTransferERC20(bytes memory vaa) external;\n}\n</code></pre> <p>GMP 预编译有一个方法：</p> <ul> <li>wormholeTransferERC20(bytes memory vaa) - 接收 Wormhole 桥接传输 已验证操作批准 (VAA)，通过 Wormhole 代币桥铸造代币，并将流动性转发到自定义负载的 多位置。有效负载应为预编译特定的 SCALE 编码对象，如本指南的 为 Wormhole 构建有效负载 部分中所述</li> </ul> <p>VAA 是在原始链交易后生成的包含有效负载的包，由 Wormhole 守护者 发现。</p> <p>用户必须与预编译交互的最常见情况是在恢复期间，即中继器未完成 MRL 交易。例如，用户必须搜索其原始链交易随附的 VAA，并手动调用 <code>wormholeTransferERC20</code> 函数。</p>"}, {"location": "builders/ethereum/precompiles/interoperability/gmp/#building-the-payload-for-wormhole", "title": "构建 Wormhole 的有效负载", "text": "<p>目前，GMP 预编译仅支持通过 Wormhole、Moonbeam 并进入其他平行链来发送流动性。GMP 预编译不协助从平行链返回 Moonbeam，进而返回 Wormhole 连接链的路线。</p> <p>要从像 Ethereum 这样的 Wormhole 连接的原始链发送流动性，用户必须在 原始链的部署上调用 <code>transferTokensWithPayload</code> 方法，该部署是 WormholeTokenBridge 智能合约。此函数需要一个字节有效负载，该有效负载必须格式化为 SCALE 编码的多位置对象，并包装在 另一个预编译特定的版本类型中。</p> <p>如果您不熟悉 Polkadot 生态系统，您可能不熟悉 SCALE 编码和多位置。SCALE 编码是 Polkadot 使用的一种紧凑的编码形式。 <code>MultiLocation</code> 类型用于定义 Polkadot 中的相对点，例如特定平行链（Polkadot 区块链）上的特定帐户。</p> <p>Moonbeam 的 GMP 协议需要一个多位置来表示流动性路由的目的地，这很可能意味着另一个平行链上的一个帐户。无论它是什么，此目的地都必须表示为相对于 Moonbeam。</p> <p>Remember</p> <p>多位置的相对性很重要，因为平行链团队可能会错误地给您一个相对于他们自己链的多位置，这可能会有所不同。提供不正确的多位置可能会导致资金损失！</p> <p>每个平行链都有其解释多位置的特定方法，并且应与项目确认您形成的多位置是否正确。但是，您很可能正在使用帐户形成多位置。</p> <p>多种类型的帐户可以包含在多位置中，您在构建多位置时必须事先知道。最常见的两种是：</p> <ul> <li>AccountKey20 — 长度为 20 字节的帐户 ID，包括与 Ethereum 兼容的帐户 ID，例如 Moonbeam 上的帐户 ID</li> <li>AccountId32 — 长度为 32 字节的帐户 ID，Polkadot 及其平行链中的标准</li> </ul> <p>以下多位置模板以 Moonbeam 作为相对原点，定位其他平行链上的帐户。要使用它们，请将 <code>INSERT_PARACHAIN_ID</code> 替换为您要将资金发送到的网络的平行链 ID，并将 <code>INSERT_ADDRESS</code> 替换为您要将资金发送到该平行链上的帐户地址。</p> AccountId32AccountKey20 <pre><code>{\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { Parachain: 'INSERT_PARACHAIN_ID' },\n        {\n          AccountId32: {\n            id: 'INSERT_ADDRESS',\n          },\n        },\n      ],\n    },\n  },\n};\n</code></pre> <pre><code>{\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { Parachain: 'INSERT_PARACHAIN_ID' },\n        {\n          AccountKey20: {\n            key: 'INSERT_ADDRESS',\n          },\n        },\n      ],\n    },\n  }\n};\n</code></pre> <p>如果没有合适的工具，正确地 SCALE 编码整个有效负载可能具有挑战性，这主要是由于 预编译所需的自定义类型。幸运的是，Polkadot.js API 可以帮助解决这个问题。</p> <p>预编译所需的版本化用户操作接受两个版本：V1 和 V2。V1 接受 <code>XcmRoutingUserAction</code> 类型，该类型尝试将转移的资产路由到多位置定义的 Destination。V2 接受 <code>XcmRoutingUserActionWithFee</code> 类型，该类型也尝试将转移的资产路由到 Destination，并允许支付费用。Relayer 可以使用 V2 在 Moonbeam 上指定费用，以将交易转发到给定的 Destination。</p> <p>以下脚本展示了如何创建一个 <code>Uint8Array</code>，该 <code>Uint8Array</code> 可用作 GMP 预编译的有效负载：</p> V1 有效载荷V2 有效载荷 <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nenum MRLTypes {\n  // Runtime defined MultiLocation. Allows for XCM versions 2, 3, and 4\n  XcmVersionedLocation = 'XcmVersionedLocation',\n  // MRL payload (V1) that only defines the destination MultiLocation\n  XcmRoutingUserAction = 'XcmRoutingUserAction',\n  // Wrapper object for the MRL payload\n  VersionedUserAction = 'VersionedUserAction',\n}\n\n// Parachain IDs of each parachain\nenum Parachain {\n  MoonbaseBeta = 888,\n  // Insert additional parachain IDs\n}\n\n// List of parachains that use ethereum (20) accounts\nconst ETHEREUM_ACCOUNT_PARACHAINS = [Parachain.MoonbaseBeta];\n\n// A function that creates a SCALE encoded payload to use with transferTokensWithPayload\nasync function createMRLPayload(\n  parachainId: Parachain,\n  account: string\n): Promise&lt;Uint8Array&gt; {\n  // Create a multilocation object based on the target parachain's account type\n  const isEthereumStyle = ETHEREUM_ACCOUNT_PARACHAINS.includes(parachainId);\n  const multilocation = {\n    V4: {\n      parents: 1,\n      interior: {\n        X2: [\n          { Parachain: parachainId },\n          isEthereumStyle\n            ? { AccountKey20: { key: account } }\n            : { AccountId32: { id: account } },\n        ],\n      },\n    },\n  };\n\n  // Creates an API for Moonbeam that defines MRL's special types\n  const wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n  const api = await ApiPromise.create({\n    provider: wsProvider,\n    types: {\n      [MRLTypes.XcmRoutingUserAction]: {\n        destination: MRLTypes.XcmVersionedLocation,\n      },\n      [MRLTypes.VersionedUserAction]: {\n        _enum: { V1: MRLTypes.XcmRoutingUserAction },\n      },\n    },\n  });\n\n  // Format multilocation object as a Polkadot.js type\n  const versionedLocation = api.createType(\n    MRLTypes.XcmVersionedLocation,\n    multilocation\n  );\n  const userAction = api.createType(MRLTypes.XcmRoutingUserAction, {\n    destination: versionedLocation,\n  });\n\n  // Wrap and format the MultiLocation object into the precompile's input type\n  const versionedUserAction = api.createType(MRLTypes.VersionedUserAction, {\n    V1: userAction,\n  });\n\n  // Disconnect the API\n  api.disconnect();\n\n  // SCALE encode resultant precompile formatted objects\n  return versionedUserAction.toU8a();\n}\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { u256 } from '@polkadot/types';\n\nenum MRLTypes {\n  // Runtime defined MultiLocation. Allows for XCM versions 2 and 3\n  XcmVersionedLocation = 'XcmVersionedLocation',\n  // MRL payload (V2) that defines the destination MultiLocation and a\n  // fee for the relayer\n  XcmRoutingUserActionWithFee = 'XcmRoutingUserActionWithFee',\n  // Wrapper object for the MRL payload\n  VersionedUserAction = 'VersionedUserAction',\n}\n\n// Parachain IDs of each parachain\nenum Parachain {\n  MoonbaseBeta = 888,\n  // Insert additional parachain IDs\n}\n\n// List of parachains that use ethereum (20) accounts\nconst ETHEREUM_ACCOUNT_PARACHAINS = [Parachain.MoonbaseBeta];\n\n// A function that creates a SCALE encoded payload to use with\n// transferTokensWithPayload\nasync function createMRLPayload(\n  parachainId: Parachain,\n  account: string,\n  fee: u256\n): Promise&lt;Uint8Array&gt; {\n  // Create a multilocation object based on the target parachain's account\n  // type\n  const isEthereumStyle = ETHEREUM_ACCOUNT_PARACHAINS.includes(parachainId);\n  const multilocation = {\n    V4: {\n      parents: 1,\n      interior: {\n        X2: [\n          { Parachain: parachainId },\n          isEthereumStyle\n            ? { AccountKey20: { key: account } }\n            : { AccountId32: { id: account } },\n        ],\n      },\n    },\n  };\n\n  // Creates an API for Moonbeam that defines MRL's special types\n  const wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n  const api = await ApiPromise.create({\n    provider: wsProvider,\n    types: {\n      [MRLTypes.XcmRoutingUserActionWithFee]: {\n        destination: MRLTypes.XcmVersionedLocation,\n        fee: 'U256',\n      },\n      [MRLTypes.VersionedUserAction]: {\n        _enum: { V2: MRLTypes.XcmRoutingUserActionWithFee },\n      },\n    },\n  });\n\n  // Format multilocation object as a Polkadot.js type\n  const versionedLocation = api.createType(\n    MRLTypes.XcmVersionedLocation,\n    multilocation\n  );\n  const userAction = api.createType(MRLTypes.XcmRoutingUserActionWithFee, {\n    destination: versionedLocation,\n    fee,\n  });\n\n  // Wrap and format the MultiLocation object into the precompile's input type\n  const versionedUserAction = api.createType(MRLTypes.VersionedUserAction, {\n    V2: userAction,\n  });\n\n    // Disconnect the API\n    api.disconnect();\n\n  // SCALE encode resultant precompile formatted objects\n  return versionedUserAction.toU8a();\n}\n</code></pre>"}, {"location": "builders/ethereum/precompiles/interoperability/gmp/#restrictions", "title": "限制", "text": "<p>GMP 预编译目前还处于早期阶段。存在许多限制，并且它仅支持进入平行链的“快乐路径”。以下是您应该注意的一些限制：</p> <ul> <li>目前没有费用机制。在 Moonbeam 上运行流动性转发到平行链的中继者将补贴交易。将来可能会改变</li> <li>预编译不会检查以确保目标链支持要发送给它的代币。不正确的多重位置可能导致资金损失</li> <li>构建多重位置时出错会导致回滚，这将困住代币并导致资金损失</li> <li>目前没有从平行链到以太坊等其他链的推荐向后路径。在实现一键式方法之前，必须完成额外的协议级工作</li> <li>由于 ERC-20 XC 资产的限制，从平行链发送代币回 Moonbeam 的唯一方法是在原始平行链上拥有 xcGLMR，并在发送代币返回时将其用作费用资产</li> </ul>"}, {"location": "builders/ethereum/precompiles/utility/eth-mainnet/", "title": "以太坊主网预编译合约", "text": ""}, {"location": "builders/ethereum/precompiles/utility/eth-mainnet/#introduction", "title": "简介", "text": "<p>以太坊中的预编译合约是指包含复杂加密计算但不需要 EVM 开销的合约。这些预编译可以在 EVM 中用于处理特定的常见操作，例如哈希和签名方案。</p> <p>目前包括以下预编译：ecrecover、sha256、ripemd-160、Bn128Add、Bn128Mul、Bn128Pairing、identity 函数和模幂运算。</p> <p>这些预编译在以太坊上原生可用，并且为了保持以太坊的兼容性，它们在 Moonbeam 上也可用。</p> <p>在本指南中，您将学习如何使用和/或验证这些预编译。</p>"}, {"location": "builders/ethereum/precompiles/utility/eth-mainnet/#verify-signatures-with-ecrecover", "title": "使用 ECRECOVER 验证签名", "text": "<p>此预编译的主要功能是验证消息的签名。通常来说，您将交易的签名值提供给 <code>ecrecover</code>，它会返回一个地址。如果返回的地址与发送交易的公共地址相同，则签名已验证。</p> <p>以下是一个小例子，展示如何利用此预编译函数。您需要检索交易的签名值（<code>v</code>、<code>r</code>、<code>s</code>）。因此，您将签名并检索已签名消息，其中包含这些值：</p> <pre><code>const { Web3 } = require('web3');\n\n// Provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\n// Address and Private Key\nconst address = '0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b';\nconst pk1 = '99B3C12287537E38C90A9219D4CB074A89A16E9CDB20BF85728EBD97C343E342';\nconst msg = web3.utils.sha3('supercalifragilisticexpialidocious');\n\nasync function signMessage(pk) {\n  try {\n    // Sign and get Signed Message\n    const smsg = await web3.eth.accounts.sign(msg, pk);\n    console.log(smsg);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nsignMessage(pk1);\n</code></pre> <p>此代码将在终端中返回以下对象：</p> <pre><code>{\n  message: '0xc2ae6711c7a897c75140343cde1cbdba96ebbd756f5914fde5c12fadf002ec97',\n  messageHash: '0xc51dac836bc7841a01c4b631fa620904fc8724d7f9f1d3c420f0e02adf229d50',\n  v: '0x1b',\n  r: '0x44287513919034a471a7dc2b2ed121f95984ae23b20f9637ba8dff471b6719ef',\n  s: '0x7d7dc30309a3baffbfd9342b97d0e804092c0aeb5821319aa732bc09146eafb4',\n  signature: '0x44287513919034a471a7dc2b2ed121f95984ae23b20f9637ba8dff471b6719ef7d7dc30309a3baffbfd9342b97d0e804092c0aeb5821319aa732bc09146eafb41b'\n}\n</code></pre> <p>有了必要的值，您可以转到 Remix 来测试预编译的合约。请注意，这也可以使用 Web3.js 库进行验证，但在这种情况下，您可以转到 Remix 以确保它正在使用区块链上的预编译合约。您可以用来验证签名的 Solidity 代码如下：</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract ECRECOVER {\n    address addressTest = 0x12Cb274aAD8251C875c0bf6872b67d9983E53fDd;\n    bytes32 msgHash =\n        0xc51dac836bc7841a01c4b631fa620904fc8724d7f9f1d3c420f0e02adf229d50;\n    uint8 v = 0x1b;\n    bytes32 r =\n        0x44287513919034a471a7dc2b2ed121f95984ae23b20f9637ba8dff471b6719ef;\n    bytes32 s =\n        0x7d7dc30309a3baffbfd9342b97d0e804092c0aeb5821319aa732bc09146eafb4;\n\n    function verify() public view returns (bool) {\n        // Use ECRECOVER to verify address\n        return (ecrecover(msgHash, v, r, s) == (addressTest));\n    }\n}\n</code></pre> <p>使用 Remix 编译器和部署 并且 MetaMask 指向 Moonbase Alpha，您可以部署合约并调用 <code>verify()</code> 方法，如果 <code>ecrecover</code> 返回的地址等于用于签署消息的地址（与私钥相关，需要在合约中手动设置），则返回 true。</p>"}, {"location": "builders/ethereum/precompiles/utility/eth-mainnet/#hashing-with-sha256", "title": "使用 SHA256 进行哈希", "text": "<p>此哈希函数从给定的数据返回 SHA256 哈希值。要测试此预编译合约，您可以使用此 SHA256 哈希计算器工具 来计算您想要的任何字符串的 SHA256 哈希值。在本例中，您将使用 <code>Hello World!</code>。您可以直接前往 Remix 并部署以下代码，其中计算出的哈希值设置为 <code>expectedHash</code> 变量：</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract Hash256 {\n    bytes32 public expectedHash =\n        0x7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069;\n\n    function calculateHash() internal pure returns (bytes32) {\n        string memory word = \"Hello World!\";\n        bytes32 hash = sha256(bytes(word));\n\n        return hash;\n    }\n\n    function checkHash() public view returns (bool) {\n        return (calculateHash() == expectedHash);\n    }\n}\n</code></pre> <p>合约部署完成后，您可以调用 <code>checkHash()</code> 方法，如果 <code>calculateHash()</code> 返回的哈希值等于提供的哈希值，则返回 true。</p>"}, {"location": "builders/ethereum/precompiles/utility/eth-mainnet/#hashing-with-ripemd-160", "title": "使用 RIPEMD160 哈希", "text": "<p>此哈希函數從給定的數據返回 RIPEMD160 哈希。要測試此預編譯，您可以使用此 RIPEMD160 哈希計算器工具 來計算任何字符串的 RIPEMD160 哈希。在這種情況下，您將再次使用 <code>Hello World!</code> 執行此操作。您將重用與以前相同的代碼，但使用 <code>ripemd160</code> 函數。請注意，它返回一個 <code>bytes20</code> 類型的變量：</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract HashRipmd160 {\n    bytes20 public expectedHash = hex\"8476ee4631b9b30ac2754b0ee0c47e161d3f724c\";\n\n    function calculateHash() internal pure returns (bytes20) {\n        string memory word = \"Hello World!\";\n        bytes20 hash = ripemd160(bytes(word));\n\n        return hash;\n    }\n\n    function checkHash() public view returns (bool) {\n        return (calculateHash() == expectedHash);\n    }\n}\n</code></pre> <p>部署合約後，您可以調用 <code>checkHash()</code> 方法，如果 <code>calculateHash()</code> 返回的哈希等於提供的哈希，則返回 true。</p>"}, {"location": "builders/ethereum/precompiles/utility/eth-mainnet/#bn128add", "title": "BN128Add", "text": "<p>BN128Add 预编译实现了本地椭圆曲线点加法。它返回一个椭圆曲线点，表示 <code>(ax, ay) + (bx, by)</code>，使得 <code>(ax, ay)</code> 和 <code>(bx, by)</code> 是 BN256 曲线上的有效点。</p> <p>目前 Solidity 中没有 BN128Add 的支持，所以需要使用内联汇编来调用。以下示例代码可用于调用此预编译。</p> <pre><code>pragma solidity &gt;=0.4.21;\n\ncontract Precompiles {\n    function callBn256Add(\n        bytes32 ax,\n        bytes32 ay,\n        bytes32 bx,\n        bytes32 by\n    ) public returns (bytes32[2] memory result) {\n        bytes32[4] memory input;\n        input[0] = ax;\n        input[1] = ay;\n        input[2] = bx;\n        input[3] = by;\n        assembly {\n            let success := call(gas, 0x06, 0, input, 0x80, result, 0x40)\n            switch success\n            case 0 {\n                revert(0, 0)\n            }\n        }\n    }\n}\n</code></pre> <p>使用 Remix 编译器和部署 并使用 MetaMask 指向 Moonbase Alpha，您可以部署合约并调用 <code>callBn256Add(bytes32 ax, bytes32 ay, bytes32 bx, bytes32 by)</code> 方法以返回操作结果。</p>"}, {"location": "builders/ethereum/precompiles/utility/eth-mainnet/#bn128mul", "title": "BN128Mul", "text": "<p>BN128Mul 预编译实现了与标量值的原生椭圆曲线乘法。它返回一个椭圆曲线点，表示 <code>scalar * (x, y)</code>，使得 <code>(x, y)</code> 是 BN256 曲线上的有效曲线点。</p> <p>目前，Solidity 中没有 BN128Mul 支持，因此需要使用内联汇编来调用它。以下示例代码可用于调用此预编译。</p> <pre><code>pragma solidity &gt;=0.4.21;\n\ncontract Precompiles {\n    function callBn256ScalarMul(\n        bytes32 x,\n        bytes32 y,\n        bytes32 scalar\n    ) public returns (bytes32[2] memory result) {\n        bytes32[3] memory input;\n        input[0] = x;\n        input[1] = y;\n        input[2] = scalar;\n        assembly {\n            let success := call(gas, 0x07, 0, input, 0x60, result, 0x40)\n            switch success\n            case 0 {\n                revert(0, 0)\n            }\n        }\n    }\n}\n</code></pre> <p>使用 Remix 编译器和部署 以及 指向 Moonbase Alpha 的 MetaMask，您可以部署合约并调用 <code>callBn256ScalarMul(bytes32 x, bytes32 y, bytes32 scalar)</code> 方法来返回操作结果。</p>"}, {"location": "builders/ethereum/precompiles/utility/eth-mainnet/#bn128pairing", "title": "BN128配对", "text": "<p>BN128 配对预编译实现了椭圆曲线配对操作，以执行 zkSNARK 验证。有关更多信息，请查看 EIP-197 标准。</p> <p>目前 Solidity 中没有 BN128 配对支持，因此需要使用内联汇编来调用它。以下示例代码可用于调用此预编译。</p> <pre><code>pragma solidity &gt;=0.4.21;\n\ncontract Precompiles {\n    function callBn256Pairing(\n        bytes memory input\n    ) public returns (bytes32 result) {\n        // input is a serialized bytes stream of (a1, b1, a2, b2, ..., ak, bk) from (G_1 x G_2)^k\n        uint256 len = input.length;\n        require(len % 192 == 0);\n        assembly {\n            let memPtr := mload(0x40)\n            let success := call(\n                gas(),\n                0x08,\n                0,\n                add(input, 0x20),\n                len,\n                memPtr,\n                0x20\n            )\n            switch success\n            case 0 {\n                revert(0, 0)\n            }\n            default {\n                result := mload(memPtr)\n            }\n        }\n    }\n}\n</code></pre> <p>使用 Remix 编译器和部署 以及 MetaMask 指向 Moonbase Alpha，您可以部署合约并调用 <code>function callBn256Pairing(bytes memory input)</code> 方法以返回操作结果。</p>"}, {"location": "builders/ethereum/precompiles/utility/eth-mainnet/#the-identity-function", "title": "身份函数", "text": "<p>也被称为数据复制，此函数提供了一种更便宜的在内存中复制数据的方法。</p> <p>目前，Solidity 中不支持身份函数，因此需要使用内联汇编来调用它。以下示例代码（改编自 Solidity）可用于调用此预编译合约：</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract Identity {\n    bytes public memoryStored;\n\n    function callDatacopy(bytes memory data) public returns (bytes memory) {\n        bytes memory result = new bytes(data.length);\n        assembly {\n            let len := mload(data)\n            if iszero(\n                call(\n                    gas(),\n                    0x04,\n                    0,\n                    add(data, 0x20),\n                    len,\n                    add(result, 0x20),\n                    len\n                )\n            ) {\n                invalid()\n            }\n        }\n\n        memoryStored = result;\n\n        return result;\n    }\n}\n</code></pre> <p>您可以使用此 Web3 类型转换器工具 从任何字符串获取字节，因为这是 <code>callDataCopy()</code> 方法的输入。</p> <p>部署合约后，您可以调用 <code>callDataCopy()</code> 方法并验证 <code>memoryStored</code> 是否与您作为函数输入传递的字节匹配。</p>"}, {"location": "builders/ethereum/precompiles/utility/eth-mainnet/#modular-exponentiation", "title": "模幂运算", "text": "<p>此预编译计算整数 <code>b</code>（底数）的 <code>e</code> 次方（指数）除以正整数 <code>m</code>（模数）后的余数。</p> <p>Solidity 编译器不支持此功能，因此需要使用内联汇编来调用。以下代码经过简化，用于展示此预编译的功能：</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract ModularCheck {\n    uint public checkResult;\n\n    // Function to Verify ModExp Result\n    function verify(uint _base, uint _exp, uint _modulus) public {\n        checkResult = modExp(_base, _exp, _modulus);\n    }\n\n    function modExp(\n        uint256 _b,\n        uint256 _e,\n        uint256 _m\n    ) public returns (uint256 result) {\n        assembly {\n            // Free memory pointer\n            let pointer := mload(0x40)\n            // Define length of base, exponent and modulus. 0x20 == 32 bytes\n            mstore(pointer, 0x20)\n            mstore(add(pointer, 0x20), 0x20)\n            mstore(add(pointer, 0x40), 0x20)\n            // Define variables base, exponent and modulus\n            mstore(add(pointer, 0x60), _b)\n            mstore(add(pointer, 0x80), _e)\n            mstore(add(pointer, 0xa0), _m)\n            // Store the result\n            let value := mload(0xc0)\n            // Call the precompiled contract 0x05 = bigModExp\n            if iszero(call(not(0), 0x05, 0, pointer, 0xc0, value, 0x20)) {\n                revert(0, 0)\n            }\n            result := mload(value)\n        }\n    }\n}\n</code></pre> <p>您可以尝试在 Remix 中执行此操作。使用 <code>verify()</code> 函数，传递底数、指数和模数。此函数将把结果存储在 <code>checkResult</code> 变量中。</p>"}, {"location": "builders/ethereum/precompiles/utility/eth-mainnet/#p256-verify", "title": "P256 验证", "text": "<p>P256Verify 预编译增加了对 RIP-7212 的支持，即 Secp256r1 椭圆曲线的签名验证。此预编译添加了签名验证的 WASM 实现，旨在由可用的本机运行时函数调用替换。</p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\ncontract P256Verify {\n    function verify(\n        bytes32 msg_hash,\n        bytes32[2] memory signature,\n        bytes32[2] memory public_key\n    ) public view returns (bool) {\n        bool output;\n\n        bytes memory args = abi.encodePacked(\n            msg_hash,\n            signature[0],\n            signature[1],\n            public_key[0],\n            public_key[1]\n        );\n\n        bool success;\n        assembly {\n            success := staticcall(not(0), 0x100, add(args, 32), mload(args), output, 0x20)\n        }\n        require(success, \"p256verify precompile call failed\");\n\n        return output;\n    }\n}\n</code></pre> <p>下面的文件包含两个不同的测试用例：一个具有有效的签名测试，第二个具有无效的签名测试。</p> p256verifywithtests.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\ncontract P256Verify {\n    function verify(\n        bytes32 msg_hash,\n        bytes32[2] memory signature,\n        bytes32[2] memory public_key\n    ) public view returns (bool) {\n        bool output;\n\n        bytes memory args = abi.encodePacked(\n            msg_hash,\n            signature[0],\n            signature[1],\n            public_key[0],\n            public_key[1]\n        );\n\n        bool success;\n        assembly {\n            success := staticcall(not(0), 0x100, add(args, 32), mload(args), output, 0x20)\n        }\n        require(success, \"p256verify precompile call failed\");\n\n        return output;\n    }\n\n    function test() public {\n        bytes32[2] memory msg_hashes;\n        bytes32[2][2] memory signatures;\n        bytes32[2][2] memory public_keys;\n        bool[2] memory expected_result;\n\n        // Case 1 (valid)\n        msg_hashes[0] = hex\"b5a77e7a90aa14e0bf5f337f06f597148676424fae26e175c6e5621c34351955\";\n        signatures[0][0] = hex\"289f319789da424845c9eac935245fcddd805950e2f02506d09be7e411199556\";\n        signatures[0][1] = hex\"d262144475b1fa46ad85250728c600c53dfd10f8b3f4adf140e27241aec3c2da\";\n        public_keys[0][0] = hex\"3a81046703fccf468b48b145f939efdbb96c3786db712b3113bb2488ef286cdc\";\n        public_keys[0][1] = hex\"ef8afe82d200a5bb36b5462166e8ce77f2d831a52ef2135b2af188110beaefb1\";\n        expected_result[0] = true;\n\n        // Case 2 (invalid)\n        msg_hashes[1] = hex\"d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b\";\n        signatures[1][0] = hex\"6162630000000000000000000000000000000000000000000000000000000000\";\n        signatures[1][1] = hex\"6162630000000000000000000000000000000000000000000000000000000000\";\n        public_keys[1][0] = hex\"6162630000000000000000000000000000000000000000000000000000000000\";\n        public_keys[1][1] = hex\"6162630000000000000000000000000000000000000000000000000000000000\";\n        expected_result[0] = false;\n\n        for (uint256 i = 0; i &lt; expected_result.length; i++) {\n            bool result = verify(msg_hashes[i], signatures[i], public_keys[i]);\n            if (expected_result[i]) {\n                require(result, \"Expected success\");\n            } else {\n                require(!result, \"Expected failure\");\n            }\n        }\n    }\n}\n</code></pre> <p>使用 Remix 编译器和部署 以及 指向 Moonbase Alpha 的 MetaMask，您可以部署合约并使用以下参数调用 <code>verify</code> 方法：</p> <p>=== “有效签名”</p> <pre><code>| 参数       | 值                                                                                                                                             |\n|--------------|------------------------------------------------------------------------------------------------------------------------------------------------|\n| `msg_hash`   | `0xb5a77e7a90aa14e0bf5f337f06f597148676424fae26e175c6e5621c34351955`                                                                           |\n| `signature`  | `[\"0x289f319789da424845c9eac935245fcddd805950e2f02506d09be7e411199556\", \"0xd262144475b1fa46ad85250728c600c53dfd10f8b3f4adf140e27241aec3c2da\"]` |\n| `public_key` | `[\"0x3a81046703fccf468b48b145f939efdbb96c3786db712b3113bb2488ef286cdc\", \"0xef8afe82d200a5bb36b5462166e8ce77f2d831a52ef2135b2af188110beaefb1\"]` |\n| 预期结果   | `true`                                                                                                                                         |\n</code></pre> <p>=== “无效签名”</p> <pre><code>| 参数          | 值                                                                                                                                             |\n|-----------------|------------------------------------------------------------------------------------------------------------------------------------------------|\n| `msg_hash`      | `0xd182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b`                                                                           |\n| `signature`     | `[\"0x6162630000000000000000000000000000000000000000000000000000000000\", \"0x6162630000000000000000000000000000000000000000000000000000000000\"]` |\n| `public_key`    | `[\"0x6162630000000000000000000000000000000000000000000000000000000000\", \"0x6162630000000000000000000000000000000000000000000000000000000000\"]` |\n| 预期结果   | `false`                                                                                                                                          |\n</code></pre> <p>您将收到两个布尔值作为响应；第一个指示签名是否有效，第二个指示对 P256Verify 预编译的调用是否成功。第二个布尔值应始终返回 true；第一个是检查签名是否有效的那个。</p>"}, {"location": "builders/ethereum/precompiles/utility/non-specific/", "title": "非网络特定预编译智能合约", "text": ""}, {"location": "builders/ethereum/precompiles/utility/non-specific/#introduction", "title": "简介", "text": "<p>预编译合约（或预编译）是一组硬编码到区块链客户端中的已编程功能。预编译执行计算量大的任务，例如散列等加密过程。将这些功能移动到区块链客户端具有双重目的：使计算比使用传统智能合约更有效，并确保每个人都可以访问正确运行所需的完整、准确的过程和算法集。</p> <p>预编译功能被捆绑并在智能合约地址下共享，这允许与传统智能合约类似的交互。一些预编译合约并非特定于以太坊或 Moonbeam，但受支持在您的 Moonbeam 应用程序中使用。</p> <p>此类别中目前包含的非特定预编译是 <code>ECRecoverPublicKey</code> 和 <code>SHA3FIPS256</code> 预编译。</p> <p>在下一节中，您将了解有关这些预编译中包含的功能的更多信息。</p>"}, {"location": "builders/ethereum/precompiles/utility/non-specific/#ecrecoverpublickey", "title": "使用 ECRecoverPublicKey 检索公钥", "text": "<p><code>ECRecoverPublicKey</code> 预编译的主要功能是从给定的消息哈希和签名中恢复用于创建数字签名的公钥。此预编译类似于 ECRecover，但区别在于它返回签署消息的帐户的公钥，而不是帐户地址。</p> <p>在以下部分中，您将学习如何使用 <code>ECRecoverPublicKey</code> 预编译。</p>"}, {"location": "builders/ethereum/precompiles/utility/non-specific/#checking-prerequisites", "title": "检查先决条件", "text": "<p>You need to install Node.js (for this example, you can use v16.x) and the npm package manager. You can download directly from Node.js or in your terminal:</p> UbuntuMacOS <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n\nsudo apt install -y nodejs\n</code></pre> <pre><code># You can use homebrew (https://docs.brew.sh/Installation)\nbrew install node\n\n# Or you can use nvm (https://github.com/nvm-sh/nvm)\nnvm install node\n</code></pre> <p>You can verify that everything is installed correctly by querying the version for each package:</p> <pre><code>node -v\n</code></pre> <pre><code>npm -v\n</code></pre> <p>本示例中使用的版本为 v20.15.0 (Node.js) 和 10.7.0 (npm)。您还需要通过执行以下命令安装 Web3 包：</p> <pre><code>npm install --save web3\n</code></pre> <p>要验证已安装的 Web3 版本，您可以使用 <code>ls</code> 命令：</p> <pre><code>npm ls web3\n</code></pre> <p>本示例使用 4.11.1 版本。您还将使用 Remix，通过 MetaMask 将其连接到 Moonbase Alpha TestNet。</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"}, {"location": "builders/ethereum/precompiles/utility/non-specific/#_2", "title": "检索交易签名值", "text": "<p>要使用 <code>ECRecoverPublicKey</code> 预编译，您必须首先签署消息以创建和检索消息哈希和交易签名值（<code>v</code>、<code>r</code>、<code>s</code>），以作为合约调用中的参数传递。在处理私钥时，请务必始终使用安全最佳实践。</p> <p>在您的项目目录中创建一个名为 <code>signMessage.js</code> 的新文件：</p> <p>bash touch signMessage.js</p> <p>在您的代码编辑器中打开 <code>signMessage.js</code>，并添加以下脚本以使用 Moonbase Alpha TestNet 初始化 Web3，对消息进行签名和哈希处理，并返回签名值：</p> <p>js title=\"signMessage.js\" const { Web3 } = require('web3'); const web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');</p> <p>// Address and private key const address = 'INSERT_RECEIVER_ADDRESS'; const pk1 =   'INSERT_SENDER_PRIVATE_KEY'; const msg = web3.utils.sha3('supercooltestmessage');</p> <p>async function signMessage(pk) {   try {     // Sign and get signed message     const smsg = await web3.eth.accounts.sign(msg, pk);     console.log(smsg);   } catch (error) {     console.error(error);   } }</p> <p>signMessage(pk1);</p> <p>返回到您的终端命令行，使用以下命令运行脚本：</p> <p>bash node signMessage.js</p> <p>此代码将在终端中返回以下对象：</p> node signMessage.js {   message: '0x5836e21a51f25aad199e2e0feb5ca19673ed56b3811285f5124d7a8171d75851',   messageHash: '0xa69b720d0293b9e8f4e471afb80f9d410b825abe5ce524e7d5755fd2a00bf9de',   v: '0x1b',   r: '0xb7d4783ee3b34d6fbc419d5b7bc67002c511322c5c71b49a7d78a8b7e9c5b30a',   s: '0x4e5939eaef3917b1cb09af9e632cc9a727b64191b7ee40a6ae34f6fdde60a371',   signature: '0xb7d4783ee3b34d6fbc419d5b7bc67002c511322c5c71b49a7d78a8b7e9c5b30a4e5939eaef3917b1cb09af9e632cc9a727b64191b7ee40a6ae34f6fdde60a3711b' } <p>保存这些值，因为您将在下一节中需要它们。</p>"}, {"location": "builders/ethereum/precompiles/utility/non-specific/#ecrecoverpublickey_1", "title": "测试 ECRecoverPublicKey 合约", "text": "<p>现在您可以访问 Remix 来测试预编译合约。请注意，您也可以使用 Web3.js 库，但在这种情况下，您可以转到 Remix 以确保它使用区块链上的预编译合约。您可以使用以下 Solidity 代码来检索公钥：</p> <p>solidity title=\"RecoverPublicKey.sol\" // SPDX-License-Identifier: MIT</p> <p>pragma solidity &gt;=0.8.2 &lt;0.9.0;</p> <p>contract RecoverPublicKey {     function recoverPublicKey(         bytes32 hash,         uint8 v,         bytes32 r,         bytes32 s     ) public view returns (bytes memory) {         address precompileAddress = 0x0000000000000000000000000000000000000402;         (bool success, bytes memory publicKey) = precompileAddress.staticcall(             abi.encodeWithSignature(                 \"ECRecoverPublicKey(bytes32,uint8,bytes32,bytes32)\",                 hash,                 v,                 r,                 s             )         );         require(success, \"ECRecoverPublicKey failed\");         return publicKey;     } }</p> <p>使用 Remix 编译器和部署 以及 MetaMask 指向 Moonbase Alpha，您可以部署合约并调用 <code>recoverPublicKey()</code> 方法，该方法返回签署消息的帐户的公钥。现在您可以将此公钥值用于其他加密功能和验证。</p> <p></p>"}, {"location": "builders/ethereum/precompiles/utility/non-specific/#create-a-hash-with-sha3fips256", "title": "使用 SHA3FIPS256 创建哈希", "text": "<p>SHA3-256 是 SHA-3 系列密码哈希算法的一部分，该算法在 FIPS202 中进行了编码，可生成长度为 256 位的输出。尽管名称与 SHA256 相似，但 SHA-3 系列是使用完全不同的算法构建的，因此对于相同的输入，产生的哈希输出与 SHA256 不同。您可以使用此 SHA3-256 哈希计算器工具自行验证。计算出 SHA3-256 输出后，在下拉选择器中将算法更改为 SHA256，并注意生成的输出。</p> <p>目前，Solidity 中没有 SHA3-256 支持，因此需要使用内联汇编来调用它。以下示例代码可用于调用此预编译。</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract Precompiles {\n    function sha3fips(bytes memory data) public view returns (bytes32) {\n        bytes32[1] memory h;\n        assembly {\n            if iszero(\n                staticcall(not(0), 0x400, add(data, 32), mload(data), h, 32)\n            ) {\n                invalid()\n            }\n        }\n        return h[0];\n    }\n}\n</code></pre> <p>使用 Remix 并通过 MetaMask 指向 Moonbase Alpha，您可以部署合约并调用 <code>sha3fips(bytes memory data)</code> 方法以返回数据参数的编码字符串。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "builders/ethereum/precompiles/utility/registry/", "title": "Moonbeam上的预编译注册表", "text": ""}, {"location": "builders/ethereum/precompiles/utility/registry/#introduction", "title": "简介", "text": "<p>预编译注册表是 Moonbeam 上可用预编译合约的单一数据源。预编译注册表可用于确定地址是否对应于预编译合约，以及预编译合约是处于活动状态还是已弃用状态。当 Substrate 和 Polkadot 生态系统中存在上游更改，从而导致与预编译合约的向后不兼容的更改时，这尤其有用。开发人员可以设计退出策略，以确保他们的 dApp 在这些情况下能够优雅地恢复。</p> <p>预编译注册表还有另一个用途，因为它允许任何用户为预编译合约设置“虚拟代码”(<code>0x60006000fd</code>)，从而使预编译合约可以从 Solidity 调用。这是必要的，因为默认情况下，Moonbeam 上的预编译合约没有字节码。“虚拟代码”可以绕过 Solidity 中的检查，以确保合约字节码存在且非空。</p> <p>注册表预编译合约位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p><code>0x0000000000000000000000000000000000000815</code></p> <p><code>0x0000000000000000000000000000000000000815</code></p> <p><code>0x0000000000000000000000000000000000000815</code></p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/utility/registry/#the-solidity-interface", "title": "预编译注册表 Solidity 接口", "text": "<p><code>PrecompileRegistry.sol</code> 是一个 Solidity 接口，允许开发者与预编译的方法进行交互。</p> PrecompileRegistry.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Precompile Registry contract's address.\naddress constant PRECOMPILE_REGISTRY_ADDRESS = 0x0000000000000000000000000000000000000815;\n\n/// @dev The Precompile Registry contract's instance.\nPrecompileRegistry constant PRECOMPILE_REGISTRY_CONTRACT = PrecompileRegistry(PRECOMPILE_REGISTRY_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Precompile Registry\n/// @dev Interface to the set of available precompiles.\ninterface PrecompileRegistry {\n    /// @dev Query if the given address is a precompile. Note that deactivated precompiles\n    /// are still considered precompiles and will return `true`.\n    /// @param a: Address to query\n    /// @return output Is this address a precompile?\n    /// @custom:selector 446b450e\n    function isPrecompile(address a) external view returns (bool);\n\n    /// @dev Query if the given address is an active precompile. Will return false if the\n    /// address is not a precompile or if this precompile is deactivated.\n    /// @param a: Address to query\n    /// @return output Is this address an active precompile?\n    /// @custom:selector 6f5e23cf\n    function isActivePrecompile(address a) external view returns (bool);\n\n    /// @dev Update the account code of a precompile address.\n    /// As precompiles are implemented inside the Runtime, they don't have a bytecode, and\n    /// their account code is empty by default. However in Solidity calling a function of a\n    /// contract often automatically adds a check that the contract bytecode is non-empty.\n    /// For that reason a dummy code (0x60006000fd) can be inserted at the precompile address\n    /// to pass that check. This function allows any user to insert that code to precompile address\n    /// if they need it.\n    /// @param a: Address of the precompile.\n    /// @custom:selector 48ceb1b4\n    function updateAccountCode(address a) external;\n}\n</code></pre> <p>该接口包括以下函数：</p> isPrecompile(address a) - 返回一个布尔值，指示给定地址是否为预编译地址。对于活动和已弃用的预编译地址，返回 <code>true</code> 参数返回值 <ul> <li><code>a</code> - 要检查是否为预编译地址的地址</li> </ul> <ul> <li><code>bool</code> 地址是否为预编译地址（活动或已弃用）</li> </ul> isActivePrecompile(address a) - 返回一个布尔值，指示给定地址是否为活动预编译地址。如果预编译已弃用，则返回 <code>false</code> 参数返回值 <ul> <li><code>a</code> - 要检查是否为活动预编译地址的地址</li> </ul> <ul> <li><code>bool</code> 地址是否为活动预编译地址</li> </ul> updateAccountCode(address a) - 使用虚拟代码 (<code>0x60006000fd</code>) 更新给定预编译地址的字节码，给定预编译的地址。默认情况下，预编译没有与其关联的字节码。此函数可用于添加虚拟字节码，以绕过 Solidity 中的要求，即在可以调用合约的函数之前，检查合约的字节码是否为空 参数返回值 <ul> <li><code>a</code> - 要使用虚拟字节码更新的预编译地址</li> </ul> <p>无。</p>"}, {"location": "builders/ethereum/precompiles/utility/registry/#interact-with-precompile-registry-interface", "title": "与预编译注册表Solidity接口交互", "text": "<p>以下章节将介绍如何通过Remix 和 以太坊库（例如 Ethers.js 和 Web3.py）与注册表预编译进行交互。</p> <p>本指南中的示例将在Moonbase Alpha上进行。 To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"}, {"location": "builders/ethereum/precompiles/utility/registry/#use-remix", "title": "使用 Remix 与预编译注册表交互", "text": "<p>要快速开始使用 Remix，预编译注册表合约已从 GitHub 加载。您也可以在 Remix 中创建一个新文件，并手动粘贴 <code>PrecompileRegistry.sol</code> 合约的内容。</p> <p></p> <p>然后，您可以按照以下步骤编译、部署预编译注册表并与之交互：</p> <ol> <li> <p>在“编译”选项卡中，单击“编译 PrecompileRegistry.sol”以编译合约。成功编译合约后，将出现一个绿色复选标记</p> <p></p> </li> <li> <p>在“部署和运行交易”选项卡中，您可以使用其地址加载预编译注册表：</p> <ol> <li>确保在“环境”下拉列表中选择了“注入提供程序 - Metamask”，并且您已将 MetaMask 连接到 Moonbase Alpha</li> <li>确保在“合约”下拉列表中选择了“PrecompileRegistry”。由于这是一个预编译合约，因此无需部署，而是需要在“位于地址”字段中提供预编译的地址</li> <li>提供 Moonbase Alpha 的预编译注册表的地址：<code>0x0000000000000000000000000000000000000815</code>，然后单击“位于地址”</li> <li>预编译注册表将出现在“已部署合约”列表中</li> </ol> <p></p> </li> <li> <p>您可以与任何预编译方法进行交互。在“已部署合约”下，展开预编译注册表以查看方法列表。例如，您可以使用 isPrecompile 函数检查地址是否为预编译</p> <p></p> </li> </ol>"}, {"location": "builders/ethereum/precompiles/utility/registry/#use-ethereum-libraries", "title": "使用以太坊库与预编译注册表交互", "text": "<p>要使用以太坊库与预编译注册表的 Solidity 接口交互，您需要预编译注册表的 ABI。</p> 预编译注册表 ABI <pre><code>[\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isActivePrecompile\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isPrecompile\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"updateAccountCode\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    }\n]\n</code></pre> <p>获得 ABI 后，您可以使用您选择的以太坊库与注册表进行交互。一般来说，您需要执行以下步骤：</p> <ol> <li>创建一个 provider</li> <li>创建预编译注册表的合约实例</li> <li>与预编译注册表的功能进行交互</li> </ol> <p>Remember</p> <p>以下代码段仅供演示使用。切勿将您的私钥存储在 JavaScript 或 Python 文件中。</p> Ethers.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport ABI from './precompileRegistryABI.js'; // Import Precompile Registry ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n// Create interface for the Precompile Registry\nconst precompileRegistry = new ethers.Contract(\n  '0x0000000000000000000000000000000000000815',\n  ABI,\n  signer\n);\n\n// Interact with the Precompile Registry\nconst isActivePrecompile = async () =&gt; {\n  const proxyPrecompile = '0x000000000000000000000000000000000000080b';\n\n  // Check if the Proxy Precompile is a precompile\n  const isPrecompile = await precompileRegistry.isPrecompile(proxyPrecompile);\n  // Should return 'Address is a precompile: true'\n  console.log(`Address is a precompile: ${isPrecompile}`);\n\n  // Check if the Proxy Precompile is an active precompile\n  const isActivePrecompile = await precompileRegistry.isActivePrecompile(\n    proxyPrecompile\n  );\n  // Should return 'Address is an active precompile: true'\n  console.log(`Address is an active precompile: ${isActivePrecompile}`);\n};\n\nisActivePrecompile();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_PRECOMPILE_REGISTRY_ABI\"  # Paste or import the Precompile Registry ABI\nprivate_key = \"INSERT_PRIVATE_KEY\"\n\n# Create provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create interface for the Precompile Registry\nprecompile_registry = web3.eth.contract(\n    address=\"0x0000000000000000000000000000000000000815\", abi=abi\n)\n\n\n# Interact with the Precompile Registry\ndef is_active_precompile():\n    proxy_precompile = \"0x000000000000000000000000000000000000080b\"\n\n    # Check if the Proxy Precompile is a precompile\n    is_precompile = precompile_registry.functions.isPrecompile(proxy_precompile).call()\n    # Should return 'Address is a precompile: true'\n    print(\"Address is a precompile: \", is_precompile)\n\n    # Check if the Proxy Precompile is an active precompile\n    is_active_precompile = precompile_registry.functions.isActivePrecompile(\n        proxy_precompile\n    ).call()\n    # Should return 'Address is an active precompile: true'\n    print(\"Address is an active precompile: \", is_active_precompile)\n\n\nis_active_precompile()\n</code></pre>"}, {"location": "builders/ethereum/precompiles/utility/relay-data-verifier/", "title": "与中继数据验证器预编译交互", "text": ""}, {"location": "builders/ethereum/precompiles/utility/relay-data-verifier/#introduction", "title": "简介", "text": "<p>Polkadot 依赖于状态证明来保证特定时间的数据完整性。状态证明是一种简洁的密码学数据结构，表示 trie 中特定交易或状态数据的子集。它由一组哈希值组成，这些哈希值形成从目标数据到存储在区块头中的根哈希值的路径。</p> <p>客户端可以通过提供状态证明来独立地重建根哈希值，并将其与区块头中存储的原始根哈希值进行比较。如果重建的根哈希值与原始值匹配，则确认目标数据的真实性、有效性以及在区块链中的包含性。</p> <p>Polkadot 独特的架构和平行链区块验证过程意味着像 Moonbeam 这样的区块链在其状态中具有中继链存储根哈希值。因此，Moonbeam 可以提供一种机制，通过检查存储的存储根哈希值的证明来验证中继链状态。</p> <p>Moonbeam 的 中继数据验证器预编译 合约为智能合约提供了一种简便的方法，可以通过编程方式构建依赖于在合约调用中验证中继链状态的函数。因此，无需预言机将中继链数据馈送到 Moonbeam。此功能在以下合约地址中随时可用：</p> MoonbeamMoonriverMoonbase Alpha <p><code>0x0000000000000000000000000000000000000819</code></p> <p><code>0x0000000000000000000000000000000000000819</code></p> <p><code>0x0000000000000000000000000000000000000819</code></p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/utility/relay-data-verifier/#the-relay-data-verifier-solidity-interface", "title": "中继数据验证器 Solidity 接口", "text": "<p><code>RelayDataVerifier.sol</code> 是一个 Solidity 接口，允许开发者与预编译的方法进行交互。</p> RelayDataVerifier.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The RelayDataVerifier contract's address.\naddress constant RELAY_DATA_VERIFIER_ADDRESS = 0x0000000000000000000000000000000000000819;\n\n/// @dev The RelayDataVerifier contract's instance.\nRelayDataVerifier constant RELAY_DATA_VERIFIER_CONTRACT = RelayDataVerifier(\n    RELAY_DATA_VERIFIER_ADDRESS\n);\n\n/// @author The Moonbeam Team\n/// @title Relay Proof Verifier Interface\n/// @dev The interface that Solidity contracts use to interact with the Relay Proof Verifier\n/// precompile.\n/// A typical workflow to verify relay chain data is the following:\n/// 1. Moonbeam RPC Call: Call `latestRelayBlockNumber` function to get the latest relay\n///    block number tracked by the chain in `pallet-storage-root`.\n/// 2. Relay RPC Call: Call `chain_getBlockHash(blockNumber)` RPC method to get the relay block hash\n///    for the block number obtained in step 1.\n/// 3. Relay RPC Call: Call `state_getReadProof(keys, at)` RPC method where `at`\n///    is the relay block hash obtained in step 2 to get the 'ReadProof` of the entries.\n/// 4. Moonbeam RPC Call: Submit an ethereum transaction (directly or through a SC) to call the\n///    `verifyEntry` or `verifyEntries` function to verify the data against the relay block\n///    number. The call data contain the relay block number obtained in step 1, and the read\n///    proof generated in step 3, along with the key/s to verify.\n/// @custom:address 0x0000000000000000000000000000000000000819\ninterface RelayDataVerifier {\n    /// @dev ReadProof struct returned by the `state_getReadProof` RPC method.\n    struct ReadProof {\n        // The block hash against which the proof is generated\n        bytes32 at;\n        /// The storage proof\n        bytes[] proof;\n    }\n\n    /// @dev Verifies a storage entry in the Relay Chain using a relay block number and a storage\n    /// proof. This function takes a relay block number, a storage proof, and the key of the storage\n    /// entry to verify. It returns the value associated with the key if the verification is\n    /// successful.\n    /// @custom:selector 27001faa\n    /// @param relayBlockNumber The relay block number against which the entry is being verified.\n    /// @param readProof The storage proof used to verify the entry.\n    /// @param key The key of the storage entry to verify.\n    /// @return value The value associated with the key, returned as a bytes array.\n    function verifyEntry(\n        uint32 relayBlockNumber,\n        ReadProof calldata readProof,\n        bytes calldata key\n    ) external returns (bytes memory value);\n\n    /// @dev Verifies a set of entries in the Relay Chain and returns the corresponding values.\n    /// This function takes a relay block number, a storage proof, and an array of keys for the\n    /// storage entries to verify. It returns an array of values associated with the keys, in the\n    /// same order as the keys.\n    /// @custom:selector 2da33a45\n    /// @param relayBlockNumber The relay block number for which the data is being verified.\n    /// @param readProof The storage proof used to verify the data.\n    /// @param keys The keys of the storage entries to verify.\n    /// @return values The values associated with the keys, returned in the same order as the keys.\n    function verifyEntries(\n        uint32 relayBlockNumber,\n        ReadProof calldata readProof,\n        bytes[] calldata keys\n    ) external returns (bytes[] memory values);\n\n    /// @dev Returns the latest relay block number that has a storage root stored on-chain.\n    /// @custom:selector aed36869\n    /// @return relayBlockNumber the lastest relay block number\n    function latestRelayBlockNumber()\n        external\n        view\n        returns (uint32 relayBlockNumber);\n}\n</code></pre> <p>该接口包括以下函数：</p> latestRelayBlockNumber() — 检索区块链本身存储的最新中继链区块的存储根 参数返回值 <p>无</p> <p>链上存储有存储根的最新中继区块号。</p> verifyEntry(uint32 relayBlockNumber, ReadProof calldata readProof, bytes callData key) — 使用中继区块号、存储证明和存储密钥验证中继链中的存储条目。如果验证成功，它将返回与密钥关联的值 参数返回值 <ul> <li><code>relayBlockNumber</code> - 用于验证数据的中继区块号。最新的中继区块号可以从 <code>latestRelayBlockNumber()</code> 函数中获取</li> <li><code>readProof</code> - 预编译合约中定义的结构体，包含用于验证数据的存储证明。<code>ReadProof</code> 结构体定义如下：   <pre><code>struct ReadProof {\n    // 生成证明所针对的区块哈希\n    bytes32 at;\n    /// 存储证明\n    bytes[] proof;\n}\n</code></pre></li> <li><code>key</code> - 生成证明的存储密钥</li> </ul> <p>在 <code>verifyEntry</code> 函数上执行静态调用时，您可以查看与十六进制格式的密钥关联的返回值。</p> <pre><code>'0x01000000040000000100000000000000f88ce384dca20000000000000000000000370589030a0000000000000000000000203d88792d0000000000000000000000000000000000000000000000000080'\n</code></pre> verifyEntries(uint32 relayBlockNumber, ReadProof calldata readProof, bytes[] callData keys) — 验证中继链中的一组条目，并返回相应的值。此函数接受中继区块号、存储证明和要验证的存储密钥数组。它返回与密钥关联的值数组，顺序与密钥相同 参数返回值 <ul> <li><code>relayBlockNumber</code> - 用于验证数据的中继区块号。最新的中继区块号可以从 <code>latestRelayBlockNumber()</code> 函数中获取</li> <li><code>readProof</code> - 预编译合约中定义的结构体，包含用于验证数据的存储证明。<code>ReadProof</code> 结构体定义如下： <pre><code>struct ReadProof {\n    // 生成证明所针对的区块哈希\n    bytes32 at;\n    /// 存储证明\n    bytes[] proof;\n}\n</code></pre></li> <li><code>keys</code> - 生成证明的存储密钥</li> </ul> <p>在 <code>verifyEntries</code> 函数上执行静态调用时，您可以查看包含映射到各自密钥的相应值的数组，以十六进制格式表示。</p> <pre><code>['0x01000000040000000100000000000000f88ce384dca20000000000000000000000370589030a0000000000000000000000203d88792d0000000000000000000000000000000000000000000000000080']\n</code></pre>"}, {"location": "builders/ethereum/precompiles/utility/relay-data-verifier/#interact-with-the-solidity-interface", "title": "与Solidity接口交互", "text": "<p>验证中继链数据的典型工作流程包括以下步骤：</p> <ol> <li>Moonbeam RPC调用 - 调用<code>latestRelayBlockNumber</code>函数获取链在<code>pallet-storage-root</code>中跟踪的最新中继区块号</li> <li>中继RPC调用 - 调用<code>chain_getBlockHash(blockNumber)</code> RPC方法获取第一步中获得区块号对应的中继区块哈希</li> <li>中继RPC调用 - 调用<code>state_getReadProof(keys, at)</code> RPC方法检索存储证明，其中<code>at</code>是第二步中获得的中继区块哈希，而<code>keys</code>是字符串数组，其中包含目标存储项的键。对于<code>@polkadot/api</code>，可以通过<code>api.query.module.key()</code>函数获得</li> <li>Moonbeam RPC调用 - 提交一笔以太坊交易，调用<code>verifyEntry</code>或<code>verifyEntries</code>函数，以根据中继区块号验证数据。调用数据应包含第一步中获得的中继区块号、第三步中生成的读取证明以及要验证的键</li> </ol> <p>以下章节将介绍如何使用以太坊库（例如Ethers.js和Web3.py）与中继数据验证器预编译进行交互。本指南中的示例将在Moonbase Alpha上进行。</p>"}, {"location": "builders/ethereum/precompiles/utility/relay-data-verifier/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要学习本教程，您需要具备：</p> <ul> <li>在 Moonbase Alpha 上创建或拥有一个帐户，以测试预编译中的不同功能</li> <li>该帐户需要用 <code>DEV</code> 代币充值。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"}, {"location": "builders/ethereum/precompiles/utility/relay-data-verifier/#using-ethereum-libraries", "title": "使用以太坊库", "text": "<p>要使用以太坊库与Solidity接口进行交互，您需要预编译的ABI（应用程序二进制接口）。中继链数据验证器预编译的ABI如下：</p> 中继数据验证器预编译ABI <pre><code>[\n  {\n    inputs: [],\n    name: 'latestRelayBlockNumber',\n    outputs: [\n      {\n        internalType: 'uint32',\n        name: 'relayBlockNumber',\n        type: 'uint32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint32',\n        name: 'relayBlockNumber',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'bytes32',\n            name: 'at',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'proof',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct RelayDataVerifier.ReadProof',\n        name: 'readProof',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes[]',\n        name: 'keys',\n        type: 'bytes[]',\n      },\n    ],\n    name: 'verifyEntries',\n    outputs: [\n      {\n        internalType: 'bytes[]',\n        name: 'values',\n        type: 'bytes[]',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint32',\n        name: 'relayBlockNumber',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'bytes32',\n            name: 'at',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'proof',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct RelayDataVerifier.ReadProof',\n        name: 'readProof',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'key',\n        type: 'bytes',\n      },\n    ],\n    name: 'verifyEntry',\n    outputs: [\n      {\n        internalType: 'bytes',\n        name: 'value',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> <p>获得ABI后，您可以使用您选择的以太坊库与预编译进行交互，例如Ethers.js或Web3.py。一般步骤如下：</p> <ol> <li>创建一个provider</li> <li>创建预编译的合约实例</li> <li>与预编译的函数交互</li> </ol> <p>提供的代码示例演示了如何使用Ethers.js库与Moonbase Alpha网络及其中继链进行交互，并使用<code>verifyEntry</code>函数验证数据条目。</p> <p>Note</p> <p>以下各节中提供的代码段不适用于生产环境。请确保针对每个用例进行调整。</p> Ethers.js <pre><code>// For reading local ABI file\nimport * as fs from 'fs';\n// Import Ethers library, to interact with Moonbeam networks\nimport { ethers } from 'ethers';\n// Import Polkadot library, to interact with relay chain\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst abi = JSON.parse(fs.readFileSync('./RelayChainDataVerifierABI.json'));\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst precompileAddress = '0x0000000000000000000000000000000000000819';\nconst moonbeamURL = 'https://rpc.api.moonbase.moonbeam.network';\nconst relayURL = 'wss://relay.api.moonbase.moonbeam.network';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(moonbeamURL);\nconst signer = new ethers.Wallet(privateKey, provider);\nconst precompileContract = new ethers.Contract(precompileAddress, abi, signer);\n\nasync function run() {\n  // Create provider for relay chain\n  const wsProvider = new WsProvider(relayURL);\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Get the storage key for a random account on relay chain\n  const key = api.query.system.account.key(\n    '5CBATpb3yvEM4mhX9Dw3tyuqiWKhq9YBG6ugSbodRUSbodoU'\n  );\n  // Find the latest available relay chain block number from Moonbeam\n  const blockNum = await precompileContract.latestRelayBlockNumber();\n\n  // Get the block hash and storage proof from relay chain\n  const blockHash = await api.rpc.chain.getBlockHash(blockNum);\n  const proof = await api.rpc.state.getReadProof([key], blockHash);\n\n  // This tx will be rejected if the verification failed\n  const receipt = await precompileContract.verifyEntry(blockNum, proof, key);\n  await receipt.wait();\n  console.log(receipt.hash);\n}\n\nawait run();\n</code></pre> <p>\"Web3.py\"</p> <pre><code># Import packages\nfrom eth_account import Account\nfrom substrateinterface import SubstrateInterface\nfrom web3 import Web3\n\n# Initialize variables\nabi = INSERT_ABI\n\nprivateKey = \"INSERT_PRIVATE_KEY\"\nprecompileAddress = \"0x0000000000000000000000000000000000000819\"\nmoonbeamURL = \"https://rpc.api.moonbase.moonbeam.network\"\nrelayURL = \"wss://relay.api.moonbase.moonbeam.network\"\n\n# Create provider for Moonbeam network\nweb3 = Web3(Web3.HTTPProvider(moonbeamURL))\naccount = Account.from_key(privateKey)\nprecompileContract = web3.eth.contract(address=precompileAddress, abi=abi)\n\n# Create provider for relay chain\nsubstrate = SubstrateInterface(url=relayURL)\n\n# Get storage key\nkey = substrate.generate_storage_hash(\n    storage_module=\"System\",\n    storage_function=\"Account\",\n    params=[\"5CBATpb3yvEM4mhX9Dw3tyuqiWKhq9YBG6ugSbodRUSbodoU\"],\n)\n\n# Find the latest available relay chain block number from Moonbeam\nblockNum = precompileContract.functions.latestRelayBlockNumber().call()\n\n# Get the block hash from relay chain\nblockHash = substrate.get_block_hash(blockNum)\n\n# Get the storage proof from relay chain\nresponse = substrate.rpc_request(\"state_getReadProof\", [[key], blockHash])\nproof = response[\"result\"]\n\n# Call smart contract\ntx = precompileContract.functions.verifyEntry(blockNum, proof, key).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account.address),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account.address)\n        ),\n    }\n)\ntx_create = web3.eth.account.sign_transaction(tx, privateKey)\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n</code></pre>"}, {"location": "builders/ethereum/precompiles/ux/", "title": "Index", "text": "<ul> <li>toc</li> <li>feedback</li> </ul>"}, {"location": "builders/ethereum/precompiles/ux/batch/", "title": "与批量预编译交互", "text": ""}, {"location": "builders/ethereum/precompiles/ux/batch/#introduction", "title": "介绍", "text": "<p>Moonbeam 上的批量预编译合约允许开发者将多个 EVM 调用合并为一个。</p> <p>目前，让用户与多个合约交互需要在用户的钱包中进行多次交易确认。一个例子是批准智能合约访问某个代币，然后再转移它。通过批量预编译，开发者可以通过批量交易来改善用户体验，因为它最大限度地减少了用户需要确认的交易数量，只需一次确认即可。此外，由于批量处理避免了多个基本 Gas 费（开始一笔交易最初花费的 21000 个单位的 Gas），因此可以降低 Gas 费。</p> <p>预编译直接与 Substrate 的 EVM pallet 交互。批量函数的调用者的地址将充当所有子交易的 <code>msg.sender</code>，但与 委托调用 不同，目标合约仍然会影响其自身的存储。这实际上与用户签署多个交易相同，但只需要一次确认。</p> <p>预编译位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p><code>0x0000000000000000000000000000000000000808</code></p> <p><code>0x0000000000000000000000000000000000000808</code></p> <p><code>0x0000000000000000000000000000000000000808</code></p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/ux/batch/#the-batch-interface", "title": "Batch Solidity 接口", "text": "<p><code>Batch.sol</code> 是一个 Solidity 接口，允许开发人员与预编译的三个方法进行交互。</p> <p>该接口包括以下函数：</p> batchSome(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) - 执行多个调用，其中每个数组的相同索引组合成单个子调用所需的信息。 如果一个子调用回退，将仍然尝试后续的子调用 参数 <ul> <li><code>to</code> - address[] 地址数组，用于将子交易定向到，其中每个条目是一个子交易</li> <li><code>value</code> - uint256[] 原生货币值数组，用于在子交易中发送，其中索引对应于 to 数组中相同索引的子交易。 如果此数组短于 to 数组，则所有后续的子交易将默认为值 0</li> <li><code>callData</code> - bytes[] 调用数据数组，用于包含在子交易中，其中索引对应于 to 数组中相同索引的子交易。 如果此数组短于 to 数组，则所有后续的子交易将不包含调用数据</li> <li><code>gasLimit</code> - uint64[] gas 限制数组，用于子交易中，其中索引对应于 to 数组中相同索引的子交易。 值为 0 被解释为无限制，并将转发批量交易的所有剩余 gas。 如果此数组短于 to 数组，则所有后续的子交易将转发所有剩余 gas</li> </ul> batchSomeUntilFailure(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) - 执行多个调用，其中每个数组的相同索引组合成单个子调用所需的信息。 如果一个子调用回退，则不会执行后续的子调用 参数 <ul> <li><code>to</code> - address[] 地址数组，用于将子交易定向到，其中每个条目是一个子交易</li> <li><code>value</code> - uint256[] 原生货币值数组，用于在子交易中发送，其中索引对应于 to 数组中相同索引的子交易。 如果此数组短于 to 数组，则所有后续的子交易将默认为值 0</li> <li><code>callData</code> - bytes[] 调用数据数组，用于包含在子交易中，其中索引对应于 to 数组中相同索引的子交易。 如果此数组短于 to 数组，则所有后续的子交易将不包含调用数据</li> <li><code>gasLimit</code> - uint64[] gas 限制数组，用于子交易中，其中索引对应于 to 数组中相同索引的子交易。 值为 0 被解释为无限制，并将转发批量交易的所有剩余 gas。 如果此数组短于 to 数组，则所有后续的子交易将转发所有剩余 gas</li> </ul> batchAll(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) - 以原子方式执行多个调用，其中每个数组的相同索引组合成单个子调用所需的信息。 如果一个子调用回退，则所有子调用都会回退 参数 <ul> <li><code>to</code> - address[] 地址数组，用于将子交易定向到，其中每个条目是一个子交易</li> <li><code>value</code> - uint256[] 原生货币值数组，用于在子交易中发送，其中索引对应于 to 数组中相同索引的子交易。 如果此数组短于 to 数组，则所有后续的子交易将默认为值 0</li> <li><code>callData</code> - bytes[] 调用数据数组，用于包含在子交易中，其中索引对应于 to 数组中相同索引的子交易。 如果此数组短于 to 数组，则所有后续的子交易将不包含调用数据</li> <li><code>gasLimit</code> - uint64[] gas 限制数组，用于子交易中，其中索引对应于 to 数组中相同索引的子交易。 值为 0 被解释为无限制，并将转发批量交易的所有剩余 gas。 如果此数组短于 to 数组，则所有后续的子交易将转发所有剩余 gas</li> </ul> <p>该接口还包括以下必需的事件：</p> <ul> <li>SubcallSucceeded(uint256 index) - 当给定索引的子调用成功时发出</li> <li>SubcallFailed(uint256 index) - 当给定索引的子调用失败时发出</li> </ul>"}, {"location": "builders/ethereum/precompiles/ux/batch/#interact-with-the-solidity-interface", "title": "与Solidity接口交互", "text": ""}, {"location": "builders/ethereum/precompiles/ux/batch/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要学习本教程，您需要具备：</p> <ul> <li>已安装MetaMask并连接到Moonbase Alpha</li> <li>在Moonbase Alpha上创建或拥有两个帐户，以测试批处理预编译中的不同功能</li> <li>至少一个帐户需要有<code>DEV</code>代币。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"}, {"location": "builders/ethereum/precompiles/ux/batch/#example-contract", "title": "示例合约", "text": "<p>合约 <code>SimpleContract.sol</code> 将用作批量处理合约交互的示例，但实际上，任何合约都可以进行交互。</p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.30;\n\ncontract SimpleContract {\n    mapping(uint256 =&gt; string) public messages;\n\n    function setMessage(uint256 id, string calldata message) external {\n        messages[id] = message;\n    }\n}\n</code></pre>"}, {"location": "builders/ethereum/precompiles/ux/batch/#remix-set-up", "title": "Remix 设置", "text": "<p>您可以使用 Remix 与批量预编译进行交互。您需要 <code>Batch.sol</code> 和 <code>SimpleContract.sol</code> 的副本。要将预编译添加到 Remix 并按照教程进行操作，您需要：</p> <ol> <li>点击文件浏览器标签</li> <li>将 <code>Batch.sol</code> 合约粘贴到名为 Batch.sol 的 Remix 文件中</li> <li>将 <code>SimpleContract.sol</code> 合约粘贴到名为 SimpleContract.sol 的 Remix 文件中</li> </ol>"}, {"location": "builders/ethereum/precompiles/ux/batch/#compile-the-contract", "title": "编译合约", "text": "<p>接下来，您需要在 Remix 中编译这两个文件：</p> <ol> <li>确保您已打开 Batch.sol 文件</li> <li>单击顶部的第二个 Compile 选项卡</li> <li>要编译合约，请单击 Compile Batch.sol</li> </ol> <p></p> <p>如果接口编译成功，您将在 Compile 选项卡旁边看到一个绿色复选标记。</p>"}, {"location": "builders/ethereum/precompiles/ux/batch/#access-the-precompile", "title": "访问预编译", "text": "<p>您可以通过预编译合约的地址访问接口，而不是部署批处理预编译：</p> <ol> <li>在 Remix 中，点击编译选项卡正下方的部署和运行选项卡。请注意，预编译合约已经部署</li> <li>确保在环境下拉菜单中选择了 注入提供程序 - Metamask。选择 注入提供程序 - Metamask 后，MetaMask 可能会提示您将您的帐户连接到 Remix</li> <li>确保在帐户下显示了正确的帐户</li> <li>确保在合约下拉菜单中选择了 Batch - Batch.sol。由于这是一个预编译合约，因此无需部署任何代码。相反，我们将在地址字段中提供预编译的地址</li> <li>提供批处理预编译的地址：<code>0x0000000000000000000000000000000000000808</code>，然后点击地址</li> </ol> <p></p> <p>BATCH 预编译将出现在已部署合约列表中。</p>"}, {"location": "builders/ethereum/precompiles/ux/batch/#deploy-example-contract", "title": "部署示例合约", "text": "<p>另一方面，<code>SimpleContract.sol</code> 将被部署为一个新合约。在开始本节之前，请使用 <code>SimpleContract.sol</code> 文件重复编译步骤。</p> <ol> <li>在 Remix 中，单击 Compile 选项卡正下方的 Deploy and Run 选项卡</li> <li>确保在 ENVIRONMENT 下拉列表中选择了 Injected Provider - Metamask。选择 Injected Provider - Metamask 后，MetaMask 可能会提示您将您的帐户连接到 Remix</li> <li>确保 ACCOUNT 下显示正确的帐户</li> <li>确保在 CONTRACT 下拉列表中选择了 SimpleContract - SimpleContract.sol</li> <li>点击 Deploy</li> <li>点击 Confirm 确认出现的 MetaMask 交易</li> </ol> <p></p> <p>SIMPLECONTRACT 合约将出现在 Deployed Contracts 列表中。</p>"}, {"location": "builders/ethereum/precompiles/ux/batch/#send-native-currency-via-precompile", "title": "通过预编译发送本地货币", "text": "<p>通过批量预编译发送本地货币比在 Remix 或 MetaMask 中按几个按钮要复杂。在此示例中，您将使用 batchAll 函数以原子方式发送本地货币。</p> <p>交易有一个 value 字段，用于指定要随之发送的本地货币量。在 Remix 中，这由“部署和运行交易”选项卡中的“VALUE”输入表示。但是，对于批量预编译，此数据在批量函数的 value 数组输入中提供。</p> <p>尝试通过 Moonbase Alpha 上的批量预编译将本地货币转移到您选择的两个钱包：</p> <ol> <li>确保您连接的钱包中至少有 0.5 DEV</li> <li>展开“已部署合约”下的批量合约</li> <li>展开 batchAll 函数</li> <li>对于 to 输入，以以下格式插入您的地址：<code>[\"INSERT_ADDRESS_1\", \"INSERT_ADDRESS_2\"]</code>，其中第一个地址对应于您选择的第一个钱包，第二个地址对应于您选择的第二个钱包</li> <li>对于 value 输入，插入您希望为每个地址转移的 Wei 金额。例如，<code>[\"100000000000000000\", \"200000000000000000\"]</code> 会将 0.1 DEV 转移到第一个地址，将 0.2 DEV 转移到第二个地址</li> <li>对于剩余的 callData 和 gasLimit 输入，插入 <code>[]</code>。调用数据和 gas 限制不是转移本地货币的问题</li> <li>按“交易”</li> <li>在 MetaMask 扩展中按“确认”以确认交易</li> </ol> <p></p> <p>交易完成后，请务必检查两个帐户的余额，无论是在 MetaMask 中还是在区块浏览器中。恭喜！您现在已通过批量预编译发送了批量转移。</p> <p>Note</p> <p>通常，如果您想将本地货币发送到合约或通过合约发送，则必须在整个交易对象中设置该值，并与可支付函数交互。但是，由于批量预编译直接与 Substrate 代码交互，因此这不是典型的以太坊交易，因此没有必要。</p>"}, {"location": "builders/ethereum/precompiles/ux/batch/#function-interaction-via-precompile", "title": "通过预编译进行函数交互", "text": "<p>本节的示例将使用 batchAll 函数，该函数可确保事务以原子方式解析。请记住，还有另外两个批量函数可以继续子事务（即使出现错误），或者停止后续子事务，但不恢复先前的子事务。</p> <p>与函数交互与发送原生币非常相似，因为它们都是事务。但是，需要调用数据才能正确地将输入提供给函数，并且发送者可能希望限制每个子事务中花费的 gas 量。</p> <p><code>callData</code> 和 <code>gasLimit</code> 字段与和合约交互的子事务更相关。对于批量接口中的每个函数，<code>callData</code> 输入是一个数组，其中每个索引对应于子事务的每个接收者的调用数据，即每个 <code>to</code> 输入。如果 <code>callData</code> 数组的大小小于 <code>to</code> 数组，则剩余的子事务将没有调用数据（没有输入的函数）。<code>gasLimit</code> 输入是一个数组，对应于每个子事务可以花费的 gas 量。如果它在索引处的值为 0，或者索引是数组的大小或更大（且小于 <code>to</code> 数组的大小），则将转发来自先前子事务的所有剩余 gas。</p> <p>要使用预编译来发送原子批量事务，请执行以下步骤：</p> <ol> <li>使用其标题右侧的复制按钮复制 <code>SimpleContract.sol</code> 合约的地址。请务必同时拥有上一节中的调用数据</li> <li>展开 已部署的合约 下的批量合约</li> <li>展开 batchAll 函数</li> <li>对于 to 输入，插入您先前复制的 <code>SimpleContract.sol</code> 合约的地址，格式如下：<code>[\"INSERT_SIMPLE_CONTRACT_ADDRESS\"]</code></li> <li>对于值输入，由于 <code>SimpleContract.sol</code> 不需要支付任何原生币，因此插入 <code>[\"0\"]</code> 作为 0 Wei</li> <li>对于 callData 输入，插入上一节中的调用数据，格式如下：<code>[\"INSERT_CALL_DATA\"]</code></li> <li>对于 gasLimit 输入，插入 <code>[]</code>。您可以输入 gas 限制值，但它是可选的</li> <li>按 transact</li> <li>在 MetaMask 扩展程序中按 Confirm 以确认交易</li> </ol> <p></p> <p>如果您使用了与教程相同的调用数据，检查以确保交易成功：</p> <ol> <li>展开 已部署的合约 下的 <code>SimpleContract.sol</code> 合约</li> <li>在 messages 按钮的右侧，插入 <code>1</code></li> <li>按蓝色 messages 按钮</li> </ol> <p></p> <p>短语 “moonbeam” 应该出现在它下面。恭喜！您已使用批量预编译与函数进行了交互。</p>"}, {"location": "builders/ethereum/precompiles/ux/batch/#_2", "title": "组合子交易", "text": "<p>到目前为止，转移原生货币和与函数交互是分开的，但它们可以交织在一起。</p> <p>以下四个字符串可以组合作为批量交易的输入。 它们会将 1 DEV 交易到公共 Gerald (<code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code>) 帐户，并与预先部署的 <code>SimpleContract.sol</code> 智能合约交互两次。 以下是详细的分解：</p> <p>有三个子交易，因此 <code>to</code> 的输入数组中有三个地址。 第一个是公共 Gerald 帐户，接下来的两个是预先部署的 <code>SimpleContract.sol</code> 智能合约。 如果愿意，可以将最后两个替换为您自己的 <code>SimpleContract.sol</code> 实例。 或者，只替换一个：您可以在一条消息中与多个合约交互。</p> <p>text [   \"0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b\",   \"0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39\",    \"0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39\" ]</p> <p><code>value</code> 数组也将有三个值。 <code>to</code> 输入数组中的第一个地址与发送 1 DEV 有关，因此 Wei 中的 1 DEV 在数组中。 以下两个值为 0，因为它们的子交易与之交互的函数不接受或不需要原生货币。</p> <p>text [\"1000000000000000000\", \"0\", \"0\"]</p> <p>您将需要 <code>callData</code> 数组的三个值。 由于转移原生货币不需要调用数据，因此该字符串只是空白。 数组中的第二个和第三个值对应于将消息设置为 id 5 和 6 的 setMessage 的调用。</p> <p>text [   \"0x\",    \"0x648345c8000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000009796f752061726520610000000000000000000000000000000000000000000000\",    \"0x648345c800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000e61206d6f6f6e6265616d2070726f000000000000000000000000000000000000\" ]</p> <p>最后的输入是 <code>gas_input</code>。此数组将留空，以将所有剩余 gas 转发到每个子交易。</p> <p>text []</p> <p>尝试以相同的方式在 Remix 中使用这些输入发送批量交易您批量调用函数的方式。</p> <p>就这样！ 您已使用 MetaMask 和 Remix 成功与 ERC-20 预编译合约进行交互！</p>"}, {"location": "builders/ethereum/precompiles/ux/batch/#ethereum-development-libraries", "title": "Ethereum 开发库", "text": "<p>如果您已经学习了 Moonbeam 上的 Ethers.js 教程，您可能会发现很难找到函数的调用数据。答案隐藏在 Ether 的 <code>Interface</code> 对象中，其中的 encodeFunctionData 函数允许您输入函数名称和输入，以接收最终的调用数据。</p> <p>Note</p> <p>以下各节中提供的代码片段不适用于生产环境。请确保针对每个用例进行调整。</p> <p>===</p> <pre><code> js\n // Import the contract ABI\n const { abi } = require('./INSERT_ABI_PATH');\n\n // Use ABI to create an interface\n const yourContractInterface = new ethers.Interface(abi);\n\n // Find call data for the setMessage function\n const callData = yourContractInterface.encodeFunctionData(\n   'INSERT_FUNCTION_NAME',\n   [\n     'INSERT_INPUT_1',\n     'INSERT_INPUT_2',\n     // ...\n   ]\n );\n</code></pre> <p>===</p> <pre><code> js\n // Import the contract ABI\n const { abi } = require('./INSERT_ABI_PATH');\n\n // Find call data for the setMessage function\n const callData = web3.eth.abi.encodeFunctionCall(abi, [\n   'INSERT_INPUT_1',\n   'INSERT_INPUT_2',\n   // ...\n ]);\n</code></pre> <p>===</p> <pre><code> py\n # Import the ABI and bytecode\n from compile import abi, bytecode\n\n # Create contract instance\n your_contract = web3.eth.contract(abi=abi, bytecode=bytecode)\n\n # Encode the contract call\n call_data = your_contract.encodeABI(\n     fn_name=\"INSERT_FUNCTION_NAME\", args=[\"INSERT_INPUT_1\", \"INSERT_INPUT_2\", ...]\n )\n</code></pre> <p>之后，您应该可以像通常与 Ethers 中的合约交互一样与批处理预编译进行交互。</p>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/", "title": "与调用许可预编译交互", "text": ""}, {"location": "builders/ethereum/precompiles/ux/call-permit/#introduction", "title": "简介", "text": "<p>Moonbeam 上的调用许可预编译允许用户为任何 EVM 调用签署许可，这是一个 EIP-712 签名消息，可以由任何人或任何智能合约分派。它类似于 ERC-20 许可 Solidity 接口，只不过它适用于任何 EVM 调用，而不仅仅是批准。</p> <p>当调用许可被分派时，它是代表签署许可的用户执行的，并且分派许可的用户或合约负责支付交易费用。因此，预编译可用于执行无 Gas 交易。</p> <p>例如，Alice 签署了一个调用许可，Bob 分派它并代表 Alice 执行调用。Bob 支付交易费用，因此，Alice 不需要拥有任何原生货币来支付交易，除非调用包含转账。</p> <p>调用许可预编译位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p><code>0x000000000000000000000000000000000000080a</code></p> <p><code>0x000000000000000000000000000000000000080a</code></p> <p><code>0x000000000000000000000000000000000000080a</code></p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/#the-call-permit-interface", "title": "调用许可 Solidity 接口", "text": "<p><code>CallPermit.sol</code> 是一个 Solidity 接口，允许开发者与预编译的三个方法进行交互。</p> <p>该接口包括以下函数：</p> dispatch(address from, address to, uint256 value, bytes data, uint64[] gaslimit, uint256 deadline, uint8 v, bytes32 r, bytes32 s) - 代表另一个用户通过 EIP-712 许可调度调用。此函数可以由任何人或任何智能合约调用。如果许可无效，或者调度的调用回退或出错（例如，gas 不足），则交易将回退。如果成功，签名者的 nonce 将增加，以防止此许可被重放 参数 <ul> <li><code>from</code> - 许可签名者的地址。调用将代表此地址进行调度</li> <li><code>to</code> - 进行调用的地址</li> <li><code>value</code> - 从 <code>from</code> 账户转账的 uint256 值</li> <li><code>data</code> - 包含调用数据或要执行的操作的字节</li> <li><code>gasLimit</code> - 调度的调用所需的 uint64[] gas 限制。为此参数提供参数可以防止调度程序操纵 gas 限制</li> <li><code>deadline</code> - UNIX 秒数的时间，超过此时间许可将不再有效。在 JavaScript 中，您可以通过在 JavaScript 脚本或浏览器控制台中运行 <code>console.log(Math.floor(Date.now() / 1000))</code> 来获取以 UNIX 秒为单位的当前时间</li> <li><code>v</code> - 签名的 uint8 恢复 ID。连接签名的最后一个字节</li> <li><code>r</code> - 连接签名的前 32 个字节的 bytes32</li> <li><code>s</code> - 连接签名的后 32 个字节的 bytes32</li> </ul> nonces(address owner) - 返回给定所有者的当前 nonce 参数 <ul> <li><code>owner</code> - 要查询 nonce 的账户地址</li> </ul> DOMAIN_SEPARATOR() - 返回用于避免重放攻击的 EIP-712 域分隔符。它遵循 EIP-2612 实现 参数 <p>无。</p> <p>The domain separator is defined in the EIP-712 standard and is calculated as:</p> <pre><code>keccak256(PERMIT_DOMAIN, name, version, chain_id, address)\n</code></pre> <p>The parameters of the hash can be broken down as follows:</p> <ul> <li>PERMIT_DOMAIN - is the <code>keccak256</code> of <code>EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)</code></li> <li>name - is the name of the signing domain and must be <code>'Call Permit Precompile'</code> exactly</li> <li>version - is the version of the signing domain. For this case version is set to <code>1</code></li> <li>chainId - is the chain ID of the network</li> <li>verifyingContract - is the address of the contract that will verify the signature. In this case, the Call Permit Precompile address</li> </ul> <p>当调用 <code>dispatch</code> 时，需要先验证许可，然后才能调度调用。第一步是计算域分隔符。Moonbeam 的实现中可以看到计算过程，或者您可以在 OpenZeppelin 的 EIP712 合约中查看实际示例。</p> <p>从那里，会生成签名和给定参数的哈希值，以确保签名只能用于调用许可。它使用给定的 nonce 来确保签名不受重放攻击。它类似于 OpenZeppelin 的 <code>ERC20Permit</code> 合约，但 <code>PERMIT_TYPEHASH</code> 用于调用许可，并且参数与 [dispatch 函数](#:~:text=The interface includes the following functions) 的参数加上 nonce 相匹配。</p> <p>域分隔符和哈希结构可用于构建完全编码消息的最终哈希值。OpenZeppelin 的 EIP712 合约中显示了一个实际示例。</p> <p>使用最终哈希值以及 v、r 和 s 值，可以验证和恢复签名。如果成功验证，nonce 将增加 1，并且将调度调用。</p>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/#setup-the-example-contract", "title": "设置合约", "text": "<p>在此示例中，您将学习如何签署一个调用许可，该许可更新一个简单示例合约 <code>SetMessage.sol</code> 中的消息。在生成调用许可签名之前，您需要部署合约并为调用许可定义 <code>dispatch</code> 函数参数。</p> <p>设置好示例合约后，您可以设置调用许可预编译合约。</p>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要学习本教程，您需要具备以下条件：</p> <ul> <li>已安装MetaMask并连接到Moonbase Alpha</li> <li>在Moonbase Alpha上创建或拥有两个帐户，以测试Call Permit Precompile中的不同功能</li> <li>至少其中一个帐户需要使用<code>DEV</code>代币进行充值。</li> </ul> <p>You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</p>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/#example-contract", "title": "示例合约", "text": "<p><code>SetMessage.sol</code> 合约将用作使用调用许可的示例，但实际上，可以与任何合约进行交互。</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.7;\n\ncontract SetMessage {\n    string storedMessage;\n\n    function set(string calldata x) public {\n        storedMessage = x;\n    }\n\n    function get() public view returns (string memory) {\n        return storedMessage;\n    }\n}\n</code></pre>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/#remix-set-up", "title": "Remix 设置", "text": "<p>您可以使用 Remix 来编译示例合约并部署它。您需要 <code>SetMessage.sol</code> 和 <code>CallPermit.sol</code> 的副本。要将合约添加到 Remix，您可以采取以下步骤：</p> <ol> <li>点击 文件浏览器 标签</li> <li>将 <code>SetMessage.sol</code> 合约粘贴到名为 <code>SetMessage.sol</code> 的 Remix 文件中</li> <li>将 <code>CallPermit.sol</code> 合约粘贴到名为 <code>CallPermit.sol</code> 的 Remix 文件中</li> </ol> <p></p>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/#compile-deploy-example-contract", "title": "编译和部署示例合约", "text": "<p>首先，您需要编译示例合约：</p> <ol> <li>点击顶部的第二个 Compile 选项卡</li> <li>然后要编译接口，点击 Compile SetMessage.sol</li> </ol> <p></p> <p>然后您可以部署它：</p> <ol> <li>点击 Remix 中 Compile 选项卡正下方的 Deploy and Run 选项卡。注意：您没有在此处部署合约，而是访问已部署的预编译合约</li> <li>确保在 ENVIRONMENT 下拉菜单中选择了 Injected Provider - Metamask</li> <li>确保在 CONTRACT 下拉菜单中选择了 SetMessage.sol</li> <li>点击 Deploy</li> <li>MetaMask 将会弹出，您需要 Confirm 交易</li> </ol> <p></p> <p>该合约将出现在左侧面板上的 Deployed Contracts 列表中。复制合约地址，因为您需要使用它在下一节中生成调用许可签名。</p>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/#compile-access-call-permit", "title": "编译和访问调用许可预编译", "text": "<p>首先，您需要编译调用许可预编译合约：</p> <ol> <li>点击从顶部数第二个 Compile 选项卡</li> <li>然后，要编译接口，点击 Compile CallPermit.sol</li> </ol> <p></p> <p>然后，您只需提供预编译的地址即可访问它，而无需部署合约：</p> <ol> <li>点击 Remix 中 Compile 选项卡正下方的 Deploy and Run 选项卡。注意：这里您不是在部署合约，而是在访问一个已经部署的预编译合约</li> <li>确保在 ENVIRONMENT 下拉菜单中选择了 Injected Provider - Metamask</li> <li>确保在 CONTRACT 下拉菜单中选择了 CallPermit.sol。由于这是一个预编译合约，因此无需部署，而是需要在 At Address 字段中提供预编译的地址</li> <li>提供 Moonbase Alpha 的调用许可预编译的地址：<code>0x000000000000000000000000000000000000080a</code> 并点击 At Address</li> <li>调用许可预编译将出现在 Deployed Contracts 列表中</li> </ol> <p></p>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/#generate-call-permit-signature", "title": "生成调用许可签名", "text": "<p>为了与调用许可预编译交互，您必须拥有或生成一个签名来分派调用许可。 您可以通过多种方式生成签名，本指南将向您展示两种不同的生成方式：在浏览器中使用 MetaMask 扩展程序 和 JSFiddle，以及使用 MetaMask 的 <code>@metamask/eth-sig-util</code> npm 包。</p> <p>无论您选择哪种方法生成签名，都将执行以下步骤：</p> <ol> <li>将创建 <code>message</code>，其中包含创建调用许可所需的一些数据。 它包括将传递到 <code>dispatch</code> 函数中的参数以及签名者的 nonce</li> <li>将为调用许可组装用户需要签署的数据的 JSON 结构，并包括 <code>dispatch</code> 参数和 nonce 的所有类型。 这将产生 <code>CallPermit</code> 类型，并将保存为 <code>primaryType</code></li> <li>将使用 <code>\"Call Permit Precompile\"</code> 精确地为名称、您的 DApp 或平台的版本、要在其上使用签名的网络的链 ID 以及将验证签名的合约的地址创建域分隔符</li> <li>所有组装的数据，<code>types</code>、<code>domain</code>、<code>primaryType</code> 和 <code>message</code>，都将使用 MetaMask 进行签名（在浏览器中或通过 MetaMask 的 JavaScript 签名库）</li> <li>将返回签名，您可以使用 Ethers.js <code>Signature.from</code> method 来返回签名的 <code>v</code>、<code>r</code> 和 <code>s</code> 值</li> </ol>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/#call-permit-arguments", "title": "调用许可参数", "text": "<p>如调用许可接口部分所示，<code>dispatch</code> 函数接受以下参数：<code>from</code>、<code>to</code>、<code>value</code>、<code>data</code>、<code>gasLimit</code>、<code>deadline</code>、<code>v</code>、<code>r</code> 和 <code>s</code>。</p> <p>为了获得签名参数（<code>v</code>、<code>r</code> 和 <code>s</code>），您需要签署一条消息，其中包含上述其余参数的参数以及签名者的随机数。</p> <ul> <li><code>from</code> - 您要使用其签名调用许可的帐户地址</li> <li><code>to</code> - <code>SetMessage.sol</code> 合约的合约地址</li> <li><code>value</code> - 在此示例中可以为 <code>0</code>，因为您只需设置消息，而无需转移任何资金</li> <li><code>data</code> – 您可以发送任何您想要的消息，你只需要使用 <code>SetMessage.sol</code> 合约设置的消息的十六进制表示形式。这将包含 <code>set</code> 函数的函数选择器和消息字符串。对于此示例，您可以发送 <code>hello world</code>。为此，您可以使用此十六进制表示形式：     <pre><code>0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000\n</code></pre></li> <li><code>gasLimit</code> - <code>100000</code> 足以发送已调度的调用</li> <li><code>deadline</code> - 您可以通过在 JavaScript 脚本或浏览器控制台中运行 <code>console.log(Math.floor(Date.now() / 1000))</code> 来获取 UNIX 秒的当前时间。获得当前时间后，您可以添加额外的秒数来表示调用许可的到期时间</li> </ul> <p>还需要签名者的随机数。如果这是您第一次签署调用许可，则随机数将为 <code>0</code>。您也可以在 Remix 中检查随机数：</p> <ol> <li>展开调用许可合约</li> <li>在 nonces 函数旁边，输入签名者的地址，然后单击 nonces</li> <li>结果将直接在函数下返回</li> </ol> <p></p>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/#use-the-browser", "title": "使用浏览器", "text": "<p>要开始，您可以在浏览器中打开 JSFiddle 或其他 JavaScript 游乐场。首先，您需要添加 Ethers.js，因为它将用于获取签名的 <code>v</code>、<code>r</code> 和 <code>s</code> 值：</p> <ol> <li>点击 Resources</li> <li>开始输入 <code>ethers</code>，下拉列表应填充匹配的库。选择 ethers</li> <li>点击 + 按钮</li> </ol> <p>Ethers.js 的 CDN 将出现在 Resources 下的库列表中。</p> <p></p> <p>在 Javascript 代码框中，复制并粘贴以下 JavaScript 代码段，确保替换 <code>to</code> 变量（以及您认为合适的任何其他变量）：</p> <pre><code>const main = async () =&gt; {\n  await window.ethereum.enable();\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts',\n  });\n\n  const from = accounts[0];\n  const to = 'INSERT_TO_ADDRESS';\n  const value = 0;\n  const data =\n    '0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000';\n  const gaslimit = 100000;\n  const nonce = 'INSERT_SIGNERS_NONCE';\n  const deadline = 'INSERT_DEADLINE';\n\n  const createPermitMessageData = function () {\n    const message = {\n      from: from,\n      to: to,\n      value: value,\n      data: data,\n      gaslimit: gaslimit,\n      nonce: nonce,\n      deadline: deadline,\n    };\n\n    const typedData = JSON.stringify({\n      types: {\n        EIP712Domain: [\n          {\n            name: 'name',\n            type: 'string',\n          },\n          {\n            name: 'version',\n            type: 'string',\n          },\n          {\n            name: 'chainId',\n            type: 'uint256',\n          },\n          {\n            name: 'verifyingContract',\n            type: 'address',\n          },\n        ],\n        CallPermit: [\n          {\n            name: 'from',\n            type: 'address',\n          },\n          {\n            name: 'to',\n            type: 'address',\n          },\n          {\n            name: 'value',\n            type: 'uint256',\n          },\n          {\n            name: 'data',\n            type: 'bytes',\n          },\n          {\n            name: 'gaslimit',\n            type: 'uint64',\n          },\n          {\n            name: 'nonce',\n            type: 'uint256',\n          },\n          {\n            name: 'deadline',\n            type: 'uint256',\n          },\n        ],\n      },\n      primaryType: 'CallPermit',\n      domain: {\n        name: 'Call Permit Precompile',\n        version: '1',\n        chainId: 1287,\n        verifyingContract: '0x000000000000000000000000000000000000080a',\n      },\n      message: message,\n    });\n\n    return {\n      typedData,\n      message,\n    };\n  };\n\n  const method = 'eth_signTypedData_v4';\n  const messageData = createPermitMessageData();\n  const params = [from, messageData.typedData];\n\n  web3.currentProvider.sendAsync(\n    {\n      method,\n      params,\n      from,\n    },\n    function (err, result) {\n      if (err) return console.dir(err);\n      if (result.error) {\n        alert(result.error.message);\n        return console.error('ERROR', result);\n      }\n      console.log('Signature:' + JSON.stringify(result.result));\n\n      const ethersSignature = ethers.Signature.from(result.result);\n      const formattedSignature = {\n        r: ethersSignature.r,\n        s: ethersSignature.s,\n        v: ethersSignature.v,\n      };\n      console.log(formattedSignature);\n    }\n  );\n};\n\nmain();\n</code></pre> <p>要运行代码，请单击页面顶部的 Run（或者您也可以使用 <code>control</code> 和 <code>s</code>）。MetaMask 应该会弹出并提示您连接一个帐户。确保选择要用来签署消息的帐户。然后继续签署消息。</p> <p></p> <p>签署消息后，返回到 JSFiddle，如果控制台尚未打开，请打开它以查看签名值，其中包括 <code>v</code>、<code>r</code> 和 <code>s</code> 值。复制这些值，因为在以下各节中与 Call Permit Precompile 交互时需要它们。</p> <p></p>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/#interact-with-the-solidity-interface", "title": "与Solidity接口交互", "text": "<p>既然您已经生成了调用许可签名，您就可以测试调用调用许可预编译的<code>dispatch</code>函数了。</p>"}, {"location": "builders/ethereum/precompiles/ux/call-permit/#dispatch-a-call", "title": "调度调用", "text": "<p>当您发送 <code>dispatch</code> 函数时，您需要与签署调用许可时相同的参数。首先，返回到 Remix 中的部署和运行选项卡，并在已部署合约部分展开调用许可合约。确保您已连接到您想要使用调用许可并支付交易费用的帐户。然后按照以下步骤操作：</p> <ol> <li> <p>对于 from 字段，输入您用于签署调用许可的帐户地址</p> </li> <li> <p>复制并粘贴 <code>SetMessage.sol</code> 的合约地址</p> </li> <li> <p>在 value 字段中输入 <code>0</code></p> </li> <li> <p>输入 <code>set</code> 函数的函数选择器的十六进制表示形式，以及您想要设置为 <code>SetMessage.sol</code> 合约消息的字符串。对于此示例，可以使用 <code>hello world</code>：     text     0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000</p> </li> <li> <p>在 gasLimit 字段中输入 <code>100000</code></p> </li> <li> <p>输入您在签署调用许可时使用的 <code>deadline</code></p> </li> <li> <p>复制您在生成调用许可签名时应该检索到的 <code>v</code> 值，并将其粘贴到 v 字段中</p> </li> <li> <p>复制您在生成调用许可签名时应该检索到的 <code>r</code> 值，并将其粘贴到 r 字段中</p> </li> <li> <p>复制您在生成调用许可签名时应该检索到的 <code>s</code> 值，并将其粘贴到 s 字段中</p> </li> <li> <p>单击 transact 以发送交易</p> </li> <li> <p>MetaMask 应该会弹出，您可以确认交易</p> </li> </ol> <p></p> <p>交易完成后，您可以验证消息是否已更新为 <code>hello world</code>。为此，您可以：</p> <ol> <li>展开 <code>SetMessage.sol</code> 合约</li> <li>单击 get</li> <li>结果将显示在函数下方，并且应该显示 <code>hello world</code></li> </ol> <p></p> <p>恭喜！您已成功生成调用许可签名，并使用它代表调用许可签名者调度调用。</p>"}, {"location": "builders/ethereum/precompiles/ux/erc20/", "title": "原生代币 ERC-20 预编译", "text": ""}, {"location": "builders/ethereum/precompiles/ux/erc20/#introduction", "title": "简介", "text": "<p>Moonbeam 上的原生代币 ERC-20 预编译合约允许开发者通过 ERC-20 接口与原生协议代币进行交互。尽管 GLMR 和 MOVR 不是 ERC-20 代币，但现在您可以像与原生 ERC-20 代币交互一样与它们进行交互！</p> <p>此预编译的主要优势之一是，它消除了将协议代币的包装表示作为 ERC-20 智能合约的必要性，例如以太坊上的 WETH。此外，它可以防止同一协议代币有多个包装表示。因此，需要通过 ERC-20 接口与协议代币交互的 DApp 无需单独的智能合约即可进行操作。</p> <p>在底层，ERC-20 预编译 执行与 Substrate 余额 pallet 相关的特定 Substrate 操作，该 pallet 以 Rust 编写。余额 pallet 提供处理 Moonbeam 上的各种余额类型、设置可用余额、转移余额等功能。</p> <p>本指南将向您展示如何通过 ERC-20 预编译与 Moonbase Alpha 测试网的原生协议代币 DEV 代币进行交互。您还可以按照并改编本指南，以了解如何将 GLMR 或 MOVR 用作 ERC-20 代币。</p> <p>预编译位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p><code>0x0000000000000000000000000000000000000802</code></p> <p><code>0x0000000000000000000000000000000000000802</code></p> <p><code>0x0000000000000000000000000000000000000802</code></p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/ethereum/precompiles/ux/erc20/#the-erc20-interface", "title": "ERC-20 Solidity 接口", "text": "<p>Moonbeam 上的 <code>ERC20.sol</code> 接口遵循 EIP-20 代币标准，该标准是智能合约中代币的标准 API 接口。该标准定义了代币合约必须实现的所需函数和事件，以实现与不同应用程序的互操作性。</p> <p>该接口包括以下函数：</p> name() - 只读函数，返回代币的名称 参数 <p>无。</p> symbol() - 只读函数，返回代币的符号 参数 <p>无。</p> decimals() - 只读函数，返回代币的小数位数 参数 <p>无。</p> totalSupply() - 只读函数，返回代币的总量 参数 <p>无。</p> balanceOf(address who) - 只读函数，返回指定地址的余额 参数 <ul> <li><code>who</code> - 要查询余额的帐户地址</li> </ul> allowance(address owner, address spender) - 只读函数，检查并返回 spender 代表 owner 可以花费的代币数量 参数 <ul> <li><code>owner</code> - 拥有代币的帐户地址</li> <li><code>spender</code> - 允许花费代币的帐户地址</li> </ul> transfer(address to, uint256 value) - 将给定数量的代币转移到指定的地址，如果转移成功，则返回 <code>true</code> 参数 <ul> <li><code>to</code> - 接收者的地址</li> <li><code>value</code> - 要转移的 uint256 代币数量</li> </ul> approve(address spender, uint256 value) - 批准提供的地址代表 <code>msg.sender</code> 花费指定数量的代币。如果成功，则返回 <code>true</code> 参数 <ul> <li><code>spender</code> - 要批准花费代币的地址</li> <li><code>value</code> - 要批准花费的 uint256 代币数量</li> </ul> transferFrom(address from, address to, uint256 value) - 将代币从一个给定的地址转移到另一个给定的地址，如果成功，则返回 <code>true</code> 参数 <ul> <li><code>from</code> - 要从中转移代币的地址</li> <li><code>to</code> - 要转移代币到的地址</li> <li><code>value</code> - 要转移的 uint256 代币数量</li> </ul> <p>Note</p> <p>ERC-20 标准未指定多次调用 <code>approve</code> 的含义。多次使用此函数更改津贴可能会导致攻击向量。为避免不正确或意外的事务排序，您可以先将 <code>spender</code> 津贴减少到 <code>0</code>，然后再设置所需的津贴。有关攻击向量的更多详细信息，您可以查看 ERC-20 API：批准/转移方法上的攻击向量 概述。</p> <p>该接口还包括以下必需的事件：</p> <ul> <li>Transfer(address indexed from, address indexed to, uint256 value) - 在执行转移时发出</li> <li>Approval(address indexed owner, address indexed spender, uint256 value) - 在注册批准时发出</li> </ul> <p>Note</p> <p>ERC-20 预编译不包括 <code>deposit</code> 和 <code>withdraw</code> 函数，以及从包装的代币合约（如 WETH）中期望的后续事件。</p>"}, {"location": "builders/ethereum/precompiles/ux/erc20/#interact-with-the-solidity-interface", "title": "与Solidity接口交互", "text": ""}, {"location": "builders/ethereum/precompiles/ux/erc20/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要学习本教程，您需要具备：</p> <ul> <li>已安装 MetaMask 并连接到 Moonbase Alpha</li> <li>在 Moonbase Alpha 上创建或拥有两个帐户，以测试 ERC-20 预编译中的不同功能</li> <li>至少其中一个帐户需要有 <code>DEV</code> 代币。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"}, {"location": "builders/ethereum/precompiles/ux/erc20/#add-token-to-metamask", "title": "将Token添加到MetaMask", "text": "<p>如果您想与Moonbase Alpha DEV token交互，就像在MetaMask中使用ERC-20一样，您可以使用预编译地址创建一个自定义token。</p> <p>首先，打开MetaMask，并确保您已连接到Moonbase Alpha，然后：</p> <ol> <li>切换到 Assets 选项卡</li> <li>点击 Import tokens</li> </ol> <p></p> <p>现在，您可以创建一个自定义token：</p> <ol> <li>输入token合约地址的预编译地址- <code>0x0000000000000000000000000000000000000802</code>。一旦您输入地址，Token Symbol和Token Decimal字段应自动填充。如果它们没有自动填充，您可以为符号输入<code>DEV</code>，为小数位数输入<code>18</code></li> <li>点击 Add Custom Token</li> </ol> <p></p> <p>MetaMask将提示您导入token。您可以查看token详细信息，然后点击 Import Tokens 将DEV token导入您的钱包。</p> <p></p> <p>就这样！您已成功将DEV token作为Moonbase Alpha TestNet上的自定义ERC-20 token添加。</p>"}, {"location": "builders/ethereum/precompiles/ux/erc20/#remix-set-up", "title": "Remix 设置", "text": "<p>您可以使用 Remix 与 ERC-20 预编译进行交互。要将预编译添加到 Remix，您需要：</p> <ol> <li>获取 <code>ERC20.sol</code> 的副本</li> <li>将文件内容粘贴到名为 <code>IERC20.sol</code> 的 Remix 文件中</li> </ol>"}, {"location": "builders/ethereum/precompiles/ux/erc20/#compile-the-contract", "title": "编译合约", "text": "<p>接下来，您需要在 Remix 中编译接口：</p> <ol> <li>点击从上往下数第二个编译标签</li> <li>通过点击Compile IERC20.sol编译接口</li> </ol> <p></p> <p>如果接口编译成功，您将在Compile标签旁边看到一个绿色复选标记。</p>"}, {"location": "builders/ethereum/precompiles/ux/erc20/#access-the-contract", "title": "访问合约", "text": "<p>您将访问预编译合约的接口，而不是部署 ERC-20 预编译合约，该接口提供了预编译合约的地址：</p> <ol> <li>点击 Remix 中Compile选项卡正下方的Deploy and Run选项卡。请注意，预编译合约已经部署</li> <li>确保在 ENVIRONMENT 下拉菜单中选择了 Injected Web3。选择 Injected Web3 后，MetaMask 可能会提示您将您的帐户连接到 Remix</li> <li>确保 ACCOUNT 下显示正确的帐户</li> <li>确保在 CONTRACT 下拉菜单中选择了 IERC20 - IERC20.sol。由于这是一个预编译合约，因此无需部署任何代码。而是要在 At Address 字段中提供预编译合约的地址</li> <li>提供 ERC-20 预编译合约的地址：<code>0x0000000000000000000000000000000000000802</code>，然后点击 At Address</li> </ol> <p></p> <p>IERC20 预编译合约将出现在 Deployed Contracts 列表中。</p>"}, {"location": "builders/ethereum/precompiles/ux/erc20/#get-basic-token-information", "title": "获取基本代币信息", "text": "<p>ERC-20 接口允许您快速获取代币信息，包括代币的总供应量、名称、符号和小数位数。 您可以通过以下步骤获取此信息：</p> <ol> <li>展开 Deployed Contracts 下的 IERC20 合约</li> <li>点击 decimals 获取 Moonbase Alpha 原生协议代币的小数位数</li> <li>点击 name 获取代币的名称</li> <li>点击 symbol 获取代币的符号</li> <li>点击 totalSupply 获取 Moonbase Alpha 上存在的代币总供应量</li> </ol> <p></p> <p>每次调用的响应将显示在相应的函数下。</p>"}, {"location": "builders/ethereum/precompiles/ux/erc20/#get-account-balance", "title": "获取账户余额", "text": "<p>您可以通过调用 <code>balanceOf</code> 函数并传入地址来检查 Moonbase Alpha 上任何地址的余额：</p> <ol> <li>展开 balanceOf 函数</li> <li>输入您想检查余额的地址，作为 owner</li> <li>点击 call</li> </ol> <p></p> <p>您的余额将显示在 <code>balanceOf</code> 函数下方。</p>"}, {"location": "builders/ethereum/precompiles/ux/erc20/#approve-a-spend", "title": "批准支出", "text": "<p>要批准支出，您需要为支出者提供地址以及允许支出者支出的代币数量。支出者可以是外部拥有的帐户或智能合约。对于此示例，您可以批准支出者支出 1 个 DEV 代币。要开始，请按照以下步骤操作：</p> <ol> <li>展开 approve 函数</li> <li>输入支出者的地址。您应该在开始之前创建两个帐户，因此可以使用第二个帐户作为支出者</li> <li>输入支出者可以支出的代币数量作为 value。对于此示例，您可以允许支出者以 Wei 单位支出 1 个 DEV 代币 (<code>1000000000000000000</code>)</li> <li>点击 transact</li> <li>MetaMask 将会弹出，并且您将被提示查看交易详情。点击 View full transaction details 以查看要发送的金额和支出者的地址</li> <li>如果一切正常，您可以点击 Confirm 来发送交易</li> </ol> <p></p> <p>交易成功完成后，您会注意到您帐户的余额没有改变。这是因为您只批准了给定金额的支出，而支出者尚未支出资金。在下一节中，您将使用 <code>allowance</code> 函数来验证支出者是否能够代表您支出 1 个 DEV 代币。</p>"}, {"location": "builders/ethereum/precompiles/ux/erc20/#get-allowance-of-spender", "title": "获取消费者的授权额度", "text": "<p>要检查消费者是否收到了在 批准支出 部分中批准的授权额度，您可以：</p> <ol> <li>展开 allowance 函数</li> <li>输入您的 owner 地址</li> <li>输入您在前一节中使用的 spender 地址</li> <li>点击 call</li> </ol> <p></p> <p>调用完成后，将显示消费者的授权额度，该额度应等同于 1 DEV 代币 (<code>1000000000000000000</code>)。</p>"}, {"location": "builders/ethereum/precompiles/ux/erc20/#send-transfer", "title": "发送转账", "text": "<p>要执行标准转账并直接从您的帐户向另一个帐户发送代币，您可以按照以下步骤调用 <code>transfer</code> 函数：</p> <ol> <li>展开 transfer 函数</li> <li>输入要发送 DEV 代币的地址。您应该在开始之前创建两个帐户，因此您可以使用第二个帐户作为接收者</li> <li>输入要发送的 DEV 代币数量。对于此示例，您可以发送 1 个 DEV 代币 (<code>1000000000000000000</code>)</li> <li>点击 transact</li> <li>MetaMask 将会弹出，您可以查看交易详情，如果一切正常，请点击 Confirm</li> </ol> <p></p> <p>交易完成后，您可以使用 <code>balanceOf</code> 函数或查看 MetaMask 查看您的余额，并注意到这次您的余额减少了 1 个 DEV 代币。您还可以使用 <code>balanceOf</code> 函数来确保接收者的余额如预期增加了 1 个 DEV 代币。</p>"}, {"location": "builders/ethereum/precompiles/ux/erc20/#send-transferfrom", "title": "从特定账户发送转账", "text": "<p>到目前为止，您应该已经批准了 1 个 DEV 代币的支出者额度，并通过标准 <code>transfer</code> 函数发送了 1 个 DEV 代币。<code>transferFrom</code> 函数与标准 <code>transfer</code> 函数的不同之处在于，它允许您定义要发送代币的地址。因此，您可以指定一个具有额度的地址或您的地址，只要您有资金即可。在此示例中，您将使用支出者的账户来启动从所有者到支出者的允许资金的转移。支出者可以将资金发送到任何账户，但在此示例中，您可以将资金从所有者发送到支出者。</p> <p>首先，您需要在 MetaMask 中切换到支出者的账户。切换到支出者的账户后，您会注意到 Remix 中“账户”选项卡下选择的地址现在是支出者的地址。</p> <p></p> <p>接下来，您可以启动并发送转账，为此：</p> <ol> <li>展开 transferFrom 函数</li> <li>在 from 字段中输入您的地址作为所有者</li> <li>在 to 字段中输入接收者地址，应该是支出者的地址</li> <li>输入要发送的 DEV 代币数量。同样，支出者目前只允许发送 1 个 DEV 代币，因此输入 <code>1000000000000000000</code></li> <li>点击 transact</li> </ol> <p></p> <p>交易完成后，您可以使用 <code>balanceOf</code> 函数检查所有者和支出者的余额。支出者的余额应该增加了 1 个 DEV 代币，他们的额度现在应该已用完。要验证支出者是否不再具有额度，您可以调用 <code>allowance</code> 函数，传入所有者和支出者的地址。您应该收到结果 0。</p> <p></p> <p>就这样！您已使用 MetaMask 和 Remix 成功与 ERC-20 预编译进行交互！</p>"}, {"location": "builders/ethereum/verify-contracts/api-verification/", "title": "基于 API 的合约验证", "text": ""}, {"location": "builders/ethereum/verify-contracts/api-verification/#introduction", "title": "简介", "text": "<p>验证智能合约可以大大提高其透明性和安全性。部署在 Moonbeam 网络上的智能合约可以通过基于 API 的工具进行验证，包括 Moonscan API 和 Sourcify。</p> <p>本页将概述使用这些基于 API 的工具来验证智能合约，或检索 Moonbeam 网络上智能合约的验证状态和元数据的步骤。</p>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#using-moonscan-api", "title": "使用 Moonscan API", "text": "<p>Moonscan 是 Etherscan 的官方分支，可用于查看和搜索链上数据，并提供一套开发者工具和分析功能，以便与 Moonbeam 网络上的数据进行交互。</p> <p>Etherscan API 提供了各种端点，用于验证智能合约、检索已验证的合约 ABI 和源代码，以及与 Moonbeam 网络上已验证的合约进行交互。</p>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#generating-an-etherscan-api-key", "title": "生成 Etherscan API 密钥", "text": "<p>在使用 Moonscan API 之前，您需要生成一个 Etherscan API 密钥。请按照 Etherscan 插件验证页面的密钥生成部分中的说明进行操作，因为生成的 API 密钥用于两者。</p>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#moonscan-public-api-url", "title": "Moonscan 公共 API URL", "text": "<p>Moonbeam 网络的 Moonscan API URL 如下：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>https://api-moonbeam.moonscan.io/api\n</code></pre> <pre><code>https://api-moonriver.moonscan.io/api\n</code></pre> <pre><code>https://api-moonbase.moonscan.io/api\n</code></pre>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#verify-source-code", "title": "验证源代码", "text": "<p>要使用 Moonscan API 验证已部署合约的源代码，您必须创建一个包含所有相关合约创建信息的 POST 请求，并将该请求发送到 Moonscan 的 REST API。以下是使用 JavaScript 和 HTTP 客户端 Axios 的示例代码：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>// 提交源代码以进行验证\nconst response = await axios.post(\n  'https://api-moonbeam.moonscan.io/api',\n  {\n    apikey: 'INSERT_API_KEY',\n    module: 'contract',\n    action: 'verifysourcecode',\n    contractAddress: 'INSERT_CONTRACT_ADDRESS',\n    sourceCode: 'INSERT_SOURCE_CODE', // 必要时进行扁平化处理\n    codeformat: 'solidity-single-file', // 或者您可以使用 \"solidity-standard-json-input\"\n    contractname: 'INSERT_CONTRACT_NAME', // 如果 codeformat = solidity-standard-json-input，则输入合约名称，例如：erc20.sol:erc20\n    compilerversion: 'INSERT_COMPILER_VERSION', // 请参阅 https://etherscan.io/solcversions 获取支持版本列表\n    optimizationUsed: 0, // 0 = 未使用优化，1 = 使用了优化 (当 codeformat=solidity-single-file 时适用)\n    runs: 200, // 除非另有说明，否则默认设置为 200 (当 codeformat=solidity-single-file 时适用)\n    constructorArguments: 'INSERT_CONSTRUCTOR_ARGUMENTS', // 如果适用\n    evmversion: 'INSERT_EVM_VERSION', // 选项：homestead, tangerineWhistle, spuriousDragon, byzantium, constantinople, petersburg, istanbul (当 codeformat=solidity-single-file 时适用)\n    licenseType: 1, // 有效代码 1-14，其中 1=无许可证 ... 14=商业源代码许可证 1.1，请参阅 https://etherscan.io/contract-license-types\n    libraryname1: 'INSERT_LIBRARY_NAME', // 如果适用，输入使用的第一个库的名称，即 SafeMath（最多可以使用 10 个库）\n    libraryaddress1: 'INSERT_LIBRARY_ADDRESS', // 如果适用，输入使用的第一个库的地址\n    libraryname2: 'INSERT_LIBRARY_NAME', // 如果适用，输入使用的第二个库的名称\n    libraryaddress2: 'INSERT_LIBRARY_ADDRESS', // 如果适用，输入使用的第二个库的地址\n    // ...\n  },\n  { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }\n);\n\nif (response.data.status == '1') {\n  // 1 = 提交成功，使用返回的 guid (response.data.result) 检查提交状态\n  // 平均处理时间为 30-60 秒\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n  // response.data.result 是提交的 GUID 收据，您可以使用此 guid 检查验证状态\n} else {\n  // 0 = 错误\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n}\n</code></pre> <pre><code>// 提交源代码以进行验证\nconst response = await axios.post(\n  'https://api-moonriver.moonscan.io/api', \n  {\n    apikey: 'INSERT_API_KEY',\n    module: 'contract',\n    action: 'verifysourcecode',\n    contractAddress: 'INSERT_CONTRACT_ADDRESS',\n    sourceCode: 'INSERT_SOURCE_CODE', // 必要时进行扁平化处理\n    codeformat: 'solidity-single-file', // 或者您可以使用 \"solidity-standard-json-input\"\n    contractname: 'INSERT_CONTRACT_NAME', // 如果 codeformat = solidity-standard-json-input，则输入合约名称，例如：erc20.sol:erc20\n    compilerversion: 'INSERT_COMPILER_VERSION', // 请参阅 https://etherscan.io/solcversions 获取支持版本列表\n    optimizationUsed: 0, // 0 = 未使用优化，1 = 使用了优化 (当 codeformat=solidity-single-file 时适用)\n    runs: 200, // 除非另有说明，否则默认设置为 200 (当 codeformat=solidity-single-file 时适用)\n    constructorArguments: 'INSERT_CONSTRUCTOR_ARGUMENTS', // 如果适用\n    evmversion: 'INSERT_EVM_VERSION', // 选项：homestead, tangerineWhistle, spuriousDragon, byzantium, constantinople, petersburg, istanbul (当 codeformat=solidity-single-file 时适用)\n    licenseType: 1, // 有效代码 1-14，其中 1=无许可证 ... 14=商业源代码许可证 1.1，请参阅 https://etherscan.io/contract-license-types\n    libraryname1: 'INSERT_LIBRARY_NAME', // 如果适用，输入使用的第一个库的名称，即 SafeMath（最多可以使用 10 个库）\n    libraryaddress1: 'INSERT_LIBRARY_ADDRESS', // 如果适用，输入使用的第一个库的地址\n    libraryname2: 'INSERT_LIBRARY_NAME', // 如果适用，输入使用的第二个库的名称\n    libraryaddress2: 'INSERT_LIBRARY_ADDRESS', // 如果适用，输入使用的第二个库的地址\n    // ...\n  },\n  { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }\n);\n\nif (response.data.status == '1') {\n  // 1 = 提交成功，使用返回的 guid (response.data.result) 检查提交状态\n  // 平均处理时间为 30-60 秒\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n  // response.data.result 是提交的 GUID 收据，您可以使用此 guid 检查验证状态\n} else {\n  // 0 = 错误\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n}\n</code></pre> <pre><code>// 提交源代码以进行验证\nconst response = await axios.post(\n  'https://api-moonbase.moonscan.io/api', \n  {\n    apikey: 'INSERT_API_KEY',\n    module: 'contract',\n    action: 'verifysourcecode',\n    contractAddress: 'INSERT_CONTRACT_ADDRESS',\n    sourceCode: 'INSERT_SOURCE_CODE', // 必要时进行扁平化处理\n    codeformat: 'solidity-single-file', // 或者您可以使用 \"solidity-standard-json-input\"\n    contractname: 'INSERT_CONTRACT_NAME', // 如果 codeformat = solidity-standard-json-input，则输入合约名称，例如：erc20.sol:erc20\n    compilerversion: 'INSERT_COMPILER_VERSION', // 请参阅 https://etherscan.io/solcversions 获取支持版本列表\n    optimizationUsed: 0, // 0 = 未使用优化，1 = 使用了优化 (当 codeformat=solidity-single-file 时适用)\n    runs: 200, // 除非另有说明，否则默认设置为 200 (当 codeformat=solidity-single-file 时适用)\n    constructorArguments: 'INSERT_CONSTRUCTOR_ARGUMENTS', // 如果适用\n    evmversion: 'INSERT_EVM_VERSION', // 选项：homestead, tangerineWhistle, spuriousDragon, byzantium, constantinople, petersburg, istanbul (当 codeformat=solidity-single-file 时适用)\n    licenseType: 1, // 有效代码 1-14，其中 1=无许可证 ... 14=商业源代码许可证 1.1，请参阅 https://etherscan.io/contract-license-types\n    libraryname1: 'INSERT_LIBRARY_NAME', // 如果适用，输入使用的第一个库的名称，即 SafeMath（最多可以使用 10 个库）\n    libraryaddress1: 'INSERT_LIBRARY_ADDRESS', // 如果适用，输入使用的第一个库的地址\n    libraryname2: 'INSERT_LIBRARY_NAME', // 如果适用，输入使用的第二个库的名称\n    libraryaddress2: 'INSERT_LIBRARY_ADDRESS', // 如果适用，输入使用的第二个库的地址\n    // ...\n  },\n  { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }\n);\n\nif (response.data.status == '1') {\n  // 1 = 提交成功，使用返回的 guid (response.data.result) 检查提交状态\n  // 平均处理时间为 30-60 秒\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n  // response.data.result 是提交的 GUID 收据，您可以使用此 guid 检查验证状态\n} else {\n  // 0 = 错误\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n}\n</code></pre> <p>成功提交后，将返回一个 GUID 作为结果的一部分。此 GUID 可用于检查提交状态。</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://api-moonbeam.moonscan.io/api\n  ?module=contract\n  &amp;action=checkverifystatus\n  &amp;guid=INSERT_GUID_FROM_RESPONSE\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonriver.moonscan.io/api\n  ?module=contract\n  &amp;action=checkverifystatus\n  &amp;guid=INSERT_GUID_FROM_RESPONSE\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonbase.moonscan.io/api\n  ?module=contract\n  &amp;action=checkverifystatus\n  &amp;guid=INSERT_GUID_FROM_RESPONSE\n  &amp;apikey=INSERT_API_KEY\n</code></pre>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#retrieve-contract-abi-for-verified-contracts", "title": "检索已验证合约的合约 ABI", "text": "<p>一旦您的合约在 Moonscan 上得到验证，您可以使用以下端点来检索合约 ABI：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://api-moonbeam.moonscan.io/api \\\n  ?module=contract \\\n  &amp;action=getabi \\\n  &amp;address=INSERT_CONTRACT_ADDRESS \\\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonriver.moonscan.io/api \\\n  ?module=contract \\\n  &amp;action=getabi \\\n  &amp;address=INSERT_CONTRACT_ADDRESS \\\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonbase.moonscan.io/api \\\n  ?module=contract \\\n  &amp;action=getabi \\\n  &amp;address=INSERT_CONTRACT_ADDRESS \\\n  &amp;apikey=INSERT_API_KEY\n</code></pre>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#retrieve-contract-source-code-for-verified-contracts", "title": "检索已验证合约的合约源代码", "text": "<p>一旦您的合约在 Moonscan 上得到验证，您可以使用以下端点来检索合约源代码：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://api-moonbeam.moonscan.io/api \\\n  ?module=contract \\\n  &amp;action=getsourcecode \\\n  &amp;address=INSERT_CONTRACT_ADDRESS \\\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonriver.moonscan.io/api \\\n  ?module=contract \\\n  &amp;action=getsourcecode \\\n  &amp;address=INSERT_CONTRACT_ADDRESS \\\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonbase.moonscan.io/api \\\n  ?module=contract \\\n  &amp;action=getsourcecode \\\n  &amp;address=INSERT_CONTRACT_ADDRESS \\\n  &amp;apikey=INSERT_API_KEY\n</code></pre>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#using-sourcify-api", "title": "使用 Sourcify API", "text": "<p>Sourcify 是一个多链去中心化自动合约验证服务，并维护一个合约元数据的公共存储库。Sourcify 还提供了一个公共服务器 API 用于验证和检查合约是否已验证，以及一个存储库 API 用于检索元数据文件。</p>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#sourcify-public-server-url", "title": "Sourcify 公共服务器 URL", "text": "<p>可以通过以下公共服务器访问 Soucify API 端点：</p> <p>===\"Production\" （生产环境）</p> <pre><code>text\nhttps://sourcify.dev/server\n</code></pre> <p>===\"Staging\" （测试环境）</p> <pre><code>text\nhttps://staging.sourcify.dev/server\n</code></pre>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#moonbeam-network-chain-ids", "title": "Moonbeam网络链ID", "text": "<p>Sourcify使用链ID来识别请求的目标网络。Moonbeam网络的链ID如下：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>1284\n</code></pre> <pre><code>1285\n</code></pre> <pre><code>1287\n</code></pre>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#full-vs-partial-match", "title": "完全匹配 vs. 部分匹配", "text": "<p>Sourcify 支持两种类型的验证匹配结果。</p> <p>完全匹配（有时称为完美匹配）指的是部署合约的字节码与给定源代码文件在元数据文件中定义的编译设置下的编译输出逐字节相同的情况。</p> <p>部分匹配指的是链上合约的已部署字节码与使用元数据和源文件（元数据哈希除外）重新编译产生的字节码相匹配的情况。对于部分匹配，已部署的合约与给定的源代码和元数据在功能上是相同的，但源代码注释、变量名或其他元数据字段（如源路径）存在差异。</p>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#verify-contract", "title": "验证合约", "text": "<p>POST 请求用于在 Sourcify 上验证合约。以下是使用 JavaScript 的示例代码：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>// 提交合约源代码和元数据以进行验证\nconst response = await axios.post('https://sourcify.dev/server/verify', {\n  address: 'INSERT_CONTRACT_ADDRESS',\n  chain: 1284, // Moonbeam 的链 ID\n  files: {\n    'metadata-1.json': 'INSERT_JSON_FILE', // 合约文件 1 的元数据文件\n    'metadata-2.json': 'INSERT_JSON_FILE', // 合约文件 2 的元数据文件\n    'file1-name.sol': 'INSERT_SOL_FILE', // 合约源文件 1\n    'file2-name.sol': 'INSERT_SOL_FILE', // 合约源文件 2\n    //...\n  },\n  chosenContract: 1, //（可选）合约的索引，如果提供的文件包含多个元数据文件\n});\n\nif (result.status == 'perfect') {\n  // 完全匹配\n  console.log(result.status + ';' + result.address);\n} else if (result.status == 'partial') {\n  // 部分匹配\n  console.log(result.status + ';' + result.address);\n} else {\n  // 不匹配\n  console.log(result.status + ';' + result.address);\n}\n</code></pre> <pre><code>// 提交合约源代码和元数据以进行验证\nconst response = await axios.post('https://sourcify.dev/server/verify', {\n  address: 'INSERT_CONTRACT_ADDRESS',\n  chain: 1285, // Moonriver 的链 ID\n  files: {\n    'metadata-1.json': 'INSERT_JSON_FILE', // 合约文件 1 的元数据文件\n    'metadata-2.json': 'INSERT_JSON_FILE', // 合约文件 2 的元数据文件\n    'file1-name.sol': 'INSERT_SOL_FILE', // 合约源文件 1\n    'file2-name.sol': 'INSERT_SOL_FILE', // 合约源文件 2\n    //...\n  },\n  chosenContract: 1, //（可选）合约的索引，如果提供的文件包含多个元数据文件\n});\n\nif (result.status == 'perfect') {\n  // 完全匹配\n  console.log(result.status + ';' + result.address);\n} else if (result.status == 'partial') {\n  // 部分匹配\n  console.log(result.status + ';' + result.address);\n} else {\n  // 不匹配\n  console.log(result.status + ';' + result.address);\n}\n</code></pre> <pre><code>// 提交合约源代码和元数据以进行验证\nconst response = await axios.post('https://sourcify.dev/server/verify', {\n  address: 'INSERT_CONTRACT_ADDRESS',\n  chain: 1287, // Moonbase Alpha 的链 ID\n  files: {\n    'metadata-1.json': 'INSERT_JSON_FILE', // 合约文件 1 的元数据文件\n    'metadata-2.json': 'INSERT_JSON_FILE', // 合约文件 2 的元数据文件\n    'file1-name.sol': 'INSERT_SOL_FILE', // 合约源文件 1\n    'file2-name.sol': 'INSERT_SOL_FILE', // 合约源文件 2\n    //...\n  },\n  chosenContract: 1, //（可选）合约的索引，如果提供的文件包含多个元数据文件\n});\n\nif (result.status == 'perfect') {\n  // 完全匹配\n  console.log(result.status + ';' + result.address);\n} else if (result.status == 'partial') {\n  // 部分匹配\n  console.log(result.status + ';' + result.address);\n} else {\n  // 不匹配\n  console.log(result.status + ';' + result.address);\n}\n</code></pre> <p>或者，您也可以使用 Sourcify 托管的 GUI 提交合约进行验证。</p>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#id", "title": "通过地址和链 ID 检查验证状态", "text": "<p>Sourcify 提供了用于一次性检查多个 EVM 链上合约验证状态的端点。这可以通过 URL 参数来完成，通过指定合约地址和网络的链 ID。</p> <p>此端点有两种变体，一种用于完全匹配，另一种用于部分匹配：</p> 完全匹配部分匹配 <pre><code>curl https://sourcify.dev/server/check-by-addresses \\\n  ?addresses={INSERT_ADDRESS_1, INSERT_ADDRESS_2, ...} \\\n  &amp;chainIds={INSERT_CHAIN_ID_1, INSERT_CHAIN_ID_2, ...}\n</code></pre> <pre><code>curl https://sourcify.dev/server/check-all-by-addresses \\\n  ?addresses={INSERT_ADDRESS_1, INSERT_ADDRESS_2, ...} \\\n  &amp;chainIds={INSERT_CHAIN_ID_1, INSERT_CHAIN_ID_2, ...}\n</code></pre> <p>一个示例响应将是一个具有以下结构的 JSON 对象：</p> <p>[     {         \"address\": \"address1\",         \"status\": \"perfect\",         \"chainIds\": [             \"chainId1\",             \"chaindId2\"         ]     },     {         \"address\": \"address2\",         \"status\": \"partial\",         \"chainIds\": [             \"chaindId2\"         ]     } ]</p>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#_1", "title": "检索已验证合约的合约源文件", "text": "<p>您还可以从 Sourcify 存储库中检索已验证合约的源文件。</p> <p>此端点有两种变体，一种用于完美匹配的源文件：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://sourcify.dev/server/files/1284/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>curl https://sourcify.dev/server/files/1285/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>curl https://sourcify.dev/server/files/1287/INSERT_CONTRACT_ADDRESS\n</code></pre> <p>还有一种用于完美匹配和部分匹配的源文件：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://sourcify.dev/server/files/any/1284/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>curl https://sourcify.dev/server/files/any/1285/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>curl https://sourcify.dev/server/files/any/1287/INSERT_CONTRACT_ADDRESS\n</code></pre>"}, {"location": "builders/ethereum/verify-contracts/api-verification/#using-sourcify-with-foundry", "title": "将 Sourcify 与 Foundry 结合使用", "text": "<p>Foundry 的 Forge 工具内置了对 Sourcify 验证的支持，类似于它对Etherscan 的内置支持。本指南的此部分中的示例将使用在使用 Foundry 部署到 Moonbeam 指南中创建的 <code>MyToken.sol</code> 合约。</p> <p>使用 Sourcify 的 Foundry 项目必须让其编译器发出元数据文件。这可以在 <code>foundry.toml</code> 文件中配置：</p> <pre><code>[profile.default]\n# 在此处输入您的自定义或默认配置选项\nextra_output_files = [\"metadata\"]\n</code></pre> <p>如果您已经部署了示例合约，您可以使用 <code>verify-contract</code> 命令来验证它。在验证合约之前，您需要对构造函数参数进行 ABI 编码。要对示例合约执行此操作，您可以运行以下命令：</p> <pre><code>cast abi-encode \"constructor(uint256)\" 100\n</code></pre> <p>结果应该是 <code>0x0000000000000000000000000000000000000000000000000000000000000064</code>。然后，您可以使用以下命令来验证合约：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>forge verify-contract --chain-id 1284 \\\n  --constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\n  --verifier sourcify INSERT_CONTRACT_ADDRESS src/MyToken.sol:MyToken\n</code></pre> <pre><code>forge verify-contract --chain-id 1285 \\\n  --constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\n  --verifier sourcify INSERT_CONTRACT_ADDRESS src/MyToken.sol:MyToken\n</code></pre> <pre><code>forge verify-contract --chain-id 1287 \\\n  --constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\n  --verifier sourcify INSERT_CONTRACT_ADDRESS src/MyToken.sol:MyToken\n</code></pre> forge verify-contract --chain-id 1287 \\ --constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\ --verifier sourcify 0x10DBedae73396699Ac2a4EB7A448d79348429d src/MyToken.sol:MyToken Submitting verification for [MyToken] \"0x10DBedae73396699Ac2a4EB7A448d79348429d\" • Submitting verification for [MyToken] \"0x10DBedae73396699Ac2a4EB7A448d79348429d\" • Contract source code already verified. Storage Timestamp: 2025-09-04 00:09:50.076Z <p>如果您想同时部署示例合约并进行验证，那么您可以使用以下命令：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>forge create --rpc-url INSERT_RPC_API_ENDPOINT \\\n  --constructor-args 100 \\\n  --verify --verifier sourcify \\\n  --private-key INSERT_YOUR_PRIVATE_KEY \\\n  src/MyToken.sol:MyToken\n</code></pre> <pre><code>forge create --rpc-url INSERT_RPC_API_ENDPOINT \\\n  --constructor-args 100 \\\n  --verify --verifier sourcify \\\n  --private-key INSERT_YOUR_PRIVATE_KEY \\\n  src/MyToken.sol:MyToken\n</code></pre> <pre><code>forge create --rpc-url https://rpc.api.moonbase.moonbeam.network \\\n  --constructor-args 100 \\\n  --verify --verifier sourcify \\\n  --private-key INSERT_YOUR_PRIVATE_KEY \\\n  src/MyToken.sol:MyToken\n</code></pre>  forge create --rpc-url https://rpc.api.moonbase.moonbeam.network \\ --constructor-args 100 \\ --verify --verifier sourcify --private-key YOUR_PRIVATE_KEY \\ src/MyToken.sol:MyToken [:] Compiling... [:] Compiling 1 files with 0.8.14 [:] Solc 0.8.14 finished in 264.52ms Compiler run successful Deployer: 0x0394c0EdFcCA370B20622721985B577850B0eb75 Deployed to: 0x6A489374557354CE325D4F4a0Dd8F1CB98c1592 Transaction hash: 0x3ab6002497ca35971d2025b0a7d544f703de465513327d4b640886354d11f612 Starting contract verification... Waiting for etherscan to detect contract deployment... Submitting verification for [MyToken] \"0x6A489374557354CE325D4F4a0Dd8F1CB98c1592\" • Submitting verification for [MyToken] \"0x6A489374557354CE325D4F4a0Dd8F1CB98c1592\" • Contract source code already verified. Storage Timestamp: 2025-09-04 00:06:03.787Z"}, {"location": "builders/ethereum/verify-contracts/block-explorers/", "title": "使用区块浏览器验证智能合约", "text": ""}, {"location": "builders/ethereum/verify-contracts/block-explorers/#introduction", "title": "简介", "text": "<p>在区块浏览器上验证智能合约是提高 Moonbeam 上已部署智能合约透明度和安全性的绝佳方法。用户可以直接查看已验证智能合约的源代码，对于某些区块浏览器，他们还可以通过区块浏览器的界面直接与合约的公共方法进行交互。</p> <p>本页面将概述通过区块浏览器在 Moonbeam 网络上验证智能合约的步骤。</p>"}, {"location": "builders/ethereum/verify-contracts/block-explorers/#deploying-the-contract", "title": "部署合约", "text": "<p>为了在区块浏览器上验证智能合约，必须首先将合约部署到目标网络。本教程将介绍如何将智能合约部署到 Moonbase Alpha，但它也可以适用于 Moonbeam 或 Moonriver。</p> <p>您可以查看此页面，获取有关使用 Moonbeam 上的 Ethereum 库部署智能合约的教程。您也可以使用开发者工具，例如 Remix、Hardhat，或者其他首选工具，将智能合约部署到 Moonbeam。</p> <p>本教程将使用与上述部署教程相同的合约，用于合约验证示例。</p> <p>使用的合约是一个简单的增量器，任意命名为 <code>Incrementer.sol</code>。Solidity 代码如下：</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre>"}, {"location": "builders/ethereum/verify-contracts/block-explorers/#_2", "title": "收集合约验证信息", "text": "<p>您需要收集一些与合约编译器和部署相关的信息，以便成功验证合约。</p> <ol> <li>记下用于编译和部署合约的 Solidity 编译器版本。Solidity 编译器版本通常可以在使用的部署工具中选择或指定</li> <li> <p>记下在 Solidity 源文件开头使用的任何 SPDX 许可证标识符（此示例使用 MIT 许可证）：</p> <pre><code>// SPDX-License-Identifier: MIT\n</code></pre> </li> <li> <p>（可选）如果在编译期间启用了优化，请记下优化运行参数的值</p> </li> <li>（可选）如果合约构造函数方法接受参数，请记下构造函数参数的 ABI 编码形式</li> <li>部署后，记下智能合约的已部署合约地址。合约的部署地址可以在控制台输出中找到（如果使用基于命令行的工具（如 Hardhat）或以太坊库），也可以从 Remix IDE 等工具的 GUI 中复制</li> </ol> <p></p> <p></p>"}, {"location": "builders/ethereum/verify-contracts/block-explorers/#verifying-the-contract", "title": "验证合约", "text": "<p>下一步将是在与EVM兼容的Moonbeam网络浏览器中验证您部署的智能合约。</p>"}, {"location": "builders/ethereum/verify-contracts/block-explorers/#moonscan", "title": "Moonscan", "text": "<p>请按照以下步骤在 Moonscan 上验证合约：</p> <ol> <li>转到 Moonscan 的 验证和发布合约源代码 页面</li> <li>在第一个字段中填写合约的已部署地址，包括 <code>0x</code> 前缀</li> <li>选择编译器类型。对于当前的 <code>Incrementer.sol</code> 示例，选择 Solidity (Single file)</li> <li>选择编译器类型后，选择用于编译合约的编译器版本。如果使用的编译器版本是 nightly commit，请取消选中该字段下的复选框以选择 nightly 版本</li> <li>选择使用的开源许可证。对于当前的 <code>Incrementer.sol</code> 示例，选择选项 MIT License (MIT)。如果没有使用任何许可证，请选择 No License (None)</li> <li>单击表单底部的 Continue 按钮以继续进入下一页</li> </ol> <p></p> <p>在第二页上，Contract Address、Compiler 和 Constructor Arguments 字段应已预先填写。填写其余信息：</p> <ol> <li>将合约的全部内容复制并粘贴到标记为该内容的文本字段中</li> <li>（可选）如果编译期间启用了 Optimization，请选择 Yes，并在 Misc Settings/Runs(Optimizer) 下填写运行次数</li> <li>（可选）添加合约库及其地址（如果合约中使用了任何库）</li> <li>（可选）选中可能适用于您的合约的任何其他可选字段，并相应地填写它们</li> <li>单击底部的 CAPTCHA 和 Verify and Publish 按钮以确认并开始验证</li> </ol> <p></p> <p>短暂等待后，验证结果将显示在浏览器中，并且成功结果页面将显示合约的 ABI 编码的构造函数参数、合约名称、字节码和 ABI。</p> <p></p>"}, {"location": "builders/ethereum/verify-contracts/block-explorers/#smart-contract-flattening", "title": "智能合约扁平化", "text": "<p>对于验证由多个文件组成的智能合约，该过程略有不同，需要进行一些预处理，以将目标智能合约的所有依赖项组合到一个 Solidity 文件中。</p> <p>此预处理通常称为智能合约扁平化。 有许多工具可用于将多部分智能合约扁平化为单个 Solidity 文件，例如 Hardhat 的 Flatten 任务。 有关其用法的更详细说明，请参阅相应的智能合约扁平化工具的文档。</p> <p>在扁平化多部分智能合约后，可以使用新的扁平化 Solidity 文件在区块浏览器上验证它，就像验证单文件智能合约一样，如本教程中所述。</p>"}, {"location": "builders/ethereum/verify-contracts/block-explorers/#verify-multi-part-smart-contract-on-moonscan", "title": "在 Moonscan 上验证多部分智能合约", "text": "<p>为了在 Moonscan 上进行验证，有一个内置功能可以处理多部分智能合约。</p> <p>在编译器类型下选择 Solidity (多部分文件)（上述示例的第 3 步）。然后，在下一页上，选择并上传合约所包含的所有不同的 Solidity 文件，包括它们嵌套的依赖合约文件。</p> <p></p> <p>除此之外，该过程与在 Moonscan 上验证单文件合约的过程大致相同。</p>"}, {"location": "builders/ethereum/verify-contracts/etherscan-plugins/", "title": "使用 Etherscan 插件验证智能合约", "text": ""}, {"location": "builders/ethereum/verify-contracts/etherscan-plugins/#introduction", "title": "简介", "text": "<p>验证智能合约是提高部署在 Moonbeam 上的合约透明度和安全性的绝佳方法。Hardhat 和 Foundry 与 Etherscan 的合约验证服务集成，通过本地检测要验证的合约以及所需的 Solidity 库（如果有）来自动执行验证合约的过程。</p> <p>Hardhat 插件可以无缝集成到您的 Hardhat 项目中。Foundry 也具有 Etherscan 功能，但它们内置于其 Forge 工具中，而不是包含在单独的插件中。</p> <p>本指南将向您展示如何使用这两个插件来验证部署在 Moonbase Alpha 上的智能合约。本指南也适用于 Moonbeam 和 Moonriver。</p>"}, {"location": "builders/ethereum/verify-contracts/etherscan-plugins/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要学习本教程，您需要具备以下条件：</p> <ul> <li>MetaMask 已安装并连接到 Moonbase Alpha 测试网</li> <li>一个已充值 <code>DEV</code> 代币的帐户。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>一个 Etherscan API 密钥</li> <li>已安装并配置 Git</li> </ul>"}, {"location": "builders/ethereum/verify-contracts/etherscan-plugins/#etherscan-api", "title": "生成 Etherscan API 密钥", "text": "<p>要在 Moonbeam 网络的 Moonscan 上验证合约，您需要一个 Etherscan API 密钥。由于 Moonscan 是 Etherscan 生态系统的一部分，因此单个密钥适用于所有支持的网络。</p> <p>要创建 Etherscan 帐户 并生成您的密钥，请按照以下步骤操作：</p> <ol> <li>点击 Sign In（登录）</li> <li>选择 Click to sign up（点击注册），然后注册您的新帐户</li> </ol> <p></p> <p>拥有帐户并登录后，您就可以创建 API 密钥。</p> <ol> <li>从左侧菜单中选择 API Dashboard（API 仪表板）</li> <li>要添加新密钥，请点击 + Add（+ 添加）按钮</li> </ol> <p></p> <p>然后，系统会提示您为 API 密钥输入 AppName（应用程序名称），输入名称并点击 Continue（继续）后，它将出现在您的 API 密钥列表中。</p>"}, {"location": "builders/ethereum/verify-contracts/etherscan-plugins/#using-the-hardhat-verify-plugin", "title": "使用 Hardhat Etherscan 插件", "text": "<p>本指南本节中的示例将基于在使用 Hardhat 部署到 Moonbeam 指南中创建的 <code>Box.sol</code> 合约。</p> <p>要开始使用 Hardhat Etherscan 插件，您首先需要安装插件库：</p> <pre><code>npm install --save-dev @nomicfoundation/hardhat-verify\n</code></pre> <p>您可以将您的 Etherscan API 密钥添加到 <code>hardhat.config.js</code> 文件中。</p> <p>在您的 Hardhat 项目中，打开您的 <code>hardhat.config.js</code> 文件。您需要导入 <code>hardhat-verify</code> 插件、您的 Etherscan API 密钥，并添加 Etherscan 的配置：</p> <pre><code>require('@nomicfoundation/hardhat-verify');\n\nmodule.exports = {\n  networks: {\n    moonbeam: { ... },\n    moonriver: { ... },\n    moonbaseAlpha: { ... }\n  },\n  etherscan: {\n    apiKey: {\n      moonbeam: 'INSERT_ETHERSCAN_API_KEY',\n      moonriver: 'INSERT_ETHERSCAN_API_KEY',\n      moonbaseAlpha: 'INSERT_ETHERSCAN_API_KEY', \n    },\n  },\n};\n</code></pre> <p>要验证合约，您将运行 <code>verify</code> 命令，并传入已部署合约的地址以及部署的网络：</p> <pre><code>npx hardhat verify --network moonbase INSERT_CONTRACT_ADDRESS\n</code></pre> <p>在您的终端中，您应该看到您的合约的源代码已成功提交以进行验证。如果验证成功，您应该看到 Successfully verified contract，并且在 Moonscan for Moonbase Alpha 上会有一个指向合约代码的链接。</p> npx hardhat verify --network moonbase 0x5d73ecDB4652173b881893235B64F1a0BdE22dD6 Successfully submitted source code for contract contracts/Box.sol:Box at 0x5d73ecDB4652173b881893235B64F1a0BdE22dD6 for verification on the block explorer. Waiting for verification result... Successfully verified contract Box on Etherscan. https://moonbase.moonscan.io/address/0x5d73ecDB4652173b881893235B64F1a0BdE22dD6#code <p>如果您要验证的合约具有构造函数参数，您需要运行上述命令，并在命令末尾添加用于部署合约的构造函数参数。例如：</p> <pre><code>npx hardhat verify --network moonbase INSERT_CONTRACT_ADDRESS INSERT_CONSTRUCTOR_ARGS\n</code></pre> <p>请参阅 Hardhat Verify 文档 以获取有关其他用例的帮助，例如：</p> <ul> <li>复杂参数</li> <li>具有无法检测地址的库</li> <li>使用多个 API 密钥</li> <li>以编程方式使用 <code>verify</code> 命令</li> <li>确定正确的构造函数参数</li> </ul>"}, {"location": "builders/ethereum/verify-contracts/etherscan-plugins/#using-foundry-to-verify", "title": "使用 Foundry 进行验证", "text": "<p>本指南此部分中的示例将使用在使用 Foundry 部署到 Moonbeam 指南中创建的 <code>MyToken.sol</code> 合约。</p> <p>除了 Foundry 项目，您还需要一个 Etherscan API 密钥 来验证您的合约。</p> <p>如果您已经部署了示例合约，您可以使用 <code>verify-contract</code> 命令来验证它。在验证合约之前，您需要对构造函数参数进行 ABI 编码。要对示例合约执行此操作，您可以运行以下命令：</p> <pre><code>cast abi-encode \"constructor(uint256)\" 100\n</code></pre> <p>结果应为 <code>0x0000000000000000000000000000000000000000000000000000000000000064</code>。然后，您可以使用以下命令验证合约：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>forge verify-contract --chain-id 1284 \\\n  YOUR_CONTRACT_ADDRESS \\\n  --constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\n  src/MyToken.sol:MyToken \\\n  --etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY\n</code></pre> <pre><code>forge verify-contract --chain-id 1285 \\\n  YOUR_CONTRACT_ADDRESS \\\n  --constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\n  src/MyToken.sol:MyToken \\\n  --etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY\n</code></pre> <pre><code>forge verify-contract --chain-id 1287 \\\n  YOUR_CONTRACT_ADDRESS \\\n  --constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\n  src/MyToken.sol:MyToken \\\n  --etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY\n</code></pre> forge verify-contract --chain-id 1284 \\ YOUR_CONTRACT_ADDRESS \\ --constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\ src/MyToken.sol:MyToken \\ --etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY Submitting verification for [src/MyToken. sol:MyToken] Ok(\"0×5A05EBOA18ee616bb5dac2C4D0a48991a83533d2\" ) . Submitted contract for verification:         Response:'OK'         GUID:'f7iwagu9vspdrdfirbie1wp16cmuvfk3zvcsix9ey21t3a8ttt'         URL: https: //moonbase.moonscan.io/address/0×5a05eb0a18ee616bb5dac2c4d0a48991a83533d2 Waiting for verification result... Contract successfully verified. <p>如果您想同时部署示例合约并进行验证，那么您可以使用以下命令：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>forge create --rpc-url INSERT_RPC_API_ENDPOINT \\\n  --constructor-args 100 \\\n  --etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY \\\n  --verify --private-key YOUR_PRIVATE_KEY \\\n  src/MyToken.sol:MyToken\n</code></pre> <pre><code>forge create --rpc-url INSERT_RPC_API_ENDPOINT \\\n  --constructor-args 100 \\\n  --etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY \\\n  --verify --private-key YOUR_PRIVATE_KEY \\\n  src/MyToken.sol:MyToken\n</code></pre> <pre><code>forge create --rpc-url https://rpc.api.moonbase.moonbeam.network \\\n  --constructor-args 100 \\\n  --etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY \\\n  --verify --private-key YOUR_PRIVATE_KEY \\\n  src/MyToken.sol:MyToken\n</code></pre> forge create --rpc-url INSERT_RPC_API_ENDPOINT \\ --constructor-args 100 \\ --etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY \\ --verify --private-key YOUR_PRIVATE_KEY \\ src/MyToken.sol:MyToken Compiling... No files changed, compilation skipped Deployer: 0x0394c0EdFcCA370B20622721985B577850B0eb 75 Deployed to: 0d21b2653f61b5B5399A677D377D52D07C7668f67 Transaction hash: 0x80fff772b930f425ed3568f0b3d8844e5297691c78807c7b393c85910b7717 Starting contract verification... Waiting for etherscan to detect contract deployment... Submitting verification for [src/MyToken.sol:MyToken]Ok(\"0x21b265361b5B5399A677D377D52D07C7668f67\"). Submitted contract for verification:         Response:'OK'         GUID:'ebbliyrquc5itkavvhvmilanzu5rdqusikImgraanepjm8gpq'         URL: https: //moonbase.moonscan.io/address/0x21b2653f61b55399a677d377d52d07c7668f67 Waiting for verification result... Contract successfully verified."}, {"location": "builders/get-started/endpoints/", "title": "网络端点", "text": ""}, {"location": "builders/get-started/endpoints/#public-endpoints", "title": "公共端点", "text": "<p>基于 Moonbeam 的网络有两个端点可供用户连接：一个用于 HTTPS，另一个用于 WSS。</p> <p>本节中的端点仅用于开发目的，不适合在生产应用程序中使用。</p> <p>如果您正在寻找适合生产使用的 API 提供商，您可以查看本指南的 端点提供商 部分。</p>"}, {"location": "builders/get-started/endpoints/#endpoint-providers", "title": "RPC端点提供商", "text": "<p>您可以使用以下任何API提供商创建适合开发或生产用途的自定义端点：</p> <ul> <li>1RPC</li> <li>Chainstack</li> <li>dRPC NodeCloud</li> <li>Dwellir</li> <li>GetBlock</li> <li>OnFinality</li> <li>UnitedBloc</li> </ul>"}, {"location": "builders/get-started/endpoints/#1rpc", "title": "1RPC", "text": "<p>1RPC 是一个免费且私密的 RPC 中继，通过防止数据收集、用户跟踪和其他方的网络钓鱼企图来保护用户隐私。它通过分布式中继将用户请求隧道传输到其他 RPC 提供商，同时使用安全 enclave 技术防止跟踪用户元数据，例如 IP 地址、设备信息和钱包可链接性。</p> <p>创建 1RPC 的目的是为了成为区块链基础设施社区的一项开放倡议。 他们的动力来自于帮助构建更好的 Web3 的共同利益使命，并鼓励任何重视用户隐私的人加入到这项开放合作中来。</p> <p>前往 1RPC 官方网站进行设置！</p> <p></p>"}, {"location": "builders/get-started/endpoints/#chainstack", "title": "Chainstack", "text": "<p>Chainstack，Web3 基础设施提供商，为 Moonbeam 提供免费和付费的端点。免费的开发者计划起始于每月 300 万次请求和每秒 25 次请求 (RPS)。您可以使用付费计划轻松扩展。</p> <p>要开始使用免费的开发者计划端点，请使用电子邮件或任何社交帐户（如 GitHub 或 X (Twitter)）注册。</p> <ol> <li>访问 Chainstack</li> <li>注册</li> <li>部署 Moonbeam 节点</li> </ol> <p></p>"}, {"location": "builders/get-started/endpoints/#drpc", "title": "dRPC 节点云", "text": "<p>dRPC.org 提供公共和付费的 Moonbeam RPC 端点，从而提供与区块链节点的高效、低延迟连接。付费层包括更高的请求限制、更低的延迟以及用于优化性能的高级分析。</p> <p>如何使用 dRPC：</p> <ol> <li>在 dRPC.org 注册或登录</li> <li>在控制面板中，创建一个 API 密钥</li> <li>单击密钥并选择所需的端点</li> </ol> <p>如需全天候支持，请加入 dRPC 的 Discord。</p>"}, {"location": "builders/get-started/endpoints/#dwellir", "title": "Dwellir", "text": "<p>Dwellir 是一种区块链运营服务，可确保全球可扩展性、低延迟和 99.99% 的正常运行时间保证，无论您的业务位于何处，都能提供快速可靠的节点运营。公共端点服务是在全球地理分布的裸机服务器。由于该服务是公共的，因此无需注册或管理 API 密钥。</p> <p>要开始使用开发者端点或专用节点，您需要联系我们：</p> <ol> <li>访问 Dwellir</li> <li>提交您的电子邮件和您的节点请求</li> </ol> <p></p>"}, {"location": "builders/get-started/endpoints/#getblock", "title": "GetBlock", "text": "<p>GetBlock 是一项服务，可提供对 Moonbeam 和 Moonriver 的即时 API 访问，并通过共享和专用节点提供。专用节点 提供对私有服务器的访问，具有快速的速度且没有速率限制。共享节点 提供免费的基于 API/附加组件的端点，以便您快速开始使用。</p> <p>要开始使用 GetBlock，您可以转到 GetBlock 注册页面 并注册一个新帐户。然后，从您的帐户仪表板中，您可以查看和管理现有多个协议的端点，还可以创建新的端点。</p> <p>创建一个新的基于 API/附加组件的端点非常简单，您只需：</p> <ol> <li>从可用区块链的列表中填写所需协议的信息</li> <li>选择您希望端点指向的网络（Mainnet、Testnet 等）</li> <li>从 API/附加组件下拉列表中选择 JSON-RPC</li> <li>单击最右侧的 Get 按钮，您就可以开始了！</li> </ol> <p></p>"}, {"location": "builders/get-started/endpoints/#onfinality", "title": "OnFinality", "text": "<p>OnFinality 为客户提供基于免费 API 密钥的端点，以代替公共端点。此外，OnFinality 还提供付费服务层级，与免费层级相比，这些层级提供更高的速率限制和更高的性能。您还可以获得更深入的应用程序使用情况分析。</p> <p>要创建自定义 OnFinality 端点，请访问 OnFinality 并注册，或者如果您已经注册，您可以直接登录。从 OnFinality 控制面板，您可以：</p> <ol> <li>单击 API 服务</li> <li>从下拉列表中选择网络</li> <li>您的自定义 API 端点将自动生成</li> </ol> <p></p>"}, {"location": "builders/get-started/endpoints/#unitedbloc", "title": "UnitedBloc", "text": "<p>UnitedBloc 是来自 Moonbeam 和 Moonriver 的社区收集者的集合。为了给社区提供价值，他们为 Moonbeam、Moonriver 和 Moonbase Alpha 网络提供公共 RPC 服务。</p> <p>公共端点服务由八个地理位置分散的裸机服务器提供，这些服务器通过 GeoDNS 进行全局负载均衡，并通过 NGINX 进行区域负载均衡。由于该服务是公共的，因此无需注册或管理 API 密钥。</p> <p>参与此倡议的收集者是：</p> <ul> <li>Blockshard (CH)</li> <li>BloClick (ES)</li> <li>BrightlyStake (IN)</li> <li>CertHum (US)</li> <li>GPValidator (PT)</li> <li>Hetavalidation (AU)</li> <li>Legend (AE)</li> <li>PathrockNetwork (DE)</li> <li>Polkadotters (CZ)</li> <li>SIK | crifferent.de (DE)</li> <li>StakeBaby (GR)</li> <li>StakeSquid (GE)</li> <li>TrueStaking (US)</li> </ul> <p>他们还提供一个公共 Grafana 仪表板，其中包含一些很酷的指标。</p> <p>查看公共端点部分以获取相关 URL。您可以通过他们的 Telegram 频道 与他们联系，或在其 博客文章页面 上阅读有关其倡议的更多信息。</p>"}, {"location": "builders/get-started/endpoints/#lazy-loading-with-RPC-Endpoint-Providers", "title": "使用 RPC 端点提供程序进行延迟加载", "text": "<p>通过延迟加载，Moonbeam 节点可以在后台下载网络状态的同时运行，从而无需等待完全同步即可使用。要使用延迟加载启动 Moonbeam 节点，您需要下载 Moonbeam 发布二进制文件或编译二进制文件。您可以使用以下标志激活延迟加载：</p> <p><code>--lazy-loading-remote-rpc 'INSERT-RPC-URL'</code></p> <p>延迟加载是高度资源密集型的，需要大量的 RPC 请求才能运行。为了避免受到限制，建议您使用专用端点（即带有 API 密钥的端点），而不是公共端点。如果您使用带有公共端点的延迟加载，则可能会受到速率限制。使用此功能启动节点后，您将看到如下输出：</p> [Lazy loading 🌗]     You are now running the Moonbeam client in lazy loading mode, where data is retrieved     from a live RPC node on demand.     Using remote state from: https://moonbeam.unitedbloc.com     Forking from block: 8482853     To ensure the client works properly, please note the following:         1. *Avoid Throttling*: Ensure that the backing RPC node is not limiting the number of         requests, as this can prevent the lazy loading client from functioning correctly;         2. *Be Patient*: As the client may take approximately 20 times longer than normal to         retrieve and process the necessary data for the requested operation.     The service will start in 10 seconds..."}, {"location": "builders/get-started/endpoints/#_2", "title": "使用延迟加载覆盖状态", "text": "<p>默认情况下，您不会在终端中看到详细的日志记录。要覆盖此设置并显示延迟加载日志，您可以将以下标志添加到启动 Moonbeam 节点的命令中：<code>-l debug</code>。您可以使用以下可选参数进一步自定义延迟加载功能的使用：</p> <ul> <li><code>--lazy-loading-block</code> - 指定一个区块哈希，从中开始加载数据。如果未提供，将使用最新的区块</li> <li><code>--lazy-loading-delay-between-requests</code> - 使用延迟加载时，RPC 请求之间的延迟（以毫秒为单位）。此参数控制连续 RPC 请求之间等待的时间量。这有助于管理请求速率并避免服务器负载过大。默认值为 <code>100</code> 毫秒</li> <li><code>--lazy-loading-max-retries-per-request</code> - 使用延迟加载时，RPC 请求的最大重试次数。默认值为 <code>10</code> 次重试</li> <li><code>--lazy-loading-runtime-override</code> - WASM 文件的路径，用于在派生时覆盖运行时。如果未提供，它将从正在派生的区块中获取运行时</li> <li><code>--lazy-loading-state-overrides</code> - JSON 文件的路径，其中包含派生时要应用的状态覆盖</li> </ul>"}, {"location": "builders/get-started/endpoints/#_3", "title": "简单的存储项覆盖", "text": "<p>状态覆盖文件应定义您要覆盖的相应托盘、存储项和值，如下所示：</p> <p>[  {      \"pallet\": \"System\",      \"storage\": \"SelectedCandidates\",      \"value\": \"0x04f24ff3a9cf04c71dbc94d0b566f7a27b94566cac\"  } ]</p>"}, {"location": "builders/get-started/endpoints/#_4", "title": "覆盖账户的可用余额", "text": "<p>要覆盖特定账户的余额，您可以按照以下方式覆盖相应账户的系统 pallet 的账户存储项：</p> <p>[   {     \"pallet\": \"System\",     \"storage\": \"Account\",     \"key\": \"TARGET_ADDRESS\",     \"value\": \"0x460c000002000000010000000600000069e10de76676d0800000000000000000040a556b0e032de12000000000000000004083a09e15c74c1b0100000000000000000000000000000000000000000000080\"   } ]</p> 关于覆盖账户余额的详细信息 <p>如上所示，覆盖账户余额可能是一个复杂的过程。但是，本指南会将其分解为易于遵循的步骤。在进行任何更改之前，您应该获取与键对应的现有值（即本例中的账户）。您可以转到 Polkadot.js 应用程序上的链状态，并通过提供您要查询的账户来查询系统 pallet。提交查询后，您将获得一个可读的账户结构，如下所示：</p> <p>text {   nonce: 3,142   consumers: 2   providers: 1   sufficients: 6   data: {     free: 1,278,606,392,142,175,328,676     reserved: 348,052,500,000,000,000,000     frozen: 20,413,910,106,633,175,872     flags: 170,141,183,460,469,231,731,687,303,715,884,105,728   } }</p> <p>虽然这可以作为参考，但您要查找的信息是编码的存储键，即使不提交链状态查询也可以访问该键。在本例中，对应于系统 pallet 和所选账户 <code>0x3B939FeaD1557C741Ff06492FD0127bd287A421e</code> 的编码存储键为：</p> <p>text 0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9b882fedb4f75b055c709ec5b66b5d9933b939fead1557c741ff06492fd0127bd287a421e</p> <p>请注意，此编码存储键将随着任何输入更改而更改，例如查询不同的账户。然后，转到 Polkadot.js 应用程序 上的 Raw Storage 选项卡。输入上述存储键并提交查询。响应是 SCALE 编码的账户结构，其中的一部分包含可用余额信息，将在本示例中修改：</p> <p>text 0x460c0000020000000100000006000000a4d92a6a4e6b3a5045000000000000000040a556b0e032de12000000000000004083a09e15c74c1b010000000000000000000000000000000000000000000080</p> <p>值字段中编码了相当多的数据，因为它是一个由多个值组成的复杂结构。该结构包括：</p> <p>text struct AccountInfo {     nonce: u32,             // 交易计数     consumers: u32,         // 消费者数量     providers: u32,         // 提供者数量     sufficients: u32,       // 充足数量     data: AccountData {     // 余额信息         free: u128,         // 可用余额         reserved: u128,     // 保留余额         frozen: u128,       // 冻结余额         flags: u128         // 账户标志     } }</p> <p>您可以将 SCALE 编码结构的每个部分与它所代表的 Alice 账户信息的相应部分相关联：</p> <p>text 0x460c0000        // nonce (u32): 3,142 02000000          // consumers (u32): 2 01000000          // providers (u32): 1 06000000          // sufficients (u32): 6</p> <p>a4d92a6a4e6b3a5045000000000000000 // free (u128): 1,278,606,392,142,175,328,676</p> <p>40a556b0e032de1200000000000000000 // reserved (u128): 348,052,500,000,000,000,000</p> <p>4083a09e15c74c1b01000000000000000 // frozen (u128): 20,413,910,106,633,175,872</p> <p>00000000000000000000000000000080 // flags (u128): 170,141,183,460,469,231,731,687,303,715,884,105,728</p> <p>请记住，这些值是小端编码的。要将十六进制小端编码值转换为十进制，您可以使用 Substrate Utilities 转换器，使用 Balance to Hex (Little Endian) 转换器。</p> <p>在本示例中，现有的可用余额 <code>1,278,606,392,142,175,328,676</code> Wei 或大约 <code>1278.60</code> DEV 是 <code>a4d92a6a4e6b3a5045</code>。以下示例会将值更改为 <code>500,000</code> DEV，即 <code>500,000,000,000,000,000,000,000</code> Wei 或 <code>0x000080d07666e70de169</code> 编码为十六进制小端值。正确填充以适合 SCALE 编码的存储值时，它变为 <code>69e10de76676d08000000000000000000</code>，因此该表现在如下所示：</p> <p>text 0x460c0000        // nonce (u32): 3,142 02000000          // consumers (u32): 2 01000000          // providers (u32): 1 06000000          // sufficients (u32): 6</p> <p>69e10de76676d08000000000000000000 // free (u128): 500,000,000,000,000,000,000,000</p> <p>40a556b0e032de1200000000000000000 // reserved (u128): 348,052,500,000,000,000,000</p> <p>4083a09e15c74c1b01000000000000000 // frozen (u128): 20,413,910,106,633,175,872</p> <p>00000000000000000000000000000080 // flags (u128): 170,141,183,460,469,231,731,687,303,715,884,105,728</p> <p>因此，SCALE 编码的覆盖值如下：</p> <p>text 0x460c000002000000010000000600000069e10de76676d0800000000000000000040a556b0e032de12000000000000000004083a09e15c74c1b0100000000000000000000000000000000000000000000080</p> <p>您现在可以在 <code>state-overrides.json</code> 文件中指定 SCALE 编码的覆盖值，如下所示：</p> <p>[   {     \"pallet\": \"System\",     \"storage\": \"Account\",     \"key\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",     \"value\": \"0x460c000002000000010000000600000069e10de76676d0800000000000000000040a556b0e032de12000000000000000004083a09e15c74c1b0100000000000000000000000000000000000000000000080\"   } ]</p> <p>要使用余额状态覆盖运行延迟加载，您可以使用以下命令：</p> <p>bash --lazy-loading-remote-rpc 'INSERT_RPC_URL' --lazy-loading-state-overrides ./state-overrides.json</p>"}, {"location": "builders/get-started/endpoints/#erc-20", "title": "覆盖 ERC-20 代币余额", "text": "<p>要覆盖 ERC-20 代币余额，请在 EVM 的 AccountStorages 中找到存储给定代币合约和帐户的 <code>balanceOf</code> 数据的存储槽。此存储槽由代币合约的 H160 地址和相应的 H256 存储密钥确定。获得此槽后，在 <code>state-overrides.json</code> 文件中指定新的余额值以实现覆盖。</p> <p>在下面的示例中，我们将帐户 <code>0x3b939fead1557c741ff06492fd0127bd287a421e</code> 的 Wormhole USDC 合约 (<code>0x931715FEE2d06333043d11F658C8CE934aC61D0c</code>) 的代币余额覆盖为 5,000 美元 USDC。由于 Wormhole USDC 使用 6 位小数，因此 5,000 美元对应于整数形式的 <code>5000000000</code>，即十六进制的 <code>0x12a05f200</code>。</p> <p>[     {         \"pallet\": \"EVM\",         \"storage\": \"AccountStorages\",         \"key\": [             \"0x931715FEE2d06333043d11F658C8CE934aC61D0c\",             \"0x8c9902c0f94ae586c91ba539eb52087d3dd1578da91158308d79ff24a8d4f342\"         ],         \"value\": \"0x000000000000000000000000000000000000000000000000000000012a05f200\"     } ]</p> <p>您可以使用以下脚本计算要覆盖的帐户的精确存储槽：</p> <p>js import { ethers from 'ethers';</p> <p>function getBalanceSlot(accountAddress) {   // Convert address to bytes32 and normalize   const addr = ethers.zeroPadValue(accountAddress, 32);</p> <p>// CAUTION! The storage slot used here is 5, which   // is specific to Wormhole contracts   // The storage slot index for other tokens may vary   const packedData = ethers.concat([     addr,     ethers.zeroPadValue(ethers.toBeHex(5), 32),   ]);</p> <p>// Calculate keccak256   return ethers.keccak256(packedData); }</p> <p>// Example usage const address = 'INSERT_ADDRESS'; console.log(getBalanceSlot(address));</p> <p>您可以将相同的过程应用于其他 ERC-20 代币合约。以下部分演示了使用各种 ERC-20 代币覆盖 <code>0x3B939FeaD1557C741Ff06492FD0127bd287A421e</code> 帐户。请记住，每当您切换到其他代币时，请更新 H160 代币合约地址。此外，您需要为要覆盖其余额的每个不同帐户重新计算 H256 存储槽。</p> 示例：覆盖 Wormhole BTC 代币余额 <p>[     {         \"pallet\": \"EVM\",         \"storage\": \"AccountStorages\",         \"key\": [             \"0xE57eBd2d67B462E9926e04a8e33f01cD0D64346D\",             \"0x8c9902c0f94ae586c91ba539eb52087d3dd1578da91158308d79ff24a8d4f342\"         ],         \"value\": \"0x000000000000000000000000000000000000000000000000000000012a05f200\"     } ]</p> 示例：覆盖 Wormhole ETH 代币余额 <p>[     {         \"pallet\": \"EVM\",         \"storage\": \"AccountStorages\",         \"key\": [             \"0xab3f0245B83feB11d15AAffeFD7AD465a59817eD\",             \"0x8c9902c0f94ae586c91ba539eb52087d3dd1578da91158308d79ff24a8d4f342\"         ],         \"value\": \"0x000000000000000000000000000000000000000000000000000000012a05f200\"     } ]</p> 示例：覆盖 WELL 代币余额 <p>因为 WELL 代币 不使用代理实现合约，所以存储槽计算有所不同。余额映射位于槽 <code>1</code>，而不是槽 <code>5</code>。您可以使用以下脚本确定要覆盖的您自己的帐户的 WELL 代币余额的精确存储槽：</p> <p>js import { ethers from 'ethers';</p> <p>function getBalanceSlot(accountAddress) {   // Convert address to bytes32 and normalize   const addr = ethers.zeroPadValue(accountAddress, 32);</p> <p>// Caution! The storage slot index used here is 1   // The storage slot index for other tokens may vary   const packedData = ethers.concat([     addr,     ethers.zeroPadValue(ethers.toBeHex(1), 32),   ]);</p> <p>// Calculate keccak256   return ethers.keccak256(packedData); }</p> <p>// Example usage const address = 'INSERT_ADDRESS'; console.log(getBalanceSlot(address));</p> <p>因此，存储覆盖将是：</p> <p>[     {         \"pallet\": \"EVM\",         \"storage\": \"AccountStorages\",         \"key\": [             \"0x511aB53F793683763E5a8829738301368a2411E3\",             \"0x728d3daf4878939a6bb58cbc263f39655bb57ea15db7daa0b306f3bf2c3f1227\"         ],         \"value\": \"0x000000000000000000000000000000000000000000000000000000012a05f200\"     } ]</p>"}, {"location": "builders/get-started/endpoints/#tracing-providers", "title": "Tracing RPC 端点供应商", "text": "<p>通过 Tracing RPC 端点，您可以访问非标准的 RPC 方法，例如属于 Geth 的 <code>debug</code> 和 <code>txpool</code> API 以及 OpenEthereum 的 <code>trace</code> 模块的方法。要查看 Moonbeam 上支持的用于调试和追踪的非标准 RPC 方法列表，请参阅调试 API 和追踪模块 指南。</p> <p>以下供应商提供 tracing RPC 端点：</p> <ul> <li>OnFinality</li> </ul>"}, {"location": "builders/get-started/endpoints/#onfinality-tracing", "title": "OnFinality", "text": "<p>OnFinality 的 Trace API 可用于快速开始在 Moonbeam 和 Moonriver 上跟踪和调试交易。它仅适用于 Growth 和 Ultimate 计划 的用户。</p> <p>要使用 Trace API，您只需从您的 私有 RPC 端点 调用您选择的跟踪方法。有关支持的网络和跟踪方法的列表，请查看 OnFinality 的 Trace API 文档。</p> <p>请注意，如果您要跟踪历史区块，建议您使用自己的专用跟踪节点来回填任何数据，然后在您赶上进度后，您可以切换到使用 Trace API。您可以查看 如何在 OnFinality 上为 Moonbeam 部署跟踪节点 这篇文章，以获取有关如何启动您自己的专用跟踪节点的更多信息。</p>"}, {"location": "builders/get-started/explorers/", "title": "区块浏览器", "text": ""}, {"location": "builders/get-started/explorers/#introduction", "title": "简介", "text": "<p>区块浏览器可以被认为是区块链的搜索引擎。它们允许用户搜索诸如余额、合约和交易等信息。更高级的区块浏览器甚至提供索引功能，这使它们能够提供完整的信息集，例如网络中的 ERC-20 代币。它们甚至可能提供 API 服务以通过外部服务访问它。</p> <p>Moonbeam 提供了两种不同类型的浏览器：一种用于查询 Ethereum API，另一种专用于 Substrate API。所有基于 EVM 的交易都可以通过 Ethereum API 访问，而 Substrate API 可以用于 Substrate 原生功能，例如治理和质押。Substrate API 还包括有关基于 EVM 的交易的信息，但仅显示有限的信息。</p>"}, {"location": "builders/get-started/explorers/#quick-links", "title": "快速链接", "text": "MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node Block Explorer Type URL Moonscan EVM https://moonbeam.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=Moonbeam Subscan Substrate https://moonbeam.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Moonscan EVM https://moonriver.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=Moonriver Subscan Substrate https://moonriver.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Moonscan EVM https://moonbase.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=MoonbaseAlpha Subscan Substrate https://moonbase.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Expedition EVM https://moonbeam-explorer.netlify.app/?network=MoonbeamDevNode Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer"}, {"location": "builders/get-started/explorers/#Moonscan", "title": "Moonscan", "text": "<p>Moonscan 是 Moonbeam 网络的的主要以太坊 API 区块链浏览器。Moonscan 由 Etherscan 团队构建，提供强大、直观且功能丰富的体验。除了其全面的交易和区块数据外，Moonscan 还提供许多统计数据和图表，例如平均 Gas 价格、每日交易量和区块大小图表。</p> <p>Moonscan 的其他功能包括：</p> <ul> <li>验证人排行榜，按性能对验证人进行排名</li> <li>合约源代码验证，可通过 Web 界面和 API 访问</li> <li>能够读取和写入已验证智能合约的状态数据</li> <li>Token 授权，您可以在其中查看和撤销之前的所有 Token 授权</li> <li>添加 Token 信息 并为部署到 Moonbeam 网络的 ERC-20、ERC-721 和 ERC-1155 创建配置文件。该配置文件可以包括指向您的项目、社交媒体、价格数据以及与您的 Token 相关的其他信息的链接</li> </ul> <p></p>"}, {"location": "builders/get-started/explorers/#expedition", "title": "Expedition", "text": "<p>一个 Moonbeam 主题的 Expedition 浏览器可以在这个链接中找到。它是一个基于 JSON-RPC 的基本浏览器。</p> <p>默认情况下，该浏览器连接到 Moonbeam。但是，您可以切换到 Moonriver 或 Moonbase Alpha，或者按照以下步骤将其连接到本地开发节点：</p> <ol> <li>点击网络文本，您可以在其中选择所有不同的网络，包括在 <code>http://127.0.0.1:9944</code> 上运行的 Moonbeam Development Node</li> <li>如果您想连接到特定的 RPC URL，请选择 Add Custom Chain 并输入 URL。例如，<code>http://localhost:9937</code></li> </ol> <p></p>"}, {"location": "builders/get-started/explorers/#subscan", "title": "Subscan", "text": "<p>Subscan 是基于 Moonbeam 网络的 Substrate API 区块链浏览器。Subscan 能够解析标准或自定义模块。例如，这对于显示有关 Staking、Governance 和 EVM pallets（或模块）的信息非常有用。该代码是完全开源的，可以在 Subscan Essentials GitHub repo 中找到。</p> <p></p>"}, {"location": "builders/get-started/explorers/#polkadotjs", "title": "Polkadot.js", "text": "<p>虽然 Polkadot.js Apps 不是一个功能完善的区块浏览器，但它对于运行本地开发节点以查看事件和查询交易哈希的用户来说，是一个方便的选择。Polkadot.js Apps 使用 WebSocket 端点与网络进行交互。您可以轻松连接到 Moonbeam、Moonriver 或 Moonbase Alpha。</p> <p></p> <p>要将其连接到 Moonbeam 开发节点，您可以按照将 Polkadot.js Apps 连接到本地 Moonbeam 节点部分中的步骤进行操作，该部分位于Moonbeam 开发节点入门指南中。此处的默认端口是 <code>9944</code>。</p> <p></p>"}, {"location": "builders/get-started/quick-start/", "title": "在 Moonbeam 上开发的快速入门指南", "text": ""}, {"location": "builders/get-started/quick-start/#overview", "title": "快速概览", "text": "<p>Moonbeam 是一个在 Polkadot 上的完全兼容以太坊的智能合约平台。因此，您可以通过 Ethereum API 和 Substrate API 与 Moonbeam 进行交互。</p> <p>虽然 Moonbeam 是一个基于 Substrate 的平台，但它使用 统一账户 系统，该系统用以太坊样式的账户和密钥替换了 Substrate 样式的账户和密钥。因此，您可以通过简单地添加 Moonbeam 的网络配置，使用 MetaMask、Ledger 和其他兼容以太坊的钱包与您的 Moonbeam 帐户进行交互。同样，您可以使用以太坊 库 和 开发环境 在 Moonbeam 上进行开发。</p>"}, {"location": "builders/get-started/quick-start/#moonbeam-networks", "title": "Moonbeam 网络", "text": "<p>要开始在 Moonbeam 上进行开发，请务必了解 Moonbeam 生态系统中的各种网络。</p> 网络 网络类型 中继链 原生资产符号 原生资产小数位数 Moonbeam 主网 Polkadot GLMR 18 Moonriver 主网 Kusama MOVR 18 Moonbase Alpha 测试网 Alphanet 中继（基于 Westend） DEV 18 Moonbeam 开发节点 本地测试网 无 DEV 18 <p>Note</p> <p>Moonbeam 开发节点没有中继链，因为它的目的是您自己的个人开发环境，您可以在其中快速开始开发，而无需中继链的开销。</p>"}, {"location": "builders/get-started/quick-start/#network-configurations", "title": "网络配置", "text": "<p>当使用开发者工具时，根据工具的不同，您可能需要配置 Moonbeam 以与网络进行交互。为此，您可以使用以下信息：</p> <p>===</p> <pre><code>|    变量     |                                                 值                                                  |\n|:---------------:|:------------------------------------------------------------------------------------------------------:|\n|    链 ID     |                           &lt;pre&gt;```1284```&lt;/pre&gt;                            |\n| 公共 RPC URL | &lt;pre&gt;```https://rpc.api.moonbeam.network```&lt;/pre&gt;  &lt;pre&gt;```https://moonbeam.unitedbloc.com```&lt;/pre&gt; |\n| 公共 WSS URL |                           &lt;pre&gt;```wss://wss.api.moonbeam.network```&lt;/pre&gt;                           |\n</code></pre> <p>===</p> <pre><code>|    变量     |                                                  值                                                   |\n|:---------------:|:--------------------------------------------------------------------------------------------------------:|\n|    链 ID     |                            &lt;pre&gt;```1285```&lt;/pre&gt;                            |\n| 公共 RPC URL | &lt;pre&gt;```https://rpc.api.moonriver.moonbeam.network```&lt;/pre&gt;  &lt;pre&gt;```https://moonriver.unitedbloc.com```&lt;/pre&gt; |\n| 公共 WSS URL |                           &lt;pre&gt;```wss://wss.api.moonriver.moonbeam.network```&lt;/pre&gt;                            |\n</code></pre> <p>===</p> <pre><code>|    变量     |                                                    值                                                    |\n|:---------------:|:-----------------------------------------------------------------------------------------------------------:|\n|    链 ID     |                              &lt;pre&gt;```1287```&lt;/pre&gt;                              |\n| 公共 RPC URL | &lt;pre&gt;```https://rpc.api.moonbase.moonbeam.network```&lt;/pre&gt; |\n| 公共 WSS URL |  &lt;pre&gt;```wss://wss.api.moonbase.moonbeam.network```&lt;/pre&gt;  |\n</code></pre> <p>===</p> <pre><code>|   变量    |                        值                         |\n|:-------------:|:----------------------------------------------------:|\n|   链 ID    | &lt;pre&gt;```1281```&lt;/pre&gt; |\n| 本地 RPC URL | &lt;pre&gt;```http://127.0.0.1:9944```&lt;/pre&gt;  |\n| 本地 WSS URL | &lt;pre&gt;```ws://127.0.0.1:9944```&lt;/pre&gt;  |\n</code></pre> <p>Note</p> <p>您可以从支持的 RPC 提供商之一创建适合开发或生产的您自己的端点。</p>"}, {"location": "builders/get-started/quick-start/#explorers", "title": "区块浏览器", "text": "<p>Moonbeam 提供了两种不同的浏览器：一种用于查询以太坊 API，另一种专用于 Substrate API。所有基于 EVM 的交易都可以通过以太坊 API 访问，而 Substrate API 可以依赖于 Substrate 原生功能，例如治理、质押以及有关基于 EVM 的交易的一些信息。有关每个浏览器的更多信息，请查看区块浏览器页面。</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node Block Explorer Type URL Moonscan EVM https://moonbeam.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=Moonbeam Subscan Substrate https://moonbeam.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Moonscan EVM https://moonriver.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=Moonriver Subscan Substrate https://moonriver.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Moonscan EVM https://moonbase.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=MoonbaseAlpha Subscan Substrate https://moonbase.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Expedition EVM https://moonbeam-explorer.netlify.app/?network=MoonbeamDevNode Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer"}, {"location": "builders/get-started/quick-start/#testnet-tokens", "title": "为测试网账户充值", "text": "<p>要开始在其中一个测试网上进行开发，您需要使用 DEV 代币为您的账户充值才能发送交易。请注意，DEV 代币没有任何实际价值，仅用于测试目的。</p> 测试网 从哪里获取代币 Moonbase Alpha Moonbase Alpha 水龙头 网站。 该水龙头每 24 小时分配 1.1 DEV tokens Moonbeam 开发节点 任何十个预先注资的账户，这些账户都随您的  开发节点一起提供"}, {"location": "builders/get-started/quick-start/#development-tools", "title": "开发工具", "text": "<p>由于 Moonbeam 是一个基于 Substrate 的链，并且完全兼容以太坊，因此您可以使用基于 Substrate 的工具和基于以太坊的工具。</p>"}, {"location": "builders/get-started/quick-start/#javascript", "title": "JavaScript 工具", "text": "<p>===</p> <pre><code>|                                   工具                                    |      类型       |\n|:------------------------------------------------------------------------:|:---------------:|\n|   [Ethers.js](/builders/ethereum/libraries/ethersjs/){target=_blank}    |     库     |\n|      [Hardhat](/builders/ethereum/dev-env/hardhat/){target=_blank}      | 开发环境 |\n|        [Remix](/builders/ethereum/dev-env/remix/){target=_blank}        | 开发环境 |\n</code></pre> <p>===</p> <pre><code>|                                       工具                                         |  类型   |\n|:---------------------------------------------------------------------------------:|:-------:|\n| [Polkadot.js API](/builders/substrate/libraries/polkadot-js-api/){target=_blank} | 库 |\n</code></pre>"}, {"location": "builders/get-started/quick-start/#python", "title": "Python工具", "text": "EthereumSubstrate 工具 类型 Web3.py 库 工具 类型 Py Substrate Interface 库"}, {"location": "builders/get-started/token-profile/", "title": "在 Moonscan 上添加代币信息", "text": ""}, {"location": "builders/get-started/token-profile/#introduction", "title": "简介", "text": "<p>本教程将指导您完成将您的 ERC-20、ERC-721 或 ERC-1155 代币的个人资料添加到 Moonscan 的过程。</p> <p>​​Moonscan 是一个与 EVM 兼容的区块链浏览器和分析平台。它是 Moonbeam 和 Etherscan 的集成，它允许用户和开发人员访问开发工具和网络统计信息，这些信息提供了对 Moonriver 和 Moonbeam 的 EVM 的精细洞察。</p> <p>开发人员可以在 Moonriver 和 Moonbeam 上为他们的代币创建个人资料。该个人资料捕获有关代币背后的项目、社交媒体链接、价格数据链接以及与项目代币销售相关的其他基本信息。</p> <p></p> <p>本教程将向您展示如何在 Moonscan 上创建一个示例 ERC-20 代币（名为 DemoToken (DEMO)）的个人资料，该代币已部署到 Moonriver。这些说明可以适用于任何基于 Moonbeam 的网络，以及 ERC-721 或 ERC-1155 代币。</p>"}, {"location": "builders/get-started/token-profile/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要学习本教程，您需要具备以下条件：</p> <ul> <li>一个 Moonscan 帐户</li> </ul> <p>在本指南的后面，您需要验证代币合约地址的所有权。您可以手动或自动执行此操作，但如果您选择自动执行，您还需要以下内容：</p> <ul> <li>访问部署代币合约的帐户，以便您可以作为所有者签署消息</li> <li>MetaMask 已安装并连接到代币部署到的网络</li> </ul>"}, {"location": "builders/get-started/token-profile/#getting-started", "title": "入门", "text": "<p>首先，您需要确保已登录到您的 Moonscan 帐户。登录帐户后，您可以转到要为其添加配置文件的令牌的令牌页面。对于 ERC-20，您可以在搜索栏中搜索令牌的名称。或者，对于任何令牌，您可以手动输入 URL。</p> <p>===</p> <pre><code>text\nhttps://moonscan.io/token/INSERT_CONTRACT_ADDRESS\n</code></pre> <p>===</p> <pre><code>text\nhttps://moonriver.moonscan.io/token/INSERT_CONTRACT_ADDRESS\n</code></pre> <p>===</p> <pre><code>text\nhttps://moonbase.moonscan.io/token/INSERT_CONTRACT_ADDRESS\n</code></pre> <p>在“社交资料”旁边，您可以单击更新。</p> <p></p> <p>您将被转到令牌更新申请表。</p> <p>如果您尚未验证您的合约源代码，您需要先这样做，然后才能继续下一步。如果您已经验证了您的合约，您可以跳到 验证地址所有权 部分。</p>"}, {"location": "builders/get-started/token-profile/#verifying-contract-source-code", "title": "验证合约源代码", "text": "<p>您可以通过几种方式验证您的合约源代码。您可以直接从 Moonscan 验证，或者如果您使用 Hardhat 或 Foundry 开发合约，您也可以使用它们对应的 Etherscan 集成。</p> <p>要直接从 Moonscan 验证您的合约源代码，您可以点击工具链接。</p> <p></p> <p>您将被带到验证并发布合约源代码页面，您可以在其中输入有关合约及其编译方式的详细信息。</p> <ol> <li>输入代币合约地址</li> <li>从下拉列表中选择编译器类型</li> <li>选择您使用的编译版本</li> <li>然后选择一个开源许可证类型</li> <li>查看并点击我同意服务条款复选框</li> <li>点击继续</li> </ol> <p></p> <p>您将被带到下一页，您可以在其中输入合约源代码并指定使用的其他设置和参数。</p> <ol> <li>合约地址和编译器应已填写完毕。如果启用了优化，您可以更新优化下拉列表</li> <li>输入合约源代码的扁平化版本。要展平合约，您可以使用 Flattener Remix 插件</li> <li>如果需要，更新构造函数参数、合约库地址和其他设置部分</li> <li>点击我不是机器人</li> <li>最后，点击验证并发布</li> </ol> <p></p> <p>现在您的合约源代码已通过验证，您可以继续下一步，验证您是否是合约地址所有者。</p>"}, {"location": "builders/get-started/token-profile/#verifying-address-ownership", "title": "验证地址所有权", "text": "<p>在Token Update Application Form页面，您应该在屏幕顶部看到一条消息，指出您需要验证合约地址所有者。要开始此过程，您可以单击tool链接。</p> <p></p> <p>您将被带到Verify Address Ownership页面，您可以在该页面上手动签署消息以验证您的所有权，或者通过连接到Web3来验证。 如果您希望手动验证所有权，则需要消息签名哈希。 否则，如果您连接到Web3，系统将为您计算哈希值。</p> <p></p>"}, {"location": "builders/get-started/token-profile/#sign-message-manually", "title": "手动签署消息", "text": "<p>如果您希望手动验证所有权，您需要消息签名哈希。如果您已经自己计算了哈希值，您可以点击手动签署消息，输入消息签名哈希，然后点击验证所有权。</p> <p></p>"}, {"location": "builders/get-started/token-profile/#connect-to-web3", "title": "连接到 Web3", "text": "<p>您可以使用 MetaMask 轻松计算消息签名哈希。您需要将部署合约的帐户加载到 MetaMask 中。然后，您可以单击连接到 Web3，MetaMask 将会弹出。</p> <ol> <li>选择要连接的帐户，该帐户应该是您用于部署合约的帐户</li> <li>连接到该帐户</li> </ol> <p></p> <p>返回到验证地址所有权页面，您可以采取以下步骤</p> <ol> <li>单击使用 Web3 签名</li> <li>MetaMask 将会弹出，您可以签名消息</li> </ol> <p></p> <p>签署消息后，您可以单击单击以继续。现在您应该看到消息签名哈希已自动为您填充。您只需单击验证所有权。</p> <p></p>"}, {"location": "builders/get-started/token-profile/#creating-the-profile", "title": "创建配置文件", "text": "<p>现在您可以开始填写必要的信息来构建代币配置文件，包括项目信息、社交媒体链接、价格数据链接等等。您应确保提供的所有链接在提交前均可正常访问且安全。</p> <p>您至少需要填写以下信息：</p> <ul> <li>请求类型</li> <li>代币合约地址</li> <li>请求者姓名</li> <li>请求者电子邮件地址</li> <li>官方项目网站</li> <li>官方项目电子邮件地址</li> <li>下载 32x32 png 图标徽标的链接</li> <li>项目描述</li> </ul> <p>所有其他字段都是可选的。填写完信息后，您可以点击页面底部的“提交”。</p> <p></p> <p>就这样！您已成功在 Moonscan 上创建并提交了代币的配置文件！Moonscan 团队将尽快审核您的提交，并在需要时为您提供进一步的说明。</p>"}, {"location": "builders/get-started/networks/moonbase/", "title": "Moonbase Alpha 入门指南", "text": ""}, {"location": "builders/get-started/networks/moonbase/#_1", "title": "区块浏览器", "text": "<p>对于 Moonbase Alpha，您可以使用以下任一区块浏览器：</p> <ul> <li>以太坊 API（Etherscan 等效）— Moonscan</li> <li>基于以太坊 API JSON-RPC — Moonbeam Basic Explorer</li> <li>Substrate API — Subscan 或 Polkadot.js Apps</li> </ul> <p>有关每个可用区块浏览器的更多信息，请访问文档的 区块浏览器 部分。</p>"}, {"location": "builders/get-started/networks/moonbase/#metamask", "title": "连接 MetaMask", "text": "<p>如果您已经安装了 MetaMask，您可以轻松地将 MetaMask 连接到 Moonbase Alpha 测试网：</p> Connect MetaMask <p>Note</p> <p>MetaMask 将弹出窗口，请求您授予权限以将 Moonbase Alpha 添加为自定义网络。批准权限后，MetaMask 会将您当前的网路切换到 Moonbase Alpha。</p> <p>如果您没有安装 MetaMask，或者想要按照教程开始操作，请查看使用 MetaMask 与 Moonbeam 交互 指南。</p>"}, {"location": "builders/get-started/networks/moonbase/#configuration", "title": "配置", "text": "<p>请注意以下 gas 配置参数。这些值可能会在将来的运行时升级中发生更改。</p> 变量 值 最低 gas 价格 0.03125 Gwei 目标区块时间 6 秒 区块 gas 限制 60,000,000 交易 gas 限制 52,000,000"}, {"location": "builders/get-started/networks/moonbase/#get-tokens", "title": "获取代币", "text": "<p>要开始在 Moonbase Alpha 上进行构建，您可以从 Moonbase Alpha 水龙头获取 DEV 代币。对于特定数额，您可以随时通过我们的社区渠道直接与我们联系。</p> <p>要从水龙头请求 DEV 代币，您可以在 Moonbase Alpha 水龙头 网站上输入您的地址。水龙头每 24 小时分配 1.1 DEV tokens。</p> <p></p> <p>Note</p> <p>Moonbase Alpha DEV 代币没有价值。请勿通过不必要的请求向水龙头发送垃圾邮件。</p>"}, {"location": "builders/get-started/networks/moonbase/#Demo-DApps", "title": "Demo DApps", "text": "<p>Moonbase Alpha 上部署了各种 DApp，使您可以试验各种应用程序和集成。您还可以通过 Moonbase ERC20 Minter 或 Moonbeam Uniswap DApp 获取各种测试代币。例如，Moonbeam Uniswap 可以帮助您获取 cross-chain 资产，例如 xcUNIT 或 xcKarura，以测试与 XCM 相关的函数。在下表中，您将找到每个示例 DApp、其关联的 URL 和 GitHub 存储库。</p>"}, {"location": "builders/get-started/networks/moonbase/#quick-links", "title": "快速链接", "text": "DApp 描述 存储库 Moonbase ERC-20 Minter ERC-20 水龙头 https://github.com/papermoonio/moonbase-mintableERC20 Moonbeam Uniswap Uniswap V2 分叉 https://github.com/papermoonio/moonbeam-uniswap <p>|        MoonLotto Lottery        |   TheGraph 演示    | 接口, 子图 | | Moonbeam WalletConnect | WalletConnect 演示 |            https://github.com/papermoonio/moonbeam-walletconnect-demo             | |              MoonGas              | Gas 价格追踪器  |                    https://github.com/albertov19/moonbeam-gas-station                     |</p> <p>Note</p> <p>这些 DApp 仅用于演示目的，可能不完整或不适合生产部署。</p>"}, {"location": "builders/get-started/networks/moonbase/#moonbase-erc20-minter", "title": "Moonbase ERC20 铸币器", "text": "<p>Moonbase ERC-20 铸币器 使您能够铸造各种 ERC-20 测试代币，这些代币分别对应太阳系的 8 个行星和冥王星。要铸造代币，首先按右上角的 Connect MetaMask。然后滚动到 Mint Tokens 部分，然后选择所需的 ERC-20 合约。按 Submit Tx 并在 MetaMask 中确认交易。每次铸造将授予您 100 个代币，并且您每小时可以为每个合约铸造一次代币。</p> <p></p>"}, {"location": "builders/get-started/networks/moonbase/#moonbeam-uniswap", "title": "Moonbeam Uniswap", "text": "<p>Moonbeam Uniswap 是部署到 Moonbase Alpha 的 Uniswap-V2 的一个分支。值得注意的是，Moonbeam Uniswap 允许开发人员轻松进行交易，以获取 跨链资产，例如用于 XCM 测试的 xcKarura 或 xcUNIT。要执行您的第一笔交易，请执行以下步骤：</p> <ol> <li>按下 选择代币</li> <li>连接您的 MetaMask 钱包并确保您在 Moonbase Alpha 网络上</li> <li>在提示中按下 选择列表</li> <li>选择 Moon 菜单</li> <li>从列表中搜索或选择您想要的资产，然后继续进行交易</li> </ol> <p></p> <p>Note</p> <p>如果您在 Moon 菜单 下仅看到部分资产列表，则您的浏览器可能已缓存旧版本的 Moon 菜单。清除缓存并重新添加 Moon 菜单 即可解决此问题。</p>"}, {"location": "builders/get-started/networks/moonbase/#moonlotto-lottery", "title": "MoonLotto 彩票", "text": "<p>MoonLotto 是 Moonbase Alpha 上的一个简单的彩票游戏，源自 The Graph 的示例子图。购买彩票需要 1 DEV，如果至少有 10 名参与者，则每半小时选出一名获胜者。MoonLotto.sol 包含了彩票的合约逻辑。要参与，请按照以下步骤操作：</p> <ol> <li>连接您的 MetaMask 钱包，并确保您在 Moonbase Alpha 网络上</li> <li>输入彩票接收者的地址或选中我想为我的地址购买彩票</li> <li>按下在 MetaMask 上提交并在 MetaMask 中确认交易</li> </ol> <p></p>"}, {"location": "builders/get-started/networks/moonbase/#moonbeam-walletconnect", "title": "Moonbeam WalletConnect", "text": "<p>Moonbeam WalletConnect 展示了将 WalletConnect 集成到您的 DApps 中并解锁对各种加密钱包的支持是多么容易。请务必查看 演示应用程序存储库，以了解 WalletConnect 集成是如何工作的。要开始使用，您可以按照以下步骤操作：</p> <ol> <li>按 Connect Wallet（连接钱包）</li> <li>使用 与 WalletConnect 兼容的钱包 扫描二维码</li> </ol> <p></p>"}, {"location": "builders/get-started/networks/moonbase/#moongas", "title": "MoonGas", "text": "<p>MoonGas 是一个方便的仪表板，用于查看所有 Moonbeam 网络中前一个区块的交易的最低、最高和平均 Gas 价格。请注意，这些统计数据可能会因区块而异，偶尔会包含异常值。您可以查看 MoonGas 的存储库。</p> <p>您会注意到 Moonbeam 的最低 Gas 价格是 31.25 Gwei，而 Moonriver 的最低 Gas 价格是 0.3125 Gwei，Moonbase Alpha 的最低 Gas 价格是 0.03125 Gwei。这种差异源于 GLMR 的 100 比 1 重新计价，因此 Moonbeam 上的 31.25 Gwei 最低值对应于 Moonriver 上的 0.3125 Gwei 最低值和 Moonbase 上的 0.03125 Gwei。</p> <p></p>"}, {"location": "builders/get-started/networks/moonbeam-dev/", "title": "Moonbeam本地开发节点入门", "text": ""}, {"location": "builders/get-started/networks/moonbeam-dev/#introduction", "title": "简介", "text": "<p>Moonbeam 开发节点是您自己的个人开发环境，用于在 Moonbeam 上构建和测试应用程序。对于以太坊开发人员来说，它与 Hardhat 网络类似。它使您能够快速轻松地开始，而无需中继链的开销。您可以使用 <code>--sealing</code> 选项启动节点，以便在收到交易后立即、手动或以自定义间隔创建区块。默认情况下，当收到交易时，将创建一个区块，这类似于 Hardhat 网络 instamine 功能的默认行为。</p> <p>如果您按照本指南操作到最后，您将拥有一个 Moonbeam 开发节点在您的本地环境中运行，其中包含 10 个预先资助的 帐户。</p> <p>Note</p> <p>本教程是使用 [Moonbase Alpha](https://github.com/moonbeam-foundation/moonbeam/releases/tag/v0.49.2){target=_blank} 的 v0.49.2 标签创建的。Moonbeam 平台及其依赖的 Frontier 组件来实现基于 Substrate 的以太坊兼容性，目前仍在非常积极的开发中。</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"}, {"location": "builders/get-started/networks/moonbeam-dev/#spin-up-a-node", "title": "启动 Moonbeam 开发节点", "text": "<p>有两种方法可以开始运行 Moonbeam 节点。您可以使用 Docker 运行预构建的二进制文件，也可以在本地编译二进制文件 并自己设置开发节点。使用 Docker 是一种快速便捷的入门方式，因为您无需安装 Substrate 和所有依赖项，也可以跳过节点构建过程。它确实要求您安装 Docker。另一方面，如果您决定完成构建开发节点的过程，则可能需要大约 30 分钟或更长时间才能完成，具体取决于您的硬件。</p>"}, {"location": "builders/get-started/networks/moonbeam-dev/#getting-started-with-docker", "title": "使用 Docker 启动节点", "text": "<p>使用 Docker 可以在几秒钟内启动一个节点。安装 Docker 后，您可以按照以下步骤启动您的节点：</p> <ol> <li> <p>执行以下命令来下载最新的 Moonbeam 镜像：</p> <pre><code>docker pull moonbeamfoundation/moonbeam:v0.49.2\n</code></pre> <p>控制台日志的尾部应如下所示：</p> <p> docker pull moonbeamfoundation/moonbeam:v0.49.2 v0.49.2: Pulling from moonbeamfoundation/moonbeam      b0a0cf830b12: Pull complete      fbff687640dd: Pull complete      58ea427410e2: Pull complete      811ba55e6e61: Pull complete      4316d5f1b914: Pull complete      128693ce218e: Pull complete      a3ac90b88463: Pull complete      Digest: sha256:86421aca2381265cd2e5283cb98705e24be0bc92a73937363f79d9d6e0d62088      Status: Downloaded newer image for moonbeamfoundation/moonbeam:v0.49.2      docker.io/moonbeamfoundation/moonbeam:v0.49.2    </p> </li> <li> <p>运行以下 Docker 命令启动 Moonbeam 开发节点，该命令将以即时密封模式启动节点以进行本地测试，以便在收到交易时立即生成区块：</p> Ubuntu <pre><code>docker run --rm --name moonbeam_development --network host \\\n  moonbeamfoundation/moonbeam:v0.49.2 \\\n  --dev --rpc-external\n</code></pre> MacOS <pre><code>docker run --rm --name moonbeam_development -p 9944:9944 \\\n  moonbeamfoundation/moonbeam:v0.49.2 \\\n  --dev --rpc-external\n</code></pre> Windows <pre><code>docker run --rm --name moonbeam_development -p 9944:9944 ^\n  moonbeamfoundation/moonbeam:v0.49.2 ^\n  --dev --rpc-external\n</code></pre> <p>适用于 Apple Silicon 用户</p> <p>如果 Docker 命令在 Apple Silicon 上失败或行为异常，请在 Docker Desktop 设置中启用 Use Rosetta for x86_64/amd64 emulation on Apple Silicon，并对 pull 和 run 命令使用 <code>amd64</code> 平台：</p> <pre><code>docker pull --platform=linux/amd64 moonbeamfoundation/moonbeam:v0.49.2\n</code></pre> <pre><code>docker run --rm --platform=linux/amd64 --name moonbeam_development -p 9944:9944 \\\n  moonbeamfoundation/moonbeam:v0.49.2 \\\n  --dev --rpc-external\n</code></pre> <p>如果性能仍然不足，请考虑使用二进制文件启动节点。</p> </li> </ol> <p>如果成功，您应该看到一个输出，显示一个空闲状态，等待区块被生成：</p> docker run --rm --name moonbeam_development --network host \\      moonbeamfoundation/moonbeam:v0.49.2 \\      --dev --rpc-external    CLI parameter `--execution` has no effect anymore and will be removed in the future!      2025-07-10 09:04:26 Moonbeam Parachain Collator      2025-07-10 09:04:26 ✌️  version 0.49.2      2025-07-10 09:04:26 ❤️  by PureStake, 2019-2025      2025-07-10 09:04:26 📋 Chain specification: Moonbase Development Testnet      2025-07-10 09:04:26 🏷  Node name: black-and-white-sticks-9174      2025-07-10 09:04:26 👤 Role: AUTHORITY      2025-07-10 09:04:26 💾 Database: RocksDb at /tmp/substrateO3YeRz/chains/moonbase_dev/db/full      2025-07-10 09:04:26 🔨 Initializing Genesis block/state (state: 0xf7c4…5c0f, header-hash: 0x42bd…3b5b)      2025-07-10 09:04:26 Using default protocol ID \"sup\" because none is configured in the chain specs      2025-07-10 09:04:26 🏷  Local node identity is: 12D3KooWLcpczme2JeBEfLqmjqkzYVKTGKhhGmwSzHjRXGBVhDX7      2025-07-10 09:04:26 💻 Operating system: linux      2025-07-10 09:04:26 💻 CPU architecture: x86_64      2025-07-10 09:04:26 💻 Target environment: gnu      2025-07-10 09:04:26 💻 CPU: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz      2025-07-10 09:04:26 💻 CPU cores: 12      2025-07-10 09:04:26 💻 Memory: 7946MB      2025-07-10 09:04:26 💻 Kernel: 6.4.16-linuxkit      2025-07-10 09:04:26 💻 Linux distribution: Debian GNU/Linux 12 (bookworm)      2025-07-10 09:04:26 💻 Virtual machine: yes      2025-07-10 09:04:26 📦 Highest known block at #0      2025-07-10 09:04:26 Running JSON-RPC server: addr=0.0.0.0:9944, allowed origins=[\"*\"]      2025-07-10 09:04:26 🏁 CPU score: 1.14 GiBs      2025-07-10 09:04:26 〽️ Prometheus exporter started at 127.0.0.1:9615      2025-07-10 09:04:26 🏁 Memory score: 10.41 GiBs      2025-07-10 09:04:26 🏁 Disk score (seq. writes): 987.96 MiBs      2025-07-10 09:04:26 🏁 Disk score (rand. writes): 363.65 MiBs      2025-07-10 09:04:26 Development Service Ready      2025-07-10 09:04:26 💤 Idle (0 peers), best: #0 (0xa083…f354), finalized #0 (0xa083…f354), ⬇ 0 ⬆ 0      2025-07-10 09:04:26 💤 Idle (0 peers), best: #0 (0xa083…f354), finalized #0 (0xa083…f354), ⬇ 0 ⬆ 0    <p>有关示例中使用的一些标志和选项的更多信息，请查看 Flags 和 Options。如果您想查看所有标志、选项和子命令的完整列表，请运行以下命令打开帮助菜单：</p> <pre><code>docker run --rm --name moonbeam_development \\\n  moonbeamfoundation/moonbeam \\\n  --help\n</code></pre> <p>要继续本教程，下一节不是必需的，因为您已经使用 Docker 启动了一个节点。您可以跳到 配置您的 Moonbeam 开发节点 部分。</p>"}, {"location": "builders/get-started/networks/moonbeam-dev/#getting-started-with-the-binary-file", "title": "使用二进制文件启动节点", "text": "<p>除了使用 Docker 之外，您还可以使用 Moonbeam 二进制文件启动节点。此方法更耗时。根据您的硬件，此过程可能需要大约 30 分钟才能完成。</p> <p>Note</p> <p>如果您知道自己在做什么，您可以直接从 Moonbeam 发布页面 下载附加到每个版本的预编译二进制文件。这些不适用于所有系统。例如，这些二进制文件仅适用于具有特定依赖项版本的 x86-64 Linux。确保兼容性的最安全方法是在将要运行它的系统上编译二进制文件。</p> <p>要构建二进制文件，您可以采取以下步骤：</p> <ol> <li> <p>克隆 Moonbeam 仓库的特定标签，您可以在 Moonbeam GitHub 仓库 上找到它：</p> <pre><code>git clone -b v0.49.2 https://github.com/moonbeam-foundation/moonbeam\ncd moonbeam\n</code></pre> <p>Note</p> <p>安装文件路径中的空格会导致编译错误。</p> </li> <li> <p>检查是否已安装 Rust。如果已安装 Rust，请跳过接下来的两个步骤。否则，通过执行 Rust 推荐的方法 安装 Rust 及其先决条件：</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> </li> <li> <p>通过运行以下命令更新您的 PATH 环境变量：</p> <pre><code>source $HOME/.cargo/env\n</code></pre> </li> <li> <p>通过运行以下命令构建开发节点：</p> <p>Note</p> <p>如果您使用的是 Ubuntu 20.04 或 22.04，那么您需要确保在构建二进制文件之前安装了这些额外的依赖项：</p> <pre><code>apt install clang protobuf-compiler libprotobuf-dev pkg-config libssl-dev -y\n</code></pre> <p>对于 MacOS 用户，可以通过 Homebrew 安装这些依赖项：</p> <pre><code>brew install llvm\nbrew install protobuf\n</code></pre> <pre><code>cargo build --release\n</code></pre> <p>以下是构建输出的尾部应显示的内容：</p> <p> Compiling try-runtime-cli v0.9.0 (https://github.com/paritytech/substrate?branch=rococo-v1#401c24e8)      Compiling frame-benchmarking-cli v3.0.0 (https://github.com/paritytech/substrate?branch=rococo-v1#401c24e8)      Compiling cumulus-client-cli v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Compiling moonbeam-rpc-txpool v0.6.0 (/home/purestake/moonbeam/client/rpc/txpool)      Compiling moonbeam-rpc-debug v0.1.0 (/home/purestake/moonbeam/client/rpc/debug)      Compiling moonbeam-rpc-trace v0.6.0 (/home/purestake/moonbeam/client/rpc/trace)      Compiling cumulus-client-network v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Compiling cumulus-client-consensus-relay-chain v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Compiling polkadot-test-service v0.8.29 (https://github.com/paritytech/polkadot?branch=rococo-v1#b64741e6)      Compiling cumulus-client-collator v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Compiling cumulus-client-service v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Finished release [optimized] target(s) in 31m 17s    </p> </li> </ol> <p>Note</p> <p>初始构建需要一段时间。根据您的硬件，您应该预计构建过程大约需要 30 分钟才能完成。</p> <p>然后，您将希望使用以下命令在开发模式下运行节点：</p> <pre><code>./target/release/moonbeam --dev\n</code></pre> <p>Note</p> <p>对于不熟悉 Substrate 的人来说，<code>--dev</code> 标志是一种在单节点开发者配置中运行基于 Substrate 的节点以进行测试的方式。当您使用 <code>--dev</code> 标志运行节点时，您的节点会在全新状态下启动，并且其状态不会持久存在。</p> <p>您应该会看到如下所示的输出，显示一个空闲状态，等待生成区块：</p> ./target/release/moonbeam --dev  2025-07-10 09:04:26 Moonbeam Parachain Collator      2025-07-10 09:04:26 ✌️  version 0.49.2      2025-07-10 09:04:26 ❤️  by PureStake, 2019-2025      2025-07-10 09:04:26 📋 Chain specification: Moonbase Development Testnet      2025-07-10 09:04:26 🏷  Node name: black-and-white-sticks-9174      2025-07-10 09:04:26 👤 Role: AUTHORITY      2025-07-10 09:04:26 💾 Database: RocksDb at /tmp/substrateO3YeRz/chains/moonbase_dev/db/full      2025-07-10 09:04:26 🔨 Initializing Genesis block/state (state: 0x7c34…99c5, header-hash: 0xa083…f354)      2025-07-10 09:04:26 Using default protocol ID \"sup\" because none is configured in the chain specs      2025-07-10 09:04:26 🏷  Local node identity is: 12D3KooWLcpczme2JeBEfLqmjqkzYVKTGKhhGmwSzHjRXGBVhDX7      2025-07-10 09:04:26 💻 Operating system: linux      2025-07-10 09:04:26 💻 CPU architecture: x86_64      2025-07-10 09:04:26 💻 Target environment: gnu      2025-07-10 09:04:26 💻 CPU: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz      2025-07-10 09:04:26 💻 CPU cores: 12      2025-07-10 09:04:26 💻 Memory: 7946MB      2025-07-10 09:04:26 💻 Kernel: 6.4.16-linuxkit      2025-07-10 09:04:26 💻 Linux distribution: Debian GNU/Linux 12 (bookworm)      2025-07-10 09:04:26 💻 Virtual machine: yes      2025-07-10 09:04:26 📦 Highest known block at #0      2025-07-10 09:04:26 Running JSON-RPC server: addr=0.0.0.0:9944, allowed origins=[\"*\"]      2025-07-10 09:04:26 🏁 CPU score: 1.14 GiBs      2025-07-10 09:04:26 〽️ Prometheus exporter started at 127.0.0.1:9615      2025-07-10 09:04:26 🏁 Memory score: 10.41 GiBs      2025-07-10 09:04:26 🏁 Disk score (seq. writes): 987.96 MiBs      2025-07-10 09:04:26 🏁 Disk score (rand. writes): 363.65 MiBs      2025-07-10 09:04:26 Development Service Ready      2025-07-10 09:04:26 💤 Idle (0 peers), best: #0 (0xa083…f354), finalized #0 (0xa083…f354), ⬇ 0 ⬆ 0      2025-07-10 09:04:26 💤 Idle (0 peers), best: #0 (0xa083…f354), finalized #0 (0xa083…f354), ⬇ 0 ⬆ 0    <p>有关示例中使用的一些标志和选项的更多信息，请查看 标志 和 选项。如果您想查看所有标志、选项和子命令的完整列表，请通过运行以下命令打开帮助菜单：</p> <pre><code>./target/release/moonbeam --help\n</code></pre>"}, {"location": "builders/get-started/networks/moonbeam-dev/#configure-moonbeam-dev-node", "title": "配置您的 Moonbeam 开发节点", "text": "<p>既然您已经知道如何启动并运行标准的 Moonbeam 开发节点，您可能想知道如何配置它。以下部分将介绍您启动节点时可以使用的常见配置。</p>"}, {"location": "builders/get-started/networks/moonbeam-dev/#node-flags", "title": "配置节点的常用标志", "text": "<p>标志不接受参数。要使用标志，请将其添加到命令的末尾。例如：</p> <pre><code>./target/release/moonbeam --dev\n</code></pre> <ul> <li><code>--dev</code> - 指定开发链</li> <li><code>--tmp</code> - 运行一个临时节点，在该节点中，所有配置将在进程结束时删除</li> <li><code>--rpc-external</code> - 侦听所有 RPC 和 WebSocket 接口</li> </ul>"}, {"location": "builders/get-started/networks/moonbeam-dev/#node-options", "title": "配置节点的常用选项", "text": "<p>选项接受选项右侧的参数。例如：</p> <pre><code>./target/release/moonbeam --dev --sealing 6000\n</code></pre> <ul> <li><code>-l &lt;log pattern&gt;</code> 或 <code>--log &lt;log pattern&gt;</code> - 设置自定义日志过滤器。日志模式的语法是 <code>&lt;target&gt;=&lt;level&gt;</code>。例如，要打印所有的 JSON-RPC 日志，命令如下所示：<code>-l json=trace</code></li> <li><code>--sealing &lt;interval&gt;</code> - 块在开发服务中应该被密封的时间。interval 接受的参数：<code>instant</code>、<code>manual</code> 或表示定时器间隔的毫秒数（例如，<code>6000</code> 将使节点每 6 秒生成一次块）。默认值为 <code>instant</code>。有关更多信息，请参阅下面的 配置区块生产 部分</li> <li><code>--rpc-port &lt;port&gt;</code> - 设置 HTTP 和 WS 连接的统一端口。接受一个端口作为参数。默认为 9944</li> <li><code>--ws-port &lt;port&gt;</code> - 自 client v0.33.0 起已弃用，请改用 <code>--rpc-port</code> 进行 HTTP 和 WS 连接 - 设置 WebSockets RPC 服务器 TCP 端口。从 client v0.30.0 开始，它为 HTTP 和 WS 连接设置统一端口。接受一个端口作为参数</li> <li><code>--rpc-max-connections &lt;connections&gt;</code> - 指定组合的 HTTP 和 WS 连接限制。默认为 100 个连接</li> <li><code>--ws-max-connections &lt;connections&gt;</code> - 自 client v0.33.0 起已弃用，请改用 <code>--rpc-max-connections</code> 限制 HTTP 和 WS 连接 - 此标志调整组合的 HTTP 和 WS 连接限制。默认为 100 个连接</li> <li><code>--rpc-cors &lt;origins&gt;</code> - 指定允许访问 HTTP 和 WS RPC 服务器的浏览器来源。来源可以是允许访问的来源的逗号分隔列表，或者您也可以指定 <code>null</code>。当运行开发节点时，默认是允许所有来源</li> </ul> <p>有关标志和选项的完整列表，请启动您的 Moonbeam 开发节点，并在命令末尾添加 <code>--help</code>。</p>"}, {"location": "builders/get-started/networks/moonbeam-dev/#configure-block-production", "title": "配置区块生产", "text": "<p>默认情况下，您的 Moonbeam 开发节点以即时密封模式启动，即在收到交易后立即生成区块。但是，您可以使用 <code>--sealing</code> 选项指定何时生成或密封区块。</p> <p><code>--sealing</code> 标志接受以下任何参数：</p> <ul> <li><code>instant</code> - 正如我们已经介绍过的，这是默认选项，即在收到交易后立即生成区块</li> <li><code>manual</code> - 允许您手动生成区块。如果收到交易，则在您手动创建一个区块之前，不会生成区块</li> <li>毫秒为单位的时间间隔 - 以特定的时间间隔生成区块。例如，如果您将其设置为 <code>6000</code>，则节点将每 6 秒生成一个区块</li> </ul> <p>该标志应以下列格式附加到启动命令：</p> <pre><code>--sealing &lt;interval&gt;\n</code></pre> <p>如果您选择 <code>manual</code>，则需要手动创建区块，这可以通过 <code>engine_createBlock</code> JSON-RPC 方法来完成：</p> <pre><code>engine_createBlock(createEmpty: *bool*, finalize: *bool*, parentHash?: *BlockHash*)\n</code></pre> <p>例如，您可以使用以下代码段通过 Ethers.js 手动创建一个区块，这是一个以太坊库，可以轻松地与 JSON-RPC 方法进行交互：</p> <pre><code>import { ethers } from 'ethers';\n\nconst produceBlock = async () =&gt; {\n  // Connect to the Ethereum node (if applicable, replace the URL with your node's address)\n  const provider = new ethers.JsonRpcProvider('http://127.0.0.1:9944');\n\n  // Set the custom JSON-RPC method and parameters\n  const method = 'engine_createBlock';\n  const params = [true, true, null];\n\n  try {\n    // Send the custom JSON-RPC call\n    const result = await provider.send(method, params);\n    console.log(result);\n  } catch (error) {\n    // Handle any errors that may occur\n    console.error('Error:', error.message);\n  }\n};\n\nproduceBlock();\n</code></pre> <p>Note</p> <p>如果您不熟悉 Ethers，请参阅 Ethers.js 文档页面以了解更多信息。</p>"}, {"location": "builders/get-started/networks/moonbeam-dev/#pre-funded-development-accounts", "title": "预充值开发账户", "text": "<p>Moonbeam 有一个统一账户系统，使用户能够拥有一个以太坊风格的 H160 账户，该账户可以与 Substrate API 和以太坊 API 交互。因此，您可以通过 Polkadot.js Apps 或 MetaMask（或任何其他 EVM 钱包）与您的账户进行交互。此外，您还可以使用其他开发工具，例如 Remix 和 Hardhat。</p> <p>您的 Moonbeam 开发节点附带十个已预先充值的以太坊风格的帐户，用于开发。这些地址源自 Substrate 的规范开发助记词：</p> <pre><code>bottom drive obey lake curtain smoke basket hold race lonely fit walk\n</code></pre> 开发账户地址和私钥 <ul> <li> <p>Alith:</p> <ul> <li>Public Address: <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>Private Key: <code>0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133</code></li> </ul> </li> <li> <p>Baltathar:</p> <ul> <li>Public Address: <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>Private Key: <code>0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b</code></li> </ul> </li> <li> <p>Charleth:</p> <ul> <li>Public Address: <code>0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</code></li> <li>Private Key: <code>0x0b6e18cafb6ed99687ec547bd28139cafdd2bffe70e6b688025de6b445aa5c5b</code></li> </ul> </li> <li> <p>Dorothy:</p> <ul> <li>Public Address: <code>0x773539d4Ac0e786233D90A233654ccEE26a613D9</code></li> <li>Private Key: <code>0x39539ab1876910bbf3a223d84a29e28f1cb4e2e456503e7e91ed39b2e7223d68</code></li> </ul> </li> <li> <p>Ethan:</p> <ul> <li>Public Address: <code>0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB</code></li> <li>Private Key: <code>0x7dce9bc8babb68fec1409be38c8e1a52650206a7ed90ff956ae8a6d15eeaaef4</code></li> </ul> </li> <li> <p>Faith:</p> <ul> <li>Public Address: <code>0xC0F0f4ab324C46e55D02D0033343B4Be8A55532d</code></li> <li>Private Key: <code>0xb9d2ea9a615f3165812e8d44de0d24da9bbd164b65c4f0573e1ce2c8dbd9c8df</code></li> </ul> </li> <li> <p>Goliath:</p> <ul> <li>Public Address: <code>0x7BF369283338E12C90514468aa3868A551AB2929</code></li> <li>Private Key: <code>0x96b8a38e12e1a31dee1eab2fffdf9d9990045f5b37e44d8cc27766ef294acf18</code></li> </ul> </li> <li> <p>Heath: </p> <ul> <li>Public Address: <code>0x931f3600a299fd9B24cEfB3BfF79388D19804BeA</code></li> <li>Private Key: <code>0x0d6dcaaef49272a5411896be8ad16c01c35d6f8c18873387b71fbc734759b0ab</code></li> </ul> </li> <li> <p>Ida: </p> <ul> <li>Public Address: <code>0xC41C5F1123ECCd5ce233578B2e7ebd5693869d73</code></li> <li>Private Key: <code>0x4c42532034540267bf568198ccec4cb822a025da542861fcb146a5fab6433ff8</code></li> </ul> </li> <li> <p>Judith: </p> <ul> <li>Public Address: <code>0x2898FE7a42Be376C8BC7AF536A940F7Fd5aDd423</code></li> <li>Private Key: <code>0x94c49300a58d576011096bcb006aa06f5a91b34b4383891e8029c21dc39fbb8b</code></li> </ul> </li> </ul> <p>开发节点还包含一个用于测试目的的额外预充值帐户：</p> <ul> <li>Gerald:<ul> <li>Public Address: <code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code></li> <li>Private Key: <code>0x99b3c12287537e38c90a9219d4cb074a89a16e9cdb20bf85728ebd97c343e342</code></li> </ul> </li> </ul> <p>您可以使用这些账户的私钥将它们连接到 MetaMask、Talisman、Polkadot.js Apps 等。</p>"}, {"location": "builders/get-started/networks/moonbeam-dev/#access-your-development-node", "title": "开发节点端点", "text": "<p>您可以使用以下 RPC 和 WSS 端点访问您的 Moonbeam 开发节点：</p> HTTPWSS <pre><code>http://127.0.0.1:9944\n</code></pre> <pre><code>ws://127.0.0.1:9944\n</code></pre>"}, {"location": "builders/get-started/networks/moonbeam-dev/#block-explorers", "title": "区块浏览器", "text": "<p>对于 Moonbeam 开发节点，您可以使用以下任何一个区块浏览器：</p> <ul> <li>Substrate API — Polkadot.js Apps，位于 WS 端口 <code>9944</code> 上</li> <li>基于 Ethereum API JSON-RPC — Moonbeam Basic Explorer，位于 HTTP 端口 <code>9944</code> 上</li> </ul>"}, {"location": "builders/get-started/networks/moonbeam-dev/#debug-trace-txpool-apis", "title": "Debug, Trace, 和 TxPool APIs", "text": "<p>您还可以通过运行跟踪节点来访问一些非标准的 RPC 方法，这允许开发人员在运行时检查和调试交易。跟踪节点使用与标准 Moonbeam 开发节点不同的 Docker 镜像。</p> <p>要了解如何运行 Moonbeam 开发跟踪节点，请查看运行跟踪节点指南，并确保在整个说明中切换到 Moonbeam 开发节点选项卡。然后，要使用跟踪节点访问非标准 RPC 方法，请查看Debug &amp; Trace指南。</p>"}, {"location": "builders/get-started/networks/moonbeam-dev/#purging-your-node", "title": "清理开发节点", "text": "<p>如果您想删除与您的节点相关联的数据，您可以清理它。清理节点的说明取决于您最初启动节点的方式。</p>"}, {"location": "builders/get-started/networks/moonbeam/", "title": "Moonbeam入门", "text": ""}, {"location": "builders/get-started/networks/moonbeam/#block-explorers", "title": "区块浏览器", "text": "<p>对于 Moonbeam，您可以使用以下任何区块浏览器：</p> <ul> <li>以太坊 API（Etherscan 等效） — Moonscan</li> <li>基于以太坊 API JSON-RPC — Moonbeam Basic Explorer</li> <li>Substrate API — Subscan 或 Polkadot.js Apps</li> </ul> <p>有关每个可用区块浏览器的更多信息，请访问文档的 区块浏览器 部分。</p>"}, {"location": "builders/get-started/networks/moonbeam/#connect-metamask", "title": "连接 MetaMask", "text": "<p>如果您已经安装了 MetaMask，您可以轻松地将 MetaMask 连接到 Moonbeam：</p> Connect MetaMask <p>Note</p> <p>MetaMask 将弹出窗口，请求允许将 Moonbeam 添加为自定义网络。一旦您批准权限，MetaMask 会将您当前的 网络切换到 Moonbeam。</p> <p>如果您没有安装 MetaMask，或者想按照教程开始操作，请查看使用 MetaMask 与 Moonbeam 交互 指南。</p>"}, {"location": "builders/get-started/networks/moonbeam/#configuration", "title": "配置", "text": "<p>请注意以下 gas 配置参数。这些值可能会在未来的运行时升级中发生变化。</p> 变量 值 最低 gas 价格 31.25 Gwei 目标区块时间 6 秒 区块 gas 限制 60,000,000 交易 gas 限制 52,000,000"}, {"location": "builders/get-started/networks/moonriver/", "title": "Moonriver入门", "text": ""}, {"location": "builders/get-started/networks/moonriver/#block-explorers", "title": "区块浏览器", "text": "<p>对于 Moonriver，您可以使用以下任何一个区块浏览器：</p> <ul> <li>Ethereum API（等效于 Etherscan）— Moonscan</li> <li>基于 Ethereum API JSON-RPC — Moonbeam Basic Explorer</li> <li>Substrate API — Subscan 或 Polkadot.js Apps</li> </ul> <p>有关每个可用区块浏览器的更多信息，请访问文档的区块浏览器部分。</p>"}, {"location": "builders/get-started/networks/moonriver/#connect-metamask", "title": "连接 MetaMask", "text": "<p>如果您已经安装了 MetaMask，您可以轻松地将 MetaMask 连接到 Moonriver：</p> Connect MetaMask <p>Note</p> <p>MetaMask 将弹出窗口，请求允许将 Moonriver 添加为自定义网络。一旦您批准了权限，MetaMask 会将您当前的网路切换到 Moonriver。</p> <p>如果您没有安装 MetaMask，或者想按照教程开始操作，请查看使用 MetaMask 与 Moonbeam 交互指南。</p>"}, {"location": "builders/get-started/networks/moonriver/#configuration", "title": "配置", "text": "<p>请注意以下 gas 配置参数。这些值可能会在将来的运行时升级中发生更改。</p> 变量 值 最低 gas 价格 0.3125 Gwei 目标区块时间 6 秒 区块 gas 限制 60,000,000 交易 gas 限制 52,000,000"}, {"location": "builders/integrations/indexers/covalent/", "title": "GoldRush API 入门", "text": ""}, {"location": "builders/integrations/indexers/covalent/#introduction", "title": "简介", "text": "<p>GoldRush，前身为 Covalent，是一种托管的区块链数据解决方案，可访问 100 多个受支持的区块链 的历史和当前链上数据，包括 Moonbeam、Moonriver 和 Moonbase Alpha。GoldRush 维护每个受支持区块链的完整存档副本，这意味着每个余额、交易、日志事件和 NFT 资产数据都可以从创世区块获得。此数据可通过以下方式获得：</p> <ul> <li>统一 API - 通过熟悉的 REST API 将区块链数据整合到您的应用中</li> </ul> <p>本指南将介绍开始使用 Foundational API 所需的所有详细信息，以及如何使用 curl 命令以及 JavaScript 和 Python 代码段访问 Moonbeam 的 API 端点。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "builders/integrations/indexers/covalent/#unified-api-overview", "title": "统一 API 概述", "text": "<p>GoldRush 的统一 API 是一个强大但易于使用的 REST API，可提供跨所有区块链网络的资产可见性。它具有跨网络一致的请求和响应对象格式。例如，用户可以通过更改请求 URL 中唯一的区块链名称或 ID 路径参数，来获取任何受支持的区块链上钱包地址的所有令牌余额。与通常仅限于对特定区块进行查询的 JSON-RPC 接口相比，GoldRush 的统一 API 可以提供更多的数据灵活性。它还允许查询多个对象和批量导出数据。</p>"}, {"location": "builders/integrations/indexers/covalent/#querying-the-unified-api", "title": "查询统一 API", "text": "<p>在您获得 GoldRush API 密钥后，可以轻松开始查询统一 API。请确保您拥有您的 API 密钥，该密钥以 <code>cqt_</code> 或 <code>ckey_</code> 开头。</p> <p>您可以在 GoldRush 文档的 Web 界面中与任何 API 方法进行交互。要试用代币余额 API，请访问代币余额文档，然后执行以下步骤：</p> <ol> <li>粘贴您的 API 密钥</li> <li>输入所需的 <code>chainName</code>，例如 Moonbase Alpha 的 <code>moonbeam-moonbase-alpha</code>。如果您不确定所需网络的 chainName 应该是什么，请参考快速入门部分</li> <li>输入您希望检查代币余额的地址</li> <li>按发送</li> </ol> <p></p>"}, {"location": "builders/integrations/indexers/covalent/#quick-start", "title": "快速开始", "text": "<p>如果您熟悉 GoldRush 并准备好开始，您将需要 chainID 和网络名称才能开始。</p> <p>===     |  Parameter  |               Value                |     |:-----------:|:----------------------------------:|     | <code>chainName</code> |         <code>moonbeam-mainnet</code>         |     |  <code>chainID</code>  | <code>1284</code> |</p> <p>===     |  Parameter  |                Value                |     |:-----------:|:-----------------------------------:|     | <code>chainName</code> |        <code>moonbeam-moonriver</code>         |     |  <code>chainID</code>  | <code>1285</code> |</p> <p>===     |  Parameter  |               Value                |     |:-----------:|:----------------------------------:|     | <code>chainName</code> |     <code>moonbeam-moonbase-alpha</code>      |     |  <code>chainID</code>  | <code>1287</code> |</p>"}, {"location": "builders/integrations/indexers/covalent/#fundamentals-of-the-unified-api", "title": "统一 API 的基本原理", "text": "<ul> <li>GoldRush API 是 RESTful 风格的，它围绕着可以通过 Web 界面获得的主要资源而设计</li> <li>API 的当前版本为版本 1</li> <li>所有端点的默认返回格式为 JSON</li> <li>所有请求都需要身份验证；您需要一个 API 密钥才能使用 GoldRush API</li> <li>API 调用的成本以积分计价，并且因特定调用而异。创建 API 密钥后，您将获得大量免费积分以开始使用（在撰写本文时为 25,000 个）。您可以在 GoldRush 仪表板上跟踪这些免费积分的使用情况</li> <li>请注意，免费开发 API 密钥的速率限制为每秒 <code>4</code> 个请求。专业计划的订阅者每秒最多可以发出 <code>50</code> 个请求。</li> <li>API 的根 URL 为：<code>https://api.covalenthq.com/v1/</code></li> <li>所有请求都通过 HTTPS 完成（通过纯 HTTP 的调用将失败）</li> <li>API 的刷新率是实时的：30 秒或两个区块，批量 30 分钟或 40 个区块</li> </ul>"}, {"location": "builders/integrations/indexers/covalent/#types-of-endpoints", "title": "端点类型", "text": "<p>GoldRush API 有三种类型的端点：</p> <ul> <li>A 类 — 返回适用于所有区块链网络的丰富区块链数据的端点，例如：余额、交易、日志事件等</li> <li>B 类 — 适用于区块链上特定协议的端点，例如，Uniswap 仅适用于 Ethereum，不适用于其他区块链网络</li> <li>C 类 — 由社区构建和维护，但由 GoldRush 基础设施提供支持的端点</li> </ul>"}, {"location": "builders/integrations/indexers/covalent/#sample-supported-endpoints", "title": "支持的示例端点", "text": "<p>有关支持的端点的完整列表，请参阅 GoldRush API 参考。支持的端点的子集包括：</p> <ul> <li>代币余额- 获取地址的所有代币余额（原生、ERC-20、ERC-721、ERC-1155）以及当前市场价格</li> <li>原生代币余额- 检索地址的原生代币余额</li> <li>获取交易- 获取并呈现带有已解码日志事件的单个交易</li> <li>交易摘要- 检索地址的关键钱包活动数据</li> <li>最早的交易- 获取地址的最早交易</li> <li>最近的交易- 获取地址的最近交易</li> <li>分页交易- 获取地址的分页交易</li> <li>批量时间分段交易- 获取 15 分钟时间分段内的所有交易</li> <li>区块交易- 获取特定区块中的所有交易</li> <li>ERC-20 代币转移- 获取地址的特定 ERC-20 代币的转移历史记录</li> <li>跨链活动- 查找地址处于活跃状态的链</li> <li>代币批准- 获取地址的代币批准列表</li> <li>NFT 批准- 检索地址的 NFT 批准</li> </ul>"}, {"location": "builders/integrations/indexers/covalent/#unified-api-methods", "title": "统一 API 方法", "text": "<p>要了解有关统一 API 的每种方法的更多信息，并获得尝试每种方法的交互式界面，请务必查看 GoldRush 文档。</p>"}, {"location": "builders/integrations/indexers/covalent/#balances", "title": "余额", "text": "代币余额 <p>代币余额端点 检索与给定地址关联的本地代币、可替代代币 (ERC-20) 和不可替代代币 (ERC-721 &amp; ERC-1155)。返回的数据包括当前市场价格和其他代币元数据。</p> 参数示例请求示例响应 <ul> <li><code>chainName</code> string - 例如 <code>moonbeam-mainnet</code>、<code>moonbeam-moonriver</code> 或 <code>moonbeam-moonbase-alpha</code></li> <li><code>walletAddress</code> string - 您希望检查代币余额的地址</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x569BE8d8b04538318e1722f6e375FD381D2da865/balances_v2/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x569be8d8b04538318e1722f6e375fd381d2da865\",\n    \"updated_at\": \"2024-10-08T23:34:58.401269473Z\",\n    \"next_update_at\": \"2024-10-08T23:39:58.401269913Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"contract_decimals\": 18,\n        \"contract_name\": \"Mainnet2021\",\n        \"contract_ticker_symbol\": \"MN21\",\n        \"contract_address\": \"0xb59c01231fd65fb2da1e23a52abb946e2e13b333\",\n        \"supports_erc\": [\n          \"erc20\"\n        ],\n        \"logo_url\": \"https://logos.covalenthq.com/tokens/1287/0xb59c01231fd65fb2da1e23a52abb946e2e13b333.png\",\n        \"balance\": \"999999\",\n        \"quote_rate\": null,\n        \"quote\": 0,\n        \"pretty_quote\": \"$0.00\"\n      },\n      {\n        \"contract_decimals\": 18,\n        \"contract_name\": \"Dev\",\n        \"contract_ticker_symbol\": \"DEV\",\n        \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n        \"supports_erc\": [\n          \"erc20\"\n        ],\n        \"logo_url\": \"https://www.datocms-assets.com/86369/1669924256-moonbeam-1.png\",\n        \"balance\": \"88335963638628211482\",\n        \"quote_rate\": 0,\n        \"quote\": 0,\n        \"pretty_quote\": \"$0.00\"\n      }\n    ],\n    \"pagination\": null\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> 本地代币余额 <p>本地代币余额端点 以简化的方式检索给定地址的本地代币余额。</p> 参数示例请求示例响应 <ul> <li><code>chainName</code> string - 例如 <code>moonbeam-mainnet</code>、<code>moonbeam-moonriver</code> 或 <code>moonbeam-moonbase-alpha</code></li> <li><code>walletAddress</code> string - 您希望检查代币余额的地址</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x569BE8d8b04538318e1722f6e375FD381D2da865/balances_native/ \\\n  --header 'Authorization: Bearer INSERT-API-KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x569be8d8b04538318e1722f6e375fd381d2da865\",\n    \"updated_at\": \"2024-10-09T00:15:57.758041451Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"contract_decimals\": 18,\n        \"contract_name\": \"Dev\",\n        \"contract_ticker_symbol\": \"DEV\",\n        \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n        \"supports_erc\": [\n          \"erc20\"\n        ],\n        \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\",\n        \"block_height\": 8959160,\n        \"balance\": \"88335963638628211482\",\n        \"quote_rate\": null,\n        \"quote\": null,\n        \"pretty_quote\": null\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> 获取地址的 ERC-20 代币转移 <p>获取地址的 ERC-20 代币转移 用于在提供钱包地址和 ERC-20 代币合约地址时，获取代币的转入和转出以及地址的历史价格</p> 参数示例请求示例响应 <ul> <li><code>chainName</code> string - 例如 <code>moonbeam-mainnet</code>、<code>moonbeam-moonriver</code> 或 <code>moonbeam-moonbase-alpha</code></li> <li><code>walletAddress</code> string - 您希望查询的地址</li> <li><code>contractAddress</code> string - 要查询的 ERC-20 代币合约</li> </ul> <pre><code>curl --request GET \\\n  --url 'https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/transfers_v2/?contract-address=0x37822de108AFFdd5cDCFDaAa2E32756Da284DB85' \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T02:02:58.842706507Z\",\n    \"next_update_at\": \"2024-10-09T02:07:58.842707047Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2022-04-29T17:41:36Z\",\n        \"block_height\": 2075113,\n        \"tx_hash\": \"0x7271982923345160707c397e412db1a75ceaa458fc1a5dc2c638dd60e58e60d2\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": \"0x37822de108affdd5cdcfdaaa2e32756da284db85\",\n        \"value\": \"0\",\n        \"gas_offered\": 35009,\n        \"gas_spent\": 32693,\n        \"gas_price\": 2500000000,\n        \"fees_paid\": \"81732500000000\",\n        \"transfers\": [\n          {\n            \"tx_hash\": \"0x7271982923345160707c397e412db1a75ceaa458fc1a5dc2c638dd60e58e60d2\",\n            \"from_address\": \"0x0000000000000000000000000000000000000000\",\n            \"to_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n            \"contract_name\": \"Mercury\",\n            \"contract_ticker_symbol\": \"MERC\",\n            \"contract_address\": \"0x37822de108affdd5cdcfdaaa2e32756da284db85\",\n            \"transfer_type\": \"IN\",\n            \"delta\": \"100000000000000000000\"\n          }\n        ]\n      },\n      {\n        \"block_signed_at\": \"2021-10-13T19:06:30Z\",\n        \"block_height\": 954752,\n        \"tx_hash\": \"0x7fb19c6b0ccf1dd87610c59a9cdc2f298ce6b39b32b396f900f1bf3c8f034b6b\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": \"0x8a1932d6e26433f3037bd6c3a40c816222a6ccd4\",\n        \"value\": \"0\",\n        \"gas_offered\": 369444,\n        \"gas_spent\": 99165,\n        \"gas_price\": 1000000000,\n        \"fees_paid\": \"99165000000000\",\n        \"transfers\": [\n          {\n            \"tx_hash\": \"0x7fb19c6b0ccf1dd87610c59a9cdc2f298ce6b39b32b396f900f1bf3c8f034b6b\",\n            \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n            \"to_address\": \"0x573db48e758cbc07a99afe67b8b7b23f671902c0\",\n            \"contract_name\": \"Mercury\",\n            \"contract_ticker_symbol\": \"MERC\",\n            \"contract_address\": \"0x37822de108affdd5cdcfdaaa2e32756da284db85\",\n            \"transfer_type\": \"OUT\",\n            \"delta\": \"10000000000000000000000\"\n          }\n        ]\n      }\n    ],\n    \"pagination\": {\n      \"has_more\": false,\n      \"page_number\": 0,\n      \"page_size\": 100,\n      \"total_count\": null\n    }\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre>"}, {"location": "builders/integrations/indexers/covalent/#transactions", "title": "交易", "text": "获取交易 <p>获取交易 用于获取和渲染单个交易，包括其解码的日志事件。</p> 参数示例请求示例响应 <ul> <li><code>chainName</code> string - 例如 <code>moonbeam-mainnet</code>、<code>moonbeam-moonriver</code> 或 <code>moonbeam-moonbase-alpha</code></li> <li><code>txHash</code> string - 交易哈希</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/transaction_v2/0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T00:33:57.799418189Z\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-09-27T22:23:54Z\",\n        \"block_height\": 8816296,\n        \"block_hash\": \"0x2f89cd5009b3c69de1eb4edf678a5dfb6c2366cb7da6945783a443133b3df44e\",\n        \"tx_hash\": \"0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60\",\n        \"tx_offset\": 1,\n        \"successful\": true,\n        \"miner_address\": \"0xd34fedcefbaacbd74bd3d0bb80b3a67e6b2defb7\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"from_address_label\": null,\n        \"to_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n        \"to_address_label\": null,\n        \"value\": \"0\",\n        \"value_quote\": null,\n        \"pretty_value_quote\": null,\n        \"gas_metadata\": {\n          \"contract_decimals\": 18,\n          \"contract_name\": \"Dev\",\n          \"contract_ticker_symbol\": \"DEV\",\n          \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n          \"supports_erc\": [\n            \"erc20\"\n          ],\n          \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\"\n        },\n        \"gas_offered\": 169164,\n        \"gas_spent\": 110096,\n        \"gas_price\": 31250000,\n        \"fees_paid\": \"13762000000000\",\n        \"gas_quote\": null,\n        \"pretty_gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"explorers\": [\n          {\n            \"label\": null,\n            \"url\": \"https://moonbase-blockscout.testnet.moonbeam.network/tx/0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60\"\n          }\n        ],\n        \"log_events\": [\n          {\n            \"block_signed_at\": \"2024-09-27T22:23:54Z\",\n            \"block_height\": 8816296,\n            \"tx_offset\": 1,\n            \"log_offset\": 1,\n            \"tx_hash\": \"0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60\",\n            \"raw_log_topics\": [\n              \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n              \"0x0000000000000000000000003b939fead1557c741ff06492fd0127bd287a421e\",\n              \"0x0000000000000000000000004b8c667590e6a28497ea4be5facb7e9869a64eae\"\n            ],\n            \"sender_contract_decimals\": 12,\n            \"sender_name\": \"xcUNIT\",\n            \"sender_contract_ticker_symbol\": \"xcUNIT\",\n            \"sender_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n            \"sender_address_label\": null,\n            \"sender_logo_url\": \"https://logos.covalenthq.com/tokens/1287/0xffffffff1fcacbd218edc0eba20fc2308c778080.png\",\n            \"supports_erc\": [\n              \"erc20\"\n            ],\n            \"sender_factory_address\": null,\n            \"raw_log_data\": \"0x000000000000000000000000000000000000000000000000000000e8d4a51000\",\n            \"decoded\": {\n              \"name\": \"Transfer\",\n              \"signature\": \"Transfer(indexed address from, indexed address to, uint256 value)\",\n              \"params\": [\n                {\n                  \"name\": \"from\",\n                  \"type\": \"address\",\n                  \"indexed\": true,\n                  \"decoded\": true,\n                  \"value\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\"\n                },\n                {\n                  \"name\": \"to\",\n                  \"type\": \"address\",\n                  \"indexed\": true,\n                  \"decoded\": true,\n                  \"value\": \"0x4b8c667590e6a28497ea4be5facb7e9869a64eae\"\n                },\n                {\n                  \"name\": \"value\",\n                  \"type\": \"uint256\",\n                  \"indexed\": false,\n                  \"decoded\": true,\n                  \"value\": \"1000000000000\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ],\n    \"pagination\": null\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> 获取地址的交易摘要 <p>获取地址的交易摘要 检索关键钱包活动数据，包括第一笔和最近的交易以及总交易计数。 它能够快速分析钱包年龄、不活动周期和整体 Web3 参与度。</p> 参数示例请求示例响应 <ul> <li><code>chainName</code> string - 例如 <code>moonbeam-mainnet</code>、<code>moonbeam-moonriver</code> 或 <code>moonbeam-moonbase-alpha</code></li> <li><code>walletAddress</code> string - 您希望查询的地址</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/transactions_summary/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T00:48:11.969915467Z\",\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"total_count\": 3066,\n        \"latest_transaction\": {\n          \"block_signed_at\": \"2024-10-04T19:41:48Z\",\n          \"tx_hash\": \"0x0923932a55c4366288cfc7a970e1d04895551d11f64d8f183877e8f6c19360bc\",\n          \"tx_detail_link\": \"https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/transaction_v2/0x0923932a55c4366288cfc7a970e1d04895551d11f64d8f183877e8f6c19360bc/\"\n        },\n        \"earliest_transaction\": {\n          \"block_signed_at\": \"2021-05-27T18:13:12Z\",\n          \"tx_hash\": \"0xc94e0072477e2543d17662317d40e4785ac6bb327c2a7483021167684b8584f3\",\n          \"tx_detail_link\": \"https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/transaction_v2/0xc94e0072477e2543d17662317d40e4785ac6bb327c2a7483021167684b8584f3/\"\n        }\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> 获取地址的最早交易 (v3) <p>获取地址的最早交易 检索涉及地址的最早交易。</p> 参数示例请求示例响应 <ul> <li><code>chainName</code> string - 例如 <code>moonbeam-mainnet</code>、<code>moonbeam-moonriver</code> 或 <code>moonbeam-moonbase-alpha</code></li> <li><code>walletAddress</code> string - 您希望查询的地址</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/bulk/transactions/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T01:12:17.851277100Z\",\n    \"next_update_at\": \"2024-10-09T01:17:17.851280680Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2021-05-27T18:13:12Z\",\n        \"block_height\": 6971,\n        \"tx_hash\": \"0xc94e0072477e2543d17662317d40e4785ac6bb327c2a7483021167684b8584f3\",\n        \"from_address\": \"0xc10dc91c62c4854ffc0997776d495da3d8c79730\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"1044522000000000\",\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"log_events\": [\n          {\n            \"sender_name\": \"Mercury\",\n            \"sender_contract_ticker_symbol\": \"MERC\",\n            \"sender_address\": \"0x37822de108affdd5cdcfdaaa2e32756da284db85\",\n            \"decoded\": {\n              \"name\": \"Transfer\",\n              \"params\": [\n                {\n                  \"name\": \"from\",\n                  \"value\": \"0x0000000000000000000000000000000000000000\"\n                },\n                {\n                  \"name\": \"to\",\n                  \"value\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\"\n                },\n                {\n                  \"name\": \"value\",\n                  \"value\": \"100000000000000000000000\"\n                }\n              ]\n            }\n          }\n        ]\n      },\n      {\n        \"block_signed_at\": \"2021-05-27T18:13:24Z\",\n        \"block_height\": 6972,\n        \"tx_hash\": \"0xc37137133cbb8b0810943a6625a7193b5b18d72b5e21a78103243f482c269e71\",\n        \"from_address\": \"0xc10dc91c62c4854ffc0997776d495da3d8c79730\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"1044486000000000\",\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"log_events\": [\n          {\n            \"sender_name\": \"Venus\",\n            \"sender_contract_ticker_symbol\": \"VEN\",\n            \"sender_address\": \"0xcdf746c5c86df2c2772d2d36e227b4c0203cba25\",\n            \"decoded\": {\n              \"name\": \"Transfer\",\n              \"params\": [\n                {\n                  \"name\": \"from\",\n                  \"value\": \"0x0000000000000000000000000000000000000000\"\n                },\n                {\n                  \"name\": \"to\",\n                  \"value\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\"\n                },\n                {\n                  \"name\": \"value\",\n                  \"value\": \"100000000000000000000000\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> 获取地址的最近交易 (v3) <p>获取地址的最近交易 检索涉及地址的最近交易。</p> 参数示例请求示例响应 <ul> <li><code>chainName</code> string - 例如 <code>moonbeam-mainnet</code>、<code>moonbeam-moonriver</code> 或 <code>moonbeam-moonbase-alpha</code></li> <li><code>walletAddress</code> string - 您希望查询的地址</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/transactions_v3/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T01:16:10.410076422Z\",\n    \"next_update_at\": \"2024-10-09T01:21:10.410077022Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-10-04T19:41:48Z\",\n        \"block_height\": 8901780,\n        \"tx_hash\": \"0x0923932a55c4366288cfc7a970e1d04895551d11f64d8f183877e8f6c19360bc\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"120825750000000\",\n        \"gas_offered\": 1010593,\n        \"gas_spent\": 966606,\n        \"gas_price\": 31250000,\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null\n      },\n      {\n        \"block_signed_at\": \"2024-09-27T22:23:54Z\",\n        \"block_height\": 8816296,\n        \"tx_hash\": \"0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n        \"value\": \"0\",\n        \"fees_paid\": \"13762000000000\",\n        \"gas_offered\": 169164,\n        \"gas_spent\": 110096,\n        \"gas_price\": 31250000,\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"log_events\": [\n          {\n            \"sender_name\": \"xcUNIT\",\n            \"sender_contract_ticker_symbol\": \"xcUNIT\",\n            \"sender_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n            \"decoded\": {\n              \"name\": \"Transfer\",\n              \"params\": [\n                {\n                  \"name\": \"from\",\n                  \"value\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\"\n                },\n                {\n                  \"name\": \"to\",\n                  \"value\": \"0x4b8c667590e6a28497ea4be5facb7e9869a64eae\"\n                },\n                {\n                  \"name\": \"value\",\n                  \"value\": \"1000000000000\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> 获取地址的分页交易 (v3) <p>获取地址的分页交易 (v3) 获取涉及地址和指定页面的交易，从 0 索引开始。</p> 参数示例请求示例响应 <ul> <li><code>chainName</code> string - 例如 <code>moonbeam-mainnet</code>、<code>moonbeam-moonriver</code> 或 <code>moonbeam-moonbase-alpha</code></li> <li><code>walletAddress</code> string - 您希望查询的地址</li> <li><code>page</code> integer - 请求的页面，0 索引。</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/transactions_v3/page/2/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T01:37:36.277434751Z\",\n    \"next_update_at\": \"2024-10-09T01:42:36.277435481Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2021-06-08T18:22:00Z\",\n        \"block_height\": 93135,\n        \"tx_hash\": \"0x802eab122522f1ae23b911e8045d9de128acaa5c790d5df0c389240f23b7e17d\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"1416680000000000\",\n        \"gas_offered\": 1455080,\n        \"gas_spent\": 1416680,\n        \"gas_price\": 1000000000,\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null\n      },\n      {\n        \"block_signed_at\": \"2021-06-08T18:21:48Z\",\n        \"block_height\": 93134,\n        \"tx_hash\": \"0xe82d29e37e8d324a22ed9ce70d0c85258c420cf98cc4161c35f4edb7c9ba09c0\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"1712047000000000\",\n        \"gas_offered\": 1750447,\n        \"gas_spent\": 1712047,\n        \"gas_price\": 1000000000,\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> 获取地址的批量时间段交易 (v3) <p>获取地址的批量时间段交易 (v3) 用于获取所有交易，包括 15 分钟时间段间隔内解码的日志事件。</p> 参数示例请求示例响应 <ul> <li><code>chainName</code> string - 例如 <code>moonbeam-mainnet</code>、<code>moonbeam-moonriver</code> 或 <code>moonbeam-moonbase-alpha</code></li> <li><code>walletAddress</code> string - 您希望查询的地址</li> <li><code>timeBucket</code> integer - 0 索引的 15 分钟时间段。例如 8 9 Oct 2024 01:49 GMT = 1728420540 (Unix 时间)。1728420540/900 = 1920467 timeBucket。</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/bulk/transactions/0x28a2B98793Fd1E20Fd79824cd29D36D3eB9A8F0E/1920467/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x28a2b98793fd1e20fd79824cd29d36d3eb9a8f0e\",\n    \"updated_at\": \"2024-10-09T01:47:40.617173773Z\",\n    \"next_update_at\": \"2024-10-09T01:52:40.617176953Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"complete\": true,\n    \"current_bucket\": 1920467,\n    \"links\": {\n      \"prev\": \"https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/bulk/transactions/0x28a2b98793fd1e20fd79824cd29d36d3eb9a8f0e/1920466/\",\n      \"next\": \"https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/bulk/transactions/0x28a2b98793fd1e20fd79824cd29d36d3eb9a8f0e/1920468/\"\n    },\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-10-08T20:48:42Z\",\n        \"block_height\": 8957260,\n        \"tx_hash\": \"0x587f0121ea9c51b93e1915a20370f0a2f004adee99d00ef8d1c0f9cc681a9772\",\n        \"from_address\": \"0x28a2b98793fd1e20fd79824cd29d36d3eb9a8f0e\",\n        \"to_address\": \"0x916b54696a70588a716f899be1e8f2a5ffd5f135\",\n        \"value\": \"0\",\n        \"gas_offered\": 582957,\n        \"gas_spent\": 551928,\n        \"gas_price\": 31250000,\n        \"fees_paid\": \"68991000000000\",\n        \"log_events\": [\n          {\n            \"sender_address\": \"0x916b54696a70588a716f899be1e8f2a5ffd5f135\",\n            \"decoded\": {\n              \"name\": \"SessionStarted\",\n              \"signature\": \"SessionStarted(indexed uint64 chainId, indexed uint64 blockHeight, uint64 deadline)\",\n              \"params\": [\n                {\n                  \"name\": \"chainId\",\n                  \"type\": \"uint64\",\n                  \"value\": \"1\"\n                },\n                {\n                  \"name\": \"blockHeight\",\n                  \"type\": \"uint64\",\n                  \"value\": \"20923350\"\n                },\n                {\n                  \"name\": \"deadline\",\n                  \"type\": \"uint64\",\n                  \"value\": \"8957360\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> 按页面获取区块中的所有交易 (v3) <p>按页面获取区块中的所有交易 (v3) 用于获取区块中包括其解码的日志事件的所有交易，并进一步标记有趣的钱包或交易。</p> 参数示例请求示例响应 <ul> <li><code>chainName</code> string - 例如 <code>moonbeam-mainnet</code>、<code>moonbeam-moonriver</code> 或 <code>moonbeam-moonbase-alpha</code></li> <li><code>blockHeight</code> integer - 请求的区块高度。也接受 <code>latest</code> 关键字</li> <li><code>page</code> integer - 请求的页面，0 索引。</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/block/8960094/transactions_v3/page/0/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T01:54:34.371150099Z\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"links\": {\n      \"prev\": null,\n      \"next\": null\n    },\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-10-09T01:51:42Z\",\n        \"block_height\": 8960094,\n        \"block_hash\": \"0x2a9cda3cfd23dffbe064932991568cae601d178717743eabc326222123d7ad44\",\n        \"tx_hash\": \"0x4abfef674580260d3c837e1dc5b17b8bf809e620518e40d3731c6c1cfa5346d9\",\n        \"tx_offset\": 0,\n        \"successful\": true,\n        \"miner_address\": \"0xeda33e2b5ffb97bb8b901b71b87e5791556fd46b\",\n        \"from_address\": \"0xf5e8a439c599205c1ab06b535de46681aed1007a\",\n        \"from_address_label\": null,\n        \"to_address\": \"0x21e612506ab4792a5d22466c0b529bb9afe4e42b\",\n        \"to_address_label\": null,\n        \"value\": \"0\",\n        \"value_quote\": null,\n        \"pretty_value_quote\": null,\n        \"gas_metadata\": {\n          \"contract_decimals\": 18,\n          \"contract_name\": \"Dev\",\n          \"contract_ticker_symbol\": \"DEV\",\n          \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n          \"supports_erc\": [\n            \"erc20\"\n          ],\n          \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\"\n        },\n        \"gas_offered\": 505088,\n        \"gas_spent\": 184528,\n        \"gas_price\": 1200000000,\n        \"fees_paid\": \"221433600000000\",\n        \"gas_quote\": null,\n        \"pretty_gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"explorers\": [\n          {\n            \"label\": null,\n            \"url\": \"https://moonbase-blockscout.testnet.moonbeam.network/tx/0x4abfef674580260d3c837e1dc5b17b8bf809e620518e40d3731c6c1cfa5346d9\"\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> 获取区块中的所有交易 (v3) <p>获取区块中的所有交易 (v3) 用于获取区块中包括其解码的日志事件的所有交易，并进一步标记有趣的钱包或交易。 它以区块哈希作为参数，并且不接受页面参数。</p> 参数示例请求示例响应 <ul> <li><code>chainName</code> string - 例如 <code>moonbeam-mainnet</code>、<code>moonbeam-moonriver</code> 或 <code>moonbeam-moonbase-alpha</code></li> <li><code>blockHash</code> integer - 请求的区块哈希</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/block_hash/0x2a9cda3cfd23dffbe064932991568cae601d178717743eabc326222123d7ad44/transactions_v3/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T01:58:08.816101489Z\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-10-09T01:51:42Z\",\n        \"block_height\": 8960094,\n        \"block_hash\": \"0x2a9cda3cfd23dffbe064932991568cae601d178717743eabc326222123d7ad44\",\n        \"tx_hash\": \"0x4abfef674580260d3c837e1dc5b17b8bf809e620518e40d3731c6c1cfa5346d9\",\n        \"tx_offset\": 0,\n        \"successful\": true,\n        \"miner_address\": \"0xeda33e2b5ffb97bb8b901b71b87e5791556fd46b\",\n        \"from_address\": \"0xf5e8a439c599205c1ab06b535de46681aed1007a\",\n        \"from_address_label\": null,\n        \"to_address\": \"0x21e612506ab4792a5d22466c0b529bb9afe4e42b\",\n        \"to_address_label\": null,\n        \"value\": \"0\",\n        \"value_quote\": null,\n        \"pretty_value_quote\": null,\n        \"gas_metadata\": {\n          \"contract_decimals\": 18,\n          \"contract_name\": \"Dev\",\n          \"contract_ticker_symbol\": \"DEV\",\n          \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n          \"supports_erc\": [\n            \"erc20\"\n          ],\n          \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\"\n        },\n        \"gas_offered\": 505088,\n        \"gas_spent\": 184528,\n        \"gas_price\": 1200000000,\n        \"fees_paid\": \"221433600000000\",\n        \"gas_quote\": null,\n        \"pretty_gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"explorers\": [\n          {\n            \"label\": null,\n            \"url\": \"https://moonbase-blockscout.testnet.moonbeam.network/tx/0x4abfef674580260d3c837e1dc5b17b8bf809e620518e40d3731c6c1cfa5346d9\"\n          }\n        ]\n      }\n    ],\n    \"pagination\": null\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre>"}, {"location": "builders/integrations/indexers/covalent/#cross-chain", "title": "跨链", "text": "获取地址的跨链活动 <p>获取地址的跨链活动 用于查找地址在哪些链上处于活跃状态，只需一次 API 调用即可</p> 参数示例请求示例响应 <ul> <li><code>walletAddress</code> string - 您希望查询的地址</li> </ul> <p>bash curl --request GET \\   --url https://api.covalenthq.com/v1/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/activity/ \\   --header 'Authorization: Bearer INSERT_API_KEY'</p> <p>bash {   \"data\": {     \"updated_at\": \"2024-10-09T02:08:22.594362014Z\",     \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",     \"items\": [       {         \"name\": \"matic-mainnet\",         \"chain_id\": \"137\",         \"is_testnet\": false,         \"label\": \"Polygon Mainnet\",         \"category_label\": \"Polygon\",         \"logo_url\": \"https://www.datocms-assets.com/86369/1677870347-property-1-polygon-zkevm-icon-white.svg\",         \"color_theme\": {           \"hex\": \"#8247E5\",           \"css_rgb\": \"rgb(130 71 229)\"         },         \"last_seen_at\": \"2024-06-26T09:50:16Z\"       },       {         \"name\": \"moonbeam-mainnet\",         \"chain_id\": \"1284\",         \"is_testnet\": false,         \"label\": \"Moonbeam Mainnet\",         \"category_label\": \"Moonbeam\",         \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\",         \"color_theme\": {           \"hex\": \"#54CBC8\",           \"css_rgb\": \"rgb(84 203 200)\"         },         \"last_seen_at\": \"2024-10-04T01:11:42Z\"       }     ]   },   \"error\": false,   \"error_message\": null,   \"error_code\": null }</p>"}, {"location": "builders/integrations/indexers/covalent/#security", "title": "安全性", "text": "获取地址的令牌批准 <p>获取地址的令牌批准 用于获取钱包资产的所有令牌合约中按消费方分类的批准列表</p> 参数示例请求示例响应 <ul> <li><code>chainName</code> string - 例如 <code>moonbeam-mainnet</code>、<code>moonbeam-moonriver</code> 或 <code>moonbeam-moonbase-alpha</code></li> <li><code>walletAddress</code> string - 您希望查询的地址</li> </ul> <p>bash curl --request GET \\   --url https://api.covalenthq.com/v1/moonbeam-mainnet/approvals/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/ \\   --header 'Authorization: Bearer INSERT_API_KEY'</p> <p>bash {   \"data\": {     \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",     \"updated_at\": \"2024-10-09T02:11:10.587740726Z\",     \"quote_currency\": \"USD\",     \"chain_id\": 1284,     \"chain_name\": \"moonbeam-mainnet\",     \"items\": [       {         \"token_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",         \"token_address_label\": \"xcDOT\",         \"ticker_symbol\": \"xcDOT\",         \"contract_decimals\": 10,         \"logo_url\": \"https://logos.covalenthq.com/tokens/1284/0xffffffff1fcacbd218edc0eba20fc2308c778080.png\",         \"quote_rate\": 4.169,         \"balance\": \"1655341603\",         \"balance_quote\": 0.6901119142907,         \"pretty_balance_quote\": \"$0.69\",         \"spenders\": [           {             \"spender_address\": \"0xbc7e02c4178a7df7d3e564323a5c359dc96c4db4\",             \"spender_address_label\": \"Stella stDOT\",             \"allowance\": \"UNLIMITED\",             \"value_at_risk_quote\": 0.6901119142907,             \"pretty_value_at_risk_quote\": \"$0.69\",             \"risk_factor\": \"LOW RISK\"           }         ]       },       {         \"token_address\": \"0x818ec0a7fe18ff94269904fced6ae3dae6d6dc0b\",         \"token_address_label\": \"USD Coin\",         \"ticker_symbol\": \"USDC\",         \"contract_decimals\": 6,         \"logo_url\": \"https://logos.covalenthq.com/tokens/1284/0x818ec0a7fe18ff94269904fced6ae3dae6d6dc0b.png\",         \"quote_rate\": 0.09,         \"balance\": \"1\",         \"balance_quote\": 0,         \"pretty_balance_quote\": \"$0.00\",         \"spenders\": [           {             \"spender_address\": \"0x70085a09d30d6f8c4ecf6ee10120d1847383bb57\",             \"spender_address_label\": null,             \"allowance\": \"UNLIMITED\",             \"value_at_risk_quote\": 0,             \"pretty_value_at_risk_quote\": \"$0.00\",             \"risk_factor\": \"LOW RISK\"           }         ]       }     ]   },   \"error\": false,   \"error_message\": null,   \"error_code\": null }</p> <p>GoldRush API 提供了许多其他方法，包括 NFT、价格、比特币和实用程序方法。请务必查看 GoldRush API，以获取有关每种方法的更多信息。</p>"}, {"location": "builders/integrations/indexers/covalent/#api-parameters-and-resources", "title": "API 参数和资源", "text": ""}, {"location": "builders/integrations/indexers/covalent/#api-parameters", "title": "API 参数", "text": "MoonbeamMoonriverMoonbase Alpha 参数 值 响应格式 JSON, CSV 实时数据延迟 2 个区块 批量数据延迟 30 分钟 API 免费层级 限制为 4 RPS API 高级层级 限制为 50 RPS 参数 值 响应格式 JSON, CSV 实时数据延迟 2 个区块 批量数据延迟 30 分钟 API 免费层级 限制为 4 RPS API 高级层级 限制为 50 RPS 参数 值 响应格式 JSON, CSV 实时数据延迟 2 个区块 批量数据延迟 30 分钟 API 免费层级 限制为 4 RPS API 高级层级 限制为 50 RPS"}, {"location": "builders/integrations/indexers/covalent/#api-resources", "title": "API 资源", "text": "<ul> <li>API 参考和浏览器内端点演示</li> <li>GoldRush 快速入门</li> <li>书面指南</li> </ul>"}, {"location": "builders/integrations/indexers/covalent/#how-to-use-the-unified-api", "title": "如何使用统一 API", "text": "<p>首先，请确保您拥有您的 API 密钥，该密钥以 <code>cqt_</code> 或 <code>ckey_</code> 开头。 拥有 API 密钥后，您可以访问任何受支持的端点。 要获取特定网络的信息，您必须提供链 ID。</p>"}, {"location": "builders/integrations/indexers/covalent/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要开始使用 GoldRush API，您需要具备以下条件：</p> <ul> <li>一个免费的 GoldRush API 密钥</li> <li>安装 MetaMask 并连接到 Moonbase Alpha</li> <li>一个有资金的帐户。   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul> <p>{   \"source_path\": \"builders/integrations/indexers/covalent.md\",   \"source_language\": \"EN\",   \"target_language\": \"ZH\",   \"checksum\": \"b83ab75d8b266d76b90a928cfc1d14030a090f1b8dc98117f6c54db98eff18ca\",   \"content\": \"### Using Curl {: #using-curl }\\n\\nOne of the supported endpoints is the token holders endpoint, which returns a list of all the token holders of a particular token. For this example, you can check the token holders for the ERTH token. The contract address for the ERTH token on Moonbase Alpha is <code>0x08B40414525687731C23F430CEBb424b332b3d35</code>.\\n\\nTry running the command below in a terminal window after replacing the placeholder with your API key.\\n\\n```bash curl https://api.covalenthq.com/v1/1287/tokens/\\\\n0x08B40414525687731C23F430CEBb424b332b3d35/token_holders/ \\\\n-u INSERT_YOUR_API_KEY:</p>"}, {"location": "builders/integrations/indexers/covalent/#using-javascript", "title": "使用 Javascript", "text": "<p>将下面的代码块复制并粘贴到您喜欢的环境或 JSFiddle 中。设置 API 密钥后，设置地址常量。请记住，对于 Moonbase Alpha，链 ID 为 <code>1287</code>。</p> 使用 Fetch使用 Async <pre><code>// Set your API key\nconst apiKey = 'INSERT_YOUR_API_KEY';\n\nfunction getData() {\n  const address = '0xFEC4f9D5B322Aa834056E85946A32c35A3f5aDD8'; // example\n  const chainId = '1287'; // Moonbase Alpha TestNet chain ID\n  const url = new URL(\n    `https://api.covalenthq.com/v1/${chainId}/address/${address}/balances_v2/`\n  );\n\n  url.search = new URLSearchParams({\n    key: apiKey,\n  });\n\n  // Use fetch API to get Covalent data\n  fetch(url)\n    .then((resp) =&gt; resp.json())\n    .then(function (data) {\n      const result = data.data;\n\n      console.log(result);\n      return result;\n    });\n}\n\ngetData();\n</code></pre> <pre><code>// Set your API key\nconst apiKey = 'INSERT_YOUR_API_KEY';\nconst address = '0xFEC4f9D5B322Aa834056E85946A32c35A3f5aDD8'; // Example\nconst chainId = '1287'; // Moonbase Alpha TestNet chain ID\nconst url = new URL(\n  `https://api.covalenthq.com/v1/${chainId}/address/${address}/balances_v2/`\n);\n\nurl.search = new URLSearchParams({\n  key: apiKey,\n});\n\nasync function getData() {\n  const response = await fetch(url);\n  const result = await response.json();\n  console.log(result);\n  return result;\n}\n\ngetData();\n</code></pre> <p>balances 端点返回所有 ERC-20 和 NFT token 余额的列表，包括 ERC-721 和 ERC-1155 余额，以及它们当前的现货价格（如果可用）。</p> <p></p>"}, {"location": "builders/integrations/indexers/covalent/#using-python", "title": "使用 Python", "text": "<p>GoldRush 没有官方的 API 包装器。要直接查询 API，您必须使用 Python requests 库。使用命令行 <code>pip install requests</code> 将 requests 安装到您的环境中。然后导入它并在您的代码中使用它。使用 HTTP 动词 get 方法从 API 返回信息。将下面的代码块复制并粘贴到您喜欢的环境中并运行它。输出应该与上面的屏幕截图类似，但是格式可能会因您的环境而异。</p> <p>python import requests</p> <p>def fetch_wallet_balance(address):     api_url = \"https://api.covalenthq.com\"     endpoint = f\"/v1/1287/address/{address}/balances_v2/\"     url = api_url + endpoint     response = requests.get(url, auth=(\"INSERT_YOUR_API_KEY\", \"\"))     print(response.json())     return response.json()</p>"}, {"location": "builders/integrations/indexers/covalent/#example-address-request", "title": "Example address request", "text": "<p>fetch_wallet_balance(\"0xFEC4f9D5B322Aa834056E85946A32c35A3f5aDD8\")</p> <p>Note</p> <p><code>auth</code> 的第二个参数为空，因为不需要密码 - 只需要您的 API 密钥。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/integrations/indexers/subquery/", "title": "使用 SubQuery 索引 Moonbeam", "text": ""}, {"location": "builders/integrations/indexers/subquery/#introduction", "title": "简介", "text": "<p>SubQuery 是一个数据聚合层，它在第 1 层区块链（如 Moonbeam 和 Polkadot）和 DApp 之间运行。此服务解锁区块链数据并将其转换为可查询状态，以便在直观的应用程序中使用。它使 DApp 开发人员能够专注于其核心用例和前端，而无需浪费时间构建用于数据处理的自定义后端。</p> <p>SubQuery 支持为任何 Moonbeam 网络索引以太坊虚拟机 (EVM) 和 Substrate 数据。使用 SubQuery 的一个主要优势是，您可以使用单个项目和工具灵活地跨 Moonbeam 的 EVM 和 Substrate 代码收集查询数据，然后使用 GraphQL 查询此数据。</p> <p>例如，除了 Substrate 数据源之外，SubQuery 还可以过滤和查询 EVM 日志和交易。SubQuery 引入了比其他索引器更高级的过滤器，允许过滤非合约交易、交易发送者、合约和索引日志参数，因此开发人员可以构建各种满足其特定数据需求的项目。</p> <p>本快速入门指南将向您展示如何创建 SubQuery 项目并将其配置为在 Moonbeam 上索引 Substrate 和 EVM 数据。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "builders/integrations/indexers/subquery/#checking-prerequisites", "title": "检查先决条件", "text": "<p>在本指南的稍后部分，您可以选择将项目部署到本地运行的SubQuery节点。为此，您需要在系统上安装以下组件：</p> <ul> <li>Docker</li> <li>Docker Compose</li> </ul> <p>Note</p> <p>如果Docker Compose是通过<code>sudo apt install docker-compose</code>命令为Linux安装的，那么您可能会在本指南的稍后部分遇到一些错误。请务必按照官方安装Docker Compose指南中的Linux说明进行操作。</p>"}, {"location": "builders/integrations/indexers/subquery/#create-a-project", "title": "创建一个项目", "text": "<p>要开始使用，您需要创建一个SubQuery项目：</p> <ol> <li> <p>全局安装 SubQuery CLI：</p> npmyarn <pre><code>npm install -g @subql/cli\n</code></pre> <pre><code>yarn global add @subql/cli\n</code></pre> </li> </ol> <p>Note</p> <p>不建议使用yarn安装<code>@subql/cli</code>，因为它依赖管理不佳，可能导致各种错误。</p> <ol> <li> <p>使用以下命令初始化您的SubQuery项目：</p> <pre><code>subql init PROJECT_NAME\n</code></pre> </li> <li> <p>系统将提示您回答一系列问题：</p> <ol> <li> <p>对于选择网络系列问题，虽然Moonbeam与EVM兼容，但Moonbeam模板位于Polkadot系列下，因此您可以选择Polkadot。</p> <p>  subql init moonbeam-demo ? Select a network family    EVM Networks   Algorand   Cosmos   Concordium   NEAR &gt; Polkadot   Stellar </p> </li> <li> <p>下一个屏幕将提示您选择一个网络。您可以在Moonbeam和Moonriver之间进行选择。</p> <p>Note</p> <p>要在Moonbase Alpha上构建项目，您可以选择任一网络并在以后进行调整。</p> <p>  subql init moonbeam-demo ? Select a network family Polkadot ? Select a network    Humanode   HydraDX   Integritee Shell   Interlay   Karura   Khala   KILT Spiritnet   Kusama   Kylin &gt; Moonbeam   Moonriver   Nodle   OriginTrail   Parallel   Parallel Heiko   Polkadex   Polkadot   Quartz   Shiden   Kusama Asset Hub (Statemine) (Move up and down to reveal more choices) </p> </li> <li> <p>系统将提示您选择一个模板项目。根据您在上一步中选择的网络，模板选项可能会有所不同。</p> MoonbeamMoonriver Template Description <code>moonbeam-evm-starter</code> 一个启动器EVM项目，它索引ERC-20 <code>Transfer</code>事件和<code>approve</code>调用 <code>moonbeam-substrate-evm-starter</code> 一个启动器Substrate和EVM项目，它索引ERC-20 <code>Transfer</code>事件和对Staking Pallet的<code>joinCandidates</code>和<code>executeLeaveCandidates</code>外部函数的调用 <code>Moonbeam-starter</code> 一个启动器Substrate项目，它通过Balances Pallet索引余额转移 Template Description <code>moonriver-evm-starter</code> 一个启动器EVM项目，它索引ERC-20 <code>Transfer</code>事件和<code>approve</code>调用 <code>Moonriver-starter</code> 一个启动器Substrate项目，它通过Balances Pallet索引余额转移 <p>  subql init moonbeam-demo ? Select a network family Polkadot ? Select a network Moonbeam ? Select a template project  &gt; moonbeam-evm-starter   moonbeam-substrate-evm-starter   Moonbeam-starter   Other                         Enter a custom git endpoint </p> </li> <li> <p>系统将提示您添加其他信息，例如RPC终结点、项目作者和项目描述。 对于这些，您可以直接按Enter键并接受默认值，或者根据需要自定义它们。</p> <p>Note</p> <p>为了避免达到公共RPC端点的速率限制，建议您拥有自己的端点和API密钥，您可以从支持的端点提供商处获得。</p> <p>  subql init moonbeam-demo ? Select a network family Polkadot ? Select a network Moonbeam ? Select a template project Moonbeam-starter RPC endpoint: [wss://moonbeam.api.onfinality.io/public-ws]: Author [SubQuery Team]: Description [This project can be used as a starting p...]: Preparing project... done moonbeam-demo is ready </p> </li> </ol> </li> <li> <p>完成所有提示后，将克隆启动器项目。 您只需从项目目录中安装依赖项：</p> npmyarn <pre><code>cd PROJECT_NAME &amp;&amp; npm install\n</code></pre> <pre><code>cd PROJECT_NAME &amp;&amp; yarn install\n</code></pre> </li> </ol>"}, {"location": "builders/integrations/indexers/subquery/#configure-the-network", "title": "配置网络", "text": "<p>模板项目已预先配置为在初始化项目时选择的网络。但是，如果您正在处理现有项目，或者想要为 Moonbase Alpha 而不是 Moonbeam 或 Moonriver 配置您的项目，您可以在 <code>project.ts</code> 文件中更新网络配置。</p> <p>每个网络的 <code>network</code> 配置如下：</p> MoonbeamMoonriverMoonbase Alpha <p>ts network: {   chainId:      '0xfe58ea77779b7abda7da4ec526d14db9b1e9cd40a217c34892af80a9b332b76d',   endpoint: ['INSERT_RPC_API_ENDPOINT'],   chaintypes: {     file: ./dist/chaintypes.js,   }, },</p> <p>ts network: {   chainId: '0x401a1f9dca3da46f5c4091016c8a2f26dcea05865116b286f60f668207d1474b',   endpoint: ['INSERT_RPC_API_ENDPOINT'],   chaintypes: {     file: ./dist/chaintypes.js,   }, },</p> <p>ts network: {   chainId: '0x91bc6e169807aaa54802737e1c504b2577d4fafedd5a02c10293b1cd60e39527',   endpoint: ['https://rpc.api.moonbase.moonbeam.network'],   chaintypes: {     file: ./dist/chaintypes.js,   }, },</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"}, {"location": "builders/integrations/indexers/subquery/#modify-the-graphql-schema", "title": "修改 GraphQL 模式", "text": "<p>在 <code>schema.graphql</code> 文件中，您可以使用 GraphQL 实体来定义数据的形状。根据您的需要编辑 GraphQL 模式后，您需要生成所需的 GraphQL 模型。为此，您可以运行以下命令：</p> npmyarn <p>bash npm run codegen</p> <p>bash yarn codegen</p>  npm run codegen &gt; moonbeam-demo@0.0.4 codegen &gt; subql codegen ============================== ---------Subql Codegen--------- ============================== Project manifest generated to /home/papermoon/moonbeam-demo/project.yaml * Schema Transfer generated ! * Schema Account generated ! * Models index generated ! * Types index generated ! <p>生成的模型将在 <code>src/types/models</code> 目录中创建。这些模型将用于处理索引数据的映射处理程序中。</p> <p>Note</p> <p>如果您更改了 <code>schema.graphql</code> 文件，则需要重新生成您的类型。</p>"}, {"location": "builders/integrations/indexers/subquery/#index-substrate-data", "title": "索引 Substrate 数据", "text": "<p><code>project.ts</code> 文件是您的索引器的入口点；它定义了要索引的数据类型以及负责处理索引数据的映射函数。</p> <p>要索引 Substrate 数据，您需要确保 <code>project</code> 的类型为 <code>SubstrateProject</code>。</p> <p>ts const project: SubstrateProject = { ... }</p>"}, {"location": "builders/integrations/indexers/subquery/#the-substrate-data-source", "title": "Substrate 数据源", "text": "<p>在 <code>project.dataSources</code> 数组中，您将定义 Substrate 数据源和要索引的数据。数据源的格式如下：</p> <p>ts datasources: [   {     kind: 'substrate/Runtime',     startBlock: INSERT_START_BLOCK,     endBlock: INSERT_END_BLOCK,     mapping: {       file: './dist/index.js',       handlers: [         {           kind: 'INSERT_HANDLER_KIND',           handler: 'INSERT_HANDLER_FUNCTION_NAME',           filter: {             'INSERT_FILTER_TYPE': 'INSERT_FILTER',           },         },       ],     },   }, ],</p> <p>每个属性可以定义如下：</p> <ul> <li><code>kind</code>：您将使用的数据源类型，对于 Substrate 数据，它是 <code>substrate/Runtime</code> 源。</li> <li><code>startBlock</code>（可选）：索引器将从该区块开始处理区块。</li> <li><code>endBlock</code>（可选）：在此区块之后，索引器将停止处理区块。</li> <li><code>mapping</code>：要索引的数据和数据的处理程序。<ul> <li><code>file</code>：映射的入口路径。</li> <li><code>handlers</code>：特定类型数据的处理程序。<ul> <li><code>kind</code>：处理程序的类型。对于 Substrate 数据，有三种类型：<code>substrateBlockHandler</code>、<code>substrate/EventHandler</code> 和 <code>substrate/CallHandler</code>。</li> <li><code>handler</code>：将处理此数据的处理函数的名字。</li> <li><code>filter</code>（可选）：将触发映射处理程序的过滤器类型和数据。例如，要索引的区块、事件或外部操作。</li> </ul> </li> </ul> </li> </ul>"}, {"location": "builders/integrations/indexers/subquery/#substrate-mapping-handlers", "title": "Substrate映射处理程序", "text": "<p>仅使用某些处理程序和过滤器将提高索引器的效率。Substrate数据可用的处理程序如下：</p> <ul> <li> <p>区块处理程序用于索引区块数据，并且每个区块都会调用一次。因此，这种类型的处理程序会显著降低项目的速度，因此只有在绝对必要时才应使用。区块处理程序支持的过滤器为：<code>specVersion</code>、<code>modulo</code>和<code>timestamp</code>。</p> Filter Description Example <code>specVersion</code> 过滤属于特定版本范围的区块 <code>specVersion: [null, 2000]</code> <code># 索引spec</code> <code>版本介于0 - 2000之间的区块</code> <code>modulo</code> 按一定间隔过滤区块 <code>modulo: 50 # 每50个区块建立索引</code> <code>timestamp</code> 按时间间隔（以 UTC 为单位）过滤区块。 接受有效的 cron 表达式 <code>timestamp: '*5/ * * * *'</code> <code># 每5分钟建立索引块</code> </li> <li> <p>事件处理程序用于索引属于运行时的特定Substrate事件。事件处理程序支持的过滤器为：<code>module</code>和<code>method</code>。</p> Filter Description Example <code>module</code> 过滤事件所属的pallet（模块） <code>module: 'balances'</code> <code>method</code> 过滤事件 <code>method: 'Transfer'</code> </li> <li> <p>调用处理程序用于索引某些Substrate外部因素。调用处理程序支持的过滤器为：<code>module</code>、<code>method</code>、<code>success</code>和<code>isSigned</code>。</p> Filter Description Example <code>module</code> 过滤外部因素所属的pallet（模块） <code>module: 'balances'</code> <code>method</code> 过滤外部因素 <code>method: 'Transfer'</code> <code>success</code> 基于结果过滤外部因素 <code>success: true</code> <code>isSigned</code> 根据外部因素是否已签名进行过滤 <code>isSigned: true</code> </li> </ul>"}, {"location": "builders/integrations/indexers/subquery/#index-ethereum-data", "title": "Index Ethereum Data", "text": "<p>The <code>project.ts</code> file is the entry point into your indexer; it defines what type of data to index and the mapping functions that are responsible for handling and processing the indexed data.</p> <p>To index Substrate data, you'll need to ensure that the type of the <code>project</code> is <code>SubstrateProject&lt;FrontierEvmDatasource&gt;</code>.</p> <p>```ts const project: SubstrateProject = { ... }"}, {"location": "builders/integrations/indexers/subquery/#the-evm-data-source", "title": "EVM数据源", "text": "<p>在 <code>project.dataSources</code> 数组中，您将定义EVM数据源和要编制索引的数据。EVM数据源由专门用于处理Moonbeam的Frontier实现的数据处理器提供支持。它允许您引用处理器使用的特定ABI资源来解析参数，以及事件来源或调用目标的智能合约地址。一般来说，它充当中间件，可以提供额外的过滤和数据转换。</p> <p>数据源的格式如下：</p> <p>ts datasources: [   {     kind: 'substrate/FrontierEvm',     startBlock: INSERT_START_BLOCK,     endBlock: INSERT_END_BLOCK,     processor: {       file: './node_modules/@subql/frontier-evm-processor/dist/bundle.js',       options: {         abi: '',         address: '',       },     },     assets: ''     mapping: {       file: './dist/index.js',       handlers: [         {           kind: 'INSERT_HANDLER_KIND',           handler: 'INSERT_HANDLER_FUNCTION_NAME',           filter: {             'INSERT_FILTER_TYPE': 'INSERT_FILTER',           },         },       ],     },   }, ],</p> <p>每个属性可以定义如下：</p> <ul> <li><code>kind</code>：您将使用的数据源类型，对于EVM数据，它是 <code>substrate/FrontierEVM</code> 源。</li> <li><code>startBlock</code>（可选）：索引器将从该区块开始处理区块。</li> <li><code>endBlock</code>（可选）：在此区块之后，索引器将停止处理区块。</li> <li><code>processor</code>：Frontier EVM数据处理器配置。<ul> <li><code>file</code>：数据处理器代码所在的⽂文件。</li> <li><code>options</code> (可选)：Frontier EVM处理器特有的处理器选项。<ul> <li><code>abi</code>（可选）：用于解析参数的ABI。<code>abi</code> 值必须是 <code>assets</code> 配置中的一个键。</li> <li><code>address</code>（可选）：事件发出的或调用发生的合约地址。使用 <code>null</code> 将捕获合约创建调用。</li> </ul> </li> <li><code>assets</code> (可选)：外部资产ABI文件的对象。</li> </ul> </li> <li><code>mapping</code>：要索引的数据和数据的处理程序。<ul> <li><code>file</code>：映射的入口路径。</li> <li><code>handlers</code>：特定类型数据的处理程序。<ul> <li><code>kind</code>：处理程序的种类。对于EVM数据，有两种类型：<code>substrate/FrontierEvmCall</code> 和 <code>substrate/FrontierEvmEvent</code>。</li> <li><code>handler</code>：将处理此数据的处理程序函数的名称。</li> <li><code>filter</code>（可选）：将触发映射处理程序的过滤器类型和数据。例如，要索引的块、事件或外部因素。</li> </ul> </li> </ul> </li> </ul>"}, {"location": "builders/integrations/indexers/subquery/#evm-mapping-handlers", "title": "Frontier EVM 映射處理程序", "text": "<p>僅使用某些處理程序和篩選器將提高索引器的效率。EVM 數據可用的處理程序如下所示：</p> <ul> <li> <p>Frontier EVM 呼叫處理程序 用於索引基於 Ethers <code>TransactionResponse</code> 類型 格式化的交易，但略有不同。有關確切變更的資訊，請參閱 SubQuery 的文件。呼叫處理程序支援的篩選器包括：<code>function</code> 和 <code>from</code>。</p> Filter Description Example <code>function</code> 依函式簽章或選取器篩選呼叫 <code>function: '0x095ea7b3'</code> <code>function: 'approve(address to,uint256 value)'</code> <code>from</code> 依傳送交易的位址篩選呼叫 <code>from: '0x6bd193ee6d2104f14f94e2ca6efefae561a4334b'</code> </li> <li> <p>Frontier EVM 事件處理程序 用於索引特定 EVM 事件。事件處理程序支援的篩選器為：<code>topics</code>。</p> Filter Description Example <code>topics</code> 依主題篩選事件日誌，這遵循 Ethereum JSON-RPC 日誌篩選器 <code>topics: 'Transfer(address indexed from,address indexed to,uint256 value)'</code> </li> </ul>"}, {"location": "builders/integrations/indexers/subquery/#run-your-indexer", "title": "运行你的索引器", "text": "<p>要使用 Docker 在本地运行你的索引器，你可以采取以下步骤：</p> <ol> <li> <p>构建你的项目：</p> npmyarn <p><code>bash npm run build</code></p> <p><code>bash yarn build</code></p> <p>  npm run build &gt; moonbeam-demo@0.0.4 build &gt; subql build Project manifest generated to /home/papermoon/moonbeam-demo/project.yaml Building and packing code ... Done! </p> <p>Note</p> <p>如果你更改了 <code>project.ts</code> 文件，你需要重新构建你的项目。</p> </li> <li> <p>启动索引器的 Docker 容器：</p> npmyarn <p><code>bash npm run start:docker</code></p> <p><code>bash yarn start:docker</code></p> <p> t found at block 171198 subquery-node_1  | 2025-04-07T04:29:52.601Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171203 subquery-node_1  | 2025-04-07T04:29:52.663Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.701Z &lt;benchmark&gt; INFO INDEXING: 3148.19 blocks/s. Target height: 5,105,255. Current height: 171,205. Estimated time remaining: 0 days 00 hours 26 mins subquery-node_1  | 2025-04-07T04:29:52.710Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.717Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.739Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.750Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.765Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.780Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.807Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.826Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.864Z &lt;sandbox-#3&gt; INFO New transfer event </p> </li> <li> <p>前往 <code>http://localhost:3000</code> 打开 GraphQL playground 并提交查询。你可以在 playground 上打开 DOCS 或 SCHEMA 选项卡，以在创建查询时作为参考。</p> <p>Note</p> <p>GraphQL 服务器可能需要几分钟才能准备好。在看到以下日志后，你就可以访问 playground：</p> <p><code>bash substrate-demo-graphql-engine-1  | &lt;subql-query&gt; INFO Started playground at `http://localhost:3000`</code></p> <p></p> </li> </ol> <p>就是这样！有关如何使用 <code>moonbeam-substrate-evm-starter</code> 模板项目的分步教程，你可以参考 SubQuery 的 Moonbeam (EVM) 快速入门文档。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/integrations/indexers/subsquid/", "title": "使用SQD（前身为Subsquid）索引Moonbeam", "text": ""}, {"location": "builders/integrations/indexers/subsquid/#introduction", "title": "介绍", "text": "<p>SQD（前身为 Subsquid） 是一个数据网络，它允许使用 SQD 的去中心化数据湖和开源 SDK，从 100 多个链中快速且经济高效地检索区块链数据。简单来说，SQD 可以被认为是一个包含 GraphQL 服务器的 ETL（提取、转换和加载）工具。它支持全面的过滤、分页，甚至全文搜索功能。</p> <p>SQD 本身完全支持以太坊虚拟机（EVM）和 Substrate 数据。由于 Moonbeam 是一个基于 Substrate 且与 EVM 兼容的智能合约平台，因此 SQD 可用于索引基于 EVM 和 Substrate 的数据。SQD 提供 Substrate 存档和处理器以及 EVM 存档和处理器。Substrate 存档和处理器可用于索引 Substrate 和 EVM 数据。这允许开发人员从任何 Moonbeam 网络中提取链上数据，并在一个项目中处理 EVM 日志以及 Substrate 实体（事件、外部操作和存储项），并通过一个 GraphQL 端点提供结果数据。如果您只想索引 EVM 数据，建议使用 EVM 存档和处理器。</p> <p>本快速入门指南将向您展示如何使用 SQD 创建 Substrate 和 EVM 项目，并配置它以索引 Moonbeam 上的数据。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "builders/integrations/indexers/subsquid/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要开始使用 SQD，您需要具备以下条件：</p> <ul> <li>Node.js 16 或更高版本</li> <li>Docker</li> <li>Squid CLI</li> </ul> <p>Note</p> <p>Squid 模板与 <code>yarn</code> 不兼容，因此您需要改用 <code>npm</code>。</p>"}, {"location": "builders/integrations/indexers/subsquid/#index-substrate-calls-events", "title": "在 Moonbeam 上索引 Substrate 数据", "text": "<p>要开始在 Moonbeam 上索引 Substrate 数据，您需要创建一个 SQD 项目，并通过执行以下步骤将其配置为 Moonbeam：</p> <ol> <li> <p>通过运行以下命令，创建一个基于 Substrate 模板的 SQD 项目：</p> <pre><code>sqd init INSERT_SQUID_NAME --template substrate\n</code></pre> <p>有关开始使用此模板的更多信息，请查看 SQD 文档站点上的 快速入门：Substrate 链 指南。</p> </li> <li> <p>导航到您的 Squid 项目的根目录，并通过运行以下命令安装依赖项：</p> <pre><code>npm ci\n</code></pre> </li> <li> <p>要配置您的 SQD 项目以在 Moonbeam 上运行，您需要更新 <code>typegen.json</code> 文件。<code>typegen.json</code> 文件负责为您的数据生成 TypeScript 接口类。根据您在其上索引数据的网络，<code>typegen.json</code> 文件中的 <code>specVersions</code> 值应配置如下：</p> MoonbeamMoonriverMoonbase Alpha </li> <li> <p>修改 <code>src/processor.ts</code> 文件，Squids 在其中实例化处理器、配置处理器并附加处理函数。处理器从 Archive 中提取历史链上数据，这是一个专门的数据湖。您需要配置您的处理器以从与您正在索引数据的 网络 对应的 Archive 中提取数据：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>const processor = new SubstrateBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_API_ENDPOINT',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonbeam-mainnet'\n  archive: lookupArchive('moonbeam', {type: 'Substrate', release: 'ArrowSquid'}),\n})\n</code></pre> <pre><code>const processor = new SubstrateBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_API_ENDPOINT',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonriver-mainnet'\n  archive: lookupArchive('moonriver', {type: 'Substrate', release: 'ArrowSquid'}),\n})\n</code></pre> <pre><code>const processor = new SubstrateBatchProcessor();\nprocessor.setDataSource({\n  chain: 'https://rpc.api.moonbase.moonbeam.network',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonbase-testnet'\n  archive: lookupArchive('moonbase', {type: 'Substrate', release: 'ArrowSquid'}),\n})\n</code></pre> <p>Note</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> </li> <li> <p>还有一项快速更改需要对模板进行。SQD Substrate 模板配置为处理 Substrate 帐户类型，但 Moonbeam 使用以太坊样式的帐户。<code>src/main.ts</code> 文件中的 <code>getTransferEvents</code> 函数将迭代 <code>processor.ts</code> 提取的事件，并将相关的 <code>transfer</code> 事件存储在数据库中。在 <code>getTransferEvents</code> 函数中，删除 <code>from</code> 和 <code>to</code> 字段的 ss58 编码。在未修改的 Substrate 模板中，<code>from</code> 和 <code>to</code> 字段按如下所示进行 ss58 编码：</p> <pre><code>from: ss58.codec('kusama').encode(rec.from),\nto: ss58.codec('kusama').encode(rec.to),\n</code></pre> <p>删除 ss58 编码后，相应的行是：</p> <pre><code>from: rec.from, \nto: rec.to, \n</code></pre> </li> </ol> <p>这就是配置您的 SQD 项目以在 Moonbeam 上索引 Substrate 数据所需要做的全部工作！现在，您可以更新 <code>schema.graphql</code>、<code>typegen.json</code>、<code>src/main.ts</code> 和 <code>src/processor.ts</code> 文件，以索引您的项目所需的数据！接下来，按照 运行您的索引器 部分中的步骤运行您的索引器并查询您的 Squid。</p>"}, {"location": "builders/integrations/indexers/subsquid/#index-ethereum-contracts", "title": "在 Moonbeam 上索引以太坊数据", "text": "<p>要开始在 Moonbeam 上索引 EVM 数据，您需要创建一个 SQD 项目，并通过以下步骤将其配置为 Moonbeam：</p> <ol> <li> <p>您可以使用通用的 EVM 模板 创建一个用于 EVM 数据的 SQD 项目，或者您可以使用 ABI 模板 索引与特定合约相关的数据：</p> EVM <p>bash sqd init INSERT_SQUID_NAME --template evm</p> <p>===</p> <pre><code>bash\nsqd init INSERT_SQUID_NAME --template abi\n</code></pre> <p>有关开始使用这两个模板的更多信息，请查看以下 SQD 文档：</p> <ul> <li>快速入门：EVM 链</li> <li>快速入门：从 ABI 生成</li> </ul> </li> <li> <p>导航到您的 Squid 项目的根目录，并通过运行以下命令安装依赖项：</p> <p>bash npm ci</p> </li> <li> <p>修改 <code>src/processor.ts</code> 文件，Squid 在其中实例化处理器、配置处理器并附加处理函数。处理器从 Archive 中获取历史链上数据，这是一个专门的数据湖。您需要配置您的处理器以从与您正在索引数据的 网络 对应的 Archive 中提取数据：</p> MoonbeamMoonriverMoonbase Alpha <p>ts const processor = new EvmBatchProcessor(); processor.setDataSource({   chain: 'INSERT_RPC_API_ENDPOINT',   // Resolves to 'https://v2.archive.subsquid.io/network/moonbeam-mainnet'   archive: lookupArchive('moonbeam', { type: 'EVM' }) })</p> <p>ts const processor = new EvmBatchProcessor(); processor.setDataSource({   chain: 'INSERT_RPC_API_ENDPOINT',   // Resolves to 'https://v2.archive.subsquid.io/network/moonriver-mainnet'   archive: lookupArchive('moonriver', { type: 'EVM' }), })</p> <p>ts const processor = new EvmBatchProcessor(); processor.setDataSource({   chain: 'https://rpc.api.moonbase.moonbeam.network',   // Resolves to 'https://v2.archive.subsquid.io/network/moonbase-testnet'   archive: lookupArchive('moonbase', { type: 'EVM' }), })</p> <p>Note</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> </li> </ol> <p>这就是配置您的 SQD 项目以在 Moonbeam 上索引 EVM 数据所需的全部操作！现在您可以更新 <code>schema.graphql</code>、<code>src/main.ts</code> 和 <code>src/processor.ts</code> 文件，以索引您项目所需的数据！继续执行下一节中的步骤以运行您的索引器并查询您的 Squid。</p>"}, {"location": "builders/integrations/indexers/subsquid/#run-your-indexer", "title": "运行您的索引器", "text": "<p>这些步骤适用于 Substrate 和 EVM 索引器。在正确配置 SQD 索引器后，只需几个步骤即可运行它：</p> <ol> <li> <p>通过运行以下命令启动 Postgres：</p> <pre><code>sqd up\n</code></pre> </li> <li> <p>检查并运行处理器：</p> <pre><code>sqd process\n</code></pre> </li> <li> <p>在同一目录中打开一个单独的终端窗口，然后启动 GraphQL 服务器：</p> <pre><code>sqd serve\n</code></pre> </li> <li> <p>您可以使用以下示例查询查询您的模板 Substrate 或 EVM Squid。如果您修改了模板 Squid 来索引不同的数据，则需要相应地修改此查询</p> Substrate 索引器EVM 索引器 <pre><code>query MyQuery {\n  accountsConnection(orderBy: id_ASC) {\n    totalCount\n  }\n}\n</code></pre> <pre><code>query MyQuery {\n  burns(orderBy: value_DESC) {\n    address\n    block\n    id\n    txHash\n    value\n  }\n}\n</code></pre> </li> </ol> <p>有关其他示例和工作流程，请参阅 SQD 文档。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/integrations/oracles/api3/", "title": "使用 API3 在 Moonbeam 上请求链下数据", "text": ""}, {"location": "builders/integrations/oracles/api3/#introduction", "title": "简介", "text": "<p>API3 是一个去中心化解决方案，旨在以易于访问和可扩展的方式向智能合约平台提供传统的 API 服务。它由去中心化自治组织 (DAO) API3 DAO 管理。API3 使开发人员能够从他们的智能合约中访问链下资源，而无需担心安全问题。API3 通过 Airnode（第一方预言机）和来自这些预言机的链上数据流来实现这一点。</p> <p>开发人员可以使用 Airnode 在 Moonbeam 网络上的智能合约中请求链下数据。Airnode 是一种第一方预言机，可将链下 API 数据推送到您的链上合约。Airnode 让 API 提供商可以轻松运行自己的第一方预言机节点。这样，他们可以向任何对其服务感兴趣的链上 dApp 提供数据，而无需中介。</p> <p>链上智能合约请求 RRP（请求响应协议） 合约（<code>AirnodeRrpV0.sol</code>），该合约将请求添加到事件日志中。然后，Airnode 访问事件日志，获取 API 数据，并使用所请求的数据对请求者执行回调。</p> <p></p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "builders/integrations/oracles/api3/#calling-an-airnode", "title": "从 Airnode 请求链下数据", "text": "<p>请求链下数据本质上包括触发 Airnode 并通过您的智能合约获取其响应。 在这种情况下，智能合约将是请求者合约，它将向所需的链下 Airnode 发出请求，然后捕获其响应。</p> <p>请求者调用 Airnode 主要侧重于两个任务：</p> <ul> <li>发出请求</li> <li>接受和解码响应</li> </ul> <p></p> <p>以下是从 Airnode 请求数据的基本请求者合约的示例：</p> <p>solidity // SPDX-License-Identifier: MIT pragma solidity 0.8.9;</p> <p>import \"@api3/airnode-protocol/contracts/rrp/requesters/RrpRequesterV0.sol\"; import \"@openzeppelin/contracts@4.9.5/access/Ownable.sol\";</p> <p>// 一个将通过调用指定的 Airnode 返回所请求数据的 Requester。 contract Requester is RrpRequesterV0, Ownable {     mapping(bytes32 =&gt; bool) public incomingFulfillments;     mapping(bytes32 =&gt; int256) public fulfilledData;</p> <pre><code>// 确保在部署合约时为您的链指定正确的 _rrpAddress。\nconstructor(address _rrpAddress) RrpRequesterV0(_rrpAddress) {}\n\n// 用于从赞助商钱包接收资金并将其发送给所有者。\nreceive() external payable {\n    payable(owner()).transfer(address(this).balance);\n}\n\n// 将触发 Airnode 请求的主要 makeRequest 函数。\nfunction makeRequest(\n    address airnode,\n    bytes32 endpointId,\n    address sponsor,\n    address sponsorWallet,\n    bytes calldata parameters\n\n) external {\n    bytes32 requestId = airnodeRrp.makeFullRequest(\n        airnode,                        // airnode 地址\n        endpointId,                     // endpointId\n        sponsor,                        // 赞助商的地址\n        sponsorWallet,                  // 赞助商钱包\n        address(this),                  // fulfillAddress\n        this.fulfill.selector,          // fulfillFunctionId\n        parameters                      // 编码的 API 参数\n    );\n    incomingFulfillments[requestId] = true;\n}\n\nfunction fulfill(bytes32 requestId, bytes calldata data)\n    external\n    onlyAirnodeRrp\n{\n    require(incomingFulfillments[requestId], \"No such request made\");\n    delete incomingFulfillments[requestId];\n    int256 decodedData = abi.decode(data, (int256));\n    fulfilledData[requestId] = decodedData;\n}\n\n// 用于从赞助商钱包中提款到合约。\nfunction withdraw(address airnode, address sponsorWallet) external onlyOwner {\n    airnodeRrp.requestWithdrawal(\n    airnode,\n    sponsorWallet\n    );\n}\n</code></pre> <p>}</p> <p>您还可以尝试在 Remix 上部署示例合约。</p>"}, {"location": "builders/integrations/oracles/api3/#contract-addresses", "title": "合约地址", "text": "<p><code>_rrpAddress</code> 是主要的 <code>airnodeRrpAddress</code>。RRP 合约已部署在链上。<code>_rrpAddress</code> 的地址 在 Moonbeam 网络上如下所示：</p> <p>===</p> 合约 地址 AirnodeRrpV0 <code>0xa0AD79D995DdeeB18a14eAef56A549A04e3Aa1Bd</code> <p>===</p> 合约 地址 AirnodeRrpV0 <code>0xa0AD79D995DdeeB18a14eAef56A549A04e3Aa1Bd</code> <p>===</p> 合约 地址 AirnodeRrpV0 <code>0xa0AD79D995DdeeB18a14eAef56A549A04e3Aa1Bd</code>"}, {"location": "builders/integrations/oracles/api3/#request-params", "title": "请求参数", "text": "<p><code>makeRequest()</code> 函数需要以下参数才能发出有效的请求：</p> <ul> <li><code>airnode</code> - 指定 Airnode 地址</li> <li><code>endpointId</code> - 指定要使用的端点</li> <li><code>sponsor</code> 和 <code>sponsorWallet</code> - 指定将用于完成请求的钱包</li> <li><code>parameters</code> - 指定 API 和预留参数（有关这些参数的编码方式，请参阅 Airnode ABI 规范）。可以使用 <code>@airnode-abi</code> 库在链下对参数进行编码</li> </ul>"}, {"location": "builders/integrations/oracles/api3/#response-params", "title": "响应参数", "text": "<p>对请求者合约的回调包含两个参数：</p> <ul> <li><code>requestId</code> - 首次在发出请求时获得，并在此处传递，作为标识预期响应的请求的引用</li> <li><code>data</code> - 如果响应成功，这是请求的数据编码，除了其他响应数据外，还包含时间戳。 使用 <code>abi</code> 对象中的 <code>decode()</code> 函数对其进行解码</li> </ul> <p>Note</p> <p>赞助商不应对 <code>sponsorWallet</code> 注入超出他们对 Airnode 的信任范围的资金，因为 Airnode 控制着 <code>sponsorWallet</code> 的私钥。 此类 Airnode 的部署者不承担任何保管义务，发送到 <code>sponsorWallet</code> 的任何超额资金的损失或滥用风险由赞助商承担。</p>"}, {"location": "builders/integrations/oracles/api3/#dapis", "title": "dAPIs：API3 数据馈送", "text": "<p>dAPIs 是链下数据的持续更新流，例如最新的加密货币、股票和大宗商品价格。它们可以为去中心化应用程序提供支持，例如 DeFi 借贷、合成资产、稳定币、衍生品、NFT 等。</p> <p>数据馈送由第一方预言机使用签名数据持续更新。DApp 所有者可以实时读取任何 dAPI 的链上值。</p> <p>由于它们由第一方数据馈送组成，因此 dAPI 以统包方式提供安全性、透明度、成本效益和可扩展性。</p> <p></p> <p>要了解有关 dAPI 工作原理的更多信息，请参阅 API3 的文档。</p>"}, {"location": "builders/integrations/oracles/api3/#subscribing-to-dapis", "title": "订阅 dAPI", "text": "<p>通过 API3 市场，用户可以在 Moonbeam、Moonriver 和 Moonbase Alpha TestNet（目前标记为 Moonbeam TestNet）上访问 dAPI。</p> <p>从 API3 市场主页 上，您可以搜索给定的链。选择链后，您可以查看可用 dAPI的列表，然后点击一个以获取更多信息。例如，您可以点击适用于 Moonbeam 的 <code>USDT/USD</code> 交易对，以查看 dAPI 的参数，包括偏差和心跳。</p> <p>dAPI 支持的参数包括：</p> 偏差 心跳 0.25% 24 小时 0.5% 24 小时 1% 24 小时 5% 24 小时 <p></p>"}, {"location": "builders/integrations/oracles/api3/#select-a-dapi", "title": "配置和激活 dAPI", "text": "<p>选择要交互的 dAPI 后，请检查到期日期并根据需要更新参数。您可以通过购买新的配置来更新参数并延长订阅。如果 dAPI 已激活并且列出的配置适用于您，则可以跳到下一节，了解如何与 dAPI 交互。</p> <p>要购买具有新配置的套餐，请单击购买新套餐并执行以下步骤：</p> <ol> <li>选择您的参数</li> <li>单击连接钱包</li> </ol> <p></p> <p>连接后，您就可以购买新的套餐了。单击购买并签署交易。交易确认后，您将能够看到 dAPI 的更新配置。</p>"}, {"location": "builders/integrations/oracles/api3/#get-data", "title": "从 dAPI 获取数据", "text": "<p>要与 dAPI 交互，您需要获取它的代理地址。点击 dAPI 详细信息页面上的 Integrate 按钮。然后在集成页面上，复制代理地址。</p> <p></p> <p>有了代理地址，您就可以将 dAPI 集成到智能合约中。这是一个从 dAPI 读取数据的基本合约示例：</p> <p>solidity // SPDX-License-Identifier: MIT pragma solidity 0.8.17;</p> <p>import \"@openzeppelin/contracts@4.9.5/access/Ownable.sol\"; import \"@api3/contracts/api3-server-v1/proxies/interfaces/IProxy.sol\";</p> <p>contract DataFeedReaderExample is Ownable {     // 从 API3 Market UI 获取的代理合约地址     address public proxyAddress;</p> <pre><code>// 更新代理合约地址是一项安全性至关重要的操作。\n// 在此示例中，只有所有者才能执行此操作\nfunction setProxyAddress(address _proxyAddress) public onlyOwner {\n    proxyAddress = _proxyAddress;\n}\n\nfunction readDataFeed()\n    external\n    view\n    returns (int224 value, uint256 timestamp)\n{\n    // 使用 IProxy 接口通过其\n    // 代理合约读取 dAPI\n    (value, timestamp) = IProxy(proxyAddress).read();\n    // 如果您对“value”和“timestamp”有任何假设，\n    // 请务必在从代理读取后验证它们\n}\n</code></pre> <p>}</p> <p>示例合约包含两个函数：</p> <ul> <li><code>setProxyAddress()</code> - 用于设置 dAPI 代理合约的地址</li> <li><code>readDataFeed()</code> - 一个 <code>view</code> 函数，它返回设置的 dAPI 的最新价格</li> </ul> <p>尝试在 Remix 上部署它！</p>"}, {"location": "builders/integrations/oracles/api3/#additional-resources", "title": "更多资源", "text": "<p>以下是一些额外的开发者资源：</p> <ul> <li>API3 市场</li> <li>API3 文档</li> <li>API3 DAO GitHub</li> <li>API3 Medium</li> <li>API3 YouTube</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/integrations/oracles/dia/", "title": "DIA 预言机介绍", "text": ""}, {"location": "builders/integrations/oracles/dia/#introduction", "title": "简介", "text": "<p>DIA 提供可定制的预言机，这些预言机根据每个 dApp 的需求量身定制。每个预言机都可以通过多种方式进行定制，包括数据源、数据清理过滤器、定价和计算方法、更新机制等等。这确保了数据和预言机在市场条件下保持稳健和弹性，并提供全球市场价格以及特定的个人或跨链市场价格。</p> <p>通过直接从 90 多个来源（包括 CEX、DEX 和 NFT 市场）收集数十亿条原始交易，DIA 能够在整个价值堆栈中实现完全透明、定制和控制。DIA 的数据和预言机套件包含 20,000 多种资产的价格馈送，包括加密货币、NFT 系列和流动性质押代币，以及随机数生成和其他数据馈送类型。</p> <p>您可以访问 DIA 的文档，了解如何请求自定义预言机。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "builders/integrations/oracles/dia/#token-price-feeds", "title": "Token Price Feeds", "text": "<p>DIA 代币价格信息流为智能合约提供 3,000 多种加密货币 的实时价格信息，这些信息透明地来源于 90 多个受信任的高交易量 DEX 和 CEX。</p>"}, {"location": "builders/integrations/oracles/dia/#moonbeam-demo-price-oracles", "title": "Moonbeam 演示价格预言机", "text": "<p>DIA 为 Moonbeam 社区部署了以下演示预言机，这些预言机提供有限数量的加密货币价格馈送，并具有预定义的配置设置：</p> 网络 合约地址 Moonbeam <code>0x1f1BAe8D7a2957CeF5ffA0d957cfEDd6828D728f</code> Moonriver <code>0x11f74b94afb5968119c98ea277a2b73208bb39ab</code> Moonbase Alpha <code>0xe23d8713aa3a0a2c102af772d2467064821b8d46</code> <p>部署到 Moonbeam 的演示预言机合约是 DIA 键值预言机合约 V2。 合约结构如下：</p> <p>solidity pragma solidity 0.7.4;</p> <p>contract DIAOracleV2 {     mapping (string =&gt; uint256) public values;     address oracleUpdater;</p> <pre><code>event OracleUpdate(string key, uint128 value, uint128 timestamp);\nevent UpdaterAddressChange(address newUpdater);\n\nconstructor() {\n    oracleUpdater = msg.sender;\n}\n\nfunction setValue(string memory key, uint128 value, uint128 timestamp) public {\n    require(msg.sender == oracleUpdater);\n    uint256 cValue = (((uint256)(value)) &lt;&lt; 128) + timestamp;\n    values[key] = cValue;\n    emit OracleUpdate(key, value, timestamp);\n}\n\nfunction getValue(string memory key) external view returns (uint128, uint128) {\n    uint256 cValue = values[key];\n    uint128 timestamp = (uint128)(cValue % 2**128);\n    uint128 value = (uint128)(cValue &gt;&gt; 128);\n    return (value, timestamp);\n}\n\nfunction updateOracleUpdaterAddress(address newOracleUpdaterAddress) public {\n  require(msg.sender == oracleUpdater);\n    oracleUpdater = newOracleUpdaterAddress;\n    emit UpdaterAddressChange(newOracleUpdaterAddress);\n}\n</code></pre> <p>}</p> <p>Note</p> <p>DIA 演示预言机不适用于生产环境。 开发人员可以请求具有自定义价格馈送和配置设置的专用、可用于生产的预言机。 要启动请求过程，您可以查看 请求自定义预言机 文档。</p>"}, {"location": "builders/integrations/oracles/dia/#price-feeds", "title": "包含的价格馈送", "text": "<p>演示 oracle 中包含的价格馈送是：</p> <ul> <li>DIA/USD</li> <li>BTC/USD</li> <li>USDC/USD</li> </ul>"}, {"location": "builders/integrations/oracles/dia/#how-to-access-dia-oracles", "title": "如何访问 DIA 预言机", "text": "<p>访问 DIA 预言机上的价格值的步骤如下：</p> <ol> <li>在 Moonbeam 上访问您的预言机智能合约。</li> <li>使用 <code>pair_name</code> 调用 <code>getValue(pair_name)</code>，<code>pair_name</code> 是完整的货币对名称，例如 <code>BTC/USD</code>。您可以使用 Moonscan 上合约的合约选项卡下的读取合约功能来执行此调用。</li> </ol> <p>响应包含两个值：</p> <ul> <li>当前资产价格（美元），采用具有 8 位小数的定点逗号表示法。</li> <li>上次预言机更新的 UNIX 时间戳。</li> </ul> <p>您可以通过访问 DIA 文档站点上的获取价格数据 指南，找到 DIA 的 Solidity 和 Vyper 语言的预言机集成示例。</p>"}, {"location": "builders/integrations/oracles/dia/#supported-token-api-endpoints", "title": "支持的 Token API 端点", "text": "<p>DIA 还支持 Rest 和 GraphQL 端点以返回加密货币价格数据。您可以访问 DIA 文档以查看所有 API 端点。</p> <p>例如，您可以使用以下 JavaScript 脚本来访问 BTC/USD 价格馈送：</p> <p>===\"Rest\"</p> <pre><code>```js\nconst axios = require('axios');\n\nconst options = {\n  method: 'GET',\n  url: 'https://api.diadata.org/v1/assetQuotation/Bitcoin/0x0000000000000000000000000000000000000000',\n  headers: { 'Content-Type': 'application/json' },\n};\n\naxios\n  .request(options)\n  .then(function (response) {\n    console.log(response.data);\n  })\n  .catch(function (error) {\n    console.error(error);\n  });\n```\n</code></pre> <p>===\"GraphQL\"</p> <pre><code>```js\nconst axios = require('axios');\n\nconst url = 'https://api.diadata.org/graphql/query';\n\nconst query = `\n  {\n    GetFeed(\n      Filter: \"mair\",\n      BlockSizeSeconds: 480,\n      BlockShiftSeconds: 480,\n      StartTime: 1690449575,\n      EndTime: 1690535975,\n      FeedSelection: [\n        {\n          Address: \"0x0000000000000000000000000000000000000000\",\n          Blockchain:\"Bitcoin\",\n          Exchangepairs:[],\n        },\n      ],\n    )\n    {\n      Name\n      Time\n      Value\n      Pools\n      Pairs\n    }\n  }`;\n\nconst data = {\n  query: query,\n};\n\naxios\n  .post(url, data)\n  .then((response) =&gt; {\n    console.log(response.data);\n  })\n  .catch((error) =&gt; {\n    console.error('Request failed:', error.message);\n  });\n```\n</code></pre> <p>您可以参考 DIA 关于 Rest API 端点和 GraphQL 端点的文档，以获取有关参数和返回数据的信息。</p>"}, {"location": "builders/integrations/oracles/dia/#nft-floor-price-feeds", "title": "NFT底价信息流", "text": "<p>DIA NFT底价信息流为智能合约提供18,000+ NFT藏品的实时价格信息，这些信息100%透明地来源于链上，数据出自多个跨链NFT市场。</p> <p>请参考DIA的文档，了解如何为Moonbeam上的NFT请求自定义NFT预言机。</p>"}, {"location": "builders/integrations/oracles/dia/#random-number-generation", "title": "随机数生成", "text": "<p>DIA xRandom 为智能合约提供不可预测且无偏的随机数，从而促进链上用例的开发，例如彩票、预测市场、NFT 发布等。</p> <p>DIA 利用 Drand 公共随机信标，并使用 round 数字、随机性和签名来更新其预言机。Drand 运行分布式节点以生成其随机信标。Drand 使用 Pedersen 的 DKG（分布式密钥生成）协议 来创建集体私钥和公钥。然后，他们的熵联盟的参与者会分轮生成随机数，并将其及其签名一起广播。</p> <p>要了解有关 Drand 随机信标的更多信息，请观看 链上随机预言机 | DIA 开发者教程 并阅读 Drand 的文档。</p> <p>{   \"source_path\": \"builders/integrations/oracles/dia.md\",   \"source_language\": \"EN\",   \"target_language\": \"ZH\",   \"checksum\": \"2d5c6fcb4a0319e82f20f72c8d15e51625082ec9497e86d8a5385a39f4506b93\",   \"content\": \"### Moonbeam Demo Randomness Oracle {: #moonbeam-demo-randomness-oracle }\\n\\nDIA has deployed a demo oracle on Moonbase Alpha, which can be accessed at the following address:\\n\\n``` 0x48d351ab7f8646239bbade95c3cc6de3ef4a6cec</p>"}, {"location": "builders/integrations/oracles/dia/#how-to-use-the-dia-randomness-oracle", "title": "如何使用 DIA 随机数预言机", "text": "<p>访问已发布的随机值的步骤如下：</p> <ol> <li>在 Moonbeam 上访问您的随机数预言机智能合约。</li> <li>调用 <code>getLastRound()</code> 以获取最新发布轮次的 ID。您可以使用 Moonscan 上合约合约选项卡下的读取合约功能来执行此调用。</li> <li>使用获得的轮次 ID 调用 <code>getRandomValueFromRound(uint256 _round)</code>。同样，您可以使用 Moonscan 快速执行此调用。</li> </ol> <p>响应包含随机数值。</p> <p>也可以通过调用 <code>getRandomValueFromRoundWithSignature(uint256 _round)</code> 来请求签名，这将返回一个包含随机数值、签名和上一轮签名的元组。</p> <p>要了解如何在 Moonbeam 上部署使用随机数的合约，请参阅在 EVM 链上使用 DIA xRandom Oracle 部署使用随机数的智能合约视频教程。</p>"}, {"location": "builders/integrations/oracles/dia/#resources", "title": "资源", "text": "<ul> <li>X</li> <li>Discord</li> <li>网站</li> <li>文档</li> <li>探索数据</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/integrations/oracles/supra/", "title": "Supra 预言机", "text": ""}, {"location": "builders/integrations/oracles/supra/#introduction", "title": "简介", "text": "<p>Supra 是一个新型、高吞吐量的预言机和层内：一个垂直整合的跨链解决方案工具包（数据预言机、资产桥、自动化网络等），可互连所有区块链，包括公有链（L1 和 L2）或私有链（企业），包括 Moonbeam。</p> <p>Supra 提供去中心化的预言机价格 Feeds，可用于链上和链下用例，例如现货和永续 DEX、借贷协议和支付协议。</p> <p>本页面提供您在 Moonbeam 上开始使用 Supra 所需的一切。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "builders/integrations/oracles/supra/#price-feeds", "title": "如何使用 Supra 的价格 Feed", "text": "<p>Supra 采用拉取模型作为一种定制方法，可以根据请求发布价格数据。它结合了 Web2 和 Web3 方法，以在将数据从 Supra 发送到目标链时实现低延迟。该过程包括以下步骤：</p> <ol> <li>Web2 方法用于从 Supra 检索价格数据。</li> <li>智能合约用于以加密方式验证并将最新的价格数据写入链上，这些数据存储在使用 Supra 的拉取 Oracle V1 的不可变账本上。</li> <li>一旦数据被写入链上，最近发布的价格 Feed 数据将可以在 Supra 的存储合约中使用。</li> </ol> <p>Supra 在 Moonbeam 上的合约地址如下：</p> <p>===\"Moonbeam\"</p> <pre><code>|  Contract   |                                                               Address                                                               |\n|:-----------:|:-----------------------------------------------------------------------------------------------------------------------------------:|\n| Pull Oracle | [0x2FA6DbFe4291136Cf272E1A3294362b6651e8517](https://moonscan.io/address/0x2FA6DbFe4291136Cf272E1A3294362b6651e8517){target=_blank} |\n|   Storage   |     [0xD02cc7a670047b6b012556A88e275c685d25e0c9](https://moonscan.io/address/0xD02cc7a670047b6b012556A88e275c685d25e0c9){target=_blank}     |\n</code></pre> <p>===\"Moonbase Alpha\"</p> <pre><code>|  Contract   |                                                                   Address                                                                    |\n|:-----------:|:--------------------------------------------------------------------------------------------------------------------------------------------:|\n| Pull Oracle | [0xaa2f56843Cec7840F0C106F0202313d8d8CB13d6](https://moonbase.moonscan.io/address/0xaa2f56843Cec7840F0C106F0202313d8d8CB13d6){target=_blank} |\n|   Storage   |     [0x4591d1B110ad451d8220d82252F829E8b2a91B17](https://moonbase.moonscan.io/address/0x4591d1B110ad451d8220d82252F829E8b2a91B17){target=_blank}     |\n</code></pre> <p>Note</p> <p>目前不支持 Moonriver。</p>"}, {"location": "builders/integrations/oracles/supra/#list-of-available-price-feeds", "title": "可用价格信息列表", "text": "<p>要查看 Supra 提供的可用数据对的完整列表，请查看他们文档站点上的数据信息目录。</p> <p>要与任何这些数据对进行交互，您需要记下该对的 Pair ID。</p>"}, {"location": "builders/integrations/oracles/supra/#try-it-out", "title": "尝试一下", "text": "<p>按照上一节中提到的步骤，或参考Supra 文档，尝试一个使用 Supra 拉取模型获取价格数据的基本示例。</p>"}, {"location": "builders/integrations/oracles/supra/#connect-with-supra", "title": "与 Supra 建立连接", "text": "<p>仍在寻找答案？Supra 已经有了！查看您可以联系 Supra 团队的所有方式：</p> <ul> <li>访问 Supra 的网站 supraoracles.com。</li> <li>阅读他们的文档。</li> <li>在 Telegram 上与他们聊天。</li> <li>在 X 上关注他们。</li> <li>加入他们的 Discord。</li> <li>查看他们的 Youtube。</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/interoperability/mrl/", "title": "Moonbeam 路由流动性", "text": ""}, {"location": "builders/interoperability/mrl/#introduction", "title": "Introduction", "text": "<p>Moonbeam 路由流动性 (MRL) 是指 Moonbeam 连接的任何区块链生态系统中的流动性都可以路由到 Polkadot 平行链的使用案例。这之所以成为可能，是因为多个组件协同工作：</p> <ul> <li>通用消息传递 (GMP) - 连接包括 Moonbeam 在内的多个区块链的技术。借助它，开发人员可以传递带有任意数据的消息，并且可以通过与链无关的 GMP 协议跨非平行链区块链发送代币</li> <li>跨共识消息传递 (XCM) - Polkadot 的 GMP 版本。驱动 Polkadot 及其平行链（包括 Moonbeam）之间跨链互动的主要技术</li> <li>支持 XCM 的 ERC-20 - 也称为本地 XC-20，是指 Moonbeam EVM 上存在的所有现成的支持 XCM 的 ERC-20 代币</li> <li>GMP 预编译 - 预编译合约，它充当从 Wormhole GMP 协议传递的消息与 XCM 之间的接口</li> </ul> <p>这些组件组合在一起，通过 Moonbeam 提供到平行链的无缝流动性路由。可以使用GMP 预编译或与 XCM 相关的预编译（如 X-Tokens 预编译）交互的传统智能合约将流动性路由到平行链。</p> <p>GMP 协议通常以锁定/铸造或销毁/铸造的方式移动资产。这种流动性通常以 ERC-20 代币的形式存在于 Moonbeam 上。Moonbeam 上的所有 ERC-20 现在都支持 XCM，这意味着只要它们在其他平行链上注册，它们现在就可以作为 XC-20 存在于任何其他平行链中。支持 XCM 的 ERC-20 在 Moonbeam 上被称为本地 XC-20。</p> <p>MRL 目前可以通过与 Wormhole 连接的链获得，但没有什么可以阻止平行链团队通过不同的 GMP 提供商实施类似的途径。</p> <p>本指南将主要介绍与 Wormhole 的 SDK 和接口集成，以便您的平行链可以通过 Moonbeam 访问来自非平行链区块链的流动性的过程。它还将介绍入门的要求以及通过 Wormhole 提供的代币。</p>"}, {"location": "builders/interoperability/mrl/#prerequisites", "title": "前提条件", "text": "<p>要开始将 MRL 与您的平行链集成，您首先需要：</p> <ul> <li>通过 HRMP 通道与 Moonbeam 建立跨链集成，以便资产可以从 Moonbeam 发送到您的平行链</li> <li>在您的平行链上注册 Moonbeam 的资产。这是必需的，因为发送用于资产转移的 XCM 消息的 pallet 存在临时缺陷，这使得 Moonbeam 的原生 Gas 资产成为唯一可用作返回路径上的跨链费用的资产</li> <li>注册您想要路由到您的平行链的本地 XC-20 代币<ul> <li>允许这些本地 XC-20 代币用于 XCM 费用</li> </ul> </li> <li>允许用户发送 <code>Transact</code> XCM 指令（通过 <code>polkadotXcm.Send</code> 或使用 XCM Transactor Pallet），这支持远程 EVM 调用，允许远程平行链上的帐户与 Moonbeam 上的桥接智能合约交互</li> </ul>"}, {"location": "builders/interoperability/mrl/#mrl-through-wormhole", "title": "通过虫洞的 MRL", "text": "<p>虽然 MRL 旨在包含许多不同的 GMP 提供商，但 Wormhole 是第一个为公众构建的。在您完成所有先决条件之后，要通过 Wormhole 接收流动性，您需要：</p> <ul> <li>通知 Moonbeam 团队您希望集成到 MRL 程序中，以便我们可以帮助您进行技术实施</li> <li>与 Wormhole 团队和其他依赖 MRL 的前端连接，以最终确定技术细节并同步公告。他们可能需要以下信息：<ul> <li>平行链 ID</li> <li>您的平行链使用的帐户类型（即 AccountId32 或 AccountKey20）</li> <li>您已注册的令牌的地址和名称</li> <li>Wormhole Connect 前端可以使用的端点</li> <li>为什么您希望您的平行链通过 Wormhole Connect 连接？</li> </ul> </li> </ul>"}, {"location": "builders/interoperability/mrl/#sending-tokens-through-wormhole", "title": "通过 Wormhole 将 Token 发送到平行链", "text": "<p>MRL 提供一键式解决方案，允许您将多位置定义为从任何具有 Wormhole Connect 集成的 Wormhole 链到达的资产的最终目的地。</p> <p>要通过 Wormhole 和 MRL 发送 Token，用户界面将混合使用 Wormhole TokenBridge 和 Moonbeam 的 GMP 预编译。</p> <p>转移流动性的用户将调用原始链的 Wormhole TokenBridge 智能合约部署上的 <code>transferTokensWithPayload</code> 方法，该合约实现 <code>ITokenBridge.sol</code> 接口以将 Token 发送到 GMP 预编译。此函数需要一个字节负载，格式化为 SCALE 编码的多位置对象，该对象包装在另一个预编译特定的版本化类型中。要了解如何构建此负载，请参阅 GMP 预编译文档的 构建 Wormhole 的负载部分。</p> <p>Wormhole 依赖于一组分布式节点，这些节点监控多个区块链上的状态。在 Wormhole 中，这些节点被称为 守护者。守护者的作用是观察消息并签署相应的负载。如果 2/3 的 Wormhole 签名守护者验证了特定消息，则该消息将被批准，并且可以在其他链上接收。</p> <p>守护者签名和消息构成一个名为 已验证操作批准 (VAA) 的证明。这些 VAA 由 Wormhole 网络中的 中继器 传递到其目的地。在目标链上，VAA 用于执行操作。在这种情况下，VAA 被传递到 GMP 预编译的 <code>wormholeTransferERC20</code> 函数中，该函数通过 Wormhole 桥合约（铸造 Token）处理 VAA，并使用 XCM 消息将 Token 中继到平行链。请注意，作为集成 MRL 的平行链，您可能不需要实施或使用 GMP 预编译。</p> <p>中继器的唯一工作是将 Wormhole 守护者批准的交易传递到目标链。MRL 已经得到一些中继器的支持，但任何人都可以运行一个。此外，用户可以在通过 Wormhole 桥接时手动执行他们在目标链中的交易，并完全避免中继器。</p> <p></p>"}, {"location": "builders/interoperability/mrl/#sending-tokens-back-through-wormhole", "title": "通过 Wormhole 将代币从平行链发送回去", "text": "<p>要将代币从平行链通过 Wormhole 发送回目标链，用户必须发送一笔交易，最好使用 <code>utility.batchAll</code> extrinsic，这将把代币转移和远程执行操作批量处理到一笔交易中。例如，包含 <code>xTokens.transferMultiassets</code> 调用和具有 <code>Transact</code> 指令的 <code>polkadotXcm.send</code> 调用的批处理。</p> <p>批量处理的原因是为了提供一键式解决方案。然而，目前，用户还必须拥有平行链上的 xcGLMR（GLMR 的表示）。原因主要有两个：</p> <ul> <li>本地 XC-20（支持 XCM 的 ERC-20）不能用于支付 Moonbeam 上的 XCM 执行费用。这是一个设计决策，因为我们更倾向于将它们视为 ERC-20 并利用 ERC-20 接口的本地 <code>transfer</code> 函数。因此，处理 XC-20 的 XCM 指令仅限于将资金从一个账户转移到另一个账户，并且不理解 XCM 流固有的 Holding Register</li> <li>目前，与 XCM 相关的 pallet 限制了 XCM 消息发送具有不同储备链的代币的能力。因此，您不能发送 XC-20 并将费用代币设置为原生平行链代币</li> </ul> <p>请注意，截至 2024 年底，X-Tokens 预编译现在在底层使用 Polkadot XCM pallet，取代了 X-Tokens pallet。使用不同 pallet 的平行链必须实施自己的解决方案，以在单个消息中转移储备和非储备资产。</p> <p>例如，将 MRL 代币从平行链通过 Wormhole 发送回目标链的整个过程的简要概述如下：</p> <ol> <li>使用 Utility pallet 的 <code>batchAll</code> extrinsic 发送一个批处理交易，其中包含以下两个调用。<ul> <li><code>xTokens.transferMultiassets</code> - 将 xcGLMR 和本地 XC-20 发送到用户的 Computed Origin 账户。Computed Origin 账户是 Moonbeam 上的一个无密钥账户，另一个平行链上的账户可以通过 XCM 控制该账户</li> <li><code>polkadotXcm.send</code> - 带有 <code>Transact</code> 指令。通过 XCM 向 Moonbeam 上的 Batch Precompile 发送远程 EVM 调用，该调用使用 <code>ethereumXcm.transact</code> extrinsic 将以下两个调用批处理到单个远程 EVM 交易中：<ul> <li><code>approve</code>（本地 XC-20 合约）- 批准 Wormhole 中继器转移本地 XC-20</li> <li><code>transferTokensWithRelay</code>（中继器合约）- 调用 Moonbeam 上 Wormhole TokenBridge 智能合约的 <code>transferTokensWithPayload</code> 函数来跨链转移代币，这将广播消息以供 Wormhole Guardians 接收</li> </ul> </li> </ul> </li> <li>Guardian Network 将接收 Wormhole 交易并对其进行签名</li> <li>Wormhole 中继器将代币中继到目标链和目标账户</li> </ol> <p></p> <p>现在您已经对总体规划有一个大致的了解，您可以开始实施它了。本指南中的示例将向您展示如何将资产从平行链转移到 Moonbase Alpha，然后再通过 Wormhole 转移回目标链，但本指南可以适用于 Moonbeam。</p>"}, {"location": "builders/interoperability/mrl/#calculate-computed-origin-account", "title": "计算计算源账户", "text": "<p>要通过 Wormhole 发送代币，您需要在 Moonbeam 上计算用户的计算源账户（以前称为多位置衍生账户）。这可以使用 xcm-tools 存储库 中的 <code>calculate-multilocation-derivative-account.ts</code> 脚本 离线完成。有关更多详细信息，您可以参考 计算源 指南。</p> <p>或者，也可以使用 XCM 实用程序预编译 的 <code>multilocationToAddress</code> 函数。</p>"}, {"location": "builders/interoperability/mrl/#create-a-project", "title": "创建一个项目", "text": "<p>您需要为本指南中将要构建的文件创建一个新的项目目录。请按照以下步骤设置您的项目：</p> <ol> <li> <p>创建一个新目录并进入该目录</p> <p>bash mkdir wormhole-mrl-demo &amp;&amp; cd wormhole-mrl-demo</p> </li> <li> <p>创建一个 <code>package.json</code> 文件：</p> <p>bash npm init -y</p> </li> <li> <p>安装构建远程 EVM 调用和 XCM extrinsic 所需的软件包</p> <p>bash npm i @polkadot/api ethers</p> </li> <li> <p>创建本指南所需的文件：</p> <ul> <li><code>build-transfer-multiassets-call.js</code> - 用于创建跨链传输资产的 <code>xTokens.transferMultiassets</code> extrinsic。它包含批量交易的第一个调用的逻辑</li> <li><code>build-remote-calldata.js</code> - 用于创建编码的 calldata，该 calldata 批准 Wormhole 中继器传输本地 XC-20，并通过 Wormhole TokenBridge 合约启动传输。这是批量交易的第二个调用所必需的</li> <li><code>build-remote-evm-call.js</code> - 用于创建执行远程 EVM 调用的 <code>polkadotXcm.send</code> extrinsic。它包含批量交易的第二个调用的逻辑</li> <li><code>send-batch-transaction.js</code> - 用于组装和发送资产转移和远程 EVM 调用的批量交易</li> </ul> <p>bash touch build-transfer-multiassets.js build-remote-calldata.js \\ build-remote-evm-call.js send-batch-transaction.js</p> </li> <li> <p>为您在本指南中将要使用的每个合约的 ABI 创建一个目录和文件：</p> <p>bash mkdir abi &amp;&amp; touch abi/ERC20.js abi/TokenRelayer.js abi/Batch.js</p> ERC-20 接口 ABI <p>js title=\"ERC20.js\" export default [   {     anonymous: false,     inputs: [       {         indexed: true,         internalType: 'address',         name: 'owner',         type: 'address',       },       {         indexed: true,         internalType: 'address',         name: 'spender',         type: 'address',       },       {         indexed: false,         internalType: 'uint256',         name: 'value',         type: 'uint256',       },     ],     name: 'Approval',     type: 'event',   },   {     anonymous: false,     inputs: [       {         indexed: true,         internalType: 'address',         name: 'from',         type: 'address',       },       {         indexed: true,         internalType: 'address',         name: 'to',         type: 'address',       },       {         indexed: false,         internalType: 'uint256',         name: 'value',         type: 'uint256',       },     ],     name: 'Transfer',     type: 'event',   },   {     inputs: [       {         internalType: 'address',         name: 'owner',         type: 'address',       },       {         internalType: 'address',         name: 'spender',         type: 'address',       },     ],     name: 'allowance',     outputs: [       {         internalType: 'uint256',         name: '',         type: 'uint256',       },     ],     stateMutability: 'view',     type: 'function',   },   {     inputs: [       {         internalType: 'address',         name: 'spender',         type: 'address',       },       {         internalType: 'uint256',         name: 'amount',         type: 'uint256',       },     ],     name: 'approve',     outputs: [       {         internalType: 'bool',         name: '',         type: 'bool',       },     ],     stateMutability: 'nonpayable',     type: 'function',   },   {     inputs: [       {         internalType: 'address',         name: 'account',         type: 'address',       },     ],     name: 'balanceOf',     outputs: [       {         internalType: 'uint256',         name: '',         type: 'uint256',       },     ],     stateMutability: 'view',     type: 'function',   },   {     inputs: [],     name: 'totalSupply',     outputs: [       {         internalType: 'uint256',         name: '',         type: 'uint256',       },     ],     stateMutability: 'view',     type: 'function',   },   {     inputs: [       {         internalType: 'address',         name: 'to',         type: 'address',       },       {         internalType: 'uint256',         name: 'amount',         type: 'uint256',       },     ],     name: 'transfer',     outputs: [       {         internalType: 'bool',         name: '',         type: 'bool',       },     ],     stateMutability: 'nonpayable',     type: 'function',   },   {     inputs: [       {         internalType: 'address',         name: 'from',         type: 'address',       },       {         internalType: 'address',         name: 'to',         type: 'address',       },       {         internalType: 'uint256',         name: 'amount',         type: 'uint256',       },     ],     name: 'transferFrom',     outputs: [       {         internalType: 'bool',         name: '',         type: 'bool',       },     ],     stateMutability: 'nonpayable',     type: 'function',   }, ];</p> TokenBridge 中继器 ABI <p>js title=\"TokenRelayer.js\" export default [   {     inputs: [       {         internalType: 'uint16',         name: 'targetChainId',         type: 'uint16',       },       {         internalType: 'address',         name: 'token',         type: 'address',       },       {         internalType: 'uint8',         name: 'decimals',         type: 'uint8',       },     ],     name: 'calculateRelayerFee',     outputs: [       {         internalType: 'uint256',         name: 'feeInTokenDenomination',         type: 'uint256',       },     ],     stateMutability: 'view',     type: 'function',   },   {     inputs: [       {         internalType: 'address',         name: 'token',         type: 'address',       },       {         internalType: 'uint256',         name: 'amount',         type: 'uint256',       },       {         internalType: 'uint256',         name: 'toNativeTokenAmount',         type: 'uint256',       },       {         internalType: 'uint16',         name: 'targetChain',         type: 'uint16',       },       {         internalType: 'bytes32',         name: 'targetRecipient',         type: 'bytes32',       },       {         internalType: 'uint32',         name: 'batchId',         type: 'uint32',       },     ],     name: 'transferTokensWithRelay',     outputs: [       {         internalType: 'uint64',         name: 'messageSequence',         type: 'uint64',       },     ],     stateMutability: 'payable',     type: 'function',   },   {     inputs: [       {         internalType: 'uint256',         name: 'toNativeTokenAmount',         type: 'uint256',       },       {         internalType: 'uint16',         name: 'targetChain',         type: 'uint16',       },       {         internalType: 'bytes32',         name: 'targetRecipient',         type: 'bytes32',       },       {         internalType: 'uint32',         name: 'batchId',         type: 'uint32',       },     ],     name: 'wrapAndTransferEthWithRelay',     outputs: [       {         internalType: 'uint64',         name: 'messageSequence',         type: 'uint64',       },     ],     stateMutability: 'payable',     type: 'function',   }, ];</p> 批量预编译 ABI <p>js title=\"Batch.js\" export default [   {     anonymous: false,     inputs: [       {         indexed: false,         internalType: 'uint256',         name: 'index',         type: 'uint256',       },     ],     name: 'SubcallFailed',     type: 'event',   },   {     anonymous: false,     inputs: [       {         indexed: false,         internalType: 'uint256',         name: 'index',         type: 'uint256',       },     ],     name: 'SubcallSucceeded',     type: 'event',   },   {     inputs: [       {         internalType: 'address[]',         name: 'to',         type: 'address[]',       },       {         internalType: 'uint256[]',         name: 'value',         type: 'uint256[]',       },       {         internalType: 'bytes[]',         name: 'callData',         type: 'bytes[]',       },       {         internalType: 'uint64[]',         name: 'gasLimit',         type: 'uint64[]',       },     ],     name: 'batchAll',     outputs: [],     stateMutability: 'nonpayable',     type: 'function',   },   {     inputs: [       {         internalType: 'address[]',         name: 'to',         type: 'address[]',       },       {         internalType: 'uint256[]',         name: 'value',         type: 'uint256[]',       },       {         internalType: 'bytes[]',         name: 'callData',         type: 'bytes[]',       },       {         internalType: 'uint64[]',         name: 'gasLimit',         type: 'uint64[]',       },     ],     name: 'batchSome',     outputs: [],     stateMutability: 'nonpayable',     type: 'function',   },   {     inputs: [       {         internalType: 'address[]',         name: 'to',         type: 'address[]',       },       {         internalType: 'uint256[]',         name: 'value',         type: 'uint256[]',       },       {         internalType: 'bytes[]',         name: 'callData',         type: 'bytes[]',       },       {         internalType: 'uint64[]',         name: 'gasLimit',         type: 'uint64[]',       },     ],     name: 'batchSomeUntilFailure',     outputs: [],     stateMutability: 'nonpayable',     type: 'function',   }, ];</p> </li> </ol>"}, {"location": "builders/interoperability/mrl/#build-transfer-multiassets", "title": "构建转移多资产交易", "text": "<p>您可以开始处理 <code>xTokens.transferMultiassets</code> 交易，它接受四个参数：</p> <ul> <li><code>assets</code> - 定义了 xcDEV（Moonbeam 的 xcGLMR）和本地 XC-20 的多重位置和数量，以便发送到 Moonbase Alpha，其中 xcDEV 作为第一个资产，本地 XC-20 作为第二个资产</li> <li><code>feeItem</code> - 设置为 xcDEV 资产的索引，在本例中为 <code>0</code>，以便 DEV 用于支付 Moonbase Alpha 中的执行费用</li> <li><code>dest</code> - 一个多重位置，定义了您在前一节中在 Moonbase Alpha 上计算的计算来源帐户</li> <li><code>destWeightLimit</code> - 要购买的权重，用于支付目标链上的 XCM 执行费用</li> </ul> <p>您可以在 X-Tokens Precompile 页面 文档中找到有关每个参数的更多信息。</p> <p>在 <code>build-transfer-multiassets-call.js</code> 文件中，您将构建 <code>xTokens.transferMultiassets</code> 交易并将其导出。</p> build-transfer-multiassets-call.js<pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\n// Input data\nconst originChainProviderWsURL = 'INSERT_ORIGIN_CHAIN_WSS_URL';\nconst computedOriginAccount = 'INSERT_COMPUTED_ORIGIN_ADDRESS';\nconst localXC20Address = 'INSERT_LOCAL_XC20_ADDRESS';\nconst transferAmount = 'INSERT_AMOUNT_TO_TRANSFER';\n\n// Transfer multiassets parameters\nconst assets = {\n  V4: [\n    {\n      // xcDEV\n      id: {\n        parents: 1,\n        interior: {\n          X2: [\n            { Parachain: 1000 }, // Parachain ID\n            { PalletInstance: 3 }, // Index of the Balances Pallet\n          ],\n        },\n      },\n      fun: {\n        Fungible: '100000000000000000', // 0.1 DEV as an estimation for XCM and EVM transaction fee\n      },\n    },\n    {\n      // Local XC-20 token\n      id: {\n        parents: 1,\n        interior: {\n          X3: [\n            { Parachain: 1000 }, // Parachain ID\n            { PalletInstance: 48 }, // Index of the ERC-20 XCM Bridge Pallet\n            {\n              AccountKey20: {\n                key: localXC20Address,\n              },\n            },\n          ],\n        },\n      },\n      fun: {\n        Fungible: transferAmount,\n      },\n    },\n  ],\n};\nconst feeItem = 0;\nconst destination = {\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { Parachain: 1000 },\n        { AccountKey20: { key: computedOriginAccount } },\n      ],\n    },\n  },\n};\nconst weightLimit = 'Unlimited';\n\nexport const getTransferMultiassetsCall = async () =&gt; {\n  // Create origin chain API provider\n  const originChainProvider = new WsProvider(originChainProviderWsURL);\n  const originChainAPI = await ApiPromise.create({\n    provider: originChainProvider,\n  });\n\n  // Create the transferMultiasset extrinsic\n  const transferMultiassets = originChainAPI.tx.xTokens.transferMultiassets(\n    assets,\n    feeItem,\n    destination,\n    weightLimit\n  );\n\n  originChainAPI.disconnect();\n\n  return transferMultiassets;\n};\n</code></pre> <p>要修改 Moonbeam 的代码，您将使用以下配置：</p> 参数 值 平行链 ID 2004 余额 Pallet 索引 10 ERC-20 XCM 桥 Pallet 索引 110"}, {"location": "builders/interoperability/mrl/#build-the-remote-evm-call", "title": "构建远程 EVM 调用", "text": "<p>为了生成批量交易的第二个调用，即 <code>polkadotXcm.send</code> extrinsic，您需要创建 EVM 交易，然后组装执行该 EVM 交易的 XCM 指令。</p> <p>目前，您将专注于生成 EVM 交易的 calldata。为此，您将构建一个与 Batch Precompile 交互的交易，以便在一个交易中发生两个交易。这很有帮助，因为此 EVM 交易必须批准 Wormhole 中继器以中继本地 XC-20 代币和中继操作本身。</p> <p>要创建批量交易并将其包装在要在 Moonbeam 上执行的远程 EVM 调用中，您需要执行以下步骤：</p> <pre><code>1. 创建本地 XC-20、[Wormhole 中继器](https://github.com/wormhole-foundation/example-token-bridge-relayer/blob/main/evm/src/token-bridge-relayer/TokenBridgeRelayer.sol){target=_blank} 和 [Batch Precompile](https://github.com/moonbeam-foundation/moonbeam/blob/master/precompiles/batch/Batch.sol){target=_blank} 的合约实例。为此，您需要每个合约的 ABI 和 Wormhole 中继器的地址。您可以使用 [xLabs 中继器](https://xlabs.xyz/){target=_blank}:\n\n    === \"Moonbeam\"\n\n    - `0xcafd2f0a35a4459fa40c0517e17e6fa2939441ca`\n    === \"Moonbase Alpha\"\n\n    - `0x9563a59c15842a6f322b10f69d1dd88b41f2e97b`\n\n2. 使用 Ether 的 `encodeFunctionData` 函数获取批量交易中两个调用的编码调用数据：`approve` 交易和 `transferTokensWithRelay` 交易\n3. 将两个交易合并成一个批量交易，并使用 Ether 的 `encodeFunctionData` 获取批量交易的编码调用数据\n</code></pre> <ol> <li>使用批量交易的编码调用数据，通过 <code>ethereumXcm.transact</code> extrinsic 创建远程 EVM 调用，它接受 <code>xcmTransaction</code> 作为参数。有关更多信息，请参阅 远程 EVM 调用文档</li> </ol> <p>在 <code>build-remote-calldata.js</code> 文件中，添加以下代码：</p> build-remote-calldata.js<pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { ethers } from 'ethers';\nimport batchABI from './abi/Batch.js';\nimport erc20ABI from './abi/ERC20.js';\nimport tokenRelayerABI from './abi/TokenRelayer.js';\n\nconst localXC20Address = 'INSERT_LOCAL_XC20_ADDRESS';\nconst transferAmount = 'INSERT_AMOUNT_TO_TRANSFER';\nconst xLabsRelayer = '0x9563a59c15842a6f322b10f69d1dd88b41f2e97b';\nconst destinationChainId = 'INSERT_DESTINATION_CHAIN_ID';\nconst computedOriginAccount = 'INSERT_COMPUTED_ORIGIN_ADDRESS';\n// The recipient address on the destination chain needs to be formatted in 32 bytes\n// You'll pad the address to the left with zeroes. Add the destination address below\n// without the 0x\nconst destinationAddress =\n  '0x000000000000000000000000' + 'INSERT_DESTINATION_ADDRESS';\n\n// Create contract instances\nconst batchInterface = new ethers.Interface(batchABI);\nconst localXC20Interface = new ethers.Interface(erc20ABI);\nconst tokenRelayer = new ethers.Contract(\n  xLabsRelayer,\n  tokenRelayerABI,\n  new ethers.JsonRpcProvider('https://rpc.api.moonbase.moonbeam.network')\n);\n\n// Get the encoded calldata for the approve transaction\nconst approve = localXC20Interface.encodeFunctionData('approve', [\n  xLabsRelayer, // Spender\n  transferAmount, // Amount\n]);\n\n// Get the encoded calldata for the transferTokensWithRelay transaction.\n// Use wrapAndTransferEthWithRelay if the token is GLMR\nconst transferTokensWithRelay = tokenRelayer.interface.encodeFunctionData(\n  'transferTokensWithRelay',\n  [\n    localXC20Address, // Token\n    transferAmount, // Amount to be transferred\n    0, // Amount to swap into native assets on the target chain\n    destinationChainId, // Target chain ID, like Ethereum MainNet or Fantom\n    destinationAddress, // Target recipient address\n    0, // Batch ID for Wormhole message batching\n  ]\n);\n\nconst encodedBatchAllCall = batchInterface.encodeFunctionData('batchAll', [\n  [localXC20Address, xLabsRelayer], // Addresses to call\n  [0, 0], // Value to send for each call\n  [approve, transferTokensWithRelay], // Call data for each call\n  [], // Gas limit for each call\n]);\n\nexport const getTransactCall = async () =&gt; {\n  // Create Moonbeam API provider\n  const moonbeamProvider = new WsProvider(\n    'wss://wss.api.moonbase.moonbeam.network'\n  );\n  const moonbeamAPI = await ApiPromise.create({ provider: moonbeamProvider });\n\n  // Create the extrinsic for the remote EVM call\n  const transact = moonbeamAPI.tx.ethereumXcm.transact({\n    V2: {\n      gasLimit: 350000n,\n      action: {\n        Call: '0x0000000000000000000000000000000000000808',\n      },\n      value: 0n,\n      input: encodedBatchAllCall,\n    },\n  });\n\n  const txWeight = (await transact.paymentInfo(computedOriginAccount)).weight;\n\n  moonbeamAPI.disconnect();\n\n  return { transact, txWeight };\n};\n</code></pre>"}, {"location": "builders/interoperability/mrl/#build-xcm-message-for-remote-evm-call", "title": "构建远程 EVM 调用的 XCM 消息", "text": "<p>接下来，您需要创建 extrinsic 以将远程 EVM 调用发送到 Moonbeam。为此，您需要发送一条 XCM 消息，以便 <code>Transact</code> XCM 指令能够成功执行。最常见的方法是通过 <code>polkadotXcm.send</code>，并配合使用 <code>WithdrawAsset</code>、<code>BuyExecution</code> 和 <code>Transact</code> 指令。<code>RefundSurplus</code> 和 <code>DepositAsset</code> 也可以用于确保没有资产被困住，但它们在技术上是可选的。</p> <p>在 <code>build-remote-evm-call.js</code> 文件中，添加以下代码：</p> <p>js title=\"build-remote-evm-call.js\" import { ApiPromise, WsProvider } from '@polkadot/api'; import { getTransactCall } from './build-batch-evm-call.js';</p> <p>const originChainProviderWsURL = 'INSERT_ORIGIN_CHAIN_WSS_URL'; const computedOriginAccount = 'INSERT_COMPUTED_ORIGIN_ADDRESS';</p> <p>export const getPolkadotXcmCall = async () =&gt; {   // Create origin chain API provider   const originChainProvider = new WsProvider(originChainProviderWsURL);   const originChainAPI = await ApiPromise.create({     provider: originChainProvider,   });</p> <p>// Get the weight required to execute the Transact calldata   const { transact, txWeight } = await getTransactCall();</p> <p>// Create the extrinsic for the remote EVM call   const sendXcm = originChainAPI.tx.polkadotXcm.send(     { V4: { parents: 1, interior: { X1: [{ Parachain: 1000 }] } } },     {       V4: [         {           // Withdraw DEV asset (0.06) from the target account           WithdrawAsset: [             {               id: {                 parents: 0,                 interior: { X1: [{ PalletInstance: 3 }] },               },               fun: { Fungible: 60000000000000000n },             },           ],         },         {           // Buy execution with the DEV asset           BuyExecution: {             fees: {               id: {                 parents: 0,                 interior: { X1: [{ PalletInstance: 3 }] },               },               fun: { Fungible: 60000000000000000n },             },             weightLimit: 'Unlimited',           },         },         {           Transact: {             originKind: 'SovereignAccount',             requireWeightAtMost: {               refTime: txWeight.refTime,               proofSize: txWeight.proofSize,             },             call: {               encoded: transact.method.toHex(),             },           },         },         {           RefundSurplus: {},         },         {           DepositAsset: {             // Note that this must be AllCounted and not All, since All has too high of a gas requirement             assets: { Wild: { AllCounted: 1 } },             beneficiary: {               parents: 0,               interior: {                 X1: [{ AccountKey20: { key: computedOriginAccount } }],               },             },           },         },       ],     }   );</p> <p>return sendXcm; };</p>"}, {"location": "builders/interoperability/mrl/#build-batch-extrinsic", "title": "构建批量外部调用", "text": "<p>为了确保 <code>xTokens.transferMultiassets</code> 和 <code>polkadotXcm.send</code> 交易一起发送，您可以使用 <code>utility.batchAll</code> 将它们批量处理。这有助于确保资产转移发生在 EVM 交易之前，这是一个必要的区别。遗憾的是，这可能会随着未来的 XCM 更新而发生变化。</p> <p>在 <code>send-batch-transaction.js</code> 文件中，添加以下代码：</p> send-batch-transaction.js<pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { getTransferMultiassetsCall } from './build-transfer-multiassets-call.js';\nimport { getPolkadotXcmCall } from './build-remote-evm-call.js';\n\nconst originChainProviderWsURL = 'INSERT_ORIGIN_CHAIN_WSS_URL';\n\nconst sendBatchTransaction = async () =&gt; {\n  // Create origin chain API provider\n  const originChainProvider = new WsProvider(originChainProviderWsURL);\n  const originChainAPI = await ApiPromise.create({\n    provider: originChainProvider,\n  });\n\n  // Create the batch transaction\n  const batchTransaction = originChainAPI.tx.utility.batchAll([\n    await getTransferMultiassetsCall(),\n    await getPolkadotXcmCall(),\n  ]);\n\n  // Create a keyring instance to sign the transaction\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'ethereum' });\n  const account = keyring.addFromUri(privateKey);\n\n  // Send the batch transaction\n  const transaction = await batchTransaction.signAndSend(account, ({ status }) =&gt; {\n    if (status.isInBlock) console.log(`Transaction sent!`);\n  });\n\n  originChainAPI.disconnect();\n\n  return transaction;\n};\n\nsendBatchTransaction();\n</code></pre> <p>如果您想查看一个完全实现此功能的示例项目，可以在 GitHub 存储库 中找到一个示例。</p> <p>重要的是要注意，并非每个平行链都以允许此路径的方式实现 X-Tokens 和其他 pallets。基于 Substrate 的链非常灵活，以至于不存在标准。如果您认为您的平行链不支持此路径，请在 Moonbeam 论坛 上和 Wormhole 团队提供替代解决方案。</p>"}, {"location": "builders/interoperability/mrl/#tokens-available-through-wormhole", "title": "通过 Wormhole 提供的代币", "text": "<p>虽然 Wormhole 在技术上能够跨链桥接任何代币，但中继器不会支持每种代币的费用。可以通过 Wormhole 的 MRL 解决方案桥接的 ERC-20 资产取决于 xLabs 中继器 接收的代币量。Moonbeam 和 Moonbase Alpha 可用的代币在下表中列出：</p> MoonbeamMoonbase Alpha 代币名称 符号 小数位数 地址 Wrapped AVAX wAVAX 18 0xd4937A95BeC789CC1AE1640714C61c160279B22F Wrapped Bitcoin wBTC 8 0xE57eBd2d67B462E9926e04a8e33f01cD0D64346D Wrapped BNB wBNB 18 0xE3b841C3f96e647E6dc01b468d6D0AD3562a9eeb Celo 原生资产 CELO 18 0xc1a792041985F65c17Eb65E66E254DC879CF380b Dai 稳定币 DAI 18 0x06e605775296e851FF43b4dAa541Bb0984E9D6fD Wrapped Ethereum wETH 18 0xab3f0245B83feB11d15AAffeFD7AD465a59817eD Wrapped Fantom wFTM 18 0x609AedD990bf45926bca9E4eE988b4Fb98587D3A Wrapped GLMR wGLMR 18 0xAcc15dC74880C9944775448304B263D191c6077F Wrapped Matic wMATIC 18 0x82DbDa803bb52434B1f4F41A6F0Acb1242A7dFa3 Wrapped SOL SOL 9 0x99Fec54a5Ad36D50A4Bba3a41CAB983a5BB86A7d Sui SUI 9 0x484eCCE6775143D3335Ed2C7bCB22151C53B9F49 Tether USD USDT 6 0xc30E9cA94CF52f3Bf5692aaCF81353a27052c46f USDC (Wormhole) USDC 6 0x931715FEE2d06333043d11F658C8CE934aC61D0c 代币名称 符号 小数位数 地址 Wrapped Avax wAVAX 18 0x2E8afeCC19842229358f3650cc3F091908dcbaB4 Wrapped BNB wBNB 18 0x6097E80331B0c6aF4F74D7F2363E70Cb2Fd078A5 Celo 原生资产 CELO 18 0x3406a9b09adf0cb36DC04c1523C4b294C6b79513 Dai 稳定币 DAI 18 0xc31EC0108D8e886be58808B4C2C53f8365f1885D Wrapped Ether wETH 18 0xD909178CC99d318e4D46e7E66a972955859670E1 Wrapped Ether (Wormhole) wETH 18 0xd27d8883E31FAA11B2613b14BE83ad8951C8783C Wrapped Fantom wFTM 18 0x566c1cebc6A4AFa1C122E039C4BEBe77043148Ee Wrapped Matic wMATIC 18 0xD2888f015BcB76CE3d27b6024cdEFA16836d0dbb Sui SUI 9 0x2ed4B5B1071A3C676664E9085C0e3826542C1b27 USDC USDC 6 0x6533CE14804D113b1F494dC56c5D60A43cb5C3b5 <p>请花时间使用 Wormhole 资产验证器 验证这些资产是否仍然是 Moonbeam 上的 Wormhole 资产。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/interoperability/protocols/axelar/", "title": "Axelar 网络", "text": ""}, {"location": "builders/interoperability/protocols/axelar/#introduction", "title": "简介", "text": "<p>Axelar 为 Web3 提供安全的跨链通信。Axelar 的基础设施使 dApp 用户只需单击一下，即可与任何连接链上的任何资产或应用程序进行交互。Axelar 网络由无需许可的权益证明验证器集提供支持，允许 dApp 使用图灵完备的调用跨链传递任意消息。</p> <p>Axelar 是一个全栈传输层，支持资产转移、通用消息传递 和程序的可组合性。它安全地连接所有区块链生态系统、应用程序、资产和用户，以实现 Web3 互操作性。Axelar 由去中心化的验证器网络、安全网关合约、统一翻译、路由架构以及一套协议和应用程序编程接口 (API) 组成。请查看 技术堆栈图 了解更多详情。</p> <p></p> <p>Axelar API 提供了一套丰富的 Web3 应用程序开发套件，确保开发人员拥有构建所需的工具。借助这些工具和 API，开发人员可以使用 Axelar 网络及其 API 编写可以轻松部署在所有 Axelar 连接的生态系统中的 dApp。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "builders/interoperability/protocols/axelar/#getting-started", "title": "入门", "text": "<p>有几个资源可以帮助您开始使用 Axelar 构建跨链应用程序：</p> <ul> <li>开发者文档 - 用于技术指南</li> <li>Squid - 一种用于在链之间转移资产的桥接 UI</li> </ul> <p>还有一个区块浏览器可用于跟踪您的跨链传输等：</p> <ul> <li>Axelarscan for MainNet</li> <li>Axelarscan for TestNet</li> </ul>"}, {"location": "builders/interoperability/protocols/axelar/#contracts", "title": "合约", "text": "<p>查看已部署到 Moonbeam 的 Axelar 合约列表，以及通过 Axelar 连接到 Moonbeam 的网络。</p> <ul> <li> <p>MainNet 合约 - Moonbeam</p> </li> <li> <p>TestNet 合约 - Moonbase Alpha</p> </li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/interoperability/protocols/hyperlane/", "title": "Hyperlane 协议", "text": ""}, {"location": "builders/interoperability/protocols/hyperlane/#introduction", "title": "介绍", "text": "<p>Hyperlane 是一个用于 Web3 的安全模块化跨链通信协议。Hyperlane 使 dApp 用户能够一键与任何连接链上的任何资产或应用程序进行交互。它支持通用资产转移以及自定义跨链消息传递。</p> <p>使用链间安全模块 (ISM)，Hyperlane 允许开发人员配置消息在链之间发送和验证的方式。Hyperlane 由验证器、中继器和瞭望塔组成。验证器将监视并确认跨链消息。中继器花费 gas 在链之间发送消息。瞭望塔执行检查以确保验证器是善意参与者，从而保护协议。查看技术堆栈图及其协议文档以获取更多详细信息。</p> <p></p> <p>Hyperlane API 提供了一套丰富的 Web3 应用程序开发套件，确保开发人员拥有构建所需的工具。借助这些工具和 API，开发人员可以使用 Hyperlane 协议及其 API 来编写可以轻松部署到所有 Hyperlane 连接的生态系统中的 dApp。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "builders/interoperability/protocols/hyperlane/#getting-started", "title": "入门", "text": "<p>这里有一些资源可以帮助您开始使用 Hyperlane 构建跨链应用程序：</p> <ul> <li>开发者文档 - 用于技术指南</li> <li>Hyperlane 浏览器 - 用于跟踪跨链传输</li> </ul>"}, {"location": "builders/interoperability/protocols/hyperlane/#contracts", "title": "合约", "text": "<p>查看部署到 Moonbeam 的 Hyperlane 合约列表，以及通过 Hyperlane 连接到 Moonbeam 的网络。</p> <ul> <li>主网和测试网合约</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/interoperability/protocols/layerzero/", "title": "LayerZero 协议", "text": ""}, {"location": "builders/interoperability/protocols/layerzero/#introduction", "title": "简介", "text": "<p>LayerZero 为 Web3 提供安全的全链互操作性。它由 Oracle 参与者和 Relayer 参与者组成，它们分别工作以提供从一个链到另一个链的安全消息。LayerZero 的基础设施使 dApp 用户只需单击一下，即可与任何连接链上的任何资产或应用程序进行交互。</p> <p>LayerZero 是一个传输层，它通过低级通信原语实现资产转移。利用 LayerZero 的 DApp 被称为用户应用程序，其消息通过 Relayer 在链之间传递，并且其消息由 Oracle 的区块头在目标链上验证。请看下面的技术堆栈图及其概念文档以获取更多详细信息。</p> <p></p> <p>LayerZero API 提供了一套丰富的 Web3 应用程序开发工具，确保开发人员拥有构建所需的工具。借助这些工具和 API，开发人员可以使用 LayerZero 协议及其 API 编写可以轻松部署在所有 LayerZero 连接的生态系统中的 dApp。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "builders/interoperability/protocols/layerzero/#getting-started", "title": "入门", "text": "<p>以下是一些资源，可帮助您开始使用 LayerZero 构建跨链应用程序：</p> <ul> <li>开发者文档 - 用于技术指南</li> <li>Stargate - Stargate 团队构建的、使用 LayerZero 的桥接 UI</li> </ul>"}, {"location": "builders/interoperability/protocols/layerzero/#contracts", "title": "合约", "text": "<p>查看部署到 Moonbeam 的 LayerZero 合约列表，以及通过 LayerZero 连接到 Moonbeam 的网络。</p> <ul> <li> <p>主网合约 - Moonbeam</p> </li> <li> <p>测试网合约 - Moonbase Alpha</p> </li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/interoperability/protocols/wormhole/", "title": "Wormhole网络", "text": ""}, {"location": "builders/interoperability/protocols/wormhole/#_1", "title": "介绍", "text": "<p>Wormhole 是一种协议，通过称为可验证操作批准（VAA）的消息来验证和保护 Web3 的跨链通信。Wormhole 的基础设施使用户只需单击一下，即可与任何连接链上的任何资产或应用程序进行交互。Wormhole 由多重签名协议和 19 个签名守护者提供支持，允许 dApp 跨链传递任意消息。</p> <p>Wormhole 由多个模块化可互换组件组成，这些组件可以独立使用，并支持由众多团队构建的越来越多的可组合应用程序。在其协议之上构建 xDapps 可以实现快速的跨链资产转移和跨链逻辑，从而实现最大的 Web3 互操作性。Wormhole 的架构包括签名守护者网络、桥接智能合约和中继器。请查看技术堆栈图以获取更多详细信息。</p> <p></p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "builders/interoperability/protocols/wormhole/#getting-started", "title": "入门", "text": "<p>这里有一些资源可以帮助您开始使用 Wormhole 构建跨链应用程序：</p> <ul> <li>开发者文档 - 用于技术指南</li> <li>Portal - 一个用于跨链转移资产的桥接 UI</li> </ul>"}, {"location": "builders/interoperability/protocols/wormhole/#contracts", "title": "合约", "text": "<p>请参阅已部署到 Moonbeam 的 Wormhole 合约列表，以及通过 Wormhole 连接到 Moonbeam 的网络。</p> <ul> <li>MainNet 合约 - Moonbeam</li> </ul>"}, {"location": "builders/interoperability/protocols/wormhole/#setting-up-a-specialized-relayer-with-the-relayer-engine", "title": "使用 Relayer 引擎设置专用 Relayer", "text": "<p>在本节中，您将部署一个基本的 Wormhole 连接的智能合约，并启动一个专门的 relayer 以跨链发送消息。</p> <p>首先，介绍一些背景知识。VAA，或可验证的操作批准，是 Wormhole 版本的已验证的跨链消息。如果 Wormhole 的 19 个签名守护者中的 13 个验证了特定消息，则该消息将被批准并且可以在其他链上接收。与守护者网络（充当 Wormhole 协议的验证者）相邻的是网络间谍。他们不进行任何验证工作。相反，他们监视守护者网络并充当接口，允许用户和应用程序查看哪些 VAA 已被批准。</p> <p>Relayer 的作用是为目标链的执行付费，并且在许多协议中，relayer 反过来由用户付费。Wormhole 尚未提供通用的 relayer，因此 Wormhole 的架构要求 dApp 开发人员创建并维护他们自己的专用 relayer（而不是拥有可以为许多不同智能合约执行的 relayer）。如果开发人员希望合约调用者支付目标链上的 gas 费用，则他们必须设计自己的系统。这可能看起来工作量更大，但它可以更精细地调整消息的处理方式。例如，relayer 可以同时将同一消息发送到多个链，这称为多播。</p>"}, {"location": "builders/interoperability/protocols/wormhole/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要学习本教程，您需要具备以下条件：</p> <ul> <li>已安装MetaMask并连接到Moonbase Alpha</li> <li>已安装Docker</li> <li>拥有一个已获得<code>DEV</code>代币的帐户。</li> </ul> <p>You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</p> <ul> <li>让同一个帐户获得来自您选择的Wormhole连接的EVM的原生货币。水龙头在下表中</li> </ul>"}, {"location": "builders/interoperability/protocols/wormhole/#moonbase-alpha-remix-wormhole", "title": "在 Moonbase Alpha 上使用 Remix 部署 Wormhole 合约", "text": "<p>要发送跨链消息，在本指南中，您需要部署和使用智能合约。连接到 Wormhole 的每个链都将具有 Wormhole 核心桥 的某种实现，其目的是发布和验证 VAA。核心桥合约的每个实现（每个链一个）都受到守护者网络中每个守护者的监视，这就是他们知道何时开始验证消息的方式。</p> <p>与其他跨链协议不同，Wormhole 不提供父智能合约供用户继承来构建。这是因为 Wormhole 的第一个链 Solana 在其智能合约中没有像 Solidity 提供的典型继承。为了保持每个链上的设计体验相似，Wormhole 让他们的 Solidity 开发人员直接与 EVM 链上的 Wormhole 核心桥智能合约交互。</p> <p>您今天将部署的智能合约 存储在从 Wormhole 的 relayer engine 存储库中forked的 Git 存储库中。它将字符串从一个链发送到另一个链，并在通过 Wormhole 协议接收时存储字符串。要部署脚本，请将合约复制并粘贴到 Remix 中，或打开此 Remix gist 链接。</p> <p>首先，此智能合约中的代码在某些领域（如安全性）中得到了简化。在编写用于生产的智能合约时，请查看 Wormhole 文档，以更好地了解标准。需要明确的是，请勿在生产中使用以下智能合约。</p> <ol> <li>转到 Solidity Compiler 选项卡</li> <li>按下 Compile 按钮</li> <li>然后，转到 Remix 的 Deploy &amp; Run Transactions 选项卡</li> <li>将环境设置为 Injected Web3。 这将使用 MetaMask 作为 Web3 提供商。 确保您的 MetaMask 已连接到 Moonbase Alpha 网络</li> </ol> <p></p> <p>要在每个链上进行部署，您将需要 Wormhole 核心桥的本地实例和所提及链的链 ID。 下表提供了针对少数几个 TestNet 的所有这些数据。 您可以在 Wormhole 的 支持的网络文档 上找到其他网络的端点。 请记住，您应该仅将 EVM 用于此演示，因为为此演示设计的智能合约和 relayer 仅支持 EVM。</p> Network &amp; Faucet Core Bridge Address Wormhole Chain ID Polygon Mumbai 0x0CBE91CF822c73C2315FB05100C2F714765d5c20 5 Avalanche Fuji 0x7bbcE28e64B3F8b84d876Ab298393c38ad7aac4C 6 Fantom TestNet 0x1BB3B4119b7BA9dfad76B0545fb3F531383c3bB7 10 Sepolia 0x4a8bc80Ed5a4067f1CCf107057b8270E0cC11A78 10002 Moonbase Alpha 0xa5B7D85a8f27dd7907dc8FdC21FA5657D5E2F901 16 <ol> <li>确保选择的合约是 SimpleGeneralMessage</li> <li>使用箭头按钮打开部署菜单</li> <li>在 _CHAINID 输入中输入相关的链 ID</li> <li>在 WORMHOLE_CORE_BRIDGE_ADDRESS 输入中输入相关的核心桥地址</li> <li>按下 transact 按钮以启动部署交易</li> <li>按下 MetaMask 中的 Confirm 按钮以进行部署</li> </ol> <p>在 Moonbase Alpha 上部署合约后，请务必复制其地址，并对连接到 Wormhole 的任何其他 EVM TestNet之一重复该过程，以便您可以跨链发送消息。 请记住，您必须更改 MetaMask 中的网络才能部署到正确的网络。</p>"}, {"location": "builders/interoperability/protocols/wormhole/#moonbase-alpha", "title": "将 Moonbase Alpha 的连接合约列入白名单", "text": "<p>此时，您应该已经将相同的智能合约部署了两次。一次在 Moonbase Alpha 上，另一次在另一个 EVM 链上。</p> <p>Wormhole 建议在其连接的合约中包含一个白名单系统，在尝试发送跨链消息之前，您需要在 <code>SimpleGeneralMessage</code> 中使用该系统。</p> <p>要添加列入白名单的合约，您必须调用 <code>addTrustedAddress(bytes32 sender, uint16 _chainId)</code> 函数，该函数需要一个 bytes32 格式的地址和一个链 ID。您可以在上表和 Wormhole 的文档中找到链 ID。</p> <pre><code>function addTrustedAddress(bytes32 sender, uint16 _chainId) external {\n    myTrustedContracts[sender][_chainId] = true;\n}\n</code></pre> <p>请注意，<code>sender</code> 参数是 <code>bytes32</code> 类型，而不是 <code>address</code> 类型。Wormhole 的 VAA 以 <code>bytes32</code> 的形式提供发射器（源）地址，因此它们以 <code>bytes32</code> 的形式存储和检查。要将 <code>address</code> 类型转换为 <code>bytes32</code>，您需要填充额外的 24 个零。这是因为 <code>address</code> 值为 20 字节，小于 <code>bytes32</code> 的 32 字节。每个字节都有 2 个十六进制字符，因此：</p> <pre><code>zeros to add = (32 bytes - 20 bytes) * 2 hexadecimal characters\nzeros to add = 24\n</code></pre> <p>例如，如果您的连接合约的地址是 <code>0xaf108eF646c8214c9DD9C13CBC5fadf964Bbe293</code>，您将在 Remix 中输入以下内容：</p> <pre><code>0x000000000000000000000000af108ef646c8214c9dd9c13cbc5fadf964bbe293\n</code></pre> <p>现在使用 Remix 确保您的两个连接合约彼此信任。如果您打算来回发送消息，则必须在您已部署的两个合约上执行此操作。要在不同链上的合约之间切换，请通过 MetaMask 连接到目标网络。</p> <ol> <li>确保您处于注入 提供程序环境中</li> <li>确保您使用的是正确的帐户</li> <li>另请检查合约是否仍为 SimpleGeneralMessage</li> <li>最后，获取目标合约的地址，并将其粘贴到地址输入中</li> </ol> <p></p> <p>要添加受信任的远程地址：</p> <ol> <li>在已部署的合约中找到 addTrustedAddress 函数并将其打开</li> <li>当您在 Moonbase Alpha 上时，将 sender 设置为您部署在另一个 EVM TestNet 上的合约的格式正确的（填充了 24 个零）地址</li> <li>将 _chainId 设置为部署另一个合约的链的 Wormhole 链 ID。之后，进行交易并在 MetaMask 中确认</li> </ol> <p>当您在备用 EVM TestNet 上时，将 sender 设置为您部署在 Moonbase Alpha 上的合约的格式正确的（填充了 24 个零）地址。将 _chainId 设置为 Moonbase Alpha 的 Wormhole 链 ID (16)。最后，进行交易并在 MetaMask 中确认。</p> <p></p> <p>在本节中，您应该已经在两个链上发送了两个交易，以将地址列入两个合约的白名单。之后，您应该可以连接的合约之间发送消息。</p>"}, {"location": "builders/interoperability/protocols/wormhole/#_2", "title": "设置监听器组件", "text": "<p>现在来分解中继器的自定义代码和可配置组件。 监听器组件，顾名思义，用于侦听间谍节点的相关消息。 要定义相关消息是什么，您必须编辑配置文件。</p> <p>在 <code>plugins/simplegeneralmessage_plugin/config/devnet.json</code> 中，存在一个名为 <code>spyServiceFilters</code> 的数组。 此数组中的每个对象都将合约的 VAA 列入白名单，以便与中继器相关。 该对象包含一个 <code>chainId</code> (Wormhole 链 ID) 和一个 <code>emitterAddress</code>。 例如，在下图中，第一个对象将监视由 <code>0x428097dCddCB00Ab65e63AB9bc56Bb48d106ECBE</code> 在 Moonbase Alpha 上发送的 VAA (Wormhole 链 ID 为 16)。</p> <p>请务必编辑 <code>spyServiceFilters</code> 数组，以便中继器侦听您部署的两个合约。</p> <p>在 <code>simplegeneralmessage_plugin</code> 文件夹中，打开 <code>src/plugin.ts</code>。 此文件包含中继器的监听器和执行器组件的插件代码，但注释应清楚地表明哪些函数与哪个组件相关。 文件的片段显示在下面，您应该按照操作进行，但如果您没有这样做，则可以在 其 GitHub 存储库 中访问整个文件。</p> <p>查看下面的 <code>getFilters()</code> 函数。 注意到有什么熟悉的东西吗？ <code>spyServiceFilters</code> 对象被注入到 <code>getFilters()</code> 所属的插件类中。 请注意，没有进行任何过滤，这只是过滤器的准备工作。 VAA 的实际过滤发生在 <code>relayer-engine</code> 包中，该包使用此 <code>getFilters()</code> 函数来了解要过滤的内容。</p> <p>如果开发人员想要向过滤器添加其他逻辑，他们可以在此处添加，但就您的目的而言，仅列出一些硬编码的地址即可。</p> <pre><code> // How the relayer injects the VAA filters.\n // This is the default implementation provided by the dummy plugin.\n getFilters(): ContractFilter[] {\n   if (this.pluginConfig.spyServiceFilters) {\n     return this.pluginConfig.spyServiceFilters;\n   }\n   this.logger.error('Contract filters not specified in config');\n   throw new Error('Contract filters not specified in config');\n }\n</code></pre> <p>过滤后，监听器需要使用下面的 <code>consumeEvent(vaa, stagingArea)</code> 函数将工作流数据写入 Redis 数据库。</p> <p>工作流只是执行器需要从监听器获得的数据，以便进行正确的执行。 在这种情况下，添加到工作流的唯一信息是接收 VAA 的时间和 VAA 本身中的已解析数据。 如果开发人员想要向工作流添加更多相关信息，他们可以在 <code>workflowData</code> 对象中执行此操作。</p> <p><code>nextStagingArea</code> 对象是一种让已使用事件（已过滤的 VAA）相互影响的方式。 例如，如果开发人员想要将两个 VAA 打包到一个工作流中，他们不会每次都返回 <code>workflowData</code>。</p> <pre><code> // Receives VAAs and returns workflows.\n  async consumeEvent(\n    vaa: ParsedVaaWithBytes,\n    stagingArea: StagingAreaKeyLock,\n  ): Promise&lt;\n    |\n    {\n      workflowData: WorkflowPayload;\n      workflowOptions?: WorkflowOptions;\n    }\n    |\n    undefined\n  &gt; {\n    this.logger.debug(`VAA hash: ${vaa.hash.toString('base64')}`);\n\n    return {\n      workflowData: {\n        vaa: vaa.bytes.toString('base64'),\n      },\n    };\n  }\n</code></pre> <p>这就是监听器组件所需的一切。 幸运的是，大部分代码都隐藏在 <code>relayer-engine</code> 包中的用户面前。</p> <p>如果您还记得组件列表，则第三个是 Redis 数据库组件。 与数据库有关的大部分代码都隐藏在用户面前，因为 <code>relayer-engine</code> 包将从中写入和读取数据，然后将任何相关数据注入回插件代码中。 要运行 Redis 数据库，只需在父目录中运行以下命令：</p> <pre><code>npm run redis\n</code></pre>"}, {"location": "builders/interoperability/protocols/wormhole/#send-message-from-moonbase", "title": "使用 Wormhole 从 Moonbase 发送跨链消息", "text": "<p>现在，要发送跨链消息，您只需要调用 <code>sendMessage(string memory message, address destAddress, uint16 destChainId)</code> 函数。</p> <p>使用 Remix 接口。此示例将向 Fantom TestNet 发送跨链消息，但您可以将 <code>destChainId</code> 替换为您想要的任何 EVM。检查以下事项：</p> <ol> <li>环境为网络 1287 (Moonbase Alpha) 上的 Injected Provider</li> <li>您的钱包中有来自 水龙头 的大量资金，以支付源链和目标链上的交易 gas 成本</li> <li>在 sendMessage 部分的 message 输入中放入您选择的简短消息（在本例中为“this is a message”）</li> <li>将目标链上 SimpleGeneralMessage 实例的地址放入 destAddress 输入中</li> <li>将目标链的 Wormhole 链 ID 放入 sendMessage 部分的 destChainId 输入中</li> <li>完成所有这些操作后，交易执行并在 MetaMask 中确认它</li> </ol> <p></p> <p>几秒钟到一分钟后，跨链消息应通过您在本地计算机上托管的中继器正确中继。</p> debug | spyEventSource: 7iWtnE4whSBtCxmUA87FUQkCLhy92gHW/qIg6/vTMNM= debug | spyEventSource: 10 info | missedVaafetching: Fetching missed vas for 10: 0000000000000000000000001fd6d0beaf150526a6e48dbde8484a73a280a45, from 1 to 2 debug | SimpleGeneralMessagePlugin: VAA hash: 7iWtnE4whSBtCmUA87FUQkCLhy92gHW/qIg6/VTMNM= info | leventHarness: Received workflow data from plugin SimpleGeneralMessagePlugin, adding workflow. debug | GlobalStorage: Updating emitter record last seen sequence. debug | GlobalStorage: Found emitterRecord debug | executorHarness: New workflow found info | executorHarness: Starting workflow. info | SimpleGeneralMessagePlugin: Workflow 10/0000000000000000000000001d6d0beaf150526a648dbde8484a73a280a45/2/ee25 a received. info | SimpleGeneralMessagePlugin: Parsed VAA. seq: 2 info | SimpleGeneralMessagePlugin: VAA: 0x0394c0edf cca370b20622721985b577850b@eb75 sent \"this is a message\" to exa8add 09e4fcf1b5edc588c54bee137cb35e61f5b on chain 16. debug | GlobalStorage: Updated emitter record. Key SimpleGeneralMessagePlugin:10:0000000000000000000000001d6d0beaf150 52f6a648dbde8484a73a280a45, {\"lastSeenSequence\":2,\"time\":\"2023-03-14T21:38:11.780Z\"} info | Moonbase Alpha-0-worker: Relaying action for plugin SimpleGeneralMessagePlugin, debug | executorHarness: No new workflows found. info | SimpleGeneralMessagePlugin: [object Object] info | Moonbase Alpha-0-worker: Action SimpleGeneralMessagePlugin completed info | executorHarness: Finished executing workflow."}, {"location": "builders/interoperability/protocols/wormhole/#moonbeam-routed-liquidity-integration", "title": "Moonbeam 路由流动性集成", "text": "<p>Wormhole 将通过 Moonbeam 路由流动性 (MRL) 计划为平行链提供流动性。此计划允许通过 Moonbeam 网络发送流动性，从而将来自 Wormhole 连接链的流动性一键转移到平行链钱包。 MRL 利用 GMP 预编译，其文档解释了应如何构造跨链消息以正确使用预编译。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/interoperability/xcm/overview/", "title": "跨共识消息传递 (XCM)", "text": ""}, {"location": "builders/interoperability/xcm/overview/#introduction", "title": "简介", "text": "<p>Polkadot 的架构 允许平行链彼此原生互操作，从而实现任何类型数据或资产的跨区块链转移。</p> <p>为此，跨共识消息（XCM） 格式定义了一种语言，用于描述两个互操作区块链之间的消息传输应如何执行。XCM 并非 Polkadot 专用，因为它旨在成为不同共识系统之间的通用且可扩展的语言。</p> <p>本页是对 XCM 和其他相关元素的简要介绍和概述。更多信息可以在 Polkadot 的 Wiki 中找到。</p> <p>如果您想跳转到更多与 XCM 相关的内容，请随时查看以下页面：</p> <ul> <li>核心 XCM 概念 - 了解与 XCM 指令、多位置 和 XCM 费用 相关的主题</li> <li>XC 注册 - 完成使用 Moonbeam 打开 XCM 通道以及如何将 Polkadot 原生资产注册为 XC-20 的过程</li> <li>XC-20 - 阅读此 Moonbeam 独有资产类别的概述，并了解如何与 XC-20 交互以及如何通过 XCM 发送它们</li> <li>通过 XCM 进行远程执行 - 掌握与通过 XCM 进行远程执行相关的所有概念，从高级概述开始，然后是 计算来源，最后是通过 XCM 进行的远程调用和通过 XCM 进行的远程 EVM 调用</li> <li>XCM SDK - 了解如何使用 Moonbeam 的 XCM SDK</li> <li>XCM 调试和工具 - 了解如何通过发送和执行通用 XCM 消息来测试一些 XCM 场景，或者如何使用 XCM 实用程序预编译 来直接在 EVM 中访问 XCM_related 实用程序函数</li> </ul>"}, {"location": "builders/interoperability/xcm/overview/#general-xcm-definitions", "title": "通用 XCM 定义", "text": "<ul> <li>XCM — stands for Cross-Consensus Message. It is a general way for consensus systems to communicate with each other</li> <li>VMP — stands for Vertical Message Passing, one of the transport methods for XCMs. It allows parachains to exchange messages with the relay chain. UMP (Upward Message Passing) enables parachains to send messages to their relay chain, while DMP (Downward Message Passing) enables the relay chain to pass messages down to one of their parachains</li> <li>XCMP — stands for Cross-Consensus Message Passing, one of the transport methods for XCMs. It allows parachains to exchange messages with other parachains on the same relay chain</li> <li> <p>HRMP — stands for Horizontal Relay-routed Message Passing, a stop-gap protocol while a full XCMP implementation is launched. It has the same interface as XCMP, but messages are stored on the relay chain</p> </li> <li> <p>Sovereign account —  an account each chain in the ecosystem has, one for the relay chain and the other for other parachains. It is calculated as the <code>blake2</code> hash of a specific word and parachain ID concatenated (<code>blake2(para+ParachainID)</code> for the Sovereign account in the relay chain, and <code>blake2(sibl+ParachainID)</code> for the Sovereign account in other parachains), truncating the hash to the correct length. The account is owned by root and can only be used through SUDO (if available) or governance (referenda). The Sovereign account typically signs XCM messages in other chains in the ecosystem</p> </li> <li> <p>Multilocation —  a way to specify a point in the entire relay chain/parachain ecosystem relative to a given origin. For example, it can be used to specify a specific parachain, asset, account, or even a pallet inside a parachain. In general terms, a multilocation is defined with a <code>parents</code> and an <code>interior</code>:</p> <ul> <li><code>parents</code> - refers to how many \"hops\" into a parent blockchain you need to take from a given origin</li> <li><code>interior</code> - refers to how many fields you need to define the target point. </li> </ul> <p>For example, to target a parachain with ID <code>1000</code> from another parachain, the multilocation would be <code>{ \"parents\": 1, \"interior\": { \"X1\": [{ \"Parachain\": 1000 }]}}</code></p> </li> </ul>"}, {"location": "builders/interoperability/xcm/overview/#xcm-transport-protocols", "title": "通过 XCM 实现跨链传输协议", "text": "<p>XCM 实现了两种跨共识或传输协议，用于在其组成的平行链之间处理 XCM 消息，Moonbeam 便是其中之一：</p> <ul> <li> <p>垂直消息传递 (VMP) — 一旦项目作为平行链加入，它将自动与中继链建立双向通信通道。因此，无需链注册。VMP 分为两种消息传递传输协议：</p> <ul> <li>向上消息传递 (UMP) — 允许平行链向其中继链发送消息，例如从 Moonbeam 到 Polkadot</li> <li>向下消息传递 (DMP) — 允许中继链将消息传递给其平行链之一，例如从 Polkadot 到 Moonbeam</li> </ul> </li> <li> <p>跨链消息传递 (XCMP) — 允许两个平行链交换消息，只要它们连接到同一个中继链。跨链交易使用基于 Merkle 树的简单排队机制来解决，以确保保真度。收集人（Collator）在平行链之间交换消息，而中继链验证人将验证消息传输是否发生</p> </li> </ul> <p>Note</p> <p>目前，在开发 XCMP 时，会实施一种权宜之计协议，称为水平中继路由消息传递 (HRMP)，其中消息存储在中继链中并从中读取。将来，完整的 XCMP 实现将会弃用它。</p> <p></p>"}, {"location": "builders/interoperability/xcm/overview/#channel-registration", "title": "建立跨链通信", "text": "<p>在两个链开始通信之前，必须打开一个消息通道。通道是单向的，这意味着从链 A 到链 B 的通道只会传递从 A 到 B 的消息。因此，必须打开两个通道才能来回发送消息。</p> <p>当建立连接时，中继链和平行链之间的 XCM 通道会自动打开。但是，当平行链 A 想要与平行链 B 建立通信通道时，平行链 A 必须向其网络发送一个打开通道的外在函数。这个外在函数也是一个 XCM！</p> <p>即使平行链 A 已经表达了与平行链 B 建立 XCM 通道的意图，但后者尚未向中继链发出接收来自平行链 A 的消息的信号。因此，为了建立一个已建立的通道，平行链 B 必须向中继链发送一个外在函数（一个 XCM）。接受通道的外在函数与前一个类似。但是，编码的调用数据仅包括新方法（接受通道）和发送者的平行链 ID（在本例中为平行链 A）。一旦两个平行链都同意，通道将在下一个时期内打开。</p> <p>要了解有关通道注册过程的更多信息，请参阅如何使用 Moonbeam 建立 XC 集成指南。</p> <p></p> <p>建立通道后，可以在平行链之间发送跨链消息。对于资产转移，资产需要先注册，然后才能通过 XCM 进行转移，可以通过将其内置到运行时作为常量或通过托盘来实现。Moonbeam 依靠 Substrate 托盘来处理资产注册，而无需运行时升级，从而使过程更加简单。</p> <p>要了解如何在 Moonbeam 上注册资产以及将 Moonbeam 资产添加到另一个链所需的信息，请参阅如何注册跨链资产 指南。</p>"}, {"location": "builders/interoperability/xcm/overview/#moonbeam-and-xcm", "title": "Moonbeam 上的 XCM", "text": "<p>由于 Moonbeam 是 Polkadot 生态系统中的一个平行链，因此 XCM 最直接的实现方式之一是能够实现从 Polkadot 和其他平行链到 Moonbeam 的资产转移。这允许用户将其代币引入 Moonbeam 及其所有 dApp。</p> <p>为此，Moonbeam 引入了 XC-20s，它扩展了 Moonbeam 独特的以太坊兼容性功能。XC-20 允许 Polkadot 原生资产通过预编译合约以标准 ERC-20 接口 表示。当这些资产在 Moonbeam 上注册后，它们可以设置为 XCM 执行费用资产。因此，当用户将此类资产转移到 Moonbeam 时，少量金额将用于支付 XCM 执行费用。</p> <p>此外，部署到 Moonbeam 的 ERC-20 可以通过 XCM 发送到 Polkadot 生态系统中的其他链。因此，从开发人员的角度来看，XC-20 是一种 ERC-20 代币，其额外的好处是它是一种 XCM 跨链资产，并且 dApp 可以通过熟悉的 ERC-20 接口轻松支持它们。</p> <p></p> <p>要通过 Moonbeam 在 Polkadot 生态系统中发送 XC-20，开发人员需要使用 Polkadot XCM Pallet 通过 Substrate API 进行传输，以及使用 X-Tokens Precompile 或 XCM Precompile 通过以太坊 API 进行传输。</p> <p>Moonbeam 的另一个独特功能是能够从 EVM 智能合约启动 XCM 操作，或通过远程执行通过 XCM 消息调用其 EVM。这开启了一系列新的可能性，Moonbeam 上的合约可以通过 XCM 访问特定于平行链的功能，或者其他平行链生态系统可以使用 Moonbeam 上的 EVM 智能合约来扩展其功能。</p> <p>以下部分提供了前面提到的主要用例的高级概述。</p>"}, {"location": "builders/interoperability/xcm/overview/#transfers-moonbeam-polkadot", "title": "Moonbeam 与 Polkadot 之间的 XCM 转移", "text": "<p>由于 Moonbeam 是 Polkadot 生态系统中的一个平行链，因此 XCM + VMP 的一个直接实现是从/到 Polkadot/Moonbeam 的 DOT 转移。为此，DOT 在 Moonbeam 上注册为 xcDOT。</p> <p>Alice (Polkadot) 希望将一定数量的 DOT 从 Polkadot 转移到她在 Moonbeam 上的账户，名为 Alith。因此，她发起一个表达其意图的 XCM。对于此类转移，Moonbeam 在 Polkadot 上拥有一个主权账户。</p> <p>因此，在 Polkadot 上执行 XCM 消息会将 DOT 的数量转移到 Moonbeam 在 Polkadot 上的主权账户。资产存入后，消息的第二部分将发送到 Moonbeam。</p> <p>Moonbeam 将在本地执行 XCM 消息计划执行的操作。在这种情况下，它是铸造并将相同数量的 xcDOT 转移到 Alice 定义的账户，在本例中为 Alith。在目标平行链中执行 XCM 的费用以被转移的资产（本例中为 xcDOT ）支付。</p> <p></p> <p>请注意以下事项：</p> <ul> <li>Alice 和 Alith 账户可能不同。例如，Polkadot 的账户是 SR25519（或 ED25519），而 Moonbeam 的账户是 ECDSA（以太坊风格）账户。它们也可以有不同的所有者</li> <li>在一定程度上存在信任，即一条链依赖另一条链来执行其 XCM 消息的一部分。这是在运行时级别编程的，因此可以轻松验证</li> <li>在此示例中，xcDOT 是 Moonbeam 在 Polkadot 上的主权账户中持有的原始 DOT 的包装表示。xcDOT 可以随时在 Moonbeam 内转移，也可以按 1:1 的比例兑换 DOT（减去一些费用）</li> </ul> <p>Alith 将她的 xcDOT 存入流动资金池。接下来，Charleth 通过与该流动资金池进行交换获得了一些 xcDOT，并且他想将一些 xcDOT 转移到 Charley 的 Polkadot 账户。因此，他发起一个表达其意图的 XCM。</p> <p>因此，在 Moonbeam 上执行 XCM 消息会将 xcDOT 的数量烧毁。资产烧毁后，消息的第二部分将发送到 Polkadot。</p> <p>Polkadot 将在本地执行 XCM 消息计划执行的操作。在这种情况下，它是将从 Moonbeam 主权账户烧毁的相同数量的 xcDOT 转移到 Charleth 定义的账户，在本例中为 Charley。</p> <p></p>"}, {"location": "builders/interoperability/xcm/overview/#transfers-moonbeam-other-parachains", "title": "Moonbeam 与其他平行链之间的 XCM 转移", "text": "<p>由于 Moonbeam 是 Polkadot 生态系统中的一个平行链，因此可以从 Moonbeam 和其他平行链进行 XCM 和 XCMP 资产转移的简单实现。本节概述了与 Polkadot/Moonbeam 的 XCM 相比的主要区别。</p> <p>首要条件是平行链之间必须存在双向通道，并且被转移的资产必须在目标平行链中注册。只有当两个条件都满足时，才能在平行链之间发送 XCM。</p> <p>然后，当 Alith (Moonbeam) 将一定数量的 GLMR 从 Moonbeam 转移到目标平行链中的另一个账户 (Alice) 时，代币将被发送到 Moonbeam 上由该目标平行链拥有的主权账户。</p> <p>当 XCM 消息在目标平行链中执行时，预计这将铸造并将相同数量的 xcGLMR（跨链 GLMR）转移到由 Alith 定义的账户，在本例中为 Alice。在目标平行链中执行 XCM 的费用以转移的资产（本例中为 xcGLMR）支付。</p> <p></p> <p>如上一节所述，xcGLMR 移回 Moonbeam 的过程类似。首先，XCM 消息执行会烧毁返回到 Moonbeam 的 xcGLMR 数量。烧毁后，消息的剩余部分通过中继链发送到 Moonbeam。Moonbeam 将在本地执行 XCM 消息，并将 GLMR（与烧毁的 xcGLMR 数量相同）从目标平行链主权账户转移到指定的地址。</p>"}, {"location": "builders/interoperability/xcm/overview/#execution-chains-moonbeam", "title": "其他链与 Moonbeam 之间的远程执行", "text": "<p>如前所述，XCM 还支持从/到 Moonbeam 对 Polkadot 生态系统中的其他链进行远程执行。</p> <p>与其他用例类似，在链之间进行远程执行之前，需要建立特定于 XCM 的通道。通道是通用的，因此它们可用于资产转移和远程执行。</p> <p>另一个重要的组成部分是用于支付远程执行费用的资产。在 Moonbeam 上，当注册 XC-20 时，可以将其设置为 XCM 执行费用资产。因此，当将该 XC-20 转移到 Moonbeam 时，XCM 执行费用将从转移的金额中扣除。对于远程执行，用户可以在 XCM 消息中包含少量代币，以支付 XCM 执行费用。</p> <p>Alice (Polkadot) 想要通过 Moonbeam 上的智能合约执行某个远程操作。因此，她发起了一个表达她意图的 XCM；她必须事先用 GLMR 或 xcDOT 为她在 Moonbeam 上拥有的 XCM 执行帐户注资。</p> <p>Moonbeam 将在本地执行 XCM 消息被编程执行的操作。在本例中，它是提取 Alice 决定的用于 XCM 执行费用的资产，并购买 Moonbeam 上的一些执行时间，以执行 Moonbeam EVM 上的智能合约调用。</p> <p>您可以在远程执行页面上详细了解该流程。</p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/", "title": "发送、执行和测试 XCM 消息", "text": ""}, {"location": "builders/interoperability/xcm/send-execute-xcm/#introduction", "title": "简介", "text": "<p>XCM 消息由一系列指令组成，这些指令由跨共识虚拟机（XCVM）执行。这些指令的组合会产生预定的操作，例如跨链代币转移。您可以通过组合各种 XCM 指令来创建自己的自定义 XCM 消息。</p> <p>诸如 Polkadot XCM 和 XCM Transactor 之类的 Pallet 提供了具有预定义 XCM 指令集的功能，以发送 XC-20 或通过 XCM 在其他链上远程执行。但是，为了更好地了解组合不同 XCM 指令的结果，您可以在 Moonbeam 上本地构建和执行自定义 XCM 消息（仅在 Moonbase Alpha 上可用）。您还可以将自定义 XCM 消息发送到另一个链（该链将以 <code>DescendOrigin</code> 指令开头）。尽管如此，为了成功执行 XCM 消息，目标链需要能够理解这些指令。</p> <p>要执行或发送自定义 XCM 消息，您可以直接使用 Polkadot XCM Pallet 或通过以太坊 API 使用 XCM Utilities Precompile。在本指南中，您将学习如何使用这两种方法在 Moonbase Alpha 上本地执行和发送自定义构建的 XCM 消息。</p> <p>本指南假定您熟悉一般的 XCM 概念，例如通用 XCM 术语和 XCM 指令。有关更多信息，您可以查看 XCM 概述 文档。</p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#polkadot-xcm-pallet-interface", "title": "Polkadot XCM Pallet 接口", "text": ""}, {"location": "builders/interoperability/xcm/send-execute-xcm/#extrinsics", "title": "外在函数", "text": "<p>Polkadot XCM Pallet 包含以下相关的外在函数（函数）：</p> execute(message, maxWeight) — 仅在 Moonbase Alpha 上支持 - 在源链上执行自定义 XCM 消息 参数Polkadot.js API 示例 <ul> <li><code>message</code> - 要执行的 SCALE 编码的版本化 XCM 消息</li> <li><code>maxWeight</code> - 允许消耗的最大权重，通过指定以下内容来定义：<ul> <li><code>refTime</code> - 可用于执行的计算时间量</li> <li><code>proofSize</code> - 可以使用的存储量（以字节为单位）</li> </ul> </li> </ul> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const message = { V4: [INSERT_XCM_INSTRUCTIONS] }; const maxWeight = { refTime: INSERT_REF_TIME, proofSize: INSERT_PROOF_SIZE };</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const tx = api.tx.polkadotXcm.execute(message, maxWeight);   const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING'); };</p> <p>main();</p> send(dest, message) — 仅在 Moonbase Alpha 上支持 - 将自定义 XCM 消息发送到目标链。为了成功执行 XCM 消息，目标链需要能够理解消息中的指令 参数Polkadot.js API 示例 <ul> <li><code>dest</code> - XCM 版本化的多位置，表示生态系统中 XCM 消息发送到的链（目标链）</li> <li><code>message</code> - 要执行的 SCALE 编码的版本化 XCM 消息</li> </ul> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const dest = { V4: { parents: INSERT_PARENTS, interior: INSERT_INTERIOR } }; const message = { V4: [INSERT_XCM_INSTRUCTIONS] };</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const tx = api.tx.polkadotXcm.send(dest, message);   const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING'); };</p> <p>main();</p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#storage-methods", "title": "存储方法", "text": "<p>Polkadot XCM Pallet 包含以下相关的只读存储方法：</p> assetTraps(hash) — 返回给定 asset 的哈希值，asset 被捕获的次数 参数返回值Polkadot.js API 示例 <p><code>hash</code> - (可选) <code>Asset</code> 的 Blake2-256 哈希值</p> <p>asset 被捕获的次数。如果省略了哈希值，则返回所有哈希值的数组以及每个 asset 被捕获的次数。</p> <p>js // 如果使用 Polkadot.js API 并在该值上调用 toJSON() // 如果提供了哈希值： 10</p> <p>// 如果省略了哈希值： [   [     0xf7d4341888be30c6a842a77c52617423e8109aa249e88779019cf731ed772fb7   ],   10 ], ...</p> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const trappedAssets = await api.query.polkadotXcm.assetTraps.entries();   trappedAssets.forEach(     ([       {         args: [hash],       },       count     ]) =&gt; {       console.log(         <code>Asset with hash ${hash.toJSON()} has been trapped ${count.toJSON()} times</code>       );     }   ); };</p> <p>main();</p> palletVersion() — 从存储返回当前 pallet 版本 参数返回值Polkadot.js API 示例 <p>无</p> <p>一个表示 pallet 当前版本的数字。</p> <p>js // 如果使用 Polkadot.js API 并在解包的值上调用 toJSON() 0</p> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const palletVersion = await api.query.polkadotXcm.palletVersion(); };</p> <p>main();</p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要继续学习本指南，您需要以下内容：</p> <ul> <li>您的帐户必须有 DEV 代币。   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#execute-an-xcm-message-locally", "title": "在本地执行 XCM 消息", "text": "<p>本指南的这一部分介绍了通过两种不同的方法构建要在本地（即在 Moonbeam 中）执行的自定义 XCM 消息的过程：Polkadot XCM Pallet 的 <code>execute</code> 函数和 XCM Utilities Precompile 的 <code>xcmExecute</code> 函数。此功能为您提供了一个试验场，可以试验不同的 XCM 指令，并亲身了解这些实验的结果。这还可以帮助您确定 Moonbeam 上给定 XCM 消息相关的费用。</p> <p>在下面的示例中，您将把 DEV 代币从 Moonbase Alpha 上的一个帐户转移到另一个帐户。为此，您将构建一个包含以下 XCM 指令的 XCM 消息，这些指令在本地执行（在本例中，在 Moonbase Alpha 上）：</p> <ul> <li><code>WithdrawAsset</code> - 移除资产并将其放入持有寄存器</li> <li><code>DepositAsset</code> - 从持有寄存器中移除资产并将等效资产存入受益人帐户</li> </ul> <p>Note</p> <p>通常，当您将 XCM 消息跨链发送到目标链时，需要 <code>BuyExecution</code> 指令 来支付远程执行的费用。但是，对于本地执行，此指令不是必需的，因为您已经通过外部函数调用收费。</p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#execute-an-xcm-message-with-polkadotjs-api", "title": "使用 Polkadot.js API 执行 XCM 消息", "text": "<p>在此示例中，您将使用 Polkadot.js API 在 Moonbase Alpha 上本地执行自定义 XCM 消息，以直接与 Polkadot XCM Pallet 交互。</p> <p>Polkadot XCM Pallet 的 <code>execute</code> 函数接受两个参数：<code>message</code> 和 <code>maxWeight</code>。您可以按照以下步骤开始组装这些参数：</p> <ol> <li> <p>构建 <code>WithdrawAsset</code> 指令，这将要求您定义：</p> <ul> <li>Moonbase Alpha 上 DEV 令牌的多重地址</li> <li>要转移的 DEV 令牌数量</li> </ul> <pre><code>const instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 100000000000000000n }, // 0.1 DEV\n    },\n  ],\n};\n</code></pre> </li> <li> <p>构建 <code>DepositAsset</code> 指令，这将要求您定义：</p> <ul> <li>DEV 令牌的资产标识符。您可以使用 <code>WildAsset</code> 格式，它允许通配符匹配，以识别资产</li> <li>Moonbase Alpha 上受益人账户的多重地址</li> </ul> <pre><code>const instr2 = {\n  DepositAsset: {\n    assets: {\n      Wild: {\n        AllCounted: 1,\n      },\n    },\n    beneficiary: {\n      parents: 0,\n      interior: {\n        X1: [\n          {\n            AccountKey20: {\n              key: '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0',\n            },\n          },\n        ],\n      },\n    },\n  },\n};\n</code></pre> </li> <li> <p>将 XCM 指令合并到版本化的 XCM 消息中：</p> <pre><code>const message = { V4: [instr1, instr2] };\n</code></pre> </li> <li> <p>指定 <code>maxWeight</code>，其中包括您需要定义的 <code>refTime</code> 和 <code>proofSize</code> 的值。您可以通过将 XCM 消息作为参数提供给 <code>xcmPaymentApi</code> 运行时调用的 <code>queryXcmWeight</code> 方法来获取这两个值。</p> <pre><code>const maxWeight = { refTime: 7250000000n, proofSize: 19374n };\n</code></pre> </li> </ol> <p>现在您已经获得了每个参数的值，您可以编写执行脚本。您将执行以下步骤：</p> <ol> <li>提供调用的输入数据。这包括：<ul> <li>用于创建提供程序的 Moonbase Alpha 终端节点 URL</li> <li><code>execute</code> 函数的每个参数的值</li> </ul> </li> <li>创建一个 Keyring 实例，该实例将用于发送交易</li> <li>创建 Polkadot.js API 提供程序</li> <li>使用 <code>message</code> 和 <code>maxWeight</code> 制作 <code>polkadotXcm.execute</code> 外部函数</li> <li>使用 <code>signAndSend</code> 外部函数和您在第二步中创建的 Keyring 实例发送交易</li> </ol> <p>Remember</p> <p>这仅用于演示目的。切勿将私钥存储在 JavaScript 文件中。</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\n// 1. Provide input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 100000000000000000n }, // 0.1 DEV\n    },\n  ],\n};\nconst instr2 = {\n  DepositAsset: {\n    assets: {\n      Wild: {\n        AllCounted: 1,\n      },\n    },\n    beneficiary: {\n      parents: 0,\n      interior: {\n        X1: [\n          {\n            AccountKey20: {\n              key: '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0',\n            },\n          },\n        ],\n      },\n    },\n  },\n};\nconst message = { V4: [instr1, instr2] };\nconst maxWeight = { refTime: 7250000000n, proofSize: 19374n };\n\nconst executeXcmMessage = async () =&gt; {\n  // 2. Create Keyring instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'ethereum' });\n  const alice = keyring.addFromUri(privateKey);\n\n  // 3. Create Substrate API provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 4. Craft the extrinsic\n  const tx = api.tx.polkadotXcm.execute(message, maxWeight);\n\n  // 5. Send the transaction\n  const txHash = await tx.signAndSend(alice);\n  console.log(`Submitted with hash ${txHash}`);\n\n  api.disconnect();\n};\n\nexecuteXcmMessage();\n</code></pre> <p>Note</p> <p>您可以在 Polkadot.js Apps 上查看上述脚本的示例，该脚本将 1 DEV 发送到 Moonbase Alpha 上的 Bob 帐户，使用以下编码的 calldata：<code>0x1c030408000400010403001300008a5d784563010d010204000103003cd0a705a2dc65e5b1e1205896baa2be8a07c6e007803822b001ba2e0100</code>。</p> <p>交易处理完毕后，应从 Alice 的帐户中扣除 0.1 DEV 令牌以及相关的 XCM 费用，并且目标帐户应已在其帐户中收到 0.1 DEV 令牌。将发出一个 <code>polkadotXcm.Attempted</code> 事件，其中包含结果。</p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#test-an-xcm-message-with-the-dry-run-api", "title": "使用 Dry Run API 测试 XCM 消息", "text": "<p>XCM Dry Run API 是一种简单方便的方式来测试 XCM 消息的完整性，而无需产生任何交易费用。XCM Dry Run API 可以从 Polkadot.js Apps 的 Developer 部分的 Runtime Calls 标签页进行访问。</p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#dry-run-call-api-method", "title": "Dry Run Call API 方法", "text": "<p>此方法将 origin 和调用数据作为参数，并返回执行结果、实际权重和事件数据。</p> <p>javascript const testAccount = api.createType(   'AccountId20',   '0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798' ); const callData =   '0x1c030408000400010403001300008a5d784563010d010204000103003cd0a705a2dc65e5b1e1205896baa2be8a07c6e007803822b001ba2e0100'; const callDataU8a = hexToU8a(callData);</p> <p>const result = await api.call.dryRunApi.dryRunCall(   { system: { Signed: testAccount } },   callDataU8a );</p> 查看完整脚本 <p>js import { ApiPromise, WsProvider } from '@polkadot/api'; import { hexToU8a } from '@polkadot/util';</p> <p>const main = async () =&gt; {   try {     // Construct API provider     const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');     const api = await ApiPromise.create({ provider: wsProvider });</p> <pre><code>console.log('Connected to the API. Preparing dry run call...');\n\n// Create a test account (you should replace this with an actual account)\nconst testAccount = api.createType(\n  'AccountId20',\n  '0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798'\n);\n\n// The call data (replace with your actual call data)\nconst callData =\n  '0x1c030408000400010403001300008a5d784563010d010204000103003cd0a705a2dc65e5b1e1205896baa2be8a07c6e007803822b001ba2e0100'; // Your hex-encoded call data\n\n// Convert hex to Uint8Array\nconst callDataU8a = hexToU8a(callData);\n\n// Perform the dry run call\nconst result = await api.call.dryRunApi.dryRunCall(\n  { system: { Signed: testAccount } }, // origin\n  callDataU8a // call\n);\n\nconsole.log(\n  'Dry run XCM result:',\n  JSON.stringify(result.toJSON(), null, 2)\n);\n\n// Disconnect the API\nawait api.disconnect();\nconsole.log('Disconnected from the API.');\n</code></pre> <p>} catch (error) {     console.error('An error occurred:', error);   } };</p> <p>main().catch(console.error);</p> <p>调用 XCM Dry Run API 后，该方法将告诉您调用是否会成功，并返回如果实际在链上提交调用将会发出的事件数据。您可以在下面查看<code>dryRunCall</code>的初始输出。</p> 查看完整输出 <p>Dry run XCM result: {   \"ok\": {     \"executionResult\": {       \"ok\": {         \"actualWeight\": {           \"refTime\": 7301615000,           \"proofSize\": 20928         },         \"paysFee\": \"Yes\"       }     },     \"emittedEvents\": [       {         \"index\": \"0x030b\",         \"data\": [           \"0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798\",           \"0x0000000000000000016345785d8a0000\"         ]       },       {         \"index\": \"0x0300\",         \"data\": [           \"0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0\",           \"0x0000000000000000016345785d8a0000\"         ]       },       {         \"index\": \"0x030a\",         \"data\": [           \"0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0\",           \"0x0000000000000000016345785d8a0000\"         ]       },       {         \"index\": \"0x1c00\",         \"data\": [           {             \"complete\": {               \"used\": {                 \"refTime\": 7250000000,                 \"proofSize\": 19374               }             }           }         ]       }     ],     \"localXcm\": {       \"v4\": [         {           \"withdrawAsset\": [             {               \"id\": {                 \"parents\": 0,                 \"interior\": {                   \"x1\": [                     {                       \"palletInstance\": 3                     }                   ]                 }               },               \"fun\": {                 \"fungible\": \"0x0000000000000000016345785d8a0000\"               }             }           ]         },         {           \"depositAsset\": {             \"assets\": {               \"wild\": {                 \"allCounted\": 1               }             },             \"beneficiary\": {               \"parents\": 0,               \"interior\": {                 \"x1\": [                   {                     \"accountKey20\": {                       \"network\": null,                       \"key\": \"0x3cd0a705a2dc65e5b1e1205896baa2be8a07c6e0\"                     }                   }                 ]               }             }           }         }       ]     } // Additional events returned here       // Omitted for clarity </p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#dry-run-xcm-api-method", "title": "Dry Run XCM API 方法", "text": "<p>XCM Dry Run API 的 <code>dryRunXCM</code> 方法将完整的 XCM 消息作为参数，而不是编码的调用，以及消息的来源。</p> <p><code>dryRunXCM</code> 将来源和 XCM 消息作为参数，并返回执行结果、实际权重和事件数据。</p> <p>javascript // 定义来源 const origin = { V4: { parents: 1, interior: 'Here' } };</p> <p>const message = []; // 在此处插入 XCM 消息</p> <p>// 执行 dry run XCM 调用 const result = await api.call.dryRunApi.dryRunXcm(origin, message);</p> 查看完整脚本 <p>js import { ApiPromise, WsProvider } from '@polkadot/api'; import { hexToU8a } from '@polkadot/util';</p> <p>const main = async () =&gt; {   try {     // Construct API provider     const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');     const api = await ApiPromise.create({ provider: wsProvider });     console.log('Connected to the API. Preparing dry run XCM call...');</p> <pre><code>// Define the origin\nconst origin = { V4: { parents: 1, interior: 'Here' } };\nconst amountToSend = 1000000000000;\n\nconst message = {\n  V4: [\n    {\n      WithdrawAsset: [\n        {\n          id: { parents: 1, interior: 'Here' },\n          fun: { Fungible: amountToSend },\n        },\n      ],\n    },\n    {\n      BuyExecution: {\n        fees: {\n          id: { parents: 1, interior: 'Here' },\n          fun: { Fungible: amountToSend },\n        },\n        weightLimit: { Unlimited: null },\n      },\n    },\n    {\n      DepositAsset: {\n        assets: { Wild: { AllOf: { id: { parents: 1, interior: 'Here' } } } },\n        maxAssets: 1,\n        beneficiary: {\n          parents: 0,\n          interior: {\n            X1: [\n              {\n                AccountKey20: {\n                  network: null,\n                  key: hexToU8a('0x3B939FeaD1557C741Ff06492FD0127bd287A421e')\n                }\n              }\n            ]\n          }\n        }\n      }\n    }\n  ],\n};\n\n// Perform the dry run XCM call\nconst result = await api.call.dryRunApi.dryRunXcm(origin, message);\n\nconsole.log(\n  'Dry run XCM result:',\n  JSON.stringify(result.toJSON(), null, 2)\n);\n\nawait api.disconnect();\nconsole.log('Disconnected from the API.');\n</code></pre> <p>} catch (error) {     console.error('An error occurred:', error);   } };</p> <p>main().catch(console.error);</p> <p>调用 XCM Dry Run API 后，该方法将告诉您调用是否成功，并返回如果 XCM 实际在链上提交将发出的事件数据。您可以在下面查看 <code>dryRunXCM</code> 的初始输出。</p> 查看完整输出 <p>Dry run XCM result: {   \"ok\": {     \"executionResult\": {       \"complete\": {         \"used\": {           \"refTime\": 76473048000,           \"proofSize\": 222483         }       }     },     \"emittedEvents\": [       {         \"index\": \"0x1d03\",         \"data\": [           \"0x1fcacbd218edc0eba20fc2308c778080\",           \"0x506172656E740000000000000000000000000000\",           1000000000000         ]       },       {         \"index\": \"0x1d01\",         \"data\": [           \"0x1fcacbd218edc0eba20fc2308c778080\",           \"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",           959944978002         ]       },       {         \"index\": \"0x1d01\",         \"data\": [           \"0x1fcacbd218edc0eba20fc2308c778080\",           \"0x6d6F646c70632f74727372790000000000000000\",           40055021998         ]       }     ], // Additional events returned here       // Omitted for clarity </p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#execute-xcm-utils-precompile", "title": "使用 XCM Utilities Precompile 执行 XCM 消息", "text": "<p>在本节中，您将使用XCM Utilities Precompile的 <code>xcmExecute</code> 函数，该函数仅在 Moonbase Alpha 上受支持，以在本地执行 XCM 消息。XCM Utilities Precompile 位于以下地址：</p> <pre><code>0x000000000000000000000000000000000000080C\n</code></pre> <p>在底层，XCM Utilities Precompile 的 <code>xcmExecute</code> 函数调用 Polkadot XCM Pallet 的 <code>execute</code> 函数，这是一个用 Rust 编写的 Substrate pallet。使用 XCM Utilities Precompile 调用 <code>xcmExecute</code> 的好处是，您可以通过 Ethereum API 进行调用，并使用 Ethereum libraries，例如 Ethers.js。</p> <p><code>xcmExecute</code> 函数接受两个参数：要执行的 SCALE 编码的版本化 XCM 消息和要消耗的最大权重。</p> <p>首先，您将学习如何生成编码后的 calldata，然后您将学习如何使用编码后的 calldata 与 XCM Utilities Precompile 交互。</p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#generate-encoded-calldata", "title": "生成 XCM 消息的编码 Calldata", "text": "<p>要获取 XCM 消息的编码 calldata，您可以创建一个类似于您在 使用 Polkadot.js API 执行 XCM 消息 部分中创建的脚本。 您将构建消息以获取编码的 calldata，而不是构建消息并发送交易。 您将采取以下步骤：</p> <ol> <li>提供调用的输入数据。 这包括：<ul> <li>用于创建提供者的 Moonbase Alpha 端点 URL</li> <li><code>execute</code> 函数的每个参数的值，如使用 Polkadot.js API 执行 XCM 消息 部分中定义的那样</li> </ul> </li> <li>创建 Polkadot.js API 提供程序</li> <li>使用 <code>message</code> 和 <code>maxWeight</code> 制作 <code>polkadotXcm.execute</code> 外部函数</li> <li>使用事务获取编码的 calldata</li> </ol> <p>整个脚本如下：</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\n// 1. Provide input data\nconst moonbeamAccount = 'INSERT_ADDRESS';\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 100000000000000000n },\n    },\n  ],\n};\nconst instr2 = {\n  DepositAsset: {\n    assets: { Wild: { AllCounted: 1 } },\n    beneficiary: {\n      parents: 0,\n      interior: {\n        X1: [\n          {\n            AccountKey20: {\n              key: moonbeamAccount,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\nconst message = { V4: [instr1, instr2] };\nconst maxWeight = { refTime: 7250000000n, proofSize: 19374n };\n\nconst getEncodedXcmMessage = async () =&gt; {\n  // 2. Create Substrate API provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Craft the extrinsic\n  const tx = api.tx.polkadotXcm.execute(message, maxWeight);\n\n  // 4. Get the encoded XCM message\n  // By using index 0, you'll get just the encoded XCM message.\n  // If you wanted to get the maxWeight, you could use index 1\n  const encodedXcmMessage = tx.args[0].toHex();\n  console.log(`Encoded Calldata for XCM Message: ${encodedXcmMessage}`);\n\n  api.disconnect();\n};\n\ngetEncodedXcmMessage();\n</code></pre>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#execute-xcm-message", "title": "执行 XCM 消息", "text": "<p>现在您已经有了 SCALE 编码的 XCM 消息，您可以使用以下代码片段以编程方式调用 XCM Utilities Precompile 的 <code>xcmExecute</code> 函数，使用您选择的 以太坊库。一般来说，您需要执行以下步骤：</p> <ol> <li>创建 provider 和签名者</li> <li>创建一个 XCM Utilities Precompile 实例以进行交互</li> <li>定义 <code>xcmExecute</code> 函数所需的参数，这将是 XCM 消息的编码 calldata 和用于执行消息的最大权重。您可以将 <code>maxWeight</code> 设置为 <code>400000000n</code>，这对应于 <code>refTime</code>。<code>proofSize</code> 将自动设置为默认值，即 64KB</li> <li>执行 XCM 消息</li> </ol> <p>Remember</p> <p>以下代码段仅用于演示目的。切勿将您的私钥存储在 JavaScript 或 Python 文件中。</p> <p>===\"Ethers.js\"</p> <pre><code>```js\nimport { ethers } from 'ethers'; // Import Ethers library\nimport abi from './xcmUtilsABI.js'; // Import the XCM Utilities Precompile ABI\n\nconst privateKey = 'INSERT_YOUR_PRIVATE_KEY';\nconst xcmUtilsAddress = '0x000000000000000000000000000000000000080C';\n\n/* Create Ethers provider and signer */\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n/* Create contract instance of the XCM Utilities Precompile */\nconst xcmUtils = new ethers.Contract(\n  xcmUtilsAddress,\n  abi,\n  signer\n);\n\nconst executeXcmMessageLocally = async () =&gt; {\n  /* Define parameters required for the xcmExecute function */\n  const encodedCalldata = 'INSERT_ENCODED_CALLDATA';\n  const maxWeight = '400000000';\n\n  /* Execute the custom XCM message */\n  const tx = await xcmUtils.xcmExecute(encodedCalldata, maxWeight);\n  await tx.wait();\n  console.log(`Transaction receipt: ${tx.hash}`);\n};\n\nexecuteXcmMessageLocally();\n```\n</code></pre> <p>===\"Web3.js\"</p> <pre><code>```js\nimport { Web3 } from 'web3'; // Import Web3 library\nimport abi from './xcmUtilsABI.js'; // Import the XCM Utilities Precompile ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst accountFrom = web3.eth.accounts.privateKeyToAccount(privateKey).address;\nconst xcmUtilsAddress = '0x000000000000000000000000000000000000080C';\n\n/* Create Web3 provider */\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n/* Create contract instance of the XCM Utilities Precompile */\nconst xcmUtils = new web3.eth.Contract(\n  abi,\n  xcmUtilsAddress,\n  { from: accountFrom } // 'from' is necessary for gas estimation\n);\n\nconst executeXcmMessageLocally = async () =&gt; {\n  /* Define parameters required for the xcmExecute function */\n  const encodedCalldata = 'INSERT_ENCODED_CALLDATA';\n  const maxWeight = '400000000';\n\n  /* Send the custom XCM message */\n  // Craft the extrinsic\n  const tx = await xcmUtils.methods.xcmExecute(encodedCalldata, maxWeight);\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: xcmUtilsAddress,\n      data: tx.encodeABI(),\n      gas: await tx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom),\n    },\n    privateKey\n  );\n  // Send the signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(`Transaction receipt: ${sendTx.transactionHash}`);\n};\n\nexecuteXcmMessageLocally();\n\n```\n</code></pre> <p>===\"Web3.py\"</p> <pre><code>```py\nfrom web3 import Web3\n\nabi = \"INSERT_XCM_UTILS_ABI\"  # Paste or import the XCM Utils ABI\n# This is for demo purposes, never store your private key in plain text\nprivate_key = \"INSERT_PRIVATE_KEY\"\n# The wallet address that corresponds to your private key\naddress = \"INSERT_ADDRESS\"\nxcm_utils_address = \"0x000000000000000000000000000000000000080C\"\n\n## Create Web3 provider ##\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n## Create contract instance of the XCM Utilities Precompile ##\nxcm_utils = web3.eth.contract(\n    # XCM Utilities Precompile address\n    address=xcm_utils_address,\n    abi=abi,\n)\n\n\ndef execute_xcm_message_locally():\n    ## Define parameters required for the xcmExecute function ##\n    encoded_calldata = \"INSERT_ENCODED_CALLDATA\"\n    max_weight = 400000000\n\n    ## Execute the custom XCM message ##\n    # Craft the extrinsic\n    tx = xcm_utils.functions.xcmExecute(encoded_calldata, max_weight).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n    # Sign transaction\n    signedTx = web3.eth.account.sign_transaction(tx, private_key)\n    # Send tx\n    hash = web3.eth.send_raw_transaction(signedTx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Transaction receipt: { receipt.transactionHash.hex() }\")\n\n\nexecute_xcm_message_locally()\n\n```\n</code></pre> <p>就这样！您已成功使用 Polkadot XCM Pallet 和 XCM Utilities Precompile 在 Moonbase Alpha 上本地执行自定义 XCM 消息！</p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#send-xcm-message", "title": "跨链发送 XCM 消息", "text": "<p>本指南的这一部分介绍了通过两种不同的方法跨链发送自定义 XCM 消息（即，从 Moonbeam 到目标链，如中继链）的过程：Polkadot XCM Pallet 的 <code>send</code> 函数和 XCM Utilities Precompile 的 <code>xcmSend</code> 函数。</p> <p>要使 XCM 消息成功执行，目标链需要能够理解消息中的指令。如果不能，您将在目标链上看到 <code>Barrier</code> 过滤器。出于安全原因，XCM 消息以 <code>DescendOrigin</code> 指令开头，以防止代表原始链主权帐户执行 XCM。本节中的示例由于上述原因将不起作用，仅用于演示目的。</p> <p>在下面的示例中，您将构建一个包含以下 XCM 指令的 XCM 消息，这些指令将在 Alphanet 中继链中执行：</p> <ul> <li><code>WithdrawAsset</code> - 移除资产并将其放入持有寄存器</li> <li><code>BuyExecution</code> - 从持有寄存器中提取资产以支付执行费用。要支付的费用由目标链确定</li> <li><code>DepositAsset</code>- 从持有寄存器中移除资产并将等效资产存入受益人帐户</li> </ul> <p>总而言之，这些指令的目的是将中继链的本地资产（Alphanet 中继链的 UNIT）从 Moonbase Alpha 转移到中继链上的一个帐户。此示例仅用于演示目的，向您展示如何跨链发送自定义 XCM 消息。请记住，目标链需要能够理解消息中的指令才能执行它们。</p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#send-xcm-message-with-polkadotjs-api", "title": "使用 Polkadot.js API 发送 XCM 消息", "text": "<p>在此示例中，您将使用 Polkadot.js API 从 Moonbase Alpha 上的帐户向中继链发送自定义 XCM 消息，以直接与 Polkadot XCM Pallet 交互。</p> <p>Polkadot XCM Pallet 的 <code>send</code> 函数接受两个参数：<code>dest</code> 和 <code>message</code>。您可以按照以下步骤开始组装这些参数：</p> <ol> <li> <p>为 <code>dest</code> 构建中继链令牌 UNIT 的多重定位：</p> <pre><code>const dest = { V4: { parents: 1, interior: null } };\n</code></pre> </li> <li> <p>构建 <code>WithdrawAsset</code> 指令，这将需要您定义：</p> <ul> <li>中继链上 UNIT 令牌的多重定位</li> <li>要提取的 UNIT 令牌数量</li> </ul> <pre><code>const instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n  ],\n};\n</code></pre> </li> <li> <p>构建 <code>BuyExecution</code> 指令，这将需要您定义：</p> <ul> <li>中继链上 UNIT 令牌的多重定位</li> <li>为执行购买的 UNIT 令牌数量</li> <li>权重限制</li> </ul> <pre><code>const instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n    { Unlimited: null },\n  ],\n};\n</code></pre> </li> <li> <p>构建 <code>DepositAsset</code> 指令，这将需要您定义：</p> <ul> <li>UNIT 令牌的资产标识符。您可以使用 <code>WildAsset</code> 格式，它允许通配符匹配，以标识资产</li> <li>中继链上受益人帐户的多重定位</li> </ul> <pre><code>const instr3 = {\n  DepositAsset: {\n    assets: { Wild: 'All' },\n    beneficiary: {\n      parents: 1,\n      interior: {\n        X1: [\n          {\n            AccountId32: {\n              id: relayAccount,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\n</code></pre> </li> <li> <p>将 XCM 指令组合成一个版本化的 XCM 消息：</p> <pre><code>const message = { V4: [instr1, instr2, instr3] };\n</code></pre> </li> </ol> <p>现在您已经获得了每个参数的值，您可以编写脚本来发送 XCM 消息。您将采取以下步骤：</p> <ol> <li>提供调用的输入数据。这包括：<ul> <li>用于创建提供程序的 Moonbase Alpha 终结点 URL</li> <li><code>send</code> 函数的每个参数的值</li> </ul> </li> <li>创建将用于发送交易的 Keyring 实例</li> <li>创建 Polkadot.js API 提供程序</li> <li>使用 <code>dest</code> 和 <code>message</code> 制作 <code>polkadotXcm.send</code> 外部函数</li> <li>使用 <code>signAndSend</code> 外部函数和您在第二步中创建的 Keyring 实例发送交易</li> </ol> <p>Remember</p> <p>这仅用于演示目的。切勿将您的私钥存储在 JavaScript 文件中。</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady, decodeAddress } from '@polkadot/util-crypto';\n\n// 1. Input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\n// You can use the decodeAddress function to ensure that your address is properly\n// decoded. If it isn't decoded, it will decode it and if it is, it will ignore it\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst relayAccount = decodeAddress('INSERT_ADDRESS');\nconst dest = { V4: { parents: 1, interior: null } };\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n  ],\n};\nconst instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n    { Unlimited: null },\n  ],\n};\nconst instr3 = {\n  DepositAsset: {\n    assets: { Wild: 'All' },\n    beneficiary: {\n      parents: 1,\n      interior: {\n        X1: [\n          {\n            AccountId32: {\n              id: relayAccount,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\nconst message = { V4: [instr1, instr2, instr3] };\n\nconst sendXcmMessage = async () =&gt; {\n  // 2. Create Keyring instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'ethereum' });\n  const alice = keyring.addFromUri(privateKey);\n\n  // 3. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 4. Create the extrinsic\n  const tx = api.tx.polkadotXcm.send(dest, message);\n\n  // 5. Send the transaction\n  const txHash = await tx.signAndSend(alice);\n  console.log(`Submitted with hash ${txHash}`);\n\n  api.disconnect();\n};\n\nsendXcmMessage();\n</code></pre> <p>Note</p> <p>您可以在 Polkadot.js Apps 上查看上述脚本的示例，该脚本将 1 UNIT 发送到 Bob 的中继链帐户，使用以下编码的calldata：<code>0x1c00040100040c0004010000070010a5d4e813010000070010a5d4e8000d0100010101000c36e9ba26fa63c60ec728fe75fe57b86a450d94e7fee7f9f9eddd0d3f400d67</code>。</p> <p>交易处理完毕后，将发出一个 <code>polkadotXcm.sent</code> 事件，其中包含已发送 XCM 消息的详细信息。</p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#send-xcm-utils-precompile", "title": "使用 XCM Utilities 预编译发送 XCM 消息", "text": "<p>在本节中，您将使用 XCM Utilities 预编译 的 <code>xcmSend</code> 函数，该函数仅在 Moonbase Alpha 上受支持，以跨链发送 XCM 消息。XCM Utilities 预编译位于以下地址：</p> Moonbase Alpha <pre><code>0x000000000000000000000000000000000000080C\n</code></pre> <p>在底层，XCM Utilities 预编译的 <code>xcmSend</code> 函数调用 Polkadot XCM Pallet 的 <code>send</code> 函数，Polkadot XCM Pallet 是一个用 Rust 编写的 Substrate pallet。使用 XCM Utilities 预编译调用 <code>xcmSend</code> 的好处是，您可以通过 Ethereum API 并使用 Ethereum 库（如 Ethers.js）来执行此操作。为了成功执行 XCM 消息，目标链需要能够理解消息中的指令。</p> <p><code>xcmSend</code> 函数接受两个参数：目标的 multilocation 和要发送的 SCALE 编码的版本化 XCM 消息。</p> <p>首先，您将学习如何为 XCM 消息生成编码的 calldata，然后您将学习如何使用编码的 calldata 与 XCM Utilities 预编译交互。</p>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#generate-encoded-calldata", "title": "生成 XCM 消息的编码 Calldata", "text": "<p>要获取 XCM 消息的编码 calldata，您可以创建一个类似于您在使用 Polkadot.js API 发送 XCM 消息 部分中创建的脚本。 您将构建消息以获取编码的 calldata，而不是构建消息并发送交易。 您将采取以下步骤：</p> <ol> <li>提供调用的输入数据。 这包括：<ul> <li>用于创建提供者的 Moonbase Alpha 端点 URL</li> <li><code>send</code> 函数的每个参数的值，如使用 Polkadot.js API 发送 XCM 消息部分中所定义</li> </ul> </li> <li>创建 Polkadot.js API 提供程序</li> <li>使用 <code>message</code> 和 <code>maxWeight</code> 制作 <code>polkadotXcm.execute</code> 外部函数</li> <li>使用交易获取编码的 calldata</li> </ol> <p>整个脚本如下：</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\nimport { decodeAddress } from '@polkadot/util-crypto';\n\n// 1. Input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\n// You can use the decodeAddress function to ensure that your address is properly\n// decoded. If it isn't decoded, it will decode it and if it is, it will ignore it\nconst relayAccount = decodeAddress('INSERT_ADDRESS');\nconst dest = { V4: { parents: 1, interior: null } };\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n  ],\n};\nconst instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n    { Unlimited: null },\n  ],\n};\nconst instr3 = {\n  DepositAsset: {\n    assets: { Wild: 'All' },\n    beneficiary: {\n      parents: 1,\n      interior: {\n        X1: [\n          {\n            AccountId32: {\n              id: relayAccount,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\nconst message = { V4: [instr1, instr2, instr3] };\n\nconst generateEncodedXcmMessage = async () =&gt; {\n  // 2. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Create the extrinsic\n  const tx = api.tx.polkadotXcm.send(dest, message);\n\n  // 4. Get the encoded XCM message\n  // By using index 1, you'll get just the encoded XCM message.\n  // If you wanted to get the dest, you could use index 0\n  const encodedXcmMessage = tx.args[1].toHex();\n  console.log(`Encoded Calldata for XCM Message: ${encodedXcmMessage}`);\n\n  api.disconnect();\n};\n\ngenerateEncodedXcmMessage();\n</code></pre>"}, {"location": "builders/interoperability/xcm/send-execute-xcm/#send-xcm-message", "title": "发送 XCM 消息", "text": "<p>在您可以发送 XCM 消息之前，您还需要构建目标的多重位置。在本例中，您将以 Moonbase Alpha 作为原始链来定位中继链：</p> <pre><code>const dest = [\n  1, // Parents: 1\n  [] // Interior: Here\n];\n</code></pre> <p>现在您有了 SCALE 编码的 XCM 消息和目标多重位置，您可以使用以下代码片段以编程方式调用 XCM Utilities Precompile 的 <code>xcmSend</code> 函数，方法是使用您选择的 Ethereum 库。一般来说，您需要执行以下步骤：</p> <ol> <li>创建提供者和签名者</li> <li>创建 XCM Utilities Precompile 的实例以进行交互</li> <li>定义 <code>xcmSend</code> 函数所需的参数，这将是 XCM 消息的目标和编码的 calldata</li> <li>发送 XCM 消息</li> </ol> <p>Remember</p> <p>以下代码段仅用于演示目的。切勿将您的私钥存储在 JavaScript 或 Python 文件中。</p> <p>===</p> <pre><code>```js\nimport { ethers } from 'ethers'; // Import Ethers library\nimport abi from './xcmUtilsABI.js'; // Import the XCM Utilities Precompile ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst xcmUtilsAddress = '0x000000000000000000000000000000000000080C';\n\n/* Create Ethers provider and signer */\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n/* Create contract instance of the XCM Utilities Precompile */\nconst xcmUtils = new ethers.Contract(\n  xcmUtilsAddress,\n  abi,\n  signer\n);\n\nconst sendXcm = async () =&gt; {\n  /* Define parameters required for the xcmSend function */\n  const encodedCalldata = 'INSERT_ENCODED_CALLDATA';\n  const dest = [\n    1, // Parents: 1 \n    [] // Interior: Here\n  ];\n\n  /* Send the custom XCM message */\n  const tx = await xcmUtils.xcmSend(dest, encodedCalldata);\n  await tx.wait();\n  console.log(`Transaction receipt: ${tx.hash}`);\n};\n\nsendXcm();\n```\n</code></pre> <p>===</p> <pre><code>```js\nimport { Web3 } from 'web3'; // Import Web3 library\nimport abi from './xcmUtilsABI.js'; // Import the XCM Utilities Precompile ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst accountFrom = web3.eth.accounts.privateKeyToAccount(privateKey).address;\nconst xcmUtilsAddress = '0x000000000000000000000000000000000000080C';\n\n/* Create Web3 provider */\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n/* Create contract instance of the XCM Utilities Precompile */\nconst xcmUtils = new web3.eth.Contract(\n  abi,\n  xcmUtilsAddress,\n  { from: accountFrom } // 'from' is necessary for gas estimation\n);\n\nconst sendXcm = async () =&gt; {\n  /* Define parameters required for the xcmSend function */\n  const encodedCalldata = 'INSERT_ENCODED_CALLDATA';\n  const dest = [\n    1, // Parents: 1\n    [], // Interior: Here\n  ];\n\n  /* Send the custom XCM message */\n  // Craft the extrinsic\n  const tx = await xcmUtils.methods.xcmSend(dest, encodedCalldata);\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: xcmUtilsAddress,\n      data: tx.encodeABI(),\n      gas: await tx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom),\n    },\n    privateKey\n  );\n  // Send the signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(`Transaction receipt: ${sendTx.transactionHash}`);\n};\n\nsendXcm();\n\n```\n</code></pre> <p>===</p> <pre><code>```py\nfrom web3 import Web3\n\nabi = \"INSERT_XCM_UTILS_ABI\"  # Paste or import the XCM Utils ABI\n# This is for demo purposes, never store your private key in plain text\nprivate_key = \"INSERT_PRIVATE_KEY\"\n# The wallet address that corresponds to your private key\naddress = \"INSERT_ADDRESS\"\nxcm_utils_address = \"0x000000000000000000000000000000000000080C\"\n\n## Create Web3 provider ##\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n## Create contract instance of the XCM Utilities Precompile ##\nxcm_utils = web3.eth.contract(\n    # XCM Utilities Precompile address\n    address=xcm_utils_address,\n    abi=abi,\n)\n\n\ndef send_xcm():\n    ## Define parameters required for the xcmSend function ##\n    encoded_calldata = \"INSERT_ENCODED_CALLDATA\"\n    xcm_dest = [1, []]  # Parents: 1  # Interior: Here\n\n    ## Send the custom XCM message ##\n    # Craft the extrinsic\n    tx = xcm_utils.functions.xcmSend(xcm_dest, encoded_calldata).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n    # Sign transaction\n    signed_tx = web3.eth.account.sign_transaction(tx, private_key)\n    # Send tx\n    hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Transaction receipt: { receipt.transactionHash.hex() }\")\n\n\nsend_xcm()\n\n```\n</code></pre> <p>就是这样！您已成功使用 Polkadot XCM Pallet 和 XCM Utilities Precompile 将消息从 Moonbase Alpha 发送到另一个链！</p>"}, {"location": "builders/interoperability/xcm/xcm-utils/", "title": "与 XCM 实用程序预编译交互", "text": ""}, {"location": "builders/interoperability/xcm/xcm-utils/#xcmutils-precompile", "title": "简介", "text": "<p>XCM Utilities Precompile 合约为开发者提供了直接在 EVM 中的 XCM 相关实用功能。这使得与其他 XCM 相关预编译合约的交易和互动更加容易。</p> <p>与其他 预编译合约 类似，XCM Utilities Precompile 位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p><code>0x000000000000000000000000000000000000080C</code></p> <p><code>0x000000000000000000000000000000000000080C</code></p> <p><code>0x000000000000000000000000000000000000080C</code></p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/interoperability/xcm/xcm-utils/#xcmutils-solidity-interface", "title": "XCM实用程序Solidity接口", "text": "<p>XcmUtils.sol 是与预编译交互的接口。</p> <p>Note</p> <p>预编译将在未来更新，以包括其他功能。请随时在 Discord 中建议其他实用功能。</p> <p>该接口包括以下函数：</p> <ul> <li>multilocationToAddress(Multilocation memory multilocation) — 只读函数，从给定的多位置返回计算出的原始帐户</li> <li>weightMessage(bytes memory message) — 只读函数，返回XCM消息将在链上消耗的权重。message 参数必须是SCALE编码的XCM版本XCM消息</li> <li> <p>getUnitsPerSecond(Multilocation memory multilocation) — 只读函数，以<code>Multilocation</code>的形式获取给定资产的每秒单位数。多位置必须描述一个可以作为费用支付支持的资产，例如 外部XC-20，否则此函数将恢复。</p> <p>Note</p> <p>请注意，此函数仍然返回每秒单位数据，但每秒单位已被弃用，并被相对价格的计算所取代。有关详细信息，请参阅 XC 资产注册。</p> </li> <li> <p>xcmExecute(bytes memory message, uint64 maxWeight) - 仅在Moonbase Alpha上可用 - 给定要执行的SCALE编码版本消息和要消耗的最大权重，执行自定义XCM消息。由于<code>Transact</code>指令的性质，无法从智能合约调用此函数</p> </li> <li>xcmSend(Multilocation memory dest, bytes memory message) - 仅在Moonbase Alpha上可用 - 给定要将消息发送到的目标链的多位置和要发送的SCALE编码版本消息，发送自定义XCM消息</li> </ul> <p>XCM实用程序预编译中的<code>Multilocation</code>结构与XCM交易器预编译的 <code>Multilocation</code> 构建方式相同。</p>"}, {"location": "builders/interoperability/xcm/xcm-utils/#using-the-xcmutils-precompile", "title": "使用 XCM 实用程序预编译", "text": "<p>XCM 实用程序预编译允许用户从 Ethereum JSON-RPC 读取数据，而无需通过 Polkadot 库。这些函数更多是为了方便起见，而不是为了智能合约用例。</p> <p>对于 <code>multilocationToAddress</code>，一个用例是通过将其他平行链的计算来源地址列入白名单来允许源自其他平行链的交易。用户可以通过计算和存储地址来将多位置列入白名单。EVM 交易可以通过远程 EVM 调用源自其他平行链。</p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\nimport \"https://github.com/moonbeam-foundation/moonbeam/blob/master/precompiles/xcm-utils/XcmUtils.sol\";\n\ncontract MultilocationWhitelistExample {\n    XcmUtils xcmutils = XcmUtils(0x000000000000000000000000000000000000080C);\n    mapping(address =&gt; bool) public whitelistedAddresses;\n\n    modifier onlyWhitelisted(address addr) {\n        _;\n        require(whitelistedAddresses[addr], \"Address not whitelisted!\");\n        _;\n    }\n\n    function addWhitelistedMultilocation(\n        XcmUtils.Multilocation calldata externalMultilocation\n    ) external onlyWhitelisted(msg.sender) {\n        address derivedAddress = xcmutils.multilocationToAddress(\n            externalMultilocation\n        );\n        whitelistedAddresses[derivedAddress] = true;\n    }\n\n    ...\n}\n</code></pre> <p>要查看如何使用 <code>xcmExecute</code> 函数在本地执行自定义 XCM 消息的示例，请参阅创建和执行自定义 XCM 消息指南。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/instructions/", "title": "XCM指令", "text": ""}, {"location": "builders/interoperability/xcm/core-concepts/instructions/#introduction", "title": "简介", "text": "<p>XCM 消息包含一系列由跨共识虚拟机 (XCVM) 执行的操作和指令。一个操作（例如，将一个区块链的通证转移到另一个区块链）由 XCVM 在源链和目标链中部分执行的指令组成。</p> <p>例如，将 DOT 从 Polkadot 转移到 Moonbeam 的 XCM 消息将包含以下 XCM 指令（按该顺序），其中一些在 Polkadot 上执行，另一些在 Moonbeam 上执行：</p> <ol> <li>TransferReserveAsset — 在 Polkadot 中执行</li> <li>ReserveAssetDeposited — 在 Moonbeam 中执行</li> <li>ClearOrigin — 在 Moonbeam 中执行</li> <li>BuyExecution — 在 Moonbeam 中执行</li> <li>DepositAsset — 在 Moonbeam 中执行</li> </ol> <p>从头开始构建 XCM 消息的指令并非易事。因此，开发人员可以利用包装函数和 pallet 来使用 XCM 功能。Polkadot XCM 和 XCM Transactor Pallet 提供了具有预定义 XCM 指令集的功能，可以发送 XC-20 或通过 XCM 在其他链上远程执行。</p> <p>如果您有兴趣尝试不同的指令组合，您可以使用 Polkadot XCM Pallet 执行和发送自定义 XCM 消息。</p> <p>本指南概述了一些最常用的 XCM 指令，包括上面示例中的指令。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/instructions/#buy-execution", "title": "购买执行", "text": "<p><code>BuyExecution</code> 指令通常在目标链中执行。它从持有注册表（跨共识虚拟机（XCVM）中的临时位置）中获取资产，以支付执行费用。目标链确定要支付的费用。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/instructions/#clear-origin", "title": "清除来源", "text": "<p><code>ClearOrigin</code> 指令在目标链中执行。它清除 XCM 作者的来源，从而确保后续的 XCM 指令无法命令作者的权限。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/instructions/#deposit-asset", "title": "资产存入", "text": "<p><code>DepositAsset</code> 指令在目标链中执行。它从持有注册表（Cross-Consensus Virtual Machine (XCVM) 中的一个临时位置）中移除资产，并将它们发送到目标链上的目标帐户。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/instructions/#descend-origin", "title": "Descend Origin", "text": "<p><code>DescendOrigin</code> 指令在目标链中执行。它会改变目标链上的来源，以匹配源链上的来源，确保目标链上的执行代表在源链上启动 XCM 消息的同一实体。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/instructions/#initiate-reserve-withdraw", "title": "启动储备提取", "text": "<p><code>InitiateReserveWithdraw</code> 指令在源链中执行。它从控股登记处（跨共识虚拟机 (XCVM) 中的一个临时位置）移除资产（本质上是烧毁它们），然后向储备链发送一条以 <code>WithdrawAsset</code> 指令开头的 XCM 消息。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/instructions/#refund-surplus", "title": "退还剩余", "text": "<p><code>RefundSurplus</code> 指令通常在 XCM 处理完毕后在目标链中执行。此指令将从 <code>BuyExecution</code> 指令中获取任何剩余资产，并将资产放入持有寄存器中，这是跨共识虚拟机 (XCVM) 中的一个临时位置。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/instructions/#reserve-asset-deposited", "title": "储备资产已存入", "text": "<p><code>ReserveAssetDeposited</code> 指令在目标链中执行。它获取在主权账户中收到的资产的表示形式，并将它们放入持有注册表中，这是跨共识虚拟机（XCVM）中的一个临时位置。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/instructions/#set-appendix", "title": "设置附录", "text": "<p><code>SetAppendix</code> 指令在目标链中执行。它设置附录寄存器，该寄存器保存应在当前执行完成后运行的代码。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/instructions/#transfer-reserve-asset", "title": "转移储备资产", "text": "<p><code>TransferReserveAsset</code> 指令在储备链中执行。它将资产从原始帐户转移，并将其存入目标链上的目标帐户。然后，它将一条包含 <code>ReserveAssetDeposited</code> 指令的 XCM 消息发送到目标链，后跟要执行的 XCM 指令。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/instructions/#transact", "title": "Transact", "text": "<p><code>Transact</code> 指令在目标链中执行。它从给定的来源分派编码的调用数据，从而允许在目标链上执行特定的操作或函数。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/instructions/#withdraw-asset", "title": "提取资产", "text": "<p><code>WithdrawAsset</code> 指令可以在源链或目标链中执行。它会移除资产并将它们放入持有寄存器中，这是跨共识虚拟机 (XCVM) 中的一个临时位置。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/", "title": "多重定位（Multilocations）", "text": ""}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/#introduction", "title": "简介", "text": "<p>多重位置定义了相对于给定原点的整个中继链/平行链生态系统中的特定点。它可用于定位特定的平行链、资产、帐户，甚至是平行链内的 pallet。</p> <p>多重位置遵循分层结构，其中某些位置封装在其他位置内。例如，中继链封装了连接到它的所有平行链。同样，平行链封装了存在于其中的所有 pallet、帐户和资产。</p> <p></p>"}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/#defining-a-multilocation", "title": "定义多位置", "text": "<p>多位置包含两个参数：</p> <ul> <li><code>parents</code> - 指的是从给定的原点开始，你需要向上追溯到父区块链的“跳数”。从平行链在 relay chain 生态系统中的角度来看，只能有一个父链，因此 <code>parents</code> 的值只能是 <code>0</code> (表示平行链) 或 <code>1</code> (表示 relay chain)。当定义考虑到其他共识系统（如以太坊）的通用位置时，<code>parents</code> 可以具有更高的值</li> <li><code>interior</code> - 指的是定义目标点所需的字段数。从 relay chain 出发，您可以向下钻取以定位特定的平行链、帐户、资产或该平行链上的 pallet。由于此向下移动可能更复杂，因此 Junctions 用于表示到达目标位置所需的步骤，并由 <code>XN</code> 定义，其中 <code>N</code> 是所需的 Junctions 数。如果定义目标点不需要任何 Junctions，则其值将为 <code>Here</code> 而不是 <code>X1</code></li> </ul> <p>例如，如果您专门以 relay chain 为目标，您将使用 <code>Here</code>，因为您没有在 relay chain 上定义帐户、平行链或平行链中的特定点。</p> <p>另一方面，如果您以 relay chain 上的帐户、平行链或平行链中的特定点为目标，您将根据需要使用一个或多个 Junctions。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/#junctions", "title": "连接点", "text": "<p>连接点可以是以下任何一种：</p> <ul> <li> <p><code>Parachain</code> - 使用平行链的 ID 描述平行链</p> <pre><code>{ Parachain: INSERT_PARACHAIN_ID }\n</code></pre> </li> <li> <p><code>AccountId32</code> - 描述一个 32 字节的 Substrate 风格账户。接受一个可选的 <code>network</code> 参数，可以是以下之一：<code>Any</code>、<code>Named</code>、<code>Polkadot</code> 或 <code>Kusama</code></p> <pre><code>{ AccountId32: { id: INSERT_ADDRESS, network: INSERT_NETWORK } }\n</code></pre> </li> <li> <p><code>AccountIndex64</code> - 描述一个 64 位（8 字节）的账户索引。接受一个可选的 <code>network</code> 参数，可以是以下之一：<code>Any</code>、<code>Named</code>、<code>Polkadot</code> 或 <code>Kusama</code></p> <pre><code>{ AccountIndex64: { index: INSERT_ACCOUNT_INDEX, network: INSERT_NETWORK } }\n</code></pre> </li> <li> <p><code>AccountKey20</code> - 描述一个 20 字节的 Ethereum 风格账户，就像在 Moonbeam 中使用的一样。接受一个可选的 <code>network</code> 参数，可以是以下之一：<code>Any</code>、<code>Named</code>、<code>Polkadot</code> 或 <code>Kusama</code></p> <pre><code>{ AccountKey20: { key: INSERT_ADDRESS, network: INSERT_NETWORK } }\n</code></pre> </li> <li> <p><code>PalletInstance</code> - 描述目标链上的 pallet 的索引</p> <pre><code>{ PalletInstance: INSERT_PALLET_INSTANCE_INDEX }\n</code></pre> </li> <li> <p><code>GeneralIndex</code> - 描述一个非描述性的索引，可用于定位以键值格式存储的数据</p> <pre><code>{ GeneralIndex: INSERT_GENERAL_INDEX }\n</code></pre> </li> <li> <p><code>GeneralKey</code> - 描述一个非描述性的键，可用于定位更复杂的数据结构。这需要您指定数据的 <code>data</code> 和 <code>length</code></p> <pre><code>{ GeneralKey: { length: INSERT_LENGTH_OF_DATA, data: [INSERT_DATA] } }\n</code></pre> </li> <li> <p><code>OnlyChild</code> - 描述位置的子项（如果父项和子项之间只有一对一的关系）。当前，除了在派生上下文时作为后备之外，不使用此项</p> </li> <li> <p><code>Plurality</code> - 描述满足特定条件或共享共同特征的多个元素。这要求您指定 Junction 表示的 Body ID 和 Body Part</p> <pre><code>{ Plurality: { id: INSERT_BODY_ID, part: INSERT_BODY_PART } }\n</code></pre> </li> </ul> <p>使用连接点时，您将使用 <code>XN</code>，其中 <code>N</code> 是到达目标位置所需的连接点数。例如，如果您要从平行链定位 Moonbeam 上的帐户，则需要将 <code>parents</code> 设置为 <code>1</code>，并且需要定义两个连接点，即 <code>Parachain</code> 和 <code>AccountKey20</code>，因此您将使用 <code>X2</code>，它是一个将包含每个连接点的数组：</p> <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2004 },\n      { AccountKey20: { key: 'INSERT_MOONBEAM_ADDRESS' } },\n    ],\n  },\n};\n</code></pre>"}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/#example-multilocations", "title": "Multilocations 示例", "text": ""}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/#target-moonbeam-from-parachain", "title": "从另一个平行链定位 Moonbeam", "text": "<p>要从另一个平行链定位基于 Moonbeam 的链，您需要使用以下多重定位：</p> <p>===</p> <pre><code>js\n{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 2004 }],\n  },\n};\n</code></pre> <p>===</p> <pre><code>js\n{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 2023 }],\n  },\n};\n</code></pre> <p>===</p> <pre><code>js\n{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 1000 }],\n  },\n};\n</code></pre>"}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/#target_account_moonbeam_from_parachain", "title": "从另一个平行链定位 Moonbeam 上的帐户", "text": "<p>要从另一个平行链定位 Moonbeam 链上的特定帐户，您可以使用以下多重定位：</p> MoonbeamMoonriverMoonbase Alpha <p>js {   parents: 1,   interior: {     X2: [       { Parachain: 2004 },       { AccountKey20: { key: 'INSERT_MOONBEAM_ADDRESS' } },     ],   }, };</p> <p>js {   parents: 1,   interior: {     X2: [       { Parachain: 2023 },       { AccountKey20: { key: 'INSERT_MOONBEAM_ADDRESS' } },     ],   }, };</p> <p>js {   parents: 1,   interior: {     X2: [       { Parachain: 1000 },       { AccountKey20: { key: 'INSERT_MOONBEAM_ADDRESS' } },     ],   }, };</p>"}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/#target-moonbeam-native-asset-from-parachain", "title": "从另一个平行链定位 Moonbeam 的原生资产", "text": "<p>要从另一个平行链定位 Moonbeam 的原生资产，您可以使用以下多重地址：</p> <p>===</p> <pre><code>js\n{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2004 },\n      { PalletInstance: 10 }, // Moonbeam 上 Balances Pallet 的索引\n    ],\n  },\n};\n</code></pre> <p>===</p> <pre><code>js\n{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2023 },\n      { PalletInstance: 10 }, // Moonriver 上 Balances Pallet 的索引\n    ],\n  },\n};\n</code></pre> <p>===</p> <pre><code>js\n{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 1000 },\n      { PalletInstance: 3 }, // Moonbase Alpha 上 Balances Pallet 的索引\n    ],\n  },\n};\n</code></pre>"}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/#target-moonbeam-from-relay", "title": "从中继链定位 Moonbeam", "text": "<p>要从中继链定位基于 Moonbeam 的链，您可以使用以下多重定位：</p> <p>===</p> <pre><code>js\n{\n  parents: 0,\n  interior: {\n    X1: [{ Parachain: 2004 }],\n  },\n};\n</code></pre> <p>===</p> <pre><code>js\n{\n  parents: 0,\n  interior: {\n    X1: [{ Parachain: 2023 }],\n  },\n};\n</code></pre> <p>===</p> <pre><code>js\n{\n  parents: 0,\n  interior: {\n    X1: [{ Parachain: 1000 }],\n  },\n};\n</code></pre>"}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/#target-relay-from-moonbeam", "title": "从 Moonbeam 定位中继链", "text": "<p>要从基于 Moonbeam 的链定位中继链，您可以使用以下多重定位：</p> <p>===</p> <pre><code>js\n{\n  parents: 1,\n  interior: Here,\n};\n</code></pre> <p>===</p> <pre><code>js\n{\n  parents: 1,\n  interior: Here,\n};\n</code></pre> <p>===</p> <pre><code>js\n{\n  parents: 1,\n  interior: Here,\n};\n</code></pre>"}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/#target-account-relay-from-moonbeam", "title": "从 Moonbeam 定位中继链上的帐户", "text": "<p>要定位中继链上的特定帐户，您将使用以下多重定位：</p> <p>===</p> <pre><code>js\n{\n  parents: 1,\n  interior: { X1: { AccountId32: { id: INSERT_RELAY_ADDRESS } } },\n};\n</code></pre> <p>===</p> <pre><code>js\n{\n  parents: 1,\n  interior: { X1: { AccountId32: { id: INSERT_RELAY_ADDRESS } } },\n};\n</code></pre> <p>===</p> <pre><code>js\n{\n  parents: 1,\n  interior: { X1: { AccountId32: { id: INSERT_RELAY_ADDRESS } } },\n};\n</code></pre>"}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/#target-parachain-from-moonbeam", "title": "从 Moonbeam 定位另一个平行链", "text": "<p>要从 Moonbeam 定位另一个平行链（例如，ID 为 1234 的平行链），您可以使用以下多重地址：</p> <p>===</p> <p>js {   parents: 1,   interior: {     X1: [{ Parachain: 1234 }],   }, };</p> <p>===</p> <p>js {   parents: 1,   interior: {     X1: [{ Parachain: 1234 }],   }, };</p> <p>===</p> <p>js {   parents: 1,   interior: {     X1: [{ Parachain: 1234 }],   }, };</p>"}, {"location": "builders/interoperability/xcm/core-concepts/multilocations/#location-to-account-api", "title": "Location to Account API", "text": "<p>Location to Account API 是一种将多重位置转换为 <code>AccountID20</code> 地址的简便方法。可以通过 Polkadot.js Apps 开发者部分的运行时调用选项卡访问 Location to Account API。Location to Account API 的 <code>convertLocation</code> 方法将多重位置作为参数，并返回 <code>AccountID20</code> 地址。</p> <p>javascript // 使用 convertLocation 方法查询 locationToAccountApi const result =   await api.call.locationToAccountApi.convertLocation(multilocation); console.log('转换结果：', result.toHuman());</p> <p>您可以在下方查看完整的脚本。</p> 查看完整脚本 <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const main = async () =&gt; {   // Construct API provider   const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');   const api = await ApiPromise.create({ provider: wsProvider });</p> <p>// Define the multilocation parameter   const multilocation = {     V4: {       parents: 1,       interior: 'Here',     },   };</p> <p>// Query the locationToAccountApi using convertLocation method   const result =     await api.call.locationToAccountApi.convertLocation(multilocation);   console.log('Conversion result:', result.toHuman());</p> <p>// Disconnect the API   await api.disconnect(); };</p> <p>main().catch(console.error);</p> <p>该方法将返回与提供的多重位置对应的 <code>AccountID20</code> 地址，如下所示：</p> <p>bash Conversion result: { Ok: '0x506172656E740000000000000000000000000000' }</p>"}, {"location": "builders/interoperability/xcm/core-concepts/sovereign-accounts/", "title": "主权账户概述", "text": ""}, {"location": "builders/interoperability/xcm/core-concepts/sovereign-accounts/#introduction", "title": "简介", "text": "<p>在基于 Polkadot 的生态系统中，主权账户是一种独特的、无密钥的账户，它通过 XCM 而不是个人或组织由区块链的运行时控制。这些账户用于在跨链转移代币时存储资产。例如，如果您将储备代币从平行链转移到 Moonbeam，则始发平行链会将这些代币锁定在源链上的 Moonbeam 主权账户中，同时在 Moonbeam 上生成这些代币的包装表示。</p> <p>主权账户在储备支持的转移中起着核心作用，其中一条链（“储备”）持有真实的资产，而其他链持有衍生代币。当代币跨链移动时，储备（或来源）链会锁定或解锁底层资产，并且衍生代币会在目标链上生成或销毁。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/sovereign-accounts/#calculating-sovereign", "title": "计算平行链主权账户", "text": "<p>您可以使用 xcm-tools 存储库计算给定中继链上平行链的主权账户。当您需要验证底层代币的锁定位置或直接为平行链的主权账户提供资金时，这尤其有用。</p> <ol> <li>克隆或导航到 xcm-tools 存储库</li> <li>使用 <code>calculate-sovereign-account</code> 脚本，使用 <code>--p</code> 标志指定 Parachain ID，并使用 <code>--r</code> 标志指定中继链（默认为 <code>polkadot</code>；其他接受的值为 <code>kusama</code> 或 <code>moonbase</code>）</li> </ol> <p>您需要的平行链 ID 可以在相应中继链的 Polkadot.js Apps Parachains 页面 上找到。 Parachains 页面可以在 Network 下拉菜单中访问。</p> <p>例如，要计算 Moonbase Alpha 测试网上平行链 <code>1000</code> 的主权账户地址：</p> <pre><code>yarn calculate-sovereign-account --p 1000 --r moonbase\n</code></pre> <p>运行该脚本将生成如下输出：</p> yarn calculate-sovereign-account --p 1000 --r moonbase yarn run v1.22.22 $ ts-node 'scripts/calculate-sovereign-account.ts' --p 1000 --r moonbase Sovereign Account Address on Relay: 0x70617261e8030000000000000000000000000000000000000000000000000000 Sovereign Account Address on other Parachains (Generic): 0x7369626ce8030000000000000000000000000000000000000000000000000000 Sovereign Account Address on Moonbase Alpha: 0x7369626ce8030000000000000000000000000000 <p>中继地址是 Polkadot 或 Kusama 中继链引用主权账户的方式。通用平行链地址通常用于从其他平行链引用此平行链的主权账户。 Moonbase Alpha 地址是 Moonbase Alpha 使用的 H160 EVM 地址格式中相应的主权账户。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/sovereign-accounts/#learn-more", "title": "了解更多", "text": "<p>主权账户构成了储备支持转移的支柱，从而能够安全托管资产，以便在 Polkadot 的生态系统中铸造包装代币。通过将主权账户与 XCM 框架相结合，平行链可以无缝地互操作——以透明、信任最小化的方式锁定和解锁资产。有关主权账户如何促进与 XCM 的跨链传输的更多信息，请务必查看发送 XC-20 部分。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/", "title": "Moonbeam上的XCM费用", "text": ""}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#introduction", "title": "简介", "text": "<p>XCM 旨在成为一种在共识系统之间交流思想的语言。发送 XCM 消息包含一系列指令，这些指令在发起链和目标链中执行。XCM 指令的组合会导致诸如代币转移之类的操作。为了处理和执行每个 XCM 指令，通常需要支付相关的费用。</p> <p>但是，XCM 的设计具有通用性、可扩展性和高效性，因此在不断增长的生态系统中，它始终具有价值和面向未来的特性。因此，通用性适用于包括 XCM 执行费用支付在内的概念。在 Ethereum 中，费用已纳入交易协议，而在 Polkadot 生态系统中，每个链都可以灵活地定义如何处理 XCM 费用。</p> <p>本指南将介绍费用支付的各个方面，例如谁负责支付 XCM 执行费用、如何支付费用以及如何在 Moonbeam 上计算费用。</p> <p>Note</p> <p>以下信息仅供一般参考。 自撰写本文以来，权重和外部基本成本可能已更改。请确保您检查实际值，并且切勿将以下信息用于生产应用程序。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#payment-of-fees", "title": "费用支付", "text": "<p>一般来说，费用支付过程可以描述如下：</p> <ol> <li>需要提供一些资产</li> <li>必须协商资产交换计算时间（或权重）</li> <li>XCM 操作将按照指示执行，并具有所提供的权重限制或可用于执行的资金</li> </ol> <p>每个链都可以配置 XCM 费用的处理方式以及可以使用哪些代币支付（原生储备代币或外部代币）。例如：</p> <ul> <li>Polkadot 和 Kusama - 费用分别以 DOT 或 KSM 支付，并交给区块的验证者</li> <li>Moonbeam 和 Moonriver - XCM 执行费用可以用储备资产（分别为 GLMR 或 MOVR）支付，也可以用在其他链中产生的资产支付（如果这些资产注册为 XCM 执行资产）。当 XCM 执行（代币转移或远程执行）以原生链储备资产（GLMR 或 MOVR）支付时，100% 将被销毁。当 XCM 执行以国外资产支付时，费用将发送到 Treasury</li> </ul> <p>考虑以下情景：Alice 在 Polkadot 上有一些 DOT，她想将其转移到 Moonbeam 上的 Alith。她发送了一条 XCM 消息，其中包含一组 XCM 指令，这些指令将从她在 Polkadot 上的帐户中检索给定数量的 DOT，并将它们作为 xcDOT 铸造到 Alith 的帐户中。部分指令在 Polkadot 上执行，另一部分在 Moonbeam 上执行。</p> <p>Alice 如何支付 Moonbeam 来执行这些指令并满足她的请求？她的请求通过一系列包含在 XCM 消息中的 XCM 指令来满足，这使她可以购买执行时间，减去任何相关的 XCM 执行费用。执行时间用于发行和转移 xcDOT，这是 DOT 在 Moonbeam 上的表示。这意味着当 Alice 将一些 DOT 发送到 Alith 在 Moonbeam 上的帐户时，她将收到她的 DOT 的 1:1 表示，即 xcDOT 减去任何 XCM 执行费用。请注意，在这种情况下，XCM 执行费用以 xcDOT 支付并发送到 Treasury。</p> <p>Alice 转移的确切过程如下：</p> <ol> <li>资产被发送到 Polkadot 上由 Moonbeam 拥有的帐户，称为 Sovereign 帐户。收到资产后，将向 Moonbeam 发送一条 XCM 消息</li> <li>Moonbeam 中的 XCM 消息将：<ol> <li>铸造相应的资产表示</li> <li>购买相应的执行时间</li> <li>使用该执行时间将表示（减去费用）存入目标帐户</li> </ol> </li> </ol>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#xcm-instructions", "title": "XCM 指令", "text": "<p>XCM 消息由一系列 XCM 指令组成。因此，不同的 XCM 指令组合会导致不同的操作。例如，要将 DOT 移动到 Moonbeam，可以使用以下 XCM 指令：</p> <p>When DOT is transferred from Polkadot to Moonbeam, the following XCM instructions are executed in sequence:</p> <ol> <li> <p><code>TransferReserveAsset</code> - executes on Polkadot, moving the DOT from the sender and depositing it into Moonbeam’s Sovereign account on Polkadot</p> </li> <li> <p><code>ReserveAssetDeposited</code> - executes on Moonbeam, minting the corresponding ERC-20 representation of DOT (xcDOT) on Moonbeam</p> </li> <li> <p><code>ClearOrigin</code> - executes on Moonbeam, clearing any origin data—previously set to Polkadot’s Sovereign account</p> </li> <li> <p><code>BuyExecution</code> - executes on Moonbeam, determining the execution fees. Here, a portion of the newly minted xcDOT is used to pay the cost of XCM</p> </li> <li> <p><code>DepositAsset</code> - executes on Moonbeam, delivering the xcDOT to the intended recipient’s account on Moonbeam</p> </li> </ol> <p>要检查如何构建 XCM 消息的指令以将自留资产转移到目标链（例如将 DOT 转移到 Moonbeam），您可以参考 X-Tokens 开放运行时模块库 存储库（例如）。您将需要查看 <code>transfer_self_reserve_asset</code> 函数。您会注意到它调用 <code>TransferReserveAsset</code> 并传入 <code>assets</code>、<code>dest</code> 和 <code>xcm</code> 作为参数。特别是，<code>xcm</code> 参数包括 <code>BuyExecution</code> 和 <code>DepositAsset</code> 指令。然后，如果您前往 Polkadot GitHub 存储库，您可以找到 <code>TransferReserveAsset</code> 指令。XCM 消息是通过将 <code>ReserveAssetDeposited</code> 和 <code>ClearOrigin</code> 指令与 <code>xcm</code> 参数组合而构建的，如前所述，<code>xcm</code> 参数包括 <code>BuyExecution</code> 和 <code>DepositAsset</code> 指令。</p> <p>In scenarios where you want to move an asset back to its reserve chain, such as sending xcDOT from Moonbeam to Polkadot, Moonbeam uses the following set of XCM instructions:</p> <ol> <li> <p><code>WithdrawAsset</code> – executes on Moonbeam, taking the specified token (xcDOT) from the sender</p> </li> <li> <p><code>InitiateReserveWithdraw</code> – executes on Moonbeam, which, burns the token on Moonbeam (removing the wrapped representation), and sends an XCM message to Polkadot, indicating the tokens should be released there </p> </li> <li> <p><code>WithdrawAsset</code> – executes on Polkadot, removing the tokens from Moonbeam’s Sovereign account on Polkadot</p> </li> <li> <p><code>ClearOrigin</code> – gets executed on Polkadot. Clears any origin data (e.g., the Sovereign account on Moonbeam)</p> </li> <li> <p><code>BuyExecution</code> – Polkadot determines the execution fees and uses part of the DOT being transferred to pay for them</p> </li> <li> <p><code>DepositAsset</code> – finally, the native DOT tokens are deposited into the specified Polkadot account</p> </li> </ol> <p>要检查如何构建 XCM 消息的指令以将储备资产转移到目标链（例如将 xcDOT 转移到 Polkadot），您可以参考 X-Tokens 开放运行时模块库 存储库。您将需要查看 <code>transfer_to_reserve</code> 函数。您会注意到它调用 <code>WithdrawAsset</code>，然后调用 <code>InitiateReserveWithdraw</code> 并传入 <code>assets</code>、<code>dest</code> 和 <code>xcm</code> 作为参数。特别是，<code>xcm</code> 参数包括 <code>BuyExecution</code> 和 <code>DepositAsset</code> 指令。然后，如果您前往 Polkadot GitHub 存储库，您可以找到 <code>InitiateReserveWithdraw</code> 指令。XCM 消息是通过将 <code>WithdrawAsset</code> 和 <code>ClearOrigin</code> 指令与 <code>xcm</code> 参数组合而构建的，如前所述，<code>xcm</code> 参数包括 <code>BuyExecution</code> 和 <code>DepositAsset</code> 指令。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#rel-chain-xcm-fee-calc", "title": "中继链 XCM 费用计算", "text": "<p>Substrate 引入了一种权重系统，用于确定外部因素的计算成本有多高或换句话说有多昂贵。一个权重单位被定义为一个皮秒的执行时间。在支付费用时，用户将根据所发出调用的权重支付交易费用，以及网络拥塞等因素。</p> <p>以下部分将详细介绍如何计算 Polkadot 和 Kusama 的 XCM 费用。重要的是要注意，特别是 Kusama，使用基准数据来确定 XCM 指令的总权重成本，并且某些 XCM 指令可能包括数据库读取和写入，这会增加调用的权重。</p> <p>Polkadot 和 Kusama 中有两个可用的数据库：RocksDB（默认）和 ParityDB，两者都有各自与每个网络相关的权重成本。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#polkadot", "title": "Polkadot", "text": "<p>Polkadot上的总权重成本除了给定指令所需的权重外，还考虑了数据库的读取和写入。Polkadot对指令以及数据库的读取和写入操作使用基准权重。数据库操作的权重成本细分可以在RocksDB（默认）和ParityDB的相应存储库文件中找到。</p> <p>现在您已经了解了Polkadot上数据库读取和写入的权重成本，您可以使用指令的基本权重来计算给定指令的权重成本。</p> <p>在Polkadot上，基准基础权重分为两类：可替代的和通用的。可替代权重用于涉及转移资产的XCM指令，通用权重用于其他所有指令。您可以直接在Polkadot Runtime代码中查看可替代资产和通用资产的当前权重。</p> <p>确定指令权重成本后，您可以计算每个指令的DOT成本。</p> <p>在Polkadot中，<code>ExtrinsicBaseWeight</code>设置为<code>126,045,000</code>，它映射到美分的1/10。其中1美分是<code>10^10 / 100</code>。</p> <p>因此，要计算执行XCM指令的成本，可以使用以下公式：</p> <pre><code>XCM-DOT-Cost = XCMInstrWeight * DOTWeightToFeeCoefficient\n</code></pre> <p>其中<code>DOTWeightToFeeCoefficient</code>是一个常数（映射到1美分），可以计算为：</p> <pre><code>DOTWeightToFeeCoefficient = 10^10 / ( 10 * 100 * DOTExtrinsicBaseWeight )\n</code></pre> <p>现在，您可以开始计算以DOT为单位的最终费用，使用<code>DOTWeightToFeeCoefficient</code>作为常数，<code>TotalWeight</code>作为变量：</p> <pre><code>XCM-Planck-DOT-Cost = TotalWeight * DOTWeightToFeeCoefficient\nXCM-DOT-Cost = XCM-Planck-DOT-Cost / DOTDecimalConversion\n</code></pre>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#kusama", "title": "Kusama", "text": "<p>Kusama上的总权重成本除了给定指令所需的权重外，还会考虑数据库的读取和写入。数据库操作的权重成本细分可以在RocksDB（默认）和ParityDB的相应存储库文件中找到。</p> <p>在Kusama上，基准基本权重分为两类：可替代的和通用的。可替代权重用于涉及移动资产的XCM指令，通用权重用于其他所有指令。您可以在Kusama Runtime代码中直接查看可替代资产和通用资产的当前权重。</p> <p>在确定指令权重成本后，您可以使用<code>ExtrinsicBaseWeight</code>和权重费用映射来计算KSM中指令的成本。</p> <p>要计算执行XCM指令的成本，可以使用以下公式：</p> <pre><code>XCM-KSM-Cost = XCMInstrWeight * KSMWeightToFeeCoefficient\n</code></pre> <p>其中<code>KSMWeightToFeeCoefficient</code>是一个常数（映射到1美分），可以计算为：</p> <pre><code>KSMWeightToFeeCoefficient = 10^12 / ( 10 * 3000 * KSMExtrinsicBaseWeight )\n</code></pre> <p>现在，您可以开始计算KSM中的最终费用，使用<code>KSMWeightToFeeCoefficient</code>作为常量，<code>TotalWeight</code>作为变量：</p> <pre><code>XCM-Planck-KSM-Cost = TotalWeight * KSMWeightToFeeCoefficient\nXCM-KSM-Cost = XCM-Planck-KSM-Cost / KSMDecimalConversion\n</code></pre>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#moonbeam-xcm-fee-calc", "title": "基于 Moonbeam 的网络 XCM 费用计算", "text": "<p>Substrate 引入了一个权重系统，用于确定一个 extrinsic 从计算成本角度来看有多重或换句话说有多昂贵。一个单位的权重被定义为一皮秒的执行时间。在支付费用时，用户将根据所调用函数的权重支付交易费，并且每个平行链可以决定如何将权重转换为费用。例如，这可以解释与交易大小和存储相关的额外成本。</p> <p>对于所有基于 Moonbeam 的网络，通用 XCM 指令都经过基准测试，而同质化 XCM 指令仍然对每个指令使用固定的权重。因此，经过基准测试的 XCM 指令的总权重成本除了给定指令所需的权重外，还考虑了数据库的读取和写入次数。Polkadot SDK 细分了相关的 RocksDB 数据库权重。</p> <p>现在，您可以使用指令的基本权重以及额外的数据库读取和写入（如果适用）来计算同质化和通用 XCM 指令的权重成本。</p> <p>例如，<code>WithdrawAsset</code> 指令是同质化 XCM 指令的一部分。因此，它没有经过基准测试，并且 <code>WithdrawAsset</code> 指令 的总权重成本为 <code>200,000,000</code>，但传输本地 XC-20 时除外。本地 XC-20 的 <code>WithdrawAsset</code> 指令的总权重成本基于将 Ethereum gas 转换为 Substrate 权重。</p> <p><code>BuyExecution</code> 指令是通用的，因此具有预定义的基准权重。您可以在 Moonbeam 运行时源代码 中查看其当前基本权重。除了基本权重外，该指令还执行四次数据库读取，这些读取被添加到计算总权重中。</p> <p>您可以在下表中找到所有 XCM 指令的所有权重值，这些值适用于所有基于 Moonbeam 的网络：</p> 基准测试指令 非基准测试指令 通用 XCM 指令 同质化 XCM 指令 <p>以下部分将分解如何计算基于 Moonbeam 的网络的 XCM 费用。主要有两种情况：</p> <ul> <li>以储备代币（如 GLMR、MOVR 或 DEV 等原生代币）支付的费用</li> <li>以外部资产 (XC-20) 支付的费用</li> </ul>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#moonbeam-reserve-assets", "title": "储备资产的费用计算", "text": "<p>对于每个 XCM 指令，权重单位会转换为余额单位，作为费用计算的一部分。每个基于 Moonbeam 的网络的每个权重单位的 Wei 数量如下：</p> Moonbeam Moonriver Moonbase Alpha 1,250,000 12,500 12,500 <p>这意味着，例如在 Moonbeam 上，计算储备资产中一个 XCM 指令成本的公式如下：</p> <pre><code>XCM-Wei-Cost = XCMInstrWeight * WeiPerWeight\nXCM-GLMR-Cost = XCM-Wei-Cost / 10^18\n</code></pre> <p>因此，例如，可替代指令的实际计算如下：</p> <pre><code>XCM-Wei-Cost = 200000000 * 1250000\nXCM-GLMR-Cost = 250000000000000 / 10^18\n</code></pre> <p>对于 Moonbeam 上的 XCM 指令，总成本为 <code>0.00025 GLMR</code>。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#fee-calc-external-assets", "title": "外部资产的费用计算", "text": "<p>Moonbeam根据调用的权重对外部资产收取费用。权重是一个包含两个字段的结构体，<code>refTime</code> 和 <code>proofSize</code>。<code>refTime</code> 指的是可用于执行的计算时间量。<code>proofSize</code> 指的是提交到Polkadot中继链进行验证的Moonbeam块的PoV（有效性证明）的大小。由于 <code>refTime</code> 和 <code>proofSize</code> 都是确定权重的组成部分，因此仅凭其中一个值无法获得准确的权重值。</p> <p>您可以使用 <code>xcmPaymentApi</code> 的 <code>queryXcmWeight</code> 方法查询XCM指令的 <code>refTime</code> 和 <code>proofSize</code>。您可以通过编程方式或访问 Polkadot.js Apps的运行时调用选项卡 来执行此操作。<code>queryXcmWeight</code> 方法采用XCM版本，并且指令具有parameter参数，并返回相应的 <code>refTime</code> 和 <code>proofSize</code> 值。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#weight-to-gas-mapping", "title": "权重到 Gas 的映射", "text": "<p>对于源自 EVM 操作的调用，例如依赖 EVM 操作 <code>MintInto</code> 的 <code>DepositAsset</code> 指令，您可以通过将 gas 限制乘以权重乘数来计算它们各自的权重值。对于 <code>refTime</code>，您需要将 gas 限制乘以 <code>25000</code>，对于 <code>proofSize</code>，您需要将 gas 限制乘以 <code>8</code>。为方便起见，下面提供了一个图表。</p> 权重类型 乘数值 引用时间 25,000 证明大小 8 <p>要确定 Alice 将 DOT 转移到 Moonbeam 的总权重，您需要转移所需的四个 XCM 指令中的每一个的权重。请注意，虽然前三个指令具有与这些指令相对应的特定 <code>refTime</code> 和 <code>proofSize</code> 值，可以通过 <code>xcmPaymentApi</code> 的 <code>queryXcmWeight</code> 方法 检索，但 <code>DepositAsset</code> 依赖于 EVM 操作 <code>MintInto</code> 和每个 gas 的 <code>WeightPerGas</code> 转换 <code>25,000</code>。因此，<code>DepositAsset</code> 的 <code>refTime</code> 可以计算为：</p> <pre><code>155000 gas * 25000 weight per gas = 3875000000\n</code></pre> <p><code>DepositAsset</code> 的 <code>proofSize</code> 可以计算为：</p> <pre><code>155000 gas * 8 weight per gas = 1240000\n</code></pre>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#weight-to-asset-fee-conversion", "title": "权重到资产费用转换", "text": "<p>一旦您获得了 <code>refTime</code> 和 <code>proofSize</code> 值的总和，您就可以轻松检索所需的相应费用金额。<code>xcmPaymentApi</code> 的 <code>queryWeightToAssetFee</code> 方法 采用 <code>refTime</code>、<code>proofSize</code> 和资产多重位置作为参数，并返回相应的费用。通过提供上面获得的 <code>4,428,242,000</code> <code>refTime</code> 和 <code>1,259,056</code> <code>proofSize</code> 以及 DOT 的资产多重位置，我们得到 <code>88,920,522</code> Plank 的费用金额，这是 Polkadot 中最小的单位。我们可以将其除以 <code>10^10</code> 转换为 DOT，从而得到 <code>0.008892</code> DOT 的 DOT 费用金额。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#xcm-payment-api-exanded-examples", "title": "XCM 支付 API 扩展示例", "text": "<p>XCM 支付 API 方法提供了各种有用的方法来计算费用、评估可接受的费用支付货币等等。请记住，除了通过 API 访问之外，您还可以通过 Polkadot.js 应用程序的运行时调用选项卡 与 XCM 支付 API 进行交互。</p>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#query-acceptable-fee-payment-assets", "title": "查询可接受的手续费支付资产", "text": "<p>此函数将XCM版本作为参数，并以多重定位形式返回可接受的手续费资产列表。</p> <pre><code>const allowedAssets =\n  await api.call.xcmPaymentApi.queryAcceptablePaymentAssets(3);\nconsole.log(allowedAssets);\n</code></pre> 查看完整脚本 <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const main = async () =&gt; {   // Construct API provider   const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');   const api = await ApiPromise.create({ provider: wsProvider });</p> <p>const allowedAssets =     await api.call.xcmPaymentApi.queryAcceptablePaymentAssets(4);   console.log(allowedAssets);</p> <p>// Disconnect the API   await api.disconnect(); };</p> <p>main();</p>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#weight-to-asset-fee-conversion", "title": "权重到资产费用转换", "text": "<p>此方法将权重转换为指定资产的费用。它接受权重和资产多重定位作为参数，并返回相应的费用金额。</p> <pre><code>const fee = await api.call.xcmPaymentApi.queryWeightToAssetFee(\n  {\n    refTime: 10_000_000_000n,\n    proofSize: 0n,\n  },\n  {\n    V3: {\n      Concrete: { parents: 1, interior: 'Here' },\n    },\n  }\n);\n\nconsole.log(fee);\n</code></pre> 查看完整脚本 <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const main = async () =&gt; {   // Construct API provider   const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');   const api = await ApiPromise.create({ provider: wsProvider });</p> <p>const fee = await api.call.xcmPaymentApi.queryWeightToAssetFee(     {       refTime: 10_000_000_000n,       proofSize: 0n,     },     {       V3: {         Concrete: { parents: 1, interior: 'Here' },       },     }   );</p> <p>console.log(fee);</p> <p>// Disconnect the API   await api.disconnect(); };</p> <p>main();</p>"}, {"location": "builders/interoperability/xcm/core-concepts/weights-fees/#query-xcm-weight", "title": "查询 XCM 权重", "text": "<p>此方法将 XCM 消息作为参数，并返回消息的权重。</p> <pre><code>const message = { V3: [instr1, instr2] };\n\nconst theWeight = await api.call.xcmPaymentApi.queryXcmWeight(message);\nconsole.log(theWeight);\n</code></pre> 查看完整脚本 <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const main = async () =&gt; {   // Construct API provider   const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');   const api = await ApiPromise.create({ provider: wsProvider });</p> <p>const amountToSend = BigInt(1 * 10 ** 12); // Sending 1 token (assuming 12 decimal places)   const assetMultiLocation = {     parents: 0,     interior: { X1: { PalletInstance: 3 } },   }; // The asset's location (adjust PalletInstance as needed)   const recipientAccount = '0x1234567890abcdef1234567890abcdef12345678'; // The recipient's account on the destination chain</p> <p>// 2. XCM Destination (e.g., Parachain ID 2000)   const dest = { V3: { parents: 1, interior: { X1: { Parachain: 2000 } } } };</p> <p>// 3. XCM Instruction 1: Withdraw the asset from the sender   const instr1 = {     WithdrawAsset: [       {         id: { Concrete: assetMultiLocation },         fun: { Fungible: amountToSend },       },     ],   };</p> <p>// 4. XCM Instruction 2: Deposit the asset into the recipient's account on the destination chain   const instr2 = {     DepositAsset: {       assets: { Wild: 'All' }, // Sending all withdrawn assets (in this case, 1 token)       beneficiary: {         parents: 0,         interior: { X1: { AccountKey20: { key: recipientAccount } } },       },     },   };</p> <p>// 5. Build the XCM Message   const message = { V3: [instr1, instr2] };</p> <p>const theWeight = await api.call.xcmPaymentApi.queryXcmWeight(message);   console.log(theWeight);</p> <p>// Disconnect the API   await api.disconnect(); };</p> <p>main();</p>"}, {"location": "builders/interoperability/xcm/remote-execution/computed-origins/", "title": "计算的原始账户", "text": ""}, {"location": "builders/interoperability/xcm/remote-execution/computed-origins/#introduction", "title": "简介", "text": "<p>计算来源，之前被称为多位置衍生帐户，是执行通过 XCM 的远程调用时计算出的帐户。</p> <p>计算来源是无密钥的（私钥未知）。因此，只能通过来自原始帐户的 XCM extrinsic 访问计算来源。换句话说，原始帐户是唯一可以启动在您的计算来源帐户上交易的帐户，如果您失去对原始帐户的访问权限，您也将失去对您的计算来源帐户的访问权限。</p> <p>计算来源是从用于在目标链中执行 XCM 的来源计算得出的。默认情况下，这是源链在目标链中的主权帐户。此来源可以通过 <code>DescendOrigin</code> XCM 指令进行更改。但是，目标链可以决定是否使用新更改的来源来执行 XCM。在 Moonbeam 上，计算来源帐户用于执行 XCM。</p> <p>基于 Moonbeam 的网络遵循 Polkadot 设置的计算来源标准，也就是说，通过一个 <code>blake2</code> 哈希，该哈希取决于 XCM 消息的来源的数据结构。但是，由于 Moonbeam 使用以太坊样式的帐户，因此计算来源被截断为 20 个字节。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/computed-origins/#origin-conversion", "title": "原始转换", "text": "<p>当执行 <code>Transact</code> 指令时，会发生远程调用的原始转换。目标链上的新原始地址是为目标链上 XCM 执行付费的地址。</p> <p>例如，从 relay 链，<code>DescendOrigin</code> 指令由 XCM Pallet 本地注入。对于 Moonbase Alpha 的 relay 链（基于 Westend）而言，它具有以下格式（多位置连接）：</p> <pre><code>{\n  DescendOrigin: {\n    X1: {\n      AccountId32: {\n        network: { westend: null },\n        id: decodedAddress,\n      },\n    },\n  },\n}\n</code></pre> <p>其中 <code>decodedAddress</code> 对应于在 relay 链上签署交易的帐户的地址（以解码的 32 字节格式）。您可以使用以下代码段来确保您的地址已正确解码，如果需要，它将解码地址，如果不需要，则忽略它：</p> <pre><code>import { decodeAddress } from '@polkadot/util-crypto';\nconst decodedAddress = decodeAddress('INSERT_ADDRESS');\n</code></pre> <p>当 XCM 指令在 Moonbeam（本例中为 Moonbase Alpha）中执行时，原始地址将变异为以下多位置：</p> <pre><code>{\n  DescendOrigin: {\n    parents: 1,\n    interior: {\n      X1: {\n        AccountId32: {\n          network: { westend: null },\n          id: decodedAddress,\n        },\n      },\n    },\n  },\n}\n</code></pre>"}, {"location": "builders/interoperability/xcm/remote-execution/computed-origins/#calculate-computed-origin", "title": "如何计算导出的原始地址", "text": "<p>您可以通过 xcm-tools 存储库中的 <code>calculate-multilocation-derivative-account</code> 或 <code>calculate-remote-origin</code> 脚本轻松计算导出的原始地址帐户。</p> <p>该脚本接受以下输入：</p> <ul> <li><code>--ws-provider</code> 或 <code>-w</code> - 对应于用于获取导出的原始地址的端点。这应该是目标链的端点</li> <li><code>--address</code> 或 <code>-a</code> - 指定发送 XCM 消息的源链地址</li> <li><code>--para-id</code> 或 <code>--p</code> -（可选）指定 XCM 消息的原始链的平行链 ID。它是可选的，因为 XCM 消息可能来自中继链（没有平行链 ID）。或者，平行链可以充当其他平行链的中继链</li> <li><code>--parents</code> -（可选）对应于源链相对于目标链的父链值。如果要计算中继链上帐户的导出的原始地址帐户，则此值为 <code>1</code>。如果省略，则父链值默认为 <code>0</code></li> </ul> <p>要使用该脚本，您可以采取以下步骤：</p> <ol> <li>克隆 xcm-tools 存储库</li> <li>运行 <code>yarn</code> 以安装必要的软件包</li> <li> <p>运行脚本</p> <pre><code>yarn calculate-multilocation-derivative-account \\\n--ws-provider INSERT_RPC_ENDPOINT \\\n--address INSERT_ORIGIN_ACCOUNT \\\n--para-id INSERT_ORIGIN_PARACHAIN_ID_IF_APPLIES \\\n--parents INSERT_PARENTS_VALUE_IF_APPLIES\n</code></pre> </li> </ol> <p>您还可以使用 XCM 实用程序预编译 的 <code>multilocationToAddress</code> 函数来计算导出的原始地址帐户。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/computed-origins/#calculate-the-computed-origin-on-moonbeam", "title": "计算基于 Moonbeam 的网络上的计算来源", "text": "<p>例如，要在 Moonbase Alpha 上计算 Alice 的中继链账户的计算来源，该账户为 <code>5DV1dYwnQ27gKCKwhikaw1rz1bYdvZZUuFkuduB4hEK3FgDT</code>，您可以使用以下命令来运行脚本：</p> <pre><code>yarn calculate-multilocation-derivative-account \\\n--ws-provider wss://wss.api.moonbase.moonbeam.network \\\n--address 5DV1dYwnQ27gKCKwhikaw1rz1bYdvZZUuFkuduB4hEK3FgDT \\\n--parents 1\n</code></pre> <p>Note</p> <p>对于 Moonbeam 或 Moonriver，您将需要拥有自己的端点和 API 密钥，您可以从支持的 端点提供商 处获取。</p> <p>返回的输出包括以下值：</p> 名称 值 原始链编码地址 <code>5DV1dYwnQ27gKCKwhikaw1rz1bYdvZZUuFkuduB4hEK3FgDT</code> 原始链解码地址 <code>0x3ec5f48ad0567c752275d87787954fef72f557b8bfa5eefc88665fa0beb89a56</code> 目标链中收到的多位置 <code>{\"parents\":1,\"interior\":{\"x1\":{\"accountId32\":{\"network\": {\"westend\":null},\"id\":\"0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0afb2e78fdbbbf4ce26c2556c\"}}}}</code> 计算得到的来源账户 (32 字节) <code>0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0afb2e78fdbbbf4ce26c2556c</code> 计算得到的来源账户 (20 字节) <code>0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0</code> <p>因此，对于此示例，Alice 在 Moonbase Alpha 上的计算来源帐户是 <code>0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0</code>。 请注意，Alice 是唯一可以从继链通过远程交易访问此帐户的人，因为她是其私钥的所有者，并且计算出的来源帐户是无密钥的。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/overview/", "title": "通过 XCM 进行远程执行", "text": ""}, {"location": "builders/interoperability/xcm/remote-execution/overview/#introduction", "title": "简介", "text": "<p>跨共识消息（XCM）格式定义了如何在可互操作的区块链之间发送消息。此格式为发送 XCM 消息打开了大门，该消息可以在基于 Moonbeam 的网络、中继链或 Polkadot/Kusama 生态系统中的其他平行链中执行任意字节集。</p> <p>通过 XCM 进行远程执行为跨链交互开辟了一系列新的可能性，从链在其他链上执行操作到用户在不切换链的情况下执行远程操作。</p> <p>本页介绍了 XCM 远程执行的基本原理。如果您想了解如何通过 XCM 执行远程执行，请参阅通过 Substrate API 进行远程执行或通过 Ethereum API 进行远程执行指南。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/overview/#execution-origin", "title": "执行源", "text": "<p>一般来说，所有交易都有一个源，也就是调用的来源。以太坊交易只有一种源类型，即 <code>msg.sender</code>，它是启动交易的账户。</p> <p>基于 Substrate 的交易更为复杂，因为它们可以具有不同权限级别的不同源。这类似于具有特定 <code>require</code> 语句的 EVM 智能合约调用，其中调用必须来自允许的地址。相比之下，这些权限级别是在基于 Substrate 的运行时本身中编程的。</p> <p>源在 Substrate 运行时的不同组件中非常重要，因此在 Moonbeam 运行时中也很重要。例如，它们定义了他们在链上治理实施中继承的权限级别。</p> <p>在执行 XCM 消息期间，源定义了执行 XCM 的上下文。默认情况下，XCM 由目标链中源链的主权账户执行。这种 Polkadot 特有的属性，即具有在执行 XCM 时计算的远程源，被称为计算源（以前称为多位置衍生账户）。</p> <p>根据目标链的配置，包括 <code>DescendOrigin</code> XCM 指令可以改变执行 XCM 消息的源。此属性对于远程 XCM 执行非常重要，因为正在执行的操作会考虑新改变的源的上下文，而不是源链的主权账户。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/overview/#xcm-instructions-remote-execution", "title": "远程执行的 XCM 指令", "text": "<p>通过 XCM 在 Moonbeam（作为一个例子）上执行远程执行所需的核心 XCM 指令如下：</p> <ul> <li><code>DescendOrigin</code> - （可选）在 Moonbeam 中执行。改变来源以创建一个新的计算来源，该来源表示由来源链中的发送者通过 XCM 控制的无密钥账户</li> <li><code>WithdrawAsset</code> - 在 Moonbeam 中执行。从计算来源中提取资金</li> <li><code>BuyExecution</code> - 在 Moonbeam 中执行。使用前一个 XCM 指令提取的资金来支付 XCM 执行费用，包括远程调用</li> <li><code>Transact</code> - 在 Moonbeam 中执行。执行 XCM 指令中提供的任意字节</li> </ul> <p>以上详细说明的 XCM 指令可以用其他 XCM 指令来补充，以更准确地处理某些情况，例如执行失败。一个例子是包含 <code>SetAppendix</code>、<code>RefundSurplus</code> 和 <code>Deposit</code>。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/overview/#general-remote-execution-via-xcm-flow", "title": "通过 XCM 流进行通用远程执行", "text": "<p>用户通过构建 XCM 的 pallet 在源链中启动一个交易，该 XCM 至少包含远程执行所需的 XCM 指令。该交易在源链中执行，源链将包含给定指令的 XCM 消息发送到目标链。</p> <p>XCM 消息到达目标链，目标链执行它。默认情况下，它以源链的 Sovereign 帐户作为计算 Origin 执行。使用此类 Origin 的一个示例是链在 relay 链上打开或接受 HRMP 通道时。</p> <p>如果 XCM 消息包含 <code>DescendOrigin</code> 指令，则目标链可能会改变 Origin 以计算新的计算 Origin（Moonbeam 及其衍生网络就是这种情况）。</p> <p>接下来，<code>WithdrawAsset</code> 从计算 Origin（Sovereign 帐户或已改变的帐户）中提取资金，然后这些资金用于通过 <code>BuyExecution</code> XCM 指令支付 XCM 执行费用。请注意，在这两个指令中，您都需要指定要使用的资产。此外，您必须在要购买的执行量中包含要执行的字节。</p> <p>最后，<code>Transact</code> 执行对应于目标链中 pallet 和函数的任意字节集。您必须指定要使用的 Origin 类型（通常为 <code>SovereignAccount</code>）和执行字节所需的权重（类似于以太坊领域中的 gas）。</p> <p></p>"}, {"location": "builders/interoperability/xcm/remote-execution/remote-evm-calls/", "title": "通过 XCM 进行远程 EVM 调用", "text": ""}, {"location": "builders/interoperability/xcm/remote-execution/remote-evm-calls/#introduction", "title": "简介", "text": "<p>XCM Transactor Pallet 提供了一个简单的界面，用于通过 XCM 执行远程跨链调用。但是，这不考虑对 Moonbeam 的 EVM 进行远程调用的可能性，仅考虑对特定于 Substrate 的 pallet（功能）进行调用。</p> <p>Moonbeam 的 EVM 只能通过 Ethereum Pallet 访问。除此之外，此 pallet 还在将交易放入交易池之前处理某些交易验证。然后，它在将池中的交易插入区块之前执行另一个验证步骤。最后，它通过 <code>transact</code> 函数提供接口来执行经过验证的交易。所有这些步骤都遵循与以太坊交易在结构和签名方案方面相同的行为。</p> <p>但是，直接通过 XCM <code>Transact</code> 调用 Ethereum Pallet 是不可行的。主要是因为远程 EVM 调用的调度器账户（在以太坊中称为 <code>msg.sender</code>）未在 Moonbeam 端签署 XCM 交易。XCM extrinsic 在起始链中签名，XCM 执行器通过 <code>Transact</code> 指令从链接到起始链中发送者的已知调用者调度调用。在这种情况下，Ethereum Pallet 将无法验证签名，并最终验证交易。</p> <p>为此，引入了 Ethereum XCM Pallet。它充当 XCM <code>Transact</code> 指令和 Ethereum Pallet 之间的中间件，因为通过 XCM 远程执行 EVM 调用时需要进行特殊考虑。该 pallet 执行必要的检查并验证交易。接下来，该 pallet 调用 Ethereum Pallet 以将交易调度到 EVM。由于访问 EVM 的方式，常规 EVM 调用和远程 EVM 调用之间存在一些差异。</p> <p>以下图表描述了通过 XCM 进行的常规 EVM 调用和远程 EVM 调用的理想路径：</p> <p></p> <p>本指南将介绍常规 EVM 调用和远程 EVM 调用之间的差异。此外，它还将向您展示如何通过 Ethereum XCM pallet 公开的 extrinsic 执行远程 EVM 调用。</p> <p>Note</p> <p>远程 EVM 调用通过 XCM Transactor Pallet 完成。因此，建议在尝试通过 XCM 执行远程 EVM 调用之前，先熟悉 XCM Transactor 的概念。</p> <p>请注意，通过 XCM 对 Moonbeam 的 EVM 进行的远程调用仍在积极开发中。此外，开发人员必须了解，发送不正确的 XCM 消息可能会导致资金损失。 因此，至关重要的是在 TestNet 上测试 XCM 功能，然后再转移到生产环境。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/remote-evm-calls/#differences-regular-remote-evm", "title": "通过 XCM 进行常规和远程 EVM 调用的区别", "text": "<p>正如简介中所述，常规和远程 EVM 调用到达 EVM 的路径截然不同。造成这种差异的主要原因是交易的调度程序。</p> <p>常规 EVM 调用有一个明显的发送者，它使用其私钥对以太坊交易进行签名。ECDSA 类型的签名可以通过签名消息和签名算法生成的 <code>r-s</code> 值进行验证。以太坊签名使用一个名为 <code>v</code> 的附加变量，它是恢复标识符。</p> <p>对于远程 EVM 调用，签名者在另一条链中签署 XCM 交易。Moonbeam 接收该 XCM 消息，该消息遵循通过 XCM 形式的常规远程执行：</p> <ul> <li><code>DescendOrigin</code>（可选）</li> <li><code>WithdrawAsset</code></li> <li><code>BuyExecution</code></li> <li><code>Transact</code></li> </ul> <p>XCM 执行通过 计算来源账户机制进行，默认情况下，该机制使用源链的主权账户在目标链中。如果包含 <code>DescendOrigin</code>，Moonbeam 会将 XCM 调用的来源更改为无密钥账户，源链中的用户可以通过 XCM 远程控制该账户。远程 EVM 调用从该无密钥账户（或相关的代理）分派。因此，由于交易未签名，因此没有签名的实际 <code>v-r-s</code> 值，而是 <code>0x1</code>。</p> <p>由于远程 EVM 调用没有签名的实际 <code>v-r-s</code> 值，因此 EVM 交易哈希可能会出现冲突问题，因为它被计算为签名交易 blob 的 keccak256 哈希。因此，如果两个具有相同 nonce 的账户提交相同的交易对象，它们将最终得到相同的 EVM 交易哈希。因此，所有远程 EVM 交易都使用附加到 以太坊 XCM Pallet 的全局 nonce。</p> <p>另一个显著差异是 gas 价格。远程 EVM 调用的费用是在 XCM 执行级别收取的。因此，EVM 级别的 gas 价格为零，并且 EVM 不会收取执行本身的费用。这也可以在远程 EVM 调用交易的回执中看到。因此，必须配置 XCM 消息，以便 <code>BuyExecution</code> 购买足够的权重来支付 gas 成本。</p> <p>最后一个区别在于 gas 限制。以太坊使用 gas 计量系统来调节可以在一个区块中完成的执行量。相反，Moonbeam 使用基于权重的系统，其中每个调用都以在一个区块中执行所需的时间为特征。每个权重单位对应于一皮秒的执行时间。</p> <p>截至运行时 2900，XCM 队列的配置表明 XCM 消息应在以下权重单位内执行：</p> <p>===</p> <pre><code>```\n125,000,000,000（0.125 秒的区块执行时间）\n```\n</code></pre> <p>===</p> <pre><code>```\n500,000,000,000（0.5 秒的区块执行时间）\n```\n</code></pre> <p>===</p> <pre><code>```\n500,000,000,000（0.5 秒的区块执行时间）\n```\n</code></pre> <p>Note</p> <p>在运行时 2900 之前，所有网络中 XCM 消息的权重限制均为 <code>20,000,000,000</code> 权重单位（即 <code>0.02</code> 秒的区块执行时间）。</p> <p>假设 XCM 消息由于给定区块中缺少执行时间而无法执行，并且权重要求超过上述限制。在这种情况下，XCM 消息将被标记为“超重”，并且只能通过民主方式执行。</p> <p>每个 XCM 消息的最大权重限制限制了通过 XCM 进行远程 EVM 调用可用的 gas 限制。对于所有基于 Moonbeam 的网络，每个权重单位的 gas 比率为 <code>25,000</code> (<code>WEIGHT_REF_TIME_PER_SECOND</code> / <code>GAS_PER_SECOND</code>)。考虑到您需要一些 XCM 消息权重来执行 XCM 指令，远程 EVM 调用可能会消耗 2,000,000,000 个单位。以下公式可用于确定远程 EVM 调用的最大 gas 单位数：</p> <pre><code>Maximum Gas Units = (Maximum Weight Units - Remote EVM Weight Units) / 25,000\n</code></pre> <p>因此，可以计算出您可以为远程 EVM 调用提供的最大 gas 限制：</p> <p>===</p> <pre><code>```\nMaximum Gas Units = (125,000,000,000 - 2,000,000,000) / 25,000\nMaximum Gas Units = 4,920,000\n```\n</code></pre> <p>===</p> <pre><code>```\nMaximum Gas Units = (500,000,000,000 - 2,000,000,000) / 25,000\nMaximum Gas Units = 19,920,000\n```\n</code></pre> <p>===</p> <pre><code>```\nMaximum Gas Units = (500,000,000,000 - 2,000,000,000) / 25,000\nMaximum Gas Units = 19,920,000\n```\n</code></pre> <p>Note</p> <p>这些值将来可能会发生变化。</p> <p>总之，以下是常规 EVM 调用和远程 EVM 调用之间的主要区别：</p> <ul> <li>远程 EVM 调用使用全局 nonce（由 以太坊 XCM Pallet 拥有），而不是每个账户的 nonce</li> <li>远程 EVM 调用的签名的 <code>v-r-s</code> 值为 <code>0x1</code>。无法通过标准方法（例如，通过 ECRECOVER）从签名中检索发送者。但是，<code>from</code> 包含在交易回执中，以及通过哈希获取交易时（使用以太坊 JSON-RPC）</li> <li>所有远程 EVM 调用的 gas 价格为零。EVM 执行在 XCM 执行级别收费，而不是在 EVM 级别收费</li> <li>您可以为远程 EVM 调用设置的当前最大 gas 限制不同，如上所述</li> </ul>"}, {"location": "builders/interoperability/xcm/remote-execution/remote-evm-calls/#ethereum-xcm-pallet-interface", "title": "Ethereum XCM Pallet 接口", "text": ""}, {"location": "builders/interoperability/xcm/remote-execution/remote-evm-calls/#extrinsics", "title": "外在函数", "text": "<p>Ethereum XCM Pallet 提供了以下外在函数（函数），可以通过 <code>Transact</code> 指令调用，以通过 XCM 访问 Moonbeam 的 EVM：</p> transact(xcmTransaction) — 通过 XCM 远程调用 EVM 的函数。只能通过执行 XCM 消息来调用 参数Polkadot.js API 示例 <ul> <li><code>xcmTransaction</code> - 将被调度的调用的以太坊交易详情。版本化的 <code>xcmTransaction</code> 结构包含以下内容：<ul> <li><code>gasLimit</code> - 以太坊交易的 gas 限制</li> <li><code>action</code> - 要执行的操作，它提供两个选项：<code>Call</code> 和 <code>Create</code>。Ethereum XCM Pallet 的当前实现不支持 <code>CREATE</code> 操作。因此，您无法通过远程 EVM 调用部署智能合约。对于 <code>Call</code>，您需要指定您正在交互的合约地址</li> <li><code>value</code> - 要发送的本地代币的数量</li> <li><code>input</code> - 合约交互的编码调用数据</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst xcmTransaction = {\n  V2: {\n    gasLimit: INSERT_GAS_LIMIT,\n    action: { Call: 'INSERT_CONTRACT_ADDRESS_TO_CALL' },\n    value: INSERT_VALUE,\n    input: 'INSERT_CONTRACT_CALL_DATA',\n  },\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.ethereumXcm.transact(xcmTransaction);\n};\n\nmain();      \n</code></pre> <p>Note</p> <p>在以下部分中，您将准确了解如何获取以太坊交易调用数据，以及如何使用此外在函数构建 XCM 消息。</p> transactThroughProxy(transactAs, xcmTransaction) — 通过 XCM 远程调用 EVM 并从具有已知密钥的给定帐户（<code>msg.sender</code>）调度的函数 参数Polkadot.js API 示例 <ul> <li><code>xcmTransaction</code> - 将被调度的调用的以太坊交易详情。版本化的 <code>xcmTransaction</code> 结构包含以下内容：<ul> <li><code>gasLimit</code> - 以太坊交易的 gas 限制</li> <li><code>action</code> - 要执行的操作，它提供两个选项：<code>Call</code> 和 <code>Create</code>。Ethereum XCM Pallet 的当前实现不支持 <code>CREATE</code> 操作。因此，您无法通过远程 EVM 调用部署智能合约。对于 <code>Call</code>，您需要指定您正在交互的合约地址</li> <li><code>value</code> - 要发送的本地代币的数量</li> <li><code>input</code> - 合约交互的编码调用数据</li> </ul> </li> <li><code>xcmTransactAs</code> - 将从中调度远程 EVM 调用的帐户（<code>msg.sender</code>）。此帐户需要在 Moonbeam 上将计算出的原始帐户设置为 <code>any</code> 类型的代理，否则远程 EVM 调用将失败。交易费用仍然由计算出的原始账户支付</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst xcmTransaction = {\n  V2: {\n    gasLimit: INSERT_GAS_LIMIT,\n    action: { Call: 'INSERT_CONTRACT_ADDRESS_TO_CALL' },\n    value: INSERT_VALUE,\n    input: 'INSERT_CONTRACT_CALL_DATA',\n  },\n};\nconst xcmTransactAs = 'INSERT_COMPUTED_ORIGIN_PROXY_ADDRESS';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.ethereumXcm.transactThroughProxy(\n    xcmTransaction,\n    xcmTransactAs\n  );\n};\n\nmain();\n</code></pre>"}, {"location": "builders/interoperability/xcm/remote-execution/remote-evm-calls/#build-remote-evm-call-xcm", "title": "通过 XCM 构建远程 EVM 调用", "text": "<p>本指南介绍如何使用从XCM Pallet从 relay 链到 Moonbase Alpha 构建用于远程 EVM 调用的 XCM 消息。更具体地说，它将使用 <code>transact</code> 函数。使用 <code>transactThroughProxy</code> 函数的步骤是相同的。但是，您需要提供 <code>transactAs</code> 账户，并确保此账户已在 Moonbase Alpha 上将计算源账户设置为 <code>any</code> 类型的代理。</p> <p>Note</p> <p>当使用 <code>transactThroughProxy</code> 时，EVM 调用由您提供的 <code>transactAs</code> 账户分派，充当 <code>msg.sender</code>，只要此账户已在您使用的基于 Moonbeam 的网络中将计算源账户设置为 <code>any</code> 类型的代理。但是，交易费用仍由计算源账户支付，因此您需要确保它有足够的资金来支付这些费用。</p> <p>构建和执行远程执行的过程可以概括如下：</p> <ol> <li>计算将在 Moonbase Alpha 上执行的 EVM 调用的调用数据</li> <li>使用 EVM 调用数据生成 Moonbase Alpha 上 Ethereum XCM Pallet 的 <code>transact</code> extrinsic 的调用数据</li> <li>在 relay 链上构建 XCM 消息，其中将包括 <code>WithdrawAsset</code>、<code>BuyExecution</code> 和 <code>Transact</code> 指令。在 <code>Transact</code> 指令中，您将使用 Ethereum XCM <code>transact</code> 调用数据</li> <li>使用 relay 链上的 Alice 账户，您将通过 XCM Pallet 的 <code>send</code> extrinsic 发送 XCM 消息</li> <li>Moonbase Alpha 上的 Alice 计算源账户将分派 EVM 调用数据</li> </ol>"}, {"location": "builders/interoperability/xcm/remote-execution/remote-evm-calls/#ethereumxcm-check-prerequisites", "title": "检查先决条件", "text": "<p>要能够从relay chain发送调用，您需要以下内容：</p> <ul> <li>在具有资金 (UNIT) 的relay chain上的帐户，以支付交易费用。您可以通过在Moonbeam-Swap（Moonbase Alpha上的演示Uniswap-V2克隆）上交换DEV代币（Moonbase Alpha的本地代币）来获取一些xcUNIT，然后将它们发送到relay chain。此外，您可以在Discord上联系我们以直接获取一些UNIT代币</li> <li>您的Computed Origin帐户的地址。请参阅 Computed Origin 指南，以了解如何计算您的Computed Origin地址</li> <li>为您的Computed Origin帐户提供资金。该帐户必须有足够的DEV代币（或Moonbeam/Moonriver的GLMR/MOVR），以支付远程EVM调用的XCM执行成本。请注意，这是将从中调度远程EVM调用的帐户 (<code>msg.sender</code>)。因此，该帐户必须满足EVM调用正确执行所需的任何条件。例如，如果您要进行ERC-20转账，请持有任何相关的ERC-20代币</li> </ul> <p>Note</p> <p>假设您正在使用<code>transactThroughProxy</code>函数。在这种情况下，<code>transactAs</code>帐户必须满足EVM调用正确执行所需的任何条件，因为它充当 <code>msg.sender</code>。但是，Computed Origin帐户是需要持有DEV代币（或Moonbeam/Moonriver的GLMR/MOVR）以支付远程EVM调用的XCM执行成本的帐户。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/remote-evm-calls/#ethereumxcm-transact-data", "title": "Ethereum XCM 交易调用数据", "text": "<p>在您将 XCM 消息从 Relay 链发送到 Moonbase Alpha 之前，您需要获取编码后的调用数据，该数据将通过执行 <code>Transact</code> XCM 指令来分派。</p> <p>在此示例中，您将与 Ethereum XCM Pallet 的 <code>transact</code> 函数交互，该函数接受 <code>xcmTransaction</code> 作为参数。</p> <p><code>xcmTransaction</code> 参数要求您定义 <code>gasLimit</code>、<code>action</code>、<code>value</code> 和 <code>input</code>。</p> <p>对于要执行的操作，您将与一个简单的 递增合约 进行合约交互，该合约位于 <code>0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8</code>。您将调用 <code>increment</code> 函数，该函数没有输入参数，并且会将 <code>number</code> 的值增加 1。它还会将执行该函数的区块时间戳存储到 <code>timestamp</code> 变量中。</p> <p><code>increment</code> 函数的编码调用数据为 <code>0xd09de08a</code>，它是函数选择器，也是 <code>increment()</code> 的 keccak256 哈希的前八个十六进制字符（或 4 个字节）。如果您选择与具有输入参数的函数进行交互，则还需要对它们进行编码。获取编码调用数据最简单的方法是在 Remix 或 Moonscan 中模拟交易。然后，在 Metamask 中，选中 HEX DATA: 4 BYTES（十六进制数据：4 字节）选项卡下的 HEX（十六进制）以获取调用数据。您无需签署交易。</p> <p>现在，您已经获得了编码后的合约交互数据，您可以使用 <code>eth_estimateGas</code> JSON-RPC 方法 确定此调用的 gas 限制。对于此示例，您可以将 gas 限制设置为 <code>155000</code>。</p> <p>对于 value，您可以将其设置为 <code>0</code>，因为此特定交互不需要 DEV（或者 Moonbeam/Moonriver 的 GLMR/MOVR）。对于需要 DEV 的交互，您需要相应地修改此值。</p> <p>现在您已经拥有了 <code>xcmTransaction</code> 参数所需的所有组件，您可以构建它：</p> <pre><code>const xcmTransaction = {\n  V2: {\n    gasLimit: 155000,\n    action: { Call: '0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8' },\n    value: 0,\n    input: '0xd09de08a',\n  },\n};\n</code></pre> <p>接下来，您可以编写脚本来获取交易的编码调用数据。您将采取以下步骤：</p> <ol> <li>提供调用的输入数据。这包括：<ul> <li>用于创建提供程序的 Moonbase Alpha 端点 URL</li> <li><code>transact</code> 函数的 <code>xcmTransaction</code> 参数的值</li> </ul> </li> <li>创建 Polkadot.js API 提供程序</li> <li>使用 <code>xcmTransaction</code> 值制作 <code>ethereumXcm.transact</code> 外部函数</li> <li>获取外部函数的编码调用数据。您无需签署和发送交易</li> </ol> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\n// 1. Input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst xcmTransaction = {\n  V2: {\n    gasLimit: 155000,\n    action: { Call: '0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8' },\n    value: 0,\n    input: '0xd09de08a',\n  },\n};\n\nconst getEncodedCalldata = async () =&gt; {\n  // 2. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Create the extrinsic\n  const tx = api.tx.ethereumXcm.transact(xcmTransaction);\n\n  // 4. Get the encoded call data\n  const encodedCall = tx.method.toHex();\n  console.log(`Encoded Calldata: ${encodedCall}`);\n\n  api.disconnect();\n};\n\ngetEncodedCalldata();\n</code></pre> <p>Note</p> <p>您可以在 Polkadot.js Apps 上查看上述脚本输出的示例，使用以下编码的调用数据：<code>0x260001785d02000000000000000000000000000000000000000000000000000000000000a72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8000000000000000000000000000000000000000000000000000000000000000010d09de08a00</code>。</p> <p>您将在下一节的 <code>Transact</code> 指令中使用编码的调用数据。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/remote-evm-calls/#estimate-weight-required-at-most", "title": "估计所需的最大权重", "text": "<p>当使用 <code>Transact</code> 指令时，您需要定义 <code>requireWeightAtMost</code> 字段，这是交易所需的权重。此字段接受两个参数：<code>refTime</code> 和 <code>proofSize</code>。<code>refTime</code> 是可用于执行的计算时间量，<code>proofSize</code> 是可使用的存储量（以字节为单位）。</p> <p>要获得 <code>refTime</code> 和 <code>proofSize</code> 的估计值，您可以使用 Polkadot.js API 的 <code>paymentInfo</code> 方法。由于 <code>Transact</code> 调用数据需要这些权重，您可以扩展上一节中的脚本以添加对 <code>paymentInfo</code> 的调用。</p> <p><code>paymentInfo</code> 方法接受与通常传递给 <code>.signAndSend</code> 方法相同的参数，即发送帐户，以及可选的一些附加值，例如 nonce 或签名者。</p> <p>要修改编码的调用数据脚本，您需要添加 Alice 的 Computed Origin 地址，并使用它来调用 <code>tx.paymentInfo</code> 方法。</p> 修改后的脚本 <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\n// 1. Input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst xcmTransaction = {\n  V2: {\n    gasLimit: 155000,\n    action: { Call: '0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8' },\n    value: 0,\n    input: '0xd09de08a',\n  },\n};\n\nconst getEncodedCalldata = async () =&gt; {\n  // 2. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Create the extrinsic\n  const tx = api.tx.ethereumXcm.transact(xcmTransaction);\n\n  // 4. Estimate the required weight\n  const alice = '0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0';\n  const info = await tx.paymentInfo(alice);\n  console.log(`Required Weight: ${info.weight}`);\n\n  api.disconnect();\n};\n\ngetEncodedCalldata();\n</code></pre> <p>在撰写本文时，该脚本返回 <code>refTime</code> 的估计值为 <code>3900000000</code>，<code>proofSize</code> 的估计值为 <code>9687</code>。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/", "title": "使用 XCM Transactor Pallet 进行远程执行", "text": ""}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#introduction", "title": "简介", "text": "<p>XCM 消息由一系列由跨共识虚拟机（XCVM）执行的指令组成。这些指令的组合会产生预定的操作，例如跨链代币转移，更有趣的是远程跨链执行。远程执行涉及从一个区块链执行对另一个区块链的操作或动作，同时保持发送者身份和权限的完整性。</p> <p>通常，XCM 消息从根源（即 SUDO 或通过治理）发送，这对于希望通过简单交易利用远程跨链调用的项目来说并不理想。XCM Transactor Pallet使得通过主权账户（应该只允许通过治理）或通过来自源链的简单交易的计算来源账户，在远程链上进行交易变得容易。</p> <p>本指南将向您展示如何使用 XCM Transactor Pallet 从基于 Moonbeam 的网络向生态系统中的其他链发送 XCM 消息。此外，您还将学习如何使用 XCM Transactor Precompile 通过 Ethereum API 执行相同的操作。</p> <p>请注意，通过 XCM 消息远程执行的操作仍然存在限制。</p> <p>开发人员必须了解，发送不正确的 XCM 消息可能会导致资金损失。 因此，必须先在测试网上测试 XCM 功能，然后再转移到生产环境。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcm-transactor-pallet-interface", "title": "XCM 交易器 Pallet 接口", "text": ""}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#extrinsics", "title": "Extrinsics", "text": "<p>XCM Transactor Pallet 提供了以下 extrinsics（函数）：</p> hrmpManage(action, fee, weightInfo) - 管理与打开、接受和关闭 HRMP 通道相关的 HRMP 操作 <p>在 Moonbeam 或 Moonriver 上，此函数必须通过 General Admin 或 Root Track 的治理来执行。在 Moonbase Alpha 或 Moonbeam 开发节点上，此函数也可以通过 sudo 执行。</p> 参数Polkadot.js API 示例 <ul> <li><code>action</code> - 要执行的操作。可以是 <code>InitOpen</code>、<code>Accept</code>、<code>Close</code> 或 <code>Cancel</code></li> <li><code>fee</code> - 用于支付费用的资产。它包含 <code>currency</code> 和 <code>feeAmount</code>：<ul> <li><code>currency</code> - 定义您如何指定用于支付费用的代币，可以是以下任一项：<ul> <li><code>AsCurrencyId</code> - 用于支付费用的资产的货币 ID。货币 ID 可以是：<ul> <li><code>SelfReserve</code> - 使用原生资产</li> <li><code>ForeignAsset</code> - 使用 外部 XC-20。它要求您指定 XC-20 的资产 ID</li> <li><code>LocalAssetReserve</code> - 已弃用 - 请改用通过 <code>Erc20</code> 货币类型的 本地 XC-20</li> <li><code>Erc20</code> - 使用 本地 XC-20。它要求您指定本地 XC-20 的合约地址</li> </ul> </li> <li><code>AsMultiLocation</code> - 用于支付费用的资产的 XCM 版本化多重位置</li> </ul> </li> <li><code>feeAmount</code> - （可选）用于支付费用的金额</li> </ul> </li> <li><code>weightInfo</code> - 要使用的权重信息。<code>weightInfo</code> 结构包含以下内容：<ul> <li><code>transactRequiredWeightAtMost</code> - 执行 <code>Transact</code> 调用所需的权重。<code>transactRequiredWeightAtMost</code> 结构包含以下内容：<ul> <li><code>refTime</code> - 可用于执行的计算时间量</li> <li><code>proofSize</code> - 可使用的存储量（以字节为单位）</li> </ul> </li> <li><code>overallWeight</code> - （可选）extrinsic 可用于执行所有 XCM 指令的总权重，加上 <code>Transact</code> 调用的权重 (<code>transactRequiredWeightAtMost</code>)。<code>overallWeight</code> 可以定义为以下任一项：<ul> <li><code>Unlimited</code> - 允许可以购买的无限数量的权重</li> <li><code>Limited</code> - 通过定义以下内容来限制可以购买的权重数量：<ul> <li><code>refTime</code> - 可用于执行的计算时间量</li> <li><code>proofSize</code> - 可使用的存储量（以字节为单位）</li> </ul> </li> </ul> </li> </ul> </li> </ul> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const action = 'InitOpen'; // Or 'Accept', 'Close', or 'Cancel' const fee = {   currency: {     AsCurrencyId: { ForeignAsset: INSERT_ASSET_ID },   },   feeAmount: INSERT_FEE_AMOUNT, }; const weightInfo = {   transactRequiredWeightAtMost: {     refTime: INSERT_REF_TIME,     proofSize: INSERT_PROOF_SIZE,   },   overallWeight: { Unlimited: null }, };</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const tx = api.tx.xcmTransactor.hrmpManage(action, fee, weightInfo);   const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING'); }; main();</p> removeFeePerSecond(assetLocation) — 删除给定资产在其储备链中的每秒费用信息 <p>在 Moonbeam 或 Moonriver 上，此函数必须通过 General Admin 或 Root Track 的治理来执行。在 Moonbase Alpha 或 Moonbeam 开发节点上，此函数也可以通过 sudo 执行。</p> 参数Polkadot.js API 示例 <ul> <li><code>assetLocation</code> - 要删除每秒费用信息的资产的 XCM 版本化多重位置</li> </ul> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const assetLocation = {   V4: {     parents: INSERT_PARENTS,     interior: INSERT_INTERIOR,   }, };;</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const tx = api.tx.xcmTransactor.removeFeePerSecond(assetLocation);   const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING'); }; main();</p> removeTransactInfo(location) — 删除给定链的 transact 信息 <p>在 Moonbeam 或 Moonriver 上，此函数必须通过 General Admin 或 Root Track 的治理来执行。在 Moonbase Alpha 或 Moonbeam 开发节点上，此函数也可以通过 sudo 执行。</p> 参数Polkadot.js API 示例 <ul> <li><code>location</code> - 您要删除 transact 信息的给定链的 XCM 版本化多重位置</li> </ul> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const assetLocation = {   V4: {     parents: INSERT_PARENTS,     interior: INSERT_INTERIOR,   }, };;</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const tx = api.tx.xcmTransactor.removeTransactInfo(assetLocation);   const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING'); }; main();</p> setFeePerSecond(assetLocation, feePerSecond) — 设置给定资产在其储备链上的每秒费用。每秒费用信息通常与执行 XCM 指令的成本有关 <p>在 Moonbeam 或 Moonriver 上，此函数必须通过 General Admin 或 Root Track 的治理来执行。在 Moonbase Alpha 或 Moonbeam 开发节点上，此函数也可以通过 sudo 执行。</p> 参数Polkadot.js API 示例 <ul> <li><code>assetLocation</code> - 要删除每秒费用信息的资产的 XCM 版本化多重位置</li> <li><code>feePerSecond</code> - 在执行 XCM 指令时，将向 extrinsic 发送者收取的每秒 XCM 执行的代币单位数</li> </ul> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const assetLocation = {   V4: {     parents: INSERT_PARENTS,     interior: INSERT_INTERIOR,   }, }; const feePerSecond = INSERT_FEE_PER_SECOND;</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const tx = api.tx.xcmTransactor.setFeePerSecond(assetLocation, feePerSecond);   const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING'); };</p> <p>main();</p> setTransactInfo(location, transactExtraWeight, maxWeight) — 设置给定链的 transact 信息。transact 信息通常包括有关执行 XCM 指令所需的权重以及目标链上允许的远程 XCM 执行的最大权重的详细信息 <p>在 Moonbeam 或 Moonriver 上，此函数必须通过 General Admin 或 Root Track 的治理来执行。在 Moonbase Alpha 或 Moonbeam 开发节点上，此函数也可以通过 sudo 执行。</p> 参数Polkadot.js API 示例 <ul> <li><code>location</code> - 您要设置 transact 信息的给定链的 XCM 版本化多重位置</li> <li><code>transactExtraWeight</code> - 用于支付 XCM 指令（<code>WithdrawAsset</code>、<code>BuyExecution</code> 和 <code>Transact</code>）的执行费用的权重，估计至少比远程 XCM 指令执行使用的权重高 10%。<code>transactExtraWeight</code> 结构包含以下内容：<ul> <li><code>refTime</code> - 可用于执行的计算时间量</li> <li><code>proofSize</code> - 可使用的存储量（以字节为单位）</li> </ul> </li> <li><code>maxWeight</code> - 远程 XCM 执行允许的最大权重单位。<code>maxWeight</code> 结构还包含 <code>refTime</code> 和 <code>proofSize</code></li> <li><code>transactExtraWeightSigned</code> - （可选）用于支付 XCM 指令（<code>DescendOrigin</code>、<code>WithdrawAsset</code>、<code>BuyExecution</code> 和 <code>Transact</code>）的执行费用的权重，估计至少比远程 XCM 指令执行使用的权重高 10%。<code>transactExtraWeightSigned</code> 结构还包含 <code>refTime</code> 和 <code>proofSize</code></li> </ul> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const location = INSERT_MULTILOCATION; const transactExtraWeight = {   refTime: INSERT_REF_TIME,   proofSize: INSERT_PROOF_SIZE, }; const maxWeight = {   refTime: INSERT_REF_TIME,   proofSize: INSERT_PROOF_SIZE, };</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const tx = api.tx.xcmTransactor.setTransactInfo(     location,     transactExtraWeight,     maxWeight   );   const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING'); };</p> <p>main();</p> transactThroughSigned(destination, fee, call, weightInfo, refund) — 发送一条 XCM 消息，其中包含在目标链中远程执行调用的指令。远程调用将由目标平行链必须计算的新帐户签名并执行。基于 Moonbeam 的网络遵循 Polkadot 设置的 Computed Origins 标准 参数Polkadot.js API 示例 <ul> <li><code>dest</code> - XCM 版本化多重位置，用于生态系统中要将 XCM 消息发送到的链（目标链）</li> <li><code>fee</code> - 用于支付费用的资产。它包含 <code>currency</code> 和 <code>feeAmount</code>：<ul> <li><code>currency</code> - 定义您如何指定用于支付费用的代币，可以是以下任一项：<ul> <li><code>AsCurrencyId</code> - 用于支付费用的资产的货币 ID。货币 ID 可以是：<ul> <li><code>SelfReserve</code> - 使用原生资产</li> <li><code>ForeignAsset</code> - 使用 外部 XC-20。它要求您指定 XC-20 的资产 ID</li> <li><code>LocalAssetReserve</code> - 已弃用 - 请改用通过 <code>Erc20</code> 货币类型的 本地 XC-20</li> <li><code>Erc20</code> - 使用 本地 XC-20。它要求您指定本地 XC-20 的合约地址</li> </ul> </li> <li><code>AsMultiLocation</code> - 用于支付费用的资产的 XCM 版本化多重位置</li> </ul> </li> <li><code>feeAmount</code> - （可选）用于支付费用的金额</li> </ul> </li> <li><code>call</code> - 将在目标链中执行的调用的编码调用数据</li> <li><code>weightInfo</code> - 要使用的权重信息。<code>weightInfo</code> 结构包含以下内容：<ul> <li><code>transactRequiredWeightAtMost</code> - 执行 <code>Transact</code> 调用所需的权重。<code>transactRequiredWeightAtMost</code> 结构包含以下内容：<ul> <li><code>refTime</code> - 可用于执行的计算时间量</li> <li><code>proofSize</code> - 可使用的存储量（以字节为单位）</li> </ul> </li> <li><code>overallWeight</code> - （可选）extrinsic 可用于执行所有 XCM 指令的总权重，加上 <code>Transact</code> 调用的权重 (<code>transactRequiredWeightAtMost</code>)。<code>overallWeight</code> 可以定义为以下任一项：<ul> <li><code>Unlimited</code> - 允许可以购买的无限数量的权重</li> <li><code>Limited</code> - 通过定义以下内容来限制可以购买的权重数量：<ul> <li><code>refTime</code> - 可用于执行的计算时间量</li> <li><code>proofSize</code> - 可使用的存储量（以字节为单位）</li> </ul> </li> </ul> </li> </ul> </li> <li><code>refund</code> - 指示是否将 <code>RefundSurplus</code> 和 <code>DepositAsset</code> 指令添加到 XCM 消息以退还任何剩余费用的布尔值</li> </ul> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const dest = {   V4: {     parents: INSERT_PARENTS,     interior: INSERT_INTERIOR,   }, }; const fee = {   currency: {     AsCurrencyId: { ForeignAsset: INSERT_ASSET_ID },   },   feeAmount: INSERT_FEE_AMOUNT, }; const call = 'INSERT_ENCODED_CALL_DATA'; const weightInfo = {   transactRequiredWeightAtMost: {     refTime: INSERT_REF_TIME,     proofSize: INSERT_PROOF_SIZE,   },   overallWeight: { Unlimited: null }, }; const refund = INSERT_BOOLEAN_FOR_REFUND;</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const tx = api.tx.xcmTransactor.transactThroughSigned(     dest,     fee,     call,     weightInfo,     refund   );   const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING'); };</p> <p>main();      </p> <p>Note</p> <p>在以下部分中，您将准确了解如何检索使用此 extrinsic 构建和发送 XCM 消息所需的所有参数。</p> transactThroughSovereign(dest, feePayer, fee, call, originKind, weightInfo, refund) — 发送一条 XCM 消息，其中包含在给定目标远程执行给定调用的指令。远程调用将由源平行链 Sovereign 帐户（支付费用）签名，但事务是从给定的 origin 调度的。XCM Transactor Pallet 计算远程执行的费用，并以相应的 XC-20 代币 向给定帐户收取估计金额 参数Polkadot.js API 示例 <ul> <li><code>dest</code> - XCM 版本化多重位置，用于生态系统中要将 XCM 消息发送到的链（目标链）</li> <li><code>feePayer</code> - （可选）将以相应的 XC-20 代币 支付远程 XCM 执行费用的地址。如果未指定 <code>feePayer</code>，则 XCM 执行费用将由目标链上的 Sovereign 帐户支付</li> <li><code>fee</code> - 用于支付费用的资产。它包含 <code>currency</code> 和 <code>feeAmount</code>：<ul> <li><code>currency</code> - 定义您如何指定用于支付费用的代币，可以是以下任一项：<ul> <li><code>AsCurrencyId</code> - 用于支付费用的资产的货币 ID。货币 ID 可以是：<ul> <li><code>SelfReserve</code> - 使用原生资产</li> <li><code>ForeignAsset</code> - 使用 外部 XC-20。它要求您指定 XC-20 的资产 ID</li> <li><code>LocalAssetReserve</code> - 已弃用 - 请改用通过 <code>Erc20</code> 货币类型的 本地 XC-20</li> <li><code>Erc20</code> - 使用 本地 XC-20。它要求您指定本地 XC-20 的合约地址</li> </ul> </li> <li><code>AsMultiLocation</code> - 用于支付费用的资产的 XCM 版本化多重位置</li> </ul> </li> <li><code>feeAmount</code> - （可选）用于支付费用的金额</li> </ul> </li> <li><code>call</code> - 将在目标链中执行的调用的编码调用数据</li> <li><code>originKind</code> - 目标链中远程调用的调度程序。有四种类型的调度程序 可用：<code>Native</code>、<code>SovereignAccount</code>、<code>Superuser</code> 或 <code>Xcm</code></li> <li><code>weightInfo</code> - 要使用的权重信息。<code>weightInfo</code> 结构包含以下内容：<ul> <li><code>transactRequiredWeightAtMost</code> - 执行 <code>Transact</code> 调用所需的权重。<code>transactRequiredWeightAtMost</code> 结构包含以下内容：<ul> <li><code>refTime</code> - 可用于执行的计算时间量</li> <li><code>proofSize</code> - 可使用的存储量（以字节为单位）</li> </ul> </li> <li><code>overallWeight</code> - （可选）extrinsic 可用于执行所有 XCM 指令的总权重，加上 <code>Transact</code> 调用的权重 (<code>transactRequiredWeightAtMost</code>)。<code>overallWeight</code> 可以定义为以下任一项：<ul> <li><code>Unlimited</code> - 允许可以购买的无限数量的权重</li> <li><code>Limited</code> - 通过定义以下内容来限制可以购买的权重数量：<ul> <li><code>refTime</code> - 可用于执行的计算时间量</li> <li><code>proofSize</code> - 可使用的存储量（以字节为单位）</li> </ul> </li> </ul> </li> </ul> </li> <li><code>refund</code> - 指示是否将 <code>RefundSurplus</code> 和 <code>DepositAsset</code> 指令添加到 XCM 消息以退还任何剩余费用的布尔值</li> </ul> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const dest = {   V4: {     parents: INSERT_PARENTS,     interior: INSERT_INTERIOR,   }, }; const fee = {   currency: {     AsCurrencyId: { ForeignAsset: INSERT_ASSET_ID },   },   feeAmount: INSERT_FEE_AMOUNT, }; const feePayer = 'INSERT_ADDRESS_RESPONSIBLE_FOR_FEES'; const call = 'INSERT_ENCODED_CALL_DATA'; const originKind = 'INSERT_ORIGIN_KIND'; const weightInfo = {   transactRequiredWeightAtMost: {     refTime: INSERT_REF_TIME,     proofSize: INSERT_PROOF_SIZE,   },   overallWeight: { Unlimited: null }, }; const refund = INSERT_BOOLEAN_FOR_REFUND;</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const tx = api.tx.xcmTransactor.transactThroughSovereign(     dest,     feePayer,     fee,     call,     originKind,     weightInfo,     refund   );   const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING'); };</p> <p>main();</p>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#storage-methods", "title": "存储方法", "text": "<p>XCM Transactor Pallet 包含以下只读存储方法：</p> destinationAssetFeePerSecond(location) - 返回给定资产的每秒费用 参数返回值Polkadot.js API 示例 <ul> <li><code>location</code> - (可选) 特定目标资产的 XCM 版本多位置</li> </ul> <p>表示给定资产每秒费用的值的数字。此值的返回格式可能因链及其存储数据的方式而异。您可以使用 <code>@polkadot/util</code> 库进行各种转换，例如，使用 <code>hexToBigInt</code> 方法将十六进制值转换为大整数。</p> <p>js // 如果使用 Polkadot.js API 并在解包的值上调用 toJSON() 10000000000000</p> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const location = {   parents: INSERT_PARENTS,   interior: INSERT_INTERIOR, };</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const feePerSecond =     await api.query.xcmTransactor.destinationAssetFeePerSecond(location);</p> <p>if (feePerSecond.isSome) {     const data = feePerSecond.unwrap();     console.log(data.toJSON());   } };</p> <p>main();</p> palletVersion() — 从存储返回当前的 pallet 版本 参数返回值Polkadot.js API 示例 <p>无</p> <p>表示 pallet 当前版本的数字。</p> <p>js // 如果使用 Polkadot.js API 并在解包的值上调用 toJSON() 0</p> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const palletVersion = await api.query.xcmTransactor.palletVersion(); };</p> <p>main();</p> transactInfoWithWeightLimit(location) — 返回给定多位置的事务信息 参数返回值Polkadot.js API 示例 <ul> <li><code>location</code> - (可选) 特定目标资产的 XCM 版本多位置</li> </ul> <p>事务信息对象。</p> <p>js // 如果使用 Polkadot.js API 并在解包的值上调用 toJSON() {   transactExtraWeight: { refTime: 3000000000, proofSize: 131072 },   maxWeight: { refTime: 20000000000, proofSize: 131072 },   transactExtraWeightSigned: { refTime: 4000000000, proofSize: 131072 }, }</p> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const location = {   parents: INSERT_PARENTS,   interior: INSERT_INTERIOR, };</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });   const transactInfoWithWeightLimit =     await api.query.xcmTransactor.transactInfoWithWeightLimit(location);</p> <p>if (transactInfoWithWeightLimit.isSome) {     const data = transactInfoWithWeightLimit.unwrap();     console.log(data.toJSON());   } };</p> <p>main();</p>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#constants", "title": "Pallet 常量", "text": "<p>XCM 交易器 Pallet 包含以下只读函数来获取 pallet 常量：</p> baseXcmWeight() - 返回每个 XCM 指令执行所需的基本 XCM 权重 返回值Polkadot.js API 示例 <p>基本 XCM 权重对象。</p> <p>js // 如果使用 Polkadot.js API 并在解包的值上调用 toJSON()</p> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });</p> <p>const baseXcmWeight = api.consts.xcmTransactor.baseXcmWeight;   console.log(baseXcmWeight.toJSON()); };</p> <p>main();</p> selfLocation() - 返回链的 multilocation 返回值Polkadot.js API 示例 <p>自定位 multilocation 对象。</p> <p>js // 如果使用 Polkadot.js API 并在解包的值上调用 toJSON() { parents: 0, interior: { here: null } }</p> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const main = async () =&gt; {   const api = await ApiPromise.create({     provider: new WsProvider('INSERT_WSS_ENDPOINT'),   });</p> <p>const selfLocation = api.consts.xcmTransactor.selfLocation;   console.log(selfLocation.toJSON()); };</p> <p>main();</p>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcm-instructions-for-remote-execution", "title": "用于远程执行的 XCM 指令", "text": "<p>通过 XCM 执行远程执行的相关 XCM 指令 包括但不限于：</p> <ul> <li><code>DescendOrigin</code> - 在目标链中执行。它会改变目标链上的发起方，以匹配源链上的发起方，确保目标链上的执行代表在源链上发起 XCM 消息的同一实体发生</li> <li><code>WithdrawAsset</code> - 在目标链中执行。移除资产，并将它们放入持有登记处</li> <li><code>BuyExecution</code> - 在目标链中执行。从持有处获取资产以支付执行费用。要支付的费用由目标链确定</li> <li><code>Transact</code> - 在目标链中执行。从给定的发起方分派编码的调用数据，允许执行特定的操作或函数</li> </ul>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcmtransactor-transact-through-signed", "title": "通过计算的原始帐户进行交易", "text": "<p>本节介绍如何使用 XCM Transactor Pallet 构建用于远程执行的 XCM 消息，特别是使用 <code>transactThroughSigned</code> 函数。此函数使用目标链上的计算原始帐户来分发远程调用。</p> <p>本节中的示例使用了不可公开访问的目标平行链，因此您无法完全按照示例进行操作。您可以根据自己的用例修改示例。</p> <p>Note</p> <p>您需要确保要在远程执行的调用在目标链中是允许的！</p>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcmtransactor-signed-check-prerequisites", "title": "检查先决条件", "text": "<p>要能够发送本节中的外部调用，您需要具备以下条件：</p> <ul> <li>原始链中的一个帐户，其中包含资金</li> <li>目标链上计算出的原始帐户中的资金。要了解如何计算计算出的原始帐户的地址，请参阅如何计算计算出的原始帐户文档</li> </ul> <p>在此示例中，将使用以下帐户：</p> <ul> <li>Alice在原始平行链（Moonbase Alpha）中的帐户：<code>0x44236223aB4291b93EEd10E4B511B37a398DEE55</code></li> <li>她在目标平行链（平行链888）中计算出的原始地址：<code>0x5c27c4bb7047083420eddff9cddac4a0a120b45c</code></li> </ul>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcm-transact-through-signed", "title": "构建 XCM", "text": "<p>由于您将与 XCM Transactor Pallet 的 <code>transactThroughSigned</code> 函数交互，因此您需要组装 <code>dest</code>、<code>fee</code>、<code>call</code>、<code>weightInfo</code> 和 <code>refund</code> 参数的值。为此，您可以采取以下步骤：</p> <ol> <li> <p>定义目标多重位置，它将目标定为平行链 888</p> <p>js const privateKey = 'INSERT_PRIVATE_KEY'; const dest = {   V4: {     parents: 1,     interior: { X1: [{ Parachain: 888 }] },   },</p> </li> <li> <p>定义 <code>fee</code> 信息，这将要求您定义货币并设置费用金额</p> External XC-20sLocal XC-20s <p>js const fee = {   currency: {     AsCurrencyId: { ForeignAsset: 35487752324713722007834302681851459189n },   },   feeAmount: 50000000000000000n, };</p> <p>js const fee = {   currency: {     AsCurrencyId: { Erc20: { contractAddress: ERC_20_ADDRESS} },   },   feeAmount: 50000000000000000n, };</p> </li> <li> <p>定义将在目标链中执行的 <code>call</code>，它是要调用的 pallet、方法和输入的编码调用数据。 它可以在 Polkadot.js Apps（必须连接到目标链）或使用 Polkadot.js API 构建。 对于此示例，内部调用是将目标链的 1 个代币简单余额转移到 Alice 在那里的帐户</p> <p>js const call = '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';</p> </li> <li> <p>设置 <code>weightInfo</code>，其中包括特定于内部调用的权重 (<code>transactRequiredWeightAtMost</code>) 以及事务加上 XCM 执行的可选整体权重 (<code>overallWeight</code>)。 对于每个参数，您可以遵循以下准则：</p> <ul> <li>对于 <code>transactRequiredAtMost</code>，您可以将 <code>refTime</code> 设置为 <code>1000000000</code> 权重单位，将 <code>proofSize</code> 设置为 <code>40000</code></li> <li>对于 <code>overallWeight</code>，该值必须是 <code>transactRequiredWeightAtMost</code> 加上涵盖目标链中 XCM 指令的执行成本所需的权重的总和。 如果您不提供此值，则 pallet 将使用存储中的元素（如果存在）并将其添加到 <code>transactRequiredWeightAtMost</code>。 对于此示例，您可以将 <code>overallWeight</code> 设置为 <code>Unlimited</code>，这无需知道目标链需要多少权重才能执行 XCM</li> </ul> <p>js const weightInfo = {   transactRequiredWeightAtMost: { refTime: 1000000000n, proofSize: 40000n },   overallWeight: { Unlimited: null }, };</p> <p>Note</p> <p>为了准确估计 <code>transactRequiredAtMost</code> 的 <code>refTime</code> 和 <code>proofSize</code> 数字，您可以使用 Polkadot.js API 的 <code>paymentInfo</code> 方法。</p> </li> <li> <p>要退还任何剩余的 XCM 费用，您可以将 <code>refund</code> 值设置为 <code>true</code>。 否则，将其设置为 <code>false</code></p> <p>js const refund = true;</p> </li> </ol>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#sending-the-xcm", "title": "发送 XCM", "text": "<p>既然您已经获得了每个参数的值，那么您可以编写交易脚本。您需要执行以下步骤：</p> <ol> <li>提供调用的输入数据。包括：<ul> <li>用于创建提供程序的 Moonbase Alpha 端点 URL</li> <li><code>transactThroughSigned</code> 函数的每个参数的值</li> </ul> </li> <li>创建将用于发送交易的 Keyring 实例</li> <li>创建 Polkadot.js API 提供程序</li> <li>使用 <code>dest</code>、<code>fee</code>、<code>call</code>、<code>weightInfo</code> 和 <code>refund</code> 值制作 <code>xcmTransactor.transactThroughSigned</code> extrinsic</li> <li>使用 <code>signAndSend</code> extrinsic 和您在第二步中创建的 Keyring 实例发送交易</li> </ol> <p>Remember</p> <p>这仅用于演示目的。切勿将您的私钥存储在 JavaScript 文件中。</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\n// 1. Provide input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst dest = {\n  V4: {\n    parents: 1,\n    interior: { X1: [{ Parachain: 888 }] },\n  },\n};\nconst fee = {\n  currency: {\n    AsCurrencyId: { ForeignAsset: 35487752324713722007834302681851459189n },\n  },\n  feeAmount: 50000000000000000n,\n};\nconst call = '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\nconst weightInfo = {\n  transactRequiredWeightAtMost: { refTime: 1000000000n, proofSize: 40000n },\n  overallWeight: { Unlimited: null },\n};\nconst refund = true;\n\nconst transactThroughSigned = async () =&gt; {\n  // 2. Create Keyring instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'ethereum' });\n  const alice = keyring.addFromUri(privateKey);\n\n  // 3. Create Substrate API provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 4. Craft the extrinsic\n  const tx = api.tx.xcmTransactor.transactThroughSigned(\n    dest,\n    fee,\n    call,\n    weightInfo,\n    refund\n  );\n\n  // 5. Send the transaction\n  const txHash = await tx.signAndSend(alice);\n  console.log(`Submitted with hash ${txHash}`);\n\n  api.disconnect();\n};\n\ntransactThroughSigned();\n</code></pre> <p>Note</p> <p>您可以在 Polkadot.js 应用 上查看上述脚本的示例，该脚本将一个 token 发送到平行链 888 上的 Alice 的 Computed Origin 账户，使用以下编码的 calldata：<code>0x210604010100e10d00017576e5e612ff054915d426c546b1b21a010000c52ebca2b10000000000000000007c030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d02286bee02710200010001</code>。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#transact-through-computed-origin-fees", "title": "通过计算来源费用进行 XCM 交易", "text": "<p>当通过“计算来源”帐户进行交易时，交易费用由发起调用的同一帐户支付，该帐户是目标链中的“计算来源”帐户。因此，“计算来源”帐户必须持有必要的资金才能支付整个执行过程的费用。请注意，用于支付费用的目标 Token 不需要在来源链中注册为 XC-20。</p> <p>要估算 Alice 的“计算来源”帐户执行远程调用所需的 Token 数量，您需要检查特定于目标链的交易信息。您可以使用以下脚本来获取平行链 888 的交易信息：</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\n\nconst location = { parents: 1, interior: { X1: [{ Parachain: 888 }] } };\n\nconst main = async () =&gt; {\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  const transactInfoWithWeightLimit =\n    await api.query.xcmTransactor.transactInfoWithWeightLimit(location);\n\n  if (transactInfoWithWeightLimit.isSome) {\n    const data = transactInfoWithWeightLimit.unwrap();\n    const transactExtraWeightSigned =\n      data.toJSON().transactExtraWeightSigned.refTime;\n    console.log(transactExtraWeightSigned);\n  }\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> <p>响应显示 <code>transactExtraWeightSigned</code> 是 <code>400,000,000</code>。执行该特定目标链中此远程调用的四个 XCM 指令需要此权重。接下来，您需要了解目标链根据资产价格对 XCM 执行的每个权重收取多少费用。以前，这是通过获取每秒单位值来完成的。但是，此方法已被计算相对价格所取代。相对价格是指从价值（即价格）角度来看，外币资产的多少单位对应于本地 Token（GLMR 或 MOVR）的一个单位。例如，如果外币资产价值 5 美元，而 GLMR 价值 0.25 美元，则相对价格为 0.05。但是，我们必须将结果缩放到 18 位小数，以对应于使用的 Wei 单位。在这种情况下，相对价格将为 <code>50000000000000000</code>。</p> <p>您可以使用 XCM Tools 存储库 中的脚本来计算相对价格。该脚本也复制如下：</p> 计算相对价格 <pre><code>import axios from 'axios';\nimport chalk from 'chalk';\n\n// CoinGecko IDs for the networks\nconst NETWORK_IDS = {\n  GLMR: 'moonbeam',\n  MOVR: 'moonriver',\n};\n\nasync function calculateRelativePrice(\n  assetPrice: number,\n  network: 'GLMR' | 'MOVR'\n): Promise&lt;string&gt; {\n  try {\n    // Fetch the native token price from CoinGecko\n    const response = await axios.get(\n      `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[network]}&amp;vs_currencies=usd`\n    );\n\n    const nativeTokenPrice = response.data[NETWORK_IDS[network]].usd;\n\n    // Calculate relative price with 18 decimal places\n    // Formula: (nativeTokenPrice / assetPrice) * 10^18\n    // This gives us how many units of the asset we need to equal 1 unit of native token\n    const relativePrice = (nativeTokenPrice / assetPrice) * Math.pow(10, 18);\n\n    // Return as string to preserve precision\n    return relativePrice.toFixed(0);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Failed to calculate relative price: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\nfunction validateInput(\n  price: string,\n  network: string\n): { assetPrice: number; network: 'GLMR' | 'MOVR' } {\n  // Validate price\n  const assetPrice = parseFloat(price);\n  if (isNaN(assetPrice) || assetPrice &lt;= 0) {\n    throw new Error('Price must be a positive number');\n  }\n\n  // Validate network\n  const upperNetwork = network.toUpperCase() as 'GLMR' | 'MOVR';\n  if (!['GLMR', 'MOVR'].includes(upperNetwork)) {\n    throw new Error('Network must be either GLMR or MOVR');\n  }\n\n  return { assetPrice, network: upperNetwork };\n}\n\nfunction printUsage() {\n  console.log('\\nUsage:');\n  console.log('npx ts-node relative-price-calculator.ts &lt;price&gt; &lt;network&gt;');\n  console.log('\\nExample:');\n  console.log('npx ts-node relative-price-calculator.ts 0.25 GLMR');\n  console.log('\\nParameters:');\n  console.log('price   - The price of your asset in USD');\n  console.log('network - Either GLMR or MOVR');\n}\n\nasync function main() {\n  try {\n    // Get command line arguments\n    const [, , price, network] = process.argv;\n\n    // Check if help flag is passed\n    if (price === '--help' || price === '-h') {\n      printUsage();\n      return;\n    }\n\n    // Check if required arguments are provided\n    if (!price || !network) {\n      console.error('Error: Missing required arguments');\n      printUsage();\n      process.exit(1);\n    }\n\n    // Validate inputs\n    const { assetPrice, network: validNetwork } = validateInput(price, network);\n\n    console.log(\n      `\\nCalculating relative price for asset worth $${assetPrice} against ${validNetwork}...`\n    );\n    const relativePrice = await calculateRelativePrice(\n      assetPrice,\n      validNetwork\n    );\n    const nativeTokenPrice = (\n      await axios.get(\n        `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[validNetwork]}&amp;vs_currencies=usd`\n      )\n    ).data[NETWORK_IDS[validNetwork]].usd;\n\n    const decimalRatio = nativeTokenPrice / assetPrice;\n\n    console.log(`\\nResults:`);\n    console.log(`Asset Price: $${assetPrice}`);\n    console.log(`Network: ${validNetwork}`);\n    console.log(`Native Token Price (from CoinGecko): $${nativeTokenPrice}`);\n    console.log(`\\nRelative Price Analysis:`);\n    console.log(\n      `1 ${validNetwork} is equal to approximately ${decimalRatio.toFixed(\n        3\n      )} of your specified token.`\n    );\n    console.log(\n      `With 18 decimals, 1 ${validNetwork} or in WEI, 1000000000000000000 is equal to a relative price of ${relativePrice} units of your token`\n    );\n    console.log(chalk.bold(`\\nRelative Price: ${relativePrice}`));\n    console.log(\n      `\\nThe relative price you should specify in asset registration steps is ${relativePrice}\\n`\n    );\n  } catch (error) {\n    console.error('\\nError:', error instanceof Error ? error.message : error);\n    process.exit(1);\n  }\n}\n\nmain();\n</code></pre> <p>请注意，相对价格值与 中继链 XCM 费用计算 部分中估计的成本相关，或者如果目标是另一条平行链，则与 每权重单位 部分中显示的成本相关。您需要找到正确的值，以确保“计算来源”帐户持有的 Token 数量是正确的。计算相关的 XCM 执行费用就像将 <code>transactExtraWeightSigned</code> 乘以 <code>relativePrice</code>（用于估算）一样简单：</p> <pre><code>XCM-Wei-Token-Cost = transactExtraWeightSigned * relativePrice\nXCM-Token-Cost = XCM-Wei-Token-Cost / DecimalConversion\n</code></pre> <p>因此，通过派生调用进行一次 XCM Transactor 交易的实际计算如下：</p> <pre><code>XCM-Wei-Token-Cost = 400000000 * 50000000000000000\nXCM-Token-Cost = 20000000000000 / 10^18\n</code></pre> <p>通过“计算来源”进行交易的成本是 <code>0.00002 TOKEN</code>。请注意，这不包括远程执行调用的成本，仅包括 XCM 执行费用。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/", "title": "使用 XCM Transactor 预编译进行远程执行", "text": "<p>XCM 消息由一系列由跨共识虚拟机 (XCVM) 执行的指令组成。这些指令的组合会产生预定的操作，例如跨链代币转移，更有趣的是，远程跨链执行。远程执行涉及从一个区块链在另一个区块链上执行操作或动作，同时保持发送者身份和权限的完整性。</p> <p>通常，XCM 消息是从根源（即 SUDO 或通过治理）发送的，这对于希望通过简单交易利用远程跨链调用的项目来说并不理想。XCM Transactor Pallet 可以通过主权账户（应仅允许通过治理）或通过来自源链的简单交易的计算来源账户，轻松地在远程链上进行交易。</p> <p>但是，XCM Transactor Pallet 是用 Rust 编写的，通常无法从 Moonbeam 的 Ethereum API 端访问。因此，Moonbeam 引入了 XCM Transactor 预编译，它是一个 Solidity 接口，允许您使用 Ethereum API 直接与 Substrate pallet 交互。</p> <p>本指南将向您展示如何使用 XCM Transactor 预编译将 XCM 消息从基于 Moonbeam 的网络发送到生态系统中的其他链。</p> <p>请注意，通过 XCM 消息远程执行的操作仍然存在限制。</p> <p>开发人员必须了解，发送不正确的 XCM 消息可能会导致资金损失。 因此，在转移到生产环境之前，必须在测试网上测试 XCM 功能。</p>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#precompile-address", "title": "XCM Transactor 预编译合约地址", "text": "<p>XCM Transactor 预编译有多个版本。V1 将在不久的将来被弃用，因此所有实现都必须迁移到更新的接口。</p> <p>XCM Transactor 预编译位于以下地址：</p> <p>===</p> <pre><code>| 版本  |                                地址                                 |\n|:-------:|:----------------------------------------------------------------------:|\n|   V1    | &lt;pre&gt;0x0000000000000000000000000000000000000806&lt;/pre&gt; |\n|   V2    | &lt;pre&gt;0x000000000000000000000000000000000000080d&lt;/pre&gt; |\n|   V3    | &lt;pre&gt;0x0000000000000000000000000000000000000817&lt;/pre&gt; |\n</code></pre> <p>===     | 版本  |                                 地址                                 |     |:-------:|:-----------------------------------------------------------------------:|     |   V1    | <pre>0x0000000000000000000000000000000000000806</pre> |     |   V2    | <pre>0x000000000000000000000000000000000000080d</pre> |     |   V3    | <pre>0x0000000000000000000000000000000000000817</pre> |</p> <p>===</p> <pre><code>| 版本  |                                地址                                 |\n|:-------:|:----------------------------------------------------------------------:|\n|   V1    | &lt;pre&gt;0x0000000000000000000000000000000000000806&lt;/pre&gt; |\n|   V2    | &lt;pre&gt;0x000000000000000000000000000000000000080d&lt;/pre&gt; |\n|   V3    | &lt;pre&gt;0x0000000000000000000000000000000000000817&lt;/pre&gt; |\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcmtrasactor-solidity-interface", "title": "XCM Transactor Solidity 接口", "text": "<p>XCM Transactor 预编译合约是一个 Solidity 接口，开发者可以通过它使用 Ethereum API 与 XCM Transactor Pallet 交互。</p> XcmTransactorV1.sol <p>solidity // SPDX-License-Identifier: GPL-3.0-only pragma solidity &gt;=0.8.3;</p> <p>/// @dev The XcmTransactorV1 contract's address. address constant XCM_TRANSACTOR_V1_ADDRESS = 0x0000000000000000000000000000000000000806;</p> <p>/// @dev The XcmTransactorV1 contract's instance. XcmTransactorV1 constant XCM_TRANSACTOR_V1_CONTRACT = XcmTransactorV1(     XCM_TRANSACTOR_V1_ADDRESS );</p> <p>/// @author The Moonbeam Team /// @title Xcm Transactor Interface /// @dev The interface through which solidity contracts will interact with xcm transactor pallet /// @custom:address 0x0000000000000000000000000000000000000806 interface XcmTransactorV1 {     // A multilocation is defined by its number of parents and the encoded junctions (interior)     struct Multilocation {         uint8 parents;         bytes[] interior;     }</p> <pre><code>/// Get index of an account in xcm transactor\n/// @custom:selector 3fdc4f36\n/// @param index The index of which we want to retrieve the account\n/// @return owner The owner of the derivative index\n///\nfunction indexToAccount(uint16 index) external view returns (address owner);\n\n/// DEPRECATED, replaced by transactInfoWithSigned\n/// Get transact info of a multilocation\n/// @custom:selector d07d87c3\n/// @param multilocation The location for which we want to know the transact info\n/// @return transactExtraWeight The extra weight involved in the XCM message of using derivative\n/// @return feePerSecond The amount of fee charged for a second of execution in the dest\n/// @return maxWeight Maximum allowed weight for a single message in dest\n///\nfunction transactInfo(Multilocation memory multilocation)\n    external\n    view\n    returns (\n        uint64 transactExtraWeight,\n        uint256 feePerSecond,\n        uint64 maxWeight\n    );\n\n/// Get transact info of a multilocation\n/// @custom:selector b689e20c\n/// @param multilocation The location for which we want to know the transact info\n/// @return transactExtraWeight The extra weight involved in the XCM message of using derivative\n/// @return transactExtraWeightSigned The extra weight involved in the XCM message of using signed\n/// @return maxWeight Maximum allowed weight for a single message in dest\n///\nfunction transactInfoWithSigned(Multilocation memory multilocation)\n    external\n    view\n    returns (\n        uint64 transactExtraWeight,\n        uint64 transactExtraWeightSigned,\n        uint64 maxWeight\n    );\n\n/// Get fee per second charged in its reserve chain for an asset\n/// @custom:selector 906c9990\n/// @param multilocation The asset location for which we want to know the fee per second value\n/// @return feePerSecond The fee per second that the reserve chain charges for this asset\n///\nfunction feePerSecond(Multilocation memory multilocation)\n    external\n    view\n    returns (uint256 feePerSecond);\n\n/// Transact through XCM using fee based on its multilocation\n/// @custom:selector 94a63c54\n/// @dev The token transfer burns/transfers the corresponding amount before sending\n/// @param transactor The transactor to be used\n/// @param index The index to be used\n/// @param feeAsset The asset in which we want to pay fees.\n/// It has to be a reserve of the destination chain\n/// @param weight The weight we want to buy in the destination chain\n/// @param innerCall The inner call to be executed in the destination chain\nfunction transactThroughDerivativeMultilocation(\n    uint8 transactor,\n    uint16 index,\n    Multilocation memory feeAsset,\n    uint64 weight,\n    bytes memory innerCall\n) external;\n\n/// Transact through XCM using fee based on its currencyId\n/// @custom:selector 02ae072d\n/// @dev The token transfer burns/transfers the corresponding amount before sending\n/// @param transactor The transactor to be used\n/// @param index The index to be used\n/// @param currencyId Address of the currencyId of the asset to be used for fees\n/// It has to be a reserve of the destination chain\n/// @param weight The weight we want to buy in the destination chain\n/// @param innerCall The inner call to be executed in the destination chain\nfunction transactThroughDerivative(\n    uint8 transactor,\n    uint16 index,\n    address currencyId,\n    uint64 weight,\n    bytes memory innerCall\n) external;\n\n/// Transact through XCM using fee based on its multilocation through signed origins\n/// @custom:selector 71d31587\n/// @dev No token is burnt before sending the message. The caller must ensure the destination\n/// is able to understand the DescendOrigin message, and create a unique account from which\n/// dispatch the call\n/// @param dest The destination chain (as multilocation) where to send the message\n/// @param feeLocation The asset multilocation that indentifies the fee payment currency\n/// It has to be a reserve of the destination chain\n/// @param weight The weight we want to buy in the destination chain for the call to be made\n/// @param call The call to be executed in the destination chain\nfunction transactThroughSignedMultilocation(\n    Multilocation memory dest,\n    Multilocation memory feeLocation,\n    uint64 weight,\n    bytes memory call\n) external;\n\n/// Transact through XCM using fee based on its erc20 address through signed origins\n/// @custom:selector 42ca339d\n/// @dev No token is burnt before sending the message. The caller must ensure the destination\n/// is able to understand the DescendOrigin message, and create a unique account from which\n/// dispatch the call\n/// @param dest The destination chain (as multilocation) where to send the message\n/// @param feeLocationAddress The ERC20 address of the token we want to use to pay for fees\n/// only callable if such an asset has been BRIDGED to our chain\n/// @param weight The weight we want to buy in the destination chain for the call to be made\n/// @param call The call to be executed in the destination chain\nfunction transactThroughSigned(\n    Multilocation memory dest,\n    address feeLocationAddress,\n    uint64 weight,\n    bytes memory call\n) external;\n\n/// @dev Encode 'utility.as_derivative' relay call\n/// @custom:selector ff86378d\n/// @param transactor The transactor to be used\n/// @param index: The derivative index to use\n/// @param innerCall: The inner call to be executed from the derivated address\n/// @return result The bytes associated with the encoded call\nfunction encodeUtilityAsDerivative(uint8 transactor, uint16 index, bytes memory innerCall)\n    external\n    pure\n    returns (bytes memory result);\n</code></pre> <p>}</p> XcmTransactorV2.sol <p>solidity // SPDX-License-Identifier: GPL-3.0-only pragma solidity &gt;=0.8.0;</p> <p>/// @dev The XcmTransactorV2 contract's address. address constant XCM_TRANSACTOR_V2_ADDRESS = 0x000000000000000000000000000000000000080D;</p> <p>/// @dev The XcmTransactorV2 contract's instance. XcmTransactorV2 constant XCM_TRANSACTOR_V2_CONTRACT = XcmTransactorV2(     XCM_TRANSACTOR_V2_ADDRESS );</p> <p>/// @author The Moonbeam Team /// @title Xcm Transactor Interface /// The interface through which solidity contracts will interact with xcm transactor pallet /// @custom:address 0x000000000000000000000000000000000000080D interface XcmTransactorV2 {     // A multilocation is defined by its number of parents and the encoded junctions (interior)     struct Multilocation {         uint8 parents;         bytes[] interior;     }</p> <pre><code>/// Get index of an account in xcm transactor\n/// @custom:selector 3fdc4f36\n/// @param index The index of which we want to retrieve the account\n/// @return owner The owner of the derivative index\n///\nfunction indexToAccount(uint16 index) external view returns (address owner);\n\n/// Get transact info of a multilocation\n/// @custom:selector b689e20c\n/// @param multilocation The location for which we want to know the transact info\n/// @return transactExtraWeight The extra weight involved in the XCM message of using derivative\n/// @return transactExtraWeightSigned The extra weight involved in the XCM message of using signed\n/// @return maxWeight Maximum allowed weight for a single message in dest\n///\nfunction transactInfoWithSigned(Multilocation memory multilocation)\n    external\n    view\n    returns (\n        uint64 transactExtraWeight,\n        uint64 transactExtraWeightSigned,\n        uint64 maxWeight\n    );\n\n/// Get fee per second charged in its reserve chain for an asset\n/// @custom:selector 906c9990\n/// @param multilocation The asset location for which we want to know the fee per second value\n/// @return feePerSecond The fee per second that the reserve chain charges for this asset\n///\nfunction feePerSecond(Multilocation memory multilocation)\n    external\n    view\n    returns (uint256 feePerSecond);\n\n/// Transact through XCM using fee based on its multilocation\n/// @custom:selector fe430475\n/// @dev The token transfer burns/transfers the corresponding amount before sending\n/// @param transactor The transactor to be used\n/// @param index The index to be used\n/// @param feeAsset The asset in which we want to pay fees.\n/// It has to be a reserve of the destination chain\n/// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain\n/// @param innerCall The inner call to be executed in the destination chain\n/// @param feeAmount Amount to be used as fee.\n/// @param overallWeight Overall weight to be used for the xcm message.\n///\nfunction transactThroughDerivativeMultilocation(\n    uint8 transactor,\n    uint16 index,\n    Multilocation memory feeAsset,\n    uint64 transactRequiredWeightAtMost,\n    bytes memory innerCall,\n    uint256 feeAmount,\n    uint64 overallWeight\n) external;\n\n/// Transact through XCM using fee based on its currency_id\n/// @custom:selector 185de2ae\n/// @dev The token transfer burns/transfers the corresponding amount before sending\n/// @param transactor The transactor to be used\n/// @param index The index to be used\n/// @param currencyId Address of the currencyId of the asset to be used for fees\n/// It has to be a reserve of the destination chain\n/// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain\n/// @param innerCall The inner call to be executed in the destination chain\n/// @param feeAmount Amount to be used as fee.\n/// @param overallWeight Overall weight to be used for the xcm message.\nfunction transactThroughDerivative(\n    uint8 transactor,\n    uint16 index,\n    address currencyId,\n    uint64 transactRequiredWeightAtMost,\n    bytes memory innerCall,\n    uint256 feeAmount,\n    uint64 overallWeight\n) external;\n\n/// Transact through XCM using fee based on its multilocation through signed origins\n/// @custom:selector d7ab340c\n/// @dev No token is burnt before sending the message. The caller must ensure the destination\n/// is able to understand the DescendOrigin message, and create a unique account from which\n/// dispatch the call\n/// @param dest The destination chain (as multilocation) where to send the message\n/// @param feeLocation The asset multilocation that indentifies the fee payment currency\n/// It has to be a reserve of the destination chain\n/// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain for the call to be made\n/// @param call The call to be executed in the destination chain\n/// @param feeAmount Amount to be used as fee.\n/// @param overallWeight Overall weight to be used for the xcm message.\nfunction transactThroughSignedMultilocation(\n    Multilocation memory dest,\n    Multilocation memory feeLocation,\n    uint64 transactRequiredWeightAtMost,\n    bytes memory call,\n    uint256 feeAmount,\n    uint64 overallWeight\n) external;\n\n/// Transact through XCM using fee based on its erc20 address through signed origins\n/// @custom:selector b648f3fe\n/// @dev No token is burnt before sending the message. The caller must ensure the destination\n/// is able to understand the DescendOrigin message, and create a unique account from which\n/// dispatch the call\n/// @param dest The destination chain (as multilocation) where to send the message\n/// @param feeLocationAddress The ERC20 address of the token we want to use to pay for fees\n/// only callable if such an asset has been BRIDGED to our chain\n/// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain for the call to be made\n/// @param call The call to be executed in the destination chain\n/// @param feeAmount Amount to be used as fee.\n/// @param overallWeight Overall weight to be used for the xcm message.\nfunction transactThroughSigned(\n    Multilocation memory dest,\n    address feeLocationAddress,\n    uint64 transactRequiredWeightAtMost,\n    bytes memory call,\n    uint256 feeAmount,\n    uint64 overallWeight\n) external;\n\n/// @dev Encode 'utility.as_derivative' relay call\n/// @custom:selector ff86378d\n/// @param transactor The transactor to be used\n/// @param index: The derivative index to use\n/// @param innerCall: The inner call to be executed from the derivated address\n/// @return result The bytes associated with the encoded call\nfunction encodeUtilityAsDerivative(uint8 transactor, uint16 index, bytes memory innerCall)\n    external\n    pure\n    returns (bytes memory result);\n</code></pre> <p>}</p> XcmTransactorV3.sol <p>solidity // SPDX-License-Identifier: GPL-3.0-only pragma solidity &gt;=0.8.0;</p> <p>/// @dev The XcmTransactorV3 contract's address. address constant XCM_TRANSACTOR_V3_ADDRESS = 0x0000000000000000000000000000000000000817;</p> <p>/// @dev The XcmTransactorV3 contract's instance. XcmTransactorV3 constant XCM_TRANSACTOR_V3_CONTRACT = XcmTransactorV3(     XCM_TRANSACTOR_V3_ADDRESS );</p> <p>/// @author The Moonbeam Team /// @title Xcm Transactor Interface /// The interface through which solidity contracts will interact with xcm transactor pallet /// @custom:address 0x0000000000000000000000000000000000000817 interface XcmTransactorV3 {     // A multilocation is defined by its number of parents and the encoded junctions (interior)     struct Multilocation {         uint8 parents;         bytes[] interior;     }</p> <pre><code>// Support for Weights V2\nstruct Weight {\n    uint64 refTime;\n    uint64 proofSize;\n}\n\n/// Get index of an account in xcm transactor\n/// @custom:selector 3fdc4f36\n/// @param index The index of which we want to retrieve the account\n/// @return owner The owner of the derivative index\n///\nfunction indexToAccount(uint16 index) external view returns (address owner);\n\n/// Get transact info of a multilocation\n/// @custom:selector b689e20c\n/// @param multilocation The location for which we want to know the transact info\n/// @return transactExtraWeight The extra weight involved in the XCM message of using derivative\n/// @return transactExtraWeightSigned The extra weight involved in the XCM message of using signed\n/// @return maxWeight Maximum allowed weight for a single message in dest\n///\nfunction transactInfoWithSigned(Multilocation memory multilocation)\n    external\n    view\n    returns (\n        Weight memory transactExtraWeight,\n        Weight memory transactExtraWeightSigned,\n        Weight memory maxWeight\n    );\n\n/// Get fee per second charged in its reserve chain for an asset\n/// @custom:selector 906c9990\n/// @param multilocation The asset location for which we want to know the fee per second value\n/// @return feePerSecond The fee per second that the reserve chain charges for this asset\n///\nfunction feePerSecond(Multilocation memory multilocation)\n    external\n    view\n    returns (uint256 feePerSecond);\n\n/// Transact through XCM using fee based on its multilocation\n/// @custom:selector bdacc26b\n/// @dev The token transfer burns/transfers the corresponding amount before sending\n/// @param transactor The transactor to be used\n/// @param index The index to be used\n/// @param feeAsset The asset in which we want to pay fees.\n/// It has to be a reserve of the destination chain\n/// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain\n/// @param innerCall The inner call to be executed in the destination chain\n/// @param feeAmount Amount to be used as fee.\n/// @param overallWeight Overall weight to be used for the xcm message. If uint64:MAX is passed \n/// through refTime field, Unlimited variant will be used. \n/// @param refund Indicates if RefundSurplus instruction will be appended\nfunction transactThroughDerivativeMultilocation(\n    uint8 transactor,\n    uint16 index,\n    Multilocation memory feeAsset,\n    Weight memory transactRequiredWeightAtMost,\n    bytes memory innerCall,\n    uint256 feeAmount,\n    Weight memory overallWeight,\n    bool refund\n) external;\n\n/// Transact through XCM using fee based on its currency_id\n/// @custom:selector ca8c82d8\n/// @dev The token transfer burns/transfers the corresponding amount before sending\n/// @param transactor The transactor to be used\n/// @param index The index to be used\n/// @param currencyId Address of the currencyId of the asset to be used for fees\n/// It has to be a reserve of the destination chain\n/// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain\n/// @param innerCall The inner call to be executed in the destination chain\n/// @param feeAmount Amount to be used as fee.\n/// @param overallWeight Overall weight to be used for the xcm message. If uint64:MAX is passed \n/// through refTime field, Unlimited variant will be used. \n/// @param refund Indicates if RefundSurplus instruction will be appended\nfunction transactThroughDerivative(\n    uint8 transactor,\n    uint16 index,\n    address currencyId,\n    Weight memory transactRequiredWeightAtMost,\n    bytes memory innerCall,\n    uint256 feeAmount,\n    Weight memory overallWeight,\n    bool refund\n) external;\n\n/// Transact through XCM using fee based on its multilocation through signed origins\n/// @custom:selector 27b1d492\n/// @dev No token is burnt before sending the message. The caller must ensure the destination\n/// is able to understand the DescendOrigin message, and create a unique account from which\n/// dispatch the call\n/// @param dest The destination chain (as multilocation) where to send the message\n/// @param feeLocation The asset multilocation that indentifies the fee payment currency\n/// It has to be a reserve of the destination chain\n/// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain for the call to be made\n/// @param call The call to be executed in the destination chain\n/// @param feeAmount Amount to be used as fee.\n/// @param overallWeight Overall weight to be used for the xcm message. If uint64:MAX is passed \n/// through refTime field, Unlimited variant will be used. \n/// @param refund Indicates if RefundSurplus instruction will be appended\nfunction transactThroughSignedMultilocation(\n    Multilocation memory dest,\n    Multilocation memory feeLocation,\n    Weight memory transactRequiredWeightAtMost,\n    bytes memory call,\n    uint256 feeAmount,\n    Weight memory overallWeight,\n    bool refund\n) external;\n\n/// Transact through XCM using fee based on its erc20 address through signed origins\n/// @custom:selector b18270cf\n/// @dev No token is burnt before sending the message. The caller must ensure the destination\n/// is able to understand the DescendOrigin message, and create a unique account from which\n/// dispatch the call\n/// @param dest The destination chain (as multilocation) where to send the message\n/// @param feeLocationAddress The ERC20 address of the token we want to use to pay for fees\n/// only callable if such an asset has been BRIDGED to our chain\n/// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain for the call to be made\n/// @param call The call to be executed in the destination chain\n/// @param feeAmount Amount to be used as fee.\n/// @param overallWeight Overall weight to be used for the xcm message. If uint64:MAX is passed \n/// through refTime field, Unlimited variant will be used. \n/// @param refund Indicates if RefundSurplus instruction will be appended\nfunction transactThroughSigned(\n    Multilocation memory dest,\n    address feeLocationAddress,\n    Weight memory transactRequiredWeightAtMost,\n    bytes memory call,\n    uint256 feeAmount,\n    Weight memory overallWeight,\n    bool refund\n) external;\n\n/// @dev Encode 'utility.as_derivative' relay call\n/// @custom:selector ff86378d\n/// @param transactor The transactor to be used\n/// @param index: The derivative index to use\n/// @param innerCall: The inner call to be executed from the derivated address\n/// @return result The bytes associated with the encoded call\nfunction encodeUtilityAsDerivative(uint8 transactor, uint16 index, bytes memory innerCall)\n    external\n    pure\n    returns (bytes memory result);\n</code></pre> <p>}</p> <p>Note</p> <p>XCM Transactor Precompile V1 将在不久的将来被弃用，因此所有实现都必须迁移到更新的接口。</p> <p>该接口在不同版本之间略有不同。您可以在下面找到每个版本的接口概述。</p> V2V3 <p>V2 接口包括以下函数：</p> transactInfoWithSigned(Multilocation memory multilocation) — 一个只读函数，返回给定链的事务信息 ParametersReturns <ul> <li><code>multilocation</code> - 要获取事务信息的链的 multilocation</li> </ul> <p>以下事务信息：</p> <ul> <li>与外部调用执行相关的三个 XCM 指令 (<code>transactExtraWeight</code>)</li> <li>与通过签名 extrinsic 进行事务的 <code>DescendOrigin</code> XCM 指令相关的额外权重信息 (<code>transactExtraWeightSigned</code>)</li> <li>给定链中消息允许的最大权重</li> </ul> <p>js [ 173428000n, 0n, 20000000000n ]</p> feePerSecond(Multilocation memory multilocation) — 一个只读函数，返回每秒 XCM 执行的 token 单位数，该值作为给定资产的 XCM 执行费用收取。当对于给定链，有多个资产可用于支付费用时，这非常有用 ParametersReturns <ul> <li><code>multilocation</code> - 要获取每秒单位值的资产的 multilocation</li> </ul> <p>储备链对给定资产收取的每秒费用。</p> <p>js 13764626000000n</p> transactThroughSignedMultilocation(Multilocation memory dest, Multilocation memory feeLocation, uint64 transactRequiredWeightAtMost, bytes memory call, uint256 feeAmount, uint64 overallWeight) — 发送一条 XCM 消息，其中包含在目标链中远程执行调用的指令。远程调用将由一个新账户签名并执行，该账户称为 Computed Origin 账户，目标平行链必须计算该账户。基于 Moonbeam 的网络遵循 Polkadot 设定的 Computed Origins 标准。您需要提供用于支付费用的 token 的资产 multilocation，而不是 XC-20 token 的地址 Parameters <ul> <li><code>dest</code> - 生态系统中一条链的 multilocation，XCM 消息将发送到该链（目标链）。multilocation 必须以特定方式格式化，这在 构建预编译 Multilocation 部分中描述</li> <li><code>feeLocation</code> - 用于支付费用的资产的 multilocation。multilocation 必须以特定方式格式化，这在 构建预编译 Multilocation 部分中描述</li> <li><code>transactRequiredWeightAtMost</code> - 在目标链中购买的权重，用于执行在 <code>Transact</code> 指令中定义的调用</li> <li><code>call</code> - 在目标链中执行的调用，如 <code>Transact</code> 指令中定义</li> <li><code>feeAmount</code> - 用作费用的金额</li> <li><code>overallWeight</code> - extrinsic 可以用来执行所有 XCM 指令的总权重，加上 <code>Transact</code> 调用的权重 (<code>transactRequiredWeightAtMost</code>)。<code>overallWeight</code> 结构还包含 <code>refTime</code> 和 <code>proofSize</code>。如果您为 <code>refTime</code> 传递一个 uint64 的最大值，您将允许购买无限量的权重，从而无需确切知道目标链执行 XCM 需要多少权重</li> </ul> transactThroughSigned(Multilocation memory dest, address feeLocationAddress, uint64 transactRequiredWeightAtMost, bytes memory call, uint256 feeAmount, uint64 overallWeight) — 发送一条 XCM 消息，其中包含在目标链中远程执行调用的指令。远程调用将由一个新账户签名并执行，该账户称为 Computed Origin 账户，目标平行链必须计算该账户。基于 Moonbeam 的网络遵循 Polkadot 设定的 Computed Origins 标准。您需要提供 XC-20 资产的地址以用于支付费用 Parameters <ul> <li><code>dest</code> - 生态系统中一条链的 multilocation，XCM 消息将发送到该链（目标链）。multilocation 必须以特定方式格式化，这在 构建预编译 Multilocation 部分中描述</li> <li><code>feeLocationAddress</code> - 用于支付费用的资产的 XC-20 地址</li> <li><code>transactRequiredWeightAtMost</code> - 在目标链中购买的权重，用于执行在 <code>Transact</code> 指令中定义的调用</li> <li><code>call</code> - 在目标链中执行的调用，如 <code>Transact</code> 指令中定义</li> <li><code>feeAmount</code> - 用作费用的金额</li> <li><code>overallWeight</code> - extrinsic 可以用来执行所有 XCM 指令的总权重，加上 <code>Transact</code> 调用的权重 (<code>transactRequiredWeightAtMost</code>)。<code>overallWeight</code> 结构还包含 <code>refTime</code> 和 <code>proofSize</code>。如果您为 <code>refTime</code> 传递一个 uint64 的最大值，您将允许购买无限量的权重，从而无需确切知道目标链执行 XCM 需要多少权重</li> </ul> <p>V3 接口增加了对 Weights V2 的支持，该版本更新了 <code>Weight</code> 类型，以表示除了计算时间之外的 proof size。因此，这要求定义 <code>refTime</code> 和 <code>proofSize</code>，其中 <code>refTime</code> 是可用于执行的计算时间量，<code>proofSize</code> 是可以使用的存储量（以字节为单位）。</p> <p>以下结构已添加到 XCM Transactor Precompile 中以支持 Weights V2：</p> <p>solidity struct Weight {     uint64 refTime;     uint65 proofSize; }</p> <p>此外，还增加了对 <code>RefundSurplus</code> 和 <code>DepositAsset</code> 指令的支持。要将 <code>RefundSurplus</code> 指令附加到 XCM 消息，您可以使用 <code>refund</code> 参数，如果设置为 <code>true</code>，该参数将退还未用于 <code>Transact</code> 的任何剩余资金。</p> <p>V3 接口包括以下函数：</p> transactInfoWithSigned(Multilocation memory multilocation) — 一个只读函数，返回给定链的事务信息 ParametersReturns <ul> <li><code>multilocation</code> - 要获取事务信息的链的 multilocation</li> </ul> <p>以下事务信息：</p> <ul> <li>与外部调用执行相关的三个 XCM 指令 (<code>transactExtraWeight</code>)</li> <li>与通过签名 extrinsic 进行事务的 <code>DescendOrigin</code> XCM 指令相关的额外权重信息 (<code>transactExtraWeightSigned</code>)</li> <li>给定链中消息允许的最大权重</li> </ul> <p>js [ 173428000n, 0n, 20000000000n ]</p> feePerSecond(Multilocation memory multilocation) — 一个只读函数，返回每秒 XCM 执行的 token 单位数，该值作为给定资产的 XCM 执行费用收取。当对于给定链，有多个资产可用于支付费用时，这非常有用 ParametersReturns <ul> <li><code>multilocation</code> - 要获取每秒单位值的资产的 multilocation</li> </ul> <p>储备链对给定资产收取的每秒费用。</p> <p>js 13764626000000n</p> transactThroughSignedMultilocation(Multilocation memory dest, Multilocation memory feeLocation, Weight transactRequiredWeightAtMost, bytes memory call, uint256 feeAmount, Weight overallWeight, bool refund) — 发送一条 XCM 消息，其中包含在目标链中远程执行调用的指令。远程调用将由一个新账户签名并执行，该账户称为 Computed Origin 账户，目标平行链必须计算该账户。基于 Moonbeam 的网络遵循 Polkadot 设定的 Computed Origins 标准。您需要提供用于支付费用的 token 的资产 multilocation，而不是 XC-20 token 的地址 Parameters <ul> <li><code>dest</code> - 生态系统中一条链的 multilocation，XCM 消息将发送到该链（目标链）。multilocation 必须以特定方式格式化，这在 构建预编译 Multilocation 部分中描述</li> <li><code>feeLocation</code> - 用于支付费用的资产的 multilocation。multilocation 必须以特定方式格式化，这在 以下部分 中描述</li> <li> <p><code>transactRequiredWeightAtMost</code> - 在目标链中购买的权重，用于执行在 <code>Transact</code> 指令中定义的调用。<code>transactRequiredWeightAtMost</code> 结构包含以下内容：</p> <ul> <li><code>refTime</code> - 可用于执行的计算时间量</li> <li><code>proofSize</code> - 可以使用的存储量（以字节为单位） 它应格式化如下： js [ INSERT_REF_TIME, INSERT_PROOF_SIZE ]</li> </ul> </li> <li> <p><code>call</code> - 在目标链中执行的调用，如 <code>Transact</code> 指令中定义</p> </li> <li><code>feeAmount</code> - 用作费用的金额</li> <li><code>overallWeight</code> - extrinsic 可以用来执行所有 XCM 指令的总权重，加上 <code>Transact</code> 调用的权重 (<code>transactRequiredWeightAtMost</code>)。<code>overallWeight</code> 结构还包含 <code>refTime</code> 和 <code>proofSize</code>。如果您为 <code>refTime</code> 传递一个 uint64 的最大值，您将允许购买无限量的权重，从而无需确切知道目标链执行 XCM 需要多少权重</li> <li><code>refund</code> - 一个布尔值，指示是否将 <code>RefundSurplus</code> 和 <code>DepositAsset</code> 指令添加到 XCM 消息中，以退还任何剩余费用</li> </ul> transactThroughSigned(Multilocation memory dest, address feeLocationAddress, Weight transactRequiredWeightAtMost, bytes memory call, uint256 feeAmount, Weight overallWeight, bool refund) — 发送一条 XCM 消息，其中包含在目标链中远程执行调用的指令。远程调用将由一个新账户签名并执行，该账户称为 Computed Origin 账户，目标平行链必须计算该账户。基于 Moonbeam 的网络遵循 Polkadot 设定的 Computed Origins 标准。您需要提供 XC-20 资产的地址以用于支付费用 Parameters <ul> <li><code>dest</code> - 生态系统中一条链的 multilocation，XCM 消息将发送到该链（目标链）。multilocation 必须以特定方式格式化，这在 构建预编译 Multilocation 部分中描述</li> <li><code>feeLocationAddress</code> - 用于支付费用的资产的 XC-20 地址</li> <li> <p><code>transactRequiredWeightAtMost</code> - 在目标链中购买的权重，用于执行在 <code>Transact</code> 指令中定义的调用。<code>transactRequiredWeightAtMost</code> 结构包含以下内容：</p> <ul> <li><code>refTime</code> - 可用于执行的计算时间量</li> <li><code>proofSize</code> - 可以使用的存储量（以字节为单位） 它应格式化如下： js [ INSERT_REF_TIME, INSERT_PROOF_SIZE ]</li> </ul> </li> <li> <p><code>call</code> - 在目标链中执行的调用，如 <code>Transact</code> 指令中定义</p> </li> <li><code>feeAmount</code> - 用作费用的金额</li> <li><code>overallWeight</code> - extrinsic 可以用来执行所有 XCM 指令的总权重，加上 <code>Transact</code> 调用的权重 (<code>transactRequiredWeightAtMost</code>)。<code>overallWeight</code> 结构还包含 <code>refTime</code> 和 <code>proofSize</code>。如果您为 <code>refTime</code> 传递一个 uint64 的最大值，您将允许购买无限量的权重，从而无需确切知道目标链执行 XCM 需要多少权重</li> <li><code>refund</code> - 一个布尔值，指示是否将 <code>RefundSurplus</code> 和 <code>DepositAsset</code> 指令添加到 XCM 消息中，以退还任何剩余费用</li> </ul>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcm-instructions-for-remote-execution", "title": "用于远程执行的 XCM 指令", "text": "<p>通过 XCM 执行远程执行的相关 XCM 指令 包括但不限于：</p> <ul> <li><code>DescendOrigin</code> - 在目标链中执行。它会改变目标链上的来源，以匹配源链上的来源，确保目标链上的执行代表在源链上发起 XCM 消息的同一实体</li> <li><code>WithdrawAsset</code> - 在目标链中执行。移除资产并将其放入持有注册表</li> <li><code>BuyExecution</code> - 在目标链中执行。从持有注册表中获取资产以支付执行费用。要支付的费用由目标链确定</li> <li><code>Transact</code> - 在目标链中执行。从给定的来源分派编码的调用数据，从而可以执行特定的操作或函数</li> </ul>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#building-the-precompile-multilocation", "title": "构建预编译多重定位", "text": "<p>在 XCM 交易器预编译接口中，<code>Multilocation</code> 结构定义如下：</p> <pre><code> struct Multilocation {\n    uint8 parents;\n    bytes[] interior;\n}\n</code></pre> <p>As with a standard multilocation, there are <code>parents</code> and <code>interior</code> elements. However, instead of defining the multilocation as an object, with Ethereum libraries, the struct is defined as an array, which contains a <code>uint8</code> for the <code>parents</code> as the first element and a bytes array for the <code>interior</code> as the second element.</p> <p>The normal values you would see for the <code>parents</code> element are:</p> Origin Destination Parents Value Parachain A Parachain A 0 Parachain A Relay Chain 1 Parachain A Parachain B 1 <p>For the <code>interior</code> element, the number of fields you need to drill down to in the target chain to reach the exact location of the target, such as the specific asset or account, represents the size of the bytes array:</p> Array Size Interior Value [] 0 Here [XYZ] 1 X1 [XYZ, ABC] 2 X2 [XYZ, ... N] N XN <p>Note</p> <p>Interior value <code>Here</code> is often used for the relay chain (either as a destination or to target the relay chain asset).</p> <p>Each field required to reach the exact location of the target needs to be defined as a hex string. The first byte (2 hexadecimal characters) corresponds to the selector of the field. For example:</p> Byte Value Selector Data Type 0x00 Parachain bytes4 0x01 AccountId32 bytes32 0x02 AccountIndex64 u64 0x03 AccountKey20 bytes20 0x04 PalletInstance byte 0x05 GeneralIndex u128 0x06 GeneralKey bytes[] <p>Next, depending on the selector and its data type, the following bytes correspond to the actual data being provided. Note that for <code>AccountId32</code>, <code>AccountIndex64</code>, and <code>AccountKey20</code>, the optional <code>network</code> field is appended at the end. For example:</p> Selector Data Value Represents Parachain \"0x00+000007E7\" Parachain ID 2023 AccountId32 \"0x01+AccountId32+00\" AccountId32, Network(Option) Null AccountId32 \"0x01+AccountId32+03\" AccountId32, Network Polkadot AccountKey20 \"0x03+AccountKey20+00\" AccountKey20, Network(Option) Null PalletInstance \"0x04+03\" Pallet Instance 3 <p>Note</p> <p>The <code>interior</code> data usually needs to be wrapped around quotes, or you might get an <code>invalid tuple value</code> error.</p> <p>以下代码片段介绍了一些 <code>Multilocation</code> 结构的示例，因为它们需要馈送到 XCM 交易器预编译函数中：</p> <p>js // Multilocation targeting the relay chain asset from a parachain [   1, // parents = 1   [], // interior = here ]</p> <p>// Multilocation targeting Moonbase Alpha DEV token from another parachain [   1, // parents = 1   [  // interior = X2 (the array has a length of 2)     \"0x00000003E8\", // Parachain selector + Parachain ID 1000 (Moonbase Alpha)     \"0x0403\", // Pallet Instance selector + Pallet Instance 3 (Balances Pallet)   ], ]</p> <p>// Multilocation targeting aUSD asset on Acala [   1, // parents = 1   [  // interior = X2 (the array has a length of 2)     \"0x00000007D0\", // Parachain selector + Parachain ID 2000 (Acala)     \"0x060001\", // General Key selector + Asset Key   ], ]</p>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcmtransactor-transact-through-signed", "title": "通过计算来源账户进行交易", "text": "<p>本节介绍了如何构建 XCM 消息，以便使用 XCM Transactor Pallet 进行远程执行，特别是使用 <code>transactThroughSigned</code> 函数。此函数使用目标链上的计算来源账户来分派远程调用。</p> <p>本节中的示例使用了一个不可公开访问的目标平行链，因此您无法完全按照示例进行操作。您可以根据自己的用例修改示例。</p> <p>Note</p> <p>您需要确保您要远程执行的调用在目标链中是允许的！</p>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcmtransactor-signed-check-prerequisites", "title": "检查先决条件", "text": "<p>要能够发送本节中的外部交易，您需要具备：</p> <ul> <li>原始链中的一个拥有资金的帐户</li> <li>目标链上的计算原始帐户中的资金。要了解如何计算计算原始帐户的地址，请参阅如何计算计算原始文档。</li> </ul> <p>在本示例中，将使用以下帐户：</p> <ul> <li>原始平行链（Moonbase Alpha）中的 Alice 帐户：<code>0x44236223aB4291b93EEd10E4B511B37a398DEE55</code></li> <li>目标平行链（Parachain 888）中她的计算原始地址：<code>0x5c27c4bb7047083420eddff9cddac4a0a120b45c</code></li> </ul>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcm-transact-through-signed", "title": "构建 XCM", "text": "<p>在此示例中，您将与 XCM 交易器预编译 V3 的 <code>transactThroughSigned</code> 函数交互。要使用此函数，您需要执行以下常规步骤：</p> <ol> <li>使用 Moonbase Alpha RPC 终结点创建提供程序</li> <li>创建签名者以发送交易。此示例使用私钥创建签名者，仅用于演示目的。切勿将您的私钥存储在 JavaScript 文件中</li> <li> <p>使用预编译的地址和 ABI 创建 XCM 交易器 V3 预编译的合约实例</p> XCM 交易器 V3 ABI <p>js [   {     inputs: [       {         internalType: 'uint8',         name: 'transactor',         type: 'uint8',       },       {         internalType: 'uint16',         name: 'index',         type: 'uint16',       },       {         internalType: 'bytes',         name: 'innerCall',         type: 'bytes',       },     ],     name: 'encodeUtilityAsDerivative',     outputs: [       {         internalType: 'bytes',         name: 'result',         type: 'bytes',       },     ],     stateMutability: 'pure',     type: 'function',   },   {     inputs: [       {         components: [           {             internalType: 'uint8',             name: 'parents',             type: 'uint8',           },           {             internalType: 'bytes[]',             name: 'interior',             type: 'bytes[]',           },         ],         internalType: 'struct XcmTransactorV3.Multilocation',         name: 'multilocation',         type: 'tuple',       },     ],     name: 'feePerSecond',     outputs: [       {         internalType: 'uint256',         name: 'feePerSecond',         type: 'uint256',       },     ],     stateMutability: 'view',     type: 'function',   },   {     inputs: [       {         internalType: 'uint16',         name: 'index',         type: 'uint16',       },     ],     name: 'indexToAccount',     outputs: [       {         internalType: 'address',         name: 'owner',         type: 'address',       },     ],     stateMutability: 'view',     type: 'function',   },   {     inputs: [       {         components: [           {             internalType: 'uint8',             name: 'parents',             type: 'uint8',           },           {             internalType: 'bytes[]',             name: 'interior',             type: 'bytes[]',           },         ],         internalType: 'struct XcmTransactorV3.Multilocation',         name: 'multilocation',         type: 'tuple',       },     ],     name: 'transactInfoWithSigned',     outputs: [       {         components: [           {             internalType: 'uint64',             name: 'refTime',             type: 'uint64',           },           {             internalType: 'uint64',             name: 'proofSize',             type: 'uint64',           },         ],         internalType: 'struct XcmTransactorV3.Weight',         name: 'transactExtraWeight',         type: 'tuple',       },       {         components: [           {             internalType: 'uint64',             name: 'refTime',             type: 'uint64',           },           {             internalType: 'uint64',             name: 'proofSize',             type: 'uint64',           },         ],         internalType: 'struct XcmTransactorV3.Weight',         name: 'transactExtraWeightSigned',         type: 'tuple',       },       {         components: [           {             internalType: 'uint64',             name: 'refTime',             type: 'uint64',           },           {             internalType: 'uint64',             name: 'proofSize',             type: 'uint64',           },         ],         internalType: 'struct XcmTransactorV3.Weight',         name: 'maxWeight',         type: 'tuple',       },     ],     stateMutability: 'view',     type: 'function',   },   {     inputs: [       {         internalType: 'uint8',         name: 'transactor',         type: 'uint8',       },       {         internalType: 'uint16',         name: 'index',         type: 'uint16',       },       {         internalType: 'address',         name: 'currencyId',         type: 'address',       },       {         components: [           {             internalType: 'uint64',             name: 'refTime',             type: 'uint64',           },           {             internalType: 'uint64',             name: 'proofSize',             type: 'uint64',           },         ],         internalType: 'struct XcmTransactorV3.Weight',         name: 'transactRequiredWeightAtMost',         type: 'tuple',       },       {         internalType: 'bytes',         name: 'innerCall',         type: 'bytes',       },       {         internalType: 'uint256',         name: 'feeAmount',         type: 'uint256',       },       {         components: [           {             internalType: 'uint64',             name: 'refTime',             type: 'uint64',           },           {             internalType: 'uint64',             name: 'proofSize',             type: 'uint64',           },         ],         internalType: 'struct XcmTransactorV3.Weight',         name: 'overallWeight',         type: 'tuple',       },       {         internalType: 'bool',         name: 'refund',         type: 'bool',       },     ],     name: 'transactThroughDerivative',     outputs: [],     stateMutability: 'nonpayable',     type: 'function',   },   {     inputs: [       {         internalType: 'uint8',         name: 'transactor',         type: 'uint8',       },       {         internalType: 'uint16',         name: 'index',         type: 'uint16',       },       {         components: [           {             internalType: 'uint8',             name: 'parents',             type: 'uint8',           },           {             internalType: 'bytes[]',             name: 'interior',             type: 'bytes[]',           },         ],         internalType: 'struct XcmTransactorV3.Multilocation',         name: 'feeAsset',         type: 'tuple',       },       {         components: [           {             internalType: 'uint64',             name: 'refTime',             type: 'uint64',           },           {             internalType: 'uint64',             name: 'proofSize',             type: 'uint64',           },         ],         internalType: 'struct XcmTransactorV3.Weight',         name: 'transactRequiredWeightAtMost',         type: 'tuple',       },       {         internalType: 'bytes',         name: 'innerCall',         type: 'bytes',       },       {         internalType: 'uint256',         name: 'feeAmount',         type: 'uint256',       },       {         components: [           {             internalType: 'uint64',             name: 'refTime',             type: 'uint64',           },           {             internalType: 'uint64',             name: 'proofSize',             type: 'uint64',           },         ],         internalType: 'struct XcmTransactorV3.Weight',         name: 'overallWeight',         type: 'tuple',       },       {         internalType: 'bool',         name: 'refund',         type: 'bool',       },     ],     name: 'transactThroughDerivativeMultilocation',     outputs: [],     stateMutability: 'nonpayable',     type: 'function',   },   {     inputs: [       {         components: [           {             internalType: 'uint8',             name: 'parents',             type: 'uint8',           },           {             internalType: 'bytes[]',             name: 'interior',             type: 'bytes[]',           },         ],         internalType: 'struct XcmTransactorV3.Multilocation',         name: 'dest',         type: 'tuple',       },       {         internalType: 'address',         name: 'feeLocationAddress',         type: 'address',       },       {         components: [           {             internalType: 'uint64',             name: 'refTime',             type: 'uint64',           },           {             internalType: 'uint64',             name: 'proofSize',             type: 'uint64',           },         ],         internalType: 'struct XcmTransactorV3.Weight',         name: 'transactRequiredWeightAtMost',         type: 'tuple',       },       {         internalType: 'bytes',         name: 'call',         type: 'bytes',       },       {         internalType: 'uint256',         name: 'feeAmount',         type: 'uint256',       },       {         components: [           {             internalType: 'uint64',             name: 'refTime',             type: 'uint64',           },           {             internalType: 'uint64',             name: 'proofSize',             type: 'uint64',           },         ],         internalType: 'struct XcmTransactorV3.Weight',         name: 'overallWeight',         type: 'tuple',       },       {         internalType: 'bool',         name: 'refund',         type: 'bool',       },     ],     name: 'transactThroughSigned',     outputs: [],     stateMutability: 'nonpayable',     type: 'function',   },   {     inputs: [       {         components: [           {             internalType: 'uint8',             name: 'parents',             type: 'uint8',           },           {             internalType: 'bytes[]',             name: 'interior',             type: 'bytes[]',           },         ],         internalType: 'struct XcmTransactorV3.Multilocation',         name: 'dest',         type: 'tuple',       },       {         components: [           {             internalType: 'uint8',             name: 'parents',             type: 'uint8',           },           {             internalType: 'bytes[]',             name: 'interior',             type: 'bytes[]',           },         ],         internalType: 'struct XcmTransactorV3.Multilocation',         name: 'feeLocation',         type: 'tuple',       },       {         components: [           {             internalType: 'uint64',             name: 'refTime',             type: 'uint64',           },           {             internalType: 'uint64',             name: 'proofSize',             type: 'uint64',           },         ],         internalType: 'struct XcmTransactorV3.Weight',         name: 'transactRequiredWeightAtMost',         type: 'tuple',       },       {         internalType: 'bytes',         name: 'call',         type: 'bytes',       },       {         internalType: 'uint256',         name: 'feeAmount',         type: 'uint256',       },       {         components: [           {             internalType: 'uint64',             name: 'refTime',             type: 'uint64',           },           {             internalType: 'uint64',             name: 'proofSize',             type: 'uint64',           },         ],         internalType: 'struct XcmTransactorV3.Weight',         name: 'overallWeight',         type: 'tuple',       },       {         internalType: 'bool',         name: 'refund',         type: 'bool',       },     ],     name: 'transactThroughSignedMultilocation',     outputs: [],     stateMutability: 'nonpayable',     type: 'function',   }, ];</p> </li> <li> <p>组装 <code>transactThroughSigned</code> 函数的参数：</p> <ul> <li> <p><code>dest</code> - 目标的多重定位，即平行链 888：</p> <p>js const dest = [   1, // parents = 1   [  // interior = X1 (数组长度为 1)     '0x0000000378', // 平行链选择器 + 平行链 ID 888   ], ];</p> </li> <li> <p><code>feeLocationAddress</code> - 用于支付费用的 XC-20 地址，即平行链 888 的原生资产：</p> <p>js const feeLocationAddress = '0xFFFFFFFF1AB2B146C526D4154905FF12E6E57675';</p> </li> <li> <p><code>transactRequiredWeightAtMost</code> - 在 <code>Transact</code> 指令中执行调用所需的权重。您可以使用 Polkadot.js API 的 <code>paymentInfo</code> 方法 获取此信息</p> <p>js const transactRequiredWeightAtMost = [1000000000n, 5000n];</p> </li> <li> <p><code>call</code> - 要调用的 pallet、方法和输入的编码调用数据。它可以在 Polkadot.js Apps（必须连接到目标链）中构建，也可以使用 Polkadot.js API。在此示例中，内部调用是将目标链的 1 个代币简单地转移到 Alice 在该链上的帐户：</p> <p>js const call =   '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';</p> </li> <li> <p><code>feeAmount</code> - 用于支付费用的金额</p> <p>js const feeAmount = 50000000000000000n;</p> </li> <li> <p><code>overallWeight</code> - 内部调用 (<code>transactRequiredWeightAtMost</code>) 特有的权重，加上覆盖目标链中 XCM 指令执行成本所需的权重：<code>DescendOrigin</code>、<code>WithdrawAsset</code>、<code>BuyExecution</code> 和 <code>Transact</code>。请务必注意，每个链都定义了自己的权重要求。要确定给定链上每个 XCM 指令所需的权重，请参阅该链的文档或联系其团队成员。或者，您可以为 <code>refTime</code>（数组的第一个索引）传递 uint64 的最大值。这将解释为使用无限量的权重，从而无需确切知道目标链执行 XCM 需要多少权重</p> <p>js const overallWeight = [18446744073709551615n, 10000n];</p> </li> </ul> </li> <li> <p>创建 <code>transactThroughSigned</code> 函数，传入参数</p> </li> <li>签名并发送交易</li> </ol> <p>===</p> <pre><code>js\nimport { ethers } from 'ethers'; // Import Ethers library\n\nconst abi = INSERT_ABI;\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n// Create contract instance\nconst xcmTransactorV3 = new ethers.Contract(\n  '0x0000000000000000000000000000000000000817',\n  abi,\n  signer\n);\n\n// Arguments for the transactThroughSigned function\nconst dest = [\n  1, // parents = 1\n  [\n    // interior = X1 (the array has a length of 1)\n    '0x0000000378', // Parachain selector + Parachain ID 888\n  ],\n];\nconst feeLocationAddress = '0xFFFFFFFF1AB2B146C526D4154905FF12E6E57675';\nconst transactRequiredWeightAtMost = [1000000000n, 5000n];\nconst call = '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\nconst feeAmount = 50000000000000000n;\nconst overallWeight = [2000000000n, 10000n];\nconst refund = true;\n\n// Sends 1 token to Alice's account on parachain 888\nasync function transactThroughSigned() {\n  // Creates, signs, and sends the transfer transaction\n  const transaction = await xcmTransactorV3.transactThroughSigned(\n    dest,\n    feeLocationAddress,\n    transactRequiredWeightAtMost,\n    call,\n    feeAmount,\n    overallWeight,\n    refund\n  );\n\n  // Waits for the transaction to be included in a block\n  await transaction.wait();\n  console.log(transaction);\n}\n\ntransactThroughSigned();\n</code></pre> <p>===</p> <pre><code>js\nimport Web3 from 'web3'; // Import Web3 library\n\nconst abi = INSERT_ABI;\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Web3 provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n// Create contract instance\nconst xcmTransactorV3 = new web3.eth.Contract(\n  abi,\n  '0x0000000000000000000000000000000000000817',\n  { from: web3.eth.accounts.privateKeyToAccount(privateKey).address } // 'from' is necessary for gas estimation\n);\n\n// Arguments for the transactThroughSigned function\nconst dest = [\n  1, // parents = 1\n  [\n    // interior = X1 (the array has a length of 1)\n    '0x0000000378', // Parachain selector + Parachain ID 888\n  ],\n];\nconst feeLocationAddress = '0xFFFFFFFF1AB2B146C526D4154905FF12E6E57675';\nconst transactRequiredWeightAtMost = [1000000000n, 5000n];\nconst call = '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\nconst feeAmount = 50000000000000000n;\nconst overallWeight = [2000000000n, 10000n];\nconst refund = true;\n\n// Sends 1 token to Alice's account on parachain 888\nasync function transactThroughSigned() {\n  // Create transaction\n  const transferTx = xcmTransactorV3.methods.transactThroughSigned(\n    dest,\n    feeLocationAddress,\n    transactRequiredWeightAtMost,\n    call,\n    feeAmount,\n    overallWeight,\n    refund\n  );\n\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: '0x000000000000000000000000000000000000080d',\n      data: transferTx.encodeABI(),\n      gas: await transferTx.estimateGas(),\n    },\n    privateKey\n  );\n\n  // Send signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(sendTx);\n}\n\ntransactThroughSigned();\n</code></pre> <p>===</p> <pre><code>py\nfrom web3 import Web3\n\nabi = \"INSERT_ABI\"  # Paste or import the XCM Transactor V3 ABI\nprivate_key = \"INSERT_PRIVATE_KEY\"  # This is for demo purposes, never store your private key in plain text\naddress = \"INSERT_ADDRESS\"  # The wallet address that corresponds to your private key\n\n# Create Web3 provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create contract instance\nxcm_transactor_v3 = web3.eth.contract(\n    address=\"0x0000000000000000000000000000000000000817\", abi=abi\n)\n\n# Arguments for the transactThroughSigned function\ndest = [\n    1,  # parents = 1\n    [\n        # interior = X1 (the array has a length of 1)\n        \"0x0000000378\",  # Parachain selector + Parachain ID 888\n    ],\n]\nfeeLocationAddress = \"0xFFFFFFFF1AB2B146C526D4154905FF12E6E57675\"\ntransactRequiredWeightAtMost = [1000000000, 5000]\ncall = \"0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d\"\nfeeAmount = 50000000000000000\noverallWeight = [2000000000, 10000]\nrefund = True\n\n\n# Sends 1 xcUNIT to the relay chain using the transferMultiasset function\ndef transact_through_signed():\n    # Create transaction\n    transferTx = xcm_transactor_v3.functions.transactThroughSigned(\n        dest,\n        feeLocationAddress,\n        transactRequiredWeightAtMost,\n        call,\n        feeAmount,\n        overallWeight,\n        refund,\n    ).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n\n    # Sign transaction\n    signedTx = web3.eth.account.sign_transaction(transferTx, private_key)\n\n    # Send tx and wait for receipt\n    hash = web3.eth.send_raw_transaction(signedTx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Tx successful with hash: { receipt.transactionHash.hex() }\")\n\n\ntransact_through_signed()\n</code></pre>"}, {"location": "builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#transact-through-computed-origin-fees", "title": "通过计算 Origin 费用进行 XCM 交易", "text": "<p>当通过计算 Origin 账户进行交易时，交易费用由发起调用的同一账户支付，即目标链中的计算 Origin 账户。因此，计算 Origin 账户必须持有必要的资金来支付整个执行过程。请注意，用于支付费用的目标 Token 不需要在起始链中注册为 XC-20。</p> <p>要估计 Alice 的计算 Origin 账户需要持有的 Token 数量才能执行远程调用，您需要检查特定于目标链的交易信息。您可以使用以下脚本来获取平行链 888 的交易信息：</p> <pre><code>import { ethers } from 'ethers'; // Import Ethers library\n\nconst abi = INSERT_ABI;\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers wallet &amp; contract instance\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\nconst xcmTransactorV3 = new ethers.Contract(\n  '0x0000000000000000000000000000000000000817',\n  abi,\n  signer\n);\n\n// Multilocation for parachain 888\nconst multilocation = [\n  1, // parents = 1\n  [  // interior = X1 (the array has a length of 1)\n    '0x0000000378', // Parachain selector + Parachain ID 888\n  ],\n];\n\nconst main = async () =&gt; {\n  const transactInfoWithSigned = await xcmTransactorV3.transactInfoWithSigned(\n    multilocation\n  );\n  console.log(transactInfoWithSigned);\n};\n\nmain();\n</code></pre> <p>响应显示 <code>transactExtraWeightSigned</code> 为 <code>400,000,000</code>。执行该特定目标链中此远程调用的四个 XCM 指令需要此权重。接下来，您需要找出目标链根据资产价格，对每个 XCM 执行权重的收费。以前，这是通过获取每秒单位值来完成的。但是，此方法已被计算相对价格所取代。相对价格是指从价值（即价格）角度来看，多少单位的外国资产对应于一个单位的本机 Token（GLMR 或 MOVR）。例如，如果外国资产价值 5 美元，而 GLMR 价值 0.25 美元，则相对价格为 0.05。但是，我们必须将结果缩放到 18 位小数，以对应于使用的 Wei 单位。在这种情况下，相对价格将为 <code>50000000000000000</code>。</p> <p>您可以使用 XCM Tools repo 中的脚本计算相对价格。该脚本也如下所示：</p> 计算相对价格 <pre><code>import axios from 'axios';\nimport chalk from 'chalk';\n\n// CoinGecko IDs for the networks\nconst NETWORK_IDS = {\n  GLMR: 'moonbeam',\n  MOVR: 'moonriver',\n};\n\nasync function calculateRelativePrice(\n  assetPrice: number,\n  network: 'GLMR' | 'MOVR'\n): Promise&lt;string&gt; {\n  try {\n    // Fetch the native token price from CoinGecko\n    const response = await axios.get(\n      `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[network]}&amp;vs_currencies=usd`\n    );\n\n    const nativeTokenPrice = response.data[NETWORK_IDS[network]].usd;\n\n    // Calculate relative price with 18 decimal places\n    // Formula: (nativeTokenPrice / assetPrice) * 10^18\n    // This gives us how many units of the asset we need to equal 1 unit of native token\n    const relativePrice = (nativeTokenPrice / assetPrice) * Math.pow(10, 18);\n\n    // Return as string to preserve precision\n    return relativePrice.toFixed(0);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Failed to calculate relative price: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\nfunction validateInput(\n  price: string,\n  network: string\n): { assetPrice: number; network: 'GLMR' | 'MOVR' } {\n  // Validate price\n  const assetPrice = parseFloat(price);\n  if (isNaN(assetPrice) || assetPrice &lt;= 0) {\n    throw new Error('Price must be a positive number');\n  }\n\n  // Validate network\n  const upperNetwork = network.toUpperCase() as 'GLMR' | 'MOVR';\n  if (!['GLMR', 'MOVR'].includes(upperNetwork)) {\n    throw new Error('Network must be either GLMR or MOVR');\n  }\n\n  return { assetPrice, network: upperNetwork };\n}\n\nfunction printUsage() {\n  console.log('\\nUsage:');\n  console.log('npx ts-node relative-price-calculator.ts &lt;price&gt; &lt;network&gt;');\n  console.log('\\nExample:');\n  console.log('npx ts-node relative-price-calculator.ts 0.25 GLMR');\n  console.log('\\nParameters:');\n  console.log('price   - The price of your asset in USD');\n  console.log('network - Either GLMR or MOVR');\n}\n\nasync function main() {\n  try {\n    // Get command line arguments\n    const [, , price, network] = process.argv;\n\n    // Check if help flag is passed\n    if (price === '--help' || price === '-h') {\n      printUsage();\n      return;\n    }\n\n    // Check if required arguments are provided\n    if (!price || !network) {\n      console.error('Error: Missing required arguments');\n      printUsage();\n      process.exit(1);\n    }\n\n    // Validate inputs\n    const { assetPrice, network: validNetwork } = validateInput(price, network);\n\n    console.log(\n      `\\nCalculating relative price for asset worth $${assetPrice} against ${validNetwork}...`\n    );\n    const relativePrice = await calculateRelativePrice(\n      assetPrice,\n      validNetwork\n    );\n    const nativeTokenPrice = (\n      await axios.get(\n        `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[validNetwork]}&amp;vs_currencies=usd`\n      )\n    ).data[NETWORK_IDS[validNetwork]].usd;\n\n    const decimalRatio = nativeTokenPrice / assetPrice;\n\n    console.log(`\\nResults:`);\n    console.log(`Asset Price: $${assetPrice}`);\n    console.log(`Network: ${validNetwork}`);\n    console.log(`Native Token Price (from CoinGecko): $${nativeTokenPrice}`);\n    console.log(`\\nRelative Price Analysis:`);\n    console.log(\n      `1 ${validNetwork} is equal to approximately ${decimalRatio.toFixed(\n        3\n      )} of your specified token.`\n    );\n    console.log(\n      `With 18 decimals, 1 ${validNetwork} or in WEI, 1000000000000000000 is equal to a relative price of ${relativePrice} units of your token`\n    );\n    console.log(chalk.bold(`\\nRelative Price: ${relativePrice}`));\n    console.log(\n      `\\nThe relative price you should specify in asset registration steps is ${relativePrice}\\n`\n    );\n  } catch (error) {\n    console.error('\\nError:', error instanceof Error ? error.message : error);\n    process.exit(1);\n  }\n}\n\nmain();\n</code></pre> <p>请注意，相对价格值与 中继链 XCM 费用计算 部分中估计的成本或 每权重单位 部分中显示的成本相关（如果目标是另一个平行链）。您需要找到正确的值，以确保计算 Origin 账户持有的 Token 数量正确。计算相关的 XCM 执行费用就像将 <code>transactExtraWeightSigned</code> 乘以 <code>relativePrice</code> 一样简单（用于估算）：</p> <pre><code>XCM-Wei-Token-Cost = transactExtraWeightSigned * relativePrice\nXCM-Token-Cost = XCM-Wei-Token-Cost / DecimalConversion\n</code></pre> <p>因此，通过派生调用进行一次 XCM Transactor 交易的实际计算如下：</p> <pre><code>XCM-Wei-Token-Cost = 400000000 * 50000000000000000\nXCM-Token-Cost = 20000000000000 / 10^18\n</code></pre> <p>通过计算 Origin 进行交易的成本为 <code>0.00002 TOKEN</code>。请注意，这不包括远程执行调用的成本，仅包括 XCM 执行费用。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/", "title": "如何通过治理注册跨链资产", "text": ""}, {"location": "builders/interoperability/xcm/xc-registration/assets/#introduction", "title": "简介", "text": "<p>要通过 XCM 在链之间转移资产，需要在两条链之间建立开放通道，并且需要在目标链上注册该资产。如果两条链之间不存在通道，则需要打开一个通道。请查看 XC 通道注册 指南，了解如何在 Moonbeam 和另一条链之间建立通道。</p> <p>本指南将向您展示如何在 Moonbeam 上注册 外部 XC-20，并提供您需要在另一个链上注册 Moonbeam 资产的信息，包括 Moonbeam 原生资产（GLMR、MOVR 和 DEV）和本地 XC-20（支持 XCM 的 ERC-20）。</p> <p>本指南中的示例使用了一个 CLI 工具，该工具旨在简化整个过程，您可以在 xcm-tools GitHub 存储库 中找到它。</p> <p>bash git clone https://github.com/Moonsong-Labs/xcm-tools &amp;&amp; \\ cd xcm-tools &amp;&amp; \\ yarn</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#register-xc-20s", "title": "在 Moonbeam 上注册外部 XC-20", "text": "<p>在 Moonbeam 上注册外部 XC-20 是一个多步骤的过程，从高层次上讲，涉及到在 Moonbeam 社区论坛 上提出资产注册，并创建一个链上治理提案。</p> <p>如果 Moonbeam 和资产的原始链之间尚不存在通道，则需要打开一个通道。您可以将通道相关的调用与资产注册调用进行批处理，这样您只需要提交一个提案即可。您必须首先创建几个论坛帖子：一个 XCM 披露 帖子和一个 XCM 提案 帖子。</p> <p>在您收集到社区成员的反馈后，您可以创建一个提案来开通一个通道并注册任何资产。有关开通通道的更多信息，请参阅 与 Moonbeam 建立 XC 集成 指南。</p> <p></p> <p>如果链之间的通道已经存在，您需要创建一个论坛帖子来注册资产，收集反馈，然后提交提案来注册资产。</p> <p></p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#create-a-forum-post", "title": "创建论坛帖子", "text": "<p>要在 Moonbeam 社区论坛 上创建论坛帖子，您需要确保将帖子添加到正确的类别并添加相关内容。有关一般指南和要遵循的模板，请参阅Moonbeam 社区论坛 XCM 集成模板 页面。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#calculate-relative-price", "title": "计算相对价格", "text": "<p>资产的 <code>relativePrice</code> 指的是一个 <code>u128</code> 值，它表示该资产有多少个单位（以其最小面额表示）相当于一个单位（即 <code>1 × 10^18 Wei</code>）的本地代币（GLMR 或 MOVR）。这有助于确定在最初以本地代币报价的费用中使用多少您的资产，尤其是在跨链消息传递（XCM）中。</p> <p>您可以使用以下脚本（也可作为 xcm-tools 的一部分）来计算资产的正确 <code>relativePrice</code> 值。</p> 计算相对价格 <pre><code>import axios from 'axios';\n\n// CoinGecko IDs for the networks\nconst NETWORK_IDS = {\n  GLMR: 'moonbeam',\n  MOVR: 'moonriver',\n};\n\nasync function calculateRelativePrice(\n  assetPrice: number,\n  assetDecimals: number,\n  network: 'GLMR' | 'MOVR'\n): Promise&lt;bigint&gt; {\n  try {\n    // Fetch the native token price from CoinGecko\n    const response = await axios.get(\n      `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[network]}&amp;vs_currencies=usd`\n    );\n\n    const nativeTokenPrice = response.data[NETWORK_IDS[network]].usd;\n\n    // Calculate relative price with 18 decimal places\n    // Formula: (assetPrice / nativeTokenPrice) * 10^18\n    // This gives us how many units of the asset we need to equal 1 unit of native token\n    const relativePrice = BigInt(\n      0.175 *\n        Math.pow(10, 18 - assetDecimals) *\n        (assetPrice / nativeTokenPrice) *\n        Math.pow(10, 18)\n    );\n\n    // Return as string to preserve precision\n    return relativePrice;\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Failed to calculate relative price: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\nfunction validateInput(\n  price: string,\n  decimals: string,\n  network: string\n): { assetPrice: number; assetDecimals: number; network: 'GLMR' | 'MOVR' } {\n  // Validate price\n  const assetPrice = parseFloat(price);\n  if (isNaN(assetPrice) || assetPrice &lt;= 0) {\n    throw new Error('Price must be a positive number');\n  }\n\n  // Validate decimals\n  const assetDecimals = parseFloat(decimals);\n  if (isNaN(assetDecimals) || assetDecimals &lt;= 0) {\n    throw new Error('Decimals must be a positive number');\n  }\n\n  // Validate network\n  const upperNetwork = network.toUpperCase() as 'GLMR' | 'MOVR';\n  if (!['GLMR', 'MOVR'].includes(upperNetwork)) {\n    throw new Error('Network must be either GLMR or MOVR');\n  }\n\n  return { assetPrice, assetDecimals, network: upperNetwork };\n}\n\nfunction printUsage() {\n  console.log('\\nUsage:');\n  console.log(\n    'npx ts-node calculate-relative-price.ts &lt;price&gt; &lt;decimals&gt; &lt;network&gt;'\n  );\n  console.log('\\nExample:');\n  console.log('npx ts-node calculate-relative-price.ts 0.25 12 GLMR');\n  console.log('\\nParameters:');\n  console.log('price      - The price of your asset in USD');\n  console.log('decimals   - The decimals of your asset');\n  console.log('network    - Either GLMR or MOVR');\n}\n\nasync function main() {\n  try {\n    // Get command line arguments\n    const [, , price, decimals, network] = process.argv;\n\n    // Check if help flag is passed\n    if (price === '--help' || price === '-h') {\n      printUsage();\n      return;\n    }\n\n    // Check if required arguments are provided\n    if (!price || !decimals || !network) {\n      console.error('Error: Missing required arguments');\n      printUsage();\n      process.exit(1);\n    }\n\n    // Validate inputs\n    const {\n      assetPrice,\n      assetDecimals,\n      network: validNetwork,\n    } = validateInput(price, decimals, network);\n\n    console.log(\n      `\\nCalculating relative price for asset worth $${assetPrice} against ${validNetwork}...`\n    );\n    const relativePrice = await calculateRelativePrice(\n      assetPrice,\n      assetDecimals,\n      validNetwork\n    );\n    const nativeTokenPrice = (\n      await axios.get(\n        `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[validNetwork]}&amp;vs_currencies=usd`\n      )\n    ).data[NETWORK_IDS[validNetwork]].usd;\n\n    const decimalRatio = nativeTokenPrice / assetPrice;\n\n    console.log(`\\nResults:`);\n    console.log(`Asset Price: $${assetPrice}`);\n    console.log(`Network: ${validNetwork}`);\n    console.log(`Native Token Price (from CoinGecko): $${nativeTokenPrice}`);\n    console.log(`\\nRelative Price Analysis:`);\n    console.log(\n      `1 ${validNetwork} is equal to approximately ${decimalRatio.toFixed(\n        3\n      )} of your specified token.`\n    );\n    console.log(\n      `With 18 decimals, 1 ${validNetwork} or in WEI, 1000000000000000000 is equal to a relative price of ${relativePrice} units of your token`\n    );\n    console.log(`\\nRelative Price: ${relativePrice}`);\n    console.log(\n      `\\nThe relative price you should specify in asset registration steps is ${relativePrice}\\n`\n    );\n  } catch (error) {\n    console.error('\\nError:', error instanceof Error ? error.message : error);\n    process.exit(1);\n  }\n}\n\nmain();\n</code></pre> <p>计算资产的相对价格只需要三个参数：</p> <ul> <li>资产价格（美元） - 一个正数，表示您的资产的 1 个单位（以人类可读的形式）以美元计算的成本</li> <li>资产小数位数 - 您的资产使用的小数位数。例如，如果您的代币有 12 个小数位，请指定 12</li> <li>网络 - GLMR（Moonbeam）或 MOVR（Moonriver）。这应对应于您在其上注册资产的网络，并且这决定了脚本将从 CoinGecko 获取哪个本地代币的美元价格</li> </ul> <p>首先，通过运行以下命令确保您已安装所需的依赖项：</p> <pre><code>yarn\n</code></pre> <p>执行脚本，确保提供您要注册的资产的美元价格、它的小数位数以及您在其上注册资产的网络（GLMR 或 MOVR）：</p> <pre><code>yarn calculate-relative-price INSERT_ASSET_PRICE INSERT_DECIMALS GLMR\n</code></pre> <p>例如，如果您要注册的资产的美元价格为 0.25 美元，并且有 12 个小数位，并且您要在 Moonbeam 网络上注册该资产，您将运行：</p> <pre><code>yarn calculate-relative-price 0.25 12 GLMR\n</code></pre> <p>这指示脚本计算有多少最小单位的资产（价格为 0.25 美元，有 12 个小数位）对应于 1 个 GLMR 代币。</p> yarn calculate-relative-price 0.04901 12 GLMR Calculating relative price for asset worth $0.04901 against GLMR... Results: Asset Price: $0.04901 Network: GLMR Native Token Price (from CoinGecko): $0.126009 Relative Price Analysis: 1 GLMR is equal to approximately 2.571 of your specified token. With 18 decimals, 1 GLMR (in WEI: 1000000000000000000) is equal to 68064582688538114392064 units of your token. Relative Price: 68064582688538114392064 The relative price you should specify in asset registration steps is 68064582688538114392064 <p>成功执行后，脚本会将计算出的 <code>relativePrice</code> 打印为 <code>BigInt</code>。此值表示资产的美元价格与本地代币的美元价格之间的缩放比率，最高乘以 18 个小数位。然后，您可以在链上资产注册或费用计算场景中使用此结果，尤其是在需要 <code>u128</code> 18 位小数格式的情况下。</p> <p>有关更多信息、使用详情或查看实际示例，您可以通过运行以下命令来调用帮助命令：</p> <pre><code>yarn calculate-relative-price --help\n</code></pre> <p>{   \"source_path\": \"builders/interoperability/xcm/xc-registration/assets.md\",   \"source_language\": \"EN\",   \"target_language\": \"ZH\",   \"checksum\": \"4e965a49313743949f5662d64a26eaf924c1aa29dd2dd3451761a8074b578dcb\",   \"content\": \"### Generate the Encoded Calldata for the Asset Registration {: #generate-encoded-calldata-for-asset-registration }\\n\\nSubmitting a governance proposal on Moonbeam requires two steps: first, submit a preimage that defines the actions to be executed, then use that preimage to submit the proposal. For more details, see the Governance on Moonbeam page. To submit a preimage for asset registration, you'll need the encoded calldata for both the <code>evmForeignAssets.createForeignAsset</code> and <code>xcmWeightTrader.addAsset</code> extrinsics. An existing asset's price can be updated with <code>xcmWeightTrader.editAsset</code>. \\n\\nProposals must be submitted via the Fast General Admin track. A channel must be established before an asset can be registered. To get the encoded calldata for the <code>evmForeignAssets.createForeignAsset</code> extrinsic, you will need to provide the following arguments:\\n\\n- <code>assetId</code> - unique identifier of the asset, generated from the <code>calculate-external-asset-info.ts</code> script\\n- <code>xcmLocation</code> - the multilocation of the asset relative to Moonbeam \\n- <code>decimals</code> - the number of decimals of the asset\\n- <code>symbol</code>  - the symbol of the asset. Remember that \\\"xc\\\" should be prepended to the symbol to indicate the asset is an XCM-enabled asset\\n- <code>name</code> - the asset name\\n\\nUsing the above information, you can generate the encoded call data for the <code>createForeignAsset</code> call either via the Polkadot API or on Polkadot.js Apps.\\n\\nYou can generate this required calldata using the xcm-asset-registrator script as follows:\\n\\n```bash yarn register-asset --w wss://wss.api.moonbeam.network  \\\\n--asset \\\"INSERT_MULTILOCATION\\\" \\\\n--symbol \\\"INSERT_ASSET_SYMBOL\\\" \\\\n--decimals INSERT_DECIMALS \\\\n--name \\\"INSERT_ASSET_NAME\\\" \\\\n--relative-price INSERT_RELATIVE_PRICE</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#_2", "title": "构建添加资产调用", "text": "<p>如果您已经使用了上面显示的 xcm-asset-registrator 脚本，则可以跳过本节。本节将更详细地介绍如何构建 <code>xcmWeightTrader.addAsset</code> 调用。要获取 <code>xcmWeightTrader.addAsset</code> 外部函数的编码调用数据，您需要提供以下参数：</p> <ul> <li><code>xcmLocation</code> - 相对于 Moonbeam 的资产多重位置</li> <li><code>relativePrice</code> - 一个数值 (u128)，表示您的资产价格占原生代币价格的比例，缩放到 18 位小数。此值通过确定需要多少单位的非原生资产来支付 XCM 操作成本来计算跨链费用</li> </ul> <p>使用上述信息，您可以通过 Polkadot API 或 Polkadot.js Apps 生成 <code>addAsset</code> 调用的编码调用数据。</p> <p>要创建一个批处理事务，将 <code>xcmWeightTrader.addAsset</code> 和 <code>evmForeignAssets.createForeignAsset</code> 调用组合在一起，您可以使用 Polkadot API 的 <code>batch</code> 方法。如前所述，XCM 资产注册器脚本 可以帮助您构建和提交所需的调用。</p> <p>{   \"source_path\": \"builders/interoperability/xcm/xc-registration/assets.md\",   \"source_language\": \"EN\",   \"target_language\": \"ZH\",   \"checksum\": \"4e965a49313743949f5662d64a26eaf924c1aa29dd2dd3451761a8074b578dcb\",   \"content\": \"### Submit the Preimage and Proposal for Asset Registration {: #submit-preimage-proposal }\\n\\nYour next task is to submit the preimage of your batched call containing both the <code>xcmWeightTrader.addAsset</code> and the <code>evmForeignAssets.createForeignAsset</code> by following the guidelines in the Submit a Democracy Proposal Guide.\\n\\nYou do not need to go through governance for Moonbase Alpha, as Moonbase Alpha has sudo access. Instead, you can provide the output of the batch call data to the Moonbeam team, and they can submit the call with sudo. This will be a faster and easier process than going through governance. However, you may still wish to go through governance on Moonbase Alpha to prepare for Moonbeam's governance process.\\n\\nAfter submitting the preimage, you can submit the proposal by following the guidelines in the Submitting a Proposal section.\\n\\nIf you prefer the script method and you're comfortable working with the scripts in the XCM tools repo, you can use the generic call proposer by passing in the requisite calls, including the acceptance and proposal of the XCM Channel, and the asset registration. The generic call proposer can help you assemble the multiple requisite calls as follows:\\n\\n```bash yarn generic-call-propose \\\\n  --call INSERT_CALLDATA_INCOMING_XCM_CHANNEL \\\\n  --call INSERT_CALLDATA_OUTGOING_XCM_CHANNEL \\\\n  --call INSERT_CALLDATA_BATCH_ASSET_REGISTRATION \\\\n  --ws-provider INSERT_WSS_PROVIDER</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#test-asset-registration", "title": "在 Moonbeam 上测试资产注册", "text": "<p>在您的资产注册后，团队将提供资产 ID 和 XC-20 预编译地址。您的 XC-20 预编译地址通过将资产 ID 十进制数转换为十六进制，并在其前面加上 F，直到获得一个 40 个十六进制字符（加上“0x”）的地址来计算得出。有关如何计算的更多信息，请参阅外部 XC-20 指南的 计算外部 XC-20 预编译地址 部分。资产成功注册后，您可以将代币从您的平行链转移到您正在集成的基于 Moonbeam 的网络。</p> <p>Note</p> <p>请记住，基于 Moonbeam 的网络使用 AccountKey20（以太坊风格的地址）。</p> <p>为了进行测试，请提供您的平行链 WSS 端点，以便 Moonbeam dApp 可以连接到它。最后，请为相应的帐户提供资金：</p> <p>===</p> <pre><code>text\nAccountId: 5E6kHM4zFdH5KEJE3YEzX5QuqoETVKUQadeY8LVmeh2HyHGt\nHex:       0x5a071f642798f89d68b050384132eea7b65db483b00dbb05548d3ce472cfef48\n</code></pre> <p>===</p> <pre><code>text\nAccountId: 5E6kHM4zFdH5KEJE3YEzX5QuqoETVKUQadeY8LVmeh2HyHGt\nHex:       0x5a071f642798f89d68b050384132eea7b65db483b00dbb05548d3ce472cfef48\n</code></pre> <p>===</p> <pre><code>text\nAccountId: 5GWpSdqkkKGZmdKQ9nkSF7TmHp6JWt28BMGQNuG4MXtSvq3e\nHex:       0xc4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a063\n</code></pre> <p>Note</p> <p>对于 Moonbeam 和 Moonriver 测试，请向上述帐户发送价值 50 美元的代币。此外，请提供一个以太坊风格的帐户，用于发送价值 50 美元的 GLMR/MOVR 以进行测试。</p> <p>XC-20s 是具有 ERC-20 接口 的基于 Substrate 的资产。这意味着可以将它们添加到 MetaMask，并可以与生态系统中存在的任何 EVM DApp 组合使用。 团队可以将您与您认为与 XC-20 集成相关的任何 DApp 联系起来。</p> <p>如果您需要 DEV 代币（Moonbase Alpha 的本地代币）来使用您的 XC-20 资产，您可以从 Moonbase Alpha 水龙头 获得一些，该水龙头每 24 小时分配 1.1 DEV tokens 。如果您需要更多，请随时通过 Telegram 或 Discord 与团队联系。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#set-bytecode", "title": "设置 XC-20 预编译字节码", "text": "<p>一旦您的 XC-20 在 Moonbeam 上注册，您就可以设置 XC-20 的预编译字节码。这是必要的，因为预编译是在 Moonbeam 运行时内部实现的，并且默认情况下没有字节码。在 Solidity 中，当调用合约时，会有一些检查要求合约字节码不能为空。因此，将字节码设置为占位符可以绕过这些检查，并允许调用预编译。</p> <p>您可以使用 预编译注册表（它是一个 Solidity 接口）来更新 XC-20 预编译的字节码，以避免任何问题并确保可以从 Solidity 调用该预编译。为此，您将使用预编译注册表的 <code>updateAccountCode</code> 函数。</p> <p>要开始，您需要计算 XC-20 的预编译地址并拥有预编译注册表的 ABI。</p> 预编译注册表 ABI <pre><code>[\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isActivePrecompile\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isPrecompile\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"updateAccountCode\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    }\n]\n</code></pre> <p>然后，您可以使用以下脚本为您的 XC-20 预编译设置虚拟代码。</p> <p>Remember</p> <p>以下代码段仅用于演示目的。切勿将您的私钥存储在 JavaScript 或 Python 文件中。</p> <p>===</p> <pre><code>```js\nimport { ethers } from 'ethers'; // Import Ethers library\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst abi = 'INSERT_PRECOMPILE_REGISTRY_ABI';\nconst xc20Address = 'INSERT_XC_20_PRECOMPILE_ADDRESS';\nconst registryAddress = '0x0000000000000000000000000000000000000815';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n// Create interface for the Precompile Registry\nconst precompileRegistry = new ethers.Contract(registryAddress, abi, signer);\n\nconst updateAccountCode = async () =&gt; {\n  // Update the precompile bytecode\n  await precompileRegistry.updateAccountCode(xc20Address);\n\n  // Check the precompile bytecode\n  const bytecode = await provider.getCode(xc20Address);\n  console.log(`The XC-20 precompile's bytecode is: ${bytecode}`);\n};\n\nupdateAccountCode();\n\n```\n</code></pre> <p>===</p> <pre><code>```js\nimport { Web3 } from 'web3';\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst abi = 'INSERT_PRECOMPILE_REGISTRY_ABI';\nconst xc20Address = 'INSERT_XC_20_PRECOMPILE_ADDRESS';\nconst registryAddress = '0x0000000000000000000000000000000000000815';\n\n// Create provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\n// Create interface for the Precompile Registry\nconst precompileRegistry = new web3.eth.Contract(abi, registryAddress, {\n  from: web3.eth.accounts.privateKeyToAccount(privateKey).address,\n});\n\nconst updateAccountCode = async () =&gt; {\n  // Update the precompile bytecode\n  await precompileRegistry.methods.updateAccountCode(xc20Address).call();\n\n  // Check the precompile bytecode\n  const bytecode = await web3.eth.getCode(xc20Address);\n  console.log(`The XC-20 precompile's bytecode is: ${bytecode}`);\n};\n\nupdateAccountCode();\n\n```\n</code></pre> <p>===</p> <pre><code>```py\nfrom web3 import Web3\n\nprivate_key = \"INSERT_PRIVATE_KEY\"\nabi = \"INSERT_PRECOMPILE_REGISTRY_ABI\"  # Paste or import the Precompile Registry ABI\nxc20_address = \"INSERT_XC_20_PRECOMPILE_ADDRESS\"\nregistry_address = \"0x0000000000000000000000000000000000000815\"\n\n# Create provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create interface for the Precompile Registry\nprecompile_registry = web3.eth.contract(address=registry_address, abi=abi)\n\n\ndef update_account_code():\n    # Update the precompile bytecode\n    precompile_registry.functions.updateAccountCode(xc20_address).call()\n\n    # Check the precompile bytecode\n    bytecode = web3.eth.get_code(xc20_address)\n    print(\"The XC-20 precompile's bytecode is: \", web3.to_hex(bytecode))\n\n\nupdate_account_code()\n\n```\n</code></pre> <p>运行脚本以设置字节码后，您应该在终端上看到 <code>The XC-20 precompile's bytecode is: 0x60006000fd</code>。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#register-moonbeam-assets-on-another-chain", "title": "在另一条链上注册 Moonbeam 资产", "text": "<p>为了实现 Moonbeam 资产（包括 Moonbeam 原生资产 (GLMR、MOVR、DEV) 和部署在 Moonbeam 上的本地 XC-20 (支持 XCM 的 ERC-20)）在 Moonbeam 和另一条链之间的跨链转移，您需要在另一条链上注册这些资产。由于每条链存储跨链资产的方式不同，因此在另一条链上注册 Moonbeam 资产的具体步骤会因链而异。至少，您需要知道 Moonbeam 上资产的元数据和多重位置。</p> <p>除了资产注册之外，还需要采取其他步骤才能实现与 Moonbeam 的跨链集成。有关更多信息，请参阅与 Moonbeam 建立 XC 集成 指南。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#register-moonbeam-native-assets", "title": "在另一条链上注册 Moonbeam 原生资产", "text": "<p>每个网络的元数据如下：</p> MoonbeamMoonriverMoonbase Alpha 变量 值 名称 Glimmer 符号 GLMR 小数位 18 存在性存款 1 (1 * 10^-18 GLMR) 变量 值 名称 Moonriver 符号 MOVR 小数位 18 存在性存款 1 (1 * 10^-18 MOVR) 变量 值 名称 DEV 符号 DEV 小数位 18 存在性存款 1 (1 * 10^-18 DEV) <p>Moonbeam 原生资产的多重定位包括 Moonbeam 网络的平行链 ID 和 Moonbeam 资产所在的 pallet 实例，它对应于 Balances Pallet 的索引。每个网络的多重定位如下：</p> MoonbeamMoonriverMoonbase Alpha <p>js {   V4: {     parents: 1,     interior: {       X2: [         {           Parachain: 2004         },         {           PalletInstance: 10         }       ]     }   } }</p> <p>js {   V4: {     parents: 1,     interior: {       X2: [         {           Parachain: 2023         },         {           PalletInstance: 10         }       ]     }   } }</p> <p>js {   V4: {     parents: 1,     interior: {       X2: [         {           Parachain: 1000         },         {           PalletInstance: 3         }       ]     }   } }</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#register-local-xc20", "title": "在另一个链上注册本地 XC-20", "text": "<p>本地 XC-20 的多重定位包括 Moonbeam 的平行链 ID、pallet 实例和 ERC-20 的地址。pallet 实例对应于 ERC-20 XCM 桥接 Pallet 的索引，因为这是允许通过 XCM 传输任何 ERC-20 的 pallet。</p> <p>要在其他链上注册，本地 XC-20 必须严格遵守 EIP-20 中描述的标准 ERC-20 接口。特别是，<code>transfer</code> 函数 必须如 EIP-20 中所述：</p> <pre><code>function transfer(address _to, uint256 _value) public returns (bool success)\n</code></pre> <p>如果 <code>transfer</code> 函数的函数选择器偏离标准，则跨链传输将失败。</p> <p>您可以使用以下多重定位来注册本地 XC-20：</p> <p>===</p> <pre><code>```js\n{\n  parents: 1,\n  interior: {\n    X3: [\n      {\n        Parachain: 2004\n      },\n      {\n        PalletInstance: 110\n      },\n      {\n        AccountKey20: {\n          key: 'INSERT_ERC20_ADDRESS'\n        }\n      }\n    ]\n  }\n}\n```\n</code></pre> <p>===</p> <pre><code>```js\n{\n  parents: 1,\n  interior: {\n    X3: [\n      {\n        Parachain: 2023\n      },\n      {\n        PalletInstance: 110\n      },\n      {\n        AccountKey20: {\n          key: 'INSERT_ERC20_ADDRESS'\n        }\n      }\n    ]\n  }\n}\n```\n</code></pre> <p>===</p> <pre><code>```js\n{\n  parents: 1,\n  interior: {\n    X3: [\n      {\n        Parachain: 1000\n      },\n      {\n        PalletInstance: 48\n      },\n      {\n        AccountKey20: {\n          key: 'INSERT_ERC20_ADDRESS'\n        }\n      }\n    ]\n  }\n}\n```\n</code></pre> <p>由于本地 XC-20 是 Moonbeam 上的 ERC-20，因此在 Moonbeam 上创建 ERC-20 不需要任何存款。 但是，可能需要存款才能在另一个平行链上注册资产。 请咨询您希望注册资产的平行链团队以获取更多信息。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#xc", "title": "管理 XC 资产", "text": "<p>在完成 XC 资产的注册过程后，您可能需要定期更新资产详细信息，例如 XCM 多位置详细信息或资产价格。本节将介绍这些主题。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#updating-foreign-asset-xcm-location", "title": "更新外部资产 XCM 位置", "text": "<p>您可以使用 <code>evmForeignAssets.changeXcmLocation</code> 调用来更新资产的多重位置，该调用使用 <code>assetId</code> 和新的多重位置作为参数。您需要发起一个治理提案，并在通用管理轨道下提交更新。如果您在 Moonbase Alpha 中进行测试，您可以要求 Moonbeam 团队使用 Sudo 提交外部函数调用以加快流程。您也可以在 Moonbase Alpha 上提交必要的治理提案。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#freezing-a--foreign-asset", "title": "冻结外部资产", "text": "<p>您可以通过调用 <code>evmForeignAssets.freezeForeignAsset</code> 来冻结外部资产，该方法接收 <code>assetId</code> 和一个 <code>allowXcmDeposit</code> 布尔值作为参数。如果设置为 true，则仍然允许来自远程链的 XCM 存款并铸造代币。如果设置为 false，则来自远程链的 XCM 存款将失败，因为不允许铸造。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/assets/#paying-xcm-fees-with-foreign-assets", "title": "使用外部资产支付 XCM 费用", "text": "<p>在您通过 <code>evmForeignAssets</code> 和 <code>xcmWeightTrader</code> pallet 注册外部资产后，您的资产现在将成为支付 XCM 费用的受支持资产之一。要验证，您可以查询 <code>xcmWeightTrader</code> pallet 和 <code>supportedAssets</code> 链状态查询。关闭包含选项滑块以查看完整列表，或者您可以按资产的多重位置筛选列表。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/forum-templates/", "title": "Moonbeam 社区论坛 XCM 集成模板", "text": ""}, {"location": "builders/interoperability/xcm/xc-registration/forum-templates/#introduction", "title": "简介", "text": "<p>当在 Moonriver 或 Moonbeam MainNet 上启动 XCM 集成时，必须在 Moonbeam 社区论坛 上发布两个初步帖子，以便投票社区有机会提供反馈。这两个初步帖子是 XCM 披露和 XCM 提案。连接到 Moonbase Alpha 时，此步骤不是必需的。</p> <p>如果仅注册资产，则必须已经建立跨链通道，因此仅需要 XCM 提案帖子即可注册资产。</p> <p>建议在链上提交实际提案前五天完成此操作，以便为社区反馈提供时间。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/forum-templates/#xcm-disclosure", "title": "XCM披露", "text": "<p>应该发布的第一个帖子是XCM披露类别中的关键披露，其中突出显示了对投票者决策至关重要的关键信息。此帖子仅在建立XCM集成时才需要；如果集成已存在且您只需要注册资产，则不需要此帖子。</p> <p>点击新主题按钮后，将提供一个模板，其中包含要填写的相关信息。请使用Moonbeam/Moonriver标签，具体取决于您要集成的网络。</p> <p>在帖子中，请提供以下信息：</p> <ul> <li>标题 - XCM披露：您的网络名称</li> <li>网络信息 - 一句话总结您的网络以及指向您网站、Twitter和其他社交渠道的相关链接</li> </ul> <p>您还需要提供以下问题的答案：</p> <ul> <li>区块链网络的代码是否为开源？如果是，请提供GitHub链接。如果不是，请解释原因</li> <li>网络的SUDO是否已禁用？如果SUDO已禁用，网络是否由一组选定的地址控制？</li> <li>网络的集成是否已在Moonbase Alpha TestNet上完全测试过？</li> <li>(仅适用于Moonbeam HRMP提案) 您的网络是否有Kusama部署？如果是，请提供其网络名称以及Kusama部署是否与Moonriver集成</li> <li>区块链网络的代码是否经过审计？如果是，请提供：</li> <li>审计员姓名</li> <li>审计报告的日期</li> <li>审计报告的链接</li> </ul>"}, {"location": "builders/interoperability/xcm/xc-registration/forum-templates/#xcm-proposals", "title": "XCM 提案", "text": "<p>第二篇文章是XCM 提案类别中提案的初步草案。一旦提案在链上提交并可供投票，您还必须在 Moonbeam Polkassembly 或 Moonriver Polkassembly 中添加对其的描述。</p> <p>点击“新主题”按钮后，将提供一个模板，其中包含要填写的相关信息。请使用 Moonbeam 或 Moonriver 标签，具体取决于您要集成的网络。</p> <p>在 Moonbeam XCM 提案论坛帖子和 Polkassembly 中，添加以下部分和信息：</p> <ul> <li>标题——YOUR_NETWORK_NAME 提案以打开通道并注册 ASSET_NAME。如果您仅注册资产，则可以使用：YOUR_NETWORK_NAME 提案以注册 ASSET_NAME</li> <li>简介——一句话总结提案</li> <li>网络信息——一句话总结您的网络以及指向您网站、Twitter 和其他社交渠道的相关链接</li> <li>摘要——提案内容的简要说明</li> <li>链上提案参考——如果它是 Moonbeam 或 Moonriver 提案，则包括提案编号和提案哈希</li> <li>技术细节——提供社区理解提案用例和目的所需的技术信息</li> <li>附加信息——您希望社区了解的任何附加信息</li> </ul>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/", "title": "兄弟平行链的自助资产注册", "text": ""}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#introduction", "title": "简介", "text": "<p>在 Moonbeam 或 Moonriver 上注册您的平行链原生代币，可以让您的社区享受 ERC‑20 风格的用户体验和深入的 EVM 集成，同时保留完整的链上溯源。本指南向兄弟 Polkadot 平行链团队展示了如何使用 Moonbeam Runtime 3600 中引入的新的 <code>ForeignAssetOwnerOrigin</code> 自行注册外来资产。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#origin-why-a-new-origin", "title": "为什么需要新的 Origin？{: #why-a-new-origin }", "text": "<p>Moonbeam 引入了一个新的专用 Origin，名为 <code>ForeignAssetOwnerOrigin</code>，它只允许 Origin 包含资产多重定位的 XCM 消息在 <code>evm‑foreign‑assets</code> pallet 中执行调用。实际上，这意味着只有拥有该资产的平行链的主权账户或 Moonbeam 治理机构才能创建、冻结、解冻或重新定位它。与此同时，一个可配置的运行时常量 <code>ForeignAssetCreationDeposit</code> 会在创建时从调用者的主权账户中预留。该保证金旨在阻止垃圾注册。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#required-deposits", "title": "必需的存款", "text": "<p>为了防止垃圾邮件，需要 <code>ForeignAssetCreationDeposit</code> 并在资产的整个生命周期内锁定。存款从 Moonbeam 网络上的兄弟平行链的主权账户中获得资金，因此需要有足够的资金来支付资产存款和相关的交易费用。如果资产通过治理销毁，则存款将被解除保留并返回到原始主权账户。</p> <p>存款是特定于网络的，可以通过 Moonbeam 治理通过 <code>parameters</code> pallet 进行调整：</p> <p>===</p> <pre><code>|    Variable    |                       Value                       |\n|:--------------:|:-------------------------------------------------:|\n| Foreign Asset Deposit | 10,000 GLMR |\n</code></pre> <p>===</p> <pre><code>|    Variable    |                       Value                       |\n|:--------------:|:-------------------------------------------------:|\n| Foreign Asset Deposit | 1,000 MOVR |\n</code></pre> <p>===</p> <pre><code>|    Variable    |                       Value                       |\n|:--------------:|:-------------------------------------------------:|\n| Foreign Asset Deposit | 100 DEV |\n</code></pre>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#prerequisites", "title": "必备条件", "text": "<p>需要注意以下几个必备条件：</p> <ul> <li>Moonbeam上的兄弟平行链的主权账户必须有足够的资金来支付资产存款和交易费用。建议您预留额外的资金缓冲，以备后续交易之需。请参阅此主权账户计算指南</li> <li>您的平行链应支持 XCM V4</li> <li>您的平行链需要与 Moonbeam 建立双向 XCM 通道。请参阅此关于打开与 Moonbeam 之间的 XCM 通道的信息指南</li> </ul>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#assemble-your-asset-details", "title": "收集您的资产详细信息", "text": "<p>在 Moonbeam 上注册您的兄弟平行链代币之前，您需要收集四个信息：</p> <ul> <li><code>AssetID</code>: 从代币的 <code>multilocation</code> 派生的确定性 <code>u128</code>（见下文）。</li> <li><code>Decimals</code>: 代币使用的小数位数（例如，<code>18</code>）。</li> <li><code>Symbol</code>: 一个简短的交易代码，例如 <code>xcTEST</code>。该交易代码应以 <code>xc</code> 作为前缀。</li> <li><code>Name</code>: 一个人类可读的名称，例如 <code>Test Token</code>。</li> </ul> <pre><code>const ASSET_ID = 42259045809535163221576417993425387648n;\nconst DECIMALS = 18n;\nconst SYMBOL   = \"xcTEST\";\nconst NAME     = \"Test Token\";\n</code></pre>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#calculate-asset-id", "title": "如何计算资产 ID", "text": "<p>要生成代币的资产 ID，首先需要知道它的多重定位。<code>assetLocation</code> 是一个 SCALE 编码的多重定位，用于精确定位您的兄弟链上现有的代币。定义资产的方法有很多种，您的多重定位可能包括平行链 ID、管理资产的 pallet 以及本地资产索引。由于 extrinsic 在 Moonbeam 上执行，因此您需要从 Moonbeam 的角度描述路径：首先向上跳一级到 Relay <code>(\"parents\": 1)</code>，然后向下进入您的平行链 <code>(Parachain: &lt;paraId&gt;)</code>、pallet 和资产索引。Moonbeam 使用它来验证调用者是否真的“包含”该资产，然后才允许任何注册或更新。</p> <p>构造好您的多重定位后，请随手保存，因为下一步会用到它。典型的资产多重定位如下所示：</p> <p>XCM 工具仓库中有一个有用的计算外部资产信息脚本，您可以使用该脚本以编程方式生成资产 ID。该脚本接受两个参数，即资产的多重定位和目标网络（Moonbeam 或 Moonriver）。使用您资产的多重定位和目标网络调用 <code>calculate-external-asset-info.ts</code> 助手脚本，如下所示，以轻松生成其资产 ID。</p> <pre><code>ts-node scripts/calculate-external-asset-info.ts \\\n  --asset '{\"parents\":1,\"interior\":{\"X3\":[{\"Parachain\":4},{\"PalletInstance\":12},{\"GeneralIndex\":15}]}}' \\\n  --network moonbeam\n</code></pre> <p>该脚本将返回 <code>assetID</code>，您现在可以将其传递给 <code>evmForeignAssets.createForeignAsset</code>。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#xc-20", "title": "推导 XC-20 地址", "text": "<p>将 <code>assetID</code> 转换为十六进制，在左侧填充到 32 个十六进制字符，并在前面加上八个 <code>F</code>，如下所示：</p> <p>text xc20Address = 0xFFFFFFFF + hex(assetId).padStart(32, '0')</p> <p>xcDOT 的 XC-20 地址示例可以这样计算：</p> <p>===</p> <p>公式</p> <p>ts const xc20Address = <code>0xFFFFFFFF${hex(assetId).padStart(32, \"0\")}</code>;</p> <p>=== 示例</p> <p>bash 0xFFFFFFFF1FCACBD218EDC0EBA20FC2308C778080</p>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#generate-the-encoded-call-data", "title": "生成编码的调用数据", "text": "<p>以下代码片段展示了如何构建需要发送到 Moonbeam 的调用，该调用会创建外部资产。保存生成的十六进制字符串，因为您会将其嵌入到从您的兄弟平行链分派的后续 XCM <code>Transact</code> 调用中。</p> <p>ts import '@moonbeam-network/api-augment'; import { ApiPromise, WsProvider } from '@polkadot/api'; import { blake2AsHex } from '@polkadot/util-crypto';</p> <p>const moonbeam = await ApiPromise.create({   provider: new WsProvider(MOONBEAM_WSS), });</p> <p>const tx = moonbeam.tx.evmForeignAssets.createForeignAsset(   ASSET_ID,   assetLocation,   DECIMALS,   SYMBOL,   NAME );</p> <p>// SCALE-encoded call data (includes call index 0x3800) const encodedCall = tx.method.toHex(); console.log('Encoded call data:', encodedCall);</p> <p>// Optional: 32-byte call hash (blake2_256) console.log('Call hash:', blake2AsHex(encodedCall));</p>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#dispatch-the-call-with-xcm-transact", "title": "使用 XCM Transact 调度调用", "text": "<p>要注册您的资产，请将 SCALE 编码的 <code>createForeignAsset</code> 字节包装在从您的平行链的主权账户执行的单个 <code>Transact</code> 指令中。调用的基本结构如下所示：</p> <p>text Transact {   originKind: SovereignAccount,   requireWeightAtMost: ,   call:  } <p>通过 <code>xcmPallet.send</code> 发送 transact 指令，目标平行链对于 Moonbeam 为 <code>2004</code>（对于 Moonriver 为 <code>2023</code>）。</p> <p>rust xcmPallet.send(   dest: { Parachain: 2004 },   message: VersionedXcm::V4(INSERT_TRANSACT_INSTRUCTION) );</p> <p>最后，在 Moonbeam 上查找以下成功发出的事件：</p> <p>text EvmForeignAssets.ForeignAssetCreated(assetId, location, creator)</p> <p>它的存在确认了 XC-20 资产已启动。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#managing-an-existing-foreign-asset", "title": "管理现有外部资产", "text": "<p>创建外部资产后，可以使用以下外部函数对其进行更新。请注意，如果主权帐户发送调用，则主权帐户和位置仍必须位于来源内部。否则，唯一其他授权来源是来自 Moonbeam 治理行动的 <code>Root</code>。</p> Extrinsic 谁可以调用？ 注释 <code>changeXcmLocation</code> 兄弟主权帐户或 Moonbeam 治理 需要已预留的存款。 <code>freezeForeignAsset</code> / <code>unfreezeForeignAsset</code> 兄弟主权帐户或 Moonbeam 治理 <code>freeze</code> 可以选择销毁资产的元数据。"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#faqs", "title": "常见问题", "text": ""}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#_2", "title": "如何取回保证金？", "text": "<p>保证金会在资产的整个生命周期内保持预留状态。如果资产通过治理被销毁，保证金将被解除预留并返还给原始主权帐户。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#eoa", "title": "普通的 EOA 可以注册资产吗？", "text": "<p>不可以。来自非主权、非治理账户的调用会因 <code>BadOrigin</code> 而失败。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#xcm", "title": "如果我的 XCM 位置超出我的原始位置会发生什么？", "text": "<p>该调用将被 <code>LocationOutsideOfOrigin</code> 拒绝。请仔细检查 <code>Parachain</code>、<code>PalletInstance</code> 和 <code>GeneralIndex</code> 字段。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#_3", "title": "可以创建的资产数量是否有限制？", "text": "<p>是的，每个网络（例如，Moonbeam、Moonriver）的外部资产数量限制为 <code>256</code> 个。超出此限制的尝试将返回 <code>TooManyForeignAssets</code>。如果接近此阈值，则可以在将来的运行时升级中进行修订以解除此限制。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/xc-integration/", "title": "如何建立与 Moonbeam 的 XC 集成", "text": "<p>{   \"source_path\": \"builders/interoperability/xcm/xc-registration/xc-integration.md\",   \"source_language\": \"EN\",   \"target_language\": \"ZH\",   \"checksum\": \"7fab55ff0a91aa059948372297f7196958e02f2f0deca8df1d85f1cdb918dab8\",   \"content\": \"## Introduction {: #introduction }\\n\\nWhile Cross-Chain Message Passing (XCMP) is being developed, a stop-gap protocol has been implemented called Horizontal Relay-routed Message Passing (HRMP). It has the same interface and functionality as XCMP, but the messages are stored in and read from the relay chain. Whereas with XCMP, only the message's associated metadata is stored in the relay chain. Since all messages are passed via the relay chain with HRMP, it is much more demanding on resources. As such, HRMP will be phased out once XCMP is implemented.\\n\\nAll XCMP channel integrations with Moonbeam are unidirectional, meaning messages flow only in one direction. If chain A initiates a channel to chain B, chain A will only be allowed to send messages to B, and B will not be able to send messages back to chain A. As such, chain B will also need to initiate a channel with chain A to send messages back and forth between the two chains.\\n\\nOnce the XCMP (or HRMP) channels have been opened, the corresponding assets from both chains will need to be registered on the opposing chain before being able to be transferred. To find step-by-step details on how to register an asset, you can refer to the How to Register Cross-Chain Assets guide.\\n\\nThis guide will cover the process of opening and accepting an HRMP channel between a parachain and a Moonbeam-based network. In addition, the guide provides the necessary steps to create a batch proposal that combines opening and accepting a channel and registering an asset on Moonbeam into a single proposal.\\n\\nAll of the examples in this guide use a CLI tool developed to ease the entire process, which you can find in the xcm-tools GitHub repository.\\n\\n```bash git clone https://github.com/Moonsong-Labs/xcm-tools &amp;&amp; \\ cd xcm-tools &amp;&amp; \\ yarn</p>"}, {"location": "builders/interoperability/xcm/xc-registration/xc-integration/#moonbase-alpha-xcm", "title": "Moonbase Alpha XCM 集成概述", "text": "<p>Moonriver/Moonbeam XCM 集成的第一步是通过 Alphanet 中继链与 Moonbase Alpha TestNet 集成。然后在进行 Moonbeam 之前，必须完成 Moonriver 集成（如果适用）。</p> <p>开始使用 Moonbase Alpha 的整个过程可以概括如下：</p> <ol> <li>使用 Alphanet 中继链同步节点</li> <li>在 Alphanet 中继链上计算您的平行链主权账户</li> <li>一旦您的节点完全同步，请通过 Telegram 或 Discord 与 Moonbeam 团队联系，以便该团队可以将您的平行链加入到中继链上。提供以下信息以进行加入：</li> <li>WASM/Genesis head hash</li> <li>您的平行链 ID</li> <li>您的主权账户地址。Moonbeam 团队将在中继链级别为您的主权账户提供资金。此步骤是创建 HRMP 通道所必需的</li> <li>编码的调用数据，用于打开到您的平行链的 HRMP 通道，接受传入的 HRMP 通道，以及注册资产（如果适用）。这将通过 sudo 执行</li> <li>从您的平行链打开到 Moonbase Alpha 的 HRMP 通道（通过 sudo 或通过治理）</li> <li>接受来自 Moonbase Alpha 的 HRMP 通道（通过 sudo 或通过治理）</li> <li>（可选）在您的平行链上注册 Moonbase Alpha 的 DEV 令牌</li> <li>为了测试 XCM 集成，请发送一些令牌到：</li> </ol> <pre><code>AccountId (Encoded): 5GWpSdqkkKGZmdKQ9nkSF7TmHp6JWt28BMGQNuG4MXtSvq3e\nDecoded (32-Bytes):  0xc4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a063\n</code></pre> <ol> <li>测试 XCM 集成</li> </ol> <p></p> <p>一旦所有这些步骤都完成，并且两个团队都成功测试了资产转移，您的平行链令牌就可以添加到 Moonbeam DApp 的跨链资产部分。如果存款和取款按预期工作，则可以开始与 Moonriver 集成。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/xc-integration/#sync-a-node", "title": "同步节点", "text": "<p>要同步节点，您可以使用 Alphanet 中继链规范（注意：中继链是基于 Westend 的，可能需要一天时间才能同步）。</p> <p>作为参考，您可以使用 Moonbase Alpha 的规范文件。您需要将其适配到您的链。</p> <p>还有一些 Alphanet 生态系统中继链的快照，您可以使用它们快速入门，这些快照由社区提供。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/xc-integration/#calculate-and-fund-the-parachain-sovereign-account", "title": "计算和资助平行链主权账户", "text": "<p>您可以使用xcm-tools 存储库中的脚本计算主权账户信息。要运行该脚本，您必须提供平行链 ID 和关联的中继链的名称。</p> <p>您可以在中继链的 Polkadot.js Apps 页面上找到已使用的平行链 ID。</p> <p>中继链的可接受值包括 <code>polkadot</code>（默认）、<code>kusama</code> 和 <code>moonbase</code>。</p> <p>例如，可以使用以下方法获取 Moonbase Alpha 的中继链和其他平行链的主权账户：</p> <pre><code>yarn calculate-sovereign-account --p 1000 --r moonbase\n</code></pre> <p>这应该会产生以下响应：</p> <pre><code>Sovereign Account Address on Relay: 0x70617261e8030000000000000000000000000000000000000000000000000000\nSovereign Account Address on other Parachains (Generic): 0x7369626ce8030000000000000000000000000000000000000000000000000000\nSovereign Account Address on Moonbase Alpha: 0x7369626ce8030000000000000000000000000000\n</code></pre>"}, {"location": "builders/interoperability/xcm/xc-registration/xc-integration/#moonriver-moonbeam", "title": "Moonriver 和 Moonbeam XCM 集成概述", "text": "<p>从技术角度来看，创建与 Moonriver 和 Moonbeam 的 HRMP 通道的过程几乎相同。但是，与 Moonbeam 社区的互动至关重要，并且是提案获得通过的必要条件。</p> <p>在开始之前，请查看社区投票通过的 Moonriver 和 Moonbeam 的 HRMP 通道指南。</p> <p>该过程可以总结为以下步骤：</p> <ol> <li>从您的链打开（或确保存在）到 Moonriver/Moonbeam 的 HRMP 通道。可以选择注册 MOVR/GLMR</li> <li>创建 两个 Moonbeam 社区论坛帖子，其中包含 XCM 集成的一些关键信息：</li> <li>一个 XCM 披露帖子，您将在其中提供有关项目、代码库和社交网络渠道的一些披露信息</li> <li>一个 XCM 提案帖子，您将在其中提供有关提案本身的一些技术信息</li> <li> <p>在 Moonbeam/Moonriver 上创建一个批量提案，以：</p> </li> <li> <p>接受传入的 HRMP 通道</p> </li> <li>建议打开从 Moonriver/Moonbeam 发出的传出 HRMP 通道</li> <li>将资产注册为 XC-20 代币（如果适用）</li> </ol> <p>提案应在 OpenGov 的 General Admin Track 中完成。正常的颁布时间如下：</p> <ul> <li>Moonriver - 决策期约为 14 days，颁布时间至少为 1 day</li> <li> <p>Moonbeam - 决策期约为 14 days，颁布时间至少为 1 day</p> </li> <li> <p>在连接的平行链上接受来自 Moonriver/Moonbeam 的 HRMP 通道</p> </li> <li>交换价值 50 美元的代币以测试 XCM 集成。请将代币发送至：</li> </ul> <pre><code>AccountId (Encoded): 5E6kHM4zFdH5KEJE3YEzX5QuqoETVKUQadeY8LVmeh2HyHGt\nDecoded (32-Bytes):  0x5a071f642798f89d68b050384132eea7b65db483b00dbb05548d3ce472cfef48\n</code></pre> <ol> <li>提供 MOVR/GLMR 的以太坊风格地址</li> <li>使用提供的代币测试 XCM 集成</li> </ol> <p>下图描述了在 Moonbeam 上成功提案的此过程的示例。</p> <p></p> <p>成功完成这些步骤后，可以协调营销工作，并且可以将 Moonriver/Moonbeam 上的新 XC-20 添加到 Moonbeam DApp 的 Cross Chain Assets 部分。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/xc-integration/#create-forum-posts", "title": "创建论坛帖子", "text": "<p>要在 Moonbeam 社区论坛 上创建论坛帖子，您需要确保将帖子添加到正确的类别并添加相关内容。 有关要遵循的通用指南和模板，请参阅 Moonbeam 社区论坛 XCM 集成模板 页面。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/xc-integration/#create-an-hrmp-channel", "title": "创建 HRMP 通道", "text": "<p>在可以将任何消息从您的平行链发送到 Moonbeam 之前，必须先打开一个 HRMP 通道。要创建 HRMP 通道，您需要向中继链发送一条 XCM 消息，该消息将请求通过中继链打开通道。该消息需要包含至少以下 XCM 指令：</p> <ol> <li>WithdrawAsset - 从原始平行链的 Sovereign 账户（在中继链中）取出资金到一个持有状态</li> <li>BuyExecution - 从中继链购买执行时间以执行 XCM 消息</li> <li>Transact - 提供要执行的中继链调用数据。在这种情况下，调用将是 HRMP extrinsic</li> </ol> <p>Note</p> <p>您可以添加 DepositAsset 以在执行后退还剩余资金。如果未提供此选项，则不会进行退款。此外，您还可以在 Transact 之后添加 RefundSurplus 以获取未用于 Transact 的任何剩余资金。但是您必须计算支付额外 XCM 指令的执行成本是否值得。</p> <p>要将这些 XCM 消息发送到中继链，通常会调用 Polkadot XCM Pallet。Moonbeam 还有一个 XCM Transactor Pallet，它将该过程简化为抽象 XCM 消息构造器的调用。</p> <p>您可能会使用 Polkadot.js Apps 为 HRMP 操作生成 calldata，但 xcm-tools GitHub 存储库 可以为您构建它，并且是此过程的推荐工具。</p> <pre><code>git clone https://github.com/Moonsong-Labs/xcm-tools &amp;&amp; \\\ncd xcm-tools &amp;&amp; \\\nyarn\n</code></pre> <p>xcm-tools 存储库有一个用于 HRMP 交互的特定脚本，称为 <code>hrmp-channel-manipulator.ts</code>。此命令为特定的 HRMP 操作生成编码的 calldata，前提是它具有正确的详细信息。该脚本使用 DepositAsset XCM 指令构建 XCM 消息，但不使用 RefundSurplus。</p> <p>编码的 calldata 然后用于提交将执行 HRMP 操作的治理提案。所有与 HRMP 相关的提案都应分配给 General Admin Track。</p> <p><code>hrmp-channel-manipulator.ts</code> 脚本旨在是通用的。它应该适用于包含 Polkadot XCM Pallet 的任何链，尽管它会尝试首先使用 XCM Transactor Pallet 的 <code>hrmpManage</code> extrinsic。如果链上不存在 XCM Transactor Pallet，将使用 Polkadot XCM Pallet 的 <code>send</code> extrinsic。请注意，它期望 pallet 名称为 <code>polkadotXcm</code>，因为 extrinsic 将构建为 <code>api.tx.polkadotXcm.send()</code>。对于 Moonbeam，General Admin Track 无法执行 <code>polkadotXcm.send</code> 调用，因此必须使用 <code>xcmTransactor.hrmpManage</code> extrinsic。</p> <p>以下各节将介绍在基于 Moonbeam 的网络中创建和接受打开通道请求的步骤，但它们也可以适用于您的平行链。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/xc-integration/#accept-an-hrmp-channel-on-moonbeam", "title": "在 Moonbeam 上接受 HRMP 通道", "text": "<p>当平行链收到来自另一个平行链的传入 HRMP 通道打开请求时，它必须向中继链发出信号，表明它接受此通道，然后才能使用该通道。这需要一个 XCM 消息发送到中继链，其中包含调用 HRMP Pallet 和 <code>hrmpAcceptOpenChannel</code> extrinsic 的 Transact 指令。</p> <p>幸运的是，xcm-tools GitHub 仓库的 <code>hrmp-channel-manipulator.ts</code> 脚本可以为您构建 XCM！</p> <p>To use the script, you'll need to provide the following required arguments:</p> <ul> <li><code>--parachain-ws-provider</code> or <code>--w</code> - specifies the parachain WebSocket provider that will be issuing the requests</li> <li><code>--relay-ws-provider</code> or <code>--wr</code> - specifies the relay chain WebSocket provider that will be issuing the requests</li> <li><code>--hrmp-action</code> or <code>--hrmp</code> - accepts the following action to take, which can be any of the following: <code>accept</code>, <code>cancel</code>, <code>close</code>, and <code>open</code></li> <li><code>--target-para-id</code> or <code>-p</code> - the target parachain ID for the requests</li> </ul> <p>运行以下命令将提供编码后的 calldata，以接受 Moonbeam 网络上的打开 HRMP 通道请求。将 <code>YOUR_PARACHAIN_ID</code> 替换为您平行链的 ID：</p> <p>===</p> <pre><code>```bash\n</code></pre> <p>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\     --parachain-ws-provider wss://wss.api.moonbeam.network  \\     --relay-ws-provider wss://rpc.polkadot.io \\     --hrmp-action accept     ```</p> <p>===</p> <pre><code>```bash\n</code></pre> <p>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\     --parachain-ws-provider wss://wss.api.moonriver.moonbeam.network  \\     --relay-ws-provider wss://kusama-rpc.polkadot.io \\     --hrmp-action accept     ```</p> <p>===</p> <pre><code>```bash\n</code></pre> <p>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\     --parachain-ws-provider wss://wss.api.moonbase.moonbeam.network  \\     --relay-ws-provider wss://relay.api.moonbase.moonbeam.network \\     --hrmp-action accept     ```</p> <p>Note</p> <p>您可以通过更改 <code>parachain-ws-provider</code> 来使脚本适应您的平行链。</p> <p>运行脚本后，您将看到如下所示的输出：</p> yarn hrmp-manipulator --target-para-id 3370 \\ --parachain-ws-provider wss://moonbeam.public.blastapi.io  \\ --relay-ws-provider wss://polkadot-rpc.publicnode.com \\ --hrmp-action accept yarn run v1.22.22 warning ../../../package.json: No license field $ ts-node 'scripts/hrmp-channel-manipulator.ts' --target-para-id 3370 --parachain-ws-provider wss://moonbeam.public.blastapi.io --relay-ws-provider wss://polkadot-rpc.publicnode.com --hrmp-action accept Genesis hash is: 0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3 Polkadot FeeAmount is: 10000000000 XCM Version is V4 Encoded Call Data for Tx is 0x6b09012a0d0000010401000100e40b5402000000000000000000000002286bee020004000100 ✨  Done in 4.39s. <p>如上所示运行脚本将返回编码后的 calldata，以接受 HRMP 通道。您还可以使用该脚本在链上为给定的 HRMP 操作创建并提交预映像和提案。对于 Moonbeam 和 Moonriver，提案必须通过 General Admin Track 提交。</p> <p>请参阅 README 以获取参数的完整列表，包括可选参数，以及有关如何使用 HRMP-manipulator 脚本的示例。</p> <p>如果您计划将交易与其他调用批量处理，请复制生成的 calldata，以便稍后在使用 批量交易 脚本时使用。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/xc-integration/#open-an-hrmp-channel-from-moonbeam", "title": "从 Moonbeam 打开 HRMP 通道", "text": "<p>平行链需要双向 HRMP 通道才能相互发送 XCM。建立 HRMP 通道的第一步是创建打开通道请求。这需要一个带有 Transact 指令的 XCM 消息到中继链，该指令调用 HRMP Pallet 和 <code>hrmpInitOpenChannel</code> extrinsic。</p> <p>幸运的是，xcm-tools GitHub 存储库的 <code>hrmp-channel-manipulator.ts</code> 脚本可以为您构建 XCM！</p> <p>To use the script, you'll need to provide the following required arguments:</p> <ul> <li><code>--parachain-ws-provider</code> or <code>--w</code> - specifies the parachain WebSocket provider that will be issuing the requests</li> <li><code>--relay-ws-provider</code> or <code>--wr</code> - specifies the relay chain WebSocket provider that will be issuing the requests</li> <li><code>--hrmp-action</code> or <code>--hrmp</code> - accepts the following action to take, which can be any of the following: <code>accept</code>, <code>cancel</code>, <code>close</code>, and <code>open</code></li> <li><code>--target-para-id</code> or <code>-p</code> - the target parachain ID for the requests</li> </ul> <p>运行以下命令将提供编码的 calldata，以从 Moonbeam 网络创建 HRMP 通道请求。最大消息大小和容量值可以从中继链的 Configuration Pallet 和 <code>activeConfig</code> extrinsic 获取。将 <code>YOUR_PARACHAIN_ID</code> 替换为您的平行链的 ID：</p> <p>===</p> <pre><code>```bash\nyarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonbeam.network  \\\n--relay-ws-provider wss://rpc.polkadot.io \\\n--max-capacity 1000 --max-message-size 102400 \\\n--hrmp-action open\n```\n</code></pre> <p>===</p> <pre><code>```bash\nyarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonriver.moonbeam.network  \\\n--relay-ws-provider wss://kusama-rpc.polkadot.io \\\n--max-capacity 1000 --max-message-size 102400 \\\n--hrmp-action open\n```\n</code></pre> <p>===</p> <pre><code>```bash\nyarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonbase.moonbeam.network  \\\n--relay-ws-provider wss://relay.api.moonbase.moonbeam.network \\\n--max-capacity 1000 --max-message-size 102400 \\\n--hrmp-action open\n```\n</code></pre> <p>Note</p> <p>您可以通过更改 <code>parachain-ws-provider</code> 来调整脚本以适应您的平行链。</p> <p>运行脚本后，您将看到如下所示的输出：</p> yarn hrmp-manipulator --target-para-id 3370 \\ --parachain-ws-provider wss://moonbeam.public.blastapi.io  \\ --relay-ws-provider wss://polkadot-rpc.publicnode.com \\ --max-capacity 1000 --max-message-size 102400 \\ --hrmp-action open yarn run v1.22.22 warning ../../../package.json: No license field $ ts-node 'scripts/hrmp-channel-manipulator.ts' --target-para-id 3370 --parachain-ws-provider wss://moonbeam.public.blastapi.io --relay-ws-provider wss://polkadot-rpc.publicnode.com --max-capacity 1000 --max-message-size 102400 --hrmp-action open Genesis hash is: 0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3 Polkadot FeeAmount is: 10000000000 XCM Version is V4 Encoded Call Data for Tx is 0x6b09002a0d0000e803000000900100010401000100e40b5402000000000000000000000002286bee020004000100 ✨  Done in 4.25s. <p>如上所示运行脚本将返回编码的 calldata，以打开 HRMP 通道。您还可以使用该脚本为给定的 HRMP 操作创建和提交链上的 preimage 和提案。对于 Moonbeam 和 Moonriver，提案必须通过 General Admin Track 提交。</p> <p>有关参数（包括可选参数）的完整列表以及如何使用 HRMP-manipulator 脚本的示例，请参阅 README。</p> <p>如果您计划将交易与其他调用批量处理，请复制生成的 calldata，以便以后在使用 批量交易 脚本时使用。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/xc-integration/#batch-actions-into-one", "title": "将操作批量处理为一个", "text": "<p>在平行链上完成 XCM 过程最有效的方法是将所有交易批量处理在一起。xcm-tools 存储库提供了一个脚本，可以将 extrinsic 调用批量处理为单个调用，从而只需要一个交易。如果您的平行链想要同时打开一个 HRMP 通道并注册一个资产，这将很有帮助。在 Moonbeam 网络上提议通道注册时，应该使用此方法。</p> <p>如果您除了建立通道之外还要注册资产，请参阅如何注册跨链资产指南，以了解如何生成资产注册所需的编码调用数据。</p> <p>下图描述了将所有交易批量处理为一个的过程。</p> <p></p> <p>您现在将使用编码的调用数据输出，用于打开通道、接受通道和注册资产，并将它们插入到以下命令中，以将批量提案发送到 democracy。</p> <p>您可以为您要批处理的每个调用添加一个 <code>--call \"INSERT_CALL\"</code>。在运行命令之前，请替换以下值：</p> <ul> <li><code>OPEN_CHANNEL_CALL</code> 是 SCALE 编码的调用数据，用于从 Moonbeam 打开到您的平行链的 HRMP 通道</li> <li><code>ACCEPT_INCOMING_CALL</code> 是 SCALE 编码的调用数据，用于从您的平行链接受通道请求</li> <li><code>REGISTER_ASSET_CALL</code> 是 SCALE 编码的调用数据，用于注册跨链资产。如果您有多个资产要在 Moonbeam 上注册，您可以包含额外的注册 SCALE 编码的调用数据，并带有额外的 <code>--call</code> 标志</li> </ul> <p>===</p> <pre><code>```bash\n</code></pre> <p>yarn generic-call-propose -w wss://wss.api.moonbeam.network \\     --call \"OPEN_CHANNEL_CALL\" \\     --call \"ACCEPT_INCOMING_CALL\" \\     --call \"REGISTER_ASSET_CALL\" \\     ```</p> <p>===</p> <pre><code>```bash\n</code></pre> <p>yarn generic-call-propose -w wss://wss.api.moonriver.moonbeam.network \\     --call \"OPEN_CHANNEL_CALL\" \\     --call \"ACCEPT_INCOMING_CALL\" \\     --call \"REGISTER_ASSET_CALL\" \\     ```</p> <p>===</p> <pre><code>```bash\n</code></pre> <p>yarn generic-call-propose -w wss://wss.api.moonbase.moonbeam.network  \\     --call \"OPEN_CHANNEL_CALL\" \\     --call \"ACCEPT_INCOMING_CALL\" \\     --call \"REGISTER_ASSET_CALL\" \\     ```</p> <p>Note</p> <p>您可以通过更改 <code>parachain-ws-provider</code> 来重新调整您的平行链的脚本。</p> <p>有了编码的调用数据，您就可以提交治理提案。对于 Moonbeam 和 Moonriver，您必须将提案分配给 General Admin Track。建议您熟悉基于 Moonbeam 的网络上的 OpenGov：Governance v2 流程。</p> <p>如果您想直接从 CLI 发送治理提案，您需要使用以下附加标志：</p> <pre><code>--account-priv-key YOUR_PRIVATE_KEY \\\n--send-preimage-hash true \\\n--send-proposal-as v2 \\\n--track '{ \"Origins\": \"GeneralAdmin\" }'\n</code></pre> <p>对于 Moonbase Alpha，您无需提供私钥或通过治理。相反，您可以使用 <code>--sudo</code> 标志，并将输出提供给 Moonbeam 团队，以便可以通过 sudo 快速添加资产和通道。</p> <p>请随时查看此脚本的其他标志。</p>"}, {"location": "builders/interoperability/xcm/xc-registration/xc-integration/#additional-flags-xcm-tools", "title": "XCM-Tools 的附加标志", "text": "<p>xcm-tools GitHub 仓库 及其大多数函数都可以通过一些附加标志来调用，这些标志会在所采取的操作周围创建一些包装器。例如，您可能希望将 XCM 消息的发送包装在 sudo 中，或者通过民主提案。</p> <p>以下是可与该脚本一起使用的完整选项：</p> 标志 类型 描述 account-priv-key 字符串 （send-proposal-as，send-preimage-hash 所需）用于发送交易的帐户的私钥 sudo 布尔值 是否将外部调用数据包装在 <code>sudo.sudo</code> 外部调用中。如果存在 <code>account-priv-key</code>，它将尝试发送交易 send-preimage-hash 布尔值 是否将编码的外部调用数据作为预映像提交并检索其哈希 send-proposal-as democracy/council-external/v2 是否通过民主或理事会（Governance v1）或 OpenGov（Governance v2）发送编码的外部调用数据 collective-threshold 数字 (council-external 所需) 理事会决定提案的阈值 delay 数字 (v2 所需) OpenGovV2 提案执行延迟的区块数 track 字符串（JSON 编码的来源） （v2 所需）OpenGovV2 提案的 JSON 编码来源。对于 Moonbeam 网络：“Root”、“WhitelistedCaller”、“GeneralAdmin”、“ReferendumCanceller”、“ReferendumKiller” at-block 数字 是否将外部调用数据包装在 <code>scheduler.schedule</code> 外部调用中。将来应该安排执行操作的区块 fee-currency 字符串 (多重定位) （使用 XCM Transactor 的非 Moonbeam 链所需）中继链资产的多重定位 <p>Note</p> <p>必须像这样指定 track 选项：<code>'{ \"Origins\": \"INSERT_ORIGIN\" }'</code>，您可以在其中插入以下任何一个作为来源：“Root”、“WhitelistedCaller”、“GeneralAdmin”、“ReferendumCanceller”、“ReferendumKiller”。</p>"}, {"location": "builders/interoperability/xcm/xc20/interact/", "title": "在Moonbeam上与XC-20互动", "text": ""}, {"location": "builders/interoperability/xcm/xc20/interact/#introduction", "title": "简介", "text": "<p>正如XC-20s 概述页面中所述，XC-20s 是 Moonbeam 上一种独特的资产类别。虽然它们是 Substrate 原生资产，但它们也具有 ERC-20 接口，并且可以像任何其他 ERC-20 一样进行交互。此外，ERC-20 许可接口适用于所有外部 XC-20。</p> <p>本指南涵盖了 XC-20 Solidity 接口，包括标准 ERC-20 接口和 ERC-20 许可接口，以及如何使用这些接口与外部 XC-20 进行交互。</p>"}, {"location": "builders/interoperability/xcm/xc20/interact/#xc20s-solidity-interface", "title": "XC-20s Solidity 接口", "text": "<p>两种类型的 XC-20s 都具有标准的 ERC-20 接口。此外，所有外部 XC-20s 还具有 ERC-20 Permit 接口。以下两个部分分别描述了每个接口。</p>"}, {"location": "builders/interoperability/xcm/xc20/interact/#the-erc20-interface", "title": "ERC-20 Solidity 接口", "text": "<p>如前所述，您可以通过 ERC-20 接口与 XC-20 交互。Moonbeam 上的 ERC20.sol 接口遵循 EIP-20 代币标准，这是智能合约中代币的标准 API 接口。该标准定义了代币合约必须实现的必要函数和事件，以与不同的应用程序互操作。</p> <p>该接口包括以下函数：</p> <ul> <li>name() — 只读函数，返回代币的名称</li> <li>symbol() — 只读函数，返回代币的符号</li> <li>decimals() — 只读函数，返回代币的小数位数</li> <li>totalSupply() — 只读函数，返回现有代币的总数</li> <li>balanceOf(address who) — 只读函数，返回指定地址的余额</li> <li>allowance(address owner, address spender) — 只读函数，检查并返回允许消费方代表所有者消费的代币数量</li> <li>transfer(address to, uint256 value) — 将给定数量的代币转移到指定地址，如果转移成功，则返回 <code>true</code></li> <li>approve(address spender, uint256 value) — 批准提供的地址代表 <code>msg.sender</code> 消费指定数量的代币。如果成功，则返回 <code>true</code></li> <li>transferFrom(address from, address to, uint256 value) — 将代币从一个给定地址转移到另一个给定地址，如果成功，则返回 <code>true</code></li> </ul> <p>Note</p> <p>ERC-20 标准未指定多次调用 <code>approve</code> 的影响。使用此函数多次更改津贴会启用可能的攻击媒介。为了避免不正确或意外的交易排序，您可以先将 <code>spender</code> 津贴减少到 <code>0</code>，然后再设置所需的津贴。有关攻击媒介的更多详细信息，您可以查看 ERC-20 API：批准/转移方法的攻击媒介 概述。</p> <p>该接口还包括以下必需的事件：</p> <ul> <li>Transfer(address indexed from, address indexed to, uint256 value) - 当执行转移时发出</li> <li>Approval(address indexed owner, address indexed spender, uint256 value) - 当注册批准时发出</li> </ul>"}, {"location": "builders/interoperability/xcm/xc20/interact/#the-erc20-permit-interface", "title": "ERC-20 Permit Solidity 接口", "text": "<p>外部 XC-20 也具有 ERC-20 Permit 接口。 Moonbeam 上的 Permit.sol 接口遵循 EIP-2612 标准，该标准使用 <code>permit</code> 函数扩展了 ERC-20 接口。Permit 是已签名的消息，可用于更改帐户的 ERC-20 额度。 请注意，本地 XC-20 也可以具有 Permit 接口，但这不是它们满足 XCM 就绪的必要条件。</p> <p>标准 ERC-20 <code>approve</code> 函数的设计受到限制，因为 <code>allowance</code> 只能由交易的发送者 <code>msg.sender</code> 修改。这可以在 OpenZeppelin 的 ERC-20 接口实现 中看到，它通过 <code>msgSender</code> 函数 设置 <code>owner</code>，最终将其设置为 <code>msg.sender</code>。</p> <p>用户可以不签署 <code>approve</code> 交易，而是签署消息，并且该签名可用于调用 <code>permit</code> 函数以修改 <code>allowance</code>。 因此，它允许无 gas 的代币转移。 此外，用户不再需要发送两个交易来批准和转移代币。 要查看 <code>permit</code> 函数的示例，您可以查看 OpenZeppelin 的 ERC-20 Permit 扩展实现。</p> <p>Permit.sol 接口包括以下函数：</p> <ul> <li>permit(address owner, address spender, uint256, value, uint256, deadline, uint8 v, bytes32 r, bytes32 s) - 使用批准许可，任何人都可以调用</li> <li>nonces(address owner) - 返回给定所有者的当前随机数</li> <li>DOMAIN_SEPARATOR() - 返回 EIP-712 域分隔符，用于避免重放攻击。它遵循 EIP-2612 实现</li> </ul> <p>DOMAIN_SEPARATOR() 在 EIP-712 标准 中定义，计算方法如下：</p> <pre><code>keccak256(PERMIT_DOMAIN, name, version, chain_id, address)\n</code></pre> <p>hash 的参数可以分解如下：</p> <ul> <li>PERMIT_DOMAIN - 是指 <code>EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)</code> 的 <code>keccak256</code></li> <li>name - 是代币名称，但需要考虑以下事项：<ul> <li>如果代币定义了名称，则域的 name 是 <code>XC20: &lt;name&gt;</code>，其中 <code>&lt;name&gt;</code> 是代币名称</li> <li>如果代币未定义名称，则域的 name 是 <code>XC20: No name</code></li> </ul> </li> <li>version - 是签名域的版本。 对于这种情况，version 设置为 <code>1</code></li> <li>chainId - 是网络的链 ID</li> <li>verifyingContract - 是 XC-20 地址</li> </ul> <p>Note</p> <p>在运行时升级 1600 之前，name 字段不遵循标准 EIP-2612 实现。</p> <p>域分隔符的计算可以在 Moonbeam 的 EIP-2612 实现中看到，OpenZeppelin 的 <code>EIP712</code> 合约 中显示了一个实际示例。</p> <p>除了域分隔符之外，<code>hashStruct</code> 保证签名只能用于具有给定函数参数的 <code>permit</code> 函数。 它使用给定的随机数来确保签名不会受到重放攻击。 哈希结构的计算可以在 Moonbeam 的 EIP-2612 实现中看到，OpenZeppelin 的 <code>ERC20Permit</code> 合约 中显示了一个实际示例。</p> <p>域分隔符和哈希结构可用于构建完全编码消息的最终哈希。 OpenZeppelin 的 <code>EIP712</code> 合约 中显示了一个实际示例。</p> <p>使用最终哈希和 <code>v</code>、<code>r</code> 和 <code>s</code> 值，可以验证和恢复签名。 如果成功验证，随机数将增加 1，并且额度将会更新。</p>"}, {"location": "builders/interoperability/xcm/xc20/interact/#interact-with-the-precompile-using-remix", "title": "使用 ERC-20 接口与外部 XC-20 进行交互", "text": "<p>本指南的这一部分将向您展示如何使用 Remix 通过 ERC-20 接口与 XC-20 进行交互。由于本地 XC-20 是常规 ERC-20 的表示，本节重点介绍外部 XC-20。</p> <p>要与外部 XC-20 进行交互，您需要首先计算要交互的 XC-20 资产的预编译地址。然后，您可以像使用任何其他 ERC-20 一样与 ERC-20 接口进行交互。</p> <p>您可以调整本节中的说明，以便与 Permit.sol 接口一起使用。</p>"}, {"location": "builders/interoperability/xcm/xc20/interact/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要通过 ERC-20 接口批准支出或转移外部 XC-20，您将需要：</p> <ul> <li>已安装 MetaMask 并连接到 Moonbase Alpha TestNet</li> <li>在 Moonbase Alpha 上创建或拥有两个帐户</li> <li>至少一个帐户需要用 <code>DEV</code> 代币进行充值。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"}, {"location": "builders/interoperability/xcm/xc20/interact/#calculate-xc20-address", "title": "计算外部 XC-20 预编译地址", "text": "<p>在您可以通过 ERC-20 接口与外部 XC-20 交互之前，您需要从资产 ID 派生外部 XC-20 的预编译地址。</p> <p>外部 XC-20 预编译地址的计算方式如下：</p> <p>text address = '0xFFFFFFFF...' + DecimalToHex(AssetId)</p> <p>根据上述计算，第一步是获取资产 ID 的 u128 表示形式并将其转换为十六进制值。您可以使用您选择的搜索引擎来查找将十进制转换为十六进制值的简单工具。对于资产 ID <code>42259045809535163221576417993425387648</code>，十六进制值为 <code>1FCACBD218EDC0EBA20FC2308C778080</code>。</p> <p>外部 XC-20 预编译只能介于 <code>0xFFFFFFFF00000000000000000000000000000000</code> 和 <code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code> 之间。</p> <p>由于以太坊地址的长度为 40 个字符，因此您需要从最初的八个 <code>F</code> 开始，然后将 <code>0</code> 预置到十六进制值，直到地址具有 40 个字符。</p> <p>已经计算出的十六进制值为 32 个字符长，因此将八个 <code>F</code> 预置到十六进制值将为您提供与 XC-20 预编译交互所需的 40 个字符地址。对于此示例，完整地址为 <code>0xFFFFFFFF1FCACBD218EDC0EBA20FC2308C778080</code>。</p> <p>现在您已经计算出外部 XC-20 预编译地址，您可以像使用 Remix 中的任何其他 ERC-20 一样，使用该地址与 XC-20 进行交互。</p>"}, {"location": "builders/interoperability/xcm/xc20/interact/#add-the-interface-to-remix", "title": "添加和编译接口", "text": "<p>您可以使用 Remix 与 ERC-20 接口进行交互。首先，您需要将接口添加到 Remix 中：</p> <ol> <li>获取 ERC20.sol 的副本</li> <li>将文件内容粘贴到名为 IERC20.sol 的 Remix 文件中</li> </ol> <p></p> <p>在 Remix 中加载 ERC-20 接口后，您需要对其进行编译：</p> <ol> <li>点击从顶部数第二个 Compile 标签</li> <li>编译 IERC20.sol 文件</li> </ol> <p></p> <p>如果接口编译成功，您将在 Compile 标签旁边看到一个绿色对勾。</p>"}, {"location": "builders/interoperability/xcm/xc20/interact/#access-the-precompile", "title": "访问预编译", "text": "<p>您将访问给定 XC-20 地址的接口，而不是部署 ERC-20 预编译：</p> <ol> <li>点击 Remix 中 Compile（编译） 选项卡正下方的 Deploy and Run（部署和运行） 选项卡。请注意，预编译合约已经部署</li> <li>确保在 ENVIRONMENT（环境） 下拉列表中选择了 Injected Web3（注入 Web3）。选择 Injected Web3（注入 Web3） 后，MetaMask 可能会提示您将您的帐户连接到 Remix</li> <li>确保在 ACCOUNT（帐户） 下显示了正确的帐户</li> <li>确保在 CONTRACT（合约） 下拉列表中选择了 IERC20 - IERC20.sol。由于这是一个预编译合约，因此无需部署任何代码。相反，您需要在 At Address（在地址处） 字段中提供预编译的地址</li> <li>提供 XC-20 的地址。对于本地 XC-20，您应该已经在 计算外部 XC-20 预编译地址 部分中计算过。对于此示例，您可以使用 <code>0xFFFFFFFF1FCACBD218EDC0EBA20FC2308C778080</code> 并点击 At Address（在地址处）</li> </ol> <p></p> <p>Note</p> <p>或者，您可以通过访问您选择的搜索引擎并搜索用于校验地址的工具来校验 XC-20 预编译地址。地址经过校验后，您可以在 At Address（在地址处） 字段中使用它。</p> <p>XC-20 的 IERC20 预编译将出现在 Deployed Contracts（已部署合约） 列表中。现在您可以随意调用任何标准 ERC-20 函数来获取有关 XC-20 的信息或转移 XC-20。</p> <p></p> <p>要了解如何与每个函数进行交互，您可以查看 ERC-20 预编译 指南并对其进行修改以与 XC-20 预编译进行交互。</p>"}, {"location": "builders/interoperability/xcm/xc20/overview/", "title": "XC-20 概述", "text": ""}, {"location": "builders/interoperability/xcm/xc20/overview/#introduction", "title": "简介", "text": "<p>跨共识消息 (XCM) 格式为区块链交换消息和转移资产提供了一种通用方式。为了将这种互操作性扩展到 EVM，Moonbeam 引入了 XC-20，这是一种 Moonbeam 上的 ERC-20 代币，它与 XCM 转移完全兼容。</p> <p>在 Moonbeam 上部署的任何 ERC-20 都可以配置为 XC-20，从而可以通过 XCM 访问连接的任何链。这使得专注于 EVM 的开发人员可以使用熟悉的 ERC-20 工作流程，同时受益于 Polkadot 的原生跨链功能，而无需 Substrate 方面的专业知识。</p> <p>从技术角度来看，本地 XC-20 是源自 Moonbeam 的 ERC-20 代币（包括在 Moonbeam 上发行后被视为原生的桥接代币），而外部 XC-20 是代币的包装表示，其规范账本存在于另一个平行链或中继链上。在所有情况下，XC-20 的功能都与标准 ERC-20 相同——支持常见的基于 EVM 的用例（例如 DeFi、DEX 和借贷平台）——但具有无缝跨链互操作性的额外优势。</p> <p></p> <p>本页面旨在介绍 XC-20 的基础知识；如果您想了解如何与 XC-20 交互或转移 XC-20，请参阅 发送 XC-20 指南。</p>"}, {"location": "builders/interoperability/xcm/xc20/overview/#types-of-xc-20s", "title": "XC-20 的类型", "text": "<p>XC-20 有两种类型：本地和外部。</p>"}, {"location": "builders/interoperability/xcm/xc20/overview/#local-xc20s", "title": "什么是本地 XC-20？", "text": "<p>本地 XC-20 是指 EVM 上存在的所有 ERC-20，可以通过 XCM 进行跨链转移。为了将本地 XC-20 转移到另一个平行链，必须在该链上注册资产。当转移本地 XC-20 时，底层代币驻留在目标链在 Moonbeam 上的主权账户中。主权账户 是由区块链运行时（而不是个人）管理的无密钥账户，可以持有资产并与其他链交互。本地 XC-20 必须遵循本指南中概述的 ERC-20 接口。它们必须实现标准的 ERC-20 函数签名，包括 EIP-20 中描述的 <code>transfer</code> 函数的正确函数选择器。但是，只要不破坏基本方法，仍然可以添加其他功能。</p> <p>创建本地 XC-20 相当于部署一个标准的 ERC-20 并在任何 Moonbeam 网络上启用跨链功能。</p>"}, {"location": "builders/interoperability/xcm/xc20/overview/#external-xc20s", "title": "什么是外部 XC-20？", "text": "<p>外部 XC-20 是源自另一个平行链或中继链的跨链代币，它们在 Moonbeam 上表示为 ERC-20 代币。原始代币仍然锁定在其主链上的 Moonbeam 主权账户中，而包装后的 ERC-20 表示形式可以在 Moonbeam 上自由使用。当您转移外部 XC-20 时，规范资产仍然位于其源链的主权账户中，而 ERC-20 表示形式是在 Moonbeam 上流通的内容。</p> <p>外部 XC-20 的名称都带有 xc 前缀，以将其区分为跨链资产。例如，DOT 是 Polkadot 中继链的原生代币，当其在 Moonbeam 上表示为 XC-20 时，被称为 xcDOT。</p>"}, {"location": "builders/interoperability/xcm/xc20/overview/#local-xc-20s-vs-external-xc-20s", "title": "本地 XC-20 与外部 XC-20", "text": "<p>从 Polkadot 的角度来看，本地 XC-20 是 EVM 原生的 ERC-20 代币，Moonbeam 是它们的“家”（或储备链）。这包括最初从 Polkadot 外部桥接进来的代币（例如，Wormhole 封装的 ETH），因为一旦它们在 Moonbeam 上作为 ERC-20 发行，Polkadot 就会将它们视为 Moonbeam 本地的代币。当本地 XC-20 被转移到另一个平行链时，这些代币会移动到该链在 Moonbeam 上的主权账户中。</p> <p>另一方面，外部 XC-20 是 ERC-20 代币的表示，这些代币的规范账本保留在另一个平行链或中继链上。Moonbeam 持有“封装”版本，而底层代币则锁定在 Moonbeam 在原始链上的主权账户中。</p> <p>从跨链转移的角度来看，本地和外部 XC-20 可以使用 Ethereum 或 Substrate API 通过 Polkadot 的 XCM 基础设施发送。由于底层资产是具有 EVM 字节码的 ERC-20，遵循 EIP-20 代币标准，因此通过 Substrate 和 Ehereum API 发起的转移都会生成 EVM 日志，这些日志对诸如 Moonscan 之类的基于 EVM 的浏览器可见。相反，您无法使用 Substrate API 发送常规 ERC-20 转移。除了通过 XCM 进行的跨链转移之外，所有其他的 XC-20 交互（例如查询余额或调整授权额度）都必须在 EVM 中进行。</p> <p>XC-20 的跨链转移通过 Polkadot XCM Pallet 执行，该 Pallet 利用 ERC-20 的常规铸造、销毁和转移机制来实现 XCM 资产流动。如果您想了解如何使用该 Pallet 发送 XC-20，请参阅 使用 Polkadot XCM Pallet 指南。</p>"}, {"location": "builders/interoperability/xcm/xc20/overview/#asset-reserves", "title": "资产储备", "text": "<p>在 Polkadot 或 Kusama 生态系统中跨链转移代币时，每个代币都有一个“储备”链，用于保存其规范账本——这是铸造、销毁和供应管理的真实来源。对于 XC-20，了解哪个链是储备链决定了资产是在 Moonbeam 上本地管理还是在另一个链上远程管理。</p> <p>无论储备位于何处，Moonbeam 上的 XC-20 仍然是 ERC-20 代币，开发人员和用户可以在 EVM 中与之交互。但是，从 XCM 的角度来看，储备链决定了在执行跨链操作时，代币在幕后是如何锁定、解锁、铸造或销毁的。</p>"}, {"location": "builders/interoperability/xcm/xc20/overview/#local-reserve-assets", "title": "本地储备资产", "text": "<p>Moonbeam 上的本地储备资产是一种代币，从 XCM 的角度来看，其规范账本原生位于 Moonbeam 上。换句话说，Moonbeam 是该资产的源链，在该链上进行铸造和销毁。</p> <p>例如，Wormhole 封装的 ETH (wETH) 被认为是 Moonbeam 上的本地储备资产，即使 Ethereum 是 ETH 的最终来源。一旦 ETH 被 Wormhole 封装并通过 Moonbeam 进入 Polkadot 生态系统，wETH 就可以通过 Moonbeam 路由流动性 (MRL) 转移到其他平行链。</p> <p>重要的注意事项是，在纯粹的 Ethereum 层面来看，ETH 仍然受 Ethereum 的管辖并在 Ethereum 上铸造。但是，从 XCM 的角度来看，Moonbeam 上的 wETH 被视为本地储备资产，这意味着 wETH 的规范供应（就 Polkadot 生态系统而言）存在于 Moonbeam 上。</p>"}, {"location": "builders/interoperability/xcm/xc20/overview/#remote-reserve-assets", "title": "远程储备资产", "text": "<p>远程储备资产是一种代币，其规范账本（铸造和销毁的真实来源）位于与其当前使用位置不同的链上。以 Moonbeam 上的 xcDOT 为例，代表 xcDOT 的底层 DOT 代币仍然锁定在 Moonbeam 在 Polkadot 中继链上的主权账户中，而 xcDOT 在 Moonbeam 的 EVM 环境中充当包装的表示形式。</p> <p>用户可以在 Moonbeam 上持有和交易 xcDOT（用于 DeFi、治理等），他们知道底层 DOT 安全地锁定在中继链上。在任何时候，包装的 xcDOT 都可以兑换为原始 DOT，从而有效地销毁 xcDOT 并解锁 Polkadot 上的相应 DOT 代币。</p>"}, {"location": "builders/interoperability/xcm/xc20/overview/#list-xchain-assets", "title": "检索外部 XC-20 及其元数据的列表", "text": "<p>要获取当前可用的外部 XC-20 及其关联元数据的列表，您可以使用 Polkadot.js API 查询链状态。您将执行以下步骤：</p> <ol> <li> <p>为您想要获取资产列表的网络创建一个 API 提供程序。您可以为每个网络使用以下 WSS 端点：</p> MoonbeamMoonriverMoonbase Alpha <p>text wss://wss.api.moonbeam.network</p> <p>text wss://wss.api.moonriver.moonbeam.network</p> <p>wss://wss.api.moonbase.moonbeam.network</p> </li> <li> <p>查询 <code>assets</code> pallet 以获取所有资产</p> </li> <li>迭代资产列表以获取所有资产 ID 及其关联的元数据</li> </ol> <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const getXc20s = async () =&gt; {   try {     const substrateProvider = new WsProvider('INSERT_WSS_ENDPOINT');     const api = await ApiPromise.create({ provider: substrateProvider });</p> <pre><code>const assets = await api.query.assets.asset.entries();\n\nawait Promise.all(\n  assets.map(async ([{ args: [id] }]) =&gt; {\n    try {\n      const metadata = await api.query.assets.metadata(id);\n      const humanMetadata = metadata.toHuman();\n\n      console.log(`\\nAsset ID: ${id}`);\n      console.log('Metadata:');\n      console.log('  Name:', humanMetadata.name);\n      console.log('  Symbol:', humanMetadata.symbol);\n      console.log('  Decimals:', humanMetadata.decimals);\n      console.log('  Deposit:', humanMetadata.deposit);\n      console.log('  IsFrozen:', humanMetadata.isFrozen);\n      console.log('-----');\n    } catch (error) {\n      console.error(`Error fetching metadata for asset ${id}:`, error);\n    }\n  })\n);\n\nawait api.disconnect();\n</code></pre> <p>} catch (error) {     console.error('Error in getXc20s:', error);   } };</p> <p>getXc20s().catch(console.error);</p> <p>结果将显示资产 ID 以及所有已注册的外部 XC-20 的一些其他信息。</p>"}, {"location": "builders/interoperability/xcm/xc20/overview/#retrieve-local-xc20-metadata", "title": "检索本地 XC-20 元数据", "text": "<p>由于本地 XC-20 是 Moonbeam 上的 ERC-20，可以通过 XCM 转移到另一个平行链，您可以像与 ERC-20 交互一样与本地 XC-20 交互。只要您拥有 ERC-20 的地址和 ABI，您就可以通过与其 ERC-20 接口交互来检索其元数据，以检索资产的名称、符号和小数位数。</p> <p>以下是一个示例，检索 Moonbase Alpha 上的 Jupiter 代币的资产元数据：</p> <p>===\"Ethers.js\"</p> <pre><code>```js\nimport { ethers } from 'ethers';\n\nconst providerRPC = {\n  moonbase: {\n    name: 'moonbase',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network', // Insert your RPC URL here\n    chainId: 1287, // 0x507 in hex,\n  },\n};\n\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n});\n\n// Replace with the address of the ERC-20 token\nconst tokenAddress = '0x9Aac6FB41773af877a2Be73c99897F3DdFACf576';\nconst tokenABI = [\n  'function name() view returns (string)',\n  'function symbol() view returns (string)',\n  'function decimals() view returns (uint8)',\n];\n\nconst tokenContract = new ethers.Contract(tokenAddress, tokenABI, provider);\nasync function getTokenMetadata() {\n  try {\n    const [name, symbol, decimals] = await Promise.all([\n      tokenContract.name(),\n      tokenContract.symbol(),\n      tokenContract.decimals(),\n    ]);\n    console.log(`Name: ${name}`);\n    console.log(`Symbol: ${symbol}`);\n    console.log(`Decimals: ${decimals}`);\n  } catch (error) {\n    console.error('Error fetching token metadata:', error);\n  }\n}\ngetTokenMetadata();\n\n```\n</code></pre> <p>===\"Web3.js\"</p> <pre><code>```js\nimport { Web3 } from 'web3';\n\n// Insert your RPC URL here\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\n// Replace with the address of the ERC-20 token\nconst tokenAddress = '0x9Aac6FB41773af877a2Be73c99897F3DdFACf576';\nconst tokenABI = [\n  // ERC-20 ABI\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [{ name: '', type: 'string' }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [{ name: '', type: 'string' }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [{ name: '', type: 'uint8' }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n];\nconst tokenContract = new web3.eth.Contract(tokenABI, tokenAddress);\nasync function getTokenMetadata() {\n  try {\n    const [name, symbol, decimals] = await Promise.all([\n      tokenContract.methods.name().call(),\n      tokenContract.methods.symbol().call(),\n      tokenContract.methods.decimals().call(),\n    ]);\n    console.log(`Name: ${name}`);\n    console.log(`Symbol: ${symbol}`);\n    console.log(`Decimals: ${decimals}`);\n  } catch (error) {\n    console.error('Error fetching token metadata:', error);\n  }\n}\ngetTokenMetadata();\n\n```\n</code></pre> <p>===\"Web3.py\"</p> <pre><code>```py\nfrom web3 import Web3\n\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Replace with the address of the ERC-20 token\ntoken_address = \"0x9Aac6FB41773af877a2Be73c99897F3DdFACf576\"\ntoken_abi = [  # ERC-20 ABI\n    {\n        \"constant\": True,\n        \"inputs\": [],\n        \"name\": \"name\",\n        \"outputs\": [{\"name\": \"\", \"type\": \"string\"}],\n        \"payable\": False,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\",\n    },\n    {\n        \"constant\": True,\n        \"inputs\": [],\n        \"name\": \"symbol\",\n        \"outputs\": [{\"name\": \"\", \"type\": \"string\"}],\n        \"payable\": False,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\",\n    },\n    {\n        \"constant\": True,\n        \"inputs\": [],\n        \"name\": \"decimals\",\n        \"outputs\": [{\"name\": \"\", \"type\": \"uint8\"}],\n        \"payable\": False,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\",\n    },\n]\ntoken_contract = web3.eth.contract(address=token_address, abi=token_abi)\n\n\ndef get_token_metadata():\n    try:\n        name = token_contract.functions.name().call()\n        symbol = token_contract.functions.symbol().call()\n        decimals = token_contract.functions.decimals().call()\n        print(f\"Name: {name}\")\n        print(f\"Symbol: {symbol}\")\n        print(f\"Decimals: {decimals}\")\n    except Exception as e:\n        print(f\"Error fetching token metadata: {e}\")\n\n\nget_token_metadata()\n\n```\n</code></pre>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/eth-api/", "title": "XCM 预编译", "text": ""}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/eth-api/#introduction", "title": "简介", "text": "<p>作为 Polkadot 的平行链，Moonbeam 具有与其他连接的平行链通信和交换数据的固有能力。这种原生的跨链通信允许安全快速的代币转移，利用跨共识消息格式（简称 XCM），促进不同共识系统之间的通信。</p> <p>实现代币转移的通信协议构建在 Substrate 之上，并且运行级别低于 EVM，这使得 EVM 开发者更难访问。</p> <p>尽管如此，Moonbeam 网络具有一个 XCM 预编译合约，可以填补执行层之间的空白。这个预编译合约公开了一个智能合约接口，该接口抽象了底层复杂性，使得跨链代币转移的执行变得像任何其他智能合约调用一样简单。</p> <p>本指南将向您展示如何与 XCM 接口 预编译合约交互，以通过 Ethereum API 执行跨链代币转移。</p> <p>XCM 预编译合约位于以下地址：</p> <p>===</p> <pre><code> ```\n 0x000000000000000000000000000000000000081A\n ```\n</code></pre> <p>===</p> <pre><code> ```\n 0x000000000000000000000000000000000000081A\n ```\n</code></pre> <p>===</p> <pre><code> ```\n 0x000000000000000000000000000000000000081A\n ```\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/eth-api/#the-xcm-solidity-interface", "title": "XCM Solidity 接口", "text": "<p><code>XCMInterface.sol</code> 是一个 Solidity 接口，允许开发者与 <code>pallet-xcm</code> 的方法进行交互。</p> XCMInterface.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The XCM contract's address.\naddress constant XCM_CONTRACT_ADDRESS = 0x000000000000000000000000000000000000081A;\n\n/// @dev The XCM contract's instance.\nXCM constant XCM_CONTRACT = XCM(XCM_CONTRACT_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title XCM precompile Interface\n/// @dev The interface that Solidity contracts use to interact with the substrate pallet-xcm.\ninterface XCM {\n    // A location is defined by its number of parents and the encoded junctions (interior)\n    struct Location {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    // Support for Weights V2\n    struct Weight {\n        uint64 refTime;\n        uint64 proofSize;\n    }\n\n    // A way to represent fungible assets in XCM using Location format\n    struct AssetLocationInfo {\n        Location location;\n        uint256 amount;\n    }\n\n    // A way to represent fungible assets in XCM using address format\n    struct AssetAddressInfo {\n        address asset;\n        uint256 amount;\n    }\n\n    // The values start at `0` and are represented as `uint8`\n    enum TransferType {\n        Teleport,\n        LocalReserve,\n        DestinationReserve\n    }\n\n    /// @dev Function to send assets via XCM using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector 9ea8ada7\n    /// @param dest The destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on dest.\n    /// @param assets The combination (array) of assets to send in Location format.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    function transferAssetsLocation(\n        Location memory dest,\n        Location memory beneficiary,\n        AssetLocationInfo[] memory assets,\n        uint32 feeAssetItem\n    ) external;\n\n    /// @dev Function to send assets via XCM to a 20 byte-like parachain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector a0aeb5fe\n    /// @param paraId The para-id of the destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on paraId destination.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    function transferAssetsToPara20(\n        uint32 paraId,\n        address beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem\n    ) external;\n\n    /// @dev Function to send assets via XCM to a 32 byte-like parachain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector f23032c3\n    /// @param paraId The para-id of the destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on paraId destination.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    function transferAssetsToPara32(\n        uint32 paraId,\n        bytes32 beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem\n    ) external;\n\n    /// @dev Function to send assets via XCM to the relay chain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector 6521cc2c\n    /// @param beneficiary The actual account that will receive the tokens on the relay chain.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    function transferAssetsToRelay(\n        bytes32 beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem\n    ) external;\n\n    /// @dev Function to send assets through transfer_assets_using_type_and_then() pallet-xcm\n    /// extrinsic.\n    /// Important: in this selector RemoteReserve type (for either assets or fees) is not allowed.\n    /// If users want to send assets and fees (in Location format) with a remote reserve, \n    /// they must use the selector fc19376c.\n    /// @custom:selector 8425d893\n    /// @param dest The destination chain.\n    /// @param assets The combination (array) of assets to send in Location format.\n    /// @param assetsTransferType The TransferType corresponding to assets being sent.\n    /// @param remoteFeesIdIndex The index of the asset (inside assets array) to use as fees.\n    /// @param feesTransferType The TransferType corresponding to the asset used as fees.\n    /// @param customXcmOnDest The XCM message to execute on destination chain.\n    function transferAssetsUsingTypeAndThenLocation(\n        Location memory dest,\n        AssetLocationInfo[] memory assets,\n        TransferType assetsTransferType,\n        uint8 remoteFeesIdIndex,\n        TransferType feesTransferType,\n        bytes memory customXcmOnDest\n    ) external;\n\n    /// @dev Function to send assets through transfer_assets_using_type_and_then() pallet-xcm\n    /// extrinsic.\n    /// @custom:selector fc19376c\n    /// @param dest The destination chain.\n    /// @param assets The combination (array) of assets to send in Location format.\n    /// @param remoteFeesIdIndex The index of the asset (inside assets array) to use as fees.\n    /// @param customXcmOnDest The XCM message to execute on destination chain.\n    /// @param remoteReserve The remote reserve corresponding for assets and fees. They MUST\n    /// share the same reserve.\n    function transferAssetsUsingTypeAndThenLocation(\n        Location memory dest,\n        AssetLocationInfo[] memory assets,\n        uint8 remoteFeesIdIndex,\n        bytes memory customXcmOnDest,\n        Location memory remoteReserve\n    ) external;\n\n    /// @dev Function to send assets through transfer_assets_using_type_and_then() pallet-xcm\n    /// extrinsic.\n    /// Important: in this selector RemoteReserve type (for either assets or fees) is not allowed.\n    /// If users want to send assets and fees (in Address format) with a remote reserve, \n    /// they must use the selector aaecfc62.\n    /// @custom:selector 998093ee\n    /// @param dest The destination chain.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param assetsTransferType The TransferType corresponding to assets being sent.\n    /// @param remoteFeesIdIndex The index of the asset (inside assets array) to use as fees.\n    /// @param feesTransferType The TransferType corresponding to the asset used as fees.\n    /// @param customXcmOnDest The XCM message to execute on destination chain.\n    function transferAssetsUsingTypeAndThenAddress(\n        Location memory dest,\n        AssetAddressInfo[] memory assets,\n        TransferType assetsTransferType,\n        uint8 remoteFeesIdIndex,\n        TransferType feesTransferType,\n        bytes memory customXcmOnDest\n    ) external;\n\n    /// @dev Function to send assets through transfer_assets_using_type_and_then() pallet-xcm\n    /// extrinsic.\n    /// @custom:selector aaecfc62\n    /// @param dest The destination chain.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param remoteFeesIdIndex The index of the asset (inside assets array) to use as fees.\n    /// @param customXcmOnDest The XCM message to execute on destination chain.\n    /// @param remoteReserve The remote reserve corresponding for assets and fees. They MUST\n    /// share the same reserve.\n    function transferAssetsUsingTypeAndThenAddress(\n        Location memory dest,\n        AssetAddressInfo[] memory assets,\n        uint8 remoteFeesIdIndex,\n        bytes memory customXcmOnDest,\n        Location memory remoteReserve\n    ) external;\n}\n</code></pre> <p>该接口包含必要的数据结构以及以下函数：</p> transferAssetsToPara20(paraId, beneficiary, assets, feeAssetItem) — 使用 XCM 将资产发送到类似 20 字节的平行链，使用 XCM pallet 模块中包含的底层 <code>transfer_assets()</code> 交易 ParametersExample <ul> <li><code>paraId</code> uint32 - 目标链的 para-id</li> <li><code>beneficiary</code> address - 目标链中将接收代币的 ECDSA 类型账户</li> <li><code>assets</code> AssetAddressInfo[] memory - 要以地址格式发送的资产数组</li> <li><code>feeAssetItem</code> uint32 - 将用于支付费用的资产的索引</li> </ul> <ul> <li><code>paraId</code> - 888</li> <li><code>beneficiary</code> - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> </ul> transferAssetsToPara32(paraId, beneficiary, assets, feeAssetItem) — 使用 XCM 将资产发送到类似 32 字节的平行链，使用 XCM pallet 模块中包含的底层 <code>transfer_assets()</code> 交易 ParametersExample <ul> <li><code>paraId</code> uint32 - 目标链的 para-id</li> <li><code>beneficiary</code> bytes32 - 将在 paraId 目标链上接收代币的实际账户</li> <li><code>assets</code> AssetAddressInfo[] memory - 要以地址格式发送的资产数组</li> <li><code>feeAssetItem</code> uint32 - 将用于支付费用的资产的索引</li> </ul> <ul> <li><code>paraId</code> - 888</li> <li><code>beneficiary</code> - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> </ul> transferAssetsToRelay(beneficiary, assets, feeAssetItem) — 使用 XCM 将资产发送到中继链，使用 XCM pallet 模块中包含的底层 <code>transfer_assets()</code> 交易 ParametersExample <ul> <li><code>beneficiary</code> bytes32 - 将在中继链上接收代币的实际账户</li> <li><code>assets</code> AssetAddressInfo[] memory - 要以地址格式发送的资产数组</li> <li><code>feeAssetItem</code> uint32 - 将用于支付费用的资产的索引</li> </ul> <ul> <li><code>beneficiary</code> - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> </ul> transferAssetsLocation(dest, beneficiary, assets, feeAssetItem) — 使用 XCM 发送资产，使用 XCM pallet 模块中包含的底层 <code>transfer_assets()</code> 交易 ParametersExample <ul> <li><code>dest</code> Location memory - 目标链</li> <li><code>beneficiary</code> Location memory - 目标链中将接收代币的账户</li> <li><code>assets</code> AssetLocationInfo[] memory - 要发送的资产数组</li> <li><code>feeAssetItem</code> uint32 - 将用于支付费用的资产的索引</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>beneficiary</code> - [0, [\"0x01f831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a0600\"]]</li> <li><code>assets</code> - [[[1, [\"0x010000000000000000000000000000000000000800\"]], 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> </ul> transferAssetsUsingTypeAndThenLocation(dest, assets, assetsTransferType, remoteFeesIdIndex, feesTransferType, customXcmOnDest) — 通过 <code>transfer_assets_using_type_and_then()</code> pallet-xcm extrinsic 发送资产。重要提示：禁止 RemoteReserve 类型（对于资产或费用）。要发送具有远程储备的资产和费用（以 Location 格式），请使用后续的 <code>transferAssetsUsingTypeAndThenLocation</code>，它与此函数名称相同，但采用不同的参数集 ParametersExample <ul> <li><code>dest</code> Location memory - 目标链</li> <li><code>assets</code> AssetLocationInfo[] memory - 要以 Location 格式发送的资产数组</li> <li><code>assetsTransferType</code> TransferType - 与发送的资产对应的 TransferType (Teleport = 0, LocalReserve = 1, DestinationReserve = 2)</li> <li><code>remoteFeesIdIndex</code> uint8 - 要用作费用的资产的索引（在 assets 数组中）</li> <li><code>feesTransferType</code> TransferType - 与用作费用的资产对应的 TransferType (Teleport = 0, LocalReserve = 1, DestinationReserve = 2)</li> <li><code>customXcmOnDest</code> bytes memory - 要在目标链上执行的 XCM 消息</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>assets</code> - [[[1, [\"0x010000000000000000000000000000000000000802\"]], 1000000000000000000]]</li> <li><code>assetsTransferType</code> - 0  </li> <li><code>remoteFeesIdIndex</code> - 0</li> <li><code>feesTransferType</code> - 1    </li> <li><code>customXcmOnDest</code> - 0x0408000400010403001300008a5d784563010d01020400010300f8234bedd9553e7668c4e0d60aced12e22bd2d45  </li> </ul> transferAssetsUsingTypeAndThenLocation(dest, assets, remoteFeesIdIndex, customXcmOnDest, remoteReserve) — 通过 <code>transfer_assets_using_type_and_then()</code> pallet-xcm extrinsic 发送资产。重要提示：远程储备必须在资产和费用之间共享 ParametersExample <ul> <li><code>dest</code> Location memory - 目标链</li> <li><code>assets</code> AssetLocationInfo[] memory - 要以 Location 格式发送的资产数组</li> <li><code>remoteFeesIdIndex</code> uint8 - 要用作费用的资产的索引（在 assets 数组中）</li> <li><code>customXcmOnDest</code> bytes memory - 要在目标链上执行的 XCM 消息</li> <li><code>remoteReserve</code> Location memory - 资产和费用对应的远程储备（必须共享）</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>assets</code> - [[[1, [\"0x010000000000000000000000000000000000000800\"]], 1000000000000000000]]</li> <li><code>remoteFeesIdIndex</code> - 0</li> <li><code>customXcmOnDest</code> - 0x0408000400010403001300008a5d784563010d01020400010300f8234bedd9553e7668c4e0d60aced12e22bd2d45  </li> <li><code>remoteReserve</code> - [1,[]]  </li> </ul> transferAssetsUsingTypeAndThenAddress(dest, assets, assetsTransferType, remoteFeesIdIndex, feesTransferType, customXcmOnDest) — 通过 <code>transfer_assets_using_type_and_then()</code> pallet-xcm extrinsic 发送资产。重要提示：不允许 RemoteReserve 类型（对于资产或费用）。要发送具有远程储备的资产和费用（以 Address 格式），请使用后续的 <code>transferAssetsUsingTypeAndThenAddress</code>，它与此函数名称相同，但采用不同的参数集 ParametersExample <ul> <li><code>dest</code> Location memory - 目标链</li> <li><code>assets</code> AssetAddressInfo[] memory - 要以地址格式发送的资产数组</li> <li><code>assetsTransferType</code> TransferType - 与发送的资产对应的 TransferType (Teleport = 0, LocalReserve = 1, DestinationReserve = 2)</li> <li><code>remoteFeesIdIndex</code> uint8 - 要用作费用的资产的索引（在 assets 数组中）</li> <li><code>feesTransferType</code> TransferType - 与用作费用的资产对应的 TransferType (Teleport = 0, LocalReserve = 1, DestinationReserve = 2)</li> <li><code>customXcmOnDest</code> bytes memory - 要在目标链上执行的 XCM 消息</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>assetsTransferType</code> - 0  </li> <li><code>remoteFeesIdIndex</code> - 0</li> <li><code>feesTransferType</code> - 1   </li> <li><code>customXcmOnDest</code> - 0x0408000400010403001300008a5d784563010d01020400010300f8234bedd9553e7668c4e0d60aced12e22bd2d45 </li> </ul> transferAssetsUsingTypeAndThenAddress(dest, assets, remoteFeesIdIndex, customXcmOnDest, remoteReserve) — 通过 <code>transfer_assets_using_type_and_then()</code> pallet-xcm extrinsic 发送资产。重要提示：远程储备必须在资产和费用之间共享 ParametersExample <ul> <li><code>dest</code> Location memory - 目标链</li> <li><code>assets</code> AssetAddressInfo[] memory - 要以地址格式发送的资产数组</li> <li><code>remoteFeesIdIndex</code> uint8 - 要用作费用的资产的索引（在 assets 数组中）</li> <li><code>customXcmOnDest</code> bytes memory - 要在目标链上执行的 XCM 消息</li> <li><code>remoteReserve</code> Location memory - 资产和费用对应的远程储备（必须共享）</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>remoteFeesIdIndex</code> - 0</li> <li><code>customXcmOnDest</code> - 0x0408000400010403001300008a5d784563010d01020400010300f8234bedd9553e7668c4e0d60aced12e22bd2d45</li> <li><code>remoteReserve</code> - [1,[]]</li> </ul>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/eth-api/#interact-with-the-solidity-interface", "title": "与 Solidity 接口交互", "text": ""}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/eth-api/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要学习本教程，您必须配置好您首选的 EVM 钱包，并且账户中有原生代币。您可以按照本指南将 Moonbeam 添加到 MetaMask 钱包：使用 MetaMask 与 Moonbeam 交互。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/eth-api/#remix-set-up", "title": "Remix 设置", "text": "<p>您可以使用 Remix 与 XCM 预编译合约进行交互。要将预编译合约添加到 Remix，您需要：</p> <ol> <li>获取 <code>XCMInterface.sol</code> 的副本</li> <li>将文件内容粘贴到名为 <code>XCMInterface.sol</code> 的 Remix 文件中</li> </ol>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/eth-api/#compile-the-contract", "title": "编译合约", "text": "<p>接下来，您需要在 Remix 中编译接口：</p> <ol> <li>点击顶部的第二个 Compile 选项卡</li> <li>通过点击 Compile XcmInterface.sol 编译接口</li> </ol> <p></p> <p>编译完成后，您将在 Compile 选项卡旁边看到一个绿色复选标记。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/eth-api/#access-the-contract", "title": "访问合约", "text": "<p>您将访问预编译合约的接口，而不是部署预编译合约，前提是您拥有预编译合约的地址：</p> <ol> <li>单击 Remix 中Compile（编译）选项卡正下方的 Deploy and Run（部署和运行）选项卡。请注意，预编译合约已在其各自的地址上可用。因此，没有部署步骤</li> <li>确保在 ENVIRONMENT（环境）下拉列表中选择了 Injected Provider - Metamask（注入提供程序 - Metamask）。选择 Injected Provider - Metamask（注入提供程序 - Metamask）后，如果您的帐户尚未连接到 Remix，MetaMask 可能会提示您将帐户连接到 Remix</li> <li>确保在 ACCOUNT（帐户）下显示正确的帐户</li> <li>确保在 CONTRACT（合约）下拉列表中选择了 XCM - XcmInterface.sol。鉴于它是一个预编译合约，因此没有部署步骤。相反，您需要在 At Address（在地址）字段中提供预编译合约的地址</li> <li>提供预编译合约的地址：<code>0x000000000000000000000000000000000000081A</code>，然后单击 At Address（在地址）</li> </ol> <p></p> <p>XCM 接口预编译将出现在 Deployed Contracts（已部署合约）列表中。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/eth-api/#transfer-to-evm-chains", "title": "将代币发送到另一个EVM兼容的Appchain", "text": "<p>要将代币发送到另一个EVM兼容的Appchain中的帐户，请按照以下步骤操作：</p> <ol> <li>展开 transferAssetsToPara20 函数</li> <li>输入appchain ID (paraId)</li> <li>输入20字节的（类似以太坊的）目标帐户（受益人）</li> <li>指定要转移的代币。请注意，此参数是一个数组，其中包含至少一项资产。每项资产由其地址和要转移的总金额指定</li> <li>输入将用于支付费用的资产的索引。此索引从零开始，因此第一个元素是 <code>0</code>，第二个是 <code>1</code>，依此类推</li> <li>点击 transact</li> <li>MetaMask将会弹出，并且您将被提示查看交易详情。点击 Confirm 以发送交易</li> </ol> <p></p> <p>交易确认后，等待几个区块，让转移到达目标链并反映新的余额。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/eth-api/#transfer-to-substrate-chains", "title": "将代币发送到 Substrate 应用链", "text": "<p>要将代币发送到 Substrate 应用链中的帐户，请按照以下步骤操作：</p> <ol> <li>展开 transferAssetsToPara32 函数</li> <li>输入应用链 ID (<code>paraId</code>)</li> <li>输入 sr25519 类型的目标帐户（受益人）</li> <li>指定要转移的代币。请注意，此参数是一个数组，其中包含至少一个资产。每个资产都由其地址和要转移的总金额指定</li> </ol> <p>!!! note        There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p> <ol> <li>输入将用于支付费用的资产的索引。此索引从零开始，因此第一个元素是 <code>0</code>，第二个元素是 <code>1</code>，依此类推</li> <li>点击 transact</li> <li>MetaMask 将弹出，并提示您查看交易详情。点击 Confirm 发送交易</li> </ol> <p></p> <p>交易确认后，请等待几个区块，以便转移到达目标链并反映新的余额。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/eth-api/#transfer-to-relay-chain", "title": "将代币发送到中继链", "text": "<p>要将代币发送到中继链中的帐户，请按照以下步骤操作：</p> <ol> <li>展开 transferAssetsToRelay 函数</li> <li>输入 sr25519 类型的目标帐户（受益人）</li> <li>指定要转移的代币。请注意，此参数是一个数组，其中包含至少一项资产。每项资产都由其地址和要转移的总金额指定</li> </ol> <p>!!! note        There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p> <ol> <li>输入将用于支付费用的资产的索引。此索引从零开始，因此第一个元素是 <code>0</code>，第二个元素是 <code>1</code>，依此类推</li> <li>点击 transact</li> <li>MetaMask 将会弹出，并且系统会提示您查看交易详情。点击 Confirm 以发送交易</li> </ol> <p></p> <p>交易确认后，请等待几个区块，以便转移到达目标链并反映新的余额。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/eth-api/#transfer-locations", "title": "在特定位置发送代币", "text": "<p>有两种方法与密切相关的方法共享名称，即 <code>transferAssetsUsingTypeAndThenLocation</code> 和 <code>transferAssetsUsingTypeAndThenAddress</code>。但是，这些不是重复项。对于每个函数，一个接受五个参数，另一个接受六个参数。只有当远程储备在资产和费用之间共享时，才能使用具有五个参数的函数。如果远程储备不在资产和费用之间共享，则可以使用该方法的六个参数版本来指定所需的信息。</p> <p>以下示例将演示当远程储备在资产和费用之间共享时如何使用 <code>transferAssetsUsingTypeAndThenAddress</code>。要按照本教程进行操作，请执行以下步骤：</p> <ol> <li>展开 transferAssetsUsingTypeAndThenAddress 函数</li> <li>输入指定目标链的多位置。请注意，可以指定任何链，无论其配置或类型如何</li> <li>输入要以地址格式发送的资产组合数组</li> <li>输入将用于支付费用的资产的索引。此索引从零开始，因此第一个元素是 <code>0</code>，第二个元素是 <code>1</code>，依此类推</li> <li>输入要在目标链上执行的 XCM 消息。有关创建 XCM 调用数据的更多信息，请参见发送和执行 XCM 消息</li> <li>输入远程储备，例如 <code>[1,[]]</code></li> <li>单击 transact</li> <li>MetaMask 将弹出，系统将提示您查看交易详细信息。单击确认以发送交易</li> </ol> <p></p> <p>确认交易后，请等待几个区块，以使转移到达目标链并反映新的余额。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/overview/", "title": "XC-20 转账概览", "text": ""}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/overview/#introduction", "title": "简介", "text": "<p>资产可以使用 XCM 在平行链之间移动。目前有两种主要方法：</p> <ul> <li>资产瞬移 – 销毁储备链上的代币，并在目标链上铸造相同数量的代币。每个链都持有原生资产作为储备，类似于销毁-铸造桥接机制。由于每个链都可以创建代币，因此需要一定程度的信任</li> <li>远程转移 – 将代币从储备链转移到主权账户（储备链上由目标链以无需信任方式控制的账户）。然后，目标链铸造一个包装（也称为“虚拟”或“跨链”）表示。这个包装版本始终可以与原始资产 1:1 互换，其功能类似于锁定-铸造和销毁-解锁桥。资产发源的链被称为储备链</li> </ul> <p></p> <p>Moonbeam 目前使用远程转移进行 XC-20 转移。</p> <p>本页介绍了基于 XCM 的远程转移的基本原理。要了解如何执行 XC-20 转移，请参阅通过 Substrate API 进行 XC-20 转移指南。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/overview/#xcm-instructions-for-asset-transfers", "title": "资产转移的 XCM 指令", "text": "<p>XCM Pallet 和 Precompile 抽象了跨链资产转移中涉及的许多复杂性，自动构建必要的 XCM 消息。尽管如此，对底层指令有一个基本的了解可能会很有用。</p> <p>作为参考，您可以在使用 Polkadot XCM Pallet 发送 XC-20 指南中找到用于发送 XC-20 的 Polkadot XCM Pallet extrinsic。</p> <p>每个 XCM 转移中的指令因资产和转移路线而异。例如，将像 xcDOT 这样的原生代币返回到其储备链（从 Moonbeam 到 Polkadot）与从 Polkadot 发送 DOT 到 Moonbeam 不同。以下是这些代币转移中常用指令的示例。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/overview/#transfer-native-from-origin", "title": "从储备链转移储备资产的说明", "text": "<p>When DOT is transferred from Polkadot to Moonbeam, the following XCM instructions are executed in sequence:</p> <ol> <li> <p><code>TransferReserveAsset</code> - executes on Polkadot, moving the DOT from the sender and depositing it into Moonbeam’s Sovereign account on Polkadot</p> </li> <li> <p><code>ReserveAssetDeposited</code> - executes on Moonbeam, minting the corresponding ERC-20 representation of DOT (xcDOT) on Moonbeam</p> </li> <li> <p><code>ClearOrigin</code> - executes on Moonbeam, clearing any origin data—previously set to Polkadot’s Sovereign account</p> </li> <li> <p><code>BuyExecution</code> - executes on Moonbeam, determining the execution fees. Here, a portion of the newly minted xcDOT is used to pay the cost of XCM</p> </li> <li> <p><code>DepositAsset</code> - executes on Moonbeam, delivering the xcDOT to the intended recipient’s account on Moonbeam</p> </li> </ol> <p>此过程会调用带有 <code>assets</code>、<code>dest</code> 和 <code>xcm</code> 参数的 <code>TransferReserveAsset</code>。在 <code>xcm</code> 参数中，您通常会指定 <code>BuyExecution</code> 和 <code>DepositAsset</code> 指令。如<code>TransferReserveAsset</code> 指令中所示，该流程还包括 <code>ReserveAssetDeposited</code> 和 <code>ClearOrigin</code> 以完成转移。</p> <p>有关构造用于资产转移（例如 DOT 到 Moonbeam）的 XCM 消息的更多信息，请参阅 Polkadot XCM Pallet 指南。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/overview/#transfer-native-to-origin", "title": "将储备资产转回储备链的说明", "text": "<p>In scenarios where you want to move an asset back to its reserve chain, such as sending xcDOT from Moonbeam to Polkadot, Moonbeam uses the following set of XCM instructions:</p> <ol> <li> <p><code>WithdrawAsset</code> – executes on Moonbeam, taking the specified token (xcDOT) from the sender</p> </li> <li> <p><code>InitiateReserveWithdraw</code> – executes on Moonbeam, which, burns the token on Moonbeam (removing the wrapped representation), and sends an XCM message to Polkadot, indicating the tokens should be released there </p> </li> <li> <p><code>WithdrawAsset</code> – executes on Polkadot, removing the tokens from Moonbeam’s Sovereign account on Polkadot</p> </li> <li> <p><code>ClearOrigin</code> – gets executed on Polkadot. Clears any origin data (e.g., the Sovereign account on Moonbeam)</p> </li> <li> <p><code>BuyExecution</code> – Polkadot determines the execution fees and uses part of the DOT being transferred to pay for them</p> </li> <li> <p><code>DepositAsset</code> – finally, the native DOT tokens are deposited into the specified Polkadot account</p> </li> </ol> <p>步骤 3 到 6 由 <code>InitiateReserveWithdraw</code> 指令（步骤 2）自动触发，并在 Polkadot 上执行。一旦在 Moonbeam 上调用 <code>InitiateReserveWithdraw</code>，组装好的 XCM 消息会指示 Polkadot 运行这些最终指令，从而完成跨链转移。换句话说，虽然 Moonbeam 在幕后构建 XCM 指令，但它们最终会在 Polkadot 上执行，以完成资产返回其储备链。</p> <p>有关构建 XCM 消息以将储备资产转移到目标链（例如 xcDOT 到 Polkadot）的更多信息，您可以参考 Polkadot XCM Pallet 指南。</p> <p>Note</p> <p>具体说明可能随时间而变化，但此总体流程保持一致：代币从 Moonbeam 上的用户处提取，从本地表示中销毁，并在储备链上解锁。在此过程结束时，它们在其储备链上再次完全可访问。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/", "title": "使用 Polkadot XCM Pallet 发送 XC-20s", "text": ""}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#introduction", "title": "简介", "text": "<p>Note</p> <p>Polkadot XCM Pallet 取代了已弃用的 XTokens Pallet。因此，请确保您使用 Polkadot XCM Pallet 与 XC-20 交互。</p> <p>手动创建用于同质化资产转移的 XCM 消息是一项具有挑战性的任务。因此，开发人员可以利用包装器函数和 pallet 在 Polkadot 和 Kusama 上使用 XCM 功能。其中一个包装器的例子是 XCM Pallet，它提供了通过 XCM 转移同质化资产的不同方法。</p> <p>本指南将向您展示如何利用 Polkadot XCM Pallet 将 XC-20 从基于 Moonbeam 的网络发送到生态系统中的其他链（中继链/平行链）。</p> <p>开发人员必须了解，发送不正确的 XCM 消息可能会导致资金损失。 因此，在转移到生产环境之前，在测试网上测试 XCM 功能至关重要。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#nomenclature", "title": "命名规范", "text": "<p>因为有各种与 XCM 相关的 pallet 和预编译合约，它们的名称听起来很相似，所以以下部分将阐明它们之间的区别。</p> <ul> <li><code>PolkadotXCM</code> - 此 pallet（也是此页面的重点）使您能够在 Moonbeam 上与 XC-20 交互，替换已弃用的 <code>XTokens</code> pallet</li> <li><code>pallet-xcm</code> - 通用的 Polkadot XCM pallet 允许您与跨链资产进行交互。Moonbeam 的 <code>PolkadotXCM</code> pallet 本质上是 <code>pallet-xcm</code> 的包装器。因此，您可能会看到 <code>PolkadotXCM</code> 和 <code>pallet-xcm</code> 被互换使用</li> <li><code>XTokens</code> - 此 pallet 现在已弃用，并由 <code>PolkadotXCM</code> 替代</li> <li><code>XCMInterface.sol</code> - 此预编译合约是 solidity 接口，可替换 <code>XTokens.sol</code>，并使您可以通过 solidity 接口从 EVM 与 <code>PolkadotXCM</code> 的方法进行交互</li> </ul>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#polkadotxcm-pallet-interface", "title": "Polkadot XCM Pallet 接口", "text": ""}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#extrinsics", "title": "Extrinsics", "text": "<p>Polkadot XCM Pallet 提供了以下 extrinsics（函数）：</p> forceDefaultXcmVersion(maybeXcmVersion) — 设置消息编码的安全默认 XCM 版本（仅限管理员） 参数 <ul> <li><code>maybeXcmVersion</code> - 当目标支持的版本未知时，要使用的默认 XCM 编码版本。可以是：<ul> <li>一个版本号</li> <li><code>None</code> 以禁用默认版本设置</li> </ul> </li> </ul> transferAssets(dest, beneficiary, assets, feeAssetItem, weightLimit) — 使用预留或传送方法将资产从本地链转移到目标链 参数 <ul> <li><code>dest</code> - 资产的目标上下文。通常指定为：<ul> <li><code>X2(Parent, Parachain(..))</code> 用于平行链到平行链的转移</li> <li><code>X1(Parachain(..))</code> 用于中继链到平行链的转移</li> </ul> </li> <li><code>beneficiary</code> - 目标上下文中收款人的位置。通常是 <code>AccountId32</code> 值</li> <li><code>assets</code> - 要转移的资产。必须：<ul> <li>具有相同的预留位置或可传送到目的地（不包括手续费资产）</li> <li>包括用于支付手续费的资产</li> </ul> </li> <li><code>feeAssetItem</code> - <code>assets</code> 数组中指示应使用哪种资产来支付手续费的索引</li> <li><code>weightLimit</code> - 目标链上 XCM 手续费购买的权重限制。可以定义为：<ul> <li><code>Unlimited</code> - 允许无限量的权重</li> <li><code>Limited</code> - 指定最大权重值</li> </ul> </li> </ul> <p>转移行为根据资产类型而异：</p> <ul> <li> <p>本地预留：</p> <ul> <li>将资产转移到目标链的主权账户</li> <li>发送 XCM 以铸造并存入基于预留的资产到收款人</li> </ul> </li> <li> <p>目标预留：</p> <ul> <li>销毁本地资产</li> <li>通知目标链从该链的主权账户中提取预留</li> <li>存入收款人</li> </ul> </li> <li> <p>远程预留：</p> <ul> <li>销毁本地资产</li> <li>发送 XCM 以在主权账户之间移动预留</li> <li>通知目标链铸造并存入收款人</li> </ul> </li> <li> <p>传送：</p> <ul> <li>销毁本地资产</li> <li>发送 XCM 以铸造/传送资产并存入收款人</li> </ul> </li> </ul> <p>提醒一下，发起人必须能够提取指定的资产并执行 XCM。如果需要的权重超过 <code>weightLimit</code> 中指定的权重，操作将失败，并且传送的资产可能面临风险</p> transferAssetsUsingTypeAndThen(dest, assets, assetsTransferType, remoteFeesId, feesTransferType, customXcmOnDest, weightLimit) — 使用显式转移类型和自定义目标行为转移资产 参数 <ul> <li><code>dest</code> - 资产的目标上下文。可以指定为：<ul> <li><code>[Parent, Parachain(..)]</code> 用于平行链到平行链的转移</li> <li><code>[Parachain(..)]</code> 用于中继链到平行链的转移</li> <li><code>(parents: 2, (GlobalConsensus(..), ..))</code> 用于跨桥生态系统转移</li> </ul> </li> <li><code>assets</code> - 要转移的资产。必须：<ul> <li>具有相同的预留位置</li> <li>可传送到目的地</li> </ul> </li> <li><code>assetsTransferType</code> - 指定应如何转移主要资产：<ul> <li><code>LocalReserve</code> - 转移到主权账户，在目标链上铸造</li> <li><code>DestinationReserve</code> - 在本地销毁，从目标链的主权账户中提取</li> <li><code>RemoteReserve(reserve)</code> - 在本地销毁，通过指定的链（通常是 Asset Hub）移动预留</li> <li><code>Teleport</code> - 在本地销毁，在目标链上铸造/传送</li> </ul> </li> <li><code>remoteFeesId</code> - 指定应使用包含的哪些资产来支付手续费</li> <li><code>feesTransferType</code> - 指定应如何转移手续费支付资产（与 <code>assetsTransferType</code> 相同的选项）</li> <li><code>customXcmOnDest</code> - 在目标链上作为最后一步执行的 XCM 指令。通常用于：<ul> <li>将资产存入收款人：<code>Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])</code></li> <li>或使用转移的资产执行更复杂的操作</li> </ul> </li> <li><code>weightLimit</code> - 目标链上 XCM 手续费购买的权重限制。可以定义为：<ul> <li><code>Unlimited</code> - 允许无限量的权重</li> <li><code>Limited</code> - 指定最大权重值</li> </ul> </li> </ul> <p>一些提醒：</p> <ul> <li><code>BuyExecution</code> 用于使用指定的 <code>remoteFeesId</code> 资产购买执行时间</li> <li>手续费支付资产可以使用与主要资产不同的转移类型</li> <li>发起人必须能够提取指定的资产并执行 XCM</li> <li>如果需要的权重超过 <code>weightLimit</code> 中指定的权重，操作将失败，并且转移的资产可能面临风险</li> </ul>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#storage-methods", "title": "存储方法", "text": "<p>Polkadot XCM Pallet 包含以下只读存储方法。请注意，这并非详尽的列表。要查看当前可用的存储方法，请查看 Polkadot.js Apps 的链状态。</p> assetTraps(h256 hash) — 返回给定哈希的被困资产的计数 参数返回值Polkadot.js API 示例 <ul> <li><code>hash</code>: <code>H256</code> - 资产陷阱的哈希标识符。当资产被困时，会为其分配唯一的哈希标识符。您可以省略此字段以返回有关所有被困资产的信息</li> </ul> <p>返回一个 <code>U32</code>（无符号 32 位整数），表示资产在此哈希位置被困的次数。 <pre><code>// 示例返回值显示哈希 → 计数映射\n[\n  [[0x0140f264543926e689aeefed15a8379f6e75a8c6884b0cef0832bb913a343b53], 1],\n  [[0x0d14fd8859d8ff15dfe4d4002b402395129cdc4b69dea5575efa1dc205b96020], 425],\n  [[0x166f82439fd2b25b28b82224e82ad9f26f2da26b8257e047182a6a7031accc9a], 3]\n]\n</code></pre></p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://wss.api.moonbeam.network'),\n  });\n\n  const hash =\n    '0x166f82439fd2b25b28b82224e82ad9f26f2da26b8257e047182a6a7031accc9a';\n  const trapCount = await api.query.polkadotXcm.assetTraps(hash);\n\n  console.log('Trap count:', trapCount.toNumber());\n};\n\nmain();\n</code></pre> queryCounter() — 最新的可用查询索引 参数返回值Polkadot.js API 示例 <p>无</p> <p><code>u64</code> - 最新的可用查询索引</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://wss.api.moonbeam.network'),\n  });\n\n  const queryIndex = await api.query.polkadotXcm.queryCounter();\n\n  console.log('Query Index:', queryIndex.toNumber());\n};\n\nmain();\n</code></pre> safeXcmVersion() — 当目标版本未知时，用于编码 XCM 的默认版本 参数返回值Polkadot.js API 示例 <p>无</p> <p><code>u32</code> - 当目标版本未知时，用于编码 XCM 的默认版本</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://wss.api.moonbeam.network'),\n  });\n\n  const safeVersion = await api.query.polkadotXcm.safeXcmVersion();\n\n  console.log('Safe XCM Version:', safeVersion.toHuman());\n};\n\nmain();\n</code></pre> supportedVersion(XcmVersion, Multilocation) — 返回给定位置支持的 XCM 版本 参数返回值Polkadot.js API 示例 <ul> <li>version <code>u32</code>: XcmVersion - 要检查的版本号</li> <li>location: MultiLocation - 要检查版本支持的位置</li> </ul> <p>返回位置到其支持的 XCM 版本的映射。每个条目包含一个 MultiLocation，指定平行链位置（包括父级和内部信息）以及一个 XcmVersion 编号，指示支持的版本</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://wss.api.moonbase.moonbeam.network'),\n  });\n\n  const testLocation = {\n    V4: {\n      parents: 1,\n      interior: 'Here',\n    },\n  };\n\n  const supportedVersion = await api.query.polkadotXcm.supportedVersion(\n    4, // Testing XCM v4\n    testLocation\n  );\n\n  console.log('Location:', JSON.stringify(testLocation, null, 2));\n  console.log('Supported Version:', supportedVersion.toHuman());\n};\n\nmain();\n</code></pre> palletVersion() — 从存储返回当前的 pallet 版本 参数返回值Polkadot.js API 示例 <p>无</p> <p>表示 pallet 当前版本的数字。</p> <pre><code>// 如果使用 Polkadot.js API 并在未包装的值上调用 toJSON()\n0\n</code></pre> <pre><code> import { ApiPromise, WsProvider } from '@polkadot/api';\n\n const main = async () =&gt; {\n   const api = await ApiPromise.create({\n     provider: new WsProvider('wss://wss.api.moonbase.moonbeam.network'),\n   });\n   const palletVersion = await api.query.polkadotXcm.palletVersion();\n   console.log(\"The pallet version is \" + palletVersion);\n };\n\n main();\n</code></pre>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#constants", "title": "Pallet 常量", "text": "<p>Polkadot XCM pallet 没有常量部分。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#build-with-PolkadotXCM-pallet", "title": "使用 Polkadot XCM Pallet 构建 XCM 消息", "text": "<p>本指南介绍了使用 Polkadot XCM Pallet 构建 XCM 消息的过程，特别是 <code>transferAssets</code> 函数。</p> <p>Note</p> <p>每个平行链都可以允许和禁止来自托盘的特定方法。因此，开发人员必须确保他们使用允许的方法，否则交易将失败，并出现类似于 <code>system.CallFiltered</code> 的错误。</p> <p>您将传输 xcUNIT 代币，它是 Alphanet 中继链代币 UNIT 的 XC-20 表示形式。您可以针对任何其他 XC-20 调整本指南。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#polkadotxcm-check-prerequisites", "title": "检查先决条件", "text": "<p>要按照本指南中的示例进行操作，您需要具备以下条件：</p> <ul> <li>一个有资金的帐户。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li> <p>一些 xcUNIT 代币。您可以在 Moonbeam-Swap 上将 DEV 代币（Moonbase Alpha 的原生代币）兑换为 xcUNIT，这是一个 Moonbase Alpha 上的演示 Uniswap-V2 克隆</p> <p>Note</p> <p>您可以调整本指南以转移另一个 外部 XC-20 或本地 XC-20。对于外部 XC-20，您需要资产 ID 和资产具有的小数位数。对于本地 XC-20，您需要合约地址。</p> <p></p> </li> </ul> <p>要检查您的 xcUNIT 余额，您可以将 XC-20 的 预编译地址 添加到 MetaMask，地址如下：</p> <pre><code>0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080\n</code></pre>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#polkadotxcm-transfer-assets-function", "title": "Polkadot XCM 转移资产函数", "text": "<p>在此示例中，您将构建一条 XCM 消息，以通过 Polkadot XCM Pallet 的 <code>transferAssets</code> 函数，使用 Polkadot.js API，将 xcUNIT 从 Moonbase Alpha 转移回 Alphanet 中继链。</p> <p>要使用 <code>polkadotXcm</code> pallet 执行有限的储备转移，请按照以下步骤操作：</p> <ol> <li> <p>安装所需的依赖项：用于区块链交互的 <code>@polkadot/api</code>，用于实用函数的 <code>@polkadot/util</code>，以及用于加密函数的 <code>@polkadot/util-crypto</code>。</p> </li> <li> <p>通过使用 Moonbase Alpha 端点 <code>wss://wss.api.moonbase.moonbeam.network</code> 创建 WebSocket 提供程序来设置您的网络连接。 使用此提供程序初始化 Polkadot API。</p> </li> <li> <p>使用以太坊格式配置您的帐户。 为以太坊地址创建一个密钥环实例，然后使用您的私钥添加您的帐户。 请记住在私钥前加上 <code>0x</code>，从 MetaMask 导出密钥时会省略该前缀。</p> <p>Remember</p> <p>这仅用于演示目的。 切勿将您的私钥存储在 JavaScript 文件中。</p> </li> <li> <p>通过使用 <code>decodeAddress</code> 函数将 SS58 格式地址转换为原始字节来准备目标地址。 如果目标 SS58 地址已经是十六进制格式，则无需转换。</p> </li> <li> <p>构建 XCM 转移交易，包含：中继链作为目标（具有 <code>parents: 1</code> 的父链）、受益人（使用 <code>AccountId32</code> 格式）、资产（金额，具有 12 位小数）、费用资产项 (0) 和权重限制（“无限制”）。</p> 定义目标、受益人和资产 <pre><code> // dest\n      {\n        V4: {\n          parents: 1,\n          interior: {\n            Here: null\n          }\n        }\n      },\n      // beneficiary\n      {\n        V4: {\n          parents: 1,                   \n          interior: {\n            X1: [                        \n              {\n                AccountId32: {\n                  id: Array.from(beneficiaryRaw),\n                  network: null\n                }\n              }\n            ]\n          }\n        }\n      },\n      // assets\n      {\n        V4: [                           \n          {\n            fun: {                      \n              Fungible: 1000000000000n \n            },\n            id: {                       \n              parents: 1,\n              interior: {\n                Here: null              \n              }\n            }\n          }\n        ]\n      },\n      0,           // feeAssetItem\n      'Unlimited'  // weightLimit\n    );\n</code></pre> </li> <li> <p>提交您的交易并实施带有错误处理的监控逻辑。</p> </li> <li> <p>交易完成后，脚本将自动退出。 过程中的任何错误都将记录到控制台以进行故障排除。</p> </li> </ol> 查看完整脚本 <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api';\nimport { decodeAddress } from '@polkadot/util-crypto';\n\nconst main = async () =&gt; {\n  // Setup provider and API\n  const wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Setup account with ethereum format\n  const keyring = new Keyring({ type: 'ethereum' });\n  const account = keyring.addFromUri('INSERT_PRIVATE_KEY');\n\n  // Convert the SS58 address to raw bytes\n  const beneficiaryRaw = decodeAddress('INSERT_DESTINATION_ADDRESS');\n\n  try {\n    // Create the transaction (XCM v4)\n    const tx = api.tx.polkadotXcm.transferAssets(\n      // Destination (V4)\n      {\n        V4: {\n          parents: 1,\n          interior: {\n            Here: null\n          }\n        }\n      },\n      // Beneficiary (V4)\n      {\n        V4: {\n          parents: 1,\n          interior: {\n            X1: [\n              {\n                AccountId32: {\n                  network: null,\n                  id: beneficiaryRaw\n                }\n              }\n            ]\n          }\n        }\n      },\n      // Assets (V4)\n      {\n        V4: [\n          {\n            fun: {\n              Fungible: 1000000000000n\n            },\n            id: {\n              parents: 1,\n              interior: {\n                Here: null\n              }\n            }\n          }\n        ]\n      },\n      0,           // feeAssetItem\n      'Unlimited'  // weightLimit\n    );\n\n    // Sign and send the transaction\n    const unsub = await tx.signAndSend(account, ({ status }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in blockHash ${status.asInBlock}`);\n      } else if (status.isFinalized) {\n        console.log(`Transaction finalized in blockHash ${status.asFinalized}`);\n        unsub();\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error:', error);\n    process.exit(1);\n  }\n};\n\nmain().catch(console.error);\n</code></pre> <p>Note</p> <p>您可以在 Polkadot.js Apps 上查看上述脚本的示例，该脚本将 1 个 xcUNIT 发送到中继链上的 Alice 帐户，使用以下编码的 calldata：<code>0x1c0b0401000400010100d4620637e11439598c5fbae0506dc68b9fb1edb33b316761bf99987a1034a96b0404010000070010a5d4e80000000000</code>。</p> <p>交易处理完毕后，中继链上的目标帐户应已收到转移的金额，减去为在目标链上执行 XCM 而扣除的一小笔费用。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#_1", "title": "故障排除", "text": "<p>如果您在复制演示时遇到困难，请采取以下故障排除步骤：</p> <ul> <li>确保您的发送账户中有足够的 DEV 代币</li> <li>确保您的发送账户中有足够的 xcUNIT 代币（或您指定的其他 XC-20 代币）</li> <li>在 Moonbase Alpha 上的 Polkadot.js Apps 上检查 Explorer，以确保在源链上成功完成交易</li> <li>在 Polkadot.js Apps 上检查 Explorer，并查看 Moonbase 中继链上收到的 XCM 消息</li> </ul>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/", "title": "使用 X-Tokens 预编译发送 XC-20s", "text": ""}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#introduction", "title": "简介", "text": "<p>构建用于可替换资产转移的 XCM 消息并非易事。因此，开发人员可以利用包装函数和托盘在 Polkadot 和 Kusama 上使用 XCM 功能。此类包装器的一个示例是 Polkadot XCM 托盘，它提供了通过 XCM 转移可替换资产的不同方法。</p> <p>Polkadot XCM 托盘 以 Rust 编码，通常无法从 Moonbeam 的 Ethereum API 端访问。但是，XCM 预编译 和 X-Tokens 预编译允许您直接与 Polkadot XCM 托盘交互，以从 Solidity 接口发送 XC-20。</p> <p>本指南将向您展示如何利用 X-Tokens 预编译，使用 Ethers 和 Web3 等 Ethereum 库将 XC-20 从基于 Moonbeam 的网络发送到生态系统中的其他链（中继链/平行链）。</p> <p>开发人员必须了解，发送不正确的 XCM 消息可能会导致资金损失。 因此，在进入生产环境之前，必须在 TestNet 上测试 XCM 功能。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#contract-address", "title": "X-Tokens 预编译合约地址", "text": "<p>X-Tokens 预编译合约位于以下地址：</p> MoonbeamMoonriverMoonbase Alpha <p>text  0x0000000000000000000000000000000000000804</p> <p>text  0x0000000000000000000000000000000000000804</p> <p>text  0x0000000000000000000000000000000000000804</p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#xtokens-solidity-interface", "title": "X-Tokens Solidity 接口", "text": "<p>Xtokens.sol 是一个接口，开发人员可以通过它使用 Ethereum API 与 X-Tokens Pallet 进行交互。</p> Xtokens.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Xtokens contract's address.\naddress constant XTOKENS_ADDRESS = 0x0000000000000000000000000000000000000804;\n\n/// @dev The Xtokens contract's instance.\nXtokens constant XTOKENS_CONTRACT = Xtokens(XTOKENS_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Xtokens Interface\n/// @dev The interface through which solidity contracts will interact with xtokens pallet\n/// @custom:address 0x0000000000000000000000000000000000000804\ninterface Xtokens {\n    // A multilocation is defined by its number of parents and the encoded junctions (interior)\n    struct Multilocation {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    // A MultiAsset is defined by a multilocation and an amount\n    struct MultiAsset {\n        Multilocation location;\n        uint256 amount;\n    }\n\n    // A Currency is defined by address and the amount to be transferred\n    struct Currency {\n        address currencyAddress;\n        uint256 amount;\n    }\n\n    /// Transfer a token through XCM based on its currencyId\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param currencyAddress The ERC20 address of the currency we want to transfer\n    /// @param amount The amount of tokens we want to transfer\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector b9f813ff\n    function transfer(\n        address currencyAddress,\n        uint256 amount,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer a token through XCM based on its currencyId specifying fee\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param currencyAddress The ERC20 address of the currency we want to transfer\n    /// @param amount The amount of tokens we want to transfer\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector 3e506ef0\n    function transferWithFee(\n        address currencyAddress,\n        uint256 amount,\n        uint256 fee,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer a token through XCM based on its MultiLocation\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param asset The asset we want to transfer, defined by its multilocation.\n    /// Currently only Concrete Fungible assets\n    /// @param amount The amount of tokens we want to transfer\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector b4f76f96\n    function transferMultiasset(\n        Multilocation memory asset,\n        uint256 amount,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer a token through XCM based on its MultiLocation specifying fee\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param asset The asset we want to transfer, defined by its multilocation.\n    /// Currently only Concrete Fungible assets\n    /// @param amount The amount of tokens we want to transfer\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector 150c016a\n    function transferMultiassetWithFee(\n        Multilocation memory asset,\n        uint256 amount,\n        uint256 fee,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer several tokens at once through XCM based on its address specifying fee\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param currencies The currencies we want to transfer, defined by their address and amount.\n    /// @param feeItem Which of the currencies to be used as fee\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector ab946323\n    function transferMultiCurrencies(\n        Currency[] memory currencies,\n        uint32 feeItem,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer several tokens at once through XCM based on its location specifying fee\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param assets The assets we want to transfer, defined by their location and amount.\n    /// @param feeItem Which of the currencies to be used as fee\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector 797b45fd\n    function transferMultiAssets(\n        MultiAsset[] memory assets,\n        uint32 feeItem,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n}\n</code></pre> <p>该接口包括以下函数：</p> transfer(address currencyAddress, uint256 amount, Multilocation memory destination, uint64 weight) — 转移一种货币，给定货币的合约地址 参数 <ul> <li><code>currencyAddress</code> - 要转移的资产的地址<ul> <li>对于 外部 XC-20，请提供 XC-20 预编译地址</li> <li>对于原生代币（即 GLMR、MOVR 和 DEV），请提供 ERC-20 预编译 地址，该地址为 <code>0x0000000000000000000000000000000000000802</code></li> <li>对于 本地 XC-20，请提供代币的地址</li> </ul> </li> <li><code>amount</code> - 将通过 XCM 发送的代币数量</li> <li><code>destination</code> - 通过 XCM 发送的代币的目标地址的多位置。它支持不同的地址格式，例如 20 字节或 32 字节地址（Ethereum 或 Substrate）。多位置必须以特定方式格式化，这在 构建预编译多位置 部分中进行了描述</li> <li><code>weight</code> - 要购买的权重，用于支付目标链上 XCM 执行的费用，该费用从转移的资产中扣除</li> </ul> transferWithFee(address currencyAddress, uint256 amount, uint256 fee, Multilocation memory destination, uint64 weight) — 转移一种货币，定义为原生代币（自留）或资产 ID，并从金额中单独指定费用 参数 <ul> <li><code>currencyAddress</code> - 要转移的资产的地址<ul> <li>对于 外部 XC-20，请提供 XC-20 预编译地址</li> <li>对于原生代币（即 GLMR、MOVR 和 DEV），请提供 ERC-20 预编译 地址，该地址为 <code>0x0000000000000000000000000000000000000802</code></li> <li>对于 本地 XC-20，请提供代币的地址</li> </ul> </li> <li><code>amount</code> - 将通过 XCM 发送的代币数量</li> <li><code>fee</code> — 用于支付目标（目的地）链中 XCM 执行的金额。如果此值不足以支付执行成本，则资产将困在目标链中</li> <li><code>destination</code> - 通过 XCM 发送的代币的目标地址的多位置。它支持不同的地址格式，例如 20 字节或 32 字节地址（Ethereum 或 Substrate）。多位置必须以特定方式格式化，这在 构建预编译多位置 部分中进行了描述</li> <li><code>weight</code> - 要购买的权重，用于支付目标链上 XCM 执行的费用，该费用从转移的资产中扣除</li> </ul> transferMultiasset(Multilocation memory asset, uint256 amount, Multilocation memory destination, uint64 weight) — 转移一种可替代资产，由其多位置定义 参数 <ul> <li><code>asset</code> - 要转移的资产的多位置。多位置必须以特定方式格式化，这在 构建预编译多位置 部分中进行了描述</li> <li><code>amount</code> - 将通过 XCM 发送的代币数量</li> <li><code>destination</code> - 通过 XCM 发送的代币的目标地址的多位置。它支持不同的地址格式，例如 20 字节或 32 字节地址（Ethereum 或 Substrate）。多位置必须以特定方式格式化，这在 构建预编译多位置 部分中进行了描述</li> <li><code>weight</code> - 要购买的权重，用于支付目标链上 XCM 执行的费用，该费用从转移的资产中扣除</li> </ul> transferMultiassetWithFee(Multilocation memory asset, uint256 amount, uint256 fee, Multilocation memory destination, uint64 weight) — 转移一种可替代资产，由其多位置定义，并以不同的资产（也由其多位置定义）支付费用 参数 <ul> <li><code>asset</code> - 要转移的资产的多位置。多位置必须以特定方式格式化，这在 构建预编译多位置 部分中进行了描述</li> <li><code>amount</code> - 将通过 XCM 发送的代币数量</li> <li><code>fee</code> — 用于支付目标（目的地）链中 XCM 执行的金额。如果此值不足以支付执行成本，则资产将困在目标链中</li> <li><code>destination</code> - 通过 XCM 发送的代币的目标地址的多位置。它支持不同的地址格式，例如 20 字节或 32 字节地址（Ethereum 或 Substrate）。多位置必须以特定方式格式化，这在 构建预编译多位置 部分中进行了描述</li> <li><code>weight</code> - 要购买的权重，用于支付目标链上 XCM 执行的费用，该费用从转移的资产中扣除</li> </ul> transferMulticurrencies(Currency[] memory currencies, uint32 feeItem, Multilocation memory destination, uint64 weight) — 转移不同的货币，指定哪种货币用作费用。每种货币都定义为原生代币（自留）或资产 ID 参数 <ul> <li><code>currencies</code> - 要发送的货币的数组，这些货币由其货币地址和要发送的金额标识</li> <li><code>feeItem</code> — 一个索引，用于定义要发送的资产数组的资产位置，用于支付目标链中 XCM 执行的费用。例如，如果只发送一种资产，则 <code>feeItem</code> 将为 <code>0</code></li> <li><code>destination</code> - 通过 XCM 发送的代币的目标地址的多位置。它支持不同的地址格式，例如 20 字节或 32 字节地址（Ethereum 或 Substrate）。多位置必须以特定方式格式化，这在 构建预编译多位置 部分中进行了描述</li> <li><code>weight</code> - 要购买的权重，用于支付目标链上 XCM 执行的费用，该费用从转移的资产中扣除</li> </ul> transferMultiassets(MultiAsset[] memory assets, uint32 feeItem, Multilocation memory destination, uint64 weight) — 转移几种可替代资产，由其多位置定义，并以其中一种资产（也由其多位置定义）支付费用 参数 <ul> <li><code>assets</code> - 要转移的每种资产的多位置数组。多位置必须以特定方式格式化，这在 构建预编译多位置 部分中进行了描述</li> <li><code>feeItem</code> — 一个索引，用于定义要发送的资产数组的资产位置，用于支付目标链中 XCM 执行的费用。例如，如果只发送一种资产，则 <code>feeItem</code> 将为 <code>0</code></li> <li><code>destination</code> - 通过 XCM 发送的代币的目标地址的多位置。它支持不同的地址格式，例如 20 字节或 32 字节地址（Ethereum 或 Substrate）。多位置必须以特定方式格式化，这在 构建预编译多位置 部分中进行了描述</li> <li><code>weight</code> - 要购买的权重，用于支付目标链上 XCM 执行的费用，该费用从转移的资产中扣除</li> </ul>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#building-the-precompile-multilocation", "title": "构建预编译多重定位", "text": "<p>多重定位定义了相对于给定原点的整个中继链/平行链生态系统中的特定点。它们经常被 X-Tokens 预编译用来定义资产和目标链及账户的位置。</p> <p>多重定位需要以预编译可以理解的特定方式进行格式化，这与和 pallet 交互时看到的格式不同。在 X-Tokens 预编译接口中，<code>Multilocation</code> 结构定义如下：</p> <pre><code> struct Multilocation {\n    uint8 parents;\n    bytes[] interior;\n}\n</code></pre> <p>As with a standard multilocation, there are <code>parents</code> and <code>interior</code> elements. However, instead of defining the multilocation as an object, with Ethereum libraries, the struct is defined as an array, which contains a <code>uint8</code> for the <code>parents</code> as the first element and a bytes array for the <code>interior</code> as the second element.</p> <p>The normal values you would see for the <code>parents</code> element are:</p> Origin Destination Parents Value Parachain A Parachain A 0 Parachain A Relay Chain 1 Parachain A Parachain B 1 <p>For the <code>interior</code> element, the number of fields you need to drill down to in the target chain to reach the exact location of the target, such as the specific asset or account, represents the size of the bytes array:</p> Array Size Interior Value [] 0 Here [XYZ] 1 X1 [XYZ, ABC] 2 X2 [XYZ, ... N] N XN <p>Note</p> <p>Interior value <code>Here</code> is often used for the relay chain (either as a destination or to target the relay chain asset).</p> <p>Each field required to reach the exact location of the target needs to be defined as a hex string. The first byte (2 hexadecimal characters) corresponds to the selector of the field. For example:</p> Byte Value Selector Data Type 0x00 Parachain bytes4 0x01 AccountId32 bytes32 0x02 AccountIndex64 u64 0x03 AccountKey20 bytes20 0x04 PalletInstance byte 0x05 GeneralIndex u128 0x06 GeneralKey bytes[] <p>Next, depending on the selector and its data type, the following bytes correspond to the actual data being provided. Note that for <code>AccountId32</code>, <code>AccountIndex64</code>, and <code>AccountKey20</code>, the optional <code>network</code> field is appended at the end. For example:</p> Selector Data Value Represents Parachain \"0x00+000007E7\" Parachain ID 2023 AccountId32 \"0x01+AccountId32+00\" AccountId32, Network(Option) Null AccountId32 \"0x01+AccountId32+03\" AccountId32, Network Polkadot AccountKey20 \"0x03+AccountKey20+00\" AccountKey20, Network(Option) Null PalletInstance \"0x04+03\" Pallet Instance 3 <p>Note</p> <p>The <code>interior</code> data usually needs to be wrapped around quotes, or you might get an <code>invalid tuple value</code> error.</p> <p>以下代码片段提供了一些多重定位结构的示例，它们需要被提供给 X-Tokens 预编译函数：</p> <pre><code>// Multilocation targeting the relay chain or its asset from a parachain\n[\n  1, // parents = 1\n  [], // interior = here\n]\n\n// Multilocation targeting Moonbase Alpha DEV token from another parachain\n[\n  1, // parents = 1\n  [  // interior = X2 (the array has a length of 2)\n    '0x00000003E8', // Parachain selector + Parachain ID 1000 (Moonbase Alpha)\n    '0x0403', // Pallet Instance selector + Pallet Instance 3 (Balances Pallet)\n  ],\n]\n\n// Multilocation targeting Alice's account on the relay chain from Moonbase Alpha\n[\n  1, // parents = 1\n  [  // interior = X1 (the array has a length of 1)\n     // AccountKey32 selector + AccountId32 address in hex + Network(Option) Null\n    '0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300', \n  ],\n]\n</code></pre>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#build-xcm-xtokens-precompile", "title": "构建 XCM 消息", "text": "<p>本指南介绍了使用 X-Tokens 预编译构建 XCM 消息的过程，更具体地说，是使用 <code>transfer</code> 和 <code>transferMultiasset</code> 函数。然而，这两个用例可以推广到预编译的其他函数，特别是当您熟悉多位置时。</p> <p>您将传输 xcUNIT 代币，它们是 Alphanet 中继链代币 UNIT 的 XC-20 表示。您可以针对任何其他 XC-20 调整本指南。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#xtokens-check-prerequisites", "title": "检查先决条件", "text": "<p>要学习本指南中的示例，您需要具备以下条件：</p> <ul> <li> <p>X-Tokens预编译合约的ABI</p> X-Tokens预编译合约ABI <pre><code>export default [\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'currencyAddress',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transfer',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              {\n                internalType: 'uint8',\n                name: 'parents',\n                type: 'uint8',\n              },\n              {\n                internalType: 'bytes[]',\n                name: 'interior',\n                type: 'bytes[]',\n              },\n            ],\n            internalType: 'struct Xtokens.Multilocation',\n            name: 'location',\n            type: 'tuple',\n          },\n          {\n            internalType: 'uint256',\n            name: 'amount',\n            type: 'uint256',\n          },\n        ],\n        internalType: 'struct Xtokens.MultiAsset[]',\n        name: 'assets',\n        type: 'tuple[]',\n      },\n      {\n        internalType: 'uint32',\n        name: 'feeItem',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferMultiAssets',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'address',\n            name: 'currencyAddress',\n            type: 'address',\n          },\n          {\n            internalType: 'uint256',\n            name: 'amount',\n            type: 'uint256',\n          },\n        ],\n        internalType: 'struct Xtokens.Currency[]',\n        name: 'currencies',\n        type: 'tuple[]',\n      },\n      {\n        internalType: 'uint32',\n        name: 'feeItem',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferMultiCurrencies',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'asset',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferMultiasset',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'asset',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: 'fee',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferMultiassetWithFee',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'currencyAddress',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: 'fee',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferWithFee',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> </li> <li> <p>一个有资金的账户。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</p> </li> <li> <p>一些xcUNIT代币。您可以在Moonbeam-Swap上使用DEV代币（Moonbase Alpha的本地代币）兑换xcUNIT，Moonbeam-Swap是Moonbase Alpha上的一个演示版的Uniswap-V2克隆。</p> <p>Note</p> <p>您可以修改本指南以转移另一个外部XC-20或者本地XC-20。对于外部XC-20，您需要资产ID和资产的小数位数。对于本地XC-20，您需要合约地址。</p> <p></p> <p>要检查您的xcUNIT余额，您可以将XC-20的预编译地址添加到MetaMask，地址如下：</p> <pre><code>0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080\n</code></pre> </li> </ul> <p>Note</p> <p>要在Moonbeam或Moonriver上测试这些示例，您可以将RPC URL替换为您自己的端点和API密钥，您可以从受支持的端点提供商处获得。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#determining-weight", "title": "确定 XCM 执行所需的权重", "text": "<p>要确定目标链上 XCM 执行所需的权重，您需要知道哪些 XCM 指令在目标链上执行。您可以在通过 X-Tokens 进行传输的 XCM 指令指南中找到使用的 XCM 指令的概述。</p> <p>Note</p> <p>一些权重包括数据库读取和写入；例如，<code>WithdrawAsset</code> 和 <code>DepositAsset</code> 指令既包括一个数据库读取又包括一个写入。要获得总权重，您需要将任何必需的数据库读取或写入的权重添加到给定指令的基本权重中。</p> <p>对于基于 Westend 的中继链，如 Alphanet，您可以在 GitHub 上的 polkadot-sdk存储库中获得 Rocks DB（这是默认数据库）的读取和写入数据库操作的权重成本。</p> <p>由于 Alphanet 是基于 Westend 的中继链，因此您可以参考Westend 运行时代码中定义的指令权重，这些指令权重分为两种类型：可替代和 通用。</p> <p>重要的是要注意，每个链都定义了自己的权重要求。要确定给定链上每个 XCM 指令所需的权重，请参阅链的文档或联系其团队成员.要了解如何查找 Moonbeam、Polkadot 或 Kusama 所需的权重，您可以参考我们关于权重和费用的文档。</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#precompile-transfer", "title": "X-Tokens 预编译传输函数", "text": "<p>要使用 X-Tokens 预编译的 <code>transfer</code> 函数，您需要执行以下常规步骤：</p> <ol> <li>使用 Moonbase Alpha RPC 端点创建一个 provider</li> <li>创建一个签名者来发送交易。此示例使用私钥来创建签名者，仅用于演示目的。切勿将您的私钥存储在 JavaScript 文件中</li> <li>使用预编译的地址和 ABI 创建 X-Tokens 预编译的合约实例</li> <li> <p>组装 <code>transfer</code> 函数的参数：</p> <ul> <li><code>currencyAddress</code> - xcUNIT 的地址：<code>0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080</code></li> <li><code>amount</code> - 1 xcUNIT。由于 xcUNIT 有 12 位小数，您可以使用：<code>1000000000000</code></li> <li><code>destination</code> - 目标的多重定位，它定位中继链上的 Alice 的帐户：<code>'0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'</code></li> <li><code>weight</code> - 为目标链上的 XCM 执行购买的权重：<code>305,986,000</code></li> </ul> </li> <li> <p>创建 <code>transfer</code> 函数，传入参数</p> </li> <li>签名并发送交易</li> </ol> Ethers.jsWeb3.jsWeb3.py <p>js import { ethers } from 'ethers'; // Import Ethers library import abi from './xtokensABI.js'; // Import the X-Tokens ABI</p> <p>const privateKey = 'INSERT_PRIVATE_KEY';</p> <p>// Create Ethers provider and signer const provider = new ethers.JsonRpcProvider(   'https://rpc.api.moonbase.moonbeam.network' ); const signer = new ethers.Wallet(privateKey, provider);</p> <p>// Create X-Tokens contract instance const xTokens = new ethers.Contract(   '0x0000000000000000000000000000000000000804',   abi,   signer );</p> <p>// Arguments for the transfer function const currencyAddress = '0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080'; // xcUNIT address const amount = 1000000000000; const destination = [   // Target the relay chain from Moonbase Alpha   1,   // Target Alice's 32-byte relay chain account   ['0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'], ]; const weight = 305986000;</p> <p>// Sends 1 xcUNIT to the relay chain using the transfer function async function transferToAlice() {   // Creates, signs, and sends the transfer transaction   const transaction = await xTokens.transfer(     currencyAddress,     amount,     destination,     weight   );</p> <p>// Waits for the transaction to be included in a block   await transaction.wait();   console.log(transaction); }</p> <p>transferToAlice();</p> <p>js import Web3 from 'web3'; // Import Web3 library import abi from './xtokensABI.js'; // Import the X-Tokens ABI</p> <p>const privateKey = 'INSERT_PRIVATE_KEY';</p> <p>// Create Web3 provider const web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice</p> <p>// Create contract instance const xTokens = new web3.eth.Contract(   abi,   '0x0000000000000000000000000000000000000804',   { from: web3.eth.accounts.privateKeyToAccount(privateKey).address } // 'from' is necessary for gas estimation );</p> <p>// Arguments for the transfer function const currencyAddress = '0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080'; // xcUNIT address const amount = 1000000000000; const destination = [   // Target the relay chain from Moonbase Alpha   1,   // Target Alice's 32-byte relay chain account   ['0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'], ]; const weight = 305986000;</p> <p>// Sends 1 xcUNIT to the relay chain using the transfer function async function transferToAlice() {   // Create transaction   const transferTx = xTokens.methods.transfer(     currencyAddress,     amount,     destination,     weight   );</p> <p>// Sign transaction   const signedTx = await web3.eth.accounts.signTransaction(     {       to: '0x0000000000000000000000000000000000000804',       data: transferTx.encodeABI(),       gas: await transferTx.estimateGas(),     },     privateKey   );</p> <p>// Send signed transaction   const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);   console.log(sendTx); }</p> <p>transferToAlice();</p> <p>py from web3 import Web3</p> <p>abi = \"INSERT_XTOKENS_ABI\"  # Paste or import the x-tokens ABI private_key = \"INSERT_PRIVATE_KEY\"  # This is for demo purposes, never store your private key in plain text address = \"INSERT_ADDRESS\"  # The wallet address that corresponds to your private key</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#create-web3-provider", "title": "Create Web3 provider", "text": "<p>web3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#create-contract-instance", "title": "Create contract instance", "text": "<p>x_tokens = web3.eth.contract(     address=\"0x0000000000000000000000000000000000000804\", abi=abi )</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#arguments-for-the-transfer-function", "title": "Arguments for the transfer function", "text": "<p>currencyAddress = \"0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080\" # xcUNIT address amount = 1000000000000 destination = [     # Target the relay chain from Moonbase Alpha     1,     # Target Alice's 32-byte relay chain account     [\"0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300\"], ] weight = 305986000</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#sends-1-xcunit-to-the-relay-chain-using-the-transfer-function", "title": "Sends 1 xcUNIT to the relay chain using the transfer function", "text": "<p>def transfer_to_alice():     # Create transaction     transferTx = x_tokens.functions.transfer(         currencyAddress, amount, destination, weight     ).build_transaction(         {             \"from\": address,             \"nonce\": web3.eth.get_transaction_count(address),         }     )</p> <pre><code># Sign transaction\nsignedTx = web3.eth.account.sign_transaction(transferTx, private_key)\n\n# Send tx and wait for receipt\nhash = web3.eth.send_raw_transaction(signedTx.rawTransaction)\nreceipt = web3.eth.wait_for_transaction_receipt(hash)\nprint(f\"Tx successful with hash: { receipt.transactionHash.hex() }\")\n</code></pre> <p>transfer_to_alice()</p>"}, {"location": "builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#precompile-transfer-multiasset", "title": "X-Tokens 预编译转移多资产函数", "text": "<p>要使用 X-Tokens 预编译的 <code>transfer</code> 函数，您需要执行以下常规步骤：</p> <ol> <li>使用 Moonbase Alpha RPC 端点创建一个 provider</li> <li>创建一个签名者以发送交易。此示例使用私钥创建签名者，仅用于演示目的。切勿将您的私钥存储在 JavaScript 文件中</li> <li>使用预编译的地址和 ABI 创建 X-Tokens 预编译的合约实例</li> <li> <p>组合 <code>transferMultiasset</code> 函数的参数：</p> <ul> <li><code>asset</code> - xcUNIT 的多位置：<code>[1, []]</code></li> <li><code>amount</code> - 1 xcUNIT。由于 xcUNIT 有 12 位小数，您可以使用：<code>1000000000000</code></li> <li><code>destination</code> - 目标的多位置，目标是继电器链上的 Alice 帐户：<code>'0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'</code></li> <li><code>weight</code> - 在目标链上为 XCM 执行购买的权重：<code>305986000</code></li> </ul> </li> <li> <p>创建 <code>transferMultiasset</code> 函数，传入参数</p> </li> <li>签名并发送交易</li> </ol> <p>===</p> <pre><code>js\nimport { ethers } from 'ethers'; // Import Ethers library\nimport abi from './xtokensABI.js'; // Import the X-Tokens ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n// Create X-Tokens contract instance\nconst xTokens = new ethers.Contract(\n  '0x0000000000000000000000000000000000000804',\n  abi,\n  signer\n);\n\n// Arguments for the transfer multiasset function\nconst asset = [1, []]; // Multilocation targeting the relay chain\nconst amount = 1000000000000;\nconst dest = [\n  // Target the relay chain from Moonbase Alpha\n  1,\n  // Target Alice's 32-byte relay chain account\n  ['0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'],\n];\nconst weight = 305986000;\n\n// Sends 1 xcUNIT to the relay chain using the transferMultiasset function\nasync function transferMultiassetToAlice() {\n  const transaction = await xTokens.transferMultiasset(\n    asset,\n    amount,\n    dest,\n    weight\n  );\n  await transaction.wait();\n  console.log(transaction);\n}\n\ntransferMultiassetToAlice();\n</code></pre> <p>===</p> <pre><code>js\nimport Web3 from 'web3'; // Import Web3 library\nimport abi from './xtokensABI.js'; // Import the X-Tokens ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Web3 provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n// Create contract instance\nconst xTokens = new web3.eth.Contract(\n  abi,\n  '0x0000000000000000000000000000000000000804',\n  { from: web3.eth.accounts.privateKeyToAccount(privateKey).address } // 'from' is necessary for gas estimation\n);\n\n// Arguments for the transfer multiasset function\nconst asset = [1, []]; // Multilocation targeting the relay chain\nconst amount = 1000000000000;\nconst dest = [\n  // Target the relay chain from Moonbase Alpha\n  1,\n  // Target Alice's 32-byte relay chain account\n  ['0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'],\n];\nconst weight = 305986000;\n\n// Sends 1 xcUNIT to the relay chain using the transferMultiasset function\nasync function transferMultiassetToAlice() {\n  // Create transaction\n  const transferTx = xTokens.methods.transferMultiasset(\n    asset,\n    amount,\n    dest,\n    weight\n  );\n\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: '0x0000000000000000000000000000000000000804',\n      data: transferTx.encodeABI(),\n      gas: await transferTx.estimateGas(),\n    },\n    privateKey\n  );\n\n  // Send signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(sendTx);\n}\n\ntransferMultiassetToAlice();\n</code></pre> <p>===</p> <pre><code>py\nfrom web3 import Web3\n\nabi = \"INSERT_XTOKENS_ABI\"  # Paste or import the x-tokens ABI\nprivate_key = \"INSERT_PRIVATE_KEY\"  # This is for demo purposes, never store your private key in plain text\naddress = \"INSERT_ADDRESS\"  # The wallet address that corresponds to your private key\n\n# Create Web3 provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create contract instance\nx_tokens = web3.eth.contract(\n    address=\"0x0000000000000000000000000000000000000804\", abi=abi\n)\n\n# Arguments for the transfer function\nasset = [1, []]  # Multilocation targeting the relay chain\namount = 1000000000000\ndest = [\n    # Target the relay chain from Moonbase Alpha\n    1,\n    # Target Alice's 32-byte relay chain account\n    [\"0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300\"],\n]\nweight = 305986000\n\n\n# Sends 1 xcUNIT to the relay chain using the transferMultiasset function\ndef transfer_multiasset_to_alice():\n    # Create transaction\n    transferTx = x_tokens.functions.transferMultiasset(\n        asset, amount, dest, weight\n    ).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n\n    # Sign transaction\n    signedTx = web3.eth.account.sign_transaction(transferTx, private_key)\n\n    # Send tx and wait for receipt\n    hash = web3.eth.send_raw_transaction(signedTx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Tx successful with hash: { receipt.transactionHash.hex() }\")\n\n\ntransfer_multiasset_to_alice()\n</code></pre>"}, {"location": "builders/substrate/dev-env/chopsticks/", "title": "如何使用 Chopsticks Fork Moonbeam", "text": ""}, {"location": "builders/substrate/dev-env/chopsticks/#introduction", "title": "简介", "text": "<p>Chopsticks 提供了一种对开发者友好的方法，可以在本地 Fork 现有的基于 Substrate 的链。它允许重放区块，以便轻松检查 extrinsic 如何影响状态，Fork 多个区块以进行 XCM 测试等等。这允许开发者在本地开发环境中，测试和实验他们自己的自定义区块链配置，而无需部署实时网络。</p> <p>总的来说，Chopsticks 旨在简化在 Substrate 上构建区块链应用程序的过程，并使其能够被更广泛的开发者使用。</p>"}, {"location": "builders/substrate/dev-env/chopsticks/#forking-moonbeam", "title": "使用 Chopsticks 分叉 Moonbeam", "text": "<p>要使用 Chopsticks，您可以将其作为软件包通过 Node package manager 或 Yarn 安装：</p> <pre><code>npm i @acala-network/chopsticks@latest\n</code></pre> <p>安装完成后，您可以使用 Node package executor 运行命令。例如，以下命令运行 Chopsticks 的基本命令：</p> <pre><code>npx @acala-network/chopsticks@latest\n</code></pre> <p>要运行 Chopsticks，您需要某种配置，通常是通过文件。Chopsticks 的源代码仓库包含一组 YAML 配置文件，可用于创建各种 Substrate 链的本地副本。 您可以从源代码仓库的 <code>configs</code> 文件夹下载配置文件。</p> <p>Moonbeam、Moonriver 和 Moonbase Alpha 都有可用的默认文件：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>endpoint: wss://wss.api.moonbeam.network\nmock-signature-host: true\ndb: ./db.sqlite\n\nimport-storage:\n  System:\n    Account:\n      -\n        -\n          - \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n        - data:\n            free: \"100000000000000000000000\"\n  TechCommitteeCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  CouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  TreasuryCouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  AuthorFilter:\n    EligibleRatio: 100\n    EligibleCount: 100\n</code></pre> <pre><code>endpoint: wss://wss.moonriver.moonbeam.network\nmock-signature-host: true\ndb: ./db.sqlite\n\nimport-storage:\n  System:\n    Account:\n      -\n        -\n          - \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n        - data:\n            free: \"100000000000000000000000\"\n  TechCommitteeCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  CouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  TreasuryCouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  AuthorFilter:\n    EligibleRatio: 100\n    EligibleCount: 100\n</code></pre> <pre><code>endpoint: wss://wss.api.moonbase.moonbeam.network\nmock-signature-host: true\ndb: ./db.sqlite\n\nimport-storage:\n  System:\n    Account:\n      -\n        -\n          - \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n        - data:\n            free: \"100000000000000000000000\"\n  TechCommitteeCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  CouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  TreasuryCouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  Sudo:\n    Key: \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n  AuthorFilter:\n    EligibleRatio: 100\n    EligibleCount: 100\n</code></pre> <p>以下是可以包含在配置文件中的设置：</p> Option Description <code>genesis</code> 从 parachain 的原始 genesis 文件构建分叉的链接，而不是 endpoint。 <code>timestamp</code> 要分叉的区块的时间戳。 <code>endpoint</code> 要分叉的 parachain 的 endpoint。 <code>block</code> 用于指定在哪个区块哈希或编号处回放分叉。 <code>wasm-override</code> 要用作 parachain 运行时的 WASM 路径，而不是 endpoint 的运行时。 <code>db</code> 存储或将存储 parachain 数据库的文件的名称的路径。 <code>config</code> 配置文件的路径或 URL。 <code>port</code> 要在其上公开 endpoint 的端口。 <code>build-block-mode</code> 区块应如何在分叉中构建：batch、manual、instant。 <code>import-storage</code> 要在 parachain 存储中覆盖的预定义 JSON/YAML 存储文件路径。 <code>allow-unresolved-imports</code> 使用 WASM 构建 parachain 时是否允许 WASM 未解析的导入。 <code>html</code> 包括以生成区块之间的存储差异预览。 <code>mock-signature-host</code> 模拟签名主机，以便任何以 <code>0xdeadbeef</code> 开头并由 <code>0xcd</code> 填充的签名都被认为是有效的。 <p>您可以使用配置文件和基本命令 <code>npx @acala-network/chopsticks@latest</code>，通过为其提供 <code>--config</code> 标志来分叉资产。</p> <p>您可以使用默认配置文件的原始 GitHub URL、本地配置文件的路径，或者仅使用链的名称作为 <code>--config</code> 标志。例如，以下命令都以相同的方式使用 Moonbeam 的配置：</p> Chain NameGitHub URLLocal File Path <pre><code>npx @acala-network/chopsticks@latest --config=moonbeam\n</code></pre> <pre><code>npx @acala-network/chopsticks@latest \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbeam.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks@latest --config=configs/moonbeam.yml\n</code></pre> <p>Note</p> <p>如果使用文件路径，请确保您已下载Moonbeam 配置文件，或者创建了自己的配置文件。</p> <p>但是，配置文件不是必需的。所有设置（除了 <code>genesis</code> 和 <code>timestamp</code>）也可以作为标志传递，以在命令行中完全配置环境。例如，以下命令在区块 100 处分叉 Moonbase Alpha。</p> <pre><code>npx @acala-network/chopsticks@latest --endpoint wss://wss.api.moonbase.moonbeam.network --block 100\n</code></pre>"}, {"location": "builders/substrate/dev-env/chopsticks/#quickstart", "title": "快速入门", "text": "<p>复刻 Moonbeam 最简单的方法是通过存储在 Chopsticks GitHub 存储库中的配置文件：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>npx @acala-network/chopsticks@latest \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbeam.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks@latest \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonriver.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks@latest \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbase-alpha.yml\n</code></pre>"}, {"location": "builders/substrate/dev-env/chopsticks/#interacting-with-a-fork", "title": "与分叉交互", "text": "<p>当运行一个分叉时，默认情况下它将可以通过以下方式访问：</p> <pre><code>ws://localhost:8000\n</code></pre> <p>您将能够通过诸如 Polkadot.js 及其 用户界面 Polkadot.js Apps 等库与平行链进行交互。</p> <p>您可以通过 Polkadot.js Apps 托管的用户界面 与 Chopsticks 进行交互。为此，请访问该页面并执行以下步骤：</p> <ol> <li>单击左上角的图标</li> <li>转到底部并打开 Development</li> <li>选择 Custom 端点并输入 <code>ws://localhost:8000</code></li> <li>单击 Switch 按钮</li> </ol> <p> </p> <p>现在，您应该能够像与活动的平行链或中继链一样与该分叉进行交互。</p> <p>Note</p> <p>如果您的浏览器无法连接到 Chopsticks 提供的 WebSocket 端点，您可能需要允许 Polkadot.js Apps URL 的不安全连接。另一种解决方案是运行 Polkadot.js Apps 的 Docker 版本。</p>"}, {"location": "builders/substrate/dev-env/chopsticks/#replaying-blocks", "title": "重放区块", "text": "<p>如果您想重放一个区块并检索其信息以剖析 extrinsic 的影响，您可以使用 <code>npx @acala-network/chopsticks@latest run-block</code> 命令。其后续标志如下：</p> Flag Description <code>endpoint</code> 要分叉的平行链的端点。 <code>block</code> 用于指定重放分叉的区块哈希或编号。 <code>wasm-override</code> 用作平行链运行时的 WASM 路径，而不是端点的运行时。 <code>db</code> 存储或将存储平行链数据库的文件的路径名。 <code>config</code> 配置文件的路径或 URL。 <code>output-path=/[file_path]</code> 用于将结果打印到 JSON 文件而不是在控制台中打印出来。 <code>html</code> 包括以生成块之间存储差异预览HTML表示形式。 <code>open</code> 是否打开 HTML 表示形式。 <p>例如，运行以下命令将重新运行 Moonbeam 的第 1000 个区块，并将存储差异和其他数据写入 <code>moonbeam-output.json</code> 文件中：</p> <pre><code>npx @acala-network/chopsticks@latest run-block \\\n  --endpoint wss://wss.api.moonbeam.network \\\n  --output-path=./moonbeam-output.json \\\n  --block 1000\n</code></pre>"}, {"location": "builders/substrate/dev-env/chopsticks/#websocket-commands", "title": "WebSocket 命令", "text": "<p>Chopsticks的内部websocket服务器具有特殊的端点，允许操作本地Substrate链。以下是可以调用的方法：</p> 方法 参数 描述 <code>dev_newBlock</code> <code>options</code> 生成一个或多个新的区块。 <code>dev_setStorage</code> <code>values</code>, <code>blockHash</code> 创建或覆盖任何存储的值。 <code>dev_timeTravel</code> <code>date</code> 将区块的时间戳设置为 <code>date</code> 值。 <code>dev_setHead</code> <code>hashOrNumber</code> 将区块链的头设置为特定的哈希或数字。 <p>以上参数的格式如下：</p> 参数 格式 示例 <code>options</code> <code>{ \"to\": number, \"count\": number }</code> <code>{ \"count\": 5 }</code> <code>values</code> <code>Object</code> <code>{ \"Sudo\": { \"Key\": \"0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b\" } }</code> <code>blockHash</code> <code>string</code> <code>\"0x1a34506b33e918a0106b100db027425a83681e2332fe311ee99d6156d2a91697\"</code> <code>date</code> <code>Date</code> <code>\"2030-08-15T00:00:00\"</code> <code>hashOrNumber</code> <code>number</code> 或 <code>string</code> <code>500</code> <ul> <li><code>options</code> { \"to\": number, \"count\": number } - 一个JSON对象，其中 <code>\"to\"</code> 将创建区块直到某个值，而 <code>\"count\"</code> 将按某个区块数递增。一次只能在JSON对象中使用一个条目</li> <li><code>values</code> Object - 一个JSON对象，类似于存储值的路径，类似于您通过Polkadot.js检索到的内容</li> <li><code>blockHash</code> string - 可选，更改存储值的区块哈希</li> <li><code>date</code> Date - 一个日期字符串（与JavaScript Date库兼容），它将更改创建的下一个区块的时间戳。所有未来的区块将按时间顺序排列在该时间点之后</li> <li><code>hashOrNumber</code> number | string - 如果找到，链头将被设置为具有此值的区块号或区块哈希的区块</li> </ul> <p>每个方法都可以通过连接到websocket（默认为 <code>ws://localhost:8000</code>）并以下列格式发送数据和参数来调用。将 <code>METHOD_NAME</code> 替换为方法的名称，并将 <code>PARAMETER_1</code> 和 <code>PARAMETER_2</code> 替换为与该方法相关的参数数据，或将其删除：</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/substrate/libraries/polkadot-js-api/", "title": "Polkadot.js API 库", "text": ""}, {"location": "builders/substrate/libraries/polkadot-js-api/#introduction", "title": "简介", "text": "<p>Polkadot.js 是一系列工具，可让您与 Polkadot 及其平行链（如 Moonbeam）进行交互。Polkadot.js API 是 Polkadot.js 的一个组件，是一个库，允许应用程序开发人员查询 Moonbeam 节点，并使用 JavaScript 与节点的 Substrate 接口进行交互，从而使您可以读取数据和将数据写入网络。</p> <p>您可以使用 Polkadot.js API 查询链上数据，并从 Moonbeam 的 Substrate 端发送外部因素。您可以查询 Moonbeam 的运行时常量、链状态、事件、交易（外部）数据等。</p> <p>在这里，您将找到可用功能的概述和一些常用代码示例，以帮助您开始使用 Polkadot.js API 库与 Moonbeam 网络进行交互。</p>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#checking-prerequisites", "title": "检查先决条件", "text": "<p>安装和使用 Polkadot.js API 库需要安装 Node.js。</p> <p>You need to install Node.js (for this example, you can use v16.x) and the npm package manager. You can download directly from Node.js or in your terminal:</p> UbuntuMacOS <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n\nsudo apt install -y nodejs\n</code></pre> <pre><code># You can use homebrew (https://docs.brew.sh/Installation)\nbrew install node\n\n# Or you can use nvm (https://github.com/nvm-sh/nvm)\nnvm install node\n</code></pre> <p>You can verify that everything is installed correctly by querying the version for each package:</p> <pre><code>node -v\n</code></pre> <pre><code>npm -v\n</code></pre> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#installing-polkadot.js-api-library", "title": "安装 Polkadot.js API", "text": "<p>首先，您需要通过诸如 <code>yarn</code> 之类的包管理器为您的项目安装 Polkadot.js API 库。使用以下命令将其安装在您的项目目录中：</p> <p>===</p> <pre><code>bash\nnpm i @polkadot/api\n</code></pre> <p>===</p> <pre><code>bash\nyarn add @polkadot/api\n</code></pre> <p>该库还包括其他核心组件，如用于帐户管理的 Keyring，或本指南中使用的某些实用程序。</p>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#creating-an-API-provider-instance", "title": "创建 API 提供程序实例", "text": "<p>类似于以太坊 API 库，您必须首先实例化 Polkadot.js API 的 API 实例。使用您希望与之交互的 Moonbeam 网络的 WebSocket 端点创建 <code>WsProvider</code>。</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>===</p> <pre><code>javascript\n// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_API_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n}\n\nmain();\n</code></pre> <p>===</p> <pre><code>javascript\n// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_API_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n}\n\nmain();\n</code></pre> <p>===</p> <pre><code>javascript\n// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n}\n\nmain();\n</code></pre> <p>===</p> <pre><code>javascript\n// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('ws://127.0.0.1:9944');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n}\n\nmain();\n</code></pre>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#metadata-and-dynamic-api-decoration", "title": "元数据和动态 API 装饰", "text": "<p>在深入了解如何通过 Polkadot.js API 库执行不同任务的细节之前，了解该库的一些基本工作原理非常有用。</p> <p>当 Polkadot.js API 连接到节点时，它首先要做的事情之一是检索元数据，并根据元数据信息装饰 API。元数据有效地以以下形式提供数据：</p> <pre><code>api.&lt;类型&gt;.&lt;模块&gt;.&lt;部分&gt;\n</code></pre> <p>其中 <code>&lt;类型&gt;</code> 可以是：</p> <ul> <li><code>query</code> - 用于读取所有状态查询的端点</li> <li><code>tx</code> - 用于与交易相关的端点</li> <li><code>rpc</code> - 用于特定于 RPC 调用的端点</li> <li><code>consts</code> - 用于特定于运行时常量的端点</li> </ul> <p>因此，<code>api.{query, tx, rpc, consts}.&lt;module&gt;.&lt;method&gt;</code> 端点中包含的任何信息都没有在 API 中进行硬编码。这允许像 Moonbeam 这样的平行链通过其 pallet 拥有自定义端点，这些端点可以直接通过 Polkadot.js API 库访问。</p>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#querying-for-information", "title": "查询 Moonbeam 上的链上数据", "text": "<p>在本节中，您将学习如何使用 Polkadot.js API 库查询链上信息。</p>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#state-queries", "title": "Moonbeam 链状态查询", "text": "<p>这类查询检索与链的当前状态相关的信息。这些端点通常采用 <code>api.query.&lt;module&gt;.&lt;method&gt;</code> 的形式，其中模块和方法装饰通过元数据生成。您可以通过检查 <code>api.query</code> 对象来查看所有可用端点的列表，例如通过：</p> <pre><code>console.log(api.query);\n</code></pre> <p>假设您已初始化 API，这是一个检索给定地址的基本帐户信息的代码示例：</p> <pre><code>// Define wallet address\nconst addr = 'INSERT_ADDRESS';\n\n// Retrieve the last timestamp\nconst now = await api.query.timestamp.now();\n\n// Retrieve the account balance &amp; current nonce via the system module\nconst { nonce, data: balance } = await api.query.system.account(addr);\n\nconsole.log(\n  `${now}: balance of ${balance.free} and a current nonce of ${nonce}`\n);\n</code></pre> View the complete script <p>js import { ApiPromise, WsProvider } from '@polkadot/api';</p> <p>const main = async () =&gt; {   // Construct API provider   const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');   const api = await ApiPromise.create({ provider: wsProvider });</p> <p>// Define wallet address   const addr = 'INSERT_ADDRESS';</p> <p>// Retrieve the last timestamp via the timestamp module   const now = await api.query.timestamp.now();</p> <p>// Retrieve the account balance &amp; current nonce via the system module   const { nonce, data: balance } = await api.query.system.account(addr);</p> <p>console.log(     <code>${now}: balance of ${balance.free} and a current nonce of ${nonce}</code>   );</p> <p>// Disconnect the API   await api.disconnect(); };</p> <p>main();</p>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#rpc-queries", "title": "Moonbeam RPC 查询", "text": "<p>RPC 调用为节点之间的数据传输提供了主干。这意味着所有 API 端点（如 <code>api.query</code>、<code>api.tx</code> 或 <code>api.derive</code>）都只是对 RPC 调用的包装，以节点期望的编码格式提供信息。您可以通过检查 <code>api.rpc</code> 对象来查看所有可用端点的列表，例如通过：</p> <pre><code>console.log(api.rpc);\n</code></pre> <p><code>api.rpc</code> 接口遵循与 <code>api.query</code> 类似的格式，例如：</p> <pre><code>// 检索链名称\nconst chain = await api.rpc.system.chain();\n\n// 检索最新的标头\nconst lastHeader = await api.rpc.chain.getHeader();\n\n// 记录信息\nconsole.log(\n  `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n);\n</code></pre> 查看完整脚本 <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain name\n  const chain = await api.rpc.system.chain();\n\n  // Retrieve the latest header\n  const lastHeader = await api.rpc.chain.getHeader();\n\n  // Log the information\n  console.log(\n    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n  );\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#query-subscriptions", "title": "查询订阅", "text": "<p><code>rpc</code> API 也为订阅提供了端点。您可以调整前面的示例，开始使用订阅来侦听新区块。请注意，使用订阅时需要删除 API 断开连接，以避免 WSS 连接的正常关闭。</p> <pre><code>// 检索链名称\nconst chain = await api.rpc.system.chain();\n\n// 订阅新区块头\nawait api.rpc.chain.subscribeNewHeads((lastHeader) =&gt; {\n  console.log(\n    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n  );\n});\n// 删除 await api.disconnect()!\n</code></pre> <p><code>api.rpc.subscribe*</code> 函数的通用模式是将回调传递到订阅函数中，这将会在每次导入新条目时触发。</p> <p><code>api.query.*</code> 下的其他调用可以以类似的方式进行修改以使用订阅，包括具有参数的调用。以下是如何订阅帐户中的余额更改的示例：</p> <pre><code>// 定义钱包地址\nconst addr = 'INSERT_ADDRESS';\n\n// 订阅指定帐户的余额更改\nawait api.query.system.account(addr, ({ nonce, data: balance }) =&gt; {\n  console.log(\n    `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`\n  );\n});\n\n// 删除 await api.disconnect()!\n</code></pre> 查看完整脚本 <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain name\n  const chain = await api.rpc.system.chain();\n\n  // Subscribe to the new headers\n  await api.rpc.chain.subscribeNewHeads((lastHeader) =&gt; {\n    console.log(\n      `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n    );\n  });\n\n  // Define wallet address\n  const addr = 'INSERT_ADDRESS';\n\n  // Subscribe to balance changes for a specified account\n  await api.query.system.account(addr, ({ nonce, data: balance }) =&gt; {\n    console.log(\n      `free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`\n    );\n\n    // Handle API disconnect here if needed\n  });\n};\n\nmain();\n</code></pre>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#keyrings", "title": "为 Moonbeam 账户创建一个密钥环", "text": "<p>密钥环对象用于维护密钥对以及任何数据的签名，无论是转账、消息还是合约交互。</p>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#creating-a-keyring-instance", "title": "创建密钥环实例", "text": "<p>您可以通过仅创建 Keyring 类的实例，并指定所使用的默认钱包地址类型来创建实例。对于 Moonbeam 网络，默认钱包类型应为 <code>ethereum</code>。</p> <pre><code>// 根据需要导入密钥环\nimport Keyring from '@polkadot/keyring';\n\n// 创建密钥环实例\nconst keyring = new Keyring({ type: 'ethereum' });\n</code></pre>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#adding-accounts", "title": "向密钥环添加帐户", "text": "<p>有多种方法可以将帐户添加到密钥环实例，包括从助记词和简短格式的私钥。</p> <p>===</p> <pre><code>```javascript\n// Import the required packages\nimport Keyring from '@polkadot/keyring';\nimport { u8aToHex } from '@polkadot/util';\nimport { hdEthereum } from '@polkadot/util-crypto';\nimport { mnemonicToSeedSync } from 'bip39';\n\n// Import Ethereum account from mnemonic\nconst mnemonic = 'INSERT_MNEMONIC';\n\n// Use the exact EVM derivation path\nconst ethDerPath = \"m/44'/60'/0'/0/0\";\nconsole.log(`Mnemonic: ${mnemonic}`);\nconsole.log(`--------------------------\\n`);\n\n// Extract Ethereum address from mnemonic\nconst keyring = new Keyring();\nconst pair = keyring.createFromUri(\n  `${mnemonic}/${ethDerPath}`,\n  undefined,\n  'ethereum',\n  undefined,\n  2048\n);\nconsole.log(`Ethereum Derivation Path: ${ethDerPath}`);\nconsole.log(`Derived Ethereum Address from Mnemonic: ${pair.address}`);\n\n// Extract private key from mnemonic\nconst seed = mnemonicToSeedSync(mnemonic, '');   // Buffer\nconst node = hdEthereum(seed, ethDerPath);       // \"m/44'/60'/0'/0/0\"\nconst privateKey = u8aToHex(node.secretKey);\nconsole.log(`Derived Private Key from Mnemonic: ${privateKey}`);\n\n```\n</code></pre> <p>===</p> <pre><code>```javascript\n// Import the required packages\nimport Keyring from '@polkadot/keyring';\n\n// Import Ethereum account from private key\nconst privateKeyInput = 'INSERT_PK';\n\n// Extract address from private key\nconst keyring = new Keyring();\nconst pairFromPk = keyring.createFromUri(\n  privateKeyInput,\n  undefined,\n  'ethereum'\n);\nconsole.log(`Derived Address from provided Private Key: ${pairFromPk.address}`);\n\n```\n</code></pre>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#dry-run-api", "title": "Dry Run API", "text": "<p>Dry Run API 是一种简便的方法，用于测试调用的完整性，而不会产生任何交易费用。可以从 Polkadot.js Apps 的开发者部分的运行时调用选项卡访问 Dry Run API。虽然 Dry Run API 主要用于测试 XCM 消息，但它也可用于测试任何任意调用。</p> <p>此方法将 origin 和调用数据作为参数，并返回执行结果和其他事件数据。</p> <pre><code>const testAccount = api.createType(\n  'AccountId20',\n  '0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798'\n);\nconst callData =\n  '0x030088bce0b038effa09e58fe6d24fde4b5af21aa79813000064a7b3b6e00d';\nconst callDataU8a = hexToU8a(callData);\n\nconst result = await api.call.dryRunApi.dryRunCall(\n  { system: { Signed: testAccount } },\n  callDataU8a\n);\n</code></pre> 查看完整脚本 <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { hexToU8a } from '@polkadot/util';\n\nconst main = async () =&gt; {\n  try {\n    // Construct API provider\n    const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n    const api = await ApiPromise.create({ provider: wsProvider });\n\n    console.log('Connected to the API. Preparing dry run call...');\n\n    // Create a test account (you should replace this with an actual account)\n    const testAccount = api.createType(\n      'AccountId20',\n      '0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798'\n    );\n\n    // The call data (replace with your actual call data)\n    const callData =\n      '0x030088bce0b038effa09e58fe6d24fde4b5af21aa79813000064a7b3b6e00d'; // Your hex-encoded call data\n\n    // Convert hex to Uint8Array\n    const callDataU8a = hexToU8a(callData);\n\n    // Perform the dry run call\n    const result = await api.call.dryRunApi.dryRunCall(\n      { system: { Signed: testAccount } }, // origin\n      callDataU8a // call\n    );\n\n    console.log(\n      'Dry run XCM result:',\n      JSON.stringify(result.toJSON(), null, 2)\n    );\n\n    // Disconnect the API\n    await api.disconnect();\n    console.log('Disconnected from the API.');\n  } catch (error) {\n    console.error('An error occurred:', error);\n  }\n};\n\nmain().catch(console.error);\n</code></pre> <p>调用 Dry Run API 后，此方法会告诉您调用是否会成功，并返回如果实际在链上提交调用将发出的事件数据。</p>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#transaction-events", "title": "交易事件", "text": "<p>任何交易都会发出事件，至少对于特定交易，始终会发出 <code>system.ExtrinsicSuccess</code> 或 <code>system.ExtrinsicFailed</code> 事件。这些事件提供了交易的整体执行结果，即执行成功或失败。</p> <p>根据发送的交易，可能会发出其他事件，例如，对于余额转移事件，可能包括一个或多个 <code>balance.Transfer</code> 事件。</p> <p>Transfer API 页面包含一个示例代码段，用于订阅新的已完成区块头并检索所有 <code>balance.Transfer</code> 事件。</p>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#batching-transactions", "title": "批量交易", "text": "<p>Polkadot.js API 允许通过 <code>api.tx.utility.batch</code> 方法批量处理交易。批量交易会从单个发送者依次处理。交易费用可以使用 <code>paymentInfo</code> 辅助方法进行估算。</p> <p>例如，假设您已初始化 API、一个 密钥环实例 并添加了一个帐户，以下示例进行了几个转账，并且还使用了 <code>api.tx.parachainStaking</code> 模块来安排一个请求，以减少特定 collator 候选者的绑定：</p> <pre><code>// Construct a list of transactions to batch\nconst collator = 'INSERT_COLLATORS_ADDRESS';\nconst txs = [\n  api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(12345)),\n  api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(12345)),\n  api.tx.parachainStaking.scheduleDelegatorBondLess(collator, BigInt(12345)),\n];\n\n// Estimate the fees as RuntimeDispatchInfo, using the signer (either\n// address or locked/unlocked keypair)\nconst info = await api.tx.utility.batch(txs).paymentInfo(alice);\n\nconsole.log(`Estimated fees: ${info}`);\n\n// Construct the batch and send the transactions\napi.tx.utility.batch(txs).signAndSend(alice, ({ status }) =&gt; {\n  if (status.isInBlock) {\n    console.log(`included in ${status.asInBlock}`);\n\n    // Disconnect API here!\n  }\n});\n</code></pre> 查看完整脚本 <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport Keyring from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Create a keyring instance (ECDSA)\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  // Initialize wallet key pairs\n  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n\n  // Construct a list of transactions to batch\n  const collator = 'INSERT_COLLATORS_ADDRESS';\n  const txs = [\n    api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(12345)),\n    api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(12345)),\n    api.tx.parachainStaking.scheduleDelegatorBondLess(collator, BigInt(12345)),\n  ];\n\n  // Estimate the fees as RuntimeDispatchInfo, using the signer (either\n  // address or locked/unlocked keypair)\n  const info = await api.tx.utility.batch(txs).paymentInfo(alice);\n\n  console.log(`Estimated fees: ${info}`);\n\n  // Construct the batch and send the transactions\n  api.tx.utility.batch(txs).signAndSend(alice, async ({ status }) =&gt; {\n    if (status.isInBlock) {\n      console.log(`Included in ${status.asInBlock}`);\n\n      // Disconnect the API\n      await api.disconnect();\n    }\n  });\n};\n\nmain();\n</code></pre> <p>Note</p> <p>您可以通过将 <code>console.log(api.tx.parachainStaking);</code> 添加到您的代码中来查看 <code>parachainStaking</code> 模块的所有可用函数。</p>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#substrate-and-custom-json-rpc-endpoints", "title": "Substrate 和自定义 JSON-RPC 端点", "text": "<p>RPC 作为特定模块上的方法公开。这意味着一旦可用，您就可以通过 <code>api.rpc.&lt;module&gt;.&lt;method&gt;(...params[])</code> 调用任何 RPC。这也适用于使用 Polkadot.js API 访问以太坊 RPC，格式为 <code>polkadotApi.rpc.eth.*</code>。</p> <p>通过 Polkadot.js API 接口提供的一些方法也可以在 Moonbeam 节点上作为 JSON-RPC 端点使用。本节将提供一些示例；您可以通过调用 <code>api.rpc.rpc.methods()</code> 或下面列出的 <code>rpc_methods</code> 端点来检查公开的 RPC 端点列表。</p> <ul> <li> <p><code>methods()</code></p> <ul> <li>接口 - <code>api.rpc.rpc.methods</code></li> <li>JSON-RPC - <code>rpc_methods</code></li> <li>返回值 - 节点公开的 RPC 方法列表</li> </ul> <pre><code>  curl --location --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"rpc_methods\",\n    \"params\": []\n  }'\n</code></pre> </li> <li> <p><code>getBlock(hash?: BlockHash)</code></p> <ul> <li>接口 - <code>api.rpc.chain.getBlock</code></li> <li>JSON-RPC - <code>chain_getBlock</code></li> <li>返回值 - 由块哈希参数指定的块的头部和主体</li> </ul> <pre><code>  curl --location --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"chain_getBlock\",\n    \"params\": [\"0x870ad0935a27ed8684048860ffb341d469e091abc2518ea109b4d26b8c88dd96\"]\n  }'\n</code></pre> </li> <li> <p><code>getFinalizedHead()</code></p> <ul> <li>接口 <code>api.rpc.chain.getFinalizedHead</code></li> <li>JSON-RPC <code>chain_getFinalizedHead</code></li> <li>返回值 规范链中最后一个最终确定块的块哈希值</li> </ul> <pre><code>  curl --location --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"chain_getHeader\",\n    \"params\": []\n  }'\n</code></pre> </li> </ul> <p>共识和最终性页面 包含用于使用公开的自定义和 Substrate RPC 调用来检查给定交易的最终性的示例代码。</p>"}, {"location": "builders/substrate/libraries/polkadot-js-api/#utilities", "title": "Polkadot.js API 实用程序函数", "text": "<p>Polkadot.js API 还包括许多实用程序库，用于计算常用的加密原语和哈希函数。</p> <p>以下示例通过首先计算其 RLP（递归长度前缀）编码，然后使用 keccak256 对结果进行哈希，来计算原始以太坊旧版交易的确定性交易哈希。</p> <pre><code>import { encode } from '@polkadot/util-rlp';\nimport { keccakAsHex } from '@polkadot/util-crypto';\nimport { numberToHex } from '@polkadot/util';\n\n// Define the raw signed transaction\nconst txData = {\n  nonce: numberToHex(1),\n  gasPrice: numberToHex(21000000000),\n  gasLimit: numberToHex(21000),\n  to: '0xc390cC49a32736a58733Cf46bE42f734dD4f53cb',\n  value: numberToHex(1000000000000000000),\n  data: '',\n  v: '0507',\n  r: '0x5ab2f48bdc6752191440ce62088b9e42f20215ee4305403579aa2e1eba615ce8',\n  s: '0x3b172e53874422756d48b449438407e5478c985680d4aaa39d762fe0d1a11683',\n};\n\n// Extract the values to an array\nvar txDataArray = Object.keys(txData).map(function (key) {\n  return txData[key];\n});\n\n// Calculate the RLP encoded transaction\nvar encoded_tx = encode(txDataArray);\n\n// Hash the encoded transaction using keccak256\nconsole.log(keccakAsHex(encoded_tx));\n</code></pre> <p>您可以查看相应的 NPM 存储库页面，以获取 <code>@polkadot/util-crypto</code> 库中可用方法及其描述的列表。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/substrate/libraries/py-substrate-interface/", "title": "Python Substrate 接口", "text": ""}, {"location": "builders/substrate/libraries/py-substrate-interface/#introduction", "title": "简介", "text": "<p>Python Substrate Interface 库允许应用程序开发人员查询 Moonbeam 节点，并使用原生 Python 接口与节点的 Polkadot 或 Substrate 功能进行交互。在这里，您将找到可用功能的概述和一些常用的代码示例，以帮助您开始使用 Python Substrate Interface 与 Moonbeam 网络进行交互。</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#checking-prerequisites", "title": "检查先决条件", "text": "<p>对于本指南中的示例，您需要具备以下条件：</p> <ul> <li>一个有资金的帐户。   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>安装了 <code>pip</code></li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#installing-python-substrate-interface", "title": "安装 Python Substrate 接口", "text": "<p>您可以通过 <code>pip</code> 为您的项目安装 Python Substrate 接口库。在您的项目目录中运行以下命令：</p> <pre><code>pip install substrate-interface\n</code></pre>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#creating-an-API-provider-instance", "title": "创建 API 提供程序实例", "text": "<p>与 ETH API 库类似，您必须首先实例化 Python Substrate Interface API 的 API 实例。使用您希望与之交互的 Moonbeam 网络的 websocket 端点创建 <code>WsProvider</code>。</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"INSERT_WSS_API_ENDPOINT\",\n)\n</code></pre> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"INSERT_WSS_API_ENDPOINT\",\n)\n</code></pre> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n</code></pre> <pre><code># Import\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"ws://127.0.0.1:9944\",\n)\n</code></pre>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#querying-for-information", "title": "查询信息", "text": "<p>在本节中，您将学习如何使用 Python Substrate Interface 库查询 Moonbeam 网络的链上信息。</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#accessing-runtime-constants", "title": "访问运行时常量", "text": "<p>所有运行时常量，例如 <code>BlockWeights</code>、<code>DefaultBlocksPerRound</code> 和 <code>ExistentialDeposit</code>，都在元数据中提供。您可以使用 <code>get_metadata_constants</code> 方法来查看 Moonbeam 网络元数据中可用的运行时常量列表。</p> <p>可以通过 <code>get_constant</code> 方法查询元数据中可用的运行时常量。</p> <pre><code># 导入\nfrom substrateinterface import SubstrateInterface\n\n# 构建API提供者\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# 元数据中可用的运行时常量列表\nconstant_list = ws_provider.get_metadata_constants()\nprint(constant_list)\n\n# 在 Moonbeam 上检索存在性存款常量，该常量为 0\nconstant = ws_provider.get_constant(\"Balances\", \"ExistentialDeposit\")\nprint(constant.value)\n</code></pre>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#retrieving-blocks-and-extrinsics", "title": "检索区块和外部操作", "text": "<p>您可以使用 Python Substrate Interface API 检索关于 Moonbeam 网络的基本信息，例如区块和外部操作。</p> <p>要检索一个区块，您可以使用 <code>get_block</code> 方法。您还可以访问区块对象中的外部操作及其数据字段，该对象只是一个 Python 字典。</p> <p>要检索区块头，您可以使用 <code>get_block_header</code> 方法。</p> <pre><code># 导入\nfrom substrateinterface import SubstrateInterface\n\n# 构建 API 提供程序\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# 检索最新区块\nblock = ws_provider.get_block()\n\n# 检索最新的最终确定区块\nblock = ws_provider.get_block_header(finalized_only=True)\n\n# 检索给定其 Substrate 区块哈希的区块\nblock_hash = \"0xa499d4ebccdabe31218d232460c0f8b91bd08f72aca25f9b25b04b6dfb7a2acb\"\nblock = ws_provider.get_block(block_hash=block_hash)\n</code></pre>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#extrinsics", "title": "迭代区块内的 extrinsics", "text": "<p>python for extrinsic in block[\"extrinsics\"]:     if \"address\" in extrinsic:         signed_by_address = extrinsic[\"address\"].value     else:         signed_by_address = None     print(         \"\\nPallet: {}\\nCall: {}\\nSigned by: {}\".format(             extrinsic[\"call\"][\"call_module\"].name,             extrinsic[\"call\"][\"call_function\"].name,             signed_by_address,         )     ) <pre><code>!!! note\n    以上代码示例中使用的块哈希是 Substrate 块哈希。Python Substrate Interface 中的标准方法假定您正在使用 Substrate 版本的原语，例如块或 tx 哈希。\n\n### 订阅新区块头 {: #subscribing-to-new-block-headers }\n\n您还可以调整之前的示例，以使用基于订阅的模型来监听新的区块头。\n\n```python\n# 导入\nfrom substrateinterface import SubstrateInterface\n\n# 构建 API 提供者\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\ndef subscription_handler(obj, update_nr, subscription_id):\n    print(f\"新区块 #{obj['header']['number']}\")\n\n    if update_nr &gt; 10:\n        return {\n            \"message\": \"当返回值时，订阅将取消\",\n            \"updates_processed\": update_nr,\n        }\n\nresult = ws_provider.subscribe_block_headers(subscription_handler)\n</code></pre></p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#querying-for-storage-information", "title": "查询存储信息", "text": "<p>您可以使用 <code>get_metadata_storage_functions</code> 来查看 Moonbeam 网络元数据中可用的存储函数列表。</p> <p>通过存储函数在元数据中提供的链状态可以通过 <code>query</code> 方法进行查询。</p> <p>可以查询诸如 <code>System</code>、<code>Timestamp</code> 和 <code>Balances</code> 等 Substrate 系统模块，以提供诸如帐户随机数和余额等基本信息。可用的存储函数是从元数据中动态读取的，因此您还可以查询 Moonbeam 自定义模块（如 <code>ParachainStaking</code> 和 <code>Democracy</code>）上的存储信息，以获取特定于 Moonbeam 的状态信息。</p> <pre><code># 导入\nfrom substrateinterface import SubstrateInterface\n\n# 构建 API 提供程序\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# 元数据中可用存储函数列表\nmethod_list = ws_provider.get_metadata_storage_functions()\nprint(method_list)\n\n# 查询基本帐户信息\naccount_info = ws_provider.query(\n    module=\"System\",\n    storage_function=\"Account\",\n    params=[\"0x578002f699722394afc52169069a1FfC98DA36f1\"],\n)\n\n# 记录帐户随机数\nprint(account_info.value[\"nonce\"])\n\n# 记录帐户可用余额\nprint(account_info.value[\"data\"][\"free\"])\n\n# 从 Moonbeam 的平行链 Staking 模块查询候选池信息\ncandidate_pool_info = ws_provider.query(\n    module=\"ParachainStaking\", storage_function=\"CandidatePool\", params=[]\n)\nprint(candidate_pool_info)\n</code></pre>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#signing-and-transactions", "title": "签名和交易", "text": ""}, {"location": "builders/substrate/libraries/py-substrate-interface/#creating-a-keypair", "title": "创建密钥对", "text": "<p>Python Substrate Interface 中的密钥对对象用于对所有数据进行签名，无论是转账、消息还是合约交互。</p> <p>您可以从简短格式私钥或助记词创建密钥对实例。对于 Moonbeam 网络，您还需要将 <code>KeypairType</code> 指定为 <code>KeypairType.ECDSA</code>。</p> <pre><code># 导入\nfrom substrateinterface import Keypair, KeypairType\n\n# 定义简短格式私钥\nprivatekey = bytes.fromhex(\"INSERT_PRIVATE_KEY_WITHOUT_0X_PREFIX\")\n\n# 定义帐户助记词\nmnemonic = \"INSERT_MNEMONIC\"\n\n# 从简短格式私钥生成密钥对\nkeypair = Keypair.create_from_private_key(privatekey, crypto_type=KeypairType.ECDSA)\n\n# 从助记词生成密钥对\nkeypair = Keypair.create_from_mnemonic(mnemonic, crypto_type=KeypairType.ECDSA)\n</code></pre>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#forming-and-sending-a-transaction", "title": "构建和发送交易", "text": "<p><code>compose_call</code> 方法可用于构建调用负载，该负载可用作未签名的外部操作或提案。</p> <p>然后，可以使用密钥对通过 <code>create_signed_extrinsic</code> 方法对负载进行签名。</p> <p>然后，可以使用 <code>submit_extrinsic</code> 方法提交已签名的外部操作。</p> <p>此方法还将返回一个 <code>ExtrinsicReceipt</code> 对象，其中包含有关外部操作链上执行的信息。 如果您需要检查收据对象，则可以在提交外部操作时将 <code>wait_for_inclusion</code> 设置为 <code>True</code>，以等待外部操作成功包含到区块中。</p> <p>以下示例代码将显示发送事务的完整示例。</p> <p>```python</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_1", "title": "导入", "text": "<p>from substrateinterface import SubstrateInterface, Keypair, KeypairType from substrateinterface.exceptions import SubstrateRequestException</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#api", "title": "构造 API 提供程序", "text": "<p>ws_provider = SubstrateInterface(     url=\"wss://wss.api.moonbase.moonbeam.network\", )</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_2", "title": "定义发送帐户的简短格式私钥", "text": "<p>privatekey = bytes.fromhex(\"INSERT_PRIVATE_KEY_WITHOUT_0X_PREFIX\")</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_3", "title": "生成密钥对", "text": "<p>keypair = Keypair.create_from_private_key(privatekey, crypto_type=KeypairType.ECDSA)</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_4", "title": "形成交易调用", "text": "<p>call = ws_provider.compose_call(     call_module=\"Balances\",     call_function=\"transfer_allow_death\",     call_params={         \"dest\": \"0x44236223aB4291b93EEd10E4B511B37a398DEE55\",         \"value\": 1 * 10**18,     }, )</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_5", "title": "形成签名的外生函数", "text": "<p>extrinsic = ws_provider.create_signed_extrinsic(call=call, keypair=keypair)</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_6", "title": "提交交易", "text": "<p>try:     receipt = ws_provider.submit_extrinsic(extrinsic, wait_for_inclusion=True)     print(         \"交易 '{}' 已发送并包含在区块 '{}' 中\".format(             receipt.extrinsic_hash, receipt.block_hash         )     ) except SubstrateRequestException as e:     print(\"发送失败: {}\".format(e))</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#offline-signing", "title": "离线签名", "text": "<p>您可以使用密钥对对象通过 <code>sign</code> 方法对交易负载或任何任意数据进行签名。这可用于交易的离线签名。</p> <ol> <li> <p>首先，在在线机器上生成签名负载：</p> <p>```python</p> </li> <li> <p>在离线机器上，使用发送帐户的私钥创建一个密钥对，并对签名负载进行签名：</p> <p>```python</p> </li> <li> <p>在在线机器上，使用发送帐户的公钥创建一个密钥对，然后使用从离线机器生成的签名提交外部交易：</p> <p>```python</p> </li> </ol>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_7", "title": "导入", "text": "<p>from substrateinterface import SubstrateInterface</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#api_1", "title": "构建 API 提供程序", "text": "<p>ws_provider = SubstrateInterface(     url=\"wss://wss.api.moonbase.moonbeam.network\", )</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_8", "title": "构建交易调用", "text": "<p>call = ws_provider.compose_call(     call_module=\"Balances\",     call_function=\"transfer_allow_death\",     call_params={         \"dest\": \"0x44236223aB4291b93EEd10E4B511B37a398DEE55\",         \"value\": 1 * 10**18,     }, )</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_9", "title": "生成签名负载", "text": "<p>signature_payload = ws_provider.generate_signature_payload(call=call) ```</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_10", "title": "导入", "text": "<p>from substrateinterface import Keypair, KeypairType</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_11", "title": "定义来自离线机器的签名负载", "text": "<p>signature_payload = \"INSERT_SIGNATURE_PAYLOAD\"</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_12", "title": "定义发送帐户的简短格式私钥", "text": "<p>privatekey = bytes.fromhex(\"INSERT_PRIVATE_KEY_WITHOUT_0X_PREFIX\")</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_13", "title": "从简短格式私钥生成密钥对", "text": "<p>keypair = Keypair.create_from_private_key(privatekey, crypto_type=KeypairType.ECDSA)</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#signature_payload", "title": "对 signature_payload 进行签名", "text": "<p>signature = keypair.sign(signature_payload) ```</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_14", "title": "导入", "text": "<p>from substrateinterface import SubstrateInterface, Keypair, KeypairType</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#api_2", "title": "构建 API 提供程序", "text": "<p>ws_provider = SubstrateInterface(     url=\"wss://wss.api.moonbase.moonbeam.network\", )</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_15", "title": "定义来自离线机器的签名", "text": "<p>signature_payload = \"INSERT_SIGNATURE_PAYLOAD\"</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_16", "title": "使用发送帐户的以太坊风格钱包地址构建一个密钥对", "text": "<p>keypair = Keypair(public_key=\"INSERT_ADDRESS_WITHOUT_0X\", crypto_type=KeypairType.ECDSA)</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_17", "title": "构建与已签名的相同交易调用", "text": "<p>call = ws_provider.compose_call(     call_module=\"Balances\",     call_function=\"transfer_allow_death\",     call_params={         \"dest\": \"0x44236223aB4291b93EEd10E4B511B37a398DEE55\",         \"value\": 1 * 10**18,     }, )</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_18", "title": "使用生成的签名构建已签名的外部交易", "text": "<p>extrinsic = ws_provider.create_signed_extrinsic(     call=call, keypair=keypair, signature=signature )</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_19", "title": "提交已签名的外部交易", "text": "<p>result = ws_provider.submit_extrinsic(extrinsic=extrinsic)</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#_20", "title": "打印执行结果", "text": "<p>print(result.extrinsic_hash) ```</p>"}, {"location": "builders/substrate/libraries/py-substrate-interface/#custom-rpc-requests", "title": "自定义 RPC 请求", "text": "<p>您还可以使用 <code>rpc_request</code> 方法发出自定义 RPC 请求。</p> <p>这对于与 Moonbeam 的 Ethereum JSON-RPC 端点或 Moonbeam 的 自定义 RPC 端点进行交互特别有用。</p> <p>共识和最终性页面 提供了通过 Python Substrate Interface 使用自定义 RPC 调用来检查给定交易哈希的交易最终性的示例。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "builders/substrate/libraries/sidecar/", "title": "将 Substrate API Sidecar 与 Moonbeam 一起使用", "text": ""}, {"location": "builders/substrate/libraries/sidecar/#introduction", "title": "简介", "text": "<p>Substrate API Sidecar 允许应用程序通过 REST API 访问基于 Substrate 区块链的区块、账户余额和其他信息。这对于需要跟踪 Moonbeam 网络上的账户余额和其他状态变化的交易所、钱包或其他类型的应用程序非常有用。本页将介绍如何为 Moonbeam 安装和运行 Substrate API Sidecar，以及常用的 API 端点。</p>"}, {"location": "builders/substrate/libraries/sidecar/#installing-and-running-substrate-api-sidecar", "title": "安装和运行 Substrate API Sidecar", "text": "<p>有多种安装和运行 Substrate API Sidecar 的方法。本指南将介绍通过 NPM 在本地安装和运行它的步骤。要通过 Docker 运行 Substrate API Sidecar，或者从源代码构建和运行它，请参阅 Substrate API Sidecar Github Repository。</p>"}, {"location": "builders/substrate/libraries/sidecar/#checking-prerequisites", "title": "检查先决条件", "text": "<p>通过 NPM 在本地运行此服务需要安装 Node.js。</p> <p>You need to install Node.js (for this example, you can use v16.x) and the npm package manager. You can download directly from Node.js or in your terminal:</p> UbuntuMacOS <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n\nsudo apt install -y nodejs\n</code></pre> <pre><code># You can use homebrew (https://docs.brew.sh/Installation)\nbrew install node\n\n# Or you can use nvm (https://github.com/nvm-sh/nvm)\nnvm install node\n</code></pre> <p>You can verify that everything is installed correctly by querying the version for each package:</p> <pre><code>node -v\n</code></pre> <pre><code>npm -v\n</code></pre>"}, {"location": "builders/substrate/libraries/sidecar/#installing-the-substrate-api-sidecar", "title": "安装 Substrate API Sidecar", "text": "<p>要在当前目录中本地安装 Substrate API Sidecar，请运行：</p> <pre><code>npm install @substrate/api-sidecar@20.12.0\n</code></pre> <p>Note</p> <p>如果当前文件夹还没有 Node.js 项目结构，需要先运行 <code>mkdir node_modules</code> 创建 <code>node_modules</code> 目录。</p> <p>Substrate API Sidecar v20.12.0 是已在 Moonbeam 网络上测试过的稳定版本。安装完成后可通过以下命令验证：</p> <pre><code>node_modules/.bin/substrate-api-sidecar --version\n</code></pre>"}, {"location": "builders/substrate/libraries/sidecar/#setting-up-the-substrate-api-sidecar", "title": "设置 Substrate API Sidecar", "text": "<p>在 Sidecar 运行的终端中，导出网络 WS 端点的环境变量。例如：</p> Moonbeam <pre><code>    export SAS_SUBSTRATE_URL=wss://wss.api.moonbeam.network\n</code></pre> Moonriver <pre><code>    export SAS_SUBSTRATE_URL=wss://wss.api.moonriver.moonbeam.network\n</code></pre> Moonbase Alpha <pre><code>    export SAS_SUBSTRATE_URL=wss://wss.api.moonbase.moonbeam.network\n</code></pre> Moonbeam Dev Node <pre><code>    export SAS_SUBSTRATE_URL=ws://127.0.0.1:9944\n</code></pre> <p>请参考 公共端点 页面以获取 Moonbeam 网络端点的完整列表。</p> <p>设置环境变量后，您可以使用 <code>echo</code> 命令检查环境变量是否已正确设置，方法是输入：</p> <pre><code>echo $SAS_SUBSTRATE_URL\n</code></pre> <p>它应该显示您刚刚设置的网络端点。</p>"}, {"location": "builders/substrate/libraries/sidecar/#generating-the-types-bundle", "title": "生成类型包", "text": "<p>Moonbeam 引入了一些自定义类型。为了让 Substrate API Sidecar 正确解码，需要为所连接的网络提供对应的自定义类型包。</p> <p>首先安装 Parity 的 <code>generate-types-bundle</code> 工具：</p> <pre><code>npm install -g @substrate/generate-type-bundle\n</code></pre> <p>然后为目标网络生成类型包：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>generate-type-bundle -p \"$(pwd)\" -s moonbeam\n</code></pre> <pre><code>generate-type-bundle -p \"$(pwd)\" -s moonriver\n</code></pre> <pre><code>generate-type-bundle -p \"$(pwd)\" -s moonbase\n</code></pre> <p>生成后，将 <code>typesBundle.json</code> 路径导出给 Sidecar：</p> <pre><code>export SAS_SUBSTRATE_TYPES_BUNDLE=\"$(pwd)/typesBundle.json\"\n</code></pre> <p>可以用 <code>echo $SAS_SUBSTRATE_TYPES_BUNDLE</code> 验证是否设置正确。重新生成类型包会覆盖现有文件，如有重命名请使用对应文件名。</p>"}, {"location": "builders/substrate/libraries/sidecar/#running-substrate-api-sidecar", "title": "运行 Substrate API Sidecar", "text": "<p>设置网络端点环境变量后，从安装目录根目录运行：</p> <pre><code>node_modules/.bin/substrate-api-sidecar\n</code></pre> <p>如果安装和配置成功，您应该在控制台中看到以下输出：</p> node_modules/.bin/substrate-api-sidecar v0.42.1: Pulling from moonbeamfoundation/moonbeam     SAS:         📦 LOG:             ✅ LEVEL: \"info\"             ✅ JSON: false             ✅ FILTER_RPC: false             ✅ STRIP_ANSI: false             ✅ WRITE: false             ✅ WRITE_PATH: \"/temp/node_modules/@substrate/api-sidecar/build/src/logs\"             ✅ WRITE_MAX_FILE_SIZE: 5242880             ✅ WRITE_MAX_FILES: 5         📦 SUBSTRATE:             ✅ URL: \"wss://wss.api.moonbeam.network\"             ✅ TYPES_BUNDLE: \"/Users/alice/sidecar/typesBundle.json\"             ✅ TYPES_CHAIN: undefined             ✅ TYPES_SPEC: undefined             ✅ TYPES: undefined         📦 EXPRESS:             ✅ BIND_HOST: \"127.0.0.1\"             ✅ PORT: 8080             ✅ KEEP_ALIVE_TIMEOUT: 5000     2024-05-07 11:29:54 info: Version: 20.12.0     ...     2024-05-07 11:29:55 info: Connected to chain Moonbeam on the moonbeam client at wss://wss.api.moonbeam.network     2024-05-07 11:29:55 info: Listening on http://127.0.0.1:8080/     2024-05-07 11:29:55 info: Check the root endpoint (http://127.0.0.1:8080) to see the available endpoints for the current node"}, {"location": "builders/substrate/libraries/sidecar/#substrate-api-sidecar-endpoints", "title": "Substrate API Sidecar 端点", "text": "<p>一些常用的 Substrate API Sidecar 端点包括：</p> <ul> <li>GET /blocks​/head — 获取最近最终确定的区块。可选参数 <code>finalized</code> 可以设置为 <code>false</code> 以获取最新的已知区块，该区块可能未最终确定</li> <li>GET /blocks/head/header — 获取最近最终确定的区块头。可选参数 <code>finalized</code> 可以设置为 <code>false</code> 以获取最新的已知区块头，该区块可能未最终确定</li> <li>GET /blocks/{blockId} — 通过其高度或哈希获取区块</li> <li>GET /accounts/{accountId}/balance-info — 获取帐户的余额信息</li> <li>GET /node/version — 获取有关 Substrates 节点实现和版本控制的信息</li> <li>GET /runtime/metadata — 获取解码后的 JSON 格式的运行时元数据。</li> </ul> <p>有关 Substrate API Sidecar 上可用的 API 端点的完整列表，请参阅官方文档。</p>"}, {"location": "builders/substrate/libraries/sidecar/#evm-fields-mapping-in-block-json-object", "title": "区块 JSON 对象中的 EVM 字段映射", "text": "<p>Substrate API Sidecar 将 Moonbeam 区块作为 JSON 对象返回。与 Moonbeam 交易的 EVM 执行相关的信息位于顶层字段 <code>extrinsics</code> 下，其中各个外部因素以数字方式组织为嵌套的 JSON 对象。嵌套结构如下：</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"ethereum\"\n                |--method: \"transact\"\n            |--signature\n            |--nonce\n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"ethereum\"\n                        |--method: \"Executed\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n                        |--3\n    ...\n</code></pre> <p>Moonbeam EVM 交易可以通过当前外部对象下的 <code>method</code> 字段来识别，该字段设置为：</p> <pre><code>{extrinsic_number}.method.pallet = \"ethereum\"\n{extrinsic_number}.method.method = \"transact\"\n</code></pre>"}, {"location": "builders/substrate/libraries/sidecar/#transaction-types-and-payload", "title": "交易类型和负载", "text": "<p>Moonbeam EVM 当前支持三种交易标准：<code>legacy</code>、<code>eip1559</code> 和 <code>eip2930</code>。这些对应于上述 JSON 对象图中的 <code>transaction type</code> 字段。对于每种交易类型，交易负载包含以下字段：</p> EIP1559LegacyEIP2930 <pre><code>...\n    |--eip1559\n        |--chainId\n        |--nonce\n        |--maxPriorityFeePerGas\n        |--maxFeePerGas\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--accessList\n        |--oddYParity\n        |--r\n        |--s\n...\n</code></pre> <pre><code>...\n    |--legacy\n        |--nonce\n        |--gasPrice\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--signature\n...\n</code></pre> <pre><code>...\n    |--eip2930\n        |--chainId\n        |--nonce\n        |--gasPrice\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--accessList\n        |--oddYParity\n        |--r\n        |--s\n...\n</code></pre> <p>有关新的 EIP1559 和 EIP2930 交易类型以及每个字段的含义的更多信息，请参阅各自的官方以太坊提案规范。</p>"}, {"location": "builders/substrate/libraries/sidecar/#transaction-field-mappings", "title": "交易字段映射", "text": "<p>要获取任何 EVM 交易类型的 EVM 发送者地址、接收者地址和 EVM 哈希，请检查当前外部对象下的 <code>events</code> 字段，并识别 <code>method</code> 字段设置为以下内容的事：</p> <pre><code>{event_number}.method.pallet: \"ethereum\"\n{event_number}.method.method: \"Executed\" \n</code></pre> <p>然后将 EVM 字段映射总结如下：</p> EIP1559LegacyEIP2930 EVM 字段 块 JSON 字段 链 ID <code>extrinsics[extrinsic_number].args.transaction.eip1559.chainId</code> 随机数 <code>extrinsics[extrinsic_number].args.transaction.eip1559.nonce</code> 每 Gas 的最大优先费用 <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas</code> 每 Gas 的最大费用 <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas</code> Gas 限制 <code>extrinsics[extrinsic_number].args.transaction.eip1559.gasLimit</code> 访问列表 <code>extrinsics[extrinsic_number].args.transaction.eip1559.accessList</code> 签名 <code>extrinsics[extrinsic_number].args.transaction.eip1559.oddYParity/r/s</code> 发送者地址 <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> 接收者地址 <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> EVM 哈希 <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> EVM 执行状态 <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> EVM 字段 块 JSON 字段 随机数 <code>extrinsics[extrinsic_number].args.transaction.legacy.nonce</code> Gas 价格 <code>extrinsics[extrinsic_number].args.transaction.legacy.gasPrice</code> Gas 限制 <code>extrinsics[extrinsic_number].args.transaction.legacy.gasLimit</code> 价值 <code>extrinsics[extrinsic_number].args.transaction.legacy.value</code> 签名 <code>extrinsics[extrinsic_number].args.transaction.legacy.signature</code> 发送者地址 <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> 接收者地址 <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> EVM 哈希 <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> EVM 执行状态 <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> EVM 字段 块 JSON 字段 链 ID <code>extrinsics[extrinsic_number].args.transaction.eip2930.chainId</code> 随机数 <code>extrinsics[extrinsic_number].args.transaction.eip2930.nonce</code> Gas 价格 <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice</code> Gas 限制 <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasLimit</code> 价值 <code>extrinsics[extrinsic_number].args.transaction.eip2930.value</code> 访问列表 <code>extrinsics[extrinsic_number].args.transaction.eip2930.accessList</code> 签名 <code>extrinsics[extrinsic_number].args.transaction.eip2930.oddYParity/r/s</code> 发送者地址 <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> 接收者地址 <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> EVM 哈希 <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> EVM 执行状态 <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> <p>Note</p> <p>对于 Substrate 交易，“随机数”和“签名”字段位于 <code>extrinsics[extrinsic_number]</code> 下。对于 EVM 交易，“随机数”和“签名”字段位于 <code>extrinsics[extrinsic_number].args.transaction[transaction_type]</code> 下，将 <code>extrinsics[extrinsic_number]</code> 下的“随机数”和“签名”设为 <code>null</code>。</p> <p>成功执行的 EVM 交易将在“EVM 执行状态”字段下返回 <code>succeed: \"Stopped\"</code> 或 <code>succeed: \"Returned\"</code>。</p>"}, {"location": "builders/substrate/libraries/sidecar/#erc-20-token-transfers", "title": "ERC-20 代币转移", "text": "<p>由智能合约（如部署在 Moonbeam 上的 ERC-20 代币合约）发出的事件可以从 Sidecar 区块 JSON 对象中解码。嵌套结构如下：</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"ethereum\"\n                |--method: \"transact\"\n            |--signature:\n            |--nonce:\n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"evm\"\n                        |--method: \"Log\"\n                    |--data\n                        |--0\n                            |--address\n                            |--topics\n                                |--0\n                                |--1\n                                |--2\n                            |--data\n            ...\n    ...\n</code></pre> <p>Moonbeam ERC-20 代币转移将发出 <code>Transfer</code> 事件，该事件可以解码为以下内容：</p> Tx Information Block JSON Field ERC-20 合约地址 <code>extrinsics[extrinsic_number].events[event_number].data[0].address</code> 事件签名哈希 <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[0]</code> 发送者地址 <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[1]</code> 接收者地址 <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[2]</code> 金额 <code>extrinsics[extrinsic_number].events[event_number].data[0].data</code> <p>EVM 智能合约发出的其他事件也可以以类似的方式解码，但是主题和数据字段的内容将根据特定事件的定义而改变。</p> <p>Note</p> <p>转移的金额以 Wei 为单位，并且为十六进制格式。</p>"}, {"location": "builders/substrate/libraries/sidecar/#sample-code-for-monitoring-native-token-transfers", "title": "用于监控原生代币转移的示例代码", "text": "<p>Transfers API 页面 包含一个代码片段，演示了如何使用 Substrate API Sidecar 来检索和解码 Moonbeam 网络上通过 Substrate 和 Ethereum API 发送的原生代币转移。您可以参考该代码片段作为起点，构建利用 Sidecar 监听 Moonbeam 网络上转移的后端。</p>"}, {"location": "builders/substrate/libraries/sidecar/#calculating-transaction-fees", "title": "计算交易费用", "text": "<p>有关如何使用 Substrate Sidecar API 计算 Moonbeam 交易的交易费用的更多详细信息和示例代码，请查看 Moonbeam 上的计算交易费用 页面。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "learn/dapp-directory/", "title": "如何在 Moonbeam DApp 目录上列出您的项目", "text": ""}, {"location": "learn/dapp-directory/#introduction-to-state-of-the-dapps", "title": "Moonbeam DApp 目录简介", "text": "<p>Moonbeam 生态系统包含两个不同的生产网络：Moonbeam 和 Moonriver。每个网络都有自己专门的 DApp 目录，由 Moonbeam 基金会维护：Moonbeam 和 Moonriver。这些目录对从 DeFi 到 NFT 再到游戏的项目进行分类，为用户提供对各种应用程序的全面访问。</p> <p>添加项目时，您需要提供核心项目详细信息，如名称、描述和相关链接。根据您的项目类型，您可以包含其他数据，如链上统计信息和代币信息。</p> <p>尽管 Moonbeam 和 Moonriver DApp 目录之间存在差异，但提交过程保持不变。要在 DApp 目录中列出您的项目，您必须向 Moonbeam 基金会在 GitHub 上的 App Directory Data 存储库 提交拉取请求。本指南概述了提交所需的必要数据和格式细节。</p> <p></p>"}, {"location": "learn/dapp-directory/#overview-project-data", "title": "项目数据概览", "text": "<p>在 Moonbeam DApp 目录中，一个项目的列表使用四个主要数据来源：</p> <ul> <li>核心项目数据：核心项目数据，例如描述、徽标和屏幕截图。此数据还包括用于从外部平台查询数据的 ID。</li> <li>活跃用户和交易量：基于智能合约活动的所有与项目关联的合约的链上数据。数据通过在 Moonscan 中使用合约标签来发现，并由 DApp 目录索引和使用。</li> <li>TVL 数据：协议的 TVL 数据，来自项目在 DefiLlama 上的列表。</li> <li>项目代币信息：代币信息，来自项目在 CoinGecko 上的列表。</li> </ul>"}, {"location": "learn/dapp-directory/#configuring-external-data-sources", "title": "使用外部数据源的先决条件", "text": "<p>从上述来源提取数据之前，必须满足某些先决条件。但是，值得注意的是，这些步骤可能不适用于所有项目类型。例如，对于没有智能合约的钱包，DApp 目录目前无法显示用户和交易活动数据。</p>"}, {"location": "learn/dapp-directory/#configure-active-users", "title": "配置活跃用户和交易量的数据源", "text": "<p>对于在 Moonbeam 或 Moonriver 上部署了智能合约的项目，将这些合约链接到 DApp Directory 项目数据非常重要。</p> <p>将智能合约活动链接到 DApp Directory 的端到端流程如下：</p> <ol> <li>智能合约所有者填写在 Moonscan 上标记合约的表格。</li> <li>合约在 Moonscan 中被标记。</li> <li>然后，生态系统分析提供商可以提取已标记的合约，以便为您的项目索引活动。</li> <li>（推荐）在 FiDi 注册您的项目，以便您的活动可以被索引并公开查看。请参阅下面的 FiDi 注册部分。</li> </ol> <p>要在 Moonscan 上正确标记您项目的智能合约，请提交包含您的项目和合约详情的 Moonscan 合约标记表格。</p>"}, {"location": "learn/dapp-directory/#fidi-register-with-fidi", "title": "在 FiDi 注册以进行分析（推荐）{: #register-with-fidi }", "text": "<p>鼓励新的和现有的项目在 FiDi 上注册，以便您的项目活动可以被索引并在公共分析中显示。请使用 FiDi 项目列表表格 提交您的项目。</p> <p>提交后，可以在 Moonbeam FiDi 仪表板 上查看 Moonbeam FiDi 分析。</p> <p>必需的项目信息：</p> <p>在可能的情况下，包括每个合约的简短目的描述，以提高完整性。</p> <ul> <li>核心智能合约：定义核心功能并与网络进行重要交互的主要合约地址。可以选择包括每个合约用途的简短描述。</li> <li>工厂合约：如果适用，作为您的 dApp 的一部分部署其他合约的任何合约地址。另请提供每个工厂合约的创建主题（创建事件的哈希）。</li> <li>部署者钱包：如果适用，用于部署您的项目合约的钱包地址。</li> </ul> <p>其他特定于项目的信息（可选）：</p> <ul> <li>财务/管理钱包：具有管理控制权或资金的钱包地址。可以选择包括每个钱包功能的简短描述。</li> <li>预言机合约：任何预言机合约的地址。可以选择包括这些预言机提供哪些数据的简短描述。</li> <li>桥合约：任何桥合约的地址以及连接的链的列表。</li> <li>治理合约：与链上治理相关的任何合约的地址。可以选择包括对您的治理模型的简要说明。</li> </ul> <p>其他注意事项：</p> <ul> <li>如果您的项目批量处理交易，请考虑使用批量预编译。</li> <li>工厂合约应源自或模仿标准 Uniswap 工厂。</li> <li>支持 Diamond（多面代理）合约，并且将正确索引。</li> <li>典型的列表时间为 1-2 周；FiDi 可能会联系您进行澄清。</li> </ul> <p>一旦您标记了智能合约并准备好将您的项目提交到 DApp 目录，配置目录以利用您的智能合约数据将变得很简单。您只需要标记合约的 Project 组件。</p> <p>考虑以下示例项目，其中包含两个智能合约：最近更新到新版本的 Comptroller 和 Router。</p> Project 合约名称 合约版本 结果标签 My Project Comptroller V1 My Project: Comptroller V1 My Project Router V2 My Project: Router V2 <p>要将您的项目提交到 Moonbeam DApp 目录，请确保您已准备好您的 Project 名称，此处标识为 <code>My Project</code>。</p> <p>如果您准备好将您的项目添加到 DApp 目录，请跳至 如何提交您的项目列表 部分。</p>"}, {"location": "learn/dapp-directory/#configure-tvl", "title": "配置 TVL 的数据源", "text": "<p>如果项目代表一个带有 TVL 的 DeFi 协议（价值锁定在协议的智能合约中），则可以在 Moonbeam DApp 目录中显示 TVL。</p> <p>TVL 数据来自 DefiLlama，因此您必须在此处列出您的项目。要列出您的项目，请参阅 DefiLlama 关于如何列出 DeFi 项目的文档。</p> <p>列出您的项目后，您可以轻松配置 DApp 目录以从 DefiLlama 获取数据。为此，您需要 DefiLlama 标识符，您可以在协议页面的 URL 中找到它。例如，Moonwell 页面的 URL 是 <code>https://defillama.com/protocol/moonwell</code>，因此标识符是 <code>moonwell</code>。</p> <p>如果您有标识符并准备好将您的项目提交到 Moonbeam DApp 目录，请跳至如何提交您的项目列表部分。</p>"}, {"location": "learn/dapp-directory/#project-token-information", "title": "配置项目 Token 信息的资料来源", "text": "<p>如果一个项目有 Token，则可以在 DApp 目录中显示该 Token 的名称、当前价格和合约。</p> <p>但是，这些数据是从 CoinGecko 中提取的，因此项目的 Token 必须在那里列出。如果您的 Token 未在其中列出，您可以填写 CoinGecko 的请求表 以启动列出过程。</p> <p>假设您的项目 Token 已在其中列出，您必须获得 CoinGecko API ID 值。您可以在 CoinGecko 上 Token 页面的 信息 部分找到 API ID 值。例如，Moonwell 的 Token 页面 上的API ID是 <code>moonwell-artemis</code>。</p> <p>如果您有 CoinGecko ID 并准备好将您的项目提交到 Moonbeam DApp 目录，您可以继续下一节。</p>"}, {"location": "learn/dapp-directory/#projects-with-deployments", "title": "在 Moonbeam 和 Moonriver 上部署的项目", "text": "<p>如果一个项目同时部署到 Moonbeam 和 Moonriver，则有两种不同的选择：</p> <ul> <li>为每个部署创建一个单独的项目结构。</li> <li>使用单个项目结构并修改两个项目的项目数据文件。</li> </ul> <p>如果出现以下情况，则应使用单独的项目结构：</p> <ul> <li>这两个部署在 DefiLlama 中具有不同的表示形式（即，两个不同的标识符）。</li> <li>该项目有两个不同的代币，一个原生于 Moonbeam，另一个原生于 Moonriver。</li> </ul> <p>否则，可以使用任一选项。</p>"}, {"location": "learn/dapp-directory/#set-up-the-file-structure", "title": "为您的项目设置文件夹结构", "text": "<p>DApp 目录中列出的每个项目的所有配置都存储在 <code>projects</code> 文件夹中。</p> <p>要开始，您必须有一个唯一且正确标识您的项目的名称。使用您的项目名称，您可以采取以下步骤：</p> <ol> <li>使用您唯一的项目名称为您的项目创建一个新目录。</li> <li>在您的项目目录中，您需要创建：<ol> <li>项目数据文件是一个 JSON 文件，它定义了您的所有项目数据并包含对存储在 <code>logos</code> 和 <code>screenshots</code> 文件夹中的图像的引用。您可以使用的字段列表（带有描述）在下一节中概述。该文件必须使用您唯一的项目名称命名。</li> <li>一个 <code>logos</code> 文件夹，用于存储您的项目徽标图像。</li> <li>（可选）一个 <code>screenshots</code> 文件夹，用于存储项目的屏幕截图。</li> </ol> </li> </ol> 示例文件夹结构 <p>text my-project ├── my-project.json ├── logos │   ├── my-project-logo-small.jpeg │   └── my-project-logo-full.jpeg └── screenshots     ├── my-project-screenshot1-small.jpeg     ├── my-project-screenshot1-full.jpeg     ├── my-project-screenshot2-small.jpeg     └── my-project-screenshot2-full.jpeg</p> <p></p> <p>有了基础文件结构，您就可以填写项目提交所需的必要信息了。</p>"}, {"location": "learn/dapp-directory/#add-information", "title": "将信息添加到项目数据文件", "text": "<p>您的项目数据文件是您添加项目所有信息的地方。该文件允许以下顶级属性：</p> 属性 类型 描述 <code>id</code> 字符串 Moonbeam DApp 目录中 dApp 的唯一标识符。它应该是一个代表此项目的唯一、人类可读的字符串。例如，<code>my-project</code> <code>slug</code> 字符串 某些第三方来源中使用的标识符。 特别是，如果项目在 DefiLlama 中列出，则此值应设置为 DefiLlama 标识符。 有关更多信息，请参阅配置 TVL 的数据源部分 <code>name</code> 字符串 项目名称，因为它将出现在 DApp 目录中。例如，<code>My Project</code> <code>category</code> 字符串 项目应关联的类别。 一个项目只能有一个类别，它对应于 DApp 目录左侧导航栏中的类别列表。 有关接受的值列表，请参阅类别和标签部分 <code>coinGeckoId</code> 字符串 如果项目在 CoinGecko 上列出了代币，则此属性应具有与给定代币对应的 API ID 值。 有关更多信息，请参阅配置项目代币信息的数据源部分 <code>chains</code> 字符串数组 项目部署的 Moonbeam 生态系统链的列表。 当前的有效值为 <code>moonbeam</code> 和 <code>moonriver</code> <code>logo</code> 字符串到 JSON 对象的映射 与此项目关联并存储在 <code>logos</code> 目录中的徽标图像文件的映射。 有关更多信息，请参阅徽标部分 <code>shortDescription</code> 字符串 在目录中浏览 dapps 时，显示卡中使用的项目简短描述。 应保持在 80 个字符以下 <code>description</code> 字符串 项目详细信息页面中使用的较长描述。 不能使用 Markdown 或类似的格式。 可以使用 <code>\\r\\n</code> 进行换行。 文本应限于几个段落 <code>tags</code> 字符串数组 此项目的适用标签列表。 标签值将显示在项目详细信息中。 有关接受的值列表，请参阅类别和标签部分 <code>contracts</code> 合约 JSON 对象数组 项目合约列表。 目前，这仅用于代币合约。 构成协议的智能合约列表从 Moonscan 外部获取。 有关更多信息，请参阅合约部分 <code>urls</code> 字符串（名称）到字符串（URL）的映射 与项目关联的网站和社交网站的 URL 映射。 有关接受的属性列表，请参阅URL部分 <code>screenshots</code> 字符串（大小）到图像 JSON 对象的数组映射 与此项目关联并存储在 <code>screenshots</code> 目录中的屏幕截图图像文件列表。 有关更多信息，请参阅屏幕截图部分 <code>projectCreationDate</code> 整数 项目创建的日期。 用于在 DApp 目录中进行排序 示例项目数据文件 <p>{     \"id\": \"moonwell\",     \"slug\": \"moonwell\",     \"name\": \"Moonwell\",     \"category\": \"lending\",     \"coinGeckoId\": \"moonwell-artemis\",     \"chains\": [         \"moonbeam\"     ],     \"logo\": {         \"small\": {             \"fileName\": \"moonwell-logo-small.jpeg\",             \"width\": 40,             \"height\": 40,             \"mimeType\": \"image/jpeg\"         },         \"large\": {             \"fileName\": \"moonwell-logo-large.jpeg\",             \"width\": 400,             \"height\": 400,             \"mimeType\": \"image/jpeg\"         },         \"full\": {             \"fileName\": \"moonwell-logo-full.jpeg\",             \"width\": 3000,             \"height\": 3000,             \"mimeType\": \"image/jpeg\"         }     },     \"shortDescription\": \"Lending, borrowing, and DeFi protocol built on Moonbeam and Moonriver\",     \"description\": \"Moonwell is an open lending, borrowing, and decentralized finance protocol built on Moonbeam and Moonriver. Moonwell’s composable design can accommodate a full range of DeFi applications in the greater Polkadot and Kusama (DotSama) ecosystem.\\r\\n\\r\\nOur first deployment will be on Kusama’s Moonriver, the sister network of Polkadot’s Moonbeam. Moonriver is where new products are expected to be incubated and developed prior to being deployed on Moonbeam.\",     \"tags\": [         \"Lending\",         \"DeFi\"     ],     \"contracts\": [         {             \"contract\": \"0x511ab53f793683763e5a8829738301368a2411e3\",             \"chain\": \"moonbeam\",             \"name\": \"WELL Token\"         }     ],     \"urls\": {         \"website\": \"https://moonwell.fi/\",         \"try\": \"https://moonwell.fi/\",         \"twitter\": \"https://twitter.com/MoonwellDeFi\",         \"medium\": \"https://moonwell.medium.com/\",         \"telegram\": \"https://t.me/moonwellfichat\",         \"github\": \"https://github.com/moonwell-open-source\",         \"discord\": \"https://discord.gg/moonwellfi\"     },     \"screenshots\": [         {             \"small\": {                 \"fileName\": \"moonwell-screenshot-small1.png\",                 \"width\": 429,                 \"height\": 200,                 \"mimeType\": \"image/png\"             },             \"full\": {                 \"fileName\": \"moonwell-screenshot-full1.png\",                 \"width\": 514,                 \"height\": 300,                 \"mimeType\": \"image/png\"             }         },         {             \"small\": {                 \"fileName\": \"moonwell-screenshot-small2.png\",                 \"width\": 429,                 \"height\": 200,                 \"mimeType\": \"image/png\"             },             \"full\": {                 \"fileName\": \"moonwell-screenshot-full2.png\",                 \"width\": 1716,                 \"height\": 800,                 \"mimeType\": \"image/png\"             }         },         {             \"small\": {                 \"fileName\": \"moonwell-screenshot-small3.png\",                 \"width\": 429,                 \"height\": 200,                 \"mimeType\": \"image/png\"             },             \"full\": {                 \"fileName\": \"moonwell-screenshot-full3.png\",                 \"width\": 1054,                 \"height\": 637,                 \"mimeType\": \"image/png\"             }         },         {             \"small\": {                 \"fileName\": \"moonwell-screenshot-small4.png\",                 \"width\": 429,                 \"height\": 200,                 \"mimeType\": \"image/png\"             },             \"full\": {                 \"fileName\": \"moonwell-screenshot-full4.png\",                 \"width\": 1365,                 \"height\": 436,                 \"mimeType\": \"image/png\"             }         }     ],     \"projectCreationDate\": 1644828523000 }</p>"}, {"location": "learn/dapp-directory/#category-and-tags", "title": "类别和标签", "text": "<p>类别是项目的主要分类。一个项目只能归为一个类别，但可以有多个标签。请务必仔细选择最适合您项目的类别，以确保可以轻松找到它。任何辅助分类都可以作为标签包含在内。</p> <p>目前支持的 <code>category</code> 值有：</p> <p>text - Bridges - DAO - DEX - DeFi - Gaming - Lending - NFTs - Other - Social - Wallets</p> <p>目前支持的 <code>tag</code> 值有：</p> <p>text - Bridges - DAO - DEX - DeFi - DePIN - Developer Tools - Explorers - Files - GLMR Grants - Gaming - Infrastructure - IoT - Lending - MOVR Grants - Messaging - NFT - NFT Marketplaces - On-ramp - Other - Social - Tool - VPN - Wallets - ZeroTrust</p>"}, {"location": "learn/dapp-directory/#urls", "title": "URLs", "text": "<p><code>urls</code> 属性的名称/值对用于项目可以提供到其网站、社交媒体等的链接。</p> <p>下表列出了支持的 <code>urls</code> 属性：</p> 属性名称 描述 示例 <code>website</code> 项目的主要网站 https://moonbeam.network/ <code>try</code> 如果用户想要试用 dApp，则应访问的 URL。通常，此页面将有一个启动 dApp 的链接 https://moonbeam.network/ <code>twitter</code> 项目的 X (Twitter) 个人资料 https://x.com/MoonbeamNetwork <code>medium</code> 项目的 Medium 站点 https://medium.com/moonbeam-network <code>telegram</code> 项目的 Telegram https://t.me/Moonbeam_Official <code>github</code> 项目的 GitHub 存储库 https://github.com/moonbeam-foundation/moonbeam <code>discord</code> 项目的 Discord https://discord.com/invite/PfpUATX <p>属性名称/值对的格式应遵循 JSON 标准，例如：</p> <p>\"urls\": {     \"website\": \"https://moonbeam.network/\",     \"try\": \"https://docs.moonbeam.network/\",     \"twitter\": \"https://x.com/MoonbeamNetwork\" }</p>"}, {"location": "learn/dapp-directory/#logos", "title": "标志", "text": "<p>主项目数据文件的 <code>logos</code> 属性是从图像大小（即 <code>small</code>、<code>large</code>、<code>full</code>）到相应图像 JSON 对象的映射。图像 JSON 对象包含给定图像的显示属性。</p> <p>下表列出了图像 JSON 对象的属性：</p> 属性 类型 描述 <code>fileName</code> 字符串 存储在 <code>logos</code> 目录中的图像文件（不合格）的名称 <code>width</code> 整数 徽标图像的宽度（以像素为单位） <code>height</code> 整数 徽标图像的高度（以像素为单位） <code>mimeType</code> 字符串 文件的标准 MIME 类型。例如，<code>\"image/jpeg\"</code> <p>目前，仅使用 <code>small</code> 大小，小徽标的尺寸应为 40x40 像素。</p> <p>以下示例显示了提供 <code>small</code> 和 <code>full</code> 徽标的 <code>logo</code> 属性的结构：</p> <p>\"logo\": {     \"small\": {         \"fileName\": \"my-project-logo-small.jpeg\",         \"width\": 40,         \"height\": 40,         \"mimeType\": \"image/jpeg\"     },     \"full\": {         \"fileName\": \"my-project-logo-full.jpeg\",         \"width\": 3000,         \"height\": 3000,         \"mimeType\": \"image/jpeg\"     } }</p>"}, {"location": "learn/dapp-directory/#screenshots", "title": "屏幕截图", "text": "<p>主项目数据文件的 <code>screenshots</code> 属性是一个映射数组。数组中的每个映射都对应一个特定的屏幕截图。</p> <p>但是，应为每个屏幕截图提供不同大小的图像，以便在不同的上下文中使用不同的大小（例如，缩略图与全尺寸图像）。因此，对于每个屏幕截图，都有一个图像大小的映射（即 <code>small</code>、<code>large</code>、<code>full</code>）到相应的图像 JSON 对象。图像 JSON 对象包含给定图像的显示属性。</p> <p>下表列出了图像 JSON 对象的属性：</p> 属性 类型 描述 <code>fileName</code> 字符串 存储在 <code>screenshots</code> 目录中的图像文件的名称（不合格） <code>width</code> 整数 徽标图像的宽度（以像素为单位） <code>height</code> 整数 徽标图像的高度（以像素为单位） <code>mimeType</code> 字符串 文件的标准 MIME 类型。例如，<code>\"image/jpeg\"</code> <p>以下示例显示了两个屏幕截图（<code>screenshot1</code> 和 <code>screenshot2</code>）的 <code>screenshot</code> 属性的结构：</p>"}, {"location": "learn/dapp-directory/#contracts", "title": "合约", "text": "<p>项目合约列表。目前，这仅用于代币合约。</p> <p>构成协议的智能合约来自基于标记的 Moonscan，因此无需在此处列出。如果您没有正确标记您的合约，或者不确定它们是否按照 Moonbeam 社区标准进行标记，请参阅配置活跃用户和交易量的数据源部分。</p> <p>下表列出了在合约 JSON 对象中找到的属性：</p> 属性 类型 描述 <code>contract</code> String 智能合约的地址 <code>chain</code> String 合约部署的链（即 <code>moonbeam</code> 或 <code>moonriver</code>） <code>name</code> String 合约名称 <p>这是一个 <code>contracts</code> 数组，其中包含 WGLMR 代币的单个智能合约：</p>"}, {"location": "learn/dapp-directory/#submit-a-pull-request", "title": "提交 Pull Request", "text": "<p>在您填充了项目数据文件并添加了徽标和屏幕截图后，您应该可以提交 pull request 了。</p> <p></p> <p>从基于 Web 的编辑器中，按照以下步骤将您的更改提交到 <code>app-directory-data</code> 存储库：</p> <ol> <li>单击 Source Control 选项卡，该选项卡应显示已添加或更改了多少页面。</li> <li>查看 Changes 部分下的文件。单击 Changes 旁边的 + 按钮，或者在查看每个文件时，单击文件名旁边的 + 按钮，将它们添加到 Staged Changes 列表中。</li> </ol> <p></p> <p>您的所有文件现在都应位于 Staged Changes 部分下。您只需提交并推送更改：</p> <ol> <li>输入描述性的提交消息，例如“Add My Project”，确保使用您的实际项目名称。</li> <li>单击 Commit &amp; Push。</li> </ol> <p></p> <p>现在您已提交更改，您需要前往 <code>app-directory-data</code> 存储库 并针对 <code>develop</code> 分支打开一个 pull request：</p> <ol> <li>在存储库页面顶部，单击横幅上显示的 Compare and Pull 按钮，或者</li> <li>如果横幅不再存在，您需要从分支下拉列表中选择您的分支。</li> <li>单击 Contribute 下拉列表。</li> <li>单击 Open pull request 按钮。</li> </ol> <p></p> <p>您将被带到 Comparing changes 页面，您需要在其中执行以下操作：</p> <ol> <li>确保您将您的分支合并到 <code>develop</code> 分支中，该分支是 base 分支。</li> <li>添加标题。</li> <li>添加更改的描述。</li> <li>单击 Create pull request。</li> </ol> <p></p>"}, {"location": "learn/dapp-directory/#review-process", "title": "审核流程", "text": "<p>提交的 pull request 将由 Moonbeam 基金会每两周审核一次。在审核期间，特别是对于新项目，基金会可能需要验证创建 pull request 的 GitHub 用户是否是贡献者和/或代表特定项目。项目加快此过程的一种方法是，如果提交者的 GitHub 帐户也是 GitHub 上项目本身的主要贡献者。 另一种方法是，团队应在 pull request 的评论中留下说明，说明我们如何与项目团队成员联系以进行验证。</p> <p>如果需要任何更改，将会向 pull request 添加评论。在您的 pull request 获得批准后，它将被合并，您的项目将被添加到 Moonbeam DApp 目录中！</p>"}, {"location": "learn/dapp-directory/#how-to-update-your-project-listing", "title": "如何更新您的项目列表", "text": "<p>随着项目的不断发展，您可能需要更新项目的列表或与列表相关的图像。您可以为您的更改创建一个新分支，从根目录 <code>projects</code> 中找到并修改您现有项目的数据，并进行所需的更改。</p> <p>如果您不再使用徽标或屏幕截图，请记住将其从 <code>logos</code> 或 <code>screenshots</code> 目录中删除。</p> <p>完成更改后，您必须按照提交拉取请求部分中的相同说明进行操作，以便 Moonbeam 基金会可以审核这些更改。请注意，拉取请求是按双周审核一次，因此如果更新紧急，您可以创建一个论坛帖子请求帮助。</p>"}, {"location": "learn/dapp-directory/#dapp-directory-api", "title": "DApp Directory API", "text": "<p>DApp Directory 还提供了一个可查询的 API，您可以使用它将 Moonbeam 的 DApp Directory 中的数据集成到您的应用程序中。该 API 是公开的，目前不需要身份验证。该 API 的基本 URL 如下：</p> <p>bash https://apps.moonbeam.network/api/ds/v1/app-dir/</p>"}, {"location": "learn/dapp-directory/#query-a-project", "title": "查询项目", "text": "<p>您可以通过将<code>/projects/INSERT_PROJECT_NAME</code>附加到基本 URL 来检索特定项目的所有信息。如果您需要明确项目名称，您可以省略项目名称，如下所示，以检索每个列出项目的数据并在响应中找到该项目。</p> <p>bash https://apps.moonbeam.network/api/ds/v1/app-dir/projects</p> <p>这是一个查询 StellaSwap 的 API 的示例，它返回项目描述、社交媒体信息、用户计数、相关智能合约地址、市场数据、图像等。</p> <p>bash https://apps.moonbeam.network/api/ds/v1/app-dir/projects/stellaswap</p> <p>您可以使用像 Postman 这样的工具在浏览器中访问查询 URL 目录，或直接从命令行使用 Curl，如下所示：</p> <p>bash curl -H \"Content-Type: application/json\" -X GET 'https://apps.moonbeam.network/api/ds/v1/app-dir/projects/stellaswap'</p> 查询 StellaSwap 的 API 响应 <p>{     \"project\":{         \"currentTx\":{             \"moonbeam\":2883079         },         \"web3goIDs\":[             \"StellaSwap\"         ],         \"name\":\"StellaSwap\",         \"currentTVL\":{             \"moonbeam\":5046832.23328         },         \"currentUsers\":{             \"moonbeam\":52455         },         \"coinGeckoId\":\"stellaswap\",         \"shortDescription\":\"The leading DEX and DeFi gateway on Moonbeam\",         \"id\":\"stellaswap\",         \"featured\":true,         \"tags\":[             \"DEX\",             \"DeFi\"         ],         \"tvlChange7d\":{             \"moonbeam\":-1.61482567543498         },         \"urls\":{             \"telegram\":\"https://t.me/stellaswap\",             \"website\":\"https://stellaswap.com/\",             \"try\":\"https://stellaswap.com/\",             \"twitter\":\"https://twitter.com/StellaSwap\",             \"github\":\"https://github.com/stellaswap\",             \"medium\":\"https://stellaswap.medium.com/\"         },         \"web3goContracts\":[             {                 \"name\":\"StellaSwap: stDOT Oracle Master\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x3b23f0675ffc45153eca239664ccaefc5e816b9c\"             },             {                 \"name\":\"StellaSwap: stDOT Token\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xbc7e02c4178a7df7d3e564323a5c359dc96c4db4\"             },             {                 \"name\":\"StellaSwap: stDOT Controller\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x002d34d6a1b4a8e665fec43fd5d923f4d7cd254f\"             },             {                 \"name\":\"StellaSwap: stDOT Proxy Admin\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xe8a5c0039226269313c89c093a6c3524c4d39fa4\"             },             {                 \"name\":\"StellaSwap: madUSDC GLMR V2\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x2ad0e92461df950e2b1c72e2f7a865c81eaa3ce6\"             },             {                 \"name\":\"StellaSwap: Dual ETH - GLMR Rewarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x2ba130297d1966e077c2fb5e4b434e8802925277\"             },             {                 \"name\":\"StellaSwap: BCMC Rewarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x18e75887aa81e113636e18d5a78e3ff93787ec88\"             },             {                 \"name\":\"StellaSwap: Pulsar Position Manager V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x1ff2adaa387dd27c22b31086e658108588eda03a\"             },             {                 \"name\":\"StellaSwap: DualETH Pool LP Token V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xa3ee3a0a36dc915fdc93062e4b386df37d00217e\"             },             {                 \"name\":\"StellaSwap: Interlay Rewarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x3a7572220afaddc31a72a520642111776d92b2d2\"             },             {                 \"name\":\"StellaSwap: Router V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xd0a01ec574d1fc6652edf79cb2f880fd47d34ab1\"             },             {                 \"name\":\"StellaSwap: xStella - GLMR Rewarder 2nd V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xb4dba7fe6fcc613963d64204fcf789e9e376679a\"             },             {                 \"name\":\"StellaSwap: GLMR Rewarder First V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x69f9d134991e141c4244f397514ba05d67861cc0\"             },             {                 \"name\":\"StellaSwap: CELER Rewarder 0 V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xbebd88782a1145b71df3f4986ef7686154ce01d9\"             },             {                 \"name\":\"StellaSwap: MATICILO V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xfffa340944ff32f50c7935e2b5d22a7c3393b313\"             },             {                 \"name\":\"StellaSwap: ETHmad - GLMR V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x9fe074a56ffa7f4079c6190be6e8452911b7e349\"             },             {                 \"name\":\"StellaSwap: STELLA Token\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x0e358838ce72d5e61e0018a2ffac4bec5f4c88d2\"             },             {                 \"name\":\"StellaSwap: SFL - 4pool Wormhole V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xb1bc9f56103175193519ae1540a0a4572b1566f6\"             },             {                 \"name\":\"StellaSwap: BICO Trusted Forwarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x3d08ce1f9609bb02f47192ff620634d9eb0e7b56\"             },             {                 \"name\":\"StellaSwap: Gass Refund V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xee42d4861b56b32776e6fe9a2fe122af0e3f4a33\"             },             {                 \"name\":\"StellaSwap: xcDOT - GLMR V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xe76215efea540ea87a2e1a4bf63b1af6942481f3\"             },             {                 \"name\":\"StellaSwap: 4pool LP V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xda782836b65edc4e6811c7702c5e21786203ba9d\"             },             {                 \"name\":\"StellaSwap: SFL LP V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xa0aa99f71033378864ed6e499eb03612264e319a\"             },             {                 \"name\":\"StellaSwap: SFL - 4pool V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x422b5b7a15fb12c518aa29f9def640b4773427f8\"             },             {                 \"name\":\"StellaSwap: Acala - GLMR Rewarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x9de8171bebfa577d6663b594c60841fe096eff97\"             },             {                 \"name\":\"StellaSwap: Zap V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x01834cf26717f0351d9762cc9cca7dc059d140df\"             },             {                 \"name\":\"StellaSwap: GLMR Rewarder for UST - GLMR V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xc85ddcff71200f9673137e2f93ce504bdbf7db4e\"             },             {                 \"name\":\"StellaSwap: xStella Token\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x06a3b410b681c82417a906993acefb91bab6a080\"             },             {                 \"name\":\"StellaSwap: ETHmad - GLMR V2\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xa6ec79c97e533e7bddb00898e22c6908742e039b\"             },             {                 \"name\":\"StellaSwap: WBTC - USDT Contract V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xcae51da6dceacd84f79df4b88d9f92035d1479e9\"             },             {                 \"name\":\"StellaSwap: AVAXILO V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x96bef4719ae7c053113292e6aa7fc36e62b243e8\"             },             {                 \"name\":\"StellaSwap: Swap For Gas V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xb64dee2d182fed3dd6c273303fb08f11808c9c23\"             },             {                 \"name\":\"StellaSwap: Farming Centre V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x0d4f8a55a5b2583189468ca3b0a32d972f90e6e5\"             },             {                 \"name\":\"StellaSwap: FTMILO V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x096352f7ea415a336b41fc48b33142eff19a8ad8\"             },             {                 \"name\":\"StellaSwap: Acala Rewarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xb7b5d3659ad213478bc8bfb94d064d0efdda8f7c\"             },             {                 \"name\":\"StellaSwap: USDC Rewarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xa52123adc0bc5c4c030d1ff4f5dad966366a646c\"             },             {                 \"name\":\"StellaSwap: Vault V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x54e2d14df9348b3fba7e372328595b9f3ae243fe\"             },             {                 \"name\":\"StellaSwap: CELER Rewarder 1 V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x70cbd76ed57393e0cd81e796de850080c775d24f\"             },             {                 \"name\":\"StellaSwap: Stella Timelock V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xc6f73b028cd3154a5bb87f49aa43aa259a6522fb\"             },             {                 \"name\":\"StellaSwap: GLMR - MAI Vault V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x3a82f4da24f93a32dc3c2a28cfa9d6e63ec28531\"             },             {                 \"name\":\"StellaSwap: UST - GLMR V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x556d9c067e7a0534564d55f394be0064993d2d3c\"             },             {                 \"name\":\"StellaSwap: SFL - axlUSDC - 4pool V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xa1ffdc79f998e7fa91ba3a6f098b84c9275b0483\"             },             {                 \"name\":\"StellaSwap: Stable Router V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xb0dfd6f3fddb219e60fcdc1ea3d04b22f2ffa9cc\"             },             {                 \"name\":\"StellaSwap: ATOM - GLMR Rewarder New V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x5aa224966e302424ec13a4f51b80bcfc205984b6\"             },             {                 \"name\":\"StellaSwap: CELR Rewarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x05ad30253f0b20be35d84253d6aca8bd7ec0c66c\"             },             {                 \"name\":\"StellaSwap: Router V3\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xe6d0ed3759709b743707dcfecae39bc180c981fe\"             },             {                 \"name\":\"StellaSwap: xStella - GLMR Rewarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x896135ff51debe8083a2e03f9d44b1d3c77a0324\"             },             {                 \"name\":\"StellaSwap: XStella - MAI Vault V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x3756465c5b1c1c4cee473880c9726e20875284f1\"             },             {                 \"name\":\"StellaSwap: ATOM - USDC Rewarder New V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x5546e272c67fac10719f1223b1c0212fa3e41a8f\"             },             {                 \"name\":\"StellaSwap: SFL - athUSDC - 4pool V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x715d7721fa7e8616ae9d274704af77857779f6f0\"             },             {                 \"name\":\"StellaSwap: IDO Locker V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x4b1381b5b959a8ba7f44414c7d758e53d500a8a9\"             },             {                 \"name\":\"StellaSwap: Locker V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x8995066b7f1fb3abe3c88040b677d03d607a0b58\"             },             {                 \"name\":\"StellaSwap: ATOM - USDC - GLMR Rewarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xe06e720aaed5f5b817cb3743108ae0a12fe69e9b\"             },             {                 \"name\":\"StellaSwap: Mistake in Rewarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x168ceb7e49c21e3f37820a34590171214a765f5f\"             },             {                 \"name\":\"StellaSwap: LP 4pool - Wormhole V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xb326b5189aa42acaa3c649b120f084ed8f4dcaa6\"             },             {                 \"name\":\"StellaSwap: Farms V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xedfb330f5fa216c9d2039b99c8ce9da85ea91c1e\"             },             {                 \"name\":\"StellaSwap: Factory V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x68a384d826d3678f78bb9fb1533c7e9577dacc0e\"             },             {                 \"name\":\"StellaSwap: anyETH-madETH Pool\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xb86271571c90ad4e0c9776228437340b42623402\"             },             {                 \"name\":\"StellaSwap: Dual Farms V2\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xf3a5454496e26ac57da879bf3285fa85debf0388\"             },             {                 \"name\":\"StellaSwap: CELER Rewarder 01 - 02 V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x713f76076283fcd81babe06c76ff51485edf9d5e\"             },             {                 \"name\":\"StellaSwap: SCNFT Token\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x5f23a6a0b6b90fdeeb4816afbfb2ec0408fda59e\"             },             {                 \"name\":\"StellaSwap: ATOM - GLMR - GLMR Rewarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xe60c41de5537418fde05b804df077397dfa84d75\"             },             {                 \"name\":\"StellaSwap: Timelock Main V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x9a8693c6f7bf0f44e885118f3f83e2cdb4e611b8\"             },             {                 \"name\":\"StellaSwap: MAI - B4P - Wormhole V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xf0a2ae65342f143fc09c83e5f19b706abb37414d\"             },             {                 \"name\":\"StellaSwap: LP Token V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x7b17122b941d2173192c7d8d68faabdc88421326\"             },             {                 \"name\":\"StellaSwap: Multisig V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x4300e09284e3bb4d9044ddab31efaf5f3301daba\"             },             {                 \"name\":\"StellaSwap: Router V2\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x70085a09d30d6f8c4ecf6ee10120d1847383bb57\"             },             {                 \"name\":\"StellaSwap: DOTxc - GLMR V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x505b0a5458dd12605b84bb2928dd2bc5b44993b9\"             },             {                 \"name\":\"StellaSwap: SFL - MAI - 4pool V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x7fbe3126c03444d43fc403626ec81e3e809e6b46\"             },             {                 \"name\":\"StellaSwap: xStella - USDC Rewarder V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0xfa16d5b8bf03677945f0a750c8d2a30001b2fa93\"             },             {                 \"name\":\"StellaSwap: madUSDC - GLMR V1\",                 \"chain\":\"moonbeam\",                 \"contract\":\"0x9200cb047a9c4b34a17ccf86334e3f434f948301\"             }         ],         \"slug\":\"stellaswap\",         \"createdAt\":1699292612617,         \"tvlChange1d\":{             \"moonbeam\":-0.748278690902012         },         \"logo\":{             \"small\":{                 \"width\":36,                 \"fileName\":\"stellaswap-logo-small.jpeg\",                 \"mimeType\":\"image/jpeg\",                 \"height\":36             },             \"large\":{                 \"width\":510,                 \"fileName\":\"stellaswap-logo-large.jpeg\",                 \"mimeType\":\"image/jpeg\",                 \"height\":510             },             \"full\":{                 \"width\":3000,                 \"fileName\":\"stellaswap-logo-full.jpeg\",                 \"mimeType\":\"image/jpeg\",                 \"height\":3000             }         },         \"chains\":[             \"moonbeam\"         ],         \"usersChange7d\":{             \"moonbeam\":-17.2727272727273         },         \"marketData\":{             \"symbol\":\"stella\",             \"marketCap\":808908,             \"marketCapRank\":2865,             \"priceChangePercentage1y\":-43.01356,             \"currentPrice\":0.01729378,             \"priceChangePercentage14d\":-17.23772,             \"contracts\":{                 \"moonbeam\":\"0x0e358838ce72d5e61e0018a2ffac4bec5f4c88d2\"             },             \"priceChangePercentage60d\":-39.75633,             \"priceChangePercentage30d\":-26.13934,             \"priceChangePercentage24h\":-4.63782,             \"priceChangePercentage200d\":-74.57003,             \"marketCapChangePercentage24h\":-4.62971,             \"priceChange24h\":-0.0008410608839097,             \"marketCapChange24h\":-39268.122562502,             \"priceChangePercentage7d\":-7.91278         },         \"projectCreationDate\":1644828523000,         \"contracts\":[             {                 \"chain\":\"moonbeam\",                 \"contract\":\"0x0e358838ce72d5e61e0018a2ffac4bec5f4c88d2\"             }         ],         \"updatedAt\":1722544694830,         \"category\":\"dex\",         \"description\":\"StellaSwap is one of the first automated market-making (AMM), decentralized exchange (DEX) for the Moonbeam parachain network. The unique value proposition of StellaSwap is that we're committed in establishing a strong foundation with our native token, STELLA, as a governance token, diverse farms, a built in bridge and user-centered service. \\r\\n\\r\\nStellaSwap's main objective is to create a broader range of network effects to address the issues of liquidity in the DeFi space, instead of limiting ourselves to a single solution like many DEXs are doing now. This manifests itself in the diverse product suite of StellaSwap that will be explained in more details. Our products are structured in such a way that facilitates decentralized governance of STELLA holders, while continuing to innovate on the collective foundations by design.\",         \"usersChange1d\":{             \"moonbeam\":-6.18556701030928         }     } }</p>"}, {"location": "learn/dapp-directory/#query-a-category", "title": "查询类别", "text": "<p>您还可以通过类别查询 API。例如，您可以使用以下查询检索有关所有 NFT 项目的信息：</p> <p>bash https://apps.moonbeam.network/api/ds/v1/app-dir/projects?category=nfts</p> 用于查询 NFT 项目的 API 响应 <p>{     \"projects\":[         {             \"urls\":{                 \"telegram\":\"https://t.me/nfts2me\",                 \"website\":\"https://nfts2me.com/\",                 \"try\":\"https://nfts2me.com/\",                 \"twitter\":\"https://twitter.com/nfts2me\",                 \"medium\":\"https://nfts2me.medium.com/\",                 \"discord\":\"https://nfts2me.com/discord/\"             },             \"slug\":\"nfts2me\",             \"createdAt\":1699292617117,             \"logo\":{                 \"small\":{                     \"width\":36,                     \"fileName\":\"nfts2me-logo-small.jpeg\",                     \"mimeType\":\"image/jpeg\",                     \"height\":36                 },                 \"large\":{                     \"width\":512,                     \"fileName\":\"nfts2me-logo-large.jpeg\",                     \"mimeType\":\"image/jpeg\",                     \"height\":512                 },                 \"full\":{                     \"width\":3000,                     \"fileName\":\"nfts2me-logo-full.jpeg\",                     \"mimeType\":\"image/jpeg\",                     \"height\":3000                 }             },             \"name\":\"NFTs2Me\",             \"chains\":[                 \"moonbeam\"             ],             \"defiLLamaTvlExist\":false,             \"projectCreationDate\":1673608509000,             \"shortDescription\":\"NFTs2Me is a toolkit for creating and managing NFT projects.\",             \"contracts\":[                 {                     \"chain\":\"moonbeam\",                     \"contract\":\"0x2269bCeB3f4e0AA53D2FC43B1B7C5C5D13B119a5\"                 }             ],             \"updatedAt\":1722498896566,             \"category\":\"nfts\",             \"description\":\"NFTs2Me is a tool for creating and managing NFT projects. It includes features such as an art generator, delayed reveal, minting widget, token gating, and support for multiple blockchain platforms. It also offers customization options, an affiliate system, automatic logo and banner generation, and support for redeemable NFTs. It is user-friendly and suitable for those new to the world of NFTs.\\n\\nIn addition to these features, NFTs2Me also offers a minting widget and free IPFS hosting to make it simple to mint and store your NFTs securely and efficiently. The minting widget allows you to easily create and mint new NFTs, while the free IPFS hosting provides a secure and decentralized way to store your NFTs.\",             \"id\":\"nfts2me\",             \"tags\":[                 \"NFT\",                 \"Tool\"             ]         },         {             \"urls\":{                 \"telegram\":\"https://t.me/rmrkapp\",                 \"website\":\"https://singular.app/\",                 \"try\":\"https://singular.app/\",                 \"twitter\":\"https://twitter.com/RmrkSingular\",                 \"discord\":\"https://discord.gg/TjB6v5AGZz\"             },             \"slug\":\"singular-app\",             \"createdAt\":1699292616171,             \"logo\":{                 \"small\":{                     \"width\":36,                     \"fileName\":\"singular-app-logo-small.png\",                     \"mimeType\":\"image/png\",                     \"height\":36                 },                 \"large\":{                     \"width\":400,                     \"fileName\":\"singular-app-logo-large.png\",                     \"mimeType\":\"image/png\",                     \"height\":400                 },                 \"full\":{                     \"width\":3000,                     \"fileName\":\"singular-app-logo-full.png\",                     \"mimeType\":\"image/png\",                     \"height\":3000                 }             },             \"name\":\"Singular App\",             \"chains\":[                 \"moonbeam\"             ],             \"defiLLamaTvlExist\":false,             \"projectCreationDate\":1686240710000,             \"shortDescription\":\"The home of NFTs by @RmrkApp. Create and trade your nestable, equippable, soulbound, and multi-asset NFTs with us - no coding required.\",             \"contracts\":[</p> <pre><code>        ],\n        \"updatedAt\":1722498914806,\n        \"category\":\"nfts\",\n        \"description\":\"Singular is an NFT 2.0 marketplace that allows users to buy, sell, and trade both regular and advanced NFTs. Users can create and/or connect a wallet, browse digital items, and securely conduct transactions using blockchain technology.\",\n        \"id\":\"singular-app\",\n        \"tags\":[\n            \"NFT Marketplaces\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https:/t.me/metacourtgg\",\n            \"website\":\"https://www.metacourt.gg/\",\n            \"try\":\"https://www.metacourt.gg/\",\n            \"twitter\":\"https://twitter.com/metacourtgg\",\n            \"medium\":\"https://metacourtgg.medium.com/\",\n            \"discord\":\"https://discord.gg/9AnnfKCb39\"\n        },\n        \"slug\":\"metacourt\",\n        \"createdAt\":1699292616238,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"metacourt-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":512,\n                \"fileName\":\"metacourt-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":512\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"metacourt-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Metacourt\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1663756794000,\n        \"shortDescription\":\"Metacourt created NFTdeals for anyone who wants to become an influencer and trade their social media\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498888422,\n        \"category\":\"nfts\",\n        \"description\":\"Influencer accelerator for anyone who wants to become an influencer in the space. We allow selling your social media through NFTs and joining influencer marketing campaigns.\",\n        \"id\":\"metacourt\",\n        \"tags\":[\n            \"NFT Marketplaces\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/tofuNFT\",\n            \"website\":\"https://tofunft.com/\",\n            \"try\":\"https://tofunft.com/\",\n            \"twitter\":\"https://twitter.com/tofuNFT\",\n            \"medium\":\"https://medium.com/tofunftofficial\",\n            \"discord\":\"https://discord.com/invite/3wFUTZmTm7\"\n        },\n        \"slug\":\"tofunft\",\n        \"createdAt\":1699292615874,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"tofunft-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"tofunft-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"tofunft-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"tofuNFT\",\n        \"chains\":[\n            \"moonbeam\",\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1644828523000,\n        \"shortDescription\":\"The largest multichain NFT marketplace\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498924881,\n        \"category\":\"nfts\",\n        \"description\":\"tofuNFT.com is an NFT marketplace focused on GameFi and collectibles, rebranded from SCV’s NFT market. Enjoy exploring &amp; trading with your buddies!\",\n        \"id\":\"tofunft\",\n        \"tags\":[\n            \"NFT Marketplaces\",\n            \"NFT\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"website\":\"https://d-book.io\",\n            \"try\":\"https://d-book.io\",\n            \"twitter\":\"https://twitter.com/dbook_io\"\n        },\n        \"slug\":\"d-book.io\",\n        \"createdAt\":1699292617021,\n        \"logo\":{\n            \"small\":{\n                \"width\":129,\n                \"fileName\":\"d-book.io-logo-small.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":129,\n                \"fileName\":\"d-book.io-logo-large.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":36\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"d-book.io-logo-full.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"D-book.io\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1682016612000,\n        \"shortDescription\":\"Buğra Ayan is a speaker,and university lecturer in Turkey who founded the Web3 Association Turkey.\",\n        \"contracts\":[\n            {\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x8d4BA02D0973749ad7c646DcaAa60BDC66F6F6D2\"\n            }\n        ],\n        \"updatedAt\":1722498866417,\n        \"category\":\"nfts\",\n        \"description\":\"We are an NFT Book Platform that connects authors and the decentralized world, aiming for a transformation ecosystem.\",\n        \"id\":\"d-book.io\",\n        \"tags\":[\n            \"NFT Marketplaces\",\n            \"NFT\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/BcmHuntGroup\",\n            \"website\":\"https://bcmhunt.com/\",\n            \"try\":\"https://bcmhunt.com/\",\n            \"twitter\":\"https://twitter.com/bcmhunt\",\n            \"medium\":\"https://medium.com/bcmhunt\",\n            \"discord\":\"https://discord.com/invite/Ee9aJ287J2\"\n        },\n        \"slug\":\"blockchain-monster-hunt\",\n        \"createdAt\":1699292616780,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"blockchain-monster-hunt-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":510,\n                \"fileName\":\"blockchain-monster-hunt-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":510\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"blockchain-monster-hunt-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Blockchain Monster Hunt\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1644828523000,\n        \"shortDescription\":\"The First Multichain NFT Monster Hunt\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498855937,\n        \"category\":\"nfts\",\n        \"description\":\"Blockchain Monster Hunt (BCMH) is the world’s first multi-chain game that runs entirely on the blockchain itself. Inspired by Pokémon-GO,BCMH allows players  to continuously explore brand new places on the blockchain to hunt and battle monsters. Each block on the blockchain is a unique digital space where a limited number of monsters (of the same DNA gene and rarity) may exist.  Players and collectors can hunt or battle for a chance to capture these unique monsters and to earn coins.\",\n        \"id\":\"blockchain-monster-hunt\",\n        \"tags\":[\n            \"NFT\",\n            \"Gaming\",\n            \"GLMR Grants\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"website\":\"https://speedboat.studio/\",\n            \"try\":\"https://speedboat.studio/\",\n            \"twitter\":\"https://twitter.com/Speedboat_STDO\",\n            \"medium\":\"https://medium.com/@speedboat_studio\",\n            \"discord\":\"https://discord.gg/y7TQbtEWSV\"\n        },\n        \"slug\":\"speedboat.studio\",\n        \"createdAt\":1699292616328,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"speedboat.studio-logo-small.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":190,\n                \"fileName\":\"speedboat.studio-logo-large.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":190\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"speedboat.studio-logo-full.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Speedboat\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1657584952000,\n        \"shortDescription\":\"Your no-code Web3 toolkit\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498916466,\n        \"category\":\"nfts\",\n        \"description\":\"Speedboat is a Web3 toolkit for everyone. Built on the idea that NFTs are not just expensive JPEGs, but programmable experiences.\",\n        \"id\":\"speedboat.studio\",\n        \"tags\":[\n            \"NFT\",\n            \"Tool\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/+qGh0InPSPc1iMTNk\",\n            \"website\":\"https://www.glmrapes.com/\",\n            \"try\":\"https://www.glmrapes.com/\",\n            \"twitter\":\"https://twitter.com/GLMRApes\",\n            \"discord\":\"https://discord.com/invite/glmrapes\"\n        },\n        \"web3goContracts\":[\n            {\n                \"name\":\"GLMR Apes: GLMR Ape\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x8fbe243d898e7c88a6724bb9eb13d746614d23d6\"\n            },\n            {\n                \"name\":\"GLMR Apes: GLMR Jungle\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xcb13945ca8104f813992e4315f8ffefe64ac49ca\"\n            }\n        ],\n        \"currentTx\":{\n            \"moonbeam\":7830\n        },\n        \"slug\":\"glmr-apes\",\n        \"web3goIDs\":[\n            \"GLMR Apes\"\n        ],\n        \"createdAt\":1699292616827,\n        \"logo\":{\n            \"small\":{\n                \"width\":47,\n                \"fileName\":\"glmr-apes-logo-small.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":528,\n                \"fileName\":\"glmr-apes-logo-large.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":408\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"glmr-apes-logo-full.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"GLMR APES\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"usersChange7d\":{\n            \"moonbeam\":-66.6666666666667\n        },\n        \"currentUsers\":{\n            \"moonbeam\":1531\n        },\n        \"projectCreationDate\":1644828523000,\n        \"shortDescription\":\"The first NFT collection on GLMR by &amp; for the community\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722547408370,\n        \"category\":\"nfts\",\n        \"description\":\"GLIMMER APES is the first NFT collection on GLMR by &amp; for the community. The longer you’re bonding with GLMR Apes and the friendlier their behavior. Join the troops as soon as possible to become an EARLY APE, take part in our giveaways and games and land in the GLMR APE VIP CLUB.\",\n        \"id\":\"glmr-apes\",\n        \"tags\":[\n            \"NFT\",\n            \"Gaming\"\n        ],\n        \"usersChange1d\":{\n            \"moonbeam\":0\n        }\n    },\n    {\n        \"urls\":{\n            \"website\":\"https://snakesoldiers.com\",\n            \"try\":\"https://snakesoldiers.com\",\n            \"twitter\":\"https://twitter.com/snakesoldiers\",\n            \"github\":\"https://github.com/steven2308/snake-soldiers-contracts\",\n            \"medium\":\"https://medium.com/@snakesoldiers/emoting-to-influence-the-hatch-df3eab7e45b8\",\n            \"discord\":\"http://discord.gg/A6zQSz4YU4\"\n        },\n        \"slug\":\"snake-soldiers\",\n        \"createdAt\":1699292616971,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"snake-soldiers-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"snake-soldiers-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"snake-soldiers-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Snake Soldiers\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1691439275000,\n        \"shortDescription\":\"NFT game collection divided in 3 categories: Generals, Commanders and Soldiers🐍. Built on Moonbeam\",\n        \"contracts\":[\n            {\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x3ab955216BdD76f51fbe02A3fe237D6612BBD09F\"\n            }\n        ],\n        \"updatedAt\":1722498915320,\n        \"category\":\"nfts\",\n        \"description\":\"Snake Soldiers is an NFT collection with a supply of at most 5k units, all unique and distributed among 3 ranks. Each snake will be usable inside a play to own game, where snakes will be the main characters, necessary to interact with the SerpenTerra ecosystem. This metaverse will be based on the RMRK 2.0 standard, making forward compatible and giving super powers to the NFTs.\",\n        \"id\":\"snake-soldiers\",\n        \"tags\":[\n            \"NFT\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/+LqmDOeGUQdRmYjVh%60%60\",\n            \"website\":\"https://omni-x.io\",\n            \"try\":\"https://omni-x.io\",\n            \"twitter\":\"https://twitter.com/omnix_nft\",\n            \"github\":\"https://github.com/Omni-X-NFT\",\n            \"discord\":\"https://discord.gg/omni-x\"\n        },\n        \"slug\":\"omni-x\",\n        \"createdAt\":1699292617077,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"omni-x-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":107,\n                \"fileName\":\"omni-x-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":108\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"omni-x-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Omni-X\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1673811786000,\n        \"shortDescription\":\"The first natively omnichain NFT platform\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498898538,\n        \"category\":\"nfts\",\n        \"description\":\"Omni X is an omnichain NFT protocol and marketplace that connects communities, creators, and enthusiasts across multiple blockchains. \\n\\nWe provide tooling for creating ONFT collections, bridging regular NFTs to ONFTs and grant access to unparalleled liquidity that allows users to buy and sell NFTs from any blockchain to any other blockchain.\",\n        \"id\":\"omni-x\",\n        \"tags\":[\n            \"NFT Marketplaces\",\n            \"Infrastructure\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"website\":\"https://www.publicpressure.io/\",\n            \"try\":\"https://www.publicpressure.io/\",\n            \"twitter\":\"https://twitter.com/jointhepressure\",\n            \"discord\":\"https://discord.gg/publicpressure\"\n        },\n        \"slug\":\"publicpressure\",\n        \"createdAt\":1702283744356,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"publicpressure-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"publicpressure-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"publicpressure-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Public Pressure\",\n        \"chains\":[\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1651597275000,\n        \"shortDescription\":\"Support your favorite artists, own their music, get rewarded.\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498907699,\n        \"category\":\"nfts\",\n        \"description\":\"We are the web3 music platform powered by artists, labels and fans\",\n        \"id\":\"publicpressure\",\n        \"tags\":[\n            \"NFT Marketplaces\"\n        ]\n    },\n    {\n        \"currentTx\":{\n            \"moonbeam\":8409\n        },\n        \"web3goIDs\":[\n            \"Moonbeans\"\n        ],\n        \"name\":\"Moonbeans\",\n        \"currentUsers\":{\n            \"moonbeam\":1134\n        },\n        \"coinGeckoId\":\"moonbeans\",\n        \"shortDescription\":\"Galactic Co-Op &amp; Profit sharing NFT platform and soon to be Metaverse\",\n        \"id\":\"moonbeans\",\n        \"tags\":[\n            \"NFT Marketplaces\"\n        ],\n        \"urls\":{\n            \"website\":\"https://moonbeans.io/\",\n            \"twitter\":\"https://twitter.com/moonbeansio\",\n            \"github\":\"https://github.com/m00nbeans\",\n            \"discord\":\"https://discord.com/invite/qqE9aBPzQ9\",\n            \"telegram\":\"https://t.me/moonbeansio\",\n            \"try\":\"https://moonbeans.io/\",\n            \"medium\":\"https://medium.com/@MoonBeans\"\n        },\n        \"web3goContracts\":[\n            {\n                \"name\":\"Moonbeans: Beanie Distributor V2\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xda6367c6510d8f2d20a345888f9dff3eb3226b02\"\n            },\n            {\n                \"name\":\"Moonbeans: Marketplace V9\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x683724817a7d526d6256aec0d6f8ddf541b924de\"\n            },\n            {\n                \"name\":\"Moonbeans: Storefront Ownership V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x971dfedd548f2269e515957404cbbee1f507cd01\"\n            }\n        ],\n        \"slug\":\"moonbeans\",\n        \"createdAt\":1699292615978,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"moonbeans-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"moonbeans-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"moonbeans-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"chains\":[\n            \"moonbeam\",\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"usersChange7d\":{\n            \"moonbeam\":0\n        },\n        \"marketData\":{\n            \"symbol\":\"beans\",\n            \"marketCap\":0,\n            \"priceChangePercentage1y\":-62.22489,\n            \"currentPrice\":0.062264,\n            \"priceChangePercentage14d\":-13.93552,\n            \"contracts\":{\n\n            },\n            \"priceChangePercentage60d\":-44.93764,\n            \"priceChangePercentage30d\":-33.587,\n            \"priceChangePercentage24h\":-0.05451,\n            \"priceChangePercentage200d\":-83.0363,\n            \"marketCapChangePercentage24h\":0,\n            \"priceChange24h\":-0.0000339560550113,\n            \"marketCapChange24h\":0,\n            \"priceChangePercentage7d\":-5.36696\n        },\n        \"projectCreationDate\":1644828523000,\n        \"contracts\":[\n            {\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x65b09ef8c5a096c5fd3a80f1f7369e56eb932412\"\n            },\n            {\n                \"chain\":\"moonriver\",\n                \"contract\":\"0xC2392DD3e3fED2c8Ed9f7f0bDf6026fcd1348453\"\n            }\n        ],\n        \"updatedAt\":1722548296818,\n        \"category\":\"nfts\",\n        \"description\":\"Moonbeans is an NFT marketplace launched on October 8, 2021, featuring 465 Beanies on the Moonriver network. The platform offers NFT trading with fees for artists, traders, and project developers. Multiple collections are available, including Beanies and RivrMaids.\",\n        \"usersChange1d\":{\n            \"moonbeam\":0\n        }\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/blocsport\",\n            \"website\":\"https://blocsport.one/\",\n            \"try\":\"https://blocsport.one/\",\n            \"twitter\":\"https://twitter.com/blocsport1\",\n            \"medium\":\"https://blocsport1.medium.com/\"\n        },\n        \"slug\":\"blocsport-one\",\n        \"createdAt\":1699292616637,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"blocsport-one-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"blocsport-one-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"blocsport-one-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Blocsport.one\",\n        \"chains\":[\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1644828523000,\n        \"shortDescription\":\"Web 3.0 metaverse, smart sports money, athlete NFT launchpad &amp; assets tokenization\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498857332,\n        \"category\":\"nfts\",\n        \"description\":\"Blocsport.one is a Swiss sports tech company founded in 2019 that is transforming the sports business by building a transparent and reliable sports ecosystem uniting athletes, clubs, and fans based on blockchain. Company owns NFTdeals.io exclusive marketplace and has the biometric-enabled football scouting DApp live. Blocsport.one helps the young promising athletes get the money and exposure for their career development, which is nobody else doing in the world.\",\n        \"id\":\"blocsport-one\",\n        \"tags\":[\n            \"NFT\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/mintverse\",\n            \"website\":\"https://www.mintverse.com/\",\n            \"try\":\"https://www.mintverse.com/\",\n            \"twitter\":\"https://twitter.com/mintverse_\",\n            \"medium\":\"https://medium.com/mintverse\",\n            \"discord\":\"https://discord.com/invite/mhhnbvAaq9\"\n        },\n        \"slug\":\"mintverse\",\n        \"createdAt\":1702283733666,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"mintverse-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"mintverse-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"mintverse-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Mintverse\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1651597514000,\n        \"shortDescription\":\"Mint, Explore &amp; Trade Liquid NFT Assets Across Multiple Chains\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498889300,\n        \"category\":\"nfts\",\n        \"description\":\"Comprehensive NFT Aggregation Marketplace with a 0% trading fee\",\n        \"id\":\"mintverse\",\n        \"tags\":[\n            \"NFT Marketplaces\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/rmrkapp\",\n            \"website\":\"https://upgradooor.app\",\n            \"try\":\"https://upgradooor.app\",\n            \"twitter\":\"https://x.com/rmrkapp\",\n            \"github\":\"https://github.com/rmrk-team\",\n            \"medium\":\"https://medium.com/rmrkapp\"\n        },\n        \"slug\":\"upgradooor\",\n        \"createdAt\":1699292616895,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"upgradooor-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":512,\n                \"fileName\":\"upgradooor-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":512\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"upgradooor-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Upgradooor\",\n        \"chains\":[\n            \"moonbeam\",\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1692259742000,\n        \"shortDescription\":\"Upgrade your NFT 1.0 collections to NFT 2.0 by wrapping them into advanced functionality\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498927244,\n        \"category\":\"nfts\",\n        \"description\":\"As a collection issuer, use Upgradooor to initialize the process of upgrading your collection to NFT 2.0 if you are currently using ERC721.\\n\\nAs a holder, once the collection owner initiates the process, you can wrap any NFT you hold in that collection and instantly turn it into an equippable, multi-asset, composable NFT with no added risk.\\n\\nYou can always unwrap at will, and all the changes will still wait for you when you decide to re-claim the 2.0 wrapper again.\\n\\nUpgrading allows you to:\\n\\n- add more assets (outputs) to a legacy NFT, preventing needless airdrop spam\\n- airdrop NFTs into the NFT itself, preventing detachment of context, and saving tremendous amounts of gas by letting people transfer just the parent NFT\\n- define equippable settings and even achieve compatibility with other collections, for cross collection equippables and thus cross collection royalties and commissions\\n- see your NFTs on Singular, and use GBM auctions as a unique and novel listing mechanic\",\n        \"id\":\"upgradooor\",\n        \"tags\":[\n            \"NFT\",\n            \"Tool\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/moonfit_official_community\",\n            \"website\":\"https://moonfit.xyz/\",\n            \"try\":\"https://moonfit.xyz/\",\n            \"twitter\":\"https://twitter.com/MoonFitOfficial\",\n            \"discord\":\"https://discord.gg/hStdUVtHXp\"\n        },\n        \"slug\":\"moonfit\",\n        \"createdAt\":1702283734897,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"moonfit-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"moonfit-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"moonfit-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"MoonFit\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1654692249000,\n        \"shortDescription\":\"Web3 &amp; NFT Lifestyle App That Pays You Anytime You Burn Calories\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498891201,\n        \"category\":\"nfts\",\n        \"description\":\"MoonFit is a Web3 Lifestyle App that promotes active living by rewarding users with tokens and NFTs anytime they burn calories through physical activities.\",\n        \"id\":\"moonfit\",\n        \"tags\":[\n            \"NFT\",\n            \"Gaming\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/rmrkapp\",\n            \"website\":\"https://rmrk.app/\",\n            \"try\":\"https://rmrk.app/\",\n            \"twitter\":\"https://twitter.com/rmrkapp\",\n            \"discord\":\"https://discord.com/invite/bV9kQbVC99\"\n        },\n        \"slug\":\"rmrk\",\n        \"createdAt\":1699292615938,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"rmrk-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"rmrk-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"rmrk-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"RMRK\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"marketData\":{\n            \"symbol\":\"rmrk\",\n            \"marketCap\":5985029,\n            \"marketCapRank\":1602,\n            \"priceChangePercentage1y\":-64.99216,\n            \"currentPrice\":0.62974,\n            \"priceChangePercentage14d\":-24.26661,\n            \"contracts\":{\n                \"moonbeam\":\"0x524d524b4c9366be706d3a90dcf70076ca037ae3\"\n            },\n            \"priceChangePercentage60d\":-51.72181,\n            \"priceChangePercentage30d\":-30.11256,\n            \"priceChangePercentage24h\":-2.58554,\n            \"priceChangePercentage200d\":-75.55551,\n            \"marketCapChangePercentage24h\":-2.50147,\n            \"priceChange24h\":-0.01671434617594,\n            \"marketCapChange24h\":-153554.8536219,\n            \"priceChangePercentage7d\":-1.5052\n        },\n        \"coinGeckoId\":\"rmrk\",\n        \"projectCreationDate\":1644828523000,\n        \"shortDescription\":\"Creators of NFTs 2.0 via ERC6059, ERC6220, ERC5773, EIP6381, and EIP6454.\\nNFT equippables, future compatibility, reputation, and token balances.\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722548302467,\n        \"category\":\"nfts\",\n        \"description\":\"With the RMRK NFT Building Block System\\nOur ERC NFT standards allow you to unlock the true potential of NFTs.\\nTailored to work with each other, these EVM smart contracts will help you create your NFT projects of varying complexity.\",\n        \"id\":\"rmrk\",\n        \"tags\":[\n            \"NFT\",\n            \"Infrastructure\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"website\":\"https://www.mynft.com/\",\n            \"try\":\"https://bridge.mynft.com/home\",\n            \"twitter\":\"https://twitter.com/mynft\"\n        },\n        \"slug\":\"mynft\",\n        \"createdAt\":1699292616578,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"mynft-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"mynft-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"mynft-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"myNFT\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1644828523000,\n        \"shortDescription\":\"The marketplace that puts the power back in your hands\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498895020,\n        \"category\":\"nfts\",\n        \"description\":\"myNFT is the marketplace that puts the power back in your hands. It is a creative workshop, a trading platform and a discovery engine, helping you tell your story and share your passions, on your own terms. myNFT is built on decentralized technologies empowering you to create, trade, and discover. myNFT is built by Perpetual Altruism, a leader in the NFT space and the creator of charitable NFT publisher Cryptograph and the GBM auction system. Perpetual Altruism is backed by prominent investors and creators and is also the recipient of grants from the Web3 Foundation and the Moonbeam network for their work on the decentralized internet, which powers myNFT.\",\n        \"id\":\"mynft\",\n        \"tags\":[\n            \"NFT Marketplaces\",\n            \"GLMR Grants\",\n            \"MOVR Grants\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"website\":\"https://readl.co/\",\n            \"try\":\"https://readl.co/\",\n            \"twitter\":\"https://twitter.com/readl_co\",\n            \"medium\":\"https://medium.com/@readlnetwork\",\n            \"discord\":\"https://discord.gg/XPTENepHqY\"\n        },\n        \"slug\":\"readl\",\n        \"createdAt\":1702283745749,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"readl-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":512,\n                \"fileName\":\"readl-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":512\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"readl-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Readl\",\n        \"chains\":[\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1655885161000,\n        \"shortDescription\":\"Bringing the publishing industry to web3\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498910044,\n        \"category\":\"nfts\",\n        \"description\":\"Readl is the protocol that provides publishers and storytellers with the infrastructure to publish their content on the blockchain, while providing a user-friendly platform to enjoy any story, in any format.\",\n        \"id\":\"readl\",\n        \"tags\":[\n            \"NFT Marketplaces\",\n            \"MOVR Grants\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/rmrkapp\",\n            \"website\":\"https://emotes.app\",\n            \"try\":\"https://emotes.app\",\n            \"twitter\":\"https://x.com/rmrkapp\",\n            \"github\":\"https://github.com/rmrk-team\",\n            \"medium\":\"https://medium.com/rmrkapp\"\n        },\n        \"slug\":\"emotes.app\",\n        \"createdAt\":1699292616951,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"emotes.app-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":512,\n                \"fileName\":\"emotes.app-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":512\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"emotes.app-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Emotes.app\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1692254489000,\n        \"shortDescription\":\"React on anyone's NFT - throw 💩 at those apes, give a 🤗 to those Pudgies!\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498871347,\n        \"category\":\"nfts\",\n        \"description\":\"Emotes.app is a RMRK mini-app which allows you to send emotes / reactions to anyone's NFT. It utilizes RMRK's ERC7009 and is trivial to integrate into any project wanting to take advantage of the community's reactions to their NFTs.\\n\\nUse it to direct storylines, affect NFT egg hatching, or just do relative price comparison when influencers like one NFTs and dislike another!\",\n        \"id\":\"emotes.app\",\n        \"tags\":[\n            \"NFT\",\n            \"Social\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://twitter.com/PolkaPets\",\n            \"website\":\"https://www.polkapet.world/\",\n            \"try\":\"https://www.polkapet.world/\",\n            \"twitter\":\"https://twitter.com/PolkaPets\",\n            \"medium\":\"https://polkapetworld.medium.com/\"\n        },\n        \"slug\":\"polkapet-world\",\n        \"createdAt\":1702283743596,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"polkapet-world-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"polkapet-world-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"polkapet-world-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"PolkaPets\",\n        \"chains\":[\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"marketData\":{\n            \"priceChangePercentage60d\":1206.42918,\n            \"symbol\":\"pets\",\n            \"marketCap\":0,\n            \"priceChangePercentage30d\":619.39533,\n            \"priceChangePercentage200d\":135.91624,\n            \"priceChangePercentage1y\":355.00061,\n            \"currentPrice\":0.00515699,\n            \"priceChangePercentage14d\":-15.30948,\n            \"contracts\":{\n                \"moonriver\":\"0x1e0f2a75be02c025bd84177765f89200c04337da\"\n            },\n            \"priceChangePercentage7d\":749.62625\n        },\n        \"coinGeckoId\":\"polkapet-world\",\n        \"projectCreationDate\":1651157216000,\n        \"shortDescription\":\"Welcome to PolkaPet World\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722548303208,\n        \"category\":\"nfts\",\n        \"description\":\"An immersive NFT collection created in partnership with the biggest and best PolkaDot projects \",\n        \"id\":\"polkapet-world\",\n        \"tags\":[\n            \"NFT\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"website\":\"https://www.moonarines.com/\",\n            \"try\":\"https://www.moonarines.com/\",\n            \"discord\":\"https://discord.gg/bXhSyW8htW\"\n        },\n        \"slug\":\"moonarines\",\n        \"createdAt\":1702283733870,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"moonarines-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"moonarines-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"moonarines-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Moonarines\",\n        \"chains\":[\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1654792422000,\n        \"shortDescription\":\"Be part of the conquest of the digital space\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498889804,\n        \"category\":\"nfts\",\n        \"description\":\"The Moonarines are unique NFT characters starting soon on the Moonriver Network!\\nWith the Moonarines, the NFT owners will be taken to an unforgettable adventure to explore the Cryptoverse!\",\n        \"id\":\"moonarines\",\n        \"tags\":[\n            \"NFT\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/NFTrade\",\n            \"website\":\"https://nftrade.com/\",\n            \"try\":\"https://nftrade.com/\",\n            \"twitter\":\"https://twitter.com/NFTradeOfficial\",\n            \"medium\":\"https://medium.com/@NFTrade\",\n            \"discord\":\"https://discord.com/invite/SESqfsyw8k\"\n        },\n        \"slug\":\"nftrade\",\n        \"createdAt\":1699292616005,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"nftrade-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"nftrade-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"nftrade-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"NFTrade\",\n        \"chains\":[\n            \"moonbeam\",\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"marketData\":{\n            \"symbol\":\"nftd\",\n            \"marketCap\":234018,\n            \"marketCapRank\":3653,\n            \"priceChangePercentage1y\":-65.38449,\n            \"currentPrice\":0.00502075,\n            \"priceChangePercentage14d\":-7.09922,\n            \"contracts\":{\n\n            },\n            \"priceChangePercentage60d\":-27.37596,\n            \"priceChangePercentage30d\":-14.12267,\n            \"priceChangePercentage24h\":-2.22137,\n            \"priceChangePercentage200d\":-56.66993,\n            \"marketCapChangePercentage24h\":-2.16658,\n            \"priceChange24h\":-0.00011406326237191,\n            \"marketCapChange24h\":-5182.473845666,\n            \"priceChangePercentage7d\":-6.88049\n        },\n        \"coinGeckoId\":\"nftrade\",\n        \"projectCreationDate\":1644828523000,\n        \"shortDescription\":\"Create, Buy, Sell, Swap and Farm NFTs\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722548304198,\n        \"category\":\"nfts\",\n        \"description\":\"NFTrade is a multi-chain platform for NFT creation and trading. Seamlessly launch, mint, and swap non-fungible tokens. Earn digital collectibles. NFTrade places you at the heart of the NFT economy. Create, Buy, Sell, Swap and Farm NFTs. All chains, All NFTs, One Platform.\",\n        \"id\":\"nftrade\",\n        \"tags\":[\n            \"NFT Marketplaces\",\n            \"MOVR Grants\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"website\":\"https://www.pipcards.com/\",\n            \"try\":\"https://www.pipcards.com/\",\n            \"twitter\":\"https://twitter.com/pipcards\",\n            \"discord\":\"https://discord.com/invite/hnSC7QjTHj\"\n        },\n        \"slug\":\"pipcards\",\n        \"createdAt\":1699292616371,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"pipcards-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"pipcards-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"pipcards-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"PIP Cards\",\n        \"chains\":[\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1651149583000,\n        \"shortDescription\":\"Post-generated NFT playing card decks\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498904704,\n        \"category\":\"nfts\",\n        \"description\":\"PIPS is a first-of-its-kind NFT generative playing card project that will enable NFT holders to generate an entire deck of custom cards to be used cross-chain.\",\n        \"id\":\"pipcards\",\n        \"tags\":[\n            \"NFT\",\n            \"Gaming\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"website\":\"https://bithotel.io/\",\n            \"twitter\":\"https://twitter.com/playbithotel\",\n            \"github\":\"https://github.com/BitHotelOrg/bithotel-token-contracts\",\n            \"discord\":\"https://discord.gg/RFFZNwxY9n\",\n            \"telegram\":\"https://t.me/bithotelcommunity\",\n            \"try\":\"https://bithotel.io/\",\n            \"medium\":\"https://medium.com/@bithotelnftgame\"\n        },\n        \"slug\":\"bit-hotel\",\n        \"createdAt\":1702283710425,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"bit-hotel-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":500,\n                \"fileName\":\"bit-hotel-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":500\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"bit-hotel-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Bit Hotel\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1658743551000,\n        \"shortDescription\":\"Bit Hotel is a Social-first Play 2 Earn NFT Gaming Metaverse set in a Pixel-art Hotel.\",\n        \"contracts\":[\n            {\n                \"chain\":\"moonbeam\",\n                \"contract\":\"Not deployed yet\"\n            },\n            {\n                \"chain\":\"moonriver\",\n                \"contract\":\"Not deployed yet\"\n            }\n        ],\n        \"updatedAt\":1722498854706,\n        \"category\":\"nfts\",\n        \"description\":\"In Bit Hotel users can compete to earn Bit Hotel tokens and acquire native NFTs. These NFTs have in-game utilities and consist of characters, hotel rooms, furniture and other assets that have their own unique perks. With over 250k Hotel Guests cross-channel, this nostalgic Hotel metaverse is taking people back to their 8bit upbringing.\",\n        \"id\":\"bit-hotel\",\n        \"tags\":[\n            \"NFT\",\n            \"Gaming\"\n        ]\n    },\n    {\n        \"tvlChange7d\":{\n            \"moonriver\":0.00190215150271202\n        },\n        \"urls\":{\n            \"website\":\"https://www.moonbeamdao.com/\",\n            \"try\":\"https://www.moonbeamdao.com/\",\n            \"twitter\":\"https://twitter.com/moonbeam_dao\",\n            \"medium\":\"https://medium.com/@moonbeamdao\",\n            \"discord\":\"https://discord.gg/AevrFzwZjk\"\n        },\n        \"web3goContracts\":[\n            {\n                \"name\":\"MoonDAO: MDAO Token\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xc6342eab8b7cc405fc35eba7f7401fc400ac0709\"\n            }\n        ],\n        \"currentTx\":{\n            \"moonbeam\":972\n        },\n        \"slug\":\"moondao\",\n        \"web3goIDs\":[\n            \"MoonDAO\"\n        ],\n        \"createdAt\":1699292616416,\n        \"tvlChange1d\":{\n            \"moonriver\":-0.0349944884006391\n        },\n        \"logo\":{\n            \"small\":{\n                \"width\":25,\n                \"fileName\":\"moondao-logo-small.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":330,\n                \"fileName\":\"moondao-logo-large.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":475\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"moondao-logo-full.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"MoonDAO\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"currentTVL\":{\n            \"moonriver\":76.75665\n        },\n        \"currentUsers\":{\n            \"moonbeam\":229\n        },\n        \"projectCreationDate\":1648347145000,\n        \"shortDescription\":\"The first &amp; only community art dao on moonbeam\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722547637377,\n        \"category\":\"nfts\",\n        \"description\":\"MoonDao is the first community Art Collection DAO on the Moonbeam network!\\n\\nWe aim to utilize input from our community to select high-end NFT’s. These NFT’s will be acquired with the MoonDao treasury and stored in the MoonDao Vault.\\n\\nMoon ownership grants access to DAO voting rights, future events, and additional holder perks outlined below. Welcome to the moon, we hope you stay.\\n\\n\",\n        \"id\":\"moondao\",\n        \"tags\":[\n            \"NFT\",\n            \"DAO\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/raresama\",\n            \"website\":\"https://raresama.com/\",\n            \"try\":\"https://raresama.com/\",\n            \"twitter\":\"https://twitter.com/RaresamaNFT\",\n            \"discord\":\"https://discord.com/channels/938592318380982303/1010237900685840405\"\n        },\n        \"slug\":\"raresama\",\n        \"createdAt\":1699292615958,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"raresama-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"raresama-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"raresama-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Raresama\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1662528828000,\n        \"shortDescription\":\"Discover amazing Rare digital artwork\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498909462,\n        \"category\":\"nfts\",\n        \"description\":\"Raresama brings the magic of owning a piece of artwork to your fingertips. Create or browse NFT art collections and enjoy a diverse mix of artists, genres, styles and movements.\",\n        \"id\":\"raresama\",\n        \"tags\":[\n            \"NFT Marketplaces\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://gal.xyz/telegram\",\n            \"website\":\"https://galxe.com/\",\n            \"try\":\"https://galxe.com/\",\n            \"twitter\":\"https://twitter.com/Galxe\",\n            \"medium\":\"https://blog.galxe.com/\",\n            \"discord\":\"https://gal.xyz/discord\"\n        },\n        \"slug\":\"galxe\",\n        \"createdAt\":1699292616277,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"galxe-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"galxe-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"galxe-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Galxe\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1659868871000,\n        \"shortDescription\":\"Create Impactful Experiences With #Web3 Credentials. (Formerly Project Galaxy) \",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498876438,\n        \"category\":\"nfts\",\n        \"description\":\"Galxe is the leading Web3 credential data network in the world. A collaborative credential infrastructure enabling brands and developers to engage communities and build robust products in Web3.\",\n        \"id\":\"galxe\",\n        \"tags\":[\n            \"NFT\",\n            \"Social\",\n            \"Tool\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"http://t.me/MoonsamaNFT\",\n            \"website\":\"https://moonsama.com/\",\n            \"try\":\"https://moonsama.com/\",\n            \"twitter\":\"https://twitter.com/MoonsamaNFT\",\n            \"discord\":\"discord.gg/moonsama\"\n        },\n        \"slug\":\"moonsama\",\n        \"createdAt\":1702283735408,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"moonsama-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":512,\n                \"fileName\":\"moonsama-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":512\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"moonsama-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Moonsama\",\n        \"chains\":[\n            \"moonriver\",\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1651156798000,\n        \"shortDescription\":\"Let's build the multiverse\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498892389,\n        \"category\":\"nfts\",\n        \"description\":\"Moonsama’s protocol for bi-directional bridging of on-chain digital assets and off-chain applications. This is how we connect web2.0 games, metaverses and blockchains. It enables new games, development and community fun from across the Kusamaverse and beyond!\",\n        \"id\":\"moonsama\",\n        \"tags\":[\n            \"NFT\",\n            \"Gaming\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"website\":\"https://smartstamp.com/\",\n            \"try\":\"https://smartstamp.com/\",\n            \"discord\":\"https://discord.gg/kajPqvZY\"\n        },\n        \"slug\":\"smartstamp\",\n        \"createdAt\":1699292617058,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"smartstamp-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":436,\n                \"fileName\":\"smartstamp-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":436\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"smartstamp-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"SmartStamp\",\n        \"chains\":[\n            \"moonbeam\",\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1675081766000,\n        \"shortDescription\":\"SmartStamp is the pioneering new standard in identification and authentication for the art world.\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498915044,\n        \"category\":\"nfts\",\n        \"description\":\"Developed over more than a decade, SmartStamp’s app uses patented AI technology that is designed to read and record artworks’ surface characteristics– offering artists, collectors, institutions, and all arts and culture stakeholders a way to securely and immutably link physical objects to their digital fingerprints on the blockchain. Using the SmartStamp app is as simple as taking a picture, making the groundbreaking security and timestamping power of blockchain technology accessible to anyone who can use a smartphone.\",\n        \"id\":\"smartstamp\",\n        \"tags\":[\n            \"NFT\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/yusernetwork\",\n            \"website\":\"https://yuser.network/\",\n            \"try\":\"https://yuser.network/\",\n            \"twitter\":\"https://twitter.com/yuser\",\n            \"medium\":\"https://medium.com/yuser\",\n            \"discord\":\"https://discord.com/invite/uRRxnfAjhY\"\n        },\n        \"slug\":\"yuser\",\n        \"createdAt\":1699292616605,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"yuser-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":512,\n                \"fileName\":\"yuser-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":512\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"yuser-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Yuser\",\n        \"chains\":[\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1644828523000,\n        \"shortDescription\":\"The first NFT social networking app- by creators, for creators\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498932483,\n        \"category\":\"nfts\",\n        \"description\":\"Yuser’s mission is to build an ecosystem of interconnected applications that put power back into the hands of users by giving them full control over their content, data, and personal networks. Developers can connect via an API to instantly gain access to millions of users and incentivize them to try their product by paying them with a token.\",\n        \"id\":\"yuser\",\n        \"tags\":[\n            \"NFT Marketplaces\",\n            \"GLMR Grants\",\n            \"MOVR Grants\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/cryptosoots\",\n            \"website\":\"https://raregems.io/my#\",\n            \"try\":\"https://raregems.io/my#\",\n            \"twitter\":\"https://twitter.com/RareGems_io\"\n        },\n        \"slug\":\"rare-gems\",\n        \"createdAt\":1702283745336,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"rare-gems-logo-small.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":360,\n                \"fileName\":\"rare-gems-logo-large.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":360\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"rare-gems-logo-full.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Rare Gems\",\n        \"chains\":[\n            \"moonriver\",\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1652705611000,\n        \"shortDescription\":\"Multichain NFT marketplace.\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498909205,\n        \"category\":\"nfts\",\n        \"description\":\"Multichain NFT marketplace\\nCreated by \\n@cryptosoots\",\n        \"id\":\"rare-gems\",\n        \"tags\":[\n            \"NFT Marketplaces\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/rmrkapp\",\n            \"website\":\"https://wizard.rmrk.dev\",\n            \"try\":\"https://wizard.rmrk.dev\",\n            \"twitter\":\"https://x.com/rmrkapp\",\n            \"github\":\"https://github.com/rmrk-team\",\n            \"medium\":\"https://medium.com/rmrkapp\"\n        },\n        \"slug\":\"rmrk-wizard\",\n        \"createdAt\":1699292616919,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"rmrk-wizard-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":512,\n                \"fileName\":\"rmrk-wizard-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":512\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"rmrk-wizard-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"RMRK Wizard\",\n        \"chains\":[\n            \"moonbeam\",\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1692255253000,\n        \"shortDescription\":\"A no-code-but-code wizard UI for building NFTs 2.0\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498911520,\n        \"category\":\"nfts\",\n        \"description\":\"A simple UI to put together NFT 2.0 legos created by the RMRK.app team. Use this tool to get started developing advanced NFT collections by picking from a set of functions you need, and the tool will compose code for you which only needs final tweaks before being deployed!\",\n        \"id\":\"rmrk-wizard\",\n        \"tags\":[\n            \"NFT\",\n            \"Tool\",\n            \"Developer Tools\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/evelonapp\",\n            \"website\":\"https://platform.evelon.app/\",\n            \"try\":\"https://www.evelon.app/\",\n            \"twitter\":\"https://twitter.com/EvelonApp\"\n        },\n        \"slug\":\"evelon-app\",\n        \"createdAt\":1699292616145,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"evelon-app-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":512,\n                \"fileName\":\"evelon-app-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":512\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"evelon-app-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Evelon.App\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1690486894000,\n        \"shortDescription\":\"Transform the way you create and bring to life your own unique DNFTs, with the revolutionary platform that combines cutting-edge AI technology.\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498873048,\n        \"category\":\"nfts\",\n        \"description\":\"Evelon is a no code platform that allows you to create and deploy dynamic NFTs with ease. This project is a game changer in the world of NFTs and image generation. Evelon uses AI to generate high-quality images, making it possible to create NFTs with unique visuals that are both dynamic and engaging.\",\n        \"id\":\"evelon-app\",\n        \"tags\":[\n            \"NFT\",\n            \"Tool\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"website\":\"https://mintlabz.io/\",\n            \"try\":\"https://app.mintlabz.io/\",\n            \"twitter\":\"https://twitter.com/mintlabz\",\n            \"medium\":\"https://blog.mintlabz.io/\",\n            \"discord\":\"https://discord.com/invite/BRF2PEetea\"\n        },\n        \"slug\":\"mintlabz\",\n        \"createdAt\":1712311518649,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"mintlabz-logo-small.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"mintlabz-logo-large.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"mintlabz-logo-full.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Mintlabz\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1712189524,\n        \"shortDescription\":\"MintLabz is a complete crosschain NFT solution at zero cost.\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498889042,\n        \"category\":\"nfts\",\n        \"description\":\"MintLabz aims to establish a digital NFT minting platform for third party projects to create NFT collections with utilities to reward the NFT holder. Our mission is to become the number one choice for providing complete cross-chain NFT solutions to B2B customers.\",\n        \"id\":\"mintlabz\",\n        \"tags\":[\n            \"nfts\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/golempark\",\n            \"website\":\"https://golempark.com\",\n            \"try\":\"https://golempark.com\",\n            \"twitter\":\"https://twitter.com/golempark\",\n            \"discord\":\"https://discord.gg/rNvtdHN8q7\"\n        },\n        \"slug\":\"golem-park\",\n        \"createdAt\":1699292617039,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"golem-park-logo-small.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":512,\n                \"fileName\":\"golem-park-logo-large.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":512\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"golem-park-logo-full.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Golem Park\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1676839105000,\n        \"shortDescription\":\"Golem Park is holders friendly NFT collection. P2E blockchain game, $GP Token, Staking Pools &amp; more\",\n        \"contracts\":[\n            {\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x74746524f5A31F08e0528FaA704C2c5d8d116506\"\n            }\n        ],\n        \"updatedAt\":1722498878088,\n        \"category\":\"nfts\",\n        \"description\":\"First Time In Crypto History Token Burning Campaign!\\n30% Of Total Token Supply Will Be Burned In 30 Days.\\n\\nAfter Minting We Are Going To Release Deflationary $GP Token &amp; 50% Of Total Supply Will Be Distributed To All $GP NFT Holders, 1 NFT = 5 000 000 Tokens. Then 30 Days Each Day We'll Burn 1% Of Total Token Supply To Ensure Token Price Will Go UP!\\n\\nWorld Of Golems is a decentralized Play-To-Earn blockchain game.\\nOnce You Become Golem Park NFT Holder You Will Be Able To Participate in the WoG Game, Own Countries And Display Your Message On Them.\\n\\nThe Leaderboard Shows Of TOP 5 Wealthiest Countries &amp; Every Month Owners Of These Countries Will Be Rewarded With $GLMR.\",\n        \"id\":\"golem-park\",\n        \"tags\":[\n            \"NFT\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/rarible\",\n            \"website\":\"https://rarible.com/\",\n            \"try\":\"https://rarible.com/\",\n            \"twitter\":\"https://x.com/rarible\",\n            \"discord\":\"https://discord.com/invite/rarible\"\n        },\n        \"slug\":\"rarible\",\n        \"createdAt\":1722498909701,\n        \"logo\":{\n            \"small\":{\n                \"width\":429,\n                \"fileName\":\"rarible-small.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":121\n            },\n            \"large\":{\n                \"width\":858,\n                \"fileName\":\"rarible-medium.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":242\n            },\n            \"full\":{\n                \"width\":1716,\n                \"fileName\":\"rarible-large.png\",\n                \"mimeType\":\"image/png\",\n                \"height\":485\n            }\n        },\n        \"name\":\"Rarible\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"shortDescription\":\"Rarible - NFT Marketplace for Brands, Communities and Traders\",\n        \"projectCreationDate\":1721872843,\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498909701,\n        \"category\":\"nfts\",\n        \"description\":\"Discover, sell and buy NFTs on Rarible! Our aggregated NFT marketplace for Ethereum NFTs and Polygon NFTs powers brands, collections and creator marketplaces.\",\n        \"id\":\"rarible\",\n        \"featured\":false,\n        \"tags\":[\n            \"NFT\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"website\":\"https://neoncrisis.io/\",\n            \"try\":\"https://neoncrisis.io/\",\n            \"twitter\":\"https://twitter.com/NeonCrisisNFT\",\n            \"discord\":\"https://discord.gg/MVVjT9k9eD\"\n        },\n        \"slug\":\"neoncrisis-io\",\n        \"createdAt\":1702283737907,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"neoncrisis-io-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":319,\n                \"fileName\":\"neoncrisis-io-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":319\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"neoncrisis-io-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"Neon Crisis\",\n        \"chains\":[\n            \"moonriver\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1654792548000,\n        \"shortDescription\":\"6,008 heroes on the $MOVR network. A $RMRK powered metaverse featuring battle simulations, equipables, and more!\",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498896060,\n        \"category\":\"nfts\",\n        \"description\":\"\",\n        \"id\":\"neoncrisis-io\",\n        \"tags\":[\n            \"NFT\",\n            \"Gaming\"\n        ]\n    },\n    {\n        \"urls\":{\n            \"telegram\":\"https://t.me/xp_network\",\n            \"website\":\"https://xp.network/\",\n            \"try\":\"https://xp.network/\",\n            \"twitter\":\"https://twitter.com/xpnetwork_\",\n            \"discord\":\"https://discord.com/invite/g3vkcsmd38\"\n        },\n        \"slug\":\"xp-network\",\n        \"createdAt\":1699292615205,\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"xp-network-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":400,\n                \"fileName\":\"xp-network-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":400\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"xp-network-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"name\":\"XP Network\",\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"defiLLamaTvlExist\":false,\n        \"projectCreationDate\":1673327644000,\n        \"shortDescription\":\"A powerful NFT bridge trusted by all major blockchains \",\n        \"contracts\":[\n\n        ],\n        \"updatedAt\":1722498932103,\n        \"category\":\"nfts\",\n        \"description\":\"We build software tools that enable experienced developers and non-coding blockchain community members to move their assets seamlessly and intuitively between versatile distributed ledgers. By doing so, we encourage unlimited growth of exchange and trade between otherwise isolated ecosystems. We enable them to enrich each other technologically with insights and discoveries. To gain access to new, previously inaccessible markets with users hungry for fresh ideas and technologies to invest in.\",\n        \"id\":\"xp-network\",\n        \"tags\":[\n            \"NFT\",\n            \"Bridges\"\n        ]\n    }\n],\n\"count\":39\n</code></pre> <p>}</p> <p>以下是所有可能的类别及其各自的参数，用于查询 API。请确保使用完全按照显示的小写格式设置的参数查询 API。</p> 类别 API 参数 桥 <code>bridges</code> DAO <code>dao</code> DEX <code>dex</code> DeFi <code>defi</code> 游戏 <code>gaming</code> 借贷 <code>lending</code> NFT <code>nfts</code> 其他 <code>other</code> 社交 <code>social</code> 钱包 <code>wallets</code>"}, {"location": "learn/dapp-directory/#query-a-chain", "title": "查询链", "text": "<p>以下查询可用于查询 Moonbeam 或 Moonriver 上列出的所有项目。请注意，DApp 目录中不支持 Moonbase Alpha 网络。</p> MoonbeamMoonriver <p>bash https://apps.moonbeam.network/api/ds/v1/app-dir/projects?chain=moonbeam</p> <p>bash https://apps.moonbeam.network/api/ds/v1/app-dir/projects?chain=moonriver</p>      You are responsible for checking and validating the accuracy and truthfulness of all content. You are also responsible for doing your own diligence to understand the applicable risks present, including selection, performance, security, accuracy, or use of any third-party information.  All information contained herein is subject to modification without notice."}, {"location": "learn/core-concepts/balances/", "title": "Moonbeam 账户余额", "text": ""}, {"location": "learn/core-concepts/balances/#introduction", "title": "简介", "text": "<p>虽然 Moonbeam 致力于与以太坊的 Web3 API 和 EVM 兼容，但在账户余额方面，开发人员应该了解并理解 Moonbeam 的一些重要差异。</p> <p>Moonbeam 的设计目标之一是创建一个尽可能接近以太坊的环境，并提供一组与以太坊兼容的 Web3 RPC 端点。然而，Moonbeam 也是一条基于 Substrate 的链，这意味着它公开了 Substrate RPC，并且它具有由 Substrate 提供支持的集成功能，例如 Staking、Governance 以及其他不属于以太坊 API 的功能。</p> <p>Moonbeam 的统一账户是 Moonbeam 实现以太坊兼容性的一种方式，它通过更改协议中底层的账户类型，使其类似于以太坊（H160 或以 <code>0x</code> 开头的 20 字节地址）。统一账户被 Substrate 和以太坊 API 使用，并映射到区块链上相同的底层数据存储。然而，通过以太坊 API 使用 Moonbeam 账户时，来自以太坊的用户应该了解一些重要的差异。</p> <p>本指南将概述这些主要差异中的一些，以及首次使用 Moonbeam 时的预期情况。</p>"}, {"location": "learn/core-concepts/balances/#ethereum-account-balances", "title": "以太坊账户余额", "text": "<p>以太坊上的账户是一个具有代币余额（在本例中为以太币或ETH）的实体。账户持有人可以在以太坊上发送以太币交易，账户可以由用户（使用用于签名的私钥）或智能合约控制。</p> <p>因此，以太坊有两种主要类型的账户：用户所有和合约所有。无论类型如何，以太坊账户都有一个单一的余额字段，表示该地址拥有的Wei的数量，其中Wei是以太币的一个面额（每个ETH为1 x 10^18 Wei）。</p> <p></p>"}, {"location": "learn/core-concepts/balances/#moonbeam-account-balances", "title": "Moonbeam 账户余额", "text": "<p>Moonbeam 上的账户也是一个具有代币余额的实体（代币将取决于网络）。与以太坊一样，账户持有人可以在他们连接的 Moonbeam 网络上发送代币交易。此外，账户可以由用户（使用私钥进行签名）或智能合约控制。</p> <p>与以太坊一样，主要有两种类型的账户：用户拥有的和合约拥有的。但是，在 Moonbeam 上，在这两种账户类型中，还有代理账户，它们可以代表另一个账户执行有限数量的操作。在余额方面，所有 Moonbeam 账户类型都有五 (5) 种不同的余额类型：</p> <ul> <li>可用 — 指的是可以从 Substrate API 使用（未锁定/冻结）的余额。<code>可用</code>余额的概念取决于要执行的操作。例如，在民主投票中，不会从<code>可用</code>余额中扣除分配给投票的余额，但代币持有人将无法转移该余额</li> <li>可减少 — 指的是可以通过 Moonbeam 上的以太坊 API 使用（未锁定/冻结）的余额。例如，这是 MetaMask 引擎显示的余额。它是真正可消费的余额，用于核算所有民主锁定（在 Polkadot.js Apps 中显示为可转移）</li> <li>保留 — 指的是由于链上要求而持有的余额，可以通过执行一些链上操作来释放。例如，创建代理账户或设置链上身份的保证金显示为<code>保留余额</code>。在释放这些资金之前，不能通过以太坊 API 转移或访问这些资金</li> <li>其他冻结 — 表示在提取资金时，<code>可用</code>余额不能低于的余额，交易费用支付除外。例如，用于对治理提案进行投票的资金显示为<code>其他冻结</code>。在释放这些资金之前，不能通过以太坊 API 转移或访问这些资金</li> <li>费用冻结 — 表示专门支付交易费用时，<code>可用</code>余额不能低于的余额。在释放这些资金之前，不能通过以太坊 API 转移或访问这些资金</li> </ul> <p></p>"}, {"location": "learn/core-concepts/balances/#calculating-your-transferable-balance", "title": "计算您的可转移余额", "text": "<p>账户的可转移或可消费余额可以计算为可用余额减去 <code>0</code> 或冻结和保留代币之间的差额的最大值：</p> <p>text Transferable = free - max(0, frozen - reserved )</p> <p>以下是计算可转移余额的两个示例：</p> <p>账户拥有 <code>1000</code> 个可用代币、<code>200</code> 个冻结代币和 <code>50</code> 个保留代币。可转移余额计算如下：</p> <p>text Transferable = 1000 - max(0, 200 - 50) = 1000 - 150 = 850</p> <p>如果冻结的代币少于保留的代币，例如拥有 <code>1000</code> 个可用代币、<code>100</code> 个冻结代币和 <code>150</code> 个保留代币，则可转移余额将为：</p> <p>text Transferable = 1000 - max(0, 100 - 150) = 1000 - 0 = 1000</p>"}, {"location": "learn/core-concepts/balances/#retrieve-your-balance", "title": "检索您的余额", "text": "<p>您可以使用Polkadot.js API查看您的余额，包括您的可用（或可转账）余额和保留余额（如果存在）。</p> <p>Note</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n\nconst main = async () =&gt; {\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n  });\n\n  const balances = await polkadotApi.query.system.account('INSERT_ADDRESS');\n  console.log(balances.toHuman());\n};\n\nmain();\n</code></pre> <p>Note</p> <p>从运行时 4000 开始，由于 <code>ParachainStaking</code> pallet 从已弃用的 <code>Currency</code> 特征迁移到现代 <code>Fungible</code> 特征，质押锁已被余额冻结所取代。先前使用标识符 [<code>stkngcol</code>, <code>stkngdel</code>] 读取 <code>Balances.Locks</code> 的查询现在必须使用冻结原因 [<code>StakingCollator</code>, <code>StakingDelegator</code>] 读取 <code>Balances.Freezes</code>。</p> <p>您可以使用 Polkadot.js API 检索您的余额冻结，如下所示。</p> <pre><code>// Query Balances.Freezes\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({ provider: wsProvider });\n  const freezes = await api.query.balances.freezes('INSERT_ADDRESS_HERE');\n  console.log(freezes.toHuman());\n};\n\nmain();\n</code></pre>"}, {"location": "learn/core-concepts/balances/#main-differences", "title": "主要差异", "text": "<p>以太坊和 Moonbeam 上的账户余额之间的主要区别在于 Moonbeam 上的锁定和保留余额的概念。这些代币仍然归该账户所有，但它们尚不可花费。</p> <p>从以太坊的 API 角度来看，一个账户可能会显示它具有一定的余额（称为 <code>reducible</code> 余额）。但是，在链上操作之后，此值可能会增加（或减少），而无需实际的余额转移。</p> <p>请务必注意，此处描述的账户和行为差异仅适用于具有基础资产（GLMR、MOVR）的账户余额，以及不与智能合约交互的该资产的余额。一旦 Moonbeam 账户余额与智能合约交互，其行为将与以太坊的行为相同。例如，如果您在 Moonriver 上包装 MOVR，则无法通过质押或治理操作来更改基础余额，因为这是合约存储的一部分。在这种情况下，该账户的可减少余额已提交给包装的 MOVR 智能合约，并且无法通过 Substrate 操作进行修改。</p>"}, {"location": "learn/core-concepts/consensus-finality/", "title": "Moonbeam 共识与最终性", "text": ""}, {"location": "learn/core-concepts/consensus-finality/#introduction", "title": "简介", "text": "<p>虽然 Moonbeam 致力于与以太坊的 Web3 API 和 EVM 兼容，但在共识和最终性方面，开发人员应该了解并理解 Moonbeam 的一些重要差异。</p> <p>简而言之，共识是不同参与方就共享状态达成一致的方式。当区块被创建时，网络中的节点必须决定哪个区块将代表下一个有效状态。最终性定义了该有效状态何时不能被更改或撤销。</p> <p>以太坊最初使用基于工作量证明（PoW）的共识协议，该协议提供概率最终性。然而，在 2022 年，以太坊切换到权益证明（PoS），它提供确定性最终性，并且不再使用 PoW。相比之下，Moonbeam 使用基于委托权益证明（DPoS）的混合共识协议，该协议也提供确定性最终性。DPoS 是 Polkadot 的提名权益证明（NPoS）概念的演变，它通过允许委托人选择他们想要支持的收集人候选者以及支持的幅度，从而将更多的权力交到代币持有者手中。</p> <p>本指南将概述围绕共识和最终性的一些主要差异，以及首次使用 Moonbeam 时的预期。</p>"}, {"location": "learn/core-concepts/consensus-finality/#ethereum-consensus-and-finality", "title": "以太坊共识和最终性", "text": "<p>以太坊目前使用 PoS 共识协议，其中验证者在网络中质押 ETH，并负责生成区块和检查新区块的有效性。区块生成的时间是固定的，分为 12 秒的 slot 和 32 个 slot 的 epoch。每个 slot 随机选择一个验证者来生成区块并将其广播到网络。每个 slot 都有一个随机选择的验证者委员会，负责确定区块的有效性。在网络中质押的越多，验证者被选中生成或验证区块的机会就越大。</p> <p>最终性在以太坊的 PoS 共识协议中是确定性的，并通过“检查点”区块实现。验证者在特定的检查点区块上就区块的状态达成一致，这些检查点区块始终是 epoch 中的第一个区块，如果三分之二的验证者同意，则该区块将被最终确定。区块的最终性可以被撤销；但是，存在强大的经济激励措施，因此验证者不会试图串通以撤销区块。您可以在 Vitalik 的 On Settlement Finality 博客中的 Casper 部分的最终性下找到更多信息。</p>"}, {"location": "learn/core-concepts/consensus-finality/#moonbeam-consensus-and-finality", "title": "Moonbeam 共识和最终性", "text": "<p>在 Polkadot 中，有收集人和验证人。收集人通过收集用户的交易并为中继链验证人生成状态转换证明来维护平行链（在本例中为 Moonbeam）。收集人集合（生成区块的节点）是根据他们在网络中拥有的权益来选择的。</p> <p>对于最终性，Polkadot 和 Kusama 依赖于 GRANDPA。GRANDPA 为任何给定的交易（区块）提供确定性的最终性。换句话说，当一个区块或交易被标记为最终时，除非通过链上治理或分叉，否则它不能被撤销。Moonbeam 遵循这种确定性的最终性。</p>"}, {"location": "learn/core-concepts/consensus-finality/#main-differences", "title": "PoS 和 DPoS 之间的主要区别", "text": "<p>在共识方面，Moonbeam 基于委托权益证明，而以太坊依赖于标准权益证明系统，它们略有不同。虽然这两种机制都依赖于使用权益来验证和创建新区块，但仍存在一些关键差异。</p> <p>对于以太坊上的 PoS，验证者会根据其在网络中的权益被选中来生产和验证区块。只要验证者已存放验证者押金，他们就可以被选中来生产和验证区块。但是，如前所述，在网络中的权益越大，验证者被选中来生产和验证区块的机会就越高。</p> <p>另一方面，对于 Moonbeam 上的 DPoS，收集者有资格根据他们自己的权益加上他们在网络中委托的权益来生产区块。任何通证持有者都可以选择将其权益委托给收集者候选人。按权益（包括委托）排序靠前的收集者候选人将加入活跃集。活跃集中的候选人数量受治理的约束。一旦进入活跃集，就会随机选择收集者来使用 Nimbus 共识框架生产区块。重要的是要注意，一旦收集者进入活跃集，他们的总权益不会影响他们被选中生产区块的机会。</p> <p>在最终性方面，由于以太坊使用的检查点最终性系统，以太坊上的区块完成最终确定所需的时间可能比 Moonbeam 上要长得多。在以太坊中，验证者在检查点区块处确定最终性，检查点区块始终是 epoch 中的第一个区块。由于一个 epoch 有 32 个 slot，每个 slot 为 12 秒，因此区块完成最终确定至少需要 384 秒或 6.4 分钟。</p> <p>Moonbeam 不使用检查点区块，而是依赖于 Polkadot 的 GRANDPA 最终性工具，其中最终性过程与区块生产并行完成。此外，最终性过程整合了区块链的结构，这允许中继链验证者对他们认为有效的最高区块进行投票。在这种情况下，投票将适用于所有达到最终确定区块的区块，这加快了最终确定过程。在区块被包含在中继链中之后，区块可以在 Moonbeam 上的一个区块内完成最终确定。</p>"}, {"location": "learn/core-concepts/consensus-finality/#check-tx-finality-with-ethereum-rpc-endpoints", "title": "使用以太坊 RPC 端点检查交易最终性", "text": "<p>虽然最终性工具各不相同，但您可以使用相同且相当简单的策略来检查以太坊和 Moonbeam 上的交易最终性：</p> <ol> <li>您向网络询问最新的已完成区块的哈希值</li> <li>您使用哈希值检索区块号</li> <li>您将其与交易的区块号进行比较。如果您的交易包含在先前的区块中，则表示已完成</li> <li>作为安全检查，按编号检索区块并验证给定的交易哈希是否在该区块中</li> </ol> <p>下面的代码段遵循此策略来检查事务的最终性。它使用 默认区块参数 的 <code>finalized</code> 选项来获取最新的已完成区块。</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>Note</p> <p>以下各节中提供的代码段不适用于生产环境。请确保针对每种用例进行调整。</p> <p>===</p> <pre><code>```js\nimport { ethers } from 'ethers';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TX_HASH';\n\n// Define the RPC of the provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT',\n    chainId: 1284,\n  }\n};\n\n// Define the Web3 provider\nconst web3Provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n\nconst main = async () =&gt; {\n  // Get the last finalized block\n  const finalizedBlockHeader = await web3Provider.getBlock('finalized');\n  const finalizedBlockNumber = finalizedBlockHeader.number;\n\n  // Get the transaction receipt of the given transaction hash\n  const txReceipt = await web3Provider.getTransactionReceipt(txHash);\n\n  // If block number of receipt is not null, compare it against finalized head\n  if (txReceipt) {\n    const txBlockNumber = txReceipt.blockNumber;\n\n    // As a safety check, get given block to check if transaction is included\n    const txBlock = await web3Provider.getBlock(txBlockNumber);\n\n    console.log(`Current finalized block number is ${finalizedBlockNumber}`);\n    console.log(\n      `Your transaction in block ${txBlockNumber} is finalized? ${\n        finalizedBlockNumber &gt;= txBlockNumber\n      }`\n    );\n    console.log(\n      `Your transaction is indeed in block ${txBlockNumber}? ${txBlock.transactions.includes(\n        txHash\n      )}`\n    );\n  } else {\n    console.log(\n      'Your transaction has not been included in the canonical chain'\n    );\n  }\n};\n\nmain();\n```\n</code></pre> <p>===</p> <pre><code>```js\nimport { Web3 } from 'web3';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TX_HASH';\n\n// Define the Web3 provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst web3Provider = new Web3('INSERT_RPC_API_ENDPOINT');\n\nconst main = async () =&gt; {\n  // Get the last finalized block\n  const finalizedBlockHeader = await web3Provider.eth.getBlock('finalized');\n  const finalizedBlockNumber = finalizedBlockHeader.number;\n\n  // Get the transaction receipt of the given transaction hash\n  const txReceipt = await web3Provider.eth.getTransactionReceipt(txHash);\n\n  // If block number of receipt is not null, compare it against finalized head\n  if (txReceipt) {\n    const txBlockNumber = txReceipt.blockNumber;\n\n    // As a safety check, get given block to check if transaction is included\n    const txBlock = await web3Provider.eth.getBlock(txBlockNumber);\n\n    console.log(`Current finalized block number is ${finalizedBlockNumber}`);\n    console.log(\n      `Your transaction in block ${txBlockNumber} is finalized? ${\n        finalizedBlockNumber &gt;= txBlockNumber\n      }`\n    );\n    console.log(\n      `Your transaction is indeed in block ${txBlockNumber}? ${txBlock.transactions.includes(\n        txHash\n      )}`\n    );\n  } else {\n    console.log(\n      'Your transaction has not been included in the canonical chain'\n    );\n  }\n};\n\nmain();\n\n```\n</code></pre> <p>===</p> <pre><code>```py\nfrom web3 import Web3\n\n# Define the transaction hash to check finality\ntx_hash = \"INSERT_TX_HASH\"\n\n# Define the Web3 provider for Moonbeam\n# This can be adapted for Moonriver or Moonbase Alpha\nweb3_provider = Web3(Web3.HTTPProvider(\"INSERT_RPC_API_ENDPOINT\"))\n\nif __name__ == \"__main__\":\n    # Get the latest finalized block\n    finalized_block_header = web3_provider.eth.get_block(\"finalized\")\n    finalized_block_number = finalized_block_header.number\n\n    # Get the transaction receipt of the given transaction hash\n    tx_receipt = web3_provider.eth.get_transaction_receipt(tx_hash)\n\n    # If block number of receipt is not null, compare it against finalized head\n    if tx_receipt is not None:\n        tx_block_number = tx_receipt.blockNumber\n\n        # As a safety check, get given block to check if transaction is included\n        tx_block = web3_provider.eth.get_block(tx_block_number)\n        is_in_block = False\n        for tx in tx_block.transactions:\n            if tx_hash == web3_provider.to_hex(tx):\n                is_in_block = True\n\n        print(f\"Current finalized block number is { str(finalized_block_number) }\")\n        print(\n            f\"Your transaction in block { str(tx_block_number) } is finalized? { str(finalized_block_number &gt;= tx_block_number) }\"\n        )\n        print(\n            f\"Your transaction is indeed in block { str(tx_block_number) }? { is_in_block }\"\n        )\n    else:\n        print(\"Your transaction has not been included in the canonical chain\")\n\n```\n</code></pre>"}, {"location": "learn/core-concepts/consensus-finality/#check-tx-finality-with-moonbeam-rpc-endpoints", "title": "使用 Moonbeam RPC 端点检查交易最终性", "text": "<p>Moonbeam 增加了对两个自定义 RPC 端点 <code>moon_isBlockFinalized</code> 和 <code>moon_isTxFinalized</code> 的支持，它们可用于检查链上事件是否已最终确定。 这些方法更直接一些，因为您无需比较区块号来确保您的交易已最终确定。</p> <p>有关更多信息，您可以访问 Moonbeam 自定义 API 页面的最终性 RPC 端点部分。</p> <p>您可以修改上面 Ethereum RPC 部分中的脚本，以使用 <code>moon_isBlockFinalized</code> 和 <code>moon_isTxFinalized</code>。 为此，您可以使用 Web3.js 和 Ethers.js 的 <code>send</code> 方法自定义调用 Substrate JSON-RPC。 也可以使用 Web3.py 和 <code>make_request</code> 方法进行自定义 RPC 请求。 您需要将方法名称和参数传递给自定义请求，您可以在 Moonbeam 自定义 API 页面上找到它们。</p> moon_isBlockFinalized Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers';\n\n// Define the block hash to check finality\nconst blockHash = 'INSERT_BLOCK_HASH';\n\n// Define the RPC of the provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT',\n    chainId: 1284,\n  },\n};\n\n// Define the Web3 provider\nconst web3Provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n\n// Define the function for the custom web3 request\nconst customWeb3Request = async (web3Provider, method, params) =&gt; {\n  try {\n    return await web3Provider.send(method, params);\n  } catch (error) {\n    throw new Error(error.body);\n  }\n};\n\nconst main = async () =&gt; {\n  // Check if the block has been finalized\n  const isFinalized = await customWeb3Request(\n    web3Provider,\n    'moon_isBlockFinalized',\n    [blockHash]\n  );\n  console.log(`Block is finalized? ${isFinalized}`);\n};\n\nmain();\n</code></pre> <pre><code>import { Web3 } from 'web3';\n\n// Define the block hash to check finality\nconst blockHash = 'INSERT_BLOCK_HASH';\n\n// Define the Web3 provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst web3Provider = new Web3('INSERT_RPC_API_ENDPOINT');\n\n// Define the function for the custom Web3 request\nconst customWeb3Request = async (web3Provider, method, params) =&gt; {\n  try {\n    return await requestPromise(web3Provider, method, params);\n  } catch (error) {\n    throw new Error(error);\n  }\n};\n\n// In Web3.js you need to return a promise\nconst requestPromise = async (web3Provider, method, params) =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    web3Provider.send(\n      {\n        jsonrpc: '2.0',\n        id: 1,\n        method,\n        params,\n      },\n      (error, result) =&gt; {\n        if (error) {\n          reject(error.message);\n        } else {\n          if (result.error) {\n            reject(result.error.message);\n          }\n          resolve(result);\n        }\n      }\n    );\n  });\n};\n\nconst main = async () =&gt; {\n  // Check if the block has been finalized\n  const isFinalized = await customWeb3Request(\n    web3Provider.currentProvider,\n    'moon_isBlockFinalized',\n    [blockHash]\n  );\n\n  console.log(JSON.stringify(isFinalized));\n  console.log(`Block is finalized? ${isFinalized.result}`);\n};\n\nmain();\n</code></pre> <pre><code>from web3 import Web3\n\n# Define the block hash to check finality\nblock_hash = 'INSERT_BLOCK_HASH'\n\n# Set the RPC_address for Moonbeam\n# This can also be adapted for Moonriver or Moonbase Alpha\nRPC_address = 'INSERT_RPC_API_ENDPOINT'\n\n# Define the Web3 provider\nweb3_provider = Web3(Web3.HTTPProvider(RPC_address))\n\n# Asynchronous JSON-RPC API request\ndef custom_web3_request(method, params):\n    response = web3_provider.provider.make_request(method, params)\n    return response\n\nif __name__ == \"__main__\":\n    # Check if the block has been finalized\n    is_finalized = custom_web3_request(\n       'moon_isBlockFinalized', [block_hash])\n    print(\n        f'Block is finalized? { is_finalized[\"result\"] }')\n</code></pre> moon_isTxFinalized Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TRANSACTION_HASH';\n\n// Define the RPC of the provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT',\n    chainId: 1284,\n  },\n};\n\n// Define the Web3 provider\nconst web3Provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n\n// Define the function for the custom web3 request\nconst customWeb3Request = async (web3Provider, method, params) =&gt; {\n  try {\n    return await web3Provider.send(method, params);\n  } catch (error) {\n    throw new Error(error.body);\n  }\n};\n\nconst main = async () =&gt; {\n  // Check if the transaction has been finalized\n  const isFinalized = await customWeb3Request(\n    web3Provider,\n    'moon_isTxFinalized',\n    [txHash]\n  );\n  console.log(`Transaction is finalized? ${isFinalized}`);\n};\n\nmain();\n</code></pre> <pre><code>import Web3 from 'web3';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TRANSACTION_HASH';\n\n// Define the Web3 provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst web3Provider = new Web3('INSERT_RPC_API_ENDPOINT');\n\n// Define the function for the custom Web3 request\nconst customWeb3Request = async (web3Provider, method, params) =&gt; {\n  try {\n    return await requestPromise(web3Provider, method, params);\n  } catch (error) {\n    throw new Error(error);\n  }\n};\n\n// In Web3.js you need to return a promise\nconst requestPromise = async (web3Provider, method, params) =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    web3Provider.send(\n      {\n        jsonrpc: '2.0',\n        id: 1,\n        method,\n        params,\n      },\n      (error, result) =&gt; {\n        if (error) {\n          reject(error.message);\n        } else {\n          if (result.error) {\n            reject(result.error.message);\n          }\n          resolve(result);\n        }\n      }\n    );\n  });\n};\n\nconst main = async () =&gt; {\n  // Check if the transaction has been finalized\n  const isFinalized = await customWeb3Request(\n    web3Provider.currentProvider,\n    'moon_isTxFinalized',\n    [txHash]\n  );\n\n  console.log(JSON.stringify(isFinalized));\n  console.log(`Transaction is finalized? ${isFinalized}`);\n};\n\nmain();\n</code></pre> <pre><code>from web3 import Web3\n\n# Define the transaction hash to check finality\ntx_hash = 'INSERT_BLOCK_HASH'\n\n# Set the RPC_address for Moonbeam\n# This can also be adapted for Moonriver or Moonbase Alpha\nRPC_address = 'INSERT_RPC_API_ENDPOINT'\n\n# Define the Web3 provider\nweb3_provider = Web3(Web3.HTTPProvider(RPC_address))\n\n# Asynchronous JSON-RPC API request\ndef custom_web3_request(method, params):\n    response = web3_provider.provider.make_request(method, params)\n    return response\n\nif __name__ == \"__main__\":\n    # Check if the transaction has been finalized\n    is_finalized = custom_web3_request(\n       'moon_isTxFinalized', [tx_hash])\n    print(\n        f'Transaction is finalized? { is_finalized[\"result\"] }')\n</code></pre>"}, {"location": "learn/core-concepts/consensus-finality/#check-tx-finality-with-substrate-rpc-endpoints", "title": "使用 Substrate RPC 终结点检查交易最终性", "text": "<p>使用 Substrate JSON-RPC 中的以下三个 RPC 请求，您可以获取当前最终确定的区块，并将其与您要检查最终性的交易的区块号进行比较：</p> <ul> <li><code>chain_getFinalizedHead</code> - 第一个请求获取最后一个最终确定区块的区块哈希值</li> <li><code>chain_getHeader</code> - 第二个请求获取给定区块哈希值的区块头</li> <li><code>eth_getTransactionReceipt</code> - 这将检索给定交易哈希值的交易回执</li> </ul> <p>Polkadot.js API 软件包 和 Python Substrate 接口软件包 为开发人员提供了一种使用 JavaScript 和 Python 与 Substrate 链交互的方式。</p> <p>您可以在 Polkadot.js 官方文档站点 中找到有关 Polkadot.js 和 Substrate JSON-RPC 的更多信息，在 PySubstrate 官方文档站点 中找到有关 Python Substrate 接口的更多信息。</p> <p>===</p> <pre><code>```js\nimport { ApiPromise, WsProvider } from '@polkadot/api';\nimport { types } from 'moonbeam-types-bundle';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TX_HASH';\n\n// Define the provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst wsProvider = new WsProvider('INSERT_WSS_API_ENDPOINT');\n\nconst main = async () =&gt; {\n  // Create the provider using Moonbeam types\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n    typesBundle: types,\n  });\n  await polkadotApi.isReady;\n\n  // Get the latest finalized block of the Substrate chain\n  const finalizedHeadHash = (\n    await polkadotApi.rpc.chain.getFinalizedHead()\n  ).toJSON();\n\n  // Get finalized block header to retrieve number\n  const finalizedBlockHeader = (\n    await polkadotApi.rpc.chain.getHeader(finalizedHeadHash)\n  ).toJSON();\n\n  // Get the transaction receipt of the given tx hash\n  const txReceipt = (\n    await polkadotApi.rpc.eth.getTransactionReceipt(txHash)\n  ).toJSON();\n\n  // You can not verify if the tx is in the block because polkadotApi.rpc.eth.getBlockByNumber\n  // does not return the list of tx hashes\n\n  // If block number of receipt is not null, compare it against finalized head\n  if (txReceipt) {\n    console.log(\n      `Current finalized block number is ${finalizedBlockHeader.number}`\n    );\n    console.log(\n      `Your transaction in block ${txReceipt.blockNumber} is finalized? ${\n        finalizedBlockHeader.number &gt;= txReceipt.blockNumber\n      }`\n    );\n  } else {\n    console.log(\n      'Your transaction has not been included in the canonical chain'\n    );\n  }\n\n  polkadotApi.disconnect();\n};\n\nmain();\n\n```\n</code></pre> <p>===</p> <pre><code>```py\nfrom substrateinterface import SubstrateInterface\n\n# Define the Ethereum transaction hash to check finality\ntx_hash = \"INSERT_TX_HASH\"\n\n# Point API provider to Moonbeam\n# This can be adapted for Moonriver or Moonbase Alpha\nmoonbeam_API_provider = SubstrateInterface(\n    url=\"INSERT_WSS_API_ENDPOINT\",\n)\n\nif __name__ == \"__main__\":\n    # Get the latest finalized block header of the chain\n    finalized_block_header = moonbeam_API_provider.get_block_header(finalized_only=True)\n    # Get the finalized block number from the block header\n    finalized_block_number = finalized_block_header[\"header\"][\"number\"]\n    # Get the transaction receipt of the given transaction hash through a\n    # custom RPC request\n    tx_receipt = moonbeam_API_provider.rpc_request(\n        \"eth_getTransactionReceipt\", [tx_hash]\n    )\n\n    # Check if tx_receipt is null\n    if tx_receipt is None:\n        print(\"The transaction hash cannot be found in the canonical chain.\")\n    else:\n        # Get the block number of the transaction\n        tx_block_number = int(tx_receipt[\"result\"][\"blockNumber\"], 16)\n        # Get the transaction block through a custom RPC request\n        tx_block = moonbeam_API_provider.rpc_request(\n            \"eth_getBlockByNumber\", [tx_block_number, False]\n        )\n\n        print(f\"Current finalized block number is { str(finalized_block_number) }\")\n        print(\n            f\"Your transaction in block { str(tx_block_number) } is finalized? { str(finalized_block_number &gt;= tx_block_number) }\"\n        )\n        print(\n            f'Your transaction is indeed in block { str(tx_block_number) }? { str(tx_hash in tx_block[\"result\"][\"transactions\"]) }'\n        )\n\n```\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "learn/core-concepts/glossary/", "title": "词汇表", "text": "<p>有很多术语是 Polkadot、Substrate 以及新兴的 Parity/Web3 生态系统所特有的。我们整理了一个术语列表，我们认为您在查看 Moonbeam 文档、计划和教程时会想了解这些术语。</p>"}, {"location": "learn/core-concepts/glossary/#collators", "title": "Collators", "text": "<p>为了支持 Polkadot 网络中的平行链，需要关键的网络参与者。在 Moonbeam 中，收集人是负责区块生产并将生产的区块提交到 Polkadot 中继链以进行最终确认的节点。</p>"}, {"location": "learn/core-concepts/glossary/#delegators", "title": "委托人", "text": "<p>Moonbeam 代币持有者，他们质押代币，为平行链上的特定收集人候选人担保。任何持有最低数量代币作为自由余额的用户都可以通过质押其代币成为委托人。</p>"}, {"location": "learn/core-concepts/glossary/#nominators", "title": "提名人", "text": "<p>中继链代币持有者，他们选择“支持”验证人。他们可以获得验证人奖励的一部分，但如果验证人行为不当，他们的质押代币可能会被削减。一个提名人最多可以支持 16 个验证人，并且他们的保证金将在被选入验证人集合的支持验证人之间完全分配。</p>"}, {"location": "learn/core-concepts/glossary/#nominated-proof-of-stake", "title": "被提名权益证明", "text": "<p>Polkadot用于选择其区块验证人集以最大化链安全性的机制。 它的核心是一个权益证明系统（PoS），其中提名人支持验证人。 得到最高支持的验证人将被选择为会话的验证人集的一部分。 如果验证人出现不当行为，其权益将被削减。 因此，提名人应尽职调查他们提名的验证人。</p>"}, {"location": "learn/core-concepts/glossary/#parachains", "title": "平行链", "text": "<p>一种具有插槽并连接到 Polkadot 的区块链。平行链从 Polkadot 接收共享安全性，并且能够与 Polkadot 网络上的其他平行链进行交互。它们必须锁定 DOT（原生中继链代币），以确保在特定时间段内（最长两年）的插槽。</p>"}, {"location": "learn/core-concepts/glossary/#parathreads", "title": "平行线程", "text": "<p>一种可以连接到 Polkadot 的区块链。平行线程能够与 Polkadot 网络的其他成员交互，但它们在逐个区块的基础上竞标区块最终确定（以 DOT 为单位）。它们与其他平行线程竞争区块最终确定，这意味着在这一轮中，出价最高的区块将被选中以进行最终确定。</p>"}, {"location": "learn/core-concepts/glossary/#polkadot", "title": "Polkadot", "text": "<p>一个互连的区块链网络，提供共享的安全性和链间交互的能力。Polkadot 是使用 Substrate 开发框架构建的。连接到 Polkadot 的链被称为平行链（parachains）。</p>"}, {"location": "learn/core-concepts/glossary/#relay-chain", "title": "中继链", "text": "<p>支撑 Polkadot 网络的骨干区块链。平行链连接到中继链，并使用它进行共享安全和消息传递。中继链上的验证人帮助保护平行链。</p>"}, {"location": "learn/core-concepts/glossary/#smart-contract", "title": "智能合约", "text": "<p>智能合约 是一种计算机程序或交易协议，旨在根据合同或协议的条款自动执行、控制或记录具有法律相关性的事件和操作。智能合约旨在减少对可信中间方、仲裁和执行成本的需求，并减少欺诈损失以及恶意和意外的例外情况。</p>"}, {"location": "learn/core-concepts/glossary/#substrate", "title": "Substrate", "text": "<p>一个基于 Rust 的区块链开发框架，由 Parity Technologies 根据他们实现多个区块链客户端的经验创建。Substrate 带有构建区块链所需的许多模块和功能，包括 P2P 网络、共识机制、质押、加密货币、链上治理模块等等。它大大减少了实现区块链所需的时间和工程工作。Substrate 现在是 Polkadot SDK 的一部分。</p>"}, {"location": "learn/core-concepts/glossary/#substrate-frame-pallets", "title": "Substrate Frame Pallets", "text": "<p>Substrate Frame Pallet 是一系列基于 Rust 的模块，提供了构建区块链所需的功能。</p>"}, {"location": "learn/core-concepts/glossary/#validators", "title": "验证人", "text": "<p>通过在网络中质押 DOT 来保护 Polkadot 中继链的节点，如果它们行为不端，其质押的 DOT 将被削减。它们最终确定平行链上整理人的区块，并且与其他验证人一起参与下一个中继链区块的共识。</p>"}, {"location": "learn/core-concepts/glossary/#webassemblywasm", "title": "WebAssembly/Wasm", "text": "<p>WebAssembly 是一种开放标准，它定义了一种可移植的二进制代码格式。它受到不同编程语言、编译器和浏览器的支持。</p>"}, {"location": "learn/core-concepts/security/", "title": "安全考量", "text": ""}, {"location": "learn/core-concepts/security/#introduction", "title": "简介", "text": "<p>在 Moonbeam 上开发智能合约时，需要注意一些在以太坊上开发时不会遇到的安全问题。Moonbeam 具有多个预编译合约，这些合约是 Solidity 接口，使开发人员可以通过以太坊 API 访问基于 Substrate 的功能，但绕过了 EVM。虽然预编译合约旨在改善开发人员的体验，但可能会有一些意想不到的后果需要考虑。</p> <p>本指南将概述并提供在 Moonbeam 上开发时需要注意的一些安全问题的示例。</p>"}, {"location": "learn/core-concepts/security/#arbitrary-code-execution", "title": "任意代码执行", "text": "<p>在Solidity中，任意代码执行是指能够执行代码并使用任意数量的任何类型的参数调用其他合约的函数。</p> <p>当智能合约允许用户影响其自身的<code>call()</code>并传入任意调用数据和/或<code>call()</code>的目标时，该智能合约允许对另一个合约进行任意执行。<code>call()</code>函数通过Solidity中的地址数据类型提供。当调用<code>call()</code>函数时，将使用任意调用数据调用目标合约。</p> <p>当合约A允许用户影响其对合约B的调用时，任意代码执行遵循下图中的模式。</p> <p></p> <p>如前所述，在Moonbeam上任意执行代码的一个主要问题是Moonbeam具有可调用的预编译合约，这可用于绕过通常在Ethereum上可用的一些保护措施。为了在Moonbeam上安全地使用任意代码执行，您应该考虑以下事项，这些事项仅适用于允许任意代码执行的合约：</p> <ul> <li>Moonbeam预编译合约，例如原生ERC-20预编译、XC-20预编译和XCM相关预编译，允许用户管理和转移资产，而无需访问EVM。相反，这些操作是使用原生Substrate代码完成的。因此，如果您的合约持有原生代币或XC-20，并允许任意代码执行，则可以使用这些预编译来耗尽合约的余额，绕过通常由EVM强制执行的任何安全检查</li> <li>当使用<code>call()</code>函数时，将交易对象的value属性设置为固定金额（例如，<code>call{value: 0}(...)</code>），可以通过调用原生资产预编译并在编码的调用数据中指定要转移的金额来绕过</li> <li>允许使用你合约的用户传入任意调用数据，这将在目标合约上执行任何函数，特别是如果目标合约是预编译合约，则不安全。为了安全起见，您可以为要允许执行的安全函数硬编码函数选择器</li> <li>在执行任意调用数据的函数中，将目标合约（包括预编译）列入黑名单不被认为是安全的，因为将来可能会添加其他预编译。在执行任意调用数据的函数中提供列入白名单的目标合约被认为是安全的，假设被调用的合约不是预编译，或者在它们是预编译的情况下，进行调用的合约不持有原生代币或任何XC-20</li> </ul> <p>在以下各节中，您将通过示例了解这些安全注意事项中的每一个。</p>"}, {"location": "learn/core-concepts/security/#setting-a-value", "title": "预编译可以覆盖设置值", "text": "<p>在以太坊上，允许任意代码执行的智能合约可以强制调用的值为特定数量（例如，<code>{value: 0}</code>），从而保证只有该数量的本地货币会随交易一起发送。而在 Moonbeam 上，原生 ERC-20 预编译合约 使您可以通过 Substrate API 与 Moonbeam 的本地货币进行交互，就像与 ERC-20 进行交互一样。因此，您可以通过设置调用的 <code>value</code> 以及通过原生 ERC-20 预编译来从智能合约转移 Moonbeam 本地资产。如果您设置了任意调用的 <code>value</code>，则可以通过定位 原生 ERC-20 预编译合约 并传入调用数据来转移本地资产，以此来覆盖该值。由于 ERC-20 和 XC-20 不是原生资产，因此设置 value 属性不能为以太坊或 Moonbeam 上的这些类型的资产提供任何保护。</p> <p>例如，如果您有一个允许任意代码执行的合约，并且您将编码的调用数据传递给它，该调用数据将合约的余额转移到另一个地址，那么您基本上可以耗尽给定合约的余额。</p> <p>要获取编码的调用数据，您可以使用 Solidity 文档中概述的任何 ABI 编码函数，包括 <code>abi.encodeWithSelector</code>，如下面的函数所示：</p> <pre><code>function getBytes(address _erc20Contract, address _arbitraryCallContract, address _to) public view returns (bytes memory) {\n    // Load ERC-20 interface of contract\n    IERC20 erc20 = IERC20(_erc20Contract);\n    // Get amount to transfer\n    uint256 amount = erc20.balanceOf(_arbitraryCallContract);\n    // Build the encoded call data\n    return abi.encodeWithSelector(IERC20.transfer.selector, _to, amount);\n}\n</code></pre> <p>获得编码的调用数据后，您可以对 原生 ERC-20 预编译合约 进行任意调用，将调用的值设置为 <code>0</code>，并将调用数据以字节形式传入：</p> <pre><code>function makeArbitraryCall(address _target, bytes calldata _bytes) public {\n    // Value: 0 does not protect against native ERC-20 precompile calls or XCM precompiles\n    (bool success,) = _target.call{value: 0}(_bytes);\n    require(success);\n}\n</code></pre> <p><code>0</code> 的值将被编码的调用数据中指定的要转移的金额覆盖，在本例中，该金额是合约的余额。</p>"}, {"location": "learn/core-concepts/security/#whitelisting-function-selectors", "title": "白名单安全函数选择器", "text": "<p>通过将特定的函数选择器加入白名单，您可以控制可以执行哪些函数，并确保只允许调用被认为是安全的且不调用预编译的函数。</p> <p>要获得要加入白名单的函数选择器，您可以keccack256 哈希该函数的签名。</p> <p>获得白名单函数选择器后，您可以使用内联汇编从编码的调用数据中获取函数选择器，并使用 require 函数比较这两个选择器。如果编码的调用数据中的函数选择器与白名单函数选择器匹配，则可以进行调用。否则，将抛出异常。</p> <pre><code>function makeArbitraryCall(address _target, bytes calldata _bytes) public {\n    // Get the function selector from the encoded call data\n    bytes4 selector;\n    assembly {\n        selector := calldataload(_bytes.offset)\n    }\n\n    // Ensure the call data calls an approved and safe function\n    require(selector == INSERT_WHITELISTED_FUNCTION_SELECTOR);\n\n    // Arbitrary call\n    (bool success,) = _target.call(_bytes);\n    require(success);\n}\n</code></pre>"}, {"location": "learn/core-concepts/security/#whitelisting-safe-contracts", "title": "将安全合约列入白名单", "text": "<p>通过在可以执行任意调用数据的函数中将特定的目标合约地址列入白名单，您可以确保该调用被认为是安全的，因为EVM将强制执行只能调用白名单中的合约。这假设被调用的合约不是预编译合约。如果它们是预编译合约，您需要确保发起调用的合约不持有原生代币或任何XC-20。</p> <p>将合约列入黑名单以防止任意代码执行不被认为是安全的，因为将来可能会添加其他预编译合约。</p> <p>要将给定的合约列入白名单，您可以使用 require 函数，它将目标合约地址与白名单中的合约地址进行比较。如果地址匹配，则可以执行该调用。否则，将抛出异常。</p> <pre><code>function makeArbitraryCall(address _target, bytes calldata _bytes) public {\n    // 确保合约地址是安全的\n    require(_target == INSERT_CONTRACT_ADDRESS);\n\n    // 任意调用\n    (bool success,) = _target.call(_bytes);\n    require(success);\n}\n</code></pre>"}, {"location": "learn/core-concepts/security/#bypass-sender-origin-checks", "title": "预编译可以绕过发送者与 Origin 检查", "text": "<p>交易 origin，或 <code>tx.origin</code>，是交易起源的外部拥有账户 (EOA) 的地址。而 <code>msg.sender</code> 是启动当前调用的地址。<code>msg.sender</code> 可以是 EOA 或合约。如果一个合约调用另一个合约，而不是直接从 EOA 调用合约，则这两个值可能不同。在这种情况下，<code>msg.sender</code> 将是调用合约，而 <code>tx.origin</code> 将是最初调用调用合约的 EOA。</p> <p>例如，如果 Alice 调用合约 A 中的一个函数，该函数随后调用合约 B 中的一个函数，那么在查看对合约 B 的调用时，<code>tx.origin</code> 是 Alice，而 <code>msg.sender</code> 是合约 A。</p> <p>Note</p> <p>作为最佳实践，<code>tx.origin</code> 不应用于授权。相反，您应该使用 <code>msg.sender</code>。</p> <p>您可以使用 require 函数 比较 <code>tx.origin</code> 和 <code>msg.sender</code>。如果它们是相同的地址，则表示您正在确保只有 EOA 才能调用该函数。如果 <code>msg.sender</code> 是合约地址，则会抛出异常。</p> <pre><code>function transferFunds(address payable _target) payable public {\n    require(tx.origin == msg.sender);\n    _target.call{value: msg.value};\n}\n</code></pre> <p>在以太坊上，您可以使用此检查来确保给定的合约函数只能由 EOA 调用一次。这是因为在以太坊上，EOA 在每次交易中只能与合约交互一次。但是，Moonbeam 并非如此，因为 EOA 可以通过使用预编译合约（例如 batch 和 call permit 预编译）一次与合约交互多次。</p> <p>使用 batch 预编译，用户可以原子地对合约执行多次调用。batch 函数的调用者将是 <code>msg.sender</code> 和 <code>tx.origin</code>，从而可以一次进行多个合约交互。</p> <p>使用 call permit 预编译，如果用户希望在一次交易中与合约交互多次，他们可以通过为每次合约交互签名一个许可并在单个函数调用中调度所有许可来实现。只有当调度器与许可签名者是同一账户时，这才会绕过 <code>tx.origin == msg.sender</code> 检查。否则，<code>msg.sender</code> 将是许可签名者，<code>tx.origin</code> 将是调度器，从而导致抛出异常。</p>"}, {"location": "learn/core-concepts/transfers-api/", "title": "Moonbeam 上的余额转移", "text": ""}, {"location": "learn/core-concepts/transfers-api/#introduction", "title": "简介", "text": "<p>尽管 Moonbeam 致力于与 Ethereum 的 Web3 API 和 EVM 兼容，但在基础网络代币（例如，GLMR 和 MOVR）的余额转移方面，开发人员应该了解和理解 Moonbeam 的一些重要差异。</p> <p>代币持有者有两种在 Moonbeam 上发起余额转移的方式。一方面，用户可以通过以太坊 API 使用 MetaMask、MathWallet 等应用程序或任何其他使用以太坊 JSON-RPC 的工具。另一方面，用户可以通过 Polkadot.js Apps 网站或直接使用 Substrate RPC 来使用 Substrate API。</p> <p>开发人员需要知道，代币持有者可以利用这两个 API 来转移基础层网络代币。请注意，这些注释不适用于其他资产的转移，例如 Moonriver 或 Moonbeam EVM 中基于 ERC-20 的资产。这些资产的转移只能通过以太坊 API 完成，因为这些是智能合约交互。</p> <p>本指南将概述用于基础层网络代币余额转移的两个 API 之间的主要区别，以及首次使用 Moonbeam 时的预期情况。</p>"}, {"location": "learn/core-concepts/transfers-api/#ethereum-transfers", "title": "Ethereum 转账", "text": "<p>使用 Ethereum API 进行简单的余额转账依赖于 <code>eth_sendRawTransaction</code> JSON-RPC。可以直接从一个账户转到另一个账户，也可以通过智能合约进行。</p> <p>有不同的策略来监听 Ethereum 上的转账或余额更改，本文档不涵盖这些策略。但它们都侧重于使用 Ethereum JSON-RPC 的不同策略。</p>"}, {"location": "learn/core-concepts/transfers-api/#moonbeam-transfers", "title": "Moonbeam 转账", "text": "<p>如前所述，Moonbeam 使代币持有者能够通过 Ethereum 和 Substrate API 执行底层的网络代币转账。在 Moonbeam 上触发代币转账有多种情况。因此，要监控所有转账，您应该使用 Polkadot.js SDK（Substrate API）。</p> <p>在介绍不同的场景之前，先介绍与区块相关的两个不同元素：</p> <ul> <li>Extrinsic — 指源于系统外部的状态更改。Extrinsic 最常见的形式是交易。它们按执行顺序排列</li> <li>Events — 指由 extrinsic 生成的日志。每个 extrinsic 可以有多个事件。它们按执行顺序排列</li> </ul> <p>不同的转账场景包括：</p> <ul> <li>Substrate 转账 — 将创建一个 extrinsic，即 <code>balances.transferAllowDeath</code> 或 <code>balances.transferKeepAlive</code>。它将触发一个 <code>balances.Transfer</code> 事件</li> <li>Substrate 功能 — 某些原生 Substrate 功能可以创建 extrinsic，将代币发送到某个地址。例如，Treasury 可以创建一个 extrinsic，如 <code>treasury.proposeSend</code>，它将触发一个或多个 <code>balances.Transfer</code> 事件</li> <li>Ethereum 转账 — 将创建一个带有空输入的 <code>ethereum.transact</code> extrinsic。它将触发一个 <code>balances.Transfer</code> 事件</li> <li>通过智能合约进行的 Ethereum 转账 — 将创建一个带有某些数据作为输入的 <code>ethereum.transact</code> extrinsic。它将触发一个或多个 <code>balances.Transfer</code> 事件</li> </ul> <p>上面描述的所有场景都将有效地转移底层的网络代币。监控所有这些场景最简单的方法是依赖 <code>balances.Transfer</code> 事件。</p>"}, {"location": "learn/core-concepts/transfers-api/#monitor-transfers", "title": "监控原生代币余额转移", "text": "<p>以下代码示例将演示如何监听通过 Substrate 或 Ethereum API 发送的两种类型的原生代币转移，可以使用 Polkadot.js API 库 或 Substrate API Sidecar。以下代码片段仅用于演示目的，未经修改和在生产环境中进一步测试，不应使用。</p>"}, {"location": "learn/core-concepts/transfers-api/#using-polkadotjs-api", "title": "使用Polkadot.js API", "text": "<p>Polkadot.js API 包为开发人员提供了一种使用 JavaScript 与 Substrate 链交互的方式。</p> <p>以下代码片段使用 <code>subscribeFinalizedHeads</code> 订阅新的最终确定的区块头，循环遍历从区块中获取的 extrinsics，并检索每个 extrinsic 的事件。然后，它检查是否有任何事件对应于 <code>balances.Transfer</code> 事件。如果是，它将提取转账的 <code>from</code>、<code>to</code>、<code>amount</code> 和 <code>tx hash</code>，并在控制台上显示。请注意，<code>amount</code> 以最小单位 (Wei) 显示。您可以在他们的 官方文档网站上找到有关 Polkadot.js 和 Substrate JSON-RPC 的所有可用信息。</p> <pre><code>import { typesBundlePre900 } from 'moonbeam-types-bundle';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\n// This script will listen to all GLMR transfers (Substrate &amp; Ethereum) and extract the tx hash\n// It can be adapted for Moonriver or Moonbase Alpha\n\nconst main = async () =&gt; {\n  // Define the provider for Moonbeam\n  const wsProvider = new WsProvider('wss://wss.api.moonbeam.network');\n  // Create the provider using Moonbeam types\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n    typesBundle: typesBundlePre900 as any,\n  });\n\n  // Subscribe to finalized blocks\n  await polkadotApi.rpc.chain.subscribeFinalizedHeads(\n    async (lastFinalizedHeader) =&gt; {\n      const [{ block }, records] = await Promise.all([\n        polkadotApi.rpc.chain.getBlock(lastFinalizedHeader.hash),\n        polkadotApi.query.system.events.at(lastFinalizedHeader.hash),\n      ]);\n\n      block.extrinsics.forEach((extrinsic, index) =&gt; {\n        const {\n          method: { args, method, section },\n        } = extrinsic;\n\n        const isEthereum = section == 'ethereum' &amp;&amp; method == 'transact';\n\n        // Gets the transaction object\n        const tx = args[0] as any;\n\n        // Convert to the correct Ethereum Transaction format\n        const ethereumTx =\n          isEthereum &amp;&amp;\n          ((tx.isLegacy &amp;&amp; tx.asLegacy) ||\n            (tx.isEip1559 &amp;&amp; tx.asEip1559) ||\n            (tx.isEip2930 &amp;&amp; tx.asEip2930));\n\n        // Check if the transaction is a transfer\n        const isEthereumTransfer =\n          ethereumTx &amp;&amp;\n          ethereumTx.input.length === 0 &amp;&amp;\n          ethereumTx.action.isCall;\n\n        // Retrieve all events for this extrinsic\n        const events = records.filter(\n          ({ phase }) =&gt;\n            phase.isApplyExtrinsic &amp;&amp; phase.asApplyExtrinsic.eq(index)\n        );\n\n        // This hash will only exist if the transaction was executed through Ethereum.\n        let ethereumHash = '';\n\n        if (isEthereum) {\n          // Search for Ethereum execution\n          events.forEach(({ event }) =&gt; {\n            if (event.section == 'ethereum' &amp;&amp; event.method == 'Executed') {\n              ethereumHash = event.data[2].toString();\n            }\n          });\n        }\n\n        // Search if it is a transfer\n        events.forEach(({ event }) =&gt; {\n          if (event.section == 'balances' &amp;&amp; event.method == 'Transfer') {\n            const from = event.data[0].toString();\n            const to = event.data[1].toString();\n            const balance = (event.data[2] as any).toBigInt();\n\n            const substrateHash = extrinsic.hash.toString();\n\n            console.log(\n              `Transfer from ${from} to ${to} of ${balance} (block #${lastFinalizedHeader.number})`\n            );\n            console.log(`  - Triggered by extrinsic: ${substrateHash}`);\n            if (isEthereum) {\n              console.log(\n                `  - Ethereum (isTransfer: ${isEthereumTransfer}) hash: ${ethereumHash}`\n              );\n            }\n          }\n        });\n      });\n    }\n  );\n};\n\nmain();\n</code></pre> <p>此外，您可以在此 GitHub 页面上找到与余额转账相关的更多特定案例的示例代码片段。</p>"}, {"location": "learn/core-concepts/transfers-api/#using-substrate-api-sidecar", "title": "使用 Substrate API Sidecar", "text": "<p>开发者还可以使用 Substrate API Sidecar（一个用于与使用 Substrate 框架构建的区块链交互的 REST API 服务）检索 Moonbeam 区块并监控通过 Substrate 和 Ethereum API 发送的交易。</p> <p>以下代码片段使用 Axios HTTP 客户端查询 Sidecar 端点 <code>/blocks/head</code> 以获取最新的已完成区块，然后解码该区块，以获取 EVM 和 Substrate API 级别的原生代币转移的 <code>from</code>、<code>to</code>、<code>value</code>、<code>tx hash</code> 和 <code>transaction status</code>。</p> <pre><code>import axios from 'axios';\n\n// This script will decode all native token transfers (Substrate &amp; Ethereum) in a given Sidecar block, and extract the tx hash. It can be adapted for any Moonbeam network.\n\n// Endpoint to retrieve the latest block\nconst endpoint = 'http://127.0.0.1:8080/blocks/head';\n\nasync function main() {\n  try {\n    // Retrieve the block from the Sidecar endpoint\n    const response = await axios.get(endpoint);\n    // Retrieve the block height of the current block\n    console.log('Block Height: ' + response.data.number);\n\n    // Iterate through all extrinsics in the block\n    response.data.extrinsics.forEach((extrinsic) =&gt; {\n      // Retrieve Ethereum Transfers\n      if (\n        extrinsic.method.pallet === 'ethereum' &amp;&amp;\n        extrinsic.method.method === 'transact'\n      ) {\n        // Get the value for any of the three EIP transaction standards supported\n        const value =\n          (extrinsic.args.transaction.legacy &amp;&amp;\n            extrinsic.args.transaction.legacy.value) ||\n          (extrinsic.args.transaction.eip1559 &amp;&amp;\n            extrinsic.args.transaction.eip1559.value) ||\n          (extrinsic.args.transaction.eip2930 &amp;&amp;\n            extrinsic.args.transaction.eip2930.value);\n\n        // Iterate through the events to get transaction details\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'ethereum' &amp;&amp;\n            event.method.method === 'Executed'\n          ) {\n            console.log('From: ' + event.data[0]);\n            console.log('To: ' + event.data[1]);\n            console.log('Tx Hash: ' + event.data[2]);\n            console.log('Value: ' + value);\n            // Check the execution status\n            if (event.data[3].succeed) {\n              console.log('Status: Success');\n            } else {\n              console.log('Status: Failed');\n            }\n          }\n        });\n      }\n\n      // Retrieve Substrate Transfers\n      if (\n        extrinsic.method.pallet === 'balances' &amp;&amp;\n        (extrinsic.method.method === 'transferKeepAlive' ||\n          extrinsic.method.method === 'transferAllowDeath')\n      ) {\n        // Iterate through the events to get transaction details\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'balances' &amp;&amp;\n            event.method.method === 'Transfer'\n          ) {\n            console.log('From: ' + event.data[0]);\n            console.log('To: ' + event.data[1]);\n            console.log('Tx Hash: ' + extrinsic.hash);\n            console.log('Value: ' + event.data[2]);\n            // Check the execution status\n            if (extrinsic.success) {\n              console.log('Status: Success');\n            } else {\n              console.log('Status: Failed');\n            }\n          }\n        });\n      }\n    });\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nmain();\n</code></pre> <p>您可以参考 Substrate API Sidecar 页面，获取有关安装和运行您自己的 Sidecar 服务实例的信息，以及有关如何解码 Sidecar 区块以进行 Moonbeam 交易的更多详细信息。</p>"}, {"location": "learn/core-concepts/tx-fees/", "title": "在 Moonbeam 上计算交易费用", "text": ""}, {"location": "learn/core-concepts/tx-fees/#introduction", "title": "简介", "text": "<p>与 Moonbeam 上的用于发送转账的 Ethereum 和 Substrate API类似，Moonbeam 上的 Substrate 和 EVM 层也有不同的交易手续费模型，开发者在需要计算和跟踪交易手续费时应该注意。</p> <p>首先，以太坊交易根据其计算复杂性和数据存储要求消耗 gas 单位。另一方面，Substrate 交易使用“权重”的概念来确定费用。在本指南中，您将学习如何计算 Substrate 和 Ethereum 交易的交易手续费。在以太坊交易方面，您还将了解 Moonbeam 和以太坊计算交易手续费方式之间的主要区别。</p>"}, {"location": "learn/core-concepts/tx-fees/#key-differences-with-ethereum", "title": "与以太坊的主要区别", "text": "<p>Moonbeam 上的交易费模型与以太坊上的交易费模型存在一些主要差异，开发人员在 Moonbeam 上进行开发时应注意：</p> <ul> <li> <p>动态费用机制 类似于 EIP-1559 的机制，但实现方式不同</p> </li> <li> <p>Moonbeam 的交易费用模型中使用的 gas 量是从交易的 Substrate extrinsic <code>refTime</code> 组件（交易权重）通过固定因子 <code>25000</code> 映射而来，<code>proofSize</code> 组件（交易权重）通过固定因子 <code>8</code> 映射而来。然后将交易权重向量与单位 gas 价格相乘，以计算交易费用。这种费用模型意味着通过 Ethereum API 发送交易（如基本余额转移）可能比通过 Substrate API 发送交易便宜得多。</p> </li> <li> <p>EVM 的设计仅具有 gas 容量，而 Moonbeam 需要 gas 之外的额外指标。特别是，Moonbeam 需要能够记录证明大小，这是 Moonbeam 上中继链验证器验证状态转换所需的存储量。当当前区块的证明大小容量达到上限（即区块上限的 25%）时，将抛出“Out of Gas”错误。即使 gas 表中剩余旧版 gas，也可能发生这种情况。此额外指标也会影响退款。退款基于执行后消耗的更多资源。换句话说，如果按比例消耗的证明大小多于旧版 gas，则将使用证明大小来计算退款</p> </li> <li> <p>Moonbeam 实施了 MBIP-5 中定义的新机制，该机制限制了区块存储，并增加了导致存储增加的交易的 gas 使用量</p> </li> </ul>"}, {"location": "learn/core-concepts/tx-fees/#overview-of-mbip-5", "title": "MBIP-5 概述", "text": "<p>MBIP-5 引入了对 Moonbeam 的费用机制的更改，该机制考虑了网络上的存储增长，这与以太坊处理费用的方式不同。通过提高执行增加链状态的交易所需的 Gas，并建立区块存储限制，它可以控制存储增长。</p> <p>这会影响添加到链状态的合约部署、创建新存储条目的交易以及导致创建新帐户的预编译合约调用。</p> <p>区块存储限制可防止单个区块中的交易集体将存储状态增加超过限制。每个网络的限制如下：</p> MoonbeamMoonriverMoonbase Alpha <p>text 160KB</p> <p>text 160KB</p> <p>text 160KB</p> <p>要确定存储（以字节为单位）的 Gas 量，存在一个定义为以下内容的比例：</p> <p>text 比例 = 区块 Gas 限制 / (区块存储限制 * 1024 字节)</p> <p>每个网络的区块 Gas 限制如下：</p> MoonbeamMoonriverMoonbase Alpha <p>text 60,000,000</p> <p>text 60,000,000</p> <p>text 60,000,000</p> <p>了解了区块 Gas 和存储限制后，Gas 与存储的比例计算如下：</p> MoonbeamMoonriverMoonbase Alpha <p>text 比例 = 60000000 / (160 * 1024) 比例 = 366 </p> <p>text 比例 = 60000000 / (160 * 1024) 比例 = 366 </p> <p>text 比例 = 60000000 / (160 * 1024) 比例 = 366 </p> <p>然后，您可以获取给定交易的存储增长（以字节为单位），并将其乘以 Gas 与存储增长的比率，以确定要添加到交易中的 Gas 单位数量。例如，如果您执行的交易将存储增加 500 字节，则使用以下计算来确定要添加的 Gas 单位：</p> MoonbeamMoonriverMoonbase Alpha <p>text 额外 Gas = 500 * 366 额外 Gas = 183000</p> <p>text 额外 Gas = 500 * 366 额外 Gas = 183000</p> <p>text 额外 Gas = 500 * 366 额外 Gas = 183000</p> <p>要亲身体验此 MBIP 如何区分 Moonbeam 和以太坊，您可以估算两个不同合约交互在两个网络上的 Gas：一个修改链状态中的项目，另一个不修改。例如，您可以使用一个问候合约，该合约允许您存储一个名称，然后使用该名称来说“Hello”。</p> <p>solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.30;</p> <p>contract SayHello {     mapping(address =&gt; string) public addressToName;</p> <pre><code>constructor(string memory _name) {\n    addressToName[msg.sender] = _name;\n}\n\n// Store a name associated to the address of the sender\nfunction setName(string memory _name) public {\n    addressToName[msg.sender] = _name;\n}\n\n// Use the name in storage associated to the sender\nfunction sayHello() external view returns (string memory) {\n    return string(abi.encodePacked(\"Hello \", addressToName[msg.sender]));\n}\n</code></pre> <p>}</p> <p>您可以在 Moonriver 和以太坊上，或在 Moonbeam 的测试网 Moonbase Alpha 和以太坊的测试网 Sepolia 上部署此合约。上述合约已部署到 Moonbase Alpha 和 Sepolia。您可以随意访问以下地址的这些合约：</p> Moonbase AlphaSepolia <p>text 0xDFF8E772A9B212dc4FbA19fa650B440C5c7fd7fd</p> <p>text 0x8D0C059d191011E90b963156569A8299d7fE777d</p> <p>接下来，您可以使用 <code>eth_estimateGas</code> 方法来检查在每个网络上调用 <code>setName</code> 和 <code>sayHello</code> 函数的 Gas 估算值。为此，您需要每个交易的字节码，其中包括函数选择器，以及 <code>setName</code> 函数的要设置的名称。此示例字节码将名称设置为“Chloe”：</p> 设置名称Say Hello <p>text 0xc47f00270000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000543686c6f65000000000000000000000000000000000000000000000000000000</p> <p>text 0xef5fb05b</p> <p>现在，您可以使用以下 curl 命令在 Moonbase Alpha 上返回 Gas 估算值：</p> 设置名称Say Hello <p>sh curl https://rpc.api.moonbase.moonbeam.network -H \"Content-Type:application/json;charset=utf-8\" -d \\ '{     \"jsonrpc\": \"2.0\",     \"id\": 1,     \"method\": \"eth_estimateGas\",     \"params\":[{         \"to\": \"0xDFF8E772A9B212dc4FbA19fa650B440C5c7fd7fd\",         \"data\": \"0xc47f00270000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000543686c6f65000000000000000000000000000000000000000000000000000000\"     }] }'</p> <p>sh curl https://rpc.api.moonbase.moonbeam.network -H \"Content-Type:application/json;charset=utf-8\" -d \\ '{     \"jsonrpc\": \"2.0\",     \"id\": 1,     \"method\": \"eth_estimateGas\",     \"params\":[{         \"to\": \"0xDFF8E772A9B212dc4FbA19fa650B440C5c7fd7fd\",         \"data\": \"0xef5fb05b\"     }] }'</p> <p>然后在 Sepolia 上，您可以对 <code>data</code> 使用相同的字节码，并修改 RPC URL 和合约地址以定位部署到 Sepolia 的合约：</p> 设置名称Say Hello <p>sh curl https://sepolia.publicgoods.network -H \"Content-Type:application/json;charset=utf-8\" -d \\ '{     \"jsonrpc\": \"2.0\",     \"id\": 1,     \"method\": \"eth_estimateGas\",     \"params\":[{         \"to\": \"0x8D0C059d191011E90b963156569A8299d7fE777d\",         \"data\": \"0xc47f00270000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000543686c6f65000000000000000000000000000000000000000000000000000000\"     }] }'</p> <p>sh curl https://sepolia.publicgoods.network -H \"Content-Type:application/json;charset=utf-8\" -d \\ '{     \"jsonrpc\": \"2.0\",     \"id\": 1,     \"method\": \"eth_estimateGas\",     \"params\":[{         \"to\": \"0x8D0C059d191011E90b963156569A8299d7fE777d\",         \"data\": \"0xef5fb05b\"     }] }'</p> <p>在撰写本文时，两个网络的 Gas 估算值如下：</p> Moonbase AlphaSepolia 方法 Gas 估算值 <code>setName</code> 45977 <code>sayHello</code> 25938 方法 Gas 估算值 <code>setName</code> 21520 <code>sayHello</code> 21064 <p>您会看到，在 Sepolia 上，两个调用的 Gas 估算值非常相似，而在 Moonbase Alpha 上，调用之间存在显着差异，并且修改存储的 <code>setName</code> 调用比 <code>sayHello</code> 调用使用更多的 Gas。</p>"}, {"location": "learn/core-concepts/tx-fees/#ethereum-api-transaction-fees", "title": "Ethereum API 交易费用", "text": "<p>要计算通过 Ethereum API 发送的 Moonbeam 交易产生的费用，可以使用以下公式：</p> <p>===</p> <pre><code>text\nGasPrice = BaseFee + MaxPriorityFeePerGas &lt; MaxFeePerGas ? \n            BaseFee + MaxPriorityFeePerGas : \n            MaxFeePerGas;\nTransaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <p>===</p> <pre><code>text\nTransaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <p>===</p> <pre><code>text\nTransaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <p>Note</p> <p>Moonbeam 上的 EIP-1559 交易费用是使用前一个区块的基本费用计算的。</p> <p>以下各节更详细地描述了计算交易费用所需的每个组成部分。</p>"}, {"location": "learn/core-concepts/tx-fees/#base-fee", "title": "基础费用", "text": "<p><code>BaseFee</code> 是发送交易收取的最低金额，是由网络本身设置的值。它是在 EIP-1559 中引入的。Moonbeam 拥有自己的 动态费用机制，用于计算基础费用，该费用会根据区块拥堵情况进行调整。截至 runtime 2300，动态费用机制已推广到所有基于 Moonbeam 的网络。</p> <p>每个网络的最低 Gas 价格如下：</p> <p>===</p> <pre><code>|     变量      |                   值                    |\n|:-----------------:|:------------------------------------------:|\n| 最低 Gas 价格 | 31.25 Gwei |\n</code></pre> <p>===</p> <pre><code>|     变量      |                   值                    |\n|:-----------------:|:------------------------------------------:|\n| 最低 Gas 价格 | 0.3125 Gwei |\n</code></pre> <p>===</p> <pre><code>|     变量      |                   值                    |\n|:-----------------:|:------------------------------------------:|\n| 最低 Gas 价格 | 0.03125 Gwei |\n</code></pre> <p>要计算动态基础费用，请使用以下计算公式：</p> <p>===</p> <pre><code>```text\nBaseFee = NextFeeMultiplier * 31250000000 / 10^18\n```\n</code></pre> <p>===</p> <pre><code>```text\nBaseFee = NextFeeMultiplier * 312500000 / 10^18\n```\n</code></pre> <p>===</p> <pre><code>```text\nBaseFee = NextFeeMultiplier * 31250000 / 10^18\n```\n</code></pre> <p><code>NextFeeMultiplier</code> 的值可以从 Substrate Sidecar API 中检索，通过以下端点：</p> <pre><code>GET /pallets/transaction-payment/storage/nextFeeMultiplier?at={blockId}\n</code></pre> <p>Sidecar 的 pallets 端点返回与 pallet 相关的数据，例如 pallet 存储中的数据。您可以在 官方 Sidecar 文档 中阅读有关 pallets 端点的更多信息。从存储中获取所需的数据是 <code>nextFeeMultiplier</code>，它可以在 <code>transaction-payment</code> pallet 中找到。存储的 <code>nextFeeMultiplier</code> 值可以直接从 Sidecar 存储模式中读取。作为 JSON 对象读取，相关的嵌套结构如下：</p> <pre><code>RESPONSE JSON Storage Object:\n    |--at\n        |--hash\n        |--height\n    |--pallet\n    |--palletIndex\n    |--storageItem\n    |--keys\n    |--value\n</code></pre> <p>相关数据将存储在 JSON 对象的 <code>value</code> 键中。此值是定点数据类型，因此，实际值通过将 <code>value</code> 除以 <code>10^18</code> 得到。这就是为什么 <code>BaseFee</code> 的计算方式 包含这样的操作。</p>"}, {"location": "learn/core-concepts/tx-fees/#transaction-weight", "title": "交易权重", "text": "<p><code>TransactionWeight</code> 是一种 Substrate 机制，用于衡量给定交易在区块内执行所需的执行时间。交易的权重是一个包含两个分量的向量：<code>refTime</code> 和 <code>proofSize</code>。<code>refTime</code> 指的是可用于执行的计算时间量。<code>proofSize</code> 指的是 Moonbeam 区块的 PoV（有效性证明）的大小，该PoV 会被提交到 Polkadot Relay Chain 进行验证。由于 <code>refTime</code> 和 <code>proofSize</code> 都是确定权重的组成部分，因此仅凭其中一个值无法获得准确的权重值。</p> <p>对于所有交易类型，可以在相关 extrinsic 的事件下检索 <code>TransactionWeight</code>，其中 <code>method</code> 字段设置为：</p> <p>text pallet: \"system\", method: \"ExtrinsicSuccess\" </p> <p>然后，<code>TransactionWeight</code> 映射到区块 JSON 对象的以下两个字段。<code>proofSize</code> 的映射如下：</p> <p>text extrinsics[extrinsic_number].events[event_number].data[0].weight.proof_size </p> <p><code>refTime</code> 的映射如下：</p> <p>text extrinsics[extrinsic_number].events[event_number].data[0].weight.ref_time</p>"}, {"location": "learn/core-concepts/tx-fees/#eth-feehistory-endpoint", "title": "Fee History 端点", "text": "<p>Moonbeam 网络实现了 <code>eth_feeHistory</code> JSON-RPC 端点，作为对 EIP-1559 的支持。</p> <p><code>eth_feeHistory</code> 返回历史 gas 信息集合，您可以参考这些信息并计算提交 EIP-1559 交易时 <code>MaxFeePerGas</code> 和 <code>MaxPriorityFeePerGas</code> 字段的设置值。</p> <p>以下 curl 示例将使用 <code>eth_feeHistory</code> 返回在相应 Moonbeam 网络上从最新区块开始的最近 10 个区块的 gas 信息：</p> <p>===</p> <pre><code>sh\ncurl --location \\\n     --request POST 'INSERT_RPC_API_ENDPOINT' \\\n     --header 'Content-Type: application/json' \\\n     --data-raw '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"eth_feeHistory\",\n        \"params\": [\"0xa\", \"latest\"]\n     }'\n</code></pre> <p>===</p> <pre><code>sh\ncurl --location \\\n     --request POST 'INSERT_RPC_API_ENDPOINT' \\\n     --header 'Content-Type: application/json' \\\n     --data-raw '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"eth_feeHistory\",\n        \"params\": [\"0xa\", \"latest\"]\n     }'\n</code></pre> <p>===</p> <pre><code>sh\ncurl --location \\\n     --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n     --header 'Content-Type: application/json' \\\n     --data-raw '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"eth_feeHistory\",\n        \"params\": [\"0xa\", \"latest\"]\n     }'\n</code></pre> <p>===</p> <pre><code>sh\ncurl --location \\\n     --request POST 'http://127.0.0.1:9944' \\\n     --header 'Content-Type: application/json' \\\n     --data-raw '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"eth_feeHistory\",\n        \"params\": [\"0xa\", \"latest\"]\n     }'\n</code></pre>"}, {"location": "learn/core-concepts/tx-fees/#sample-code", "title": "用于计算交易费的示例代码", "text": "<p>以下代码片段使用 Axios HTTP 客户端 查询 Sidecar 端点 <code>/blocks/head</code> 以获取最新的最终确定区块。然后，它根据交易类型（对于以太坊 API：legacy、EIP-1559 或 EIP-2930 标准，以及对于 Substrate API）计算区块中所有交易的交易费用，并计算区块中的总交易费用。</p> <p>Note</p> <p>Moonbeam 上的 EIP-1559 交易费用是使用前一个区块的基本费用计算的。</p> <p>以下代码示例仅用于演示目的，未经修改和在生产环境中进行进一步测试，不应使用。</p> <p>您可以将以下代码段用于任何基于 Moonbeam 的网络，但您需要相应地修改 <code>baseFee</code>。您可以参考 基本费用 部分来获取每个网络的计算方法。</p> <pre><code>import axios from 'axios';\n\n// This script calculates the transaction fees of all transactions in a block\n// according to the transaction type (for Ethereum API: legacy, EIP-1559 or\n// EIP-2930 standards, and Substrate API) using the dynamic fee mechanism.\n// It also calculates the total fees in the block\n\n// Endpoint to retrieve the latest block\nconst endpointBlock = 'http://127.0.0.1:8080/blocks/head';\n// Endpoint to retrieve the latest nextFeeMultiplier\nconst endpointPallet =\n  'http://127.0.0.1:8080/pallets/transaction-payment/storage/nextFeeMultiplier?at=';\n// Endpoint to retrieve the node client's information\nconst endpointNodeVersion = 'http://127.0.0.1:8080/node/version';\n\n// Define the minimum base fee for each network\nconst baseFee = {\n  moonbeam: 31250000000n,\n  moonriver: 312500000n,\n  moonbase: 31250000n,\n};\n\nasync function main() {\n  try {\n    // Create a variable to sum the transaction fees in the whole block\n    let totalFees = 0n;\n\n    // Find which Moonbeam network the Sidecar is pointing to\n    const responseClient = await axios.get(endpointNodeVersion);\n    const network = responseClient.data.clientImplName;\n\n    // Retrieve the block from the Sidecar endpoint\n    const responseBlock = await axios.get(endpointBlock);\n    // Retrieve the block height of the current block\n    console.log('Block Height: ' + responseBlock.data.number);\n\n    // Use the previous block's base fee to match the on-chain data\n    // Find the block's nextFeeMultiplier\n    const prevBlock = Number(responseBlock.data.number) - 1;\n    const responsePallet = await axios.get(endpointPallet + prevBlock);\n\n    // Iterate through all extrinsics in the block\n    responseBlock.data.extrinsics.forEach((extrinsic) =&gt; {\n      // Create an object to store transaction information\n      let transactionData = new Object();\n      // Set the network field\n      transactionData['network'] = network;\n\n      // Filter for Ethereum Transfers\n      if (\n        extrinsic.method.pallet === 'ethereum' &amp;&amp;\n        extrinsic.method.method === 'transact'\n      ) {\n        // Iterate through the events to get non type specific parameters\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'ethereum' &amp;&amp;\n            event.method.method === 'Executed'\n          ) {\n            // Get Transaction Hash\n            transactionData['hash'] = event.data[2];\n          }\n          if (\n            event.method.pallet === 'system' &amp;&amp;\n            event.method.method === 'ExtrinsicSuccess'\n          ) {\n            // Add correction weight if needed to Transaction Weight!\n            transactionData['weight'] = BigInt(event.data[0].weight.refTime);\n          }\n        });\n\n        // Get the transaction type and type specific parameters and compute the\n        // transaction fee\n        if (extrinsic.args.transaction.legacy) {\n          transactionData['txType'] = 'legacy';\n          transactionData['gasPrice'] = BigInt(\n            extrinsic.args.transaction.legacy.gasPrice\n          );\n          transactionData['txFee'] =\n            (transactionData['gasPrice'] * transactionData['weight']) / 25000n;\n        } else if (extrinsic.args.transaction.eip1559) {\n          transactionData['txType'] = 'eip1599';\n          transactionData['maxFeePerGas'] = BigInt(\n            extrinsic.args.transaction.eip1559.maxFeePerGas\n          );\n          transactionData['maxPriorityFeePerGas'] = BigInt(\n            extrinsic.args.transaction.eip1559.maxPriorityFeePerGas\n          );\n          // Update based on the network you're getting tx fees for\n          transactionData['baseFee'] =\n            (BigInt(responsePallet.data.value) * baseFee.moonbeam) /\n            BigInt('1000000000000000000');\n\n          // Gas price dependes on the MaxFeePerGas and MaxPriorityFeePerGas set\n          transactionData['gasPrice'] =\n            transactionData['baseFee'] +\n              transactionData['maxPriorityFeePerGas'] &lt;\n            transactionData['maxFeePerGas']\n              ? transactionData['baseFee'] +\n                transactionData['maxPriorityFeePerGas']\n              : transactionData['maxFeePerGas'];\n\n          transactionData['txFee'] =\n            (transactionData['gasPrice'] * transactionData['weight']) / 25000n;\n        } else if (extrinsic.args.transaction.eip2930) {\n          transactionData['txType'] = 'eip2930';\n          transactionData['gasPrice'] = BigInt(\n            extrinsic.args.transaction.eip2930.gasPrice\n          );\n          transactionData['txFee'] =\n            (transactionData['gasPrice'] * transactionData['weight']) / 25000n;\n        }\n\n        // Increment totalFees\n        totalFees += transactionData['txFee'];\n\n        // Display the tx information to console\n        console.log(transactionData);\n      }\n      // Filter for Substrate transactions, check if the extrinsic has a\n      // 'TransactionFeePaid' event\n      else {\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'transactionPayment' &amp;&amp;\n            event.method.method === 'TransactionFeePaid'\n          ) {\n            transactionData['txType'] = 'substrate';\n            transactionData['txFee'] = event.data[1];\n            transactionData['tip'] = event.data[1];\n          }\n          if (\n            event.method.pallet === 'system' &amp;&amp;\n            event.method.method === 'ExtrinsicSuccess'\n          ) {\n            transactionData['weight'] = event.data[0].weight.refTime;\n          }\n        });\n      }\n    });\n\n    // Output the total amount of fees in the block\n    console.log('Total fees in block: ' + totalFees);\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nmain();\n</code></pre>"}, {"location": "learn/core-concepts/tx-fees/#substrate-api-transaction-fees", "title": "Substrate API 交易费用", "text": "<p>本指南的这一部分假设您正在通过 Substrate API Sidecar 服务与 Moonbeam 区块进行交互。还有其他与 Moonbeam 区块交互的方式，例如使用 Polkadot.js API 库。一旦检索到区块，逻辑是相同的。</p> <p>您可以参考 Substrate API Sidecar 页面，获取有关安装和运行您自己的 Sidecar 服务实例的信息，以及有关如何解码 Sidecar 区块以进行 Moonbeam 交易的更多细节。</p> <p>请注意，本节中的信息假设您运行的是 Substrate Sidecar REST API 的 20.12.0 版本。</p> <p>通过 Substrate API 发送的交易的所有费用数据都可以从以下区块端点提取：</p> <p>text GET /blocks/{blockId}</p> <p>区块端点将返回与一个或多个区块相关的数据。您可以在 官方 Sidecar 文档 上阅读有关区块端点的更多信息。以 JSON 对象读取时，相关的嵌套结构如下：</p> <p>text RESPONSE JSON Block Object:     ...     |--number     |--extrinsics         |--{extrinsic_number}             |--method             |--signature             |--nonce             |--args             |--tip                      |--hash             |--info             |--era             |--events                 |--{event_number}                     |--method                         |--pallet: \"transactionPayment\"                         |--method: \"TransactionFeePaid\"                     |--data                         |--0                         |--1                         |--2     ...</p> <p>对象映射总结如下：</p> 交易信息 区块 JSON 字段 费用支付账户 <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> 支付的总费用 <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> 小费 <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> <p>与交易费用相关的信息可以在相关 extrinsic 的事件下检索，其中 <code>method</code> 字段设置为：</p> <p>text pallet: \"transactionPayment\", method: \"TransactionFeePaid\" </p> <p>然后，为此 extrinsic 支付的总交易费用将映射到区块 JSON 对象的以下字段：</p> <p>text extrinsics[extrinsic_number].events[event_number].data[1]</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "learn/core-concepts/unified-accounts/", "title": "统一账户", "text": ""}, {"location": "learn/core-concepts/unified-accounts/#introduction", "title": "简介", "text": "<p>由于 Moonbeam 被设计为 Polkadot 上与 Ethereum 兼容的平行链，因此底层账户系统将默认的 Substrate 样式账户和密钥替换为 Ethereum 样式的账户和密钥。因此，您可以使用 MetaMask 和您可能已经熟悉的 Ethereum 工具（例如 Remix 和 Hardhat）与您的 Moonbeam 账户进行交互。</p> <p>您还可以使用 Polkadot.js Apps 与您的 Moonbeam 账户进行交互，因为它原生支持 H160 地址和 ECDSA 密钥。有关此集成的更多信息，您可以查看 使用 Polkadot.js Apps 与 Moonbeam 交互 指南。</p>"}, {"location": "learn/core-concepts/unified-accounts/#substrate-evm-compatible-blockchain", "title": "Substrate EVM 兼容区块链", "text": "<p>Polkadot 生态系统中的任何平行链都可以提供完整的 EVM 实现，从而可以在最小甚至无需更改的情况下执行基于 Solidity 的智能合约。Substrate 使这种集成成为可能 - 只需将 EVM pallet 插入到您的运行时中以获得 EVM 支持，并将 带有 Frontier 的以太坊 Pallet 用于获得以太坊 RPC 兼容性。Moonbeam 与 Parity 共同开发的这些开源模块的可用性已促使多个平行链在其链上提供以太坊兼容性。</p> <p>但这里有一个重要的注意事项。使用上述配置，用户（例如 Alice）可以在基于 Substrate 的链中拥有一个以太坊样式的地址（H160 格式），该地址的长度为 40+2 个十六进制字符。此地址与一个私钥匹配，该私钥可用于在链的以太坊端签署交易。此外，该地址被映射到 Substrate Balance pallet 中的存储槽，对应于 Substrate 样式的地址（H256 格式）。</p> <p>但是，Alice 只知道 H160 地址的私钥，而不知道映射版本的私钥。因此，她无法使用其 H256 地址发送交易，并且只能通过 Substrate 的 API 进行只读操作。因此，Alice 需要另一个与不同私钥匹配的 H256 地址，才能在 Substrate 链端进行操作，其中包括 staking、balances 和 governance。</p> <p>下图说明了此配置。</p> <p></p> <p>这可能会给 Alice 带来摩擦和糟糕的用户体验。首先，她必须将代币转移到她的 H160 映射的 H256 地址，才能通过 EVM 进行交易和部署合约。其次，她还需要在她的另一个 H256 地址（她拥有不同的私钥）中持有余额，才能使用基于 Substrate 的功能。简而言之，Alice 至少需要两个私钥才能获得两全其美。</p>"}, {"location": "learn/core-concepts/unified-accounts/#moonbeam-unified-accounts", "title": "Moonbeam 统一账户", "text": "<p>Moonbeam 的重点是在 Polkadot 上创建一个完全兼容以太坊的环境，并提供最佳的用户体验。这超越了基本的以太坊功能集，还具有额外的功能，例如链上治理、质押和跨链集成。</p> <p>使用统一账户，用户（例如 Bob）只需要一个 H160 地址及其相应的私钥，即可完成我们上面提到的所有操作，包括 EVM 和 Substrate 功能。</p> <p>这种新配置的图表如下所示。</p> <p></p> <p>就是这样，Bob 只需要持有一个与一个地址匹配的私钥。他不需要在 2 个不同的账户之间转移余额，并且能够通过单个账户和私钥访问所有功能。我们已将此单个账户标准化为符合以太坊风格的 H160 地址和 ECDSA 密钥标准。</p>"}, {"location": "learn/features/", "title": "Index", "text": "<ul> <li>toc</li> <li>feedback</li> </ul>"}, {"location": "learn/features/eth-compatibility/", "title": "Ethereum 兼容性", "text": "<p>Moonbeam 连接了以太坊和波卡生态系统，为开发者提供了以太坊工具和基础设施的熟悉性，同时利用了波卡的可扩展性和互操作性。</p> <p>本文档概述了 Moonbeam 的以太坊兼容性功能，并重点介绍了其关键组件。它还涵盖了 Moonbeam 和以太坊之间的一些关键差异，以便以太坊开发者了解会发生什么。</p>"}, {"location": "learn/features/eth-compatibility/#key-components", "title": "关键组件", "text": ""}, {"location": "learn/features/eth-compatibility/#evm", "title": "EVM 兼容性", "text": "<p>Moonbeam 包含一个完全兼容的 EVM，用于以 Solidity 或其他 EVM 兼容语言执行智能合约。这使开发人员能够以最少的修改在 Moonbeam 上部署现有的 Ethereum 智能合约。</p>"}, {"location": "learn/features/eth-compatibility/#ethereum-style-accounts", "title": "Ethereum 风格账户", "text": "<p>Moonbeam 采用 H160 Ethereum 风格账户和 ECDSA 密钥，确保与现有 Ethereum 钱包的兼容性，并促进流畅的最终用户体验。这得益于 Moonbeam 的统一账户系统，该系统修改了底层 Substrate 账户系统以默认使用 Ethereum 账户。</p> <p>了解更多：</p> <ul> <li>Moonbeam 的统一账户系统</li> </ul>"}, {"location": "learn/features/eth-compatibility/#json-rpc-support", "title": "JSON-RPC 支持", "text": "<p>Moonbeam提供与以太坊完全的JSON-RPC兼容性，允许开发人员使用熟悉的以太坊工具和库与Moonbeam节点进行交互。这种兼容性扩展到帐户管理、交易提交、智能合约部署和事件监控的方法。</p> <p>除了标准的以太坊RPC方法外，Moonbeam还支持非标准的Debug和Trace模块，为开发人员提供增强的智能合约执行调试和跟踪功能。Debug模块允许开发人员检查内部状态转换和执行跟踪，从而能够高效地调试复杂的智能合约。Trace模块提供详细的交易跟踪，包括操作码级别的执行信息和Gas消耗，从而方便性能分析和优化。</p> <p>了解更多：</p> <ul> <li>支持的以太坊RPC方法</li> <li>使用以太坊JSON-RPC方法订阅事件</li> <li>使用非标准RPC方法调试和跟踪交易</li> </ul>"}, {"location": "learn/features/eth-compatibility/#ethereum-dev-tools", "title": "以太坊开发者工具和库", "text": "<p>Moonbeam 以以太坊 JSON-RPC 方法为底层支持，充分利用以太坊丰富的开发者库和环境生态系统。通过与流行的以太坊库和开发环境的无缝集成，开发者可以利用他们现有的知识和工具在 Moonbeam 上构建和部署去中心化应用程序 (DApp)。</p> <p>了解更多：</p> <ul> <li>以太坊库</li> <li>以太坊开发环境</li> </ul>"}, {"location": "learn/features/eth-compatibility/#precompiled-contracts", "title": "预编译合约", "text": "<p>Moonbeam 提供预编译合约，以允许以太坊智能合约无缝访问 Substrate 功能。这些预编译合约将链上治理、质押和身份管理等 Substrate 功能暴露给 Moonbeam 上的以太坊 DApp。 这种集成确保了以太坊开发人员可以充分利用 Moonbeam 功能的潜力，从而扩展了 Moonbeam 上 dApp 开发的可能性。</p> <p>此外，开发人员可以在 Moonbeam 上的智能合约中无缝利用以太坊主网预编译。 这些预编译合约广泛应用于以太坊网络，可优化并高效地执行通用加密操作和复杂计算。 通过支持以太坊主网预编译，Moonbeam 确保了与基于以太坊的 dApp 的兼容性，同时使开发人员能够利用熟悉的工具和库在其平台上进行构建。</p> <p>了解更多：</p> <ul> <li>Moonbeam 预编译合约概述</li> </ul>"}, {"location": "learn/features/eth-compatibility/#ethereum-token-standards", "title": "Ethereum 代币标准", "text": "<p>Moonbeam 支持 Ethereum 代币标准，允许开发者部署和交互符合如 ERC-20、ERC-721 和 ERC-1155 等流行标准的代币。通过支持这些标准，Moonbeam 允许开发者无需修改即可部署现有的 Ethereum 代币。</p> <p>由于 Moonbeam 的原生互操作性，ERC-20 可以通过跨共识消息传递 (XCM) 跨链发送到 Polkadot 生态系统内的其他链。</p> <p>了解更多：</p> <ul> <li>支持 XCM 的 ERC-20（也称为本地 XC-20）</li> </ul>"}, {"location": "learn/features/eth-compatibility/#key-differences", "title": "主要区别", "text": ""}, {"location": "learn/features/eth-compatibility/#consensus-mechanisms", "title": "共识机制", "text": "<p>Moonbeam 使用委托权益证明（DPoS）共识机制，网络中的代币持有者可以委托候选人成为区块生产者，这些区块生产者被称为_收集人_。另一方面，以太坊使用权益证明（PoS）系统，其中验证者根据他们在网络中的权益被选中来生产和验证区块。</p> <p>了解更多：</p> <ul> <li>PoS 和 DPoS 之间的区别</li> </ul>"}, {"location": "learn/features/eth-compatibility/#finality", "title": "最终性", "text": "<p>Moonbeam 和以太坊具有不同的最终性流程。在以太坊上，存在一个检查点系统，验证者在该系统中确定检查点区块的最终性，区块至少需要 6.4 分钟才能最终确定。Moonbeam 依赖于 Polkadot 的 GRANDPA 最终性工具，它通过并行于区块生产完成该流程并允许中继链验证者对最高区块进行投票来加速最终性，从而最终确定所有通往该区块的区块。</p> <p>了解更多信息：</p> <ul> <li>Moonbeam 上的共识和最终性</li> </ul>"}, {"location": "learn/features/eth-compatibility/#proxy-accounts", "title": "代理账户", "text": "<p>在 Moonbeam 和以太坊上，账户都可以由两种主要的账户类型控制：外部拥有账户 (EOA) 或智能合约。但是，在 Moonbeam 上，在这两种账户类型中，还有代理账户，可以代表另一个账户执行数量有限的操作。</p> <p>了解更多：</p> <ul> <li>代理账户概述</li> <li>如何设置代理账户</li> </ul>"}, {"location": "learn/features/eth-compatibility/#account-balances", "title": "账户余额", "text": "<p>以太坊上的余额非常简单明了；如果一个账户持有代币，那么该账户就拥有代币余额。在 Moonbeam 上，存在不同的余额类型以支持各种 Substrate 功能。主要有五种类型：自由余额、可减少余额、预留余额、其他冻结余额和手续费冻结余额。当使用以太坊工具时，账户会显示可减少余额，不包括锁定或冻结的余额。</p> <p>了解更多：</p> <ul> <li>Moonbeam 账户余额</li> </ul>"}, {"location": "learn/features/eth-compatibility/#balance-transfers", "title": "余额转移", "text": "<p>由于 Moonbeam 是一个基于 Substrate 的链，因此可以通过以太坊和 Substrate API 进行原生资产（GLMR、MOVR 和 DEV）的余额转移。与以太坊一样，通过以太坊 API 发送的转移依赖于 <code>eth_sendRawTransaction</code>。通过 Substrate API 发送的转移使用 Balances Pallet 完成，Balances Pallet 是 Substrate 框架中的一个内置模块，提供管理账户和余额的功能。</p> <p>了解更多：</p> <ul> <li>Moonbeam 上的余额转移</li> </ul>"}, {"location": "learn/features/eth-compatibility/#transaction-fees", "title": "交易费用", "text": "<p>由于底层架构和共识机制的差异，Moonbeam 和以太坊计算交易费用的方式有所不同。计算交易费用的根本区别在于，以太坊使用基于 Gas 的费用系统，而 Moonbeam 使用基于权重的系统，该系统映射到所使用的 Gas。Moonbeam 还在底层 Gas 计算中实施了其他指标，包括证明大小和存储成本。</p> <p>了解更多：</p> <ul> <li>在 Moonbeam 上计算交易费用</li> </ul>"}, {"location": "learn/features/governance/", "title": "Moonbeam 上的治理", "text": ""}, {"location": "learn/features/governance/#introduction", "title": "简介", "text": "<p>Moonbeam 治理机制的目标是根据社区的意愿推进协议。在这一共同使命中，治理流程力求涵盖所有代币持有者。对协议的任何和所有更改都必须经过全民公投，以便所有代币持有者（按权益加权）都可以对决策发表意见。</p> <p>Moonbeam 社区论坛 和 Polkassembly 等治理论坛可以进行公开讨论，并根据社区的意见改进提案。自主制定和无分叉升级 将社区团结起来，共同推进协议。</p> <p>随着 OpenGov（最初称为 Gov2）的推出，Polkadot 的第二阶段治理引入了多项对治理流程的修改。您可以阅读 OpenGov：什么是 Polkadot Gov2 这篇博文，其中概述了 OpenGov 中所做的所有更改。</p> <p>截至运行时 2400，所有 Moonbeam 网络都使用 OpenGov 作为其治理系统。</p>"}, {"location": "learn/features/governance/#principles", "title": "原则", "text": "<p>参与 Moonbeam 治理流程的指导性“软”原则包括：</p> <ul> <li>对希望参与 Moonbeam 并受治理决策影响的代币持有者具有包容性</li> <li>即使观点与我们自己的观点相反，也偏向于代币持有者的参与，而不是缺乏参与</li> <li>致力于决策过程的开放性和透明性</li> <li>努力将网络的更大利益置于个人利益之上</li> <li>始终充当道德主体，从道德角度考虑行动（或不作为）的后果</li> <li>在与其他代币持有者的互动中保持耐心和慷慨，但不容忍辱骂或破坏性的语言、行为和举止，并遵守 Moonbeam 的行为准则</li> </ul> <p>这些要点很大程度上受到了 Vlad Zamfir 关于治理的著作的启发。请参阅他的文章，尤其是 如何以诚信（和良好举止）参与区块链治理 Medium 文章。</p>"}, {"location": "learn/features/governance/#on-chain-governance-mechanics", "title": "链上治理机制", "text": "<p>Moonbeam 的“硬”治理流程将由链上流程驱动，该流程允许网络中的大多数代币持有者决定围绕网络做出的关键决策的结果。这些决策点以对拟议的全民投票进行权益加权投票的形式出现。</p> <p>此治理模型的一些主要组成部分包括：</p> <ul> <li>全民投票 — 一种基于权益的投票方案，其中每项全民投票都与对 Moonbeam 系统进行更改的特定提案相关联，包括关键参数的值、代码升级或对治理系统本身的更改</li> <li>投票 — 全民投票将由代币持有者以权益加权的方式进行投票。通过的全民投票会受到延迟颁布的影响，以便不同意该决策方向的人员有时间退出网络</li> <li>理事会和技术委员会治理 V1 — 一组在系统中拥有特殊投票权的社区成员。随着 Governance v1 的弃用和移除，这两个委员会均已自 runtime 2800 版本 解散</li> <li>OpenGov 技术委员会 — 一组可以将某些提案添加到白名单轨道的社区成员</li> </ul> <p>有关这些 Substrate 框架 pallet 如何实施链上治理的更多详细信息，您可以查看 Polkadot 治理的演练 博客文章和 Polkadot 治理 Wiki。</p>"}, {"location": "learn/features/governance/#opengov", "title": "Governance v2：OpenGov", "text": "<p>本节将涵盖您需要了解的关于Moonbeam上的OpenGov的所有内容。</p>"}, {"location": "learn/features/governance/#general-definitions-gov2", "title": "通用定义", "text": "<ul> <li>Proposal — an action or item, defined by the preimage hash, being proposed by a token holder and open for consideration and discussion by token holders</li> <li> <p>Referendum — a proposal that is up for token-holder voting. Each referendum is tied to a specific proposal for a change to the Moonbeam system including values for key parameters, code upgrades, or changes to the governance system itself</p> </li> <li> <p>Preimage hash — hash of the proposal to be enacted. The first step to make a proposal is to submit a preimage. The hash is just its identifier. The proposer of the preimage can be different than the user that proposes that preimage as a formal proposal</p> </li> <li> <p>Preimage deposit — amount of tokens that the proposer needs to bond when submitting a preimage. It is calculated as the sum of a base deposit per network plus a fee per byte of the preimage being proposed</p> </li> <li> <p>Origin（发起者） - 一种基于授权的操作分发源，用于确定提案所发布的 Track（轨道）</p> </li> <li> <p>Track（轨道） - 一个特定于 Origin 的管道，概述了提案的生命周期。目前，有五个轨道：</p> Origin Track（发起者轨道） Description（描述） Referendum Examples（公投示例） Root（Root） 最高权限 Runtime upgrades（运行时升级），Technical Committee management（技术委员会管理） Whitelisted（白名单） 提案在被分发前需经过技术委员会的白名单处理 Fast-tracked operations（快速通道操作） General Admin（通用管理） 用于一般的链上决策 Changes to XCM fees（更改 XCM 费用），Orbiter program（轨道飞行器计划），Staking parameters（质押参数），Registrars（注册员） Emergency Canceller（紧急取消者） 用于取消公投。决策保证金将退还 Wrongly constructed referendum（错误构建的公投） Emergency Killer（紧急终结者） 用于终止不良/恶意公投。决策保证金将被扣除 Malicious referendum（恶意公投） Fast General Admin（快速通用管理） 用于更快的通用链上决策 HRMP channel management（HRMP 通道管理） </li> </ul> <p>轨道具有不同的标准参数，这些参数与其 Origin 类的级别成正比。例如，更危险和特权的公投将具有更多的保障措施、更高的阈值和更长的批准考虑期。请参阅 治理参数 部分以获取更多信息。</p> <ul> <li> <p>Voting — a mechanism for token holders to support (Aye), oppose (Nay), or remain neutral (Abstain) on a proposal. For Aye and Nay, the voting weight is determined by both the number of tokens locked and the lock duration (Conviction). Abstain votes do not receive additional weighting</p> <ul> <li>Conviction — the time that token holders voluntarily lock their tokens when voting; the longer they are locked, the more weight their vote has</li> <li>Lock balance — the number of tokens that a user commits to a vote (note, this is not the same as a user's total account balance) Moonbeam uses the concept of voluntary locking, which allows token holders to increase their voting power by locking tokens for a longer period of time. Specifying no Lock Period means a user's vote is valued at 10% of their lock balance. Specifying a greater Conviction increases voting power. For each increase in Conviction (vote multiplier), the Lock Periods double</li> </ul> </li> <li> <p>Approval — minimum \"Aye\" votes as a percentage of overall Conviction-weighted votes needed for approval</p> </li> <li> <p>Support — the minimum portion of Aye and Abstain votes (ignoring conviction) needed as a percentage of the total active supply for a proposal to pass. Nay votes do not count toward Support</p> </li> <li> <p>Lead-in Period — the initial proposal voting and discussion period. At this stage, proposals are in an undecided state until they pass some criteria for the given Track. The criteria include:</p> <ul> <li>Prepare Period — the minimum time the referendum needs to wait before it can progress to the next phase after submission</li> <li>Capacity — limit for the number of referenda on a given Track that can be decided at once</li> <li>Decision Deposit — the minimum deposit amount required for a referendum to progress to the decision phase after the end of the Lead-in Period. Since each Track has a defined Capacity, this deposit is larger than the submission deposit, and its goal is to mitigate spam </li> </ul> </li> <li> <p>Decide Period（决定期） - 代币持有者继续对公投进行投票。如果公投在期限结束时未通过，它将被拒绝，并且决策保证金将被退还</p> </li> <li>Confirm Period（确认期） - 决定期内的一段时间，在此期间公投需要保持足够的赞成和支持才能被批准并进入实施期</li> <li> <p>Enactment Period（实施期） - 一个指定的时间，该时间在创建提案时定义，批准的公投在可以分发之前等待。每个轨道都有最短时间限制</p> </li> <li> <p>Vote Delegation — a voter can give their voting power, including Conviction voting, to another token holder (delegate), who may be more knowledgeable and able to make specific decisions</p> </li> <li>Multirole Delegation — the ability to delegate voting power on a Track-by-Track basis, where a token holder can specify different delegates for each Track</li> </ul>"}, {"location": "learn/features/governance/#general-parameters-by-track", "title": "按 Track 列出的一般参数", "text": "MoonbeamMoonriverMoonbase Alpha Track Track ID 容量 决策保证金 Root 0 5 个提案 2000000 GLMR 已加入白名单 1 100 个提案 200000 GLMR 通用管理员 2 10 个提案 10000 GLMR 紧急取消者 3 20 个提案 200000 GLMR 紧急终止者 4 100 个提案 400000 GLMR 快速通用管理员 5 10 个提案 10000 GLMR Track Track ID 容量 决策保证金 Root 0 5 个提案 100000 MOVR 已加入白名单 1 100 个提案 10000 MOVR 通用管理员 2 10 个提案 500 MOVR 紧急取消者 3 20 个提案 10000 MOVR 紧急终止者 4 100 个提案 20000 MOVR 快速通用管理员 5 10 个提案 500 MOVR Track Track ID 容量 决策保证金 Root 0 5 个提案 100000 DEV 已加入白名单 1 100 个提案 10000 DEV 通用管理员 2 10 个提案 500 DEV 紧急取消者 3 20 个提案 10000 DEV 紧急终止者 4 100 个提案 20000 DEV 快速通用管理员 5 10 个提案 500 DEV"}, {"location": "learn/features/governance/#conviction-multiplier-v2", "title": "确信倍数", "text": "<p>确信倍数与在全民公投通过后，代币将被锁定的执行周期数相关。因此，您愿意锁定代币的时间越长，您的投票权重就越大。您也可以选择根本不锁定代币，但投票权重会大大降低（代币在全民公投期间仍会被锁定）。</p> <p>如果您以 6 倍的确信度投票 1000 个代币，则您的加权投票将为 6000 个单位。也就是说，1000 个锁定的代币乘以确信度，在本例中为 6。另一方面，如果您决定在颁布后不想锁定您的代币，您可以以 0.1 倍的确信度投票您的 1000 个代币。在这种情况下，您的加权投票仅为 100 个单位。</p> <p>每个网络的确信倍数值为：</p> <p>===     | 执行后锁定周期 | 确信倍数 |      大概锁定时间       |     |:----------------------------:|:---------------------:|:--------------------------------------------------------------:|     |              0               |          0.1          |                              无                              |     |              1               |           1           | 1 天  |     |              2               |           2           | 2 天 |     |              4               |           3           | 4 天 |     |              8               |           4           | 8 天 |     |              16              |           5           | 16 天 |     |              32              |           6           | 32 天 |</p> <p>===     | 执行后锁定周期 | 确信倍数 |        大概锁定时间        |     |:----------------------------:|:---------------------:|:---------------------------------------------------------------:|     |              0               |          0.1          |                              无                               |     |              1               |           1           | 1 天  |     |              2               |           2           | 2 天 |     |              4               |           3           | 4 天 |     |              8               |           4           | 8 天 |     |              16              |           5           | 16 天 |     |              32              |           6           | 32 天 |</p> <p>===     | 执行后锁定周期 | 确信倍数 |      大概锁定时间       |     |:----------------------------:|:---------------------:|:--------------------------------------------------------------:|     |              0               |          0.1          |                              无                              |     |              1               |           1           | 1 天  |     |              2               |           2           | 2 天 |     |              4               |           3           | 4 天 |     |              8               |           4           | 8 天 |     |              16              |           5           | 16 天 |     |              32              |           6           | 32 天 |</p> <p>Note</p> <p>锁定时间近似值基于常规的 6 秒区块时间。区块生成可能会有所不同，因此显示的锁定时间不应被视为精确值。</p>"}, {"location": "learn/features/governance/#roadmap-of-a-proposal-v2", "title": "提案路线图", "text": "<p>在提交提案之前，提案的作者可以将其提案想法提交到Moonbeam治理论坛的指定的民主提案部分，以获取社区的反馈，至少需要五天。然后，作者可以根据他们收集的反馈对提案进行调整。</p> <p>一旦作者准备就绪，他们就可以在链上提交提案。为此，首先，他们需要提交提案的预映像。提交者需要绑定费用以在链上存储预映像。一旦提交者取消注释预映像，保证金就会退还。接下来，他们可以提交实际提案并支付提交保证金，这足以支付提案的链上存储成本。然后，导入期开始，社区可以通过锁定代币开始对提案投“赞成”或“反对”票。为了使全民投票能够推进并从导入期进入决定期，必须满足以下标准：</p> <ul> <li>全民投票必须等待准备期，以便有足够的时间在提案进入下一阶段之前进行讨论</li> <li>所选轨道中有足够的容量</li> <li>已经支付了决策保证金，该保证金满足轨道的最低要求</li> </ul> <p>如果全民投票符合上述标准，它将进入决定期，并在其指定的轨道中占据一个位置。在决定期中，投票继续进行，并且全民投票有设定的天数来达到批准和支持要求，以便它能够进入确认期。</p> <p>一旦进入确认期，全民投票必须在整个期间内持续满足批准和支持要求。如果全民投票在任何时候未能满足要求，它将被返回到决定期。如果全民投票再次满足批准和支持要求，它可以再次进入确认期，并且决定期将被延迟到确认期结束。如果决定期结束，但尚未收到足够的批准和支持，全民投票将被拒绝，决策保证金将被退还。提案可以随时再次提出。</p> <p>如果全民投票在确认期内持续收到足够的批准和支持，它将被批准并进入颁布期。它将等待颁布期的持续时间，然后才能被分派。</p> <p>提案的理想路径如下图所示：</p> <p></p>"}, {"location": "learn/features/governance/#_1", "title": "提案示例演练", "text": "<p>在 Moonriver 上为 General Admin Track 提交的提案（及其原像）将具有以下特征：</p> <ul> <li>批准曲线从 100% 开始于 Day 0，到 80% 结束于 Day 4</li> <li>支持曲线从 50% 开始于 Day 0，到 10% 结束于 Day 7</li> <li>全民投票以 0% 的“赞成”票（在引导期内没有人投票）开始“决定期”</li> <li>代币持有者开始投票，批准率在 Day 4 之前增加到 80% 以上的值</li> <li>如果在确认期（14400 区块，大约 1 day）内达到批准和支持阈值，则全民投票获得批准</li> <li>如果在“决定期”内未达到批准和支持阈值，则提案将被拒绝。请注意，需要在“确认期”内满足阈值。因此，如果满足阈值，但在“决定期”到期时“确认期”尚未完成，则提案将被拒绝</li> </ul> <p>可以使用以下公式计算批准和支持百分比：</p> <p>===</p> <pre><code>text\nApproval = 100 * ( Total Conviction-weighted \"Aye\" votes / Total Conviction-weighted votes )\n</code></pre> <p>===</p> <pre><code>text\nSupport = 100 * ( Total Aye + Abstain votes, ignoring conviction / Total supply )\n</code></pre>"}, {"location": "learn/features/governance/#proposal-cancellations", "title": "提案取消", "text": "<p>如果发现已进入投票阶段的提案存在问题，则可能需要阻止其获得批准。这些情况可能涉及恶意活动或技术问题，由于最近对网络的升级，这些问题使得更改无法实施。</p> <p>取消必须由网络投票才能执行。取消提案比典型的提案更快，因为它们必须在寻求取消的提案颁布之前决定，但它们遵循与其他全民公投相同的流程。</p> <p>有一个取消发起方（Origin）用于针对包含意外问题的全民公投，称为紧急取消者（Emergency Canceller）。紧急取消者发起方和 Root Origin 允许取消全民公投。无论发起方如何，如果提案被取消，它将被拒绝，并且决策保证金（Decision Deposit）将被退还。</p> <p>此外，还有一个 Kill Origin，用于旨在损害网络的恶意全民公投，称为紧急杀手（Emergency Killer）。紧急杀手发起方和 Root Origin 有能力终止全民公投。在这种情况下，提案将被取消，并且决策保证金将被削减，这意味着无论发起方如何，保证金金额都会被销毁。</p>"}, {"location": "learn/features/governance/#rights-of-the-opengov-technical-committee", "title": "OpenGov技术委员会的权利", "text": "<p>在Polkadot上，来自Governance v1的技术委员会被Fellowship取代，根据Polkadot的wiki，Fellowship是“一个主要目标是代表那些体现并包含Kusama和/或Polkadot网络和协议技术知识库的人类，并且在很大程度上是自治的专家机构”。</p> <p>对于Moonbeam的OpenGov实施，没有采用Fellowship，而是有一个社区OpenGov技术委员会，它具有与Fellowship非常相似的权力。他们在治理中的权力在于他们有能力将提案列入白名单。OpenGov技术委员会成员只有在将提案列入白名单可以防止网络出现安全漏洞时，才能投票将提案列入白名单。OpenGov技术委员会成员是否将提案列入白名单的通过门槛由治理决定。因此，OpenGov技术委员会对网络的权力非常有限。其目的是对代币持有人提出的紧急安全问题进行技术审查。</p> <p>虽然仍然受制于治理，但白名单通道背后的想法是，它将具有不同的参数，以使提案更快地通过。白名单通道的参数，包括批准、支持和投票，由Moonriver或Moonbeam代币持有人通过治理决定，OpenGov技术委员会无法更改。</p> <p>OpenGov技术委员会由在基于Moonbeam的网络中具有技术知识和专业知识的社区成员组成。</p>"}, {"location": "learn/features/governance/#try-it-out", "title": "OpenGov 相关指南", "text": "<p>有关通过 OpenGov 在 Moonbeam 上提交提案和参与公投的相关指南，请查看以下指南：</p> <ul> <li>如何提交提案</li> <li>如何对提案进行投票</li> <li>与预映像预编译合约（Solidity 接口）交互</li> <li>与公投预编译合约（Solidity 接口）交互</li> <li>与信念投票预编译合约（Solidity 接口）交互</li> </ul>"}, {"location": "learn/features/randomness/", "title": "Moonbeam 上的随机数", "text": ""}, {"location": "learn/features/randomness/#introduction", "title": "简介", "text": "<p>随机性对于各种区块链应用来说是必要的，它可以创造公正、不可预测和独特的结果。然而，获得可靠的随机性来源是一个挑战。计算机是确定性的，这意味着给定相同的输入，总是会产生相同的输出。因此，计算机生成的随机值被称为伪随机值，因为它们在统计上看起来是随机的，但是给定相同的输入，输出很容易被重复。</p> <p>Moonbeam 利用可验证随机函数（VRF）来生成可以在链上验证的随机性。VRF 是一种密码学函数，它接受一些输入并产生随机值，以及证明它们是由提交者生成的真实性证明。任何人都可以验证该证明，以确保随机值已正确生成。</p> <p>目前有两种可用的随机性来源，它们基于区块生产者的 VRF 密钥和过去的随机性结果来提供随机输入：local VRF 和 BABE epoch randomness。Local VRF 直接在 Moonbeam 中确定，使用区块校验者的 VRF 密钥和上一个区块的 VRF 输出。另一方面，BABE epoch 随机性基于中继链验证者在完整 epoch 期间产生的所有 VRF。</p> <p>您可以使用随机性预编译合约与链上随机性进行交互和请求，这是一个 Solidity 接口，使智能合约开发者能够通过 Ethereum API 访问随机性功能。有关更多信息，请查看与随机性预编译交互 指南。</p>"}, {"location": "learn/features/randomness/#general-definitions", "title": "常规定义", "text": "<ul> <li>Epoch（纪元） - BABE协议中的一个时间段，被分成更小的时间槽。时间槽是离散的时间单位，长度为六秒。在Polkadot上，一个纪元大约持续2,400个时间槽或4小时。在Kusama上，一个纪元大约持续600个时间槽或1小时。</li> <li>Deposit（押金） - 请求随机数所需的资金数额。每个请求都需要一笔押金。一旦请求完成，押金将退还给请求随机数的账户。</li> <li>Block expiration delay（区块过期延迟） - 在本地VRF请求过期并可以清除之前必须经过的区块数量</li> <li>Epoch expiration delay（纪元过期延迟） - 在BABE请求过期并可以清除之前必须经过的纪元数量</li> <li>Minimum block delay（最小区块延迟） - 在可以满足本地VRF请求之前，必须经过的最小区块数</li> <li>Maximum block delay（最大区块延迟） - 在可以满足本地VRF请求之前，必须经过的最大区块数</li> <li>Maximum random words（最大随机词数） - 正在请求的最大随机词数</li> <li>Epoch fulfillment delay（纪元完成延迟） - 在可以满足BABE请求之前的纪元延迟</li> </ul>"}, {"location": "learn/features/randomness/#quick-reference", "title": "快速参考", "text": "MoonbeamMoonriverMoonbase Alpha 变量 值 存款 100 GLMR 区块过期延迟 10000 区块 Epoch 过期延迟 10000 epoch 最小区块延迟 2 区块 最大区块延迟 2000 区块 最大随机词数 100 词 Epoch 完成延迟 2 epoch (在当前 epoch 之后) 变量 值 存款 1 MOVR 区块过期延迟 10000 区块 Epoch 过期延迟 10000 epoch 最小区块延迟 2 区块 最大区块延迟 2000 区块 最大随机词数 100 词 Epoch 完成延迟 2 epoch (在当前 epoch 之后) 变量 值 存款 1 DEV 区块过期延迟 10000 区块 Epoch 过期延迟 10000 epoch 最小区块延迟 2 区块 最大区块延迟 2000 区块 最大随机词数 100 词 Epoch 完成延迟 2 epoch (在当前 epoch 之后)"}, {"location": "learn/features/randomness/#local-vrf", "title": "本地 VRF", "text": "<p>本地 VRF 随机数是在每个区块的开头，以区块为单位生成的，它使用前一个区块的 VRF 输出以及当前区块作者的 VRF 密钥的公钥。生成的随机数结果将被存储，并用于满足当前区块的所有随机数请求。</p> <p>您可以使用 Randomness Precompile的 <code>requestLocalVRFRandomWords</code> 方法 请求本地 VRF 随机数。</p> <p>如果您的合约可能有并发请求打开，您可以使用从 <code>requestLocalVRFRandomWords</code> 方法返回的 <code>requestId</code> 来跟踪哪个响应与哪个随机数请求相关联。</p>"}, {"location": "learn/features/randomness/#babe-epoch-randomness", "title": "BABE Epoch 随机数", "text": "<p>BABE epoch 随机数基于倒数第二个中继链 epoch 中产生的区块的 VRF 值的哈希。在 Polkadot 上，一个 epoch 大约持续 4 个小时，而在 Kusama 上，一个 epoch 大约持续 1 个小时。哈希处理在中继链上完成，因此，除非 Moonbeam 上的整理人也是中继链上的验证人，并且负责生成 epoch 中包含的最后一个输出，否则他们无法影响随机数值。</p> <p>随机数在一个 epoch 期间保持不变。如果整理人跳过区块生产，则下一个符合条件的整理人可以使用相同的随机值来满足请求。</p> <p>您可以使用 随机数预编译的 <code>requestRelayBabeEpochRandomWords</code> 方法 来请求 BABE epoch 随机数。为了生成唯一的随机数，必须为 <code>requestRelayBabeEpochRandomWords</code> 函数提供不同的 salt。</p> <p>在每个中继链 epoch 更改开始时，将从一个 epoch 前的随机数从中继链状态证明中读取，并用于满足当前区块中所有应有的随机数请求。</p>"}, {"location": "learn/features/randomness/#request-and-fulfill-process", "title": "请求和完成过程", "text": "<p>通常，随机性的请求和完成过程如下：</p> <ol> <li>支付请求随机词所需的存款</li> <li> <p>使用本地 VRF 或 BABE 纪元随机性源请求随机性。当请求随机性时，您需要指定以下几项内容：</p> <ul> <li>退款地址，任何多余的费用将发送到该地址</li> <li>将预留用于支付完成费用的金额。如果指定的金额不足，您可以随时增加请求费用，或者如果金额过多，完成之后，多余的费用将退还到指定的地址</li> <li>将用于生成不同随机词的唯一盐值</li> <li>您想要请求的随机词的数量</li> <li>对于本地 VRF，以区块为单位的延迟周期，用于增加不可预测性。它必须介于上面列出的最小和最大区块数之间。对于 BABE 纪元随机性，您无需指定延迟，但可以在纪元延迟过去后完成请求</li> </ul> </li> <li> <p>等待延迟期过去</p> </li> <li>完成随机性请求，这将触发使用当前区块的随机性结果和给定的盐值来计算随机词。这可以由任何人使用最初为请求预留的费用手动完成</li> <li>对于已完成的请求，将返回随机词，执行成本将从请求费用中退还到启动完成的地址。然后，任何多余的费用和请求存款将转移到指定的退款地址</li> </ol> <p>如果请求过期，则可以由任何人清除它。发生这种情况时，请求费用将支付给启动清除的地址，存款将退还给原始请求者。</p> <p>随机性请求的愉快路径如下图所示：</p> <p></p>"}, {"location": "learn/features/randomness/#security-considerations", "title": "安全注意事项", "text": "<p>能够直接调用您的 <code>fulfillRandomness</code> 方法的方法可能会使用任何随机值来欺骗 VRF 响应，因此至关重要的是，它只能由 <code>RandomnessConsumer.sol</code> 合约的 <code>rawFulfillRandomness</code> 方法直接调用。</p> <p>为了让您的用户相信您合约的随机行为不受恶意干扰，最好的方法是编写它，以便 VRF 响应所暗示的所有行为都在您的 <code>fulfillRandomness</code> 方法期间执行。如果您的合约必须存储响应（或从中派生的任何内容）并在以后使用它，您必须确保任何依赖于该存储值的对用户有意义的行为都不会受到后续 VRF 请求的操纵。</p> <p>同样，收集者对 VRF 响应在区块链上出现的顺序有一定的影响，因此如果您的合约可能同时有多个 VRF 请求在进行中，您必须确保 VRF 响应到达的顺序不会被用来操纵您的合约中对用户有意义的行为。</p> <p>由于为 <code>requestLocalVRFRandomWords</code> 生成的随机词的输出取决于在完成时生成区块的收集者，因此收集者可以跳过其区块，强制由不同的收集者执行完成，从而生成不同的 VRF。但是，这种攻击会导致收集者失去区块奖励的成本。如果请求和完成之间的延迟太短，收集者也可能能够预测 VRF 的某些可能结果。因此，您可以选择提供更高的延迟。</p> <p>由于为 <code>requestRelayBabeEpochRandomWords</code> 生成的随机词的输出取决于在 epoch 期间生成区块的中继链验证者，因此 epoch 的最后一个验证者可以通过跳过区块的生成来选择两个可能的 VRF 输出。但是，这种攻击会导致验证者失去区块奖励的成本。只要有一个诚实的收集者，平行链收集者就不可能预测或影响中继链 VRF 的输出，也不能审查完成。</p>"}, {"location": "learn/features/staking/", "title": "在 Moonbeam 上进行质押", "text": ""}, {"location": "learn/features/staking/#introduction", "title": "简介", "text": "<p>Moonbeam 使用基于 Polkadot 的权益证明模型 的区块生产机制，其中有收集人和验证人。收集人 通过从用户那里收集交易并为中继链验证人生成状态转换证明来维护平行链（在本例中为 Moonbeam）。</p> <p>活跃收集人集合（生成区块的节点）中的候选者是根据他们在网络中的权益来选择的。这就是质押的用武之地。</p> <p>收集人候选者（以及如果他们委托，则为代币持有者）在网络中拥有权益。按质押数量排名的前 N 个候选者被选择来生成一组有效的交易区块，其中 N 是一个可配置的参数。每个区块奖励的一部分会分配给生成区块的收集人，然后收集人会根据委托人在收集人权益中所占的百分比，与委托人分享奖励。这样，网络成员就会被激励质押代币，以提高整体安全性。由于质押是在协议级别通过质押界面完成的，如果您选择委托，您委托的收集人将无法访问您的代币。</p> <p>要轻松管理与质押相关的操作，您可以访问 Moonbeam 网络 DApp 并使用页面顶部的网络选项卡在 Moonbeam 网络之间轻松切换。要了解如何使用 DApp，您可以查看如何在 Moonriver 上质押 MOVR 代币 指南或视频教程，两者都可以适用于 Moonbeam 和 Moonbase Alpha 测试网。</p>"}, {"location": "learn/features/staking/#general-definitions", "title": "常见定义", "text": "<p>以下是与 Moonbeam 上的 Staking 系统相关的一些重要参数，需要理解：</p> <ul> <li>Round（轮次）— 强制执行 Staking 行为的特定区块数。例如，在下一轮开始时，新的委托将被执行。在减少绑定或撤销委托时，资金将在指定轮数后返还</li> <li>Candidates（候选人）- 如果节点运营商能够获得足够的 Staking 量以进入活跃集，则有资格成为区块生产者</li> <li>Collators（整理人）— 被选为区块生产者的候选人活跃集。他们从用户那里收集交易，并生成状态转换证明以供中继链验证</li> <li>Delegators（委托人）— 质押代币并为特定整理人候选人担保的代币持有者。任何持有最少数量代币作为可用余额的用户都可以成为委托人</li> <li>Minimum delegation per candidate（每个候选人的最低委托量）— 用户进入委托人集合后，委托给候选人的最小代币数量。</li> <li>Maximum delegators per candidate（每个候选人的最大委托人数）— 根据质押数量，候选人可以拥有的符合获得 Staking 奖励资格的最大委托人数</li> <li>Maximum delegations（最大委托数）— 委托人可以委托的最大候选人数</li> <li>Exit delay（退出延迟）- 退出延迟是指候选人或委托人可以执行计划的请求以减少或撤销绑定、或离开候选人或委托人集合之前的轮数</li> <li>Reward payout delay（奖励支付延迟）- 在 Staking 奖励自动分配到可用余额之前必须经过的轮次数</li> <li>Reward pool（奖励池）- 预留给整理人和委托人的年度通货膨胀的一部分</li> <li>Collator commission（整理人佣金）- 整理人从应付 Staking 奖励中提取的默认固定百分比。与奖励池无关</li> <li>Delegator rewards（委托人奖励）— 在所有符合条件的委托人之间分配的累计委托人奖励，同时考虑到质押的相对大小（了解更多）</li> <li>Auto-compounding（自动复利）- 一种设置，可自动将委托人奖励的百分比应用于其委托的总金额</li> <li>Slashing（罚没）— 一种阻止整理人不良行为的机制，通常整理人及其委托人会被罚没，损失一定百分比的质押。目前，没有罚没，但可以通过治理来更改。未被中继链最终确认的区块的整理人将不会收到奖励</li> </ul>"}, {"location": "learn/features/staking/#quick-reference", "title": "快速参考", "text": "MoonbeamMoonriverMoonbase Alpha 变量 值 轮次持续时间 1800 区块 (6 小时) 每个候选人的最小委托量 50 GLMR 每个候选人的最大委托人数 300 最大委托数 100 奖励支付延迟 2 轮 (12 小时) 添加或增加委托 在下一轮生效（资金立即提取） 减少委托延迟 28 轮 (168 小时) 撤销委托延迟 28 轮 (168 小时) 离开委托人延迟 28 轮 (168 小时) 变量 值 轮次持续时间 600 区块 (2 小时) 每个候选人的最小委托量 5 MOVR 每个候选人的最大委托人数 300 最大委托数 100 奖励支付延迟 2 轮 (4 小时) 添加或增加委托 在下一轮生效（资金立即提取） 减少委托延迟 24 轮 (48 小时) 撤销委托延迟 24 轮 (48 小时) 离开委托人延迟 24 轮 (48 小时) 变量 值 轮次持续时间 1200 区块 (2 小时) 每个候选人的最小委托量 1 DEV 每个候选人的最大委托人数 300 最大委托数 100 奖励支付延迟 2 轮 (4 小时) 添加或增加委托 在下一轮生效（资金立即提取） 减少委托延迟 2 轮 (4 小时) 撤销委托延迟 2 轮 (4 小时) 离开委托人延迟 2 轮 (4 小时) <p>Note</p> <p>As of runtime 3000, asynchronous backing has been enabled on all Moonbeam networks. As a result, the target block time was reduced from 12 seconds to 6 seconds, which may break some timing-based assumptions.</p> <p>要了解如何获取有关质押的任何参数的当前值，请查看检索质押参数部分 如何质押您的代币 指南。</p> <p>如果您正在寻找候选人或整理人特定的要求和信息，您可以查看整理人 指南。</p>"}, {"location": "learn/features/staking/#resources-for-selecting-a-collator", "title": "选择 Collator 的资源", "text": "<p>您可以通过以下资源选择要委托的 Collator：</p> <p>=== |           变量           |                                      值                                      | |:----------------------------:|:-------------------------------------------------------------------------------:| |     质押 GLMR 仪表盘     |              质押 GLMR               | |    Collator 排行榜     |       Moonscan       | |      Collator 仪表盘      | DappLooker |</p> <p>=== |           变量           |                                      值                                       | |:----------------------------:|:--------------------------------------------------------------------------------:| |     质押 MOVR 仪表盘     |               质押 MOVR               | |    Collator 排行榜     |       Moonscan       | |      Collator 仪表盘      | DappLooker |</p> <p>=== |      变量      |                                      值                                       | |:------------------:|:--------------------------------------------------------------------------------:| | 候选人列表 | Moonbase Alpha Subscan |</p>"}, {"location": "learn/features/staking/#general-tips", "title": "一般提示", "text": "<ul> <li>为了优化您的质押奖励，您通常应该选择总抵押量较低的整理人。在这种情况下，您的委托金额将代表整理人总质押中更大的部分，您将获得成比例的更高奖励。但是，整理人被踢出活跃集并且根本无法获得奖励的风险更高</li> <li>每个整理人的最低保证金往往会随着时间的推移而增加，因此如果您的委托接近最低保证金，则您更有可能低于最低保证金而无法获得奖励</li> <li>在多个整理人之间分配委托在奖励方面更有效，但仅当您有足够的资金保持在每个整理人的最低保证金之上时才建议这样做</li> <li>您可以通过查看每个整理人最近生成的区块数量来考虑整理人的表现</li> <li>您可以设置自动复利，这将自动重新质押指定百分比的您的委托奖励</li> </ul>"}, {"location": "learn/features/staking/#reward-distribution", "title": "奖励分配", "text": "<p>验证人和他们的委托人的奖励是在每一轮开始时计算的，根据他们先于奖励支付延迟之前的工作。 例如，在 Moonriver 上，奖励是根据验证人从 2 轮之前的工作计算得出的。</p> <p>计算出的奖励然后从该轮的第二个区块开始，逐个区块地支付。对于每个区块，将选择一个验证人来接收他们上一轮的全部奖励支付，以及他们的委托人，直到该轮的所有奖励都已支付完毕。例如，如果上一轮有 72 个验证人生成了区块，那么所有的验证人及其委托人都将由新区快 73 支付。</p> <p>您可以选择自动复投您的委托奖励，这样您就不再需要手动委托奖励。如果您选择设置自动复投，您可以指定要自动复投的奖励百分比。这些奖励将自动添加到您的委托中。</p>"}, {"location": "learn/features/staking/#annual-inflation", "title": "年度通货膨胀", "text": "<p>年度通货膨胀的分配如下：</p> MoonbeamMoonriverMoonbase Alpha 变量 值 年度通货膨胀 5% 验证人和委托人的奖励池 50% 的年度通货膨胀 验证人佣金 20% 的年度通货膨胀 平行链债券储备 30% 的年度通货膨胀 变量 值 年度通货膨胀 5% 验证人和委托人的奖励池 50% 的年度通货膨胀 验证人佣金 20% 的年度通货膨胀 平行链债券储备 30% 的年度通货膨胀 变量 值 年度通货膨胀 5% 验证人和委托人的奖励池 50% 的年度通货膨胀 验证人佣金 20% 的年度通货膨胀 平行链债券储备 30% 的年度通货膨胀 <p>从奖励池中，验证人获得与其在网络中的股份相对应的奖励。其余的按股份分配给委托人。</p>"}, {"location": "learn/features/staking/#calculating-rewards", "title": "奖励计算", "text": "<p>从数学上讲，对于整理人来说，每个提议和最终确定的区块的奖励分配如下所示：</p> <p></p> <p>其中 <code>amount_due</code> 是在特定区块中分配的相应通货膨胀，<code>stake</code> 对应于整理人绑定的代币数量，相对于该整理人的总权益（包括委托）。</p> <p>对于每个委托人，（由委托的整理人提议和最终确定的）每个区块的奖励分配如下所示：</p> <p></p> <p>其中 <code>amount_due</code> 是在特定区块中分配的相应通货膨胀，<code>stake</code> 对应于每个委托人绑定的代币数量，相对于该整理人的总权益。</p>"}, {"location": "learn/features/staking/#risks", "title": "Risks", "text": "<p>Holders of MOVR/GLMR tokens should perform careful due diligence on collators before delegating. Being listed as a collator is not an endorsement or recommendation from the Moonbeam Network, the Moonriver Network, or Moonbeam Foundation. Neither the Moonbeam Network, Moonriver Network, nor Moonbeam Foundation has vetted the list collators and assumes no responsibility with regard to the selection, performance, security, accuracy, or use of any third-party offerings.  You alone are responsible for doing your own diligence to understand the applicable fees and all risks present, including actively monitoring the activity of your collators.</p> <p>You agree and understand that neither the Moonbeam Network, the Moonriver Network, nor Moonbeam Foundation guarantees that you will receive staking rewards and any applicable percentage provided (i) is an estimate only and not guaranteed, (ii) may change at any time and (iii) may be more or less than the actual staking rewards you receive. The Moonbeam Foundation makes no representations as to the monetary value of any rewards at any time.</p> <p>Staking MOVR/GLMR tokens is not free of risk. 抵押的MOVR/GLMR代币被锁定，取回它们需要等待 2 天/7 天。 Additionally, if a collator fails to perform required functions or acts in bad faith, a portion of their total stake can be slashed (i.e. destroyed). This includes the stake of their delegators. If a collators behaves suspiciously or is too often offline, delegators can choose to unbond from them or switch to another collator. Delegators can also mitigate risk by electing to distribute their stake across multiple collators.</p>"}, {"location": "learn/features/treasury/", "title": "Moonbeam 上的 Treasury", "text": ""}, {"location": "learn/features/treasury/#introduction", "title": "简介", "text": "<p>Moonbeam Treasury是在网络创世之初启动的链上资金集合。国库最初预先注资了代币供应量的0.5%，并随着80%的平行链债券储备通货膨胀进入国库，国库将继续积累GLMR。有关Moonbeam通货膨胀数据的更多信息，请参见GLMR代币经济学。</p> <p>Moonbeam Treasury为支持和发展网络的计划提供资金。利益相关者可以为国库委员会的审查提出支出要求，重点关注集成、协作、社区活动和外展等工作。国库支出提案人必须将其提案提交给Moonbeam论坛。有关提交详细信息，请参见如何提出国库支出。</p> <p>国库委员会负责监督Moonbeam Treasury的支出并对资金提案进行投票。它由Moonbeam基金会的两名成员和三名外部社区成员组成。三名外部成员的任期为6个月。同一国库委员会负责监督Moonbeam和Moonriver的国库请求。理事会每月召开一次会议，审查在Moonbeam论坛上提交的提案。一旦提案达成一致，理事会成员必须完成链上审批流程。</p>"}, {"location": "learn/features/treasury/#general-definitions", "title": "常规定义", "text": "<p>以下是关于国库的一些重要术语，需要理解：</p> <ul> <li>国库委员会 — 由 Moonbeam 基金会代表和外部社区成员组成的小组。委员会负责审查资金提案，确保与社区保持一致，并最终授权国库支出</li> <li>提案 — 利益相关者提交的，旨在进一步发展网络的计划或建议，需要获得国库委员会的批准</li> </ul>"}, {"location": "learn/features/treasury/#treasury-council-voting-process", "title": "财政委员会投票流程", "text": "<p>财政委员会的成员将提交一个 <code>treasury.spend</code> 调用。此调用需要指定金额、资产类型以及接收资金的受益人账户。财政部支持支出 GLMR 之外的各种 Token 类型，包括原生 USDT/USDC。一旦提交了此外部调用，将创建一个新的财政委员会集体提案，并提供给委员会成员进行投票。一旦通过财政委员会的内部投票流程获得批准，资金将通过 <code>treasury.payout</code> 外部调用自动释放到受益人账户。</p> <p>Note</p> <p>对于财政部支出请求的提议者或受益人来说，没有链上操作。 所有财政部支出操作将由财政委员会的成员完成。</p> <p>请注意，此过程与之前的财政部流程相比发生了重大变化，之前的流程中，Token 持有者可以提交附加债券的财政部提案。现在，不需要任何链上操作即可提交财政部提案。相反，所需要的只是在 Moonbeam 论坛 上提出财政委员会请求，财政委员会将负责链上组件。</p> <p>有关更多信息，请参见 如何提出财政部支出</p>"}, {"location": "node-operators/networks/tracing-node/", "title": "运行追踪节点", "text": ""}, {"location": "node-operators/networks/tracing-node/#introduction", "title": "简介", "text": "<p>Geth 的 <code>debug</code> 和 <code>txpool</code> API 以及 OpenEthereum 的 <code>trace</code> 模块提供了非标准的 RPC 方法，可以更深入地了解交易处理过程。作为 Moonbeam 为开发者提供无缝以太坊体验的目标的一部分，我们支持其中的一些非标准 RPC 方法。支持这些 RPC 方法是一个重要的里程碑，因为许多项目（例如 The Graph）都依赖它们来索引区块链数据。</p> <p>要使用支持的 RPC 方法，您需要运行一个追踪节点，这与运行完整节点略有不同。有一个不同的 Docker 镜像，名为 <code>moonbeamfoundation/moonbeam-tracing</code>，需要用于追踪。还需要使用一些额外的标志来告知节点要支持哪些非标准功能。</p> <p>本指南将向您展示如何通过启用 <code>debug</code>、<code>txpool</code> 和 <code>tracing</code> 标志，开始在 Moonbeam 上运行追踪节点。</p>"}, {"location": "node-operators/networks/tracing-node/#checking-prerequisites", "title": "检查先决条件", "text": "<p>与运行常规节点类似，您可以使用 Docker 或 Systemd 启动跟踪节点。如果您选择使用 Docker，则必须安装 Docker（如果您尚未安装）。在编写本文时，使用的 Docker 版本为 19.03.6。</p>"}, {"location": "node-operators/networks/tracing-node/#tracing-node-flags", "title": "追踪节点标记", "text": "<p>启动 <code>debug</code>、<code>txpool</code> 或 <code>tracing</code> 节点类似于运行完整节点，但需要额外的标记来启用非标准的以太坊 RPC 模块。这些标记控制追踪深度、缓存和运行时配置。</p> <ul> <li><code>--ethapi debug</code>: 启用具有 RPC 方法（如 <code>debug_traceTransaction</code>、<code>debug_traceBlockByNumber</code>、<code>debug_traceBlockByHash</code> 和 <code>debug_traceCall</code>）的 <code>debug</code> 模块。</li> <li><code>--ethapi trace</code>: 启用 <code>trace</code> 模块及其相关联的 RPC 方法（如 <code>trace_filter</code>）。</li> <li><code>--ethapi txpool</code>: 启用 <code>txpool</code> 模块，该模块提供 <code>txpool_content</code>、<code>txpool_inspect</code> 和 <code>txpool_status</code>。</li> <li><code>--wasm-runtime-overrides &lt;path/to/overrides&gt;</code>: 追踪必需。指定本地 Wasm 运行时的存储路径。</li> <li>对于 Docker 设置，请使用 <code>/moonbeam/&lt;network&gt;-substitutes-tracing</code>，其中 <code>&lt;network&gt;</code> 为 <code>moonbeam</code>、<code>moonriver</code> 或 <code>moonbase</code>（对于 Moonbase Alpha 或开发节点）。</li> <li><code>--runtime-cache-size 64</code>: 必需。配置在内存缓存中保存的不同运行时版本的数量为 <code>64</code>。</li> <li><code>--ethapi-max-permits &lt;uint&gt;</code>: 设置追踪模块（<code>debug</code>、<code>trace</code>）共享的并发追踪任务数。默认值：<code>10</code>。</li> <li><code>--ethapi-trace-max-count &lt;uint&gt;</code>: 设置单个 <code>trace_filter</code> 请求可以返回的最大追踪条目数。默认值：<code>500</code>。</li> <li><code>--ethapi-trace-cache-duration &lt;uint&gt;</code>: 在丢弃某区块的缓存 <code>trace_filter</code> 结果之前的持续时间（以秒为单位）。默认值：<code>300</code>。</li> <li><code>--eth-log-block-cache &lt;bytes&gt;</code>: 用于存储区块数据的 LRU 缓存的大小（以字节为单位）。默认值：<code>300000000</code>。</li> <li><code>--eth-statuses-cache &lt;bytes&gt;</code>: 用于存储交易状态数据的 LRU 缓存的大小（以字节为单位）。默认值：<code>300000000</code>。</li> <li><code>--fee-history-limit &lt;uint&gt;</code>: 设置 <code>eth_feeHistory</code> 请求的最大费用历史记录缓存大小。默认值：<code>2048</code>。</li> <li><code>--max-past-logs &lt;uint&gt;</code>: 单个日志查询返回的最大日志数。默认值：<code>10000</code>。</li> <li><code>--max-block-range &lt;uint&gt;</code>: 单个日志查询中允许的最大区块跨度。默认值：<code>1024</code>。</li> <li><code>--tracing-raw-max-memory-usage &lt;bytes&gt;</code>: 原始追踪请求使用的内存上限（堆栈、存储和内存数据）。默认值：<code>20000000</code>。</li> </ul> <p>Note</p> <p>如果您想运行一个 RPC 端点以连接到 Polkadot.js Apps 或您自己的 dApp，请使用 <code>--unsafe-rpc-external</code> 标记以允许外部访问 RPC 端口。运行 <code>moonbeam --help</code> 可以获得更多详细信息。</p>"}, {"location": "node-operators/networks/tracing-node/#run-a-tracing-node-with-docker", "title": "使用 Docker 运行追踪节点", "text": "<p>如果您之前没有运行过标准的完整 Moonbeam 节点，则需要设置一个目录来存储链数据：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>mkdir /var/lib/moonbeam-data\n</code></pre> <pre><code>mkdir /var/lib/moonriver-data\n</code></pre> <pre><code>mkdir /var/lib/alphanet-data\n</code></pre> <p>在开始之前，您需要为特定用户或当前用户设置必要的权限（将 <code>INSERT_DOCKER_USER</code> 替换为将运行 <code>docker</code> 命令的实际用户）：</p> MoonbeamMoonriverMoonbase Alpha <pre><code># chown 到特定的用户\nchown INSERT_DOCKER_USER /var/lib/moonbeam-data\n\n# chown 到当前用户\nsudo chown -R $(id -u):$(id -g) /var/lib/moonbeam-data\n</code></pre> <pre><code># chown 到特定的用户\nchown INSERT_DOCKER_USER /var/lib/moonriver-data\n\n# chown 到当前用户\nsudo chown -R $(id -u):$(id -g) /var/lib/moonriver-data\n</code></pre> <pre><code># chown 到特定的用户\nchown INSERT_DOCKER_USER /var/lib/alphanet-data\n\n# chown 到当前用户\nsudo chown -R $(id -u):$(id -g) /var/lib/alphanet-data\n</code></pre> <p>您需要使用 <code>moonbeamfoundation/moonbeam-tracing</code> 镜像，而不是标准的 <code>moonbeamfoundation/moonbeam</code> Docker 镜像。最新受支持的版本可以在 <code>moonbeam-tracing</code> 镜像的 Docker Hub 上找到。</p> <p>现在，执行 docker run 命令。请注意，您必须：</p> <ul> <li>在两个不同的地方替换 <code>INSERT_YOUR_NODE_NAME</code>。</li> <li>将 <code>INSERT_RAM_IN_MB</code> 替换为您服务器实际 RAM 的 50%。例如，对于 32 GB 的 RAM，该值必须设置为 <code>16000</code>。最小值为 <code>2000</code>，但低于建议的规格。</li> </ul> <p>Note</p> <p>As of client v0.33.0, the <code>--ws-port</code> and <code>--ws-max-connections</code> flags have been deprecated and removed in favor of the <code>--rpc-port</code> and <code>--rpc-max-connections</code> flags for both RPC and WSS connections. The default port is <code>9944</code>, and the default maximum number of connections is set to 100.</p> <p>运行追踪节点的完整命令如下：</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam-tracing:v0.49.2-4101-4c40 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--ethapi debug,trace,txpool \\\n--wasm-runtime-overrides /moonbeam/moonbeam-substitutes-tracing \\\n--runtime-cache-size 64 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam-tracing:v0.49.2-4101-4c40 \\\n--base-path /data \\\n--chain moonriver \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--ethapi debug,trace,txpool \\\n--wasm-runtime-overrides /moonbeam/moonriver-substitutes-tracing \\\n--runtime-cache-size 64 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam-tracing:v0.49.2-4101-4c40 \\\n--base-path /data \\\n--chain alphanet \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--ethapi debug,trace,txpool \\\n--wasm-runtime-overrides /moonbeam/moonbase-substitutes-tracing \\\n--runtime-cache-size 64 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n</code></pre> <pre><code>docker run --network=\"host\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam-tracing:v0.49.2-4101-4c40 \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--ethapi debug,trace,txpool \\\n--wasm-runtime-overrides /moonbeam/moonbase-substitutes-tracing \\\n--runtime-cache-size 64 \\\n--dev\n</code></pre> <p>如果您启动了一个 Moonbase Alpha 追踪节点，您应该会看到类似于以下内容的终端日志：</p> docker run --network host  \\     -u $(id -u ${USER}):$(id -g ${USER}) \\         moonbeamfoundation/moonbeam-tracing:v0.49.2-4100-4d7b \\     --name=\"Moonbeam-Tracing-Tutorial\" \\     --unsafe-rpc-external \\     --ethapi=debug,trace,txpool \\     --wasm-runtime-overrides=/moonbeam/moonbase-substitutes-tracing \\     --runtime-cache-size 64 \\     --dev     2025-07-10 09:04:26 Moonbeam Parachain Collator      2025-07-10 09:04:26 ✌️  version 0.49.2      2025-07-10 09:04:26 ❤️  by PureStake, 2019-2025      2025-07-10 09:04:26 📋 Chain specification: Moonbase Development Testnet      2025-07-10 09:04:26 🏷  Node name: Moonbeam-Tracing-Tutorial      2025-07-10 09:04:26 👤 Role: AUTHORITY      2025-07-10 09:04:26 💾 Database: RocksDb at /tmp/substrateO3YeRz/chains/moonbase_dev/db/full      2025-07-10 09:04:26 Found wasm override. version=moonbase-300 (moonbase-0.tx2.au3) file=/moonbeam/moonbase-substitutes-tracing/moonbase-runtime-300-substitute-tracing.wasm      ...      2025-07-10 09:04:26 💤 Idle (0 peers), best: #0 (0x18e6…2eb1), finalized #0 (0x18e6…2eb1), ⬇ 0 ⬆ 0"}, {"location": "node-operators/networks/tracing-node/#run-a-tracing-node-with-systemd", "title": "使用 Systemd 运行追踪节点", "text": "<p>当您使用 Systemd 运行节点时，首先需要设置 Moonbeam 二进制文件。为此，您需要按照使用 Systemd 在 Moonbeam 上运行节点 页面上的说明进行操作。通常，您需要：</p> <ol> <li>按照发布二进制文件 说明设置 Moonbeam 二进制文件。或者，如果您想自己编译二进制文件，可以按照 编译二进制文件 说明进行操作</li> <li>按照设置服务 说明中的说明进行操作</li> </ol> <p>完成上述特定部分的说明后，您可以继续阅读以下说明。</p>"}, {"location": "node-operators/networks/tracing-node/#setup-the-wasm-overrides", "title": "设置 Wasm 覆盖", "text": "<p>您需要为 Wasm 运行时覆盖创建一个目录，并从 GitHub 上的 Moonbeam 运行时覆盖存储库 中获取它们。</p> <p>您可以将存储库克隆到本地计算机上的任何位置。为简单起见，您可以使用存储链上数据的目录。要设置 Wasm 覆盖文件，您可以采取以下步骤：</p> <ol> <li> <p>克隆 Moonbeam 运行时覆盖存储库</p> <pre><code>git clone https://github.com/moonbeam-foundation/moonbeam-runtime-overrides.git\n</code></pre> </li> <li> <p>将 Wasm 覆盖移动到您的链上数据目录中：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>mv moonbeam-runtime-overrides/wasm /var/lib/moonbeam-data\n</code></pre> <pre><code>mv moonbeam-runtime-overrides/wasm /var/lib/moonriver-data\n</code></pre> <pre><code>mv moonbeam-runtime-overrides/wasm /var/lib/alphanet-data\n</code></pre> </li> <li> <p>删除您未运行的网络的覆盖文件</p> MoonbeamMoonriverMoonbase Alpha <pre><code>rm /var/lib/moonbeam-data/wasm/moonriver-runtime-* &amp;&amp;  rm /var/lib/moonbeam-data/wasm/moonbase-runtime-*\n</code></pre> <pre><code>rm /var/lib/moonriver-data/wasm/moonbeam-runtime-* &amp;&amp;  rm /var/lib/moonriver-data/wasm/moonbase-runtime-*\n</code></pre> <pre><code>rm /var/lib/alphanet-data/wasm/moonbeam-runtime-* &amp;&amp;  rm /var/lib/alphanet-data/wasm/moonriver-runtime-*\n</code></pre> </li> <li> <p>设置覆盖的用户权限：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>chmod +x /var/lib/moonbeam-data/wasm/*\nchown moonbeam_service /var/lib/moonbeam-data/wasm/*\n</code></pre> <pre><code>chmod +x /var/lib/moonriver-data/wasm/*\nchown moonriver_service /var/lib/moonriver-data/wasm/*\n</code></pre> <pre><code>chmod +x /var/lib/alphanet-data/wasm/*\nchown moonbase_service /var/lib/alphanet-data/wasm/*\n</code></pre> </li> </ol>"}, {"location": "node-operators/networks/tracing-node/#create-the-configuration-file", "title": "创建配置文件", "text": "<p>下一步是创建 systemd 配置文件，您需要：</p> <ul> <li>在两个不同的位置替换 <code>INSERT_YOUR_NODE_NAME</code></li> <li>将 <code>INSERT_RAM_IN_MB</code> 替换为您服务器实际 RAM 的 50%。例如，对于 32 GB 的 RAM，该值必须设置为 <code>16000</code>。最小值是 <code>2000</code>，但低于建议的规格</li> <li>仔细检查二进制文件是否位于下方所述的正确路径中 (ExecStart)</li> <li>如果您使用了不同的目录，请仔细检查基本路径</li> <li>将文件命名为 <code>/etc/systemd/system/moonbeam.service</code></li> </ul> <p>Note</p> <p>As of client v0.33.0, the <code>--ws-port</code> and <code>--ws-max-connections</code> flags have been deprecated and removed in favor of the <code>--rpc-port</code> and <code>--rpc-max-connections</code> flags for both RPC and WSS connections. The default port is <code>9944</code>, and the default maximum number of connections is set to 100.</p> MoonbeamMoonriverMoonbase Alpha <p>bash [Unit] Description=\"Moonbeam systemd 服务\" After=network.target StartLimitIntervalSec=0</p> <p>[Service] Type=simple Restart=on-failure RestartSec=10 User=moonbeam_service SyslogIdentifier=moonbeam SyslogFacility=local7 KillSignal=SIGHUP ExecStart=/var/lib/moonbeam-data/moonbeam \\      --state-pruning archive \\      --trie-cache-size 1073741824 \\      --db-cache INSERT_RAM_IN_MB \\      --base-path /var/lib/moonbeam-data \\      --ethapi debug,trace,txpool \\      --wasm-runtime-overrides /var/lib/moonbeam-data/wasm \\      --runtime-cache-size 64 \\      --chain moonbeam \\      --name \"INSERT_YOUR_NODE_NAME\" \\      -- \\      --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"</p> <p>[Install] WantedBy=multi-user.target</p> <p>bash [Unit] Description=\"Moonriver systemd 服务\" After=network.target StartLimitIntervalSec=0</p> <p>[Service] Type=simple Restart=on-failure RestartSec=10 User=moonriver_service SyslogIdentifier=moonriver SyslogFacility=local7 KillSignal=SIGHUP ExecStart=/var/lib/moonriver-data/moonbeam \\      --state-pruning archive \\      --trie-cache-size 1073741824 \\      --db-cache INSERT_RAM_IN_MB \\      --base-path /var/lib/moonriver-data \\      --ethapi debug,trace,txpool \\      --wasm-runtime-overrides /var/lib/moonriver-data/wasm \\      --runtime-cache-size 64 \\      --chain moonriver \\      --name \"INSERT_YOUR_NODE_NAME\" \\      -- \\      --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"</p> <p>[Install] WantedBy=multi-user.target</p> <p>bash [Unit] Description=\"Moonbase Alpha systemd 服务\" After=network.target StartLimitIntervalSec=0</p> <p>[Service] Type=simple Restart=on-failure RestartSec=10 User=moonbase_service SyslogIdentifier=moonbase SyslogFacility=local7 KillSignal=SIGHUP ExecStart=/var/lib/alphanet-data/moonbeam \\      --state-pruning archive \\      --trie-cache-size 1073741824 \\      --db-cache INSERT_RAM_IN_MB \\      --base-path /var/lib/alphanet-data \\      --ethapi debug,trace,txpool \\      --wasm-runtime-overrides /var/lib/alphanet-data/wasm \\      --runtime-cache-size 64 \\      --chain alphanet \\      --name \"INSERT_YOUR_NODE_NAME\" \\      -- \\      --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"</p> <p>[Install] WantedBy=multi-user.target</p> <p>Note</p> <p>如果您想要运行 RPC 端点，以连接 polkadot.js.org，或运行您自己的应用程序，请使用 <code>--unsafe-rpc-external</code> 标志来运行具有外部 RPC 端口访问权限的完整节点。 运行 <code>moonbeam --help</code> 可以获得更多详细信息。</p>"}, {"location": "node-operators/networks/tracing-node/#using-a-tracing-node", "title": "使用追踪节点", "text": "<p>要了解 Moonbeam 上可用的不同非标准 RPC 方法，以及如何通过追踪节点使用这些方法，请查看调试与追踪指南。</p>"}, {"location": "node-operators/networks/collators/account-management/", "title": "Collator 帐户管理", "text": ""}, {"location": "node-operators/networks/collators/account-management/#introduction", "title": "简介", "text": "<p>在 Moonbeam 类的网络上运行排序人节点时，您需要了解一些账户管理活动。首先，您需要为您的主服务器和备份服务器创建会话密钥，这些密钥将用于确定区块生产和签署区块。</p> <p>此外，您可以考虑一些可选的账户管理活动，例如设置链上身份或设置代理账户。</p> <p>本指南将介绍如何管理您的排序人账户，包括生成和轮换您的会话密钥、注册和更新您的会话密钥、设置身份以及创建代理账户。</p>"}, {"location": "node-operators/networks/collators/account-management/#process", "title": "添加和更新会话密钥的流程", "text": "<p>首次添加会话密钥的流程与轮换会话密钥的流程相同。创建/轮换会话密钥的流程如下：</p> <ol> <li>使用 <code>author_rotateKeys</code> RPC 方法生成会话密钥。调用此方法的响应将是一个 128 个十六进制字符的字符串，其中包含 Nimbus ID 和 VRF 会话密钥的公钥</li> <li>如果您尚未加入候选池，请加入</li> <li>使用 Author Mapping Pallet 的 <code>setKeys(keys)</code> extrinsic 将会话密钥映射到您的候选帐户，该 extrinsic 接受整个 128 个十六进制字符的字符串作为输入。首次调用 <code>setKeys</code> 时，您需要提交一个映射 bond。如果您要轮换密钥并且之前已提交了映射 bond，则无需新的 bond</li> </ol> <p>以下部分概述了该过程的每个步骤。</p>"}, {"location": "node-operators/networks/collators/account-management/#session-keys", "title": "生成会话密钥", "text": "<p>To match the Substrate standard, Moonbeam collator's session keys are SR25519. This guide will show you how you can create/rotate your session keys associated with your collator node.</p> <p>First, make sure you're running a collator node. Once you have your collator node running, your terminal should print similar logs:</p> 2025-02-25 20:00:52 [Relaychain] 💤 Idle (6 peers), best: #12706 (0x1d51.3042), finalized #12704 (0xf74b.aa44), 1 0.4kiB/s 1 0.6kiB/s 2025-02-25 20:00:52 💤 Idle (6 peers), best: #5751 (Oxc5alesb5), finalized #5750 (0x9dc..e bad), 1 9.6kiB/s 1 3.5kiB/s 2025-02-25 20:00:53 [Relaychain] ✨ Imported #12707 (0x77ea.4299) 2025-02-25 20:00:57 [Relaychain] 💤 Idle (6 peers), best: #12707 (0x77ea..4299), finalized #12704 (0xf74b..aa44), | 16.4kiB/s 1 12.2kiB/s 2025-02-25 20:00:57 💤 Idle (6 peers), best: #5751 (0xc5a1e8b5), finalized #5750 (0x9fdc...e bad), 1 1.6kiB/s 1 0.4kiB/s 2025-02-25 20:00:59 [Relaychain] ✨ Imported #12708 (0x009f...3bbf) 2025-02-25 20:01:00 ✨ Imported #5753 (0x8981.6c81) 2025-02-25 20:01:00 ✨ Imported #5753 (0x33a...b5e3) 2025-02-25 20:01:02 [Relaychain] 💤 Idle (6 peers), best: #12708 (0x009f...3bbf), finalized #12706 (0x1d51.3042), 1 1.5kiB/s 1 1.3kiB/s 2025-02-25 20:01:02 💤 Idle (6 peers), best: #5752 (0x7036.569e), finalized #5751 (0xc5a1..e8b5), 1 3.3kiB/s 1 5.8kiB/s 2025-02-25 20:01:05 [Relaychain] ✨ Imported #12709 (0x76b9...bf65) 2025-02-25 20:01:07 [Relaychain] 💤 Idle (6 peers), best: #12709 (0x76b9..bf65), finalized #12706 (0x1d51.3042), | 2.0kiB/s | 0.9kiB/s 2025-02-25 20:01:07 💤 Idle (6 peers), best: #5752 (0x7036.569e), finalized #5751 (0xc5a1..e8b5), 1 0 1 0 <p>Next, session keys can be created/rotated by sending an RPC call to the HTTP endpoint with the <code>author_rotateKeys</code> method. When you call <code>author_rotateKeys</code>, the result is the size of two keys. The response will contain a concatenated Nimbus ID and VRF key. The Nimbus ID will be used to sign blocks and the VRF key is required for block production. The concatenated keys will be used to create an association to your H160 account for block rewards to be paid out.</p> <p>For reference, if your collator's HTTP endpoint is at port <code>9944</code>, the JSON-RPC call might look like this:</p> <pre><code>curl http://127.0.0.1:9944 -H \\\n\"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n  }'\n</code></pre> <p>The collator node should respond with the concatenated public keys of your new session keys. The first 64 hexadecimal characters after the <code>0x</code> prefix represent your Nimbus ID and the last 64 hexadecimal characters are the public key of your VRF session key. You'll use the concatenated public keys when mapping your Nimbus ID and setting the session keys in the next section.</p> curl http://127.0.0.1:9933-H\\ \"Content-Type: application/json;charset=utf-8\" -d \\ '{ \"jsonrpc\": \"2.0\", \"id\" :1, \"method\": \"author_rotatekeys\", \"params\": [] }' {\"jsonrpc\": \"2.0\", \"result\":\"0x72c7ca7ef0794103caeb520806576b52cb085f7577cc12cd36c2d64dbf73757a789407ec0f401a8792ac57c4fb7dabd4da6cc74d9ac9b8dd8c4faf770255403f\", \"id\" :1} <p>Make sure you write down the concatenated public keys. Each of your servers, your primary and backup, should have their own unique keys. Since the keys never leave your servers, you can consider them a unique ID for that server.</p> <p>Next, you'll need to register your session keys and map them to an H160 Ethereum-styled address to which the block rewards are paid.</p>"}, {"location": "node-operators/networks/collators/account-management/#manage-session-keys", "title": "管理会话密钥", "text": "<p>创建或轮换会话密钥后，您可以使用 Author Mapping Pallet 中的 extrinsics 来管理会话密钥。您可以映射会话密钥、验证链上映射并删除会话密钥。</p>"}, {"location": "node-operators/networks/collators/account-management/#author-mapping-interface", "title": "作者映射 Pallet 接口", "text": "<p><code>authorMapping</code> 模块具有以下外部调用：</p> <ul> <li>setKeys(keys) — 接受调用 <code>author_rotateKeys</code> 的结果，该结果是您的 Nimbus 和 VRF 密钥的串联公钥，并立即设置会话密钥。在密钥轮换或迁移后非常有用。调用 <code>setKeys</code> 需要 担保。替换已弃用的 <code>addAssociation</code> 和 <code>updateAssociation</code> 外部调用</li> <li>removeKeys() - 删除会话密钥。如果您打算停止整理并离开候选池，则这是唯一需要的。替换已弃用的 <code>clearAssociation</code> 外部调用</li> </ul> <p>该模块还添加了以下 RPC 调用（链状态）：</p> <ul> <li>mappingWithDeposit(NimbusPrimitivesNimbusCryptoPublic | string | Uint8Array) — 显示链上存储的所有映射，或者仅显示与提供的 Nimbus ID 相关的映射</li> <li>nimbusLookup(AccountId20) - 显示所有整理者或给定整理者地址的帐户 ID 到 Nimbus ID 的反向映射</li> </ul>"}, {"location": "node-operators/networks/collators/account-management/#mapping-extrinsic", "title": "映射会话密钥", "text": "<p>有了新生成的会话密钥后，下一步是将您的会话密钥映射到您的 H160 帐户（以太坊风格的地址）。请确保您持有此帐户的私钥，因为区块奖励将支付到此帐户。</p> <p>要将会话密钥映射到您的帐户，您需要位于候选池中。一旦您成为候选人，您需要发送一个映射外部函数，这需要一个映射保证金。</p>"}, {"location": "node-operators/networks/collators/account-management/#mapping-bonds", "title": "映射保证金", "text": "<p>映射保证金是根据注册的会话密钥计算的。将您的会话密钥映射到您的帐户的保证金如下所示：</p> MoonbeamMoonriverMoonbase Alpha <p>text 10000 GLMR</p> <p>text 100 MOVR</p> <p>text 100 DEV</p>"}, {"location": "node-operators/networks/collators/account-management/#use-polkadotjs-apps", "title": "使用 Polkadot.js Apps 映射会话密钥", "text": "<p>在本节中，您将学习如何通过 Polkadot.js Apps 映射会话密钥。要学习如何通过作者映射预编译合约创建映射，您可以参考与作者映射预编译交互页面。</p> <p>要从 Polkadot.js Apps 创建映射（确保您已连接到正确的网络），请点击页面顶部的 Developer，从下拉菜单中选择 Extrinsics 选项，然后执行以下步骤：</p> <ol> <li>选择您想要将作者 ID 关联到的帐户，您将使用该帐户签署此交易</li> <li>选择 authorMapping extrinsic</li> <li>将方法设置为 setKeys()</li> <li>输入 keys。这是通过上一节中的 RPC 调用 <code>author_rotateKeys</code> 获得的响应，它是您的 Nimbus ID 和 VRF 密钥的串联公钥</li> <li>点击 Submit Transaction</li> </ol> <p></p> <p>Note</p> <p>如果您收到以下错误，您可能需要尝试再次轮换和映射您的密钥：<code>VRF PreDigest was not included in the digests (check rand key is in keystore)</code>。</p> <p>如果交易成功，您将在屏幕上看到确认通知。如果没有，请确保您已加入候选池。</p>"}, {"location": "node-operators/networks/collators/account-management/#checking-the-mappings", "title": "检查映射", "text": "<p>您可以通过验证链状态来检查当前的链上映射。您可以通过两种方式执行此操作：通过 <code>mappingWithDeposit</code> 方法或 <code>nimbusLookup</code> 方法。这两种方法都可用于查询所有整理者或特定整理者的链上数据。</p> <p>您可以检查特定整理者的当前链上映射，也可以检查链上存储的所有映射。</p>"}, {"location": "node-operators/networks/collators/account-management/#using-nimbus-lookup", "title": "使用 Nimbus 查找方法", "text": "<p>要使用 <code>nimbusLookup</code> 方法检查特定整理人的映射，您需要整理人的地址。如果您没有将参数传递给该方法，您可以检索所有链上映射。</p> <p>从 Polkadot.js Apps 中，单击页面顶部的 Developer，然后从下拉菜单中选择 Chain State，并按照以下步骤操作：</p> <ol> <li>选择 authorMapping 作为要查询的状态</li> <li>选择 nimbusLookup 方法</li> <li>提供一个整理人的地址以进行查询。或者，您可以禁用滑块以检索所有映射</li> <li>单击 + 按钮以发送 RPC 调用</li> </ol> <p></p> <p>您应该能够看到与提供的 H160 帐户关联的 nimbus ID。如果没有提供帐户，这将返回所有存储在链上的映射。</p>"}, {"location": "node-operators/networks/collators/account-management/#removing-session-keys", "title": "删除会话密钥", "text": "<p>在删除会话密钥之前，您需要确保已停止整理并离开候选池。要停止整理，您需要安排一个离开候选池的请求，等待一段延迟时间，然后执行该请求。有关分步说明，请参阅 Moonbeam Collator Activities 页面的停止整理部分。</p> <p>离开候选池后，您可以删除您的会话密钥。之后，您存入的映射保证金将退还到您的帐户。</p> <p>从 Polkadot.js Apps 中，单击页面顶部的 Developer，然后从下拉列表中选择 Extrinsics，并按照以下步骤操作：</p> <ol> <li>选择您的帐户</li> <li>选择 authorMapping pallet 和 removeKeys extrinsic</li> <li>单击 Submit Transaction</li> </ol> <p></p> <p>交易完成后，映射保证金将退还给您。要确保密钥已删除，您可以按照检查映射部分中的步骤操作。</p>"}, {"location": "node-operators/networks/collators/account-management/#setting-an-identity", "title": "设置身份", "text": "<p>设置链上身份可以使您的收集人节点易于识别。与显示您的帐户地址相反，将显示您选择的显示名称。</p> <p>您可以通过几种方式设置您的身份，要了解如何为您的收集人节点设置身份，请查看我们文档的管理您的帐户身份页面。</p>"}, {"location": "node-operators/networks/collators/account-management/#proxy-accounts", "title": "代理账户", "text": "<p>代理账户是指可以启用以代表您执行有限数量操作的账户。通过代理，用户可以将主账户安全地保存在冷存储中，同时使用代理代表主账户积极参与网络。您可以随时删除代理账户的授权。作为额外的安全层，您可以设置具有延迟期的代理。此延迟期将使您有时间审查交易，并在交易自动执行之前根据需要取消交易。</p> <p>要了解如何设置代理账户，请参阅我们文档的设置代理账户页面。</p>"}, {"location": "node-operators/networks/collators/activities/", "title": "Collator 活动", "text": ""}, {"location": "node-operators/networks/collators/activities/#introduction", "title": "简介", "text": "<p>要成为基于 Moonbeam 的网络上的收集人，您需要满足绑定要求并加入候选池。进入候选池后，您可以随时调整您的自抵押金额或决定离开池。</p> <p>如果您希望减少您的自抵押金额或离开候选池，您需要先安排一个离开请求，然后在延迟期过后执行该请求。</p> <p>本指南将带您了解离开或减少自抵押金额时需要注意的重要时间，如何加入和离开候选池，以及如何调整您的自抵押。</p>"}, {"location": "node-operators/networks/collators/activities/#collator-timings", "title": "整理人计时", "text": "<p>在开始之前，重要的是要注意与整理人活动相关的不同操作的一些时间安排：</p> MoonbeamMoonriverMoonbase Alpha 变量 值 轮次持续时间 1800 区块 (6 小时) 离开候选人 28 轮次 (168 小时) 撤销委托 28 轮次 (168 小时) 减少自委托 28 轮次 (168 小时) 奖励支付（当前轮次之后） 2 轮次 (12 小时) 最大离线轮次 1 轮次 (6 小时) 变量 值 轮次持续时间 600 区块 (2 小时) 离开候选人 24 轮次 (48 小时) 撤销委托 24 轮次 (48 小时) 减少自委托 24 轮次 (48 小时) 奖励支付（当前轮次之后） 2 轮次 (4 小时) 最大离线轮次 2 轮次 (4 小时) 变量 值 轮次持续时间 1200 区块 (2 小时) 离开候选人 2 轮次 (4 小时) 撤销委托 2 轮次 (4 小时) 减少自委托 2 轮次 (4 小时) 奖励支付（当前轮次之后） 2 轮次 (4 小时) 最大离线轮次 2 轮次 (4 小时) <p>Note</p> <p>先前表格中显示的值可能会在将来的版本中更改。</p> <p>Note</p> <p>As of runtime 3000, asynchronous backing has been enabled on all Moonbeam networks. As a result, the target block time was reduced from 12 seconds to 6 seconds, which may break some timing-based assumptions.</p>"}, {"location": "node-operators/networks/collators/activities/#become-a-candidate", "title": "成为候选人", "text": ""}, {"location": "node-operators/networks/collators/activities/#get-the-size-of-the-candidate-pool", "title": "获取候选池的大小", "text": "<p>首先，您需要获取 <code>candidatePool</code> 的大小（这可以通过治理来更改），因为您需要在稍后的交易中提交此参数。为此，您必须从 Polkadot.js 中运行以下 JavaScript 代码片段：</p> <pre><code>// Simple script to get candidate pool size\nconst candidatePool = await api.query.parachainStaking.candidatePool();\nconsole.log(`Candidate pool size is: ${candidatePool.length}`);\n</code></pre> <p>前往 Developer 选项卡，从下拉列表中选择 JavaScript，然后执行以下步骤：</p> <ol> <li>从之前的代码段中复制代码并将其粘贴到代码编辑器框中。（可选）单击保存图标并为代码段设置一个名称，例如“Get candidatePool size”。这会将代码段保存在本地</li> <li>要执行代码，请单击运行按钮</li> <li>复制结果，因为在加入候选池时需要它</li> </ol> <p></p>"}, {"location": "node-operators/networks/collators/activities/#join-the-candidate-pool", "title": "加入候选人池", "text": "<p>一旦您的节点运行并与网络同步，您就成为候选人并加入候选人池。根据您连接到的网络，请转到 Polkadot.js，点击 Developer 选项卡，从下拉列表中选择 Extrinsics，然后执行以下步骤：</p> <ol> <li>选择您要成为收集人的帐户。确认您的帐户已至少存入所需的最低权益加上一些额外的交易费用</li> <li>在 submit the following extrinsic 菜单下选择 parachainStaking pallet</li> <li>打开下拉菜单，其中列出了所有与权益相关的可能的外部因素，然后选择 joinCandidates 函数</li> <li>将保证金设置为至少最低金额，以便被视为候选人。您需要以 <code>Wei</code> 为单位输入此金额。例如，Moonbase Alpha 上的 500 DEV 的最低保证金为 <code>500000000000000000000</code> Wei (500 + 18 个额外的零)。只有备选保证金才会计入此检查。额外的委托不算数</li> <li>将候选人计数设置为候选人池大小。要了解如何检索此值，请查看获取候选人池大小部分</li> <li>提交交易。按照向导操作，并使用您为帐户设置的密码签署交易</li> </ol> <p></p> <p>Note</p> <p>函数名称和最低保证金要求可能会在未来的版本中更改。</p> <p>如前所述，只有委托权益最高的候选人才能进入活跃的收集人集合。每个网络中排名前列的候选人的确切数量和最低保证金金额可在最低收集人保证金部分中找到。</p>"}, {"location": "node-operators/networks/collators/activities/#stop-collating", "title": "停止整理", "text": "<p>要停止整理并离开候选池，您必须首先安排一个离开该池的请求。安排请求会自动将您从活跃集中移除，因此您将不再有资格生成区块或赚取奖励。您必须等待 退出延迟 的持续时间，然后才能执行离开的请求。请求执行后，您将从候选池中移除。</p> <p>类似于 Polkadot 的 <code>chill()</code> 功能，您可以 暂时离开候选池 而无需解绑您的代币。</p>"}, {"location": "node-operators/networks/collators/activities/#schedule-request-to-leave-candidates", "title": "安排离开候选人请求", "text": "<p>要开始并安排请求，请导航到开发人员选项卡，单击外部因素，然后执行以下步骤：</p> <ol> <li>选择您的候选人帐户</li> <li>在提交以下外部因素菜单下选择 parachainStaking pallet</li> <li>选择 scheduleLeaveCandidates 外部因素</li> <li>输入您应该在获取候选池大小部分中检索到的 <code>candidateCount</code></li> <li>提交交易。按照向导操作，并使用您为该帐户设置的密码签署交易</li> </ol> <p></p>"}, {"location": "node-operators/networks/collators/activities/#execute-request-to-leave-candidates", "title": "执行离开候选人的请求", "text": "<p>等待期过后，您就可以执行该请求了。要执行离开候选人池的请求，您首先需要获得候选人的委托数量。为此，您可以查询候选人信息，其中将包括委托计数。要开始，请单击开发者选项卡，选择链状态，然后按照以下步骤操作：</p> <ol> <li>从选定的状态查询下拉菜单中，选择 parachainStaking</li> <li>选择 candidateInfo 外部函数</li> <li>选择要获取信息的候选人帐户</li> <li>单击 + 按钮提交外部函数</li> <li>复制 <code>delegationCount</code> 以用于执行离开候选人的请求</li> </ol> <p></p> <p>现在您已经获得了委托计数，您可以执行该请求了。切换回 外部函数 选项卡，然后按照以下步骤操作：</p> <ol> <li>选择您的候选人帐户</li> <li>在 提交以下外部函数 菜单下选择 parachainStaking pallet</li> <li>选择 executeLeaveCandidates 外部函数</li> <li>选择目标候选人帐户（在提交 <code>scheduleLeaveCandidates</code> 外部函数后，退出延迟过去后，任何人都可以执行该请求）</li> <li>输入候选人的委托计数</li> <li>提交交易。按照向导操作，并使用您为该帐户设置的密码签署交易</li> </ol> <p></p>"}, {"location": "node-operators/networks/collators/activities/#cancel-request-to-leave-candidates", "title": "取消离开候选人的请求", "text": "<p>如果您安排了离开候选人池的请求但改变了主意，只要请求尚未执行，您可以取消请求并保留在候选人池中。要取消请求，请确保您已点击 Developer 选项卡中的 Extrinsics，然后按照以下步骤操作：</p> <ol> <li>选择您的候选人帐户</li> <li>在 submit the following extrinsic 菜单下选择 parachainStaking 托盘</li> <li>选择 cancelLeaveCandidates 外部调用</li> <li>提供您应该在 获取候选人池的大小 部分检索到的 <code>candidateCount</code></li> <li>提交交易。按照向导操作，并使用您为该帐户设置的密码签署交易</li> </ol> <p></p>"}, {"location": "node-operators/networks/collators/activities/#temporarily-leave-the-candidate-pool", "title": "临时离开候选池", "text": "<p>如果您想暂时离开候选池，可以使用 <code>goOffline</code> 方法轻松实现。例如，如果您需要暂时离开以执行维护操作，这将非常有用。完成后，您可以使用 <code>goOnline</code> 方法重新加入池。</p> <p>要暂时离开，您可以按照以下步骤操作：</p> <ol> <li>导航到开发者选项卡</li> <li>点击Extrinsics</li> <li>选择您的候选人账户</li> <li>在提交以下 extrinsic 菜单下选择 parachainStaking pallet</li> <li>选择 goOffline extrinsic</li> <li>提交交易。按照向导操作，并使用您为该账户设置的密码签署交易</li> </ol> <p></p> <p>然后，每当您希望重新加入时，您可以按照上述相同的步骤使用 <code>goOnline</code> 方法，然后在第 5 步中，选择 <code>goOnline</code> extrinsic。请注意，只有在您之前调用过 <code>goOffline</code> 的情况下，才能调用 <code>goOnline</code>。</p>"}, {"location": "node-operators/networks/collators/activities/#change-self-bond-amount", "title": "更改自抵押金额", "text": "<p>作为候选人，更改您的自抵押金额会略有不同，具体取决于您是增加还是减少抵押。如果您要增加抵押，这是一个简单的过程，您可以通过 <code>candidateBondMore()</code> 外部函数来增加您的权益。您无需等待任何延迟，也无需安排请求然后执行它；相反，您的请求将立即自动执行。</p> <p>如果您希望减少抵押，则必须安排一个请求，等待退出延迟，然后您将能够执行该请求并将指定数量的代币 वापस 返回到您的自由余额中。换句话说，安排请求不会立即或自动减少抵押；只有在执行请求后才会减少。</p>"}, {"location": "node-operators/networks/collators/activities/#bond-more", "title": "增加保证金", "text": "<p>作为候选人，有两种增加抵押的方法。第一种也是推荐的方法是将要抵押的资金发送到另一个拥有的地址，然后委托给您的整理人。或者，已经抵押了至少最低自抵押金额的整理人可以从 Polkadot.js Apps 增加其保证金。导航到 开发者 选项卡，点击 外部调用，然后按照以下步骤操作：</p> <ol> <li>选择您的整理人帐户（并验证它是否包含要抵押的额外资金）</li> <li>在 提交以下外部调用 菜单下选择 parachainStaking 托盘</li> <li>打开下拉菜单，其中列出了所有与抵押相关的可能的外部调用，然后选择 candidateBondMore 函数</li> <li>在 more: BalanceOf 字段中指定要抵押的额外数额</li> <li>提交交易。按照向导操作，并使用您为帐户设置的密码签署交易</li> </ol> <p></p>"}, {"location": "node-operators/networks/collators/activities/#bond-less", "title": "减少抵押", "text": "<p>作为排序人或排序人候选人，只要在减少抵押后，您的抵押数量多于最低自抵押数量，您就可以减少您的抵押数量。</p> <p>为了减少抵押，您必须首先安排一个请求，等待退出延迟的持续时间，然后执行该请求。只要请求尚未执行，您可以随时取消请求。</p>"}, {"location": "node-operators/networks/collators/activities/#schedule-bond-less", "title": "安排减少绑定请求", "text": "<p>要安排减少绑定的请求，请确保您已点击Developer标签并点击Extrinsics，然后您可以按照以下步骤操作：</p> <ol> <li>选择您的候选人帐户</li> <li>在submit the following extrinsic菜单下选择parachainStaking pallet</li> <li>打开下拉菜单并选择scheduleCandidateBondLess函数</li> <li>在 less: BalanceOf 字段中指定要减少的绑定金额</li> <li>提交交易。按照向导操作，并使用您为帐户设置的密码签署交易</li> </ol> <p></p> <p>交易确认后，您必须等待退出延迟时间，然后才能执行并减少绑定金额。如果您尝试在退出延迟之前执行请求，您的 extrinsic 将会失败，并且您会在 Polkadot.js 中看到 <code>parachainStaking.PendingDelegationRequest</code> 的错误。</p>"}, {"location": "node-operators/networks/collators/activities/#execute-bond-less-request", "title": "执行减少保证金请求", "text": "<p>在安排减少保证金请求的退出延迟时间过后，您可以执行该请求以实际减少保证金金额。前往开发者选项卡，选择Extrinsics，然后按照以下步骤操作：</p> <ol> <li>选择一个帐户来执行请求</li> <li>在提交以下 extrinsic 菜单下选择 parachainStaking pallet</li> <li>选择 executeCandidateBondLess extrinsic</li> <li>选择目标候选人帐户（在提交 <code>scheduleCandidateBondLess</code> 后，退出延迟时间过后，任何人都可以执行该请求）</li> <li>提交交易。按照向导操作，并使用您为帐户设置的密码签署交易</li> </ol> <p></p> <p>交易确认后，您可以从帐户选项卡检查您的可用和保留余额，并注意到现在执行已经完成，您的余额已更新。</p>"}, {"location": "node-operators/networks/collators/activities/#cancel-bond-less-request", "title": "取消减少质押请求", "text": "<p>如果您安排了增加或减少质押的请求，但改变了主意，只要该请求尚未执行，您可以随时取消该请求并保持您的质押金额不变。要取消请求，请前往“开发者”选项卡，选择“Extrinsics”，然后按照以下步骤操作：</p> <ol> <li>选择您的候选人帐户（并验证它是否包含要质押的额外资金）</li> <li>在“submit the following extrinsic”菜单下选择 parachainStaking pallet</li> <li>选择 cancelCandidateBondRequest extrinsic</li> <li>提交交易。按照向导操作，并使用您为帐户设置的密码签署交易</li> </ol> <p></p>"}, {"location": "node-operators/networks/collators/activities/#mark-collator-as-inactive", "title": "将整理人标记为非活跃状态", "text": "<p>如果某个非活跃整理人连续多个轮次未产生区块，您可以将该整理人标记为非活跃状态。一个整理人可以离线的最长轮次数如下：</p> MoonbeamMoonriverMoonbase Alpha <p>1 轮（6 小时）</p> <p>2 轮（4 小时）</p> <p>2 轮（4 小时）</p> <p>要将整理人标记为非活跃状态，您可以使用 <code>notifyInactiveCollator</code> extrinsic，它会在整理人处于非活跃状态时通知运行时，并且默认情况下将整理人标记为离线。为此，您可以前往 Polkadot.js Apps，确保您已连接到正确的网络，然后点击 Developer 选项卡，从下拉菜单中选择 Extrinsics，然后执行以下步骤：</p> <ol> <li>选择您的帐户</li> <li>在 submit the following extrinsic 菜单下选择 parachainStaking pallet</li> <li>选择 notifyInactiveCollator extrinsic</li> <li>指定要标记为非活跃状态的整理人</li> <li>提交交易。按照向导操作，并使用您为帐户设置的密码签署交易</li> </ol> <p></p> <p>该整理人将被暂时从候选池中移除，并且他们可以随时通过调用 <code>goOnline</code> extrinsic 重新加入。</p>"}, {"location": "node-operators/networks/collators/author-mapping/", "title": "与作者映射预编译交互", "text": ""}, {"location": "node-operators/networks/collators/author-mapping/#introduction", "title": "简介", "text": "<p>Moonbeam 上的作者映射预编译合约允许收集人候选人通过熟悉且易于使用的 Solidity 接口将 Session Key 映射到用于支付区块奖励的 Moonbeam 地址。这使候选人可以使用 Ledger 或任何其他与 Moonbeam 兼容的 Ethereum 钱包完成作者映射。但是，建议您在气隙计算机上生成密钥。您可以参考收集人要求页面的帐户要求部分以了解更多信息。</p> <p>要成为收集人候选人，您必须运行一个收集人节点。您还需要加入候选人池，完全同步您的节点，并在生成会话密钥并将其映射到您的帐户之前提交所需的保证金。映射会话密钥时，必须支付额外的保证金。</p> <p>预编译合约位于以下地址：</p> <p>===</p> <pre><code> ```text\n 0x0000000000000000000000000000000000000807\n ```\n</code></pre> <p>===</p> <pre><code> ```text\n 0x0000000000000000000000000000000000000807\n ```\n</code></pre> <p>===</p> <pre><code> ```text\n 0x0000000000000000000000000000000000000807\n ```\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"}, {"location": "node-operators/networks/collators/author-mapping/#the-solidity-interface", "title": "Author Mapping Solidity 接口", "text": "<p><code>AuthorMappingInterface.sol</code> 是一个 Solidity 接口，允许开发者与预编译方法进行交互。</p> <ul> <li>removeKeys() - 移除作者 ID 和会话密钥。替换已弃用的 <code>clearAssociation</code> 外部函数</li> <li>setKeys(bytes memory keys) — 接受调用 <code>author_rotateKeys</code> 的结果，这是您的 Nimbus 和 VRF 密钥的串联公钥，并立即设置作者 ID 和会话密钥。在密钥轮换或迁移后非常有用。调用 <code>setKeys</code> 需要 bond。替换已弃用的 <code>addAssociation</code> 和 <code>updateAssociation</code> 外部函数</li> <li>nimbusIdOf(address who) - 检索给定地址的 Nimbus ID。如果给定地址不存在 Nimbus ID，则返回 <code>0</code></li> <li>addressOf(bytes32 nimbusId) - 检索与给定 Nimbus ID 关联的地址。如果 Nimbus ID 未知，则返回 <code>0</code></li> <li>keysOf(bytes32 nimbusId) - 检索与给定 Nimbus ID 关联的密钥。如果 Nimbus ID 未知，则返回空字节</li> </ul>"}, {"location": "node-operators/networks/collators/author-mapping/#bonds", "title": "必需的保证金", "text": "<p>要学习本教程，您需要加入候选池并将您的会话密钥映射到您的 H160 以太坊风格的帐户。执行这两个操作需要两个保证金。</p> <p>加入候选池的最低保证金设置如下：</p> MoonbeamMoonriverMoonbase Alpha <p>text 500000 GLMR</p> <p>text 500 MOVR</p> <p>text 500 DEV</p> <p>当将会话密钥与您的帐户映射时，会发送一个保证金。此保证金是每个注册的会话密钥的保证金。保证金设置如下：</p> MoonbeamMoonriverMoonbase Alpha <p>text 10000 GLMR</p> <p>text 100 MOVR</p> <p>text 100 DEV</p>"}, {"location": "node-operators/networks/collators/author-mapping/#interact-with-the-solidity-interface", "title": "与Solidity接口互动", "text": ""}, {"location": "node-operators/networks/collators/author-mapping/#checking-prerequisites", "title": "检查先决条件", "text": "<p>以下示例在 Moonbase Alpha 上演示，但是，Moonbeam 和 Moonriver 也可以采取类似的步骤。 你应该：</p> <ul> <li>安装 MetaMask 并连接到 Moonbase Alpha</li> <li>拥有一个包含 DEV 代币的帐户。你应该有足够的代币来支付候选人和映射保证金，以及发送交易并将你的会话密钥映射到你的帐户的 gas 费用。要获得足够的 DEV 代币来遵循本指南，你可以直接通过 Moonbeam Discord 服务器联系管理员</li> <li>确保你正在运行排序人节点并且已完全同步</li> <li>确保你已加入候选人池</li> </ul> <p>如前所述，你可以通过将 Ledger 连接到 MetaMask 来使用它。请参阅 Ledger 指南以将你的 Ledger 导入到 MetaMask。请注意，不建议将 Ledger 用于生产用途。有关更多信息，请参阅排序人要求中的帐户要求。</p>"}, {"location": "node-operators/networks/collators/author-mapping/#generate-session-keys", "title": "生成会话密钥", "text": "<p>To match the Substrate standard, Moonbeam collator's session keys are SR25519. This guide will show you how you can create/rotate your session keys associated with your collator node.</p> <p>First, make sure you're running a collator node. Once you have your collator node running, your terminal should print similar logs:</p> 2025-02-25 20:00:52 [Relaychain] 💤 Idle (6 peers), best: #12706 (0x1d51.3042), finalized #12704 (0xf74b.aa44), 1 0.4kiB/s 1 0.6kiB/s 2025-02-25 20:00:52 💤 Idle (6 peers), best: #5751 (Oxc5alesb5), finalized #5750 (0x9dc..e bad), 1 9.6kiB/s 1 3.5kiB/s 2025-02-25 20:00:53 [Relaychain] ✨ Imported #12707 (0x77ea.4299) 2025-02-25 20:00:57 [Relaychain] 💤 Idle (6 peers), best: #12707 (0x77ea..4299), finalized #12704 (0xf74b..aa44), | 16.4kiB/s 1 12.2kiB/s 2025-02-25 20:00:57 💤 Idle (6 peers), best: #5751 (0xc5a1e8b5), finalized #5750 (0x9fdc...e bad), 1 1.6kiB/s 1 0.4kiB/s 2025-02-25 20:00:59 [Relaychain] ✨ Imported #12708 (0x009f...3bbf) 2025-02-25 20:01:00 ✨ Imported #5753 (0x8981.6c81) 2025-02-25 20:01:00 ✨ Imported #5753 (0x33a...b5e3) 2025-02-25 20:01:02 [Relaychain] 💤 Idle (6 peers), best: #12708 (0x009f...3bbf), finalized #12706 (0x1d51.3042), 1 1.5kiB/s 1 1.3kiB/s 2025-02-25 20:01:02 💤 Idle (6 peers), best: #5752 (0x7036.569e), finalized #5751 (0xc5a1..e8b5), 1 3.3kiB/s 1 5.8kiB/s 2025-02-25 20:01:05 [Relaychain] ✨ Imported #12709 (0x76b9...bf65) 2025-02-25 20:01:07 [Relaychain] 💤 Idle (6 peers), best: #12709 (0x76b9..bf65), finalized #12706 (0x1d51.3042), | 2.0kiB/s | 0.9kiB/s 2025-02-25 20:01:07 💤 Idle (6 peers), best: #5752 (0x7036.569e), finalized #5751 (0xc5a1..e8b5), 1 0 1 0 <p>Next, session keys can be created/rotated by sending an RPC call to the HTTP endpoint with the <code>author_rotateKeys</code> method. When you call <code>author_rotateKeys</code>, the result is the size of two keys. The response will contain a concatenated Nimbus ID and VRF key. The Nimbus ID will be used to sign blocks and the VRF key is required for block production. The concatenated keys will be used to create an association to your H160 account for block rewards to be paid out.</p> <p>For reference, if your collator's HTTP endpoint is at port <code>9944</code>, the JSON-RPC call might look like this:</p> <pre><code>curl http://127.0.0.1:9944 -H \\\n\"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n  }'\n</code></pre> <p>The collator node should respond with the concatenated public keys of your new session keys. The first 64 hexadecimal characters after the <code>0x</code> prefix represent your Nimbus ID and the last 64 hexadecimal characters are the public key of your VRF session key. You'll use the concatenated public keys when mapping your Nimbus ID and setting the session keys in the next section.</p> curl http://127.0.0.1:9933-H\\ \"Content-Type: application/json;charset=utf-8\" -d \\ '{ \"jsonrpc\": \"2.0\", \"id\" :1, \"method\": \"author_rotatekeys\", \"params\": [] }' {\"jsonrpc\": \"2.0\", \"result\":\"0x72c7ca7ef0794103caeb520806576b52cb085f7577cc12cd36c2d64dbf73757a789407ec0f401a8792ac57c4fb7dabd4da6cc74d9ac9b8dd8c4faf770255403f\", \"id\" :1} <p>Make sure you write down the concatenated public keys. Each of your servers, your primary and backup, should have their own unique keys. Since the keys never leave your servers, you can consider them a unique ID for that server.</p> <p>Next, you'll need to register your session keys and map them to an H160 Ethereum-styled address to which the block rewards are paid.</p>"}, {"location": "node-operators/networks/collators/author-mapping/#remix-set-up", "title": "Remix 设置", "text": "<p>首先，获取 <code>AuthorMappingInterface.sol</code> 的副本，并执行以下步骤：</p> <ol> <li>点击 File explorer 选项卡</li> <li>将文件内容复制并粘贴到名为 <code>AuthorMappingInterface.sol</code> 的 Remix 文件中</li> </ol> <p></p>"}, {"location": "node-operators/networks/collators/author-mapping/#compile-the-contract", "title": "编译合约", "text": "<ol> <li>点击编译标签，从上往下数第二个</li> <li>然后编译接口，点击Compile AuthorMappingInterface.sol</li> </ol>"}, {"location": "node-operators/networks/collators/author-mapping/#access-the-contract", "title": "访问合约", "text": "<ol> <li>点击Remix中Compile(编译)选项卡下方的 Deploy and Run(部署和运行) 选项卡。注意：您不是在此处部署合约，而是访问已部署的预编译合约</li> <li>确保在 ENVIRONMENT(环境) 下拉菜单中选择了 Injected Provider - Metamask</li> <li>确保在 CONTRACT(合约) 下拉菜单中选择了 AuthorMappingInterface.sol。由于这是一个预编译合约，因此无需部署，而是需要在 At Address(在地址) 字段中提供预编译的地址</li> <li>提供 Moonbase Alpha 的作者映射预编译的地址：<code>0x0000000000000000000000000000000000000807</code> 并点击 At Address(在地址)</li> </ol> <p>作者映射预编译将出现在 Deployed Contracts(已部署合约)列表中。</p>"}, {"location": "node-operators/networks/collators/author-mapping/#map-session-keys", "title": "映射会话密钥", "text": "<p>下一步是将您的会话密钥映射到您的 H160 帐户（以太坊风格的地址）。请确保您持有此帐户的私钥，因为这是支付区块奖励的地方。</p> <p>要将会话密钥映射到您的帐户，您需要位于候选池中。一旦您成为候选人，您需要发送一个映射 extrinsic。请注意，这将绑定每个已注册作者 ID 的代币。</p> <p>在开始之前，请确保您已连接到要将您的会话密钥映射到的帐户。这将是您收到区块奖励的帐户。</p> <ol> <li>展开 AUTHORMAPPING 合约</li> <li>展开 setKeys 方法</li> <li>输入您的会话密钥</li> <li>单击 transact</li> <li>通过单击 Confirm 确认出现的 MetaMask 交易</li> </ol> <p></p> <p>要验证您是否已成功映射您的会话密钥，您可以使用 author mapping pallet 的 <code>mappingWithDeposit</code> 方法或 <code>nimbusLookup</code> 方法。为此，请参阅 Collator 帐户管理指南的“检查映射”部分。</p>"}, {"location": "node-operators/networks/collators/faq/", "title": "常见问题解答", "text": ""}, {"location": "node-operators/networks/collators/faq/#introduction", "title": "简介", "text": "<p>收集人是平行链不可或缺的一部分。他们接收交易并为中继链验证人创建状态转换证明。</p> <p>运行 Moonbeam 收集人需要 Linux 系统管理技能、仔细的监控以及对细节的关注。以下是一些已积累的技巧和窍门，应能帮助您快速启动并运行。</p>"}, {"location": "node-operators/networks/collators/faq/#_2", "title": "问答", "text": "<p>问：在哪里可以获得帮助？</p> <p>答： 有一个活跃而友好的 Discord 社区，专为整理者而设。加入服务器，即使在您需要帮助之前，也请先自我介绍。向 gilmouta 或 artkaseman 发送私信，让他们知道您是谁，如果他们发现您的节点有任何问题，他们可以与您联系。</p> <p>问：如何随时了解最新信息？</p> <p>答： 所有升级和重要的技术信息都会在 Discord 的 #tech-upgrades-announcements 频道中宣布。加入并关注此频道。如果 Slack 或 Telegram 是您首选的通信渠道，您可以设置集成。</p> <p>问：如何注册我的节点？</p> <p>答： 有一个 问卷，您可以在其中提供您的联系信息以及一些基本的硬件规格。您必须在 Moonbase Alpha 上运行整理者节点才能填写问卷。</p> <p>问：硬件要求是什么？</p> <p>答： 运行整理者需要顶级的硬件，以便能够处理交易并最大化您的奖励。这是区块生产和奖励中一个非常重要的因素。</p> <p>在顶级的裸机机器上运行 systemd 服务（即，运行物理服务器，而不是云 VM 或 docker 容器）。您可以自己运行，也可以选择提供商为您管理服务器。</p> <p>每台裸机机器一次只运行一项服务。不要运行多个实例。</p> <p>问：运行整理者的推荐硬件是什么？</p> <p>答：</p> <p>硬件建议：</p> <ul> <li>顶级 CPU：<ul> <li>Ryzen 9 5950x 或 5900x</li> <li>Intel Xeon E-2386 或 E-2388</li> </ul> </li> <li>位于不同数据中心和国家/地区的主服务器和备份裸机服务器（Hetzner 可以用于其中一个）</li> <li>Moonbeam 的专用服务器，不与其他任何应用程序共享</li> <li>1 TB NVMe SSD</li> <li>32 GB 内存</li> </ul> <p>问：备份节点怎么样？</p> <p>答： 运行两台规格相同的裸机机器，位于不同的国家/地区和服务提供商处。如果您的主服务器出现故障，您可以快速恢复备份服务器上的服务，并继续生产区块并获得奖励。请参阅下面的 故障转移 上的问答。</p> <p>问：不同的网络是什么？</p> <p>答： 有三个网络，每个网络都需要专用的硬件。Moonbase Alpha TestNet 是免费的，应该用于熟悉设置。</p> <ul> <li>Moonbeam - Polkadot 上的生产网络</li> <li>Moonriver - Kusama 上的生产网络</li> <li>Moonbase Alpha TestNet - 开发网络</li> </ul> <p>问：我的防火墙允许哪些端口？</p> <p>答：</p> <ul> <li>允许 TCP 端口 30333 和 30334 上的所有传入请求</li> <li>允许来自您的管理 IP 的 TCP 端口 22 上的请求</li> <li>丢弃所有其他端口</li> </ul> <p>问：是否有 CPU 优化的二进制文件？</p> <p>答： 在每个 发布页面 上都有 CPU 优化的二进制文件。选择适合您的 CPU 架构的二进制文件。</p> <ul> <li>Moonbeam-znver3 - Ryzen 9</li> <li>Moonbeam-skylake - Intel</li> <li>Moonbeam - 通用，可用于所有其他</li> </ul> <p>问：关于监控我的节点的建议是什么？</p> <p>答： 监控对于网络的健康状况和最大化您的奖励非常重要。我们建议使用 Grafana Labs。它们有一个免费层，应该可以处理 6+ 个 moonbeam 服务器。</p> <p>问：我应该监控哪些 KPI？</p> <p>答： 主要的关键绩效指标是生产的区块。此指标的 Prometheus 指标称为 <code>substrate_proposer_block_constructed_count</code>。</p> <p>问：我应该如何设置警报？</p> <p>答： 警报对于保持您的 moonbeam 节点生成区块并获得奖励至关重要。我们推荐 pagerduty.com，它受到 Grafana Labs 的支持。使用上面的 KPI 查询，并在其降至 1 以下时设置警报。警报应全天候呼叫值班人员。</p> <p>问：什么是 Nimbus 密钥？</p> <p>答： Nimbus 密钥就像 Polkadot 中的会话密钥。您应该在主服务器和备份服务器上拥有唯一的密钥。将密钥输出保存在安全的地方，如果您收到警报，可以在半夜访问它。要创建您的密钥，请参阅文档的 会话密钥 部分。</p> <p>问：如果我的主节点发生故障，故障转移过程是什么？</p> <p>答： 当主服务器发生故障时，执行故障转移到备份服务器的最佳方法是执行密钥关联更新。每个服务器都应已有一组唯一的密钥。运行 <code>setKeys</code> 作者映射外部函数。您可以按照 映射外部函数 指令进行操作，并修改指令以使用 <code>setKeys</code> 外部函数。</p> <p>问：我应该设置集中式日志记录吗？</p> <p>答： Grafana Labs 也可以配置为集中式日志记录，并且强烈推荐。您可以在一个地方看到所有节点。Kibana 提供了更强大的集中式日志记录功能，但 Grafana 简单且足以入门。</p> <p>问：我应该在日志中寻找什么？</p> <p>答： 日志对于确定您是否已同步并准备好加入整理者池非常有用。查看日志的末尾以确定是否：</p> <ol> <li>您的中继链已同步</li> <li>您的平行链已同步</li> </ol> <p>当您的节点同步时，您应该在日志中看到空闲。</p> <p></p> <p>一个常见的问题是在您的节点同步之前加入池。您将无法生产任何区块或获得任何奖励。在加入候选池之前，请等待直到您同步并空闲。</p> moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] 🌗 ⚙️ 10 Syncing 137.9 bps, target=#12325010 (8 peers), best: #21001 (0x25d9...57d8), finalized #20992 (0x1ebb..fd23), # 214.4kiB/s 11.7kiB/s moonbase[52847]: 2025-07-10 09:04:26 🌗 ⚙️ * Syncing 182.7 bps, target=#5219905 (8 peers), best: #22472 (0x875f..aed7), finalized #9625 (0x601b...e64f), # 371.0kiB/s 113.3kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] 🌗 ⚙️ I Syncing 186.6 bps, target=#12325011 (8 peers), best: #21935 (0x58f8...d312), finalized #21585 (0x1d73...13c8), #271.9kiB/s T1.3kiB/s moonbase[52847]: 2025-07-10 09:04:26 🌗 ⚙️ @ Syncing 193.4 bps, target=#5219905 (8 peers), best: #23440 (0xdce6...8ea6), finalized #9922 (0x07c9...1fdf), # 383.3kiB/s 17.5kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] 🌗 ⚙️ Ö Syncing 189.5 bps, target=#12325012 (8 peers), best: #22883 (0x6531.2281), finalized #22528 (0x0f21.0855), # 290.8kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 🌗 ⚙️ @ Syncing 206.4 bps, target=#5219905 (8 peers), best: #24474 (0x09dd...6700), finalized #10393 (0x3efc...8a40), #428.7kiB/s 12.4kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] 🌗 ⚙️ . Syncing 171.6 bps, target=#12325013 (8 peers), best: #23744 (0x4ced...cdae), finalized #23552 (0x1773..09d9), # 252.4kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 🌗 ⚙️ Syncing 212.3 bps, target=#5219905 (8 peers), best: #25536 (0x7bc0...e9b7), finalized #10905 (0x5c70...3063), 1427.1kiB/s 11.4kiB/s <p>中继链的同步时间比平行链长得多。在同步中继链之前，您将看不到任何最终确定的区块。</p> <p>问：成为整理者的抵押品是多少？</p> <p>答： 您需要注意两个抵押品。在继续执行这些步骤之前，请确保您的节点已配置并同步。</p> <p>第一个是加入整理者池的抵押品：</p> <ul> <li>Moonbeam - 至少 500000 GLMR</li> <li>Moonriver - 至少 500 MOVR</li> <li>Moonbase Alpha - 至少 500 DEV</li> </ul> <p>第二个是用于密钥关联的抵押品：</p> <ul> <li>Moonbeam - 至少 10000 GLMR</li> <li>Moonriver - 至少 100 MOVR</li> <li>Moonbase Alpha - 至少 100 DEV</li> </ul> <p>问：如何在我的整理者账户上设置身份？</p> <p>答： 在链上设置身份将有助于识别您的节点并吸引委托。您可以按照我们文档的管理身份页面上的说明设置身份。</p>"}, {"location": "node-operators/networks/collators/orbiter/", "title": "Moonbeam 轨道器计划", "text": ""}, {"location": "node-operators/networks/collators/orbiter/#introduction", "title": "介绍", "text": "<p>Moonbeam 基金会宣布对轨道飞行器计划进行有限的试用。与去中心化节点类似，该计划允许收集人参与网络的多样性和安全性，即使他们没有足够的资金或支持以其他方式进入活跃集。该计划是在社区的投入下开发的。</p> <p>Moonbeam 基金会将在活跃集中维护轨道飞行器池，并将分配区块生产的权限给计划中的每个成员，这些成员被称为轨道飞行器。</p> <p>活跃的轨道飞行器将定期轮换，以保持活跃轮次的公平分配。将监控轨道飞行器的性能，并且每轮的支出将根据每个轨道飞行器在该轮产生的区块重定向到每个轨道飞行器。总体奖励将与分配给每个特定整理者账户的所有其他轨道飞行器共享。</p> <p>只要轨道飞行器的性能在其同行的范围内，他们将保持其在轮换中的位置。如果他们低于此阈值，他们将被从池中删除，并降级到 Moonbase Alpha 的等待列表末尾。等待列表中的新轨道飞行器将占用他们的位置。</p>"}, {"location": "node-operators/networks/collators/orbiter/#duration", "title": "持续时间", "text": "<p>随着项目的进展，Moonbeam 基金会将评估结果并进行调整。虽然没有具体的结束日期，但项目可能会结束或发生重大变化。我们鼓励参与者在整个项目过程中提供反馈，并注意项目可能会与此处解释的概念有所不同。</p>"}, {"location": "node-operators/networks/collators/orbiter/#eligibility", "title": "资格", "text": "<p>要参与轨道飞行器计划，您必须符合以下资格标准：</p> <ul> <li>由于该计划的性质，每个轨道飞行器必须通过身份验证检查，并且不能是某些司法管辖区的居民</li> <li>每个轨道飞行器必须发布保证金。发布此保证金是为了防止不良行为，并将受到罚没</li> <li>每个实体（个人或团体）每个网络只能运行一个轨道飞行器（即，Moonriver 上一个，Moonbeam 上一个）</li> <li>轨道飞行器不能在其轨道飞行器所在的同一网络上运行另一个活动的整理人。但是，他们可以在 Moonbeam 上运行一个活跃的整理人，在 Moonriver 上运行一个轨道飞行器，反之亦然，只要他们不同时在同一网络上拥有两者</li> </ul>"}, {"location": "node-operators/networks/collators/orbiter/#communication", "title": "沟通", "text": "<p>将为此程序创建一个私有的 Discord 群组，大部分沟通将通过此频道或通过 DM 进行。填写完申请后，您将被添加到该群组中。</p>"}, {"location": "node-operators/networks/collators/orbiter/#configuration", "title": "Orbiters 和 Orbiter 池配置", "text": "<p>Orbiter 池由 Moonbeam 基金会维护，并将区块生产权限分配给每个 orbiter。每个网络的每个 orbiter 池的 orbiter 最大数量如下：</p> <p>===</p> <pre><code>text\n6 每个池的 orbiters\n</code></pre> <p>===</p> <pre><code>text\n3 每个池的 orbiters\n</code></pre> <p>===</p> <pre><code>text\n8 每个池的 orbiters\n</code></pre> <p>对于 Moonbeam 和 Moonriver，活动集中允许的最大 orbiter 池数量也有限制。对于 Moonbase Alpha，将根据需要设置任意数量的 orbiter 池。最大数量如下：</p> <p>===</p> <pre><code>text\n5 orbiter 池\n</code></pre> <p>===</p> <pre><code>text\n8 orbiter 池\n</code></pre> <p>===</p> <pre><code>text\nUnlimited orbiter 池\n</code></pre> <p>每个 orbiter 将在一定数量的轮次内处于活动状态，然后下一个 orbiter 将接管。每个网络的活动轮次数如下：</p> <p>===</p> <pre><code>text\n1 轮（约 6 小时）\n</code></pre> <p>===</p> <pre><code>text\n3 轮（约 6 小时）\n</code></pre> <p>===</p> <pre><code>text\n3 轮（约 6 小时）\n</code></pre>"}, {"location": "node-operators/networks/collators/orbiter/#application-and-onboarding-process", "title": "应用程序和入职流程", "text": "<p>要加入轨道飞行器计划，您需要首先填写一份申请表，您需要在其中提交联系信息、社交媒体句柄以及整理人和节点详细信息。在表格的末尾，您还需要按照说明完成身份验证。</p> Moonbeam Orbiter Program Application <p>一旦您通过身份验证并被该计划接受，您将收到通知，然后入职流程将开始。新的轨道飞行器必须运行 Moonbase Alpha 节点两周，才有资格运行 Moonriver 节点。然后，轨道飞行器必须运行 Moonriver 节点四周，才有资格运行 Moonbeam 节点。一旦您符合资格，您无需在任何网络上运行轨道飞行器。您可以随时通过取消注册离开其他网络，您将收到您的保证金。要再次加入该网络，您需要重新注册，并且将在队列的末尾。</p> <p>入职流程的概要如下：</p> <ul> <li>通过同步准备您的节点</li> <li>完全同步后，您可以生成会话密钥</li> <li>注册您的会话密钥并发布相关的映射保证金</li> <li>准备就绪后，通过 <code>moonbeamOrbiters.orbiterRegister()</code> extrinsic 注册为轨道飞行器，并发布相关的轨道飞行器保证金</li> <li>轨道飞行器将被放置在每个网络的等待列表中，直到有可用插槽</li> <li>一旦插槽打开，您将开始在相应网络上生成区块并获得奖励</li> </ul>"}, {"location": "node-operators/networks/collators/orbiter/#bond", "title": "债券", "text": ""}, {"location": "node-operators/networks/collators/orbiter/#mapping-bond", "title": "映射保证金", "text": "<p>当您将作者 ID 映射到您的帐户时，会发送一个保证金。此保证金是针对每个注册的作者 ID。保证金设置如下：</p> <p>===</p> <pre><code>text\n10000 GLMR\n</code></pre> <p>===</p> <pre><code>text\n100 MOVR\n</code></pre> <p>===</p> <pre><code>text\n100 DEV\n</code></pre>"}, {"location": "node-operators/networks/collators/orbiter/#orbiter-bond", "title": "Orbiter 保证金", "text": "<p>如前所述，每个轨道器必须提交保证金才能加入该计划。此保证金与活动集合的保证金不同，因为它在绑定时不赚取任何委托奖励。当前的保证金如下：</p> <p>===</p> <pre><code>text\n30000 GLMR\n</code></pre> <p>===</p> <pre><code>text\n400 MOVR\n</code></pre> <p>===</p> <pre><code>text\n100 DEV\n</code></pre>"}, {"location": "node-operators/networks/collators/orbiter/#rewards", "title": "奖励", "text": "<p>轨道器的奖励将在分配到同一轨道器池的其他轨道器之间分配。每个轨道器池的最大轨道器数量在配置部分中描述。以 Moonriver 为例，它是 3，因此奖励大约是验证人奖励的 1/3。系统会跟踪每个轨道器在活动期间生成的区块，并按比例分配奖励。</p>"}, {"location": "node-operators/networks/collators/orbiter/#performance-metrics", "title": "性能指标", "text": "<p>每个轨道器的性能将在一段时间内进行评估，以确定它们是否处于活动状态并生成区块，以及它们的性能是否在所有其他轨道器池整理者的范围内。预计轨道器将运行顶级硬件以保持在该范围内。有关硬件要求的更多信息，请查看整理者要求页面。</p> <p>指标将在七天的时间内进行评估。性能指标如下：</p> <ul> <li>轨道器在最近三个活跃的回合中生成了一个区块</li> <li>轨道器的区块生成量在七天计划平均值的两个标准差范围内</li> <li>轨道器的每区块交易量在七天计划平均值的两个标准差范围内</li> <li>轨道器的区块权重在七天计划平均值的两个标准差范围内</li> </ul> <p>Note</p> <p>这些因素可能会随着计划的进行而发生变化。</p>"}, {"location": "node-operators/networks/collators/orbiter/#leaving-the-program", "title": "离开程序", "text": "<p>轨道器可以离开程序并立即获得退还的抵押金，没有任何延迟。唯一的限制是，如果轨道器当前处于活动状态，则无法离开；一旦它们不再处于活动状态，它们可以随时通过发出 <code>moonbeamOrbiters.orbiterUnregister()</code> extrinsic 来离开。</p>"}, {"location": "node-operators/networks/collators/overview/", "title": "在 Moonbeam 上运行 Collator", "text": ""}, {"location": "node-operators/networks/collators/overview/#introduction", "title": "简介", "text": "<p>收集人是网络中的成员，他们维护其参与的平行链。他们运行一个完整的节点（针对其特定的平行链和中继链），并为中继链验证人生成状态转换证明。</p> <p>在成为收集人候选人之前，需要考虑一些要求，包括机器、绑定、帐户和社区要求。</p> <p>候选人需要绑定（自绑定）最少数量的代币才能被认为符合资格。只有一定数量的按总权益（包括自绑定和委托权益）排名的顶级收集人候选人才能进入活跃的收集人集合。否则，收集人将保留在候选人池中。</p> <p>一旦候选人被选中进入活跃的收集人集合，他们就有资格生成区块。</p> <p>Moonbeam 使用 Nimbus Parachain 共识框架。这提供了一个两步过滤器，用于将候选人分配到活跃的收集人集合，然后将收集人分配到区块生产时隙：</p> <ul> <li>平行链权益质押过滤器根据每个网络中质押的代币数量选择顶级候选人。 对于每个网络的确切顶级候选人数量和最低绑定金额，您可以查看我们文档的最低收集人绑定部分。 这个经过筛选的池称为选定的候选人（也称为活跃集合），它们每轮都会轮换</li> <li>固定大小子集过滤器为每个区块生产时隙选择先前选定的候选人的伪随机子集</li> </ul> <p>用户可以在 Moonbeam、Moonriver 和 Moonbase Alpha 上启动完整节点并激活 <code>collate</code> 功能，以作为收集人候选人参与生态系统。 为此，您可以查看文档的运行节点部分，并使用 Docker 或 Systemd 启动节点。</p>"}, {"location": "node-operators/networks/collators/overview/#join-discord", "title": "加入 Discord", "text": "<p>作为一名收集人，及时了解最新情况和配置变化非常重要。如果您的节点出现任何问题，能够轻松地与我们联系以及我们能够轻松地与您联系也很重要，因为这不仅会对收集人和委托人的奖励产生负面影响，还会对网络产生负面影响。</p> <p>为此，我们使用 Discord。与收集人最相关的 Discord 频道如下：</p> <ul> <li>tech-upgrades-announcements — 我们将在此发布收集人需要遵循的任何更新或配置变更。我们还将在此公布需要监控的任何技术问题，例如网络停滞</li> <li>collators — 这是常规的收集人讨论频道。我们很自豪拥有一个活跃而友好的收集人社区，如果您有任何问题，可以在这里提问。如果出现任何需要他们注意的问题，我们也会在此处 @ 收集人。</li> <li>meet-the-collators — 在此频道中，您可以向潜在的委托人介绍自己</li> </ul> <p>加入 Discord 后，随时可以私信 gilmouta 或 artkaseman 并介绍自己。这将帮助团队确定在您的节点出现问题时应联系的人员，并可以分配相关的 Discord 收集人角色，允许您在 meet-the-collators 中发帖。</p>"}, {"location": "node-operators/networks/collators/requirements/", "title": "Collator 要求", "text": ""}, {"location": "node-operators/networks/collators/requirements/#introduction", "title": "简介", "text": "<p>在深入运行验证人节点之前，需要记住一些要求。首先，您需要遵守社区准则并满足技术要求。您应该拥有顶级的硬件，安全创建和存储的帐户，满足绑定要求，并填写验证人问卷。</p> <p>建议在 Moonbase Alpha TestNet 上完成所有必要的要求，然后再在像 Moonbeam 或 Moonriver 这样的生产网络上进行整理。</p> <p>本指南将帮助您开始满足验证人的要求，以便您可以立即启动并运行您的节点。</p>"}, {"location": "node-operators/networks/collators/requirements/#community-guidelines", "title": "社区准则", "text": "<p>收集人有责任以诚实的方式为网络服务。如果发生以下任何禁止的违规行为，可能会通过链上治理采取行动：</p> <ul> <li>任何实体在任何一个网络中运行超过四个收集人</li> <li>收集人使用相同的 Nimbus 密钥运行多个节点，导致含糊不清。含糊不清是指在同一区块高度提交多个区块的行为，这会导致网络分叉。由于它意味着网络降级，因此严格禁止这样做。恶意行为者（试图获得更多包含/生成的区块）或错误（运行具有相同密钥的备份节点）可能会执行此操作。每个节点都需要有自己唯一的密钥，并且任何备份解决方案都需要确保不可能出现含糊不清的情况</li> <li>收集人的行为不光彩，对社区或其他收集人不友好</li> </ul> <p>有必要对社区和网络做出一定程度的承诺，以赢得委托人社区的信任并吸引更多的委托。以下是一些为社区做贡献的建议：</p> <ul> <li>积极参与社区<ul> <li>加入 Discord 并进行自我介绍，根据需要提供更新，并帮助支持社区成员或其他收集人</li> </ul> </li> <li>创建教程和教育内容</li> <li>成为 Moonbeam 大使</li> <li>贡献与生态系统相关的开源软件</li> <li>积极参与治理并对提案进行投票</li> </ul>"}, {"location": "node-operators/networks/collators/requirements/#hardware-requirements", "title": "硬件要求", "text": "<p>整理人必须运行具有整理选项的完整节点。为此，请按照运行节点教程和使用 Systemd的安装步骤进行操作。确保您使用整理人的特定代码片段。</p> <p>Note</p> <p>运行 整理人 节点的 CPU 要求高于上述教程中提供的要求。为了使您的整理人节点能够跟上高交易吞吐量，具有高时钟速度和单核性能的 CPU 非常重要，因为区块生产/导入过程几乎完全是单线程的。 也不建议在 Docker 中运行您的整理人节点，因为它会对性能产生重大影响。</p> <p>从硬件角度来看，拥有顶级的硬件对于最大限度地提高区块生产和奖励非常重要。以下是一些表现良好并提供最佳结果的硬件建议：</p> <ul> <li>推荐 CPU - Intel Xeon E-2386/2388 或 Ryzen 9 5950x/5900x</li> <li>推荐 NVMe - 1 TB NVMe</li> <li>推荐 RAM - 32 GB RAM</li> </ul> <p>此外，您还应考虑以下事项：</p> <ul> <li>由于大多数云提供商都专注于多线程而不是单线程性能，因此建议使用裸机提供商</li> <li>您应该在不同的数据中心和国家/地区拥有主备裸机服务器。Hetzner 适用于其中一台服务器，但不应用于两台服务器</li> <li>您的 Moonbeam 服务器应仅专用于 Moonbeam，请勿将同一服务器用于其他应用</li> </ul>"}, {"location": "node-operators/networks/collators/requirements/#account-requirements", "title": "账户要求", "text": "<p>与 Polkadot 验证人类似，您需要创建一个账户。对于 Moonbeam 来说，这是一个 H160 账户或一个以太坊风格的账户，您需要持有该账户的私钥。作为收集人，您有责任正确管理您自己的密钥。不正确的操作可能会导致资金损失。</p> <p>虽然可以使用许多以太坊钱包，但为了生产目的，建议尽可能安全地生成密钥。还建议生成备份密钥。您实际上可以使用 Moonbeam 二进制文件通过一个名为 Moonkey 的工具来生成密钥。它可用于生成以太坊风格的账户和 Substrate 风格的账户。</p> <p>为了安全地生成密钥，建议在与外界隔离的机器上进行。生成密钥后，请务必安全地存储它们。为了安全地存储您的密钥，以下是一些建议，从最不安全到最安全：</p> <ul> <li>写下您的密钥并进行塑封</li> <li>将您的密钥刻在金属板上</li> <li>使用像 Horcrux 这样的工具来分片您的密钥</li> </ul> <p>与往常一样，建议您自己进行研究并使用您认为是值得信赖的工具。</p>"}, {"location": "node-operators/networks/collators/requirements/#getting-started-with-moonkey", "title": "Moonkey 入门", "text": "<p>第一步是获取 GitHub 上托管的 moonkey 二进制文件。为此，您可以下载一个二进制文件（已在 Linux/Ubuntu 上测试）：</p> <p><code>https://github.com/moonbeam-foundation/moonbeam/releases/download/v0.8.0/moonkey</code></p> <p>下载该工具后，请确保您具有执行二进制文件的正确访问权限。接下来，通过检查下载文件的哈希值来检查您是否拥有正确的版本。</p> <p>对于基于 Linux 的系统（如 Ubuntu），打开终端并转到 moonkey 二进制文件所在的文件夹。到达那里后，您可以使用 sha256sum 工具来计算 SHA256 哈希值：</p> <p>text 019c3de832ded3fccffae950835bb455482fca92714448cc0086a7c5f3d48d3e</p> <p>验证哈希后，建议将二进制文件移动到气隙机器（无网络接口）。您也可以直接在气隙设备中检查文件的哈希值。</p>"}, {"location": "node-operators/networks/collators/requirements/#generating-an-account-with-moonkey", "title": "使用 Moonkey 生成账户", "text": "<p>使用 moonkey 二进制文件非常简单。每次执行该二进制文件时，都会显示与新创建的帐户相关的信息。</p> <p>此信息包括：</p> <ul> <li>助记词种子 - 一个 24 字的助记词，用可读的文字表示您的帐户。这可以直接访问您的资金，因此您需要安全地存储这些词</li> <li>私钥 - 与您的帐户关联的私钥，用于签名。它从助记词种子派生而来。这可以直接访问您的资金，因此您需要安全地存储它</li> <li>公共地址 - 您帐户的地址</li> <li>派生路径 - 告诉分层确定性 (HD) 钱包如何派生特定密钥</li> </ul> <p>Note</p> <p>请安全地存储私钥/助记词，不要与任何人分享。私钥/助记词可以直接访问您的资金。</p> <p>建议您在气隙计算机中使用该二进制文件。</p>"}, {"location": "node-operators/networks/collators/requirements/#other-moonkey-features", "title": "其他 Moonkey 功能", "text": "<p>Moonkey 提供了一些额外的功能。可以提供以下标志：</p> <ul> <li><code>-help</code> – 打印帮助信息</li> <li><code>-version</code> – 打印您正在运行的 moonkey 的版本</li> <li><code>-w12</code> – 生成一个 12 个单词的助记词种子（默认为 24 个）</li> </ul> <p>以下选项可用：</p> <ul> <li><code>-account-index</code> – 提供作为输入以在派生路径中使用的帐户索引</li> <li><code>-mnemonic</code> – 提供作为输入的助记词</li> </ul>"}, {"location": "node-operators/networks/collators/requirements/#bonding-requirements", "title": "保证金要求", "text": "<p>您需要注意两种保证金：一种是加入整理人池的保证金，另一种是用于密钥关联的保证金。</p>"}, {"location": "node-operators/networks/collators/requirements/#minimum-collator-bond", "title": "最小验证人抵押", "text": "<p>首先，您需要抵押（自抵押）至少一定数量的代币，才能被认为符合资格并成为候选人。只有总抵押量（包括自抵押和委托抵押）排名前列的一定数量的验证人候选人才能进入活跃验证人集合。</p> MoonbeamMoonriverMoonbase Alpha Variable Value Minimum self-bond amount 500000 GLMR Active set size 66 collators Variable Value Minimum self-bond amount 500 MOVR Active set size 72 collators Variable Value Minimum self-bond amount 500 DEV Active set size 7 collators"}, {"location": "node-operators/networks/collators/requirements/#key-association-bond", "title": "密钥关联保证金", "text": "<p>其次，您需要一个用于密钥关联的保证金。当将您的作者 ID 映射（会话密钥）到您的帐户以获取区块奖励时，需要此保证金，并且每个注册的作者 ID 都需要。</p> MoonbeamMoonriverMoonbase Alpha 变量 值 最低保证金 10000 GLMR 变量 值 最低保证金 100 MOVR 变量 值 最低保证金 100 DEV"}, {"location": "node-operators/networks/collators/requirements/#collator-questionnaire", "title": "收集人问卷调查表", "text": "<p>这里有一份收集人调查问卷，旨在评估 Moonbase Alpha 上所有收集人的状态。在填写此表格之前，您应该在 Moonbase Alpha 上运行一个收集人节点。您将能够提供您的联系方式以及一些基本的硬件规格。如果您的节点出现任何问题，这提供了一种在您和 Moonbeam 团队之间开通沟通渠道的方式。</p>"}, {"location": "node-operators/networks/run-a-node/compile-binary/", "title": "手动编译 Moonbeam 二进制文件", "text": ""}, {"location": "node-operators/networks/run-a-node/compile-binary/#_1", "title": "简介", "text": "<p>在基于 Moonbeam 的网络上运行完整节点，您可以连接到网络、与引导节点同步、获得对 RPC 端点的本地访问权限、在平行链上创建区块等等。</p> <p>本指南适用于具有编译 Substrate 区块链节点经验的人员。平行链节点类似于典型的 Substrate 节点，但存在一些差异。Substrate 平行链节点将是一个更大的构建，因为它包含运行平行链本身的代码，以及同步中继链和促进两者之间通信的代码。此构建非常大，可能需要 30 分钟以上，并且至少需要 32 GB 的内存。</p> <p>要快速入门而无需自己编译二进制文件，可以使用发布二进制文件。</p>"}, {"location": "node-operators/networks/run-a-node/compile-binary/#compile-the-binary", "title": "编译二进制文件", "text": "<p>手动编译二进制文件可能需要大约 30 分钟，并需要 32GB 的内存。</p> <p>以下命令将构建 Moonbeam 平行链的最新版本。</p> <ol> <li> <p>克隆 Moonbeam 存储库。</p> <pre><code>git clone https://github.com/moonbeam-foundation/moonbeam\ncd moonbeam\n</code></pre> </li> <li> <p>检查最新版本。</p> <pre><code>git checkout tags/$(git describe --tags)\n</code></pre> </li> <li> <p>如果您已经安装了 Rust，请跳过接下来的两个步骤。否则，通过 Rust 推荐的方法 安装 Rust 及其先决条件。</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> </li> <li> <p>更新您的 <code>PATH</code> 环境变量。</p> <pre><code>source $HOME/.cargo/env\n</code></pre> </li> <li> <p>构建平行链二进制文件。</p> <p>Note</p> <p>如果您使用的是 Ubuntu 20.04 或 22.04，则需要在构建二进制文件之前安装这些额外的依赖项：</p> <pre><code>apt install clang protobuf-compiler libprotobuf-dev pkg-config libssl-dev -y \n</code></pre> <pre><code>cargo build --release\n</code></pre> </li> </ol> <p></p> <p>如果在终端中出现 cargo not found error 错误，请手动将 Rust 添加到您的系统路径或重新启动您的系统：</p> <pre><code>source $HOME/.cargo/env\n</code></pre> <p>现在，您可以使用 Moonbeam 二进制文件来运行 Systemd 服务。要设置和运行该服务，请参阅使用 Systemd 在 Moonbeam 上运行节点指南。</p>"}, {"location": "node-operators/networks/run-a-node/docker/", "title": "使用 Docker 在 Moonbeam 上运行节点", "text": ""}, {"location": "node-operators/networks/run-a-node/docker/#introduction", "title": "简介", "text": "<p>在基于 Moonbeam 的网络上运行完整节点，您可以连接到网络、与引导节点同步、获得对 RPC 端点的本地访问权限、在平行链上创建区块等等。</p> <p>在本指南中，您将学习如何使用 Docker 快速启动 Moonbeam 节点，以及如何维护和清除您的节点。</p>"}, {"location": "node-operators/networks/run-a-node/docker/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要开始，您需要：</p> <ul> <li>安装 Docker。在撰写本文时，使用的 Docker 版本为 24.0.6</li> <li>确保您的系统满足要求。当连接到 Kusama 上的 Moonriver 或 Polkadot 上的 Moonbeam 时，完全同步嵌入式中继链需要几天时间</li> </ul>"}, {"location": "node-operators/networks/run-a-node/docker/#storage-chain-data", "title": "设置链数据的存储", "text": "<p>要设置用于存储链数据的目录，您需要：</p> <ol> <li> <p>创建一个本地目录</p> MoonbeamMoonriverMoonbase Alpha <p>bash mkdir /var/lib/moonbeam-data</p> <p>bash mkdir /var/lib/moonriver-data</p> <p>bash mkdir /var/lib/alphanet-data</p> </li> <li> <p>设置存储链数据的本地目录的所有权和权限。您可以为特定用户或当前用户设置权限（将 <code>INSERT_DOCKER_USER</code> 替换为将运行 <code>docker</code> 命令的实际用户）</p> MoonbeamMoonriverMoonbase Alpha <p>bash</p> <p>bash</p> <p>bash</p> </li> </ol>"}, {"location": "node-operators/networks/run-a-node/docker/#chown", "title": "chown 到特定用户", "text": "<p>chown INSERT_DOCKER_USER /var/lib/moonbeam-data</p>"}, {"location": "node-operators/networks/run-a-node/docker/#chown_1", "title": "chown 到当前用户", "text": "<p>sudo chown -R $(id -u):$(id -g) /var/lib/moonbeam-data</p>"}, {"location": "node-operators/networks/run-a-node/docker/#chown_2", "title": "chown 到特定用户", "text": "<p>chown INSERT_DOCKER_USER /var/lib/moonriver-data</p>"}, {"location": "node-operators/networks/run-a-node/docker/#chown_3", "title": "chown 到当前用户", "text": "<p>sudo chown -R $(id -u):$(id -g) /var/lib/moonriver-data</p>"}, {"location": "node-operators/networks/run-a-node/docker/#chown_4", "title": "chown 到特定用户", "text": "<p>chown INSERT_DOCKER_USER /var/lib/alphanet-data</p>"}, {"location": "node-operators/networks/run-a-node/docker/#chown_5", "title": "chown 到当前用户", "text": "<p>sudo chown -R $(id -u):$(id -g) /var/lib/alphanet-data</p>"}, {"location": "node-operators/networks/run-a-node/docker/#start-up-commands", "title": "启动命令", "text": "<p>要启动您的节点，您需要执行 <code>docker run</code> 命令。如果您正在设置一个整理人节点，请确保按照整理人的代码片段进行操作。</p> <p>请注意，在以下启动命令中，您必须：</p> <ul> <li>将 <code>INSERT_YOUR_NODE_NAME</code> 替换为您选择的节点名称。您需要在两个地方执行此操作：一个用于平行链，一个用于中继链</li> <li>将 <code>INSERT_RAM_IN_MB</code> 替换为您服务器实际 RAM 的 50%。例如，对于 32GB 的 RAM，该值必须设置为 <code>16000</code>。最小值是 <code>2000</code>，但它低于推荐的规格</li> </ul> <p>有关以下启动命令中使用的标志以及其他常用标志的概述，请参阅我们文档的标志页面。</p> <p>对于 Apple Silicon 用户</p> <p>如果 Docker 命令在 Apple Silicon 上失败或行为异常，请在 Docker Desktop 设置中启用 Use Rosetta for x86_64/amd64 emulation on Apple Silicon，并对 pull 和 run 命令使用 <code>amd64</code> 平台。 例如：</p> <p>bash docker pull --platform=linux/amd64 moonbeamfoundation/moonbeam:v0.49.2</p> <p>bash docker run --platform=linux/amd64 ...</p>"}, {"location": "node-operators/networks/run-a-node/docker/#full-node", "title": "完整节点", "text": "Linux 代码片段 MoonbeamMoonriverMoonbase Alpha <p>bash docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain moonbeam \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --state-pruning archive \\ --trie-cache-size 1073741824 \\ --db-cache INSERT_RAM_IN_MB \\ --pool-type=fork-aware \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p> <p>bash docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain moonriver \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --state-pruning archive \\ --trie-cache-size 1073741824 \\ --db-cache INSERT_RAM_IN_MB \\ --pool-type=fork-aware \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p> <p>bash docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain alphanet \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --state-pruning archive \\ --trie-cache-size 1073741824 \\ --db-cache INSERT_RAM_IN_MB \\ --pool-type=fork-aware \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p> MacOS 代码片段 MoonbeamMoonriverMoonbase Alpha <p>bash docker run -p 9944:9944 -v \"/var/lib/moonbeam-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain moonbeam \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --state-pruning archive \\ --trie-cache-size 1073741824 \\ --pool-type=fork-aware \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p> <p>bash docker run -p 9944:9944 -v \"/var/lib/moonriver-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain moonriver \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --state-pruning archive \\ --trie-cache-size 1073741824 \\ --pool-type=fork-aware \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p> <p>bash docker run -p 9944:9944 -v \"/var/lib/alphanet-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain alphanet \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --state-pruning archive \\ --trie-cache-size 1073741824 \\ --pool-type=fork-aware \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p>"}, {"location": "node-operators/networks/run-a-node/docker/#allow-external-access", "title": "Allow External Access to Your Node", "text": "<p>If you want to run an RPC endpoint, connect to Polkadot.js Apps, or run your own application, you can use the <code>--unsafe-rpc-external</code> flag to run the full node with external access to the RPC ports.</p> Moonbeam 的启动命令示例 LinuxMacOS <p>bash hl_lines=\"11\" docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain moonbeam \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --state-pruning archive \\ --trie-cache-size 1073741824 \\ --db-cache INSERT_RAM_IN_MB \\ --pool-type=fork-aware \\ --unsafe-rpc-external \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p> <p>bash hl_lines=\"10\" docker run -p 9944:9944 -v \"/var/lib/moonbeam-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain moonbeam \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --state-pruning archive \\ --trie-cache-size 1073741824 \\ --pool-type=fork-aware \\ --unsafe-rpc-external \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p>"}, {"location": "node-operators/networks/run-a-node/docker/#use-sql", "title": "Use a SQL Backend for Frontier", "text": "<p>The default Frontier database, which comes standard with Moonbeam nodes and contains all of the Ethereum-related elements, such as transactions, blocks, and logs, can be modified to use a SQL backend. Since <code>eth_getLogs</code> is a very resource-intensive method, the SQL backend aims to provide a more performant alternative for indexing and querying Ethereum logs in comparison to the default RocksDB database.</p> <p>To spin up a node with a Frontier SQL backend, you'll need to add the <code>--frontier-backend-type sql</code> flag to your start-up command.</p> <p>There are additional flags you can use to configure the pool size, query timeouts, and more for your SQL backend; please refer to the Flags page for more information.</p> Moonbeam 的启动命令示例 LinuxMacOS <p>bash hl_lines=\"12\" docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain moonbeam \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --state-pruning archive \\ --trie-cache-size 1073741824 \\</p> <p>bash hl_lines=\"10\" docker run -p 9944:9944 -v \"/var/lib/moonbeam-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain moonbeam \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --state-pruning archive \\ --trie-cache-size 1073741824 \\ --pool-type=fork-aware \\ --frontier-backend-type sql \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p>"}, {"location": "node-operators/networks/run-a-node/docker/#this-is-a-comment", "title": "This is a comment", "text": "<p>--db-cache INSERT_RAM_IN_MB \\ --pool-type=fork-aware \\ --frontier-backend-type sql \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p>"}, {"location": "node-operators/networks/run-a-node/docker/#collator", "title": "Collator 节点", "text": "<p>从 v0.39.0 开始，新的 Moonbeam collator 节点将不再在启动时自动生成会话密钥。v0.39.0 之前的节点不需要更改他们处理会话密钥的方式。</p> <p>设置新节点时，运行以下命令以生成会话密钥并将其存储在磁盘上，这些会话密钥将在启动命令中引用：</p> MoonbeamMoonriverMoonbase Alpha <p>bash</p> <p>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\  moonbeamfoundation/moonbeam:v0.49.2 key generate-node-key --base-path /var/lib/moonbeam-data --chain moonbeam </p> <p>bash</p> <p>docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\  moonbeamfoundation/moonbeam:v0.49.2 key generate-node-key --base-path /var/lib/moonriver-data --chain moonriver </p> <p>bash</p> <p>docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\  moonbeamfoundation/moonbeam:v0.49.2 key generate-node-key --base-path /var/lib/alphanet-data --chain alphanet &amp;&amp; sudo chown -R moonbase_service  /var/lib/alphanet-data</p> <p>Note</p> <p>您需要将新创建的文件夹的所有权更改为 Docker 的特定用户或当前用户。可以使用启动命令中的 <code>--unsafe-force-node-key-generation</code> 参数绕过节点密钥生成步骤，尽管这不是推荐的做法。</p> <p>现在您可以运行您的 Docker 启动命令了：</p> Linux snippets MoonbeamMoonriverMoonbase Alpha <p>bash docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain moonbeam \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --collator \\ --trie-cache-size 1073741824 \\ --db-cache INSERT_RAM_IN_MB \\ --pool-type=fork-aware \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p> <p>bash docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain moonriver \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --collator \\ --trie-cache-size 1073741824 \\ --db-cache INSERT_RAM_IN_MB \\ --pool-type=fork-aware \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p> <p>bash docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain alphanet \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --collator \\ --trie-cache-size 1073741824 \\ --db-cache INSERT_RAM_IN_MB \\ --pool-type=fork-aware \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p> MacOS snippets MoonbeamMoonriverMoonbase Alpha <p>bash docker run -p 9944:9944 -v \"/var/lib/moonbeam-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain moonbeam \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --collator \\ --trie-cache-size 1073741824 \\ --pool-type=fork-aware \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p> <p>bash docker run -p 9944:9944 -v \"/var/lib/moonriver-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain moonriver \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --collator \\ --trie-cache-size 1073741824 \\ --pool-type=fork-aware \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p> <p>bash docker run -p 9944:9944 -v \"/var/lib/alphanet-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --base-path /data \\ --chain alphanet \\ --name \"INSERT_YOUR_NODE_NAME\" \\ --collator \\ --trie-cache-size 1073741824 \\ --pool-type=fork-aware \\ -- \\ --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\ --sync fast</p>"}, {"location": "node-operators/networks/run-a-node/docker/#syncing-your-node", "title": "同步您的节点", "text": "<p>一旦 Docker 拉取了必要的镜像，您的完整节点将启动，显示大量信息，例如链规格、节点名称、角色、创世状态等等。</p> docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" -u $(id -u ${USER}):$(id -g ${USER}) moonbeam-foundation/moonbeam:v0.49.2 --base-path=/data --chain alphanet --name=\"TestNode\" --state-pruning archive --trie-cache-size 1073741824 --db-cache 8000 --name=\"TestNode (Embedded Relay)\" 2025-07-10 09:04:26 Moonbeam Parachain Collator  2025-07-10 09:04:26 ✌️  version 0.49.2  2025-07-10 09:04:26 ❤️  by PureStake, 2019-2025  2025-07-10 09:04:26 📋 Chain specification: Moonbase Development Testnet  2025-07-10 09:04:26 🏷  Node name: TestNode  2025-07-10 09:04:26 👤 Role: FULL  2025-07-10 09:04:26 💾 Database: RocksDb at /data/chains/moonbase_alpha/db/full  2025-07-10 09:04:26 Database: RocksDb at  2025-07-10 09:04:26 &amp; Native runtime: moonbase-3501 (moonbase-0.tx2.au4) 2025-07-10 09:04:26 Parachain id: Id(1000) 2025-07-10 09:04:26 Parachain Account: 5Ec4AhPZk8STuex8Wsi9TwDtJQxKqzPJRCH7348Xtcs9vZLJ 2025-07-10 09:04:26 Parachain genesis state: 0x0000000000000000000000000000000000000000000000000000000000000000006505bc9a20d69f14620b2417b6d777c398ceb3e32119b9a53507111d1880927c03170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131400 2025-07-10 09:04:26 Is collating: no 2025-07-10 09:04:26 [ 1 ^ Initializing Genesis block/state (state: 0xb505..927c, header-hash: 0x91bc...9527) 2025-07-10 09:04:26 ［Relaychain］ ^ Initializing Genesis block/state (state: 0x96a6..9426, header-hash: 0xelea..9443) <p>在同步过程中，您将看到来自嵌入式中继链 ([Relaychain]) 和平行链 ([🌗]) 的日志。这些日志显示了一个目标区块（实时网络状态）和一个最佳区块（本地节点同步状态）。</p> moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] 🌗 ⚙️ 10 Syncing 137.9 bps, target=#12325010 (8 peers), best: #21001 (0x25d9...57d8), finalized #20992 (0x1ebb..fd23), # 214.4kiB/s 11.7kiB/s moonbase[52847]: 2025-07-10 09:04:26 🌗 ⚙️ * Syncing 182.7 bps, target=#5219905 (8 peers), best: #22472 (0x875f..aed7), finalized #9625 (0x601b...e64f), # 371.0kiB/s 113.3kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] 🌗 ⚙️ I Syncing 186.6 bps, target=#12325011 (8 peers), best: #21935 (0x58f8...d312), finalized #21585 (0x1d73...13c8), #271.9kiB/s T1.3kiB/s moonbase[52847]: 2025-07-10 09:04:26 🌗 ⚙️ @ Syncing 193.4 bps, target=#5219905 (8 peers), best: #23440 (0xdce6...8ea6), finalized #9922 (0x07c9...1fdf), # 383.3kiB/s 17.5kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] 🌗 ⚙️ Ö Syncing 189.5 bps, target=#12325012 (8 peers), best: #22883 (0x6531.2281), finalized #22528 (0x0f21.0855), # 290.8kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 🌗 ⚙️ @ Syncing 206.4 bps, target=#5219905 (8 peers), best: #24474 (0x09dd...6700), finalized #10393 (0x3efc...8a40), #428.7kiB/s 12.4kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] 🌗 ⚙️ . Syncing 171.6 bps, target=#12325013 (8 peers), best: #23744 (0x4ced...cdae), finalized #23552 (0x1773..09d9), # 252.4kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 🌗 ⚙️ Syncing 212.3 bps, target=#5219905 (8 peers), best: #25536 (0x7bc0...e9b7), finalized #10905 (0x5c70...3063), 1427.1kiB/s 11.4kiB/s <p>如果您按照 Moonbase Alpha 的安装说明进行操作，一旦同步完成，您将在本地运行一个 Moonbase Alpha TestNet 节点！对于 Moonbeam 或 Moonriver，一旦同步，您将连接到对等节点，并看到网络上正在生成的区块！</p> <p>Note</p> <p>完全同步嵌入式中继链可能需要几天时间。请确保您的系统满足要求。</p>"}, {"location": "node-operators/networks/run-a-node/docker/#maintain-your-node", "title": "维护您的节点", "text": "<p>随着 Moonbeam 开发的不断进行，有时需要升级您的节点软件。当有可用升级时，节点运营商会在我们的 Discord 频道 上收到通知，并得知这些升级是否是必要的（有些客户端升级是可选的）。升级过程非常简单，对于完整节点或整理者节点都是一样的。</p> <ol> <li> <p>停止 Docker 容器：</p> <pre><code>sudo docker stop INSERT_CONTAINER_ID\n</code></pre> </li> <li> <p>通过 Moonbeam GitHub 版本 页面获取最新版本的 Moonbeam</p> </li> <li>使用最新版本来启动您的节点。为此，请在启动命令中替换为最新版本并运行它</li> </ol> <p>一旦您的节点再次运行，您应该会在终端中看到日志。</p>"}, {"location": "node-operators/networks/run-a-node/docker/#purge-your-node", "title": "清理你的节点", "text": "<p>如果您需要一个全新的 Moonbeam 节点实例，您可以通过删除关联的数据目录来清理您的节点。</p> <p>您首先需要停止 Docker 容器：</p> <p>bash   sudo docker stop INSERT_CONTAINER_ID</p> <p>如果您在启动节点时未使用 <code>-v</code> 标志来指定用于存储链数据的本地目录，则数据文件夹与 Docker 容器本身相关。因此，删除 Docker 容器将删除链数据。</p> <p>如果您确实使用 <code>-v</code> 标志启动了节点，您将需要清理指定的目录。例如，对于建议的数据目录，您可以运行以下命令来清理您的平行链和中继链数据：</p> <p>===</p> <pre><code>bash\nsudo rm -rf /var/lib/moonbeam-data/*\n</code></pre> <p>===</p> <pre><code>bash\nsudo rm -rf /var/lib/moonriver-data/*\n</code></pre> <p>===</p> <pre><code>bash\nsudo rm -rf /var/lib/alphanet-data/*\n</code></pre> <p>要仅删除特定链的平行链数据，您可以运行：</p> <p>===</p> <pre><code>bash\nsudo rm -rf /var/lib/moonbeam-data/chains/*\n</code></pre> <p>===</p> <pre><code>bash\nsudo rm -rf /var/lib/moonriver-data/chains/*\n</code></pre> <p>===</p> <pre><code>bash\nsudo rm -rf /var/lib/alphanet-data/chains/*\n</code></pre> <p>类似地，要仅删除中继链数据，您可以运行：</p> <p>===</p> <pre><code>bash\nsudo rm -rf /var/lib/moonbeam-data/polkadot/*\n</code></pre> <p>===</p> <pre><code>bash\nsudo rm -rf /var/lib/moonriver-data/polkadot/*\n</code></pre> <p>===</p> <pre><code>bash\nsudo rm -rf /var/lib/alphanet-data/polkadot/*\n</code></pre> <p>Now that your chain data has been purged, you can start a new node with a fresh data directory. You can install the newest version by repeating the instructions in this guide. Make sure you are using the latest tag available, which you can find on the Moonbeam GitHub Release page.</p> <p>Note</p> <p>On an as-needed basis, Moonbase Alpha might be purged and reset. In these instances, you will need to purge both the parachain data and the relay chain data. If a purge is required, node operators will be notified in advance (via our Discord channel).</p>"}, {"location": "node-operators/networks/run-a-node/flags/", "title": "在 Moonbeam 上运行节点时有用的标志", "text": ""}, {"location": "node-operators/networks/run-a-node/flags/#introduction", "title": "简介", "text": "<p>在启动您自己的 Moonbeam 节点时，可以使用一些必需的和可选的标志。本指南将介绍一些最常见的标志，并向您展示如何访问所有可用的标志。</p>"}, {"location": "node-operators/networks/run-a-node/flags/#common-flags", "title": "常用标志", "text": "<ul> <li><code>--collator</code>: 启用整理人候选人的整理人模式，如果符合条件，允许节点积极参与区块生产。</li> <li><code>--port</code>: 指定对等协议 TCP 端口。平行链的默认端口是 <code>30333</code>，嵌入式中继链的默认端口是 <code>30334</code>。</li> <li><code>--rpc-port</code>: 设置 HTTP 和 WS 连接的统一端口。平行链的默认端口是 <code>9944</code>，嵌入式中继链的默认端口是 <code>9945</code>。</li> <li><code>--ws-port</code>: 自 client v0.33.0 起已弃用，请改用 <code>--rpc-port</code> 进行 HTTP 和 WS 连接 - 设置 HTTP 和 WS 连接的统一端口。平行链的默认端口是 <code>9944</code>，嵌入式中继链的默认端口是 <code>9945</code>。</li> <li><code>--rpc-max-connections</code>: 指定 HTTP 和 WS 服务器连接的最大数量。默认为 100。</li> <li><code>--rpc-external</code> — 监听所有接口以进行 JSON-RPC（HTTP 和 WS）。使用代理来过滤公共端点上的不安全方法。如果您接受风险，请使用 <code>--unsafe-rpc-external</code> 来禁止安全警告。</li> <li><code>--rpc-methods</code> — 要公开哪些 RPC 方法。选项：<code>auto</code> （默认）、<code>safe</code>、<code>unsafe</code>。</li> <li><code>--rpc-cors</code> — 逗号分隔的允许的浏览器来源 (<code>protocol://domain</code>) 或 <code>all</code> 以禁用验证。在 <code>--dev</code> 中，默认允许所有来源。</li> <li><code>--rpc-rate-limit &lt;calls/min&gt;</code> — 每个连接的速率限制。默认禁用。</li> <li><code>--rpc-rate-limit-whitelisted-ips &lt;CIDR&gt;...</code> — 免于限制的 CIDR 范围。</li> <li><code>--rpc-rate-limit-trust-proxy-headers</code> — 当位于反向代理后面时，信任 <code>X-Forwarded-For</code> / <code>X-Real-IP</code>。</li> <li><code>--rpc-max-request-size &lt;MB&gt;</code> / <code>--rpc-max-response-size &lt;MB&gt;</code> — 最大有效负载大小（默认为 <code>15</code> / <code>15</code>）。</li> <li><code>--rpc-max-subscriptions-per-connection &lt;N&gt;</code> — 每个连接的最大并发订阅数（默认为 <code>1024</code>）。</li> <li><code>--rpc-message-buffer-capacity-per-connection &lt;N&gt;</code> — 每个连接在反压之前的排队消息容量（默认为 <code>64</code>）。</li> <li><code>--rpc-disable-batch-requests</code> 和 <code>--rpc-max-batch-request-len &lt;N&gt;</code> — 禁用批量 RPC 或限制批处理长度。</li> <li><code>--ws-max-connections</code>: 自 client v0.33.0 起已弃用，请改用 <code>--rpc-max-connections</code> 来调整组合的 HTTP 和 WS 连接限制 - 指定 HTTP 和 WS 服务器连接的最大数量。默认为 100。</li> <li><code>--wasm-execution</code>: 指定执行 Wasm 运行时代码的方法。可用选项包括：<ul> <li><code>compiled</code>: 这是默认选项，使用 Wasmtime 编译的运行时。</li> <li><code>interpreted-i-know-what-i-do</code>: 使用 wasmi 解释器。</li> </ul> </li> <li><code>--wasmtime-instantiation-strategy</code>: 控制 WASM 实例化。默认值为 <code>pooling-copy-on-write</code>（最快）。选项包括 <code>recreate-instance-copy-on-write</code>、<code>pooling</code>、<code>recreate-instance</code>。CoW 变体在不支持时会回退。</li> <li><code>--max-runtime-instances &lt;N&gt;</code>: 每个运行时的运行时实例缓存大小。默认为 <code>8</code>，最大为 <code>32</code>。</li> <li><code>--runtime-cache-size &lt;N&gt;</code>: 同时缓存的不同运行时的最大数量。默认为 <code>2</code>。</li> <li><code>--wasmtime-precompiled &lt;PATH&gt;</code> / <code>--wasm-runtime-overrides &lt;PATH&gt;</code>: 版本匹配时，使用预编译的运行时或本地 WASM 覆盖。仅限高级/运维使用。</li> <li><code>--state-pruning</code>: 指定状态剪枝模式。对于低于 v0.27.0 的客户端版本，<code>--state-pruning</code> 标志名为 <code>--pruning</code>。如果使用 <code>--collator</code> 标志运行节点，则默认会保留所有区块的完整状态。否则，仅保留最近 256 个区块的状态。可用选项包括：<ul> <li><code>archive</code>: 保留所有区块的完整状态。</li> <li><code>&lt;number-of-blocks&gt;</code>: 指定要保留状态的自定义区块数。</li> </ul> </li> <li><code>--trie-cache-size</code>: 指定内部状态缓存的大小（以字节为单位）。默认为 <code>1073741824</code> (1 GB)。提供 <code>0</code> 会禁用缓存。为了提高整理人和 RPC 节点的性能，通常使用 1-4 GB 左右的值，具体取决于硬件。（在客户端 v0.27.0 之前，这是 <code>--state-cache-size</code>。）</li> <li><code>--db-cache</code>: 指定数据库缓存限制使用的内存。建议将其设置为服务器实际 RAM 的 50%。例如，对于 32 GB RAM，该值应设置为 <code>16000</code>。最小值是 <code>2000</code>，但低于建议的规格。</li> <li><code>--database</code>: 选择 DB 后端。选项：<code>auto</code>（检测或创建 ParityDb）、<code>paritydb</code>、<code>paritydb-experimental</code>、<code>rocksdb</code>。对于大多数运营商来说，<code>auto</code> 就可以了；某些人可能更喜欢 RocksDB 以便熟悉工具。</li> <li><code>--blocks-pruning</code>: 从状态中单独剪除区块体/理由。选项：</li> <li><code>archive</code>：保留所有区块，</li> <li><code>archive-canonical</code>：仅保留最终确定的区块（默认），</li> <li><code>&lt;NUMBER&gt;</code>：保留最后 <code>&lt;NUMBER&gt;</code> 个最终确定的区块。</li> <li><code>--base-path</code>: 指定存储链数据的基本路径。</li> <li><code>--chain</code>: 指定要使用的链规范。它可以是预定义的链规范，例如 <code>moonbeam</code>、<code>moonriver</code> 或 <code>alphanet</code>。或者它可以是指向包含链规范的文件的路径（例如 <code>build-spec</code> 命令导出的文件）。</li> <li><code>--network-backend</code>: 选择 P2P 堆栈。选项：</li> <li><code>litep2p</code>（默认）— 轻量级，CPU 使用率较低，生态系统正在迁移到此处。</li> <li><code>libp2p</code> — 为兼容性而保留的旧版后端。</li> <li><code>--name</code>: 指定节点的人类可读名称，如果启用，可以在 遥测 上看到。</li> <li><code>--telemetry-url</code>: 指定要连接的遥测服务器的 URL。可以多次传递此标志，以指定多个遥测端点。此标志采用两个参数：URL 和详细级别。详细级别范围从 0 到 9，其中 0 表示最不详细。预期格式为“”，例如 <code>--telemetry-url 'wss://foo/bar 0'</code>。 <li><code>--no-telemetry</code>: 完全禁用遥测（默认在全局链上启用）。</li> <li><code>--prometheus-external</code>: 在所有接口上公开 Prometheus 指标（默认为本地）。</li> <li><code>--no-prometheus</code>: 禁用 Prometheus 端点。</li> <li><code>--no-prometheus-prefix</code>: 从指标名称中删除 <code>moonbeam</code> 前缀。</li> <li><code>--in-peers</code>: 指定入站全节点对等方的最大数量。默认为 <code>32</code>。</li> <li><code>--out-peers</code>: 指定要维护的出站对等方的目标数量。默认为 <code>8</code>。</li> <li><code>--reserved-nodes &lt;ADDR&gt;...</code> / <code>--reserved-only</code>: 锁定到一组对等方，并且（可选）仅与它们同步。对于专用集群或位于哨兵/拓扑后面的 RPC 节点很有用。</li> <li><code>--no-hardware-benchmarks</code>: 跳过启动时的自动 CPU/内存/磁盘基准测试（如果启用，还会禁止将这些发送到遥测）。</li> <li><code>--public-addr &lt;MULTIADDR&gt;...</code> / <code>--listen-addr &lt;MULTIADDR&gt;...</code>: P2P 的通告与监听多重地址。在 NAT/代理后面使用。</li> <li><code>--no-private-ip</code> / <code>--allow-private-ip</code>: 根据环境禁止/允许专用地址对等互连。</li> <li><code>--in-peers-light &lt;N&gt;</code>: 最大入站轻客户端对等方（默认为 <code>100</code>）。</li> <li><code>--max-parallel-downloads &lt;N&gt;</code>: 要并行请求来自多少个对等方的相同已宣布区块。默认为 <code>5</code>。</li> <li><code>--runtime-cache-size 64</code>: 将内存中缓存中保留的不同运行时版本的数量配置为 64。</li> <li><code>--eth-log-block-cache</code>: LRU 缓存用于区块数据的大小（以字节为单位）限制使用。此标志主要与 RPC 提供程序有关。默认为 <code>300000000</code>。</li> <li><code>--eth-statuses-cache</code>: LRU 缓存用于事务状态数据的大小（以字节为单位）限制使用。此标志主要与 RPC 提供程序有关。默认为 <code>300000000</code>。</li> <li><code>--sync</code>: 设置区块链同步模式，这可以使区块链同步更快。可用选项包括：<ul> <li><code>full</code>: 下载并验证完整的区块链历史记录。</li> <li><code>fast</code>: 下载区块而不执行它们，并下载带有证明的最新状态。</li> <li><code>fast-unsafe</code>: 与 <code>fast</code> 相同，但跳过下载状态证明。</li> <li><code>warp</code>: 下载最新状态和证明。</li> </ul> </li> <li><code>--prometheus-port</code>: 指定自定义 Prometheus 端口。</li> <li><code>--lazy-loading-remote-rpc</code>: 允许通过依赖指定的 RPC 端点获取网络状态来进行延迟加载，直到节点完全同步，例如 <code>--lazy-loading-remote-rpc 'https://moonbeam.unitedbloc.com'</code>，只要指定的 RPC 端点具有足够的速率限制来处理预期的负载。强烈建议使用私有（API 密钥）端点，而不是公共端点。</li> <li><code>--lazy-loading-block</code>: 用于指定延迟加载的区块哈希的可选参数。此参数允许您指定一个区块哈希，从该哈希开始加载数据。如果未提供，将使用最新的区块。</li> <li><code>--lazy-loading-state-overrides</code>: 用于指定延迟加载期间的状态覆盖的可选参数。此参数允许您提供一个包含状态覆盖的文件的路径。该文件可以包含任何应应用的自定义状态修改。</li> <li><code>--lazy-loading-runtime-override</code>: 用于指定启动延迟加载时的运行时覆盖的可选参数。如果未提供，它将从正在分叉的区块中获取运行时。</li> <li><code>--lazy-loading-delay-between-requests</code>: 使用延迟加载时，RPC 请求之间的延迟（以毫秒为单位）。此参数控制连续 RPC 请求之间等待的时间量。这有助于管理请求速率并避免使服务器不堪重负。默认值为 <code>100</code> 毫秒。</li> <li><code>--lazy-loading-max-retries-per-request</code>: 使用延迟加载时，RPC 请求的最大重试次数。默认值为 <code>10</code> 次重试。</li> <li><code>--pool-type</code>: 选择交易池实现。可用选项包括：<ul> <li><code>fork-aware</code>: 跨竞争分叉（“视图”）跟踪待处理的交易，这减少了短暂重组期间丢弃/重新验证的交易以及 nonce/顺序故障。这是当前 Moonbeam 构建上的默认设置（Polkadot SDK 更改；来自 ~RT3600+ 的默认设置），建议在整理人和 RPC 节点上使用。</li> <li><code>single-state</code>: 使用旧版单视图池。在旧版本的二进制文件上，显式设置 <code>--pool-type=fork-aware</code> 以选择加入改进的实现。</li> </ul> </li> <li><code>--pool-limit &lt;N&gt;</code>: 池中交易的最大数量。默认为 <code>8192</code>。</li> <li><code>--pool-kbytes &lt;KB&gt;</code>: 待处理交易的最大总大小。默认为 <code>20480</code> (≈20 MB)。</li> <li><code>--tx-ban-seconds &lt;S&gt;</code>: 禁止无效交易的时间。默认为 <code>1800</code> 秒。</li> <li><code>--relay-chain-rpc-urls &lt;URL&gt;...</code>: 通过从远程 RPC 获取中继链数据来减少资源使用。节点将按顺序尝试 URL，并在连接失败时回退。仍然连接到中继链网络，但带宽较低。</li> <li><code>--relay-chain-light-client</code> (实验性的，仅限完整节点)：嵌入中继链轻客户端。使用指定的中继链链规范。</li> <li><code>--offchain-worker &lt;mode&gt;</code>: 启用链下 worker。选项：<code>always</code>、<code>never</code>、<code>when-authority</code> （默认）。</li> <li><code>--enable-offchain-indexing &lt;true|false&gt;</code>: 允许运行时在区块导入期间直接写入链下 worker DB。默认为 <code>false</code>。</li>"}, {"location": "node-operators/networks/run-a-node/flags/#execution-strategy", "title": "执行策略标志", "text": "<p>这些标志用于调整运行时在不同上下文中的执行方式：</p> <ul> <li><code>--execution</code>：所有上下文的全局默认设置。选项：<code>native</code>、<code>wasm</code>、<code>both</code>、<code>native-else-wasm</code>。</li> <li><code>--execution-syncing</code>、<code>--execution-import-block</code>、<code>--execution-block-construction</code>、<code>--execution-offchain-worker</code>、<code>--execution-other</code>：使用与上述相同的选项集覆盖每个上下文的行为。</li> </ul> <p><code>Native-else-wasm</code> 和 <code>both</code> 有助于诊断升级期间的 native/wasm 差异；<code>wasm</code> 最安全，但速度较慢。</p>"}, {"location": "node-operators/networks/run-a-node/flags/#flags-for-sql-backend", "title": "用于配置 SQL 后端的标志", "text": "<ul> <li><code>--frontier-backend-type</code>: 将 Frontier 后端类型设置为以下选项之一：<ul> <li><code>key-value</code>: 根据从全局后端设置继承的设置，使用 RocksDB 或 ParityDB。这是默认选项，RocksDB 是默认后端。</li> <li><code>sql</code>: 使用带有自定义日志索引的 SQL 数据库。</li> </ul> </li> <li><code>frontier-sql-backend-pool-size</code>: 设置 Frontier SQL 后端的连接池可以同时处理的最大数据库连接数。默认为 <code>100</code>。</li> <li><code>frontier-sql-backend-num-ops-timeout</code>: 设置 Frontier SQL 后端的查询超时，以 VM 操作数为单位。默认为 <code>10000000</code>。</li> <li><code>frontier-sql-backend-thread-count</code>: 设置 Frontier SQL 后端的辅助线程限制。默认为 <code>4</code>。</li> <li><code>frontier-sql-backend-cache-size</code>: 设置 Frontier SQL 后端的缓存大小（以字节为单位）。默认值为 200MB，即 <code>209715200</code> 字节。</li> </ul>"}, {"location": "node-operators/networks/run-a-node/flags/#how-to-access-all-of-the-available-flags", "title": "如何访问所有可用标志", "text": "<p>要获得可用标志的完整列表，您可以使用在命令末尾添加 <code>--help</code> 的方式来启动您的 Moonbeam 节点。该命令会因您选择启动节点的方式以及是否使用 Docker 或 Systemd 而异。</p>"}, {"location": "node-operators/networks/run-a-node/flags/#docker", "title": "Docker", "text": "MoonbeamMoonriverMoonbase Alpha <p>bash docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --help</p> <p>bash docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --help</p> <p>bash docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ moonbeamfoundation/moonbeam:v0.49.2 \\ --help</p>"}, {"location": "node-operators/networks/run-a-node/flags/#systemd", "title": "Systemd", "text": "MoonbeamMoonriverMoonbase Alpha <p>bash</p> <p>bash</p> <p>bash</p>"}, {"location": "node-operators/networks/run-a-node/flags/#if-you-used-the-release-binary", "title": "If you used the release binary", "text": "<p>./moonbeam --help</p>"}, {"location": "node-operators/networks/run-a-node/flags/#or-if-you-compiled-the-binary", "title": "Or if you compiled the binary", "text": "<p>./target/release/moonbeam --help</p>"}, {"location": "node-operators/networks/run-a-node/flags/#if-you-used-the-release-binary_1", "title": "If you used the release binary", "text": "<p>./moonbeam --help</p>"}, {"location": "node-operators/networks/run-a-node/flags/#or-if-you-compiled-the-binary_1", "title": "Or if you compiled the binary", "text": "<p>./target/release/moonbeam --help</p>"}, {"location": "node-operators/networks/run-a-node/flags/#if-you-used-the-release-binary_2", "title": "If you used the release binary", "text": "<p>./moonbeam --help</p>"}, {"location": "node-operators/networks/run-a-node/flags/#or-if-you-compiled-the-binary_2", "title": "Or if you compiled the binary", "text": "<p>./target/release/moonbeam --help</p>"}, {"location": "node-operators/networks/run-a-node/overview/", "title": "在Moonbeam上运行节点", "text": ""}, {"location": "node-operators/networks/run-a-node/overview/#introduction", "title": "简介", "text": "<p>在基于 Moonbeam 的网络上运行完整节点，您可以连接到网络、与引导节点同步、获得对 RPC 端点的本地访问权限、在平行链上创建区块等等。</p> <p>Moonbeam 有多个部署，包括 Moonbase Alpha 测试网、Kusama 上的 Moonriver 和 Polkadot 上的 Moonbeam。以下是这些环境的命名方式以及它们对应的链规范文件名称：</p> 网络 托管方 链名称 Moonbase Alpha Moonbeam 基金会 alphanet Moonriver Kusama moonriver Moonbeam Polkadot moonbeam <p>Note</p> <p>Moonbase Alpha 仍然被认为是 Alphanet，因此_不会_有 100% 的正常运行时间。平行链可能会根据需要进行清除。在开发应用程序期间，请确保您实施一种方法，以便将您的合约和账户快速重新部署到新的平行链。 如果需要清除链，我们至少会提前 24 小时通过我们的 Discord 频道 发布通知。</p>"}, {"location": "node-operators/networks/run-a-node/overview/#requirements", "title": "要求", "text": "<p>运行平行链节点类似于典型的 Substrate 节点，但存在一些差异。Substrate 平行链节点是一个更大的构建，因为它包含运行平行链本身的代码，以及同步中继链和促进两者之间通信的代码。因此，此构建非常大，可能需要超过 30 分钟，并需要 32GB 内存。</p> <p>下表显示了运行节点的最低建议规格。对于我们的 Kusama 和 Polkadot MainNet 部署，随着网络的增长，磁盘要求将会更高。</p> MoonbeamMoonriverMoonbase Alpha 组件 要求 CPU 8 核心（每个核心速度最快） RAM 16 GB SSD 3 TB（推荐） 防火墙 P2P 端口必须对传入流量开放：    - 来源：任何    - 目标：30333、30334 TCP 组件 要求 CPU 8 核心（每个核心速度最快） RAM 16 GB SSD 2 TB（推荐） 防火墙 P2P 端口必须对传入流量开放：    - 来源：任何    - 目标：30333、30334 TCP 组件 要求 CPU 8 核心（每个核心速度最快） RAM 16 GB SSD 2 TB（推荐） 防火墙 P2P 端口必须对传入流量开放：    - 来源：任何    - 目标：30333、30334 TCP <p>Note</p> <p>如果在运行节点时没有看到 <code>Imported</code> 消息（没有 <code>[Relaychain]</code> 标签），您可能需要仔细检查您的端口配置。</p>"}, {"location": "node-operators/networks/run-a-node/overview/#running-ports", "title": "运行端口", "text": "<p>如前所述，中继链/平行链节点将监听多个端口。默认的 Substrate 端口用于平行链，而中继链将监听下一个更高的端口。</p> <p>唯一需要打开以允许传入流量的端口是那些指定用于 P2P 的端口。收集人不得打开 RPC 或 WS 端口。</p> <p>Note</p> <p>As of client v0.33.0, the <code>--ws-port</code> and <code>--ws-max-connections</code> flags have been deprecated and removed in favor of the <code>--rpc-port</code> and <code>--rpc-max-connections</code> flags for both RPC and WSS connections. The default port is <code>9944</code>, and the default maximum number of connections is set to 100.</p>"}, {"location": "node-operators/networks/run-a-node/overview/#default-ports-for-a-parachain-full-node", "title": "Parachain完整节点的默认端口", "text": "描述 端口 P2P 30333 (TCP) RPC &amp; WS 9944 Prometheus 9615"}, {"location": "node-operators/networks/run-a-node/overview/#default-ports-of-embedded-relay-chain", "title": "嵌入式中继链的默认端口", "text": "描述 端口 P2P 30334 (TCP) RPC &amp; WS 9945 Prometheus 9616"}, {"location": "node-operators/networks/run-a-node/overview/#installation", "title": "安装", "text": "<p>这里有一些不同的指南可以帮助您开始运行基于 Moonbeam 的节点：</p> <ul> <li>使用 Docker - 此方法提供了一种快速简便的 Docker 容器入门方法</li> <li>使用 Systemd - 建议有 Substrate 节点编译经验的用户使用此方法</li> </ul>"}, {"location": "node-operators/networks/run-a-node/overview/#debug-trace-txpool-apis", "title": "Debug、Trace 和 TxPool API", "text": "<p>您还可以通过运行跟踪节点来访问某些非标准的 RPC 方法，这允许开发人员在运行时检查和调试交易。跟踪节点使用与标准 Moonbase Alpha、Moonriver 或 Moonbeam 节点不同的 Docker 镜像。请查看运行跟踪节点指南，并确保在整个说明中切换到正确的网络选项卡。然后，要与您的跟踪节点进行交互，请查看Debug &amp; Trace指南。</p>"}, {"location": "node-operators/networks/run-a-node/overview/#lazy-loading", "title": "延迟加载", "text": "<p>延迟加载允许 Moonbeam 节点在后台下载网络状态时运行，从而无需等待完全同步即可使用。您可以使用以下标志激活延迟加载：</p> <ul> <li><code>--lazy-loading-remote-rpc</code> - 允许通过依赖指定的 RPC 获取网络状态来进行延迟加载，直到节点完全同步，例如：<code>--lazy-loading-remote-rpc 'INSERT-RPC-URL'</code></li> </ul> <p>使用此功能启动节点后，您将看到如下输出：</p> [Lazy loading 🌗]     You are now running the Moonbeam client in lazy loading mode, where data is retrieved     from a live RPC node on demand.     Using remote state from: https://moonbeam.unitedbloc.com     Forking from block: 8482853     To ensure the client works properly, please note the following:         1. *Avoid Throttling*: Ensure that the backing RPC node is not limiting the number of         requests, as this can prevent the lazy loading client from functioning correctly;         2. *Be Patient*: As the client may take approximately 20 times longer than normal to         retrieve and process the necessary data for the requested operation.     The service will start in 10 seconds... <p>Note</p> <p>Moonbeam 的延迟加载需要大量的 RPC 请求。为了避免受到公共端点的速率限制，强烈建议使用专用端点。</p> <p>您可以使用以下可选参数进一步自定义延迟加载功能：</p> <ul> <li><code>--lazy-loading-block</code> - 指定一个用于开始加载数据的区块哈希值。如果未提供，将使用最新的区块</li> <li><code>--lazy-loading-delay-between-requests</code> - 使用延迟加载时，RPC 请求之间的延迟（以毫秒为单位）。此参数控制连续 RPC 请求之间等待的时间量。这有助于管理请求速率并避免服务器不堪重负。默认值为 <code>100</code> 毫秒</li> <li><code>--lazy-loading-max-retries-per-request</code> - 使用延迟加载时，RPC 请求的最大重试次数。默认值为 <code>10</code> 次重试</li> <li><code>--lazy-loading-runtime-override</code> - WASM 文件的路径，用于在 fork 时覆盖运行时。如果未提供，它将从正在 fork 的区块中获取运行时</li> <li><code>--lazy-loading-state-overrides</code> - JSON 文件的路径，其中包含在 fork 时要应用的状态覆盖</li> </ul> <p>状态覆盖文件应定义您要覆盖的相应 pallet、存储项和值，如下所示：</p> <p>[  {      \"pallet\": \"System\",      \"storage\": \"SelectedCandidates\",      \"value\": \"0x04f24ff3a9cf04c71dbc94d0b566f7a27b94566cac\"  } ]</p>"}, {"location": "node-operators/networks/run-a-node/overview/#logs-and-troubleshooting", "title": "日志和故障排除", "text": "<p>您将看到来自中继链和平行链的日志。中继链将以 <code>[Relaychain]</code> 为前缀，而平行链没有前缀。</p>"}, {"location": "node-operators/networks/run-a-node/overview/#p2p-ports-not-open", "title": "P2P 端口未打开", "text": "<p>如果您没有看到 <code>Imported</code> 消息（没有 <code>[Relaychain]</code> 标签），则需要检查 P2P 端口配置。P2P 端口必须对传入流量开放。</p>"}, {"location": "node-operators/networks/run-a-node/overview/#in-sync", "title": "同步", "text": "<p>两条链必须始终保持同步，您应该看到 <code>Imported</code> 或 <code>Idle</code> 消息，并且已连接对等节点。</p>"}, {"location": "node-operators/networks/run-a-node/overview/#genesis-mismatching", "title": "Genesis 不匹配", "text": "<p>Moonbase Alpha 测试网可能需要不时地进行清除和升级。因此，您可能会看到以下消息：</p> <p>text DATE [Relaychain] 具有 peer id <code>ID</code> 的 Bootnode 位于不同的链上 chain (我们的 genesis: GENESIS_ID 他们的: OTHER_GENESIS_ID)</p> <p>这通常意味着您正在运行旧版本，需要升级。</p> <p>我们会提前至少 24 小时通过我们的 Discord 频道 公布升级（以及相应的链清除）。</p> <p>清除链数据的说明会略有不同，具体取决于您启动节点的方式：</p> <ul> <li>对于 Docker，您可以查看 清除节点 部分的 使用 Docker 页面</li> <li>对于 Systemd，您可以查看 清除节点 部分的 使用 Systemd 页面</li> </ul>"}, {"location": "node-operators/networks/run-a-node/systemd/", "title": "使用 Systemd 在 Moonbeam 上运行节点", "text": ""}, {"location": "node-operators/networks/run-a-node/systemd/#introduction", "title": "简介", "text": "<p>在基于 Moonbeam 的网络上运行完整节点，您可以连接到网络，与引导节点同步，获得对 RPC 端点的本地访问权限，在平行链上创建区块等等。</p> <p>在本指南中，您将学习如何使用 Systemd 启动 Moonbeam 节点，以及如何维护和清除您的节点。</p> <p>如果您有兴趣自己编译二进制文件（可能需要 30 多分钟并需要 32GB 的内存），您可以查看 手动编译 Moonbeam 二进制文件 指南。</p>"}, {"location": "node-operators/networks/run-a-node/systemd/#checking-prerequisites", "title": "检查先决条件", "text": "<p>以下各节将介绍使用二进制文件并将 Moonbeam 完整节点作为 systemd 服务运行的过程。要开始使用，您需要：</p> <ul> <li>确保您正在运行 Ubuntu 18.04、20.04 或 22.04。Moonbeam 可以在其他 Linux 版本上运行，但 Ubuntu 是目前唯一经过测试的版本</li> <li>确保您的系统符合要求。当连接到 Kusama 上的 Moonriver 或 Polkadot 上的 Moonbeam 时，完全同步嵌入式中继链需要几天时间</li> </ul>"}, {"location": "node-operators/networks/run-a-node/systemd/#the-release-binary", "title": "下载最新的发布版本二进制文件", "text": "<p>要下载最新的发布版本二进制文件，请按照以下步骤操作：</p> <ol> <li> <p>创建一个目录来存储二进制文件和链数据（您可能需要 <code>sudo</code>）</p> MoonbeamMoonriverMoonbase Alpha <pre><code>mkdir /var/lib/moonbeam-data\n</code></pre> <pre><code>mkdir /var/lib/moonriver-data\n</code></pre> <pre><code>mkdir /var/lib/alphanet-data\n</code></pre> </li> <li> <p>使用 <code>wget</code> 获取最新的发布版本二进制文件，并将其输出到上一步创建的目录中</p> MoonbeamMoonriverMoonbase Alpha <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/v0.49.2/moonbeam \\\n-O /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/v0.49.2/moonbeam \\\n-O /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/v0.49.2/moonbeam \\\n-O /var/lib/alphanet-data/moonbeam\n</code></pre> </li> <li> <p>要验证您是否下载了正确的版本，可以在终端中运行以下命令</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sha256sum /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>sha256sum /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>sha256sum /var/lib/alphanet-data/moonbeam\n</code></pre> <p>您应该收到以下输出：</p> MoonbeamMoonriverMoonbase Alpha <pre><code>88fd7e94f257c5bff7a2b4fbe3dc1c00fd24fcc4943440a03e059778dfcb266d\n</code></pre> <pre><code>88fd7e94f257c5bff7a2b4fbe3dc1c00fd24fcc4943440a03e059778dfcb266d\n</code></pre> <pre><code>88fd7e94f257c5bff7a2b4fbe3dc1c00fd24fcc4943440a03e059778dfcb266d\n</code></pre> </li> </ol>"}, {"location": "node-operators/networks/run-a-node/systemd/#set-up-the-service", "title": "设置服务", "text": "<p>以下命令将设置有关运行服务的所有内容：</p> <ol> <li> <p>创建一个服务帐户来运行该服务</p> MoonbeamMoonriverMoonbase Alpha <p>bash adduser moonbeam_service --system --no-create-home</p> <p>bash adduser moonriver_service --system --no-create-home</p> <p>bash adduser moonbase_service --system --no-create-home</p> </li> <li> <p>确保你正确配置了用于存储链数据的本地目录的所有权和权限，并且还记得授予二进制文件执行权限</p> MoonbeamMoonriverMoonbase Alpha <p>bash sudo chown -R moonbeam_service /var/lib/moonbeam-data sudo chmod +x /var/lib/moonbeam-data/moonbeam</p> <p>bash sudo chown -R moonriver_service /var/lib/moonriver-data sudo chmod +x /var/lib/moonriver-data/moonbeam</p> <p>bash sudo chown -R moonbase_service /var/lib/alphanet-data sudo chmod +x /var/lib/alphanet-data/moonbeam</p> </li> </ol>"}, {"location": "node-operators/networks/run-a-node/systemd/#create-the-configuration-file", "title": "创建配置文件", "text": "<p>接下来，创建 systemd 服务文件。如果您正在配置一个排序人节点，请使用下面的特定于排序人的配置文件片段。</p> <p>首先，您需要创建一个名为 <code>/etc/systemd/system/moonbeam.service</code> 的文件来存储配置。</p> <p>请注意，在以下启动配置中，您必须：</p> <ul> <li>将 <code>INSERT_YOUR_NODE_NAME</code> 替换为您选择的节点名称。您必须在两个地方执行此操作：一个用于平行链，另一个用于中继链</li> <li>将 <code>INSERT_RAM_IN_MB</code> 替换为您服务器实际 RAM 的 50%。例如，对于 32GB 的 RAM，该值必须设置为 <code>16000</code>。最小值为 <code>2000</code>，但低于建议的规格</li> <li>仔细检查二进制文件是否位于如下所述的正确路径中 (ExecStart)</li> <li>如果您使用了不同的目录，请仔细检查基本路径</li> </ul> <p>有关以下启动命令中使用的标志以及其他常用标志的概述，请参阅我们文档的 标志 页面。</p>"}, {"location": "node-operators/networks/run-a-node/systemd/#full-node", "title": "完整节点", "text": "MoonbeamMoonriverMoonbase Alpha <p>bash [Unit] Description=\"Moonbeam systemd 服务\" After=network.target StartLimitIntervalSec=0</p> <p>[Service] Type=simple Restart=on-failure RestartSec=10 User=moonbeam_service SyslogIdentifier=moonbeam SyslogFacility=local7 KillSignal=SIGHUP ExecStart=/var/lib/moonbeam-data/moonbeam \\      --state-pruning archive \\      --trie-cache-size 1073741824 \\      --db-cache INSERT_RAM_IN_MB \\      --base-path /var/lib/moonbeam-data \\      --chain moonbeam \\      --name \"INSERT_YOUR_NODE_NAME\" \\      -- \\      --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\      --sync fast</p> <p>[Install] WantedBy=multi-user.target</p> <p>bash [Unit] Description=\"Moonriver systemd 服务\" After=network.target StartLimitIntervalSec=0</p> <p>[Service] Type=simple Restart=on-failure RestartSec=10 User=moonriver_service SyslogIdentifier=moonriver SyslogFacility=local7 KillSignal=SIGHUP ExecStart=/var/lib/moonriver-data/moonbeam \\      --state-pruning archive \\      --trie-cache-size 1073741824 \\      --db-cache INSERT_RAM_IN_MB \\      --base-path /var/lib/moonriver-data \\      --chain moonriver \\      --name \"INSERT_YOUR_NODE_NAME\" \\      -- \\      --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\      --sync fast</p> <p>[Install] WantedBy=multi-user.target</p> <p>bash [Unit] Description=\"Moonbase Alpha systemd 服务\" After=network.target StartLimitIntervalSec=0</p> <p>[Service] Type=simple Restart=on-failure RestartSec=10 User=moonbase_service SyslogIdentifier=moonbase SyslogFacility=local7 KillSignal=SIGHUP ExecStart=/var/lib/alphanet-data/moonbeam \\      --state-pruning archive \\      --trie-cache-size 1073741824 \\      --db-cache INSERT_RAM_IN_MB \\      --base-path /var/lib/alphanet-data \\      --chain alphanet \\      --name \"INSERT_YOUR_NODE_NAME\" \\      -- \\      --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\      --sync fast</p> <p>[Install] WantedBy=multi-user.target</p>"}, {"location": "node-operators/networks/run-a-node/systemd/#allow-external-access", "title": "Allow External Access to Your Node", "text": "<p>If you want to run an RPC endpoint, connect to Polkadot.js Apps, or run your own application, you can use the <code>--unsafe-rpc-external</code> flag to run the full node with external access to the RPC ports.</p> Moonbeam 启动命令示例 <p>bash [Unit] Description=\"Moonbeam systemd 服务\" After=network.target StartLimitIntervalSec=0</p> <p>[Service] Type=simple Restart=on-failure RestartSec=10 User=moonbeam_service SyslogIdentifier=moonbeam SyslogFacility=local7 KillSignal=SIGHUP ExecStart=/var/lib/moonbeam-data/moonbeam \\      --state-pruning archive \\      --trie-cache-size 1073741824 \\      --db-cache INSERT_RAM_IN_MB \\      --base-path /var/lib/moonbeam-data \\      --chain moonbeam \\      --name \"INSERT_YOUR_NODE_NAME\" \\      --unsafe-rpc-external \\      -- \\      --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\      --sync fast</p> <p>[Install] WantedBy=multi-user.target</p>"}, {"location": "node-operators/networks/run-a-node/systemd/#use-sql", "title": "Use a SQL Backend for Frontier", "text": "<p>The default Frontier database, which comes standard with Moonbeam nodes and contains all of the Ethereum-related elements, such as transactions, blocks, and logs, can be modified to use a SQL backend. Since <code>eth_getLogs</code> is a very resource-intensive method, the SQL backend aims to provide a more performant alternative for indexing and querying Ethereum logs in comparison to the default RocksDB database.</p> <p>To spin up a node with a Frontier SQL backend, you'll need to add the <code>--frontier-backend-type sql</code> flag to your start-up command.</p> <p>There are additional flags you can use to configure the pool size, query timeouts, and more for your SQL backend; please refer to the Flags page for more information.</p> Moonbeam 启动命令示例 <p>bash [Unit] Description=\"Moonbeam systemd 服务\" After=network.target StartLimitIntervalSec=0</p> <p>[Service] Type=simple Restart=on-failure RestartSec=10 User=moonbeam_service SyslogIdentifier=moonbeam SyslogFacility=local7 KillSignal=SIGHUP ExecStart=/var/lib/moonbeam-data/moonbeam \\      --state-pruning archive \\      --trie-cache-size 1073741824 \\      --db-cache INSERT_RAM_IN_MB \\      --base-path /var/lib/moonbeam-data \\      --chain moonbeam \\      --name \"INSERT_YOUR_NODE_NAME\" \\      --frontier-backend-type sql \\      -- \\      --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\      --sync fast</p> <p>[Install] WantedBy=multi-user.target</p>"}, {"location": "node-operators/networks/run-a-node/systemd/#collator", "title": "Collator", "text": "<p>从 v0.39.0 开始，新的 Moonbeam Collator 节点将不再在启动时自动生成会话密钥。v0.39.0 之前的节点无需更改其处理会话密钥的方式。</p> <p>设置新节点时，运行以下命令以生成会话密钥，并将其存储在磁盘上，以便在启动命令中引用：</p> MoonbeamMoonriverMoonbase Alpha <p>bash</p> <p>/var/lib/moonbeam-data/moonbeam key generate-node-key --base-path /var/lib/moonbeam-data --chain moonbeam &amp;&amp; sudo chown -R moonbeam_service /var/lib/moonbeam-data</p> <p>bash</p> <p>/var/lib/moonriver-data/moonbeam key generate-node-key --base-path /var/lib/moonriver-data --chain moonriver &amp;&amp; sudo chown -R moonriver_service /var/lib/moonriver-data</p> <p>bash</p> <p>/var/lib/alphanet-data/moonbeam key generate-node-key --base-path /var/lib/alphanet-data --chain alphanet  &amp;&amp; sudo chown -R moonbase_service  /var/lib/alphanet-data</p> <p>Note</p> <p>可以使用启动命令中的 <code>--unsafe-force-node-key-generation</code> 参数绕过此步骤，但不建议这样做。</p> <p>现在，您可以创建 systemd 配置文件：</p> MoonbeamMoonriverMoonbase Alpha <p>bash [Unit] Description=\"Moonbeam systemd 服务\" After=network.target StartLimitIntervalSec=0</p> <p>[Service] Type=simple Restart=on-failure RestartSec=10 User=moonbeam_service SyslogIdentifier=moonbeam SyslogFacility=local7 KillSignal=SIGHUP ExecStart=/var/lib/moonbeam-data/moonbeam \\      --collator \\      --trie-cache-size 1073741824 \\      --db-cache INSERT_RAM_IN_MB \\      --base-path /var/lib/moonbeam-data \\      --chain moonbeam \\      --name \"INSERT_YOUR_NODE_NAME\" \\      -- \\      --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\      --sync fast</p> <p>[Install] WantedBy=multi-user.target</p> <p>bash [Unit] Description=\"Moonriver systemd 服务\" After=network.target StartLimitIntervalSec=0</p> <p>[Service] Type=simple Restart=on-failure RestartSec=10 User=moonriver_service SyslogIdentifier=moonriver SyslogFacility=local7 KillSignal=SIGHUP ExecStart=/var/lib/moonriver-data/moonbeam \\      --collator \\      --trie-cache-size 1073741824 \\      --db-cache INSERT_RAM_IN_MB \\      --base-path /var/lib/moonriver-data \\      --chain moonriver \\      --name \"INSERT_YOUR_NODE_NAME\" \\      -- \\      --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\      --sync fast</p> <p>[Install] WantedBy=multi-user.target</p> <p>bash [Unit] Description=\"Moonbase Alpha systemd 服务\" After=network.target StartLimitIntervalSec=0</p> <p>[Service] Type=simple Restart=on-failure RestartSec=10 User=moonbase_service SyslogIdentifier=moonbase SyslogFacility=local7 KillSignal=SIGHUP ExecStart=/var/lib/alphanet-data/moonbeam \\      --collator \\      --trie-cache-size 1073741824 \\      --db-cache INSERT_RAM_IN_MB \\      --base-path /var/lib/alphanet-data \\      --chain alphanet \\      --name \"INSERT_YOUR_NODE_NAME\" \\      -- \\      --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\      --sync fast</p> <p>[Install] WantedBy=multi-user.target</p>"}, {"location": "node-operators/networks/run-a-node/systemd/#maintain-your-node", "title": "维护您的节点", "text": "<p>随着 Moonbeam 开发的不断进行，有时需要升级您的节点软件。当有可用升级时，节点运营商将在我们的 Discord 频道 上收到通知，并了解升级是否必要（某些客户端升级是可选的）。升级过程很简单，对于完整节点或收集人节点都是一样的。</p> <p>如果您想要更新您的客户端，您可以保持现有的链数据不变，只需按照以下步骤更新二进制文件：</p> <ol> <li> <p>停止 systemd 服务</p> <pre><code>sudo systemctl stop moonbeam.service\n</code></pre> </li> <li> <p>删除旧的二进制文件</p> MoonbeamMoonriverMoonbase Alpha <pre><code>rm /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>rm /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>rm /var/lib/alphanet-data/moonbeam\n</code></pre> </li> <li> <p>从 GitHub 上的 Moonbeam 发布二进制文件 获取最新版本，并运行以下命令以更新到该版本</p> MoonbeamMoonriverMoonbase Alpha <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/INSERT_NEW_VERSION_TAG/moonbeam \\\n-O /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/INSERT_NEW_VERSION_TAG/moonbeam \\\n-O /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/INSERT_NEW_VERSION_TAG/moonbeam \\\n-O /var/lib/alphanet-data/moonbeam\n</code></pre> <p>Note</p> <p>如果您手动编译了二进制文件，则需要将二进制文件从 <code>./target/release/moonbeam</code> 移动到数据目录。</p> </li> <li> <p>更新权限</p> MoonbeamMoonriverMoonbase Alpha <pre><code>chmod +x /var/lib/moonbeam-data/moonbeam\nchown moonbeam_service /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>chmod +x /var/lib/moonriver-data/moonbeam\nchown moonriver_service /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>chmod +x /var/lib/alphanet-data/moonbeam\nchown moonbase_service /var/lib/alphanet-data/moonbeam\n</code></pre> </li> <li> <p>启动您的服务</p> <pre><code>systemctl start moonbeam.service\n</code></pre> </li> </ol> <p>要检查服务的状态和/或日志，您可以参考之前的命令。</p>"}, {"location": "node-operators/networks/run-a-node/systemd/#purge-your-node", "title": "清理您的节点", "text": "<p>如果您需要一个全新的 Moonbeam 节点实例，您可以通过删除关联的数据目录来清理您的节点。</p> <p>您首先需要停止 systemd 服务：</p> <p>bash sudo systemctl stop moonbeam</p> <p>要清理您的平行链和中继链数据，您可以运行以下命令：</p> MoonbeamMoonriverMoonbase Alpha <p>bash sudo rm -rf /var/lib/moonbeam-data/*</p> <p>bash sudo rm -rf /var/lib/moonriver-data/*</p> <p>bash sudo rm -rf /var/lib/alphanet-data/*</p> <p>要仅删除特定链的平行链数据，您可以运行：</p> MoonbeamMoonriverMoonbase Alpha <p>bash sudo rm -rf /var/lib/moonbeam-data/chains/*</p> <p>bash sudo rm -rf /var/lib/moonriver-data/chains/*</p> <p>bash sudo rm -rf /var/lib/alphanet-data/chains/*</p> <p>类似地，要仅删除中继链数据，您可以运行：</p> MoonbeamMoonriverMoonbase Alpha <p>bash sudo rm -rf /var/lib/moonbeam-data/polkadot/*</p> <p>bash sudo rm -rf /var/lib/moonriver-data/polkadot/*</p> <p>bash sudo rm -rf /var/lib/alphanet-data/polkadot/*</p> <p>Now that your chain data has been purged, you can start a new node with a fresh data directory. You can install the newest version by repeating the instructions in this guide. Make sure you are using the latest tag available, which you can find on the Moonbeam GitHub Release page.</p> <p>Note</p> <p>On an as-needed basis, Moonbase Alpha might be purged and reset. In these instances, you will need to purge both the parachain data and the relay chain data. If a purge is required, node operators will be notified in advance (via our Discord channel).</p>"}, {"location": "tokens/connect/ledger/", "title": "使用 Ledger 和 Ethereum 应用程序与 Moonbeam 交互", "text": ""}, {"location": "tokens/connect/ledger/#introduction", "title": "介绍", "text": "<p>硬件钱包提供了一种更安全的加密货币存储方式，因为私钥（用于签署交易）是离线存储的。在撰写本文时，Ledger 提供两种硬件钱包解决方案：Ledger Nano S 和 Ledger Nano X。</p> <p>对于 Moonbeam、Moonriver 和 Moonbase Alpha 测试网，您可以通过设置链 ID 来使用 Ledger Live 上的以太坊应用程序。对于 Moonbeam，链 ID 是 1284，对于 Moonriver 是 1285，对于 Moonbase Alpha 是 1287。以太坊应用程序涵盖所有支持的基于 Moonbeam 的网络，并且可用于连接 Ledger 设备。</p> <p>在本教程中，您将学习如何开始在 Moonbeam 上使用以太坊应用程序的 Ledger 硬件钱包。本指南仅说明了 Ledger Nano X 设备的步骤，但您也可以按照 Ledger Nano S 进行操作。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "tokens/connect/ledger/#ledger-live", "title": "安装 Ledger Live 应用程序", "text": "<p>如果您想连接到 Moonbeam、Moonriver 或 Moonbase Alpha TestNet，您可以通过安装 Ethereum 应用程序来实现，稍后您需要指定一个链 ID。</p> <p>To get started, open up Ledger Live and:</p> <ol> <li>Select Manager from the menu</li> <li>Connect and unlock your device (this must be done before installation)</li> <li>In the App catalog search for Ethereum (ETH) and click Install. Your Ledger device will show Processing and once the installation is complete, the app will appear on your Ledger device</li> </ol> <p>在 Ledger Live 应用程序中，根据您安装的应用程序，您应该在 Manager 页面上的 已安装的应用程序 选项卡下看到它们。成功安装应用程序后，您可以关闭 Ledger Live。</p> <p>&lt;img src=</p>"}, {"location": "tokens/connect/ledger/#import-your-ledger-account-to-metamask", "title": "将您的 Ledger 帐户导入 MetaMask", "text": "<p>现在您已经在 Ledger Live 上安装了应用程序，您可以将您的 Ledger 连接到电脑并解锁，然后打开 Ethereum 应用程序。</p> <p>Then import your Ledger account to MetaMask using the following steps:</p> <ol> <li>Click on the top-right logo to expand the menu</li> <li>Select Connect Hardware Wallet</li> </ol> <p></p> <p>In the next screen, you are prompted to select which hardware wallet you'll like to use in MetaMask. At the moment of writing, only Ledger and Trezor hardware wallets are supported. Here, take the following steps:</p> <ol> <li>Select the Ledger logo</li> <li>Click on Continue</li> </ol> <p></p> <p>If you're using Chrome or a Chrome-based browser like Brave, you'll be prompted to select your Ledger device to connect via WebHID:</p> <ol> <li>Select your Ledger device from the pop-up</li> <li>Click Connect</li> </ol> <p></p> <p>If a pop-up doesn't appear, you may need to change your MetaMask settings to enable a WebHID connection. You can check and update your MetaMask settings by following these steps:</p> <ol> <li>Expand the top-right menu and go to Settings </li> <li>Navigate to Advanced</li> <li>Scroll down to Preferred Ledger Connection Type and select WebHID from the dropdown</li> </ol> <p>Note</p> <p>The Preferred Ledger Connection Type setting is only available on Chrome and Chrome-based browsers. This setting doesn't exist on other browsers such as Firefox.</p> <p>如果 MetaMask 能够成功连接到您的 Ledger 设备，您应该会看到五个 Moonbeam/Ethereum 风格的帐户列表。 如果没有看到，请仔细检查 Ledger Live 是否已关闭，您已将 Ledger 设备连接到电脑并解锁，并确保 Ethereum 应用程序已打开。</p>"}, {"location": "tokens/connect/ledger/#import-accounts-and-view-balances", "title": "Import Accounts and View Balances", "text": "<p>From the list of accounts, take the following steps:</p> <ol> <li>Select the accounts you would like to import from your Ledger device</li> <li>Click on Unlock</li> </ol> <p></p> <p>如果您已成功导入 Ledger 帐户，您应该会在 MetaMask 主屏幕上看到您的帐户和余额，如下图所示：</p> <p></p> <p>您可以随时在 MetaMask 中切换帐户，以查看其他导入的 Ledger 帐户的余额。</p> <p>您现在已成功从 Ledger 设备导入了一个 Moonbeam 兼容帐户，现在可以开始与您的 Ledger 设备进行交互。</p>"}, {"location": "tokens/connect/ledger/#receive-tokens", "title": "Receive Tokens", "text": "<p>To get started interacting with your Ledger device, you will need to send some funds to it. Copy your address from MetaMask by clicking on your account name and address in MetaMask.</p> <p></p> <p>接下来，您需要获得一些 GLMR、MOVR 或 DEV 代币，并使用您刚刚复制的地址，将代币发送到您的帐户。交易成功完成后，您将看到您的余额更新。</p> <p>You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet.</p>"}, {"location": "tokens/connect/ledger/#send-tokens", "title": "发送 Token", "text": "<p>接下来是在 Moonbeam 上使用 Ledger 设备发送和签署交易。要开始发送交易，请点击发送按钮：</p> <p></p> <p>As you would in a standard transaction, set the recipient address, enter the number of tokens to send, review transaction details and confirm it. This will initiate the transaction signature wizard in your Ledger device. Here, take the following steps:</p> <ol> <li>Click the button to proceed to the next screen. Your Ledger device is only warning you to review the transaction</li> <li>Check the number of tokens being sent then proceed to the next screen</li> <li>Check the recipient's address and proceed to the next screen</li> <li>检查网络的链 ID。此信息确认 MetaMask 连接到哪个网络。对于 Moonbeam，链 ID 为 1284（十六进制：0x504），Moonriver 为 1285（十六进制：0x505），Moonbase Alpha 为 1287（十六进制：0x507）。准备就绪后，进入下一个屏幕</li> <li>检查适用于此交易的最高费用。这是您在 MetaMask 上设置的 Gas 价格乘以 Gas 限制。准备就绪后，进入下一个屏幕</li> <li>如果您同意所有交易详情，请批准它。这将签署交易，并触发 MetaMask 发送它。如果您不同意所有交易详情，请拒绝它。这将取消交易，MetaMask 会将其标记为失败</li> </ol> <p></p> <p>在您批准交易后，MetaMask 会将其发送到网络。交易确认后，它将在 MetaMask 的活动选项卡上显示为发送。</p> <p></p> <p>就这样！您已经使用 Ledger 硬件钱包在 Moonbeam 上签署了一笔交易并发送了一些 Token！</p>"}, {"location": "tokens/connect/metamask/", "title": "使用 MetaMask 与 Moonbeam 交互", "text": ""}, {"location": "tokens/connect/metamask/#introduction", "title": "简介", "text": "<p>开发人员可以利用 Moonbeam 的以太坊兼容性功能将 MetaMask 等工具集成到他们的 dApp 中。 这样，他们就可以使用 MetaMask 提供的注入库与区块链进行交互。</p> <p>目前，MetaMask 可以配置为连接到以下几个网络：Moonbeam、Moonriver、Moonbase Alpha 测试网和一个 Moonbeam 开发节点。</p> <p>如果您已经安装了 MetaMask，您可以轻松地将 MetaMask 连接到您选择的网络：</p> 连接到 Moonbeam 连接到 Moonriver 连接到 Moonbase Alpha <p>Note</p> <p>MetaMask 将会弹出窗口，请求您授予添加自定义网络的权限。 一旦您批准了这些权限，MetaMask 将切换您当前的网络。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "tokens/connect/metamask/#install-the-metamask-extension", "title": "安装 MetaMask 扩展", "text": "<p>首先，您需要从 Chrome 商店安装一个全新的默认 MetaMask。下载、安装并初始化扩展后，请按照入门指南进行操作。在其中，您需要创建一个钱包，设置密码，并存储您的秘密备份短语(这可以直接访问您的资金，所以请确保将其存储在安全的地方)。</p>"}, {"location": "tokens/connect/metamask/#setup-a-wallet", "title": "设置钱包", "text": "<p>安装 MetaMask 后，设置将自动打开一个新任务，并显示欢迎屏幕。在这里，您有两种选择：</p> <ul> <li>创建新钱包 - 您将完成一些步骤以获得新的种子短语。确保您安全地存储此短语，并且不要公开分享</li> <li>导入现有钱包 - 您已经存储了一个种子短语，并且您想从该恢复短语中恢复一个帐户</li> </ul> <p></p> <p>选择适合您需要的选项后，请按照步骤操作，您应该一切准备就绪。</p> <p>Note</p> <p>通过更改所谓的地址索引，可以从种子短语中派生多个帐户。默认情况下，当从种子短语创建或导入帐户时，您将获得地址索引为 0 的帐户。您只需在主 Metamask 屏幕中添加新帐户即可获得其他索引。</p>"}, {"location": "tokens/connect/metamask/#import-accounts", "title": "导入账户", "text": "<p>创建钱包或导入现有钱包后，如果您持有私钥，您也可以将任何账户导入到 MetaMask 中。</p> <p>在本示例中，您将使用开发账户的私钥。点击账户切换器按钮，使用私钥导入账户。也就是显示 账户 1 的地方。</p> <p></p> <p>接下来，点击 导入账户。</p> <p></p> <p>最后，输入您要导入的账户的私钥。例如，您可以使用 Moonbeam 开发节点中预先注资的账户之一。本指南使用 Gerald 的密钥。输入私钥后，点击 导入。</p> 开发账户地址和私钥 <ul> <li> <p>Alith:</p> <ul> <li>Public Address: <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>Private Key: <code>0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133</code></li> </ul> </li> <li> <p>Baltathar:</p> <ul> <li>Public Address: <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>Private Key: <code>0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b</code></li> </ul> </li> <li> <p>Charleth:</p> <ul> <li>Public Address: <code>0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</code></li> <li>Private Key: <code>0x0b6e18cafb6ed99687ec547bd28139cafdd2bffe70e6b688025de6b445aa5c5b</code></li> </ul> </li> <li> <p>Dorothy:</p> <ul> <li>Public Address: <code>0x773539d4Ac0e786233D90A233654ccEE26a613D9</code></li> <li>Private Key: <code>0x39539ab1876910bbf3a223d84a29e28f1cb4e2e456503e7e91ed39b2e7223d68</code></li> </ul> </li> <li> <p>Ethan:</p> <ul> <li>Public Address: <code>0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB</code></li> <li>Private Key: <code>0x7dce9bc8babb68fec1409be38c8e1a52650206a7ed90ff956ae8a6d15eeaaef4</code></li> </ul> </li> <li> <p>Faith:</p> <ul> <li>Public Address: <code>0xC0F0f4ab324C46e55D02D0033343B4Be8A55532d</code></li> <li>Private Key: <code>0xb9d2ea9a615f3165812e8d44de0d24da9bbd164b65c4f0573e1ce2c8dbd9c8df</code></li> </ul> </li> <li> <p>Goliath:</p> <ul> <li>Public Address: <code>0x7BF369283338E12C90514468aa3868A551AB2929</code></li> <li>Private Key: <code>0x96b8a38e12e1a31dee1eab2fffdf9d9990045f5b37e44d8cc27766ef294acf18</code></li> </ul> </li> <li> <p>Heath: </p> <ul> <li>Public Address: <code>0x931f3600a299fd9B24cEfB3BfF79388D19804BeA</code></li> <li>Private Key: <code>0x0d6dcaaef49272a5411896be8ad16c01c35d6f8c18873387b71fbc734759b0ab</code></li> </ul> </li> <li> <p>Ida: </p> <ul> <li>Public Address: <code>0xC41C5F1123ECCd5ce233578B2e7ebd5693869d73</code></li> <li>Private Key: <code>0x4c42532034540267bf568198ccec4cb822a025da542861fcb146a5fab6433ff8</code></li> </ul> </li> <li> <p>Judith: </p> <ul> <li>Public Address: <code>0x2898FE7a42Be376C8BC7AF536A940F7Fd5aDd423</code></li> <li>Private Key: <code>0x94c49300a58d576011096bcb006aa06f5a91b34b4383891e8029c21dc39fbb8b</code></li> </ul> </li> <li>Gerald:<ul> <li>Public Address: <code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code></li> <li>Private Key: <code>0x99b3c12287537e38c90a9219d4cb074a89a16e9cdb20bf85728ebd97c343e342</code></li> </ul> </li> </ul> <p></p> <p>您最终应该得到一个导入的 账户 2，如下所示：</p> <p></p>"}, {"location": "tokens/connect/metamask/#connect-metamask-to-moonbeam", "title": "将 MetaMask 连接到 Moonbeam", "text": "<p>一旦您安装了 MetaMask 并创建或导入了一个帐户，您就可以将其连接到任何基于 Moonbeam 的网络。为此，请执行以下步骤：</p> <ol> <li>点击左上角的网络选择器菜单</li> <li>选择 添加网络</li> </ol> <p></p> <p>接下来，转到页面底部并点击 手动添加网络：</p> <p></p> <p>在这里，您可以为以下网络配置 MetaMask：</p> <p>===     \"Moonbeam\"     |         Variable          |                                      Value                                       |     |:-------------------------:|:--------------------------------------------------------------------------------:|     |       Network Name        |                                    <code>Moonbeam</code>                                    |     |          RPC URL          |                     <code>https://rpc.api.moonbeam.network</code>                     |     |         Chain ID          | <code>1284</code> (hex: <code>0x504</code>) |     |     Symbol (Optional)     |                                      <code>GLMR</code>                                      |     | Block Explorer (Optional) |                     <code>https://moonscan.io</code>                     |</p> <p>===     \"Moonriver\"     |         Variable          |                                       Value                                        |     |:-------------------------:|:----------------------------------------------------------------------------------:|     |       Network Name        |                                    <code>Moonriver</code>                                     |     |          RPC URL          |                     <code>https://rpc.api.moonriver.moonbeam.network</code>                      |     |         Chain ID          | <code>1285</code> (hex: <code>0x505</code>) |     |     Symbol (Optional)     |                                       <code>MOVR</code>                                       |     | Block Explorer (Optional) |                     <code>https://moonriver.moonscan.io/</code>                      |</p> <p>===     \"Moonbase Alpha\"     |         Variable          |                                      Value                                       |     |:-------------------------:|:--------------------------------------------------------------------------------:|     |       Network Name        |                                 <code>Moonbase Alpha</code>                                 |     |          RPC URL          |                        <code>https://rpc.api.moonbase.moonbeam.network</code>                         |     |         Chain ID          | <code>1287</code> (hex: <code>0x507</code>) |     |     Symbol (Optional)     |                                      <code>DEV</code>                                       |     | Block Explorer (Optional) |                     <code>https://moonbase.moonscan.io/</code>                     |</p> <p>===     \"Moonbeam Dev Node\"     |         Variable          |                                         Value                                          |     |:-------------------------:|:--------------------------------------------------------------------------------------:|     |       Network Name        |                                     <code>Moonbeam Dev</code>                                     |     |          RPC URL          |                          <code>http://127.0.0.1:9944</code>                          |     |         Chain ID          | <code>1281</code> (hex: <code>0x501</code>) |     |     Symbol (Optional)     |                                         <code>DEV</code>                                          |     | Block Explorer (Optional) |                      <code>https://moonbeam-explorer.netlify.app/</code>                       |</p> <p>为此，请填写以下信息：</p> <ol> <li>网络名称 - 代表您要连接的网络的名称</li> <li>RPC URL - 网络的 RPC 端点</li> <li>Chain ID - 以太坊兼容网络的链 ID</li> <li>符号 - （可选）网络原生代币的符号。例如，对于 Moonbeam，该值为 GLMR</li> <li>区块浏览器 - （可选）区块浏览器 的 URL</li> <li>验证所有信息后，点击 保存</li> </ol> <p></p> <p>添加网络后，您将被重定向到一个屏幕，声明您已成功添加一个网络。此外，系统将提示您切换到 Moonbase Alpha，这是本示例中添加的网络。</p> <p></p>"}, {"location": "tokens/connect/metamask/#interact-with-the-network", "title": "与网络互动", "text": "<p>一旦您将 Metamask 连接 到任何基于 Moonbeam 的网络，您就可以通过以下方式开始使用您的钱包：</p> <ul> <li>向另一个地址发送代币转账</li> <li>将 ERC-20 添加到 Metamask 并与之互动</li> <li>将 ERC-721 添加到 Metamask 并与之互动</li> </ul>"}, {"location": "tokens/connect/metamask/#initiate-a-transfer", "title": "发起转账", "text": "<p>本节演示了如何将一个简单的 Token 转账到另一个地址，作为使用 Metamask 和 Moonbeam 的一个例子。</p> <p>若要执行此操作，请按照以下步骤操作：</p> <ol> <li>确保您已连接到正确的网络</li> <li>确保您已选择要用于转账的帐户</li> <li>在 Metamask 钱包的主屏幕上，单击发送</li> </ol> <p></p> <p>接下来，您可以输入要向其发送 Token 的地址。在此示例中，选择了一个已导入到 Metamask 的钱包，称为 Bob。</p> <p></p> <p>在下一个屏幕上，请按照以下步骤操作：</p> <ol> <li>输入要发送的 Token 数量</li> <li>验证所有信息是否正确，然后单击下一步</li> </ol> <p></p> <p>最后，确认所有与 Gas 相关的参数和费用都正确。在验证一切正常后，单击确认。此时，您的交易已发送到网络！</p> <p></p> <p>确认交易后，您将返回到钱包的主屏幕，在那里您将看到交易显示为“待处理”。不到一分钟后，交易应显示为“已确认”。如果单击您的交易，您可以查看更多详细信息并在区块浏览器中查看它。</p> <p></p>"}, {"location": "tokens/connect/metamask/#add-an-erc20-token", "title": "添加 ERC-20 代币", "text": "<p>要将 ERC-20 代币添加到您的 MetaMask 钱包，您需要使用其地址导入代币：</p> <ol> <li>确保您已切换到 MetaMask 中的 Tokens 选项卡</li> <li>点击 Import tokens</li> <li>输入您要导入的代币的合约地址。Token symbol 和 Token decimal 字段将自动填充，但如果需要，您可以编辑 Token symbol</li> <li>点击 Next</li> </ol> <p></p> <p>接下来，您将能够查看代币导入详细信息。要完成导入，您可以点击 Import。</p> <p></p> <p>在 Tokens 选项卡下，您将能够看到代币以及该代币的帐户余额。</p> <p></p>"}, {"location": "tokens/connect/metamask/#add-an-erc721-token", "title": "添加 ERC-721 代币", "text": "<p>要将 ERC-721 添加到您的 MetaMask 钱包，您需要代币的地址：</p> <ol> <li>确保您已切换到 MetaMask 中的NFTs选项卡</li> <li>点击导入 NFT</li> <li>输入您要导入的 NFT 的地址和代币 ID</li> <li>点击导入</li> </ol> <p></p> <p>导入 NFT 后，您将能够在 NFTs 选项卡中看到 NFT 的预览。您可以单击 NFT 以查看更多详细信息。</p> <p></p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "tokens/connect/on-ramps/", "title": "法币入口服务将为 Moonbeam 收购 GLMR", "text": ""}, {"location": "tokens/connect/on-ramps/#_1", "title": "简介", "text": "<p>与dApps互动或在Moonbeam上部署智能合约需要用户持有GLMR代币，用于支付网络交易费用（gas）。为了帮助用户获取GLMR，有几种可靠的入口服务可用于将本地货币（法币）转换为GLMR。本指南涵盖了两个受欢迎的选项 - Transak和Onramp - 每个都提供不同的支付方式和功能，以满足个人需求。这些平台支持银行转账、信用卡和移动支付解决方案，提供安全且受监管的方式来获取GLMR代币。</p> <p>您可以在Moonbeam dApp上找到当前支持的入口列表。请注意，这些服务的可用性可能因司法管辖区而异。有关更多信息，请访问相应入口的网站。</p>"}, {"location": "tokens/connect/on-ramps/#transak", "title": "Transak", "text": "<p>使用 Transak 是为 Moonbeam 网络购买 GLMR 代币的直接方式。该过程从 Transak 开始，选择 GLMR 作为所需的加密货币。用户选择其当地货币和购买金额，然后查看相关的费用和处理时间详细信息。下一步需要输入目的地 Moonbeam 钱包地址。对于银行转账和其他法定支付方式，必须通过提供有效的身份证明文件来完成一次性 KYC 验证过程。通过选定的方式（银行转账、信用卡或其他支持的选项）完成付款后，Transak 会处理交易并将 GLMR 代币直接发送到指定的钱包地址。交货时间因选择的付款方式而异，从银行卡付款的近乎即时到银行转账的最多 2 个工作日不等。</p>"}, {"location": "tokens/connect/on-ramps/#onramp", "title": "Onramp", "text": "<p>Onramp 提供了一个无缝的法币到加密货币的网关，用于购买 GLMR 代币，通过他们的平台支持超过 400 种不同的加密货币。该过程首先使用简单的基于电话的 OTP 登录系统进行验证。登录后，平台会显示交易详情，包括 GLMR 金额和当前市场价格，以供确认。根据地理位置，Onramp 会显示相关的银行账户详细信息和可用的付款方式。通过选定的方式完成付款后，Onramp 会处理转换的所有方面——从付款处理到法规遵从和钱包管理。确认存款后，该平台会自动以当前市场价格购买 GLMR，然后启动自动提款到指定的 Moonbeam 钱包地址。对于较大的交易，可能需要额外的 KYC 验证，但该平台会在内部管理所有合规性要求，以确保顺利的体验。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "tokens/connect/polkadotjs/", "title": "如何使用 Polkadot.js Apps 与 Moonbeam 互动", "text": ""}, {"location": "tokens/connect/polkadotjs/#introduction", "title": "介绍", "text": "<p>作为 Polkadot 平行链，Moonbeam 使用统一账户结构，允许您通过一个以太坊样式的地址与 Substrate (Polkadot) 功能和 Moonbeam 的 EVM 进行交互。这种统一的账户结构意味着您无需同时维护 Substrate 和以太坊账户即可与 Moonbeam 进行交互，而是可以使用一个以太坊私钥来完成所有操作。</p> <p>Polkadot.js Apps 界面原生支持 H160 地址和 ECDSA 密钥。因此，在本教程中，您可以查看以太坊账户在 Polkadot.js Apps 上的集成。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/).  <p>Note</p> <p>Polkadot.js Apps 正在逐步淘汰对存储在浏览器缓存中的本地账户的支持。建议您使用像 Talisman 这样的浏览器扩展将您的账户注入到 Polkadot.js Apps 中。</p>"}, {"location": "tokens/connect/polkadotjs/#connect-polkadotjs-apps", "title": "将 Polkadot.js 应用程序连接到 Moonbeam", "text": "<p>首次启动 Polkadot.js 应用程序 时，您可能已连接到所需的网络，也可能未连接。</p> <p>您可以通过单击左上角的徽标来更改所选网络，您将在其中找到按主网、测试网和本地网络组织的列表。每个网络都可以在以下部分找到：</p> 网络 部分 Moonbeam Polkadot &amp; Parachains Moonriver Kusama &amp; Parachains Moonbase Alpha 测试网络 Moonbeam 开发节点 开发 <p>选择正确的网络后，您可以滚动回顶部并单击 切换。</p> <p></p> <p>切换后，Polkadot.js 网站不仅会连接到所选网络，而且每个网络的徽标和样式也会发生变化。</p> <p></p>"}, {"location": "tokens/connect/polkadotjs/#creating-or-importing-an-h160-account", "title": "在 Polkadot.js Apps 中创建或导入 H160 帐户", "text": "<p>Note</p> <p>出于安全考虑，建议不要将密钥存储在本地浏览器中。更安全的方法是使用浏览器扩展程序，如 Talisman，将您的帐户注入到 Polkadot.js Apps 中。</p> <p>在本节中，您将学习如何创建新帐户或将现有的 MetaMask 帐户导入到 Polkadot.js Apps 中。首先，需要一个先决步骤。作为逐步淘汰对本地存储在浏览器缓存中的帐户的支持的一部分，您需要在“设置”选项卡中启用对帐户本地存储的支持。为此，请按照以下步骤操作：</p> <ol> <li>导航到“设置”选项卡</li> <li>在“浏览器内帐户创建”标题下，选择“允许本地浏览器内帐户存储”</li> <li>点击“保存”</li> </ol> <p></p> <p>现在，您可以返回 Polkadot.js Apps 的帐户页面 并继续执行以下步骤：</p> <ol> <li>导航到“帐户”部分</li> <li>点击“添加帐户”按钮</li> </ol> <p></p> <p>这将打开一个向导弹出窗口，指导您完成将帐户添加到 Polkadot.js Apps 界面的过程：</p> <ol> <li>点击下拉菜单</li> <li>将选择从“助记词”更改为“私钥”，这允许您通过私钥添加帐户</li> </ol> <p>Note</p> <p>目前，您只能通过私钥在 Polkadot.js 中创建或导入帐户。如果稍后尝试将此帐户导入到以太坊钱包（如 MetaMask），则使用助记词执行此操作将导致不同的公共地址。这是因为 Polkadot.js 使用 BIP39，而以太坊使用 BIP32 或 BIP44。</p> <p></p> <p>接下来，如果要创建新帐户，请确保存储向导显示的私钥。如果要导入现有帐户，请输入您可以从 MetaMask 导出的私钥。</p> <p>Note</p> <p>切勿泄露您的私钥，因为它们可以直接访问您的资金。本指南中的步骤仅用于演示目的。</p> <p>确保在私钥中包含前缀，即 <code>0x</code>。如果输入的信息正确，则相应的公共地址应出现在窗口的左上角，然后点击“下一步”。</p> <p></p> <p>要完成向导，您可以设置帐户名称和密码。收到确认消息后，您应该在主“帐户”选项卡中看到具有相应余额的地址：在本例中，是 Bob 的地址。此外，您可以覆盖 MetaMask 扩展程序，以查看两个余额是否相同。</p> <p></p>"}, {"location": "tokens/connect/polkadotjs/#sending-a-transaction-through-substrates-api", "title": "通过 Substrate 的 API 发送交易", "text": "<p>现在，为了展示 Moonbeam 的统一账户方案的潜力，您可以使用 Polkadot.js Apps 通过 Substrate API 进行转账。请记住，您正在使用以太坊式 H160 地址与 Substrate 交互。为此，您可以导入另一个帐户。</p> <p>接下来，点击 Bob 的发送按钮，这将打开另一个向导，引导您完成发送交易的流程。</p> <ol> <li>设置发送至地址</li> <li>输入要发送的金额，本例中为 1 DEV 代币</li> <li>准备就绪后，点击进行转账按钮</li> </ol> <p></p> <p>然后，系统会提示您输入密码并签名并提交交易。交易确认后，您应该会看到每个帐户的余额已更新。</p> <p></p> <p>就这样！我们很高兴能够在 Polkadot.js Apps 中支持 H160 账户，因为我们相信这将大大增强 Moonbeam 网络及其以太坊兼容功能的用户体验。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "tokens/connect/subwallet/", "title": "使用 SubWallet 与 Moonbeam 交互", "text": ""}, {"location": "tokens/connect/subwallet/#introduction", "title": "介绍", "text": "<p>Moonbeam 的开发者和用户在钱包方面有多种选择。得益于 Moonbeam 完美的以太坊兼容性，Moonbeam 支持各种流行的钱包，包括 SubWallet。</p> <p>SubWallet 是一款综合性的 Web3 钱包，原生支持 Substrate 和以太坊账户。虽然 Moonbeam 是一个基于 Substrate 的区块链，但它有一个 统一账户系统，该系统用以太坊风格的账户和密钥取代了默认的 Substrate 风格的账户和密钥。由于 SubWallet 支持以太坊风格的账户，您可以使用 SubWallet 与您的 Moonbeam 账户进行交互。</p> <p>本指南将带您完成所有必要的步骤，从安装 SubWallet 到设置钱包、将其连接到 Moonbeam 以及发送资金。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "tokens/connect/subwallet/#install-subwallet", "title": "安装 SubWallet", "text": "<p>您可以通过几种方式与 SubWallet 进行交互：它有浏览器扩展、移动应用程序和可从 Web 访问的仪表板。</p> <p>您可以访问 SubWallet 的下载页面 并下载适合您平台的 SubWallet 来开始使用。</p> <p>如果您选择使用可从 Web 访问的仪表板，则无需下载任何内容。您可以在 web.subwallet.app 访问该仪表板。</p> <p>移动应用程序、浏览器扩展和 Web 仪表板的界面非常相似，因此您可以调整以下说明（重点介绍浏览器扩展）以适用于移动应用程序和 Web 仪表板。</p>"}, {"location": "tokens/connect/subwallet/#setup-a-wallet", "title": "设置钱包", "text": "<p>下载 SubWallet 浏览器扩展程序后，系统会提示您设置钱包。您可以从以下选项中进行选择：</p> <ul> <li>创建新帐户 - 允许您通过创建密码和生成种子词来创建一个全新的帐户</li> <li>导入帐户 - 允许您使用种子词、JSON 文件、私钥或通过二维码导入现有帐户</li> <li> <p>附加帐户 - 允许您在没有私钥的情况下连接到帐户。您可以使用此方法连接到冷存储钱包（如 Keystone）或仅查看帐户。使用仅查看帐户，您将无法转移资金或与您的帐户互动；您只能查看帐户余额</p> <p>Note</p> <p>浏览器扩展程序支持 Ledger，但移动应用程序尚不支持。移动应用程序对 Ledger 的支持即将推出！</p> </li> <li> <p>连接钱包 - 仅在 Web 仪表板上可用 - 允许您连接到浏览器扩展程序钱包。您可以使用此方法轻松连接到您使用 SubWallet 浏览器扩展程序或另一个钱包（如 MetaMask）创建的帐户</p> </li> </ul> <p>以下部分将提供有关使用 SubWallet 创建新帐户 和 导入现有帐户 的分步说明。</p> <p>如果您要附加帐户，您可以在 SubWallet 的帐户管理文档 中找到分步说明。同样，如果您要在 Web 仪表板上连接钱包，您可以在 SubWallet 的连接扩展程序文档 中找到说明。</p>"}, {"location": "tokens/connect/subwallet/#create-a-new-account", "title": "创建新账户", "text": "<p>创建一个新账户将生成一个助记词，可以从中派生多个以太坊和 Substrate 账户。默认情况下，SubWallet 将生成一个以太坊账户和一个 Substrate 账户，但您可以轻松地从同一个助记词派生更多账户。要与 Moonbeam 互动，您需要使用以太坊账户。点击创建新账户开始。</p> <p></p> <p>在接下来的屏幕上，系统将提示您创建一个密码来保护您的新钱包：</p> <ol> <li>输入一个至少包含 8 个字符的密码</li> <li>再次输入密码以确认</li> <li>点击继续</li> </ol> <p></p> <p>然后，系统会提示您备份您的助记词。这是非常重要的一步，特别是考虑到您可以稍后从此助记词派生其他账户。</p> <ol> <li> <p>查看您的助记词并将其保存在安全的地方</p> <p>Remember</p> <p>您永远不应与任何人分享您的助记词（助记符）或私钥。这会使他们可以直接访问您的资金。本指南仅用于教育目的。</p> </li> <li> <p>安全存储您的助记词后，点击我已经把它保存在安全的地方</p> </li> </ol> <p></p> <p>Note</p> <p>如果您在移动应用程序上创建新帐户，则必须重新输入您的助记词以验证您是否已存储它。这些词必须按正确的顺序输入。</p> <p>创建密码并保存助记词后，您将连接到您的帐户。您可以随时添加其他账户。</p>"}, {"location": "tokens/connect/subwallet/#import-an-account", "title": "导入账户", "text": "<p>要将现有帐户导入 SubWallet，您可以选择导入帐户。</p> <p></p> <p>在随后的屏幕上，选择您希望导入现有帐户的方式。您可以选择从助记词导入、从 Polkadot.{js} 导入、通过 MetaMask 私钥导入和通过二维码导入。</p> <p>如果您选择从助记词导入，从助记词导入帐户时可能会出现一些不兼容问题。例如，Trust Wallet 和 SafePal 是与 SubWallet 不兼容的钱包。如果您遇到不兼容问题，SubWallet 建议创建一个新钱包。</p> <p>如果您选择从 Polkadot.{js} 导入，您需要确保该帐户是在 Polkadot.js 中通过私钥创建的。如果它是用助记词创建的，并且您尝试将其导入到 SubWallet，则将使用不同的公共地址。这是因为 Polkadot.js 使用 BIP39，而 Ethereum 使用 BIP32 或 BIP44。</p> <p></p> <p>如果您通过助记词导入您的帐户，您可以选择您的帐户类型为 Substrate (Polkadot) 或 EVM (Ethereum)，或两者兼有。Moonbeam 使用 Ethereum 样式的帐户，因此您需要选择 Ethereum 来导入基于 Moonbeam 的网络的帐户。</p> <p></p> <p>完成导入过程后，系统将提示您输入密码以保护您的新钱包：</p> <ol> <li>输入至少包含 8 个字符的密码</li> <li>再次输入密码以确认它</li> <li>点击“继续”</li> </ol> <p></p> <p>接下来，您将能够提供相关的助记词、私钥、JSON 文件或二维码，您可以立即开始使用您的新帐户。您可以随时添加其他帐户。</p>"}, {"location": "tokens/connect/subwallet/#add-additional-accounts", "title": "添加其他帐户", "text": "<p>在您创建新帐户或将现有帐户导入 SubWallet 后，您可以按照以下步骤添加其他帐户：</p> <ol> <li>点击帐户下拉菜单</li> <li>从屏幕底部选择一个选项。您可以点击创建新帐户，点击导入按钮导入现有帐户，或点击附加按钮附加到现有冷存储钱包或仅查看帐户</li> </ol> <p></p> <p>如果您要创建新帐户，则可以选择使用新种子短语创建或从现有帐户派生。如果您要使用新的种子短语创建新帐户，则需要选择帐户类型并备份帐户，类似于创建新帐户部分中的说明。如果您选择派生新帐户，系统将提示您选择要从中派生帐户的现有帐户。</p> <p>如果您要导入新帐户，则需要选择是使用种子短语、JSON 文件、MetaMask 私钥还是二维码导入，然后重复导入帐户部分中概述的过程。</p> <p>如果要附加帐户，您可以在 SubWallet 的帐户管理文档上找到分步说明。</p>"}, {"location": "tokens/connect/subwallet/#connect-subwallet-to-moonbeam", "title": "将 SubWallet 连接到 Moonbeam", "text": "<p>要为 Moonbeam 配置 SubWallet，请选择搜索令牌图标旁边的自定义你的资产显示图标。</p> <p></p> <p>要添加 Moonbeam，你可以：</p> <ol> <li>搜索“Moon”以查看所有基于 Moonbeam 的网络，或搜索特定网络</li> <li>切换开关以连接到网络</li> </ol> <p></p> <p>如果你尝试连接到本地 Moonbeam 开发节点，你可以从左上角选择汉堡菜单，这将带你到设置页面。</p> <p></p> <p>从设置菜单中，单击管理网络。</p> <p></p> <p>单击右上角的 + 图标，然后输入网络配置。你还可以从此菜单管理和连接到其他网络。</p> <p></p> <p>默认情况下，所有余额在 SubWallet 中都是隐藏的，但是如果按下显示余额图标，则可以切换余额可见性。</p> <p></p>"}, {"location": "tokens/connect/subwallet/#interact-with-the-network", "title": "与网络互动", "text": "<p>一旦您将 SubWallet 连接 到任何基于 Moonbeam 的网络，您就可以开始使用您的钱包，方式包括：</p> <ul> <li>从另一个地址接收代币</li> <li>向另一个地址发送代币</li> <li>将代币添加到 SubWallet 并与之互动</li> </ul>"}, {"location": "tokens/connect/subwallet/#receive-a-token", "title": "接收代币", "text": "<p>要从另一个账户接收代币，您需要向交易方展示您的钱包地址，他们可以将资产发送到该地址。</p> <p>要复制您的地址，请点击获取地址图标。</p> <p></p> <p>如果您有多个帐户，并且从帐户下拉菜单中选择了所有帐户，则需要选择要将资产发送到的接收帐户。否则，请确保您连接的帐户（显示在屏幕顶部）是您要将资产发送到的帐户。这应该是您的 Moonbeam 帐户，它是一个以太坊风格的地址。</p> <p></p> <p>接下来，您可以搜索并选择您想要接收的代币。在本例中，选择的是 DEV。</p> <p></p> <p>Note</p> <p>SubWallet 支持接收跨链代币，所以请务必检查代币名称下的链标志是否与您想要的链匹配。</p> <p>您将看到与您的帐户关联的二维码和地址。仔细检查显示的地址是否为以太坊风格的帐户。</p> <p></p> <p>现在您只需要向发送者展示二维码或地址即可。</p>"}, {"location": "tokens/connect/subwallet/#send-a-transaction", "title": "发送交易", "text": "<p>要开始将一个简单的 Token 转移到 Moonbeam 上的另一个地址，您可以点击发送图标。</p> <p></p> <p>接下来，您可以按照以下步骤操作：</p> <ol> <li> <p>指定要发送的资产和目标链</p> <p>Note</p> <p>某些 Token 允许跨链转移，因此在选择目标网络时，您可以选择下拉菜单以查看可用选项。</p> </li> <li> <p>输入目标地址，也可以使用地址簿或扫描收款人的二维码来完成</p> <p>Note</p> <p>如果您使用的是移动应用程序，请点击下一步继续。</p> </li> <li> <p>输入要发送的 Token 数量</p> </li> <li>查看交易详情，然后按转移</li> </ol> <p></p> <p>在下一个屏幕上，您将能够查看交易详情并提交交易。如果交易详情看起来没问题，您可以点击批准以发送交易。</p> <p></p> <p>发送交易后，您将能够查看交易详情。</p> <p>就这样！有关如何使用 SubWallet 的更多信息，请参阅 SubWallet 的文档。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "tokens/connect/talisman/", "title": "使用 Talisman 与 Moonbeam 交互", "text": ""}, {"location": "tokens/connect/talisman/#introduction", "title": "简介", "text": "<p>作为 Polkadot 平行链，Moonbeam 使用统一账户结构，允许您通过单个以太坊风格的地址与 Substrate (Polkadot) 功能和 Moonbeam 的 EVM 进行交互。这种统一账户结构意味着您无需维护 Substrate 和以太坊账户即可与 Moonbeam 进行交互 - 相反，您可以使用单个以太坊私钥完成所有操作。</p> <p>Polkadot.js Apps 支持通过 Talisman 等扩展程序注入到浏览器中的 H160 账户。请注意，Polkadot.js Apps 正在逐步淘汰对本地存储在浏览器缓存中的账户的支持。虽然您可以继续使用您通过 Polkadot.js Apps 导入并本地存储在浏览器中的任何帐户，但您将无法添加任何新帐户。这意味着您需要使用像 Talisman 这样的扩展程序。此外，通常认为从像 Talisman 这样的扩展程序注入您的帐户比直接将帐户存储在浏览器中更安全。</p> <p>本指南将包括在 Talisman 中设置帐户并使用它通过 Polkadot.js Apps 与 Moonbeam 交互的所有步骤。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "tokens/connect/talisman/#setting-up-talisman", "title": "设置 Talisman", "text": "<p>Talisman 是一个原生支持 Substrate (Polkadot) 和 Ethereum 账户的加密钱包。Talisman 钱包浏览器扩展程序可在 Google Chrome 和 Brave 上使用，相应的资产仪表板可在 app.talisman.xyz 访问</p> <p>首先，下载并安装 Talisman 扩展程序。扩展程序打开后，系统会提示您创建新钱包或导入现有钱包。就本演示而言，您将创建一个新钱包。在以下屏幕上，系统将提示您创建一个密码来保护新钱包。</p> <p></p> <p>请记住</p> <p>Talisman 不需要您备份助记词，但会在屏幕底部提醒您。如果您不备份助记词，您可能会丢失所有资产。</p> <p>要备份您新创建的钱包，请按照以下步骤操作：</p> <ol> <li>按 立即备份</li> <li>输入您的 Talisman 钱包的密码</li> <li>按 查看恢复短语 并将其存储在安全的地方</li> </ol> <p></p>"}, {"location": "tokens/connect/talisman/#setting-up-talisman-to-connect-to-testnets", "title": "设置 Talisman 以连接到测试网", "text": "<p>Talisman 可以在您启用以太坊账户后与所有 Moonbeam 网络配合使用。您还可以通过点击扩展程序左上角的 Talisman 徽标，在投资组合选项卡中查看所有网络中的余额。默认情况下，Talisman 会隐藏您的测试网帐户余额。但是，您可以通过以下步骤进行更改：</p> <ol> <li>打开 Talisman 扩展程序，然后点击 Talisman 徽标</li> <li>选择设置</li> <li>选择以太坊网络</li> <li>点击启用测试网</li> </ol> <p></p>"}, {"location": "tokens/connect/talisman/#connecting-talisman-to-moonbase-alpha-polkadot.js-apps", "title": "将 Talisman 连接到 Moonbeam 和 Polkadot.js 应用", "text": "<p>将 Talisman 连接到 Polkadot.js 应用中基于 Moonbeam 的网络非常简单。请记住，如果您想连接到 Moonbase Alpha，您需要启用测试网。</p> <p>要连接到基于 Moonbeam 的网络，在本例中为 Moonbase Alpha 测试网，请前往 Moonbase Alpha Polkadot.js 应用。Talisman 扩展程序将提示您选择要与 Polkadot.js 应用一起使用的帐户。如果它没有自动弹出，您可以打开 Talisman 扩展程序并按顶部的已连接/未连接按钮。要配置 Talisman 以在 Polkadot.js 应用上与 Moonbeam 网络正确交互，您应该执行以下步骤：</p> <ol> <li>选中 显示以太坊帐户 旁边的框</li> <li>选择您要连接到 Polkadot.js 应用的帐户。在本示例中，它只是我的以太坊帐户。这是 Talisman 分配的默认名称，您可以根据需要重命名</li> <li>按连接 1。该值将根据您连接的帐户数量而变化</li> </ol> <p></p> <p>您的 Talisman 钱包现已连接到 Polkadot.js 应用。刷新 Polkadot.js 应用后，您应该在 Polkadot.js 应用的帐户页面 中看到您的 Talisman 帐户。首次启动 Polkadot.js 应用 时，您可能已连接到所需的网络，也可能未连接。您可以通过单击左上角的徽标，然后向下滚动到测试网络部分，选择 Moonbase Alpha，然后滚动回顶部并单击切换，将所选网络更改为 Moonbase Alpha TestNet。</p> <p></p> <p>切换后，Polkadot.js 网站不仅会连接到 Moonbase Alpha，还会更改其样式以完美匹配。</p> <p></p>"}, {"location": "tokens/connect/talisman/#adding-a-new-account-to-talisman", "title": "向 Talisman 添加新帐户", "text": "<p>在本节中，您将学习如何创建新帐户，或将已有的 MetaMask 帐户导入到 Polkadot.js Apps 中。</p> <ol> <li>打开 Talisman 扩展程序，然后单击左上角的 Talisman 徽标</li> <li>选择 添加帐户</li> <li>选择 新建帐户</li> <li>选择 Ethereum 作为帐户类型</li> <li>为您的新帐户命名</li> <li>按 创建</li> </ol> <p></p> <p>虽然我们的新帐户已成功创建，但 Polkadot.js Apps 尚未意识到这一点。 要将新帐户连接到 Polkadot.js Apps，请按照 Polkadot.js Apps 中的以下步骤操作：</p> <ol> <li>打开 Talisman 扩展程序，然后按 已连接/未连接 按钮</li> <li>确保已选中 显示 Eth 帐户</li> <li>单击您要连接的帐户。 如果选中该帐户，则该帐户旁边的绿点将亮起</li> </ol> <p></p>"}, {"location": "tokens/connect/talisman/#sending-a-transaction-through-substrates-api", "title": "通过 Substrate 的 API 发送交易", "text": "<p>现在，为了展示 Moonbeam 的统一账户方案的潜力，您可以使用 Polkadot.js Apps 通过 Substrate API 进行转账。请记住，您正在使用以太坊风格的 H160 地址与 Substrate 进行交互。为此，您可以添加另一个账户。在 Talisman 中，账户已重命名为熟悉的 Alice 和 Bob 账户。要将一些 DEV 资金从 Alice 发送到 Bob，请按照以下步骤操作：</p> <p>点击 Alice 的发送按钮，这将打开另一个向导，指导您完成发送交易的过程。</p> <ol> <li>设置发送到地址</li> <li>输入要发送的金额，在本例中为 4 个 DEV 代币</li> <li>准备就绪后，点击进行转账按钮</li> <li>在 Talisman 弹窗中批准交易</li> </ol> <p></p> <p>交易确认后，您应该会看到每个账户的余额已更新。</p> <p></p> <p>就这样！这些步骤演示了在 Polkadot.js Apps 中使用 Talisman 与注入的 H160 账户进行交互的简易性和强大的安全性。所有这些都得益于 Moonbeam 的统一账户结构，这是 Moonbeam 致力于提供最佳用户体验的绝佳示例。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "tokens/connect/trezor/", "title": "使用 Trezor 硬件钱包与 Moonbeam 交互", "text": ""}, {"location": "tokens/connect/trezor/#introduction", "title": "介绍", "text": "<p>硬件钱包提供了一种更安全的加密货币存储方式，因为用于签署交易的私钥是离线存储的。在撰写本文时，Trezor 提供了两种硬件钱包解决方案：Trezor One 和 Trezor Model T。</p> <p>由于 Moonbeam 与 Ethereum 完全兼容，您可以使用 Trezor 设备在 Moonbeam 上签署交易！</p> <p>本教程向您展示如何在 Moonbase Alpha 上开始使用 Trezor 硬件钱包。本指南仅说明了 Trezor Model T 设备的步骤，但您也可以按照 Trezor One 的步骤进行操作。</p> <p>请注意，您的 Trezor 设备将签署连接到 MetaMask 的任何网络中的交易。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "tokens/connect/trezor/#checking-prerequisites", "title": "检查先决条件", "text": "<p>在开始之前，请将 Trezor Suite 更新到可用的最新版本。另外，请确保您的 Trezor 硬件钱包正在运行最新的固件。Trezor wiki 提供了关于如何更新 Trezor One 和 Trezor Model T 设备固件的教程。</p> <p>在撰写本文时，使用了以下版本：</p> <ul> <li>Trezor Suite 21.5.1</li> <li>Trezor One 固件 v1.10.0</li> <li>Trezor Model T 固件 v2.4.0</li> </ul> <p>此外，您需要 MetaMask 作为您的 Trezor 设备和 Moonbase Alpha 之间的媒介。请确保您的 MetaMask 已连接到 Moonbase Alpha。请注意，您的 Trezor 设备将签署连接到 MetaMask 网络的交易。</p>"}, {"location": "tokens/connect/trezor/#importing-your-trezor-account-to-metamask", "title": "将您的 Trezor 帐户导入 MetaMask", "text": "<p>首先，您需要设置一个钱包（标准钱包或隐藏钱包）。连接您的 Trezor 设备、将其解锁并在 Trezor Suite 中设置一个钱包。接下来，要将您的 Trezor Ethereum 帐户导入 MetaMask，请执行以下步骤：</p> <ol> <li>点击右上角的徽标以展开菜单</li> <li>选择 连接硬件钱包</li> </ol> <p></p> <p>之后，系统会提示您选择要在 MetaMask 中使用的硬件钱包。在撰写本文时，仅支持 Ledger 和 Trezor 硬件钱包。如果您已准备好 Trezor 设备，请执行以下步骤：</p> <ol> <li>选择 Trezor 徽标</li> <li>点击 继续</li> </ol> <p></p> <p>点击该按钮后，应会显示一个名为 TrezorConnect 的新选项卡，您需要在其中配对设备。如果您的 Trezor Suite 已打开并已连接设备，则不需要此操作。在这里，点击 配对设备。</p> <p></p> <p>在下一个屏幕上，请执行以下步骤：</p> <ol> <li>点击 检查设备。这将打开一个菜单，显示您要连接到哪个 Trezor 设备（如果有）</li> <li>选择您要使用的 Trezor 设备</li> <li>点击 连接</li> </ol> <p></p> <p>连接设备后，您需要允许 MetaMask 读取其公钥。因此，请点击 允许本次会话一次。或者，您也可以选中 不再询问 复选框。</p> <p></p> <p>接下来，系统会询问您是否要导出您的 Ethereum 帐户的公钥（选项卡被裁剪并在下图中标记为 1）。之后，系统会提示您选择是否使用 Trezor 的密码选项（选项卡被裁剪并在图像中标记为 2）。如果要使用默认钱包，只需点击 进入。否则，请参阅 Trezor 关于密码钱包的指南文章。</p> <p></p> <p>如果 MetaMask 能够成功连接到您的 Trezor 设备，您应该会看到一个包含五个 Ethereum 样式帐户的列表。如果不是，请仔细检查您是否已将 Trezor 设备正确连接到计算机并已解锁。您也可以在打开 Trezor Suite 应用程序的情况下重复该过程。</p> <p>从此包含五个 Ethereum 帐户的列表中，请执行以下步骤：</p> <ol> <li>选择您要从 Trezor 设备导入的帐户</li> <li>点击 解锁</li> </ol> <p></p> <p>如果您已成功导入 Trezor Ethereum 样式帐户，您应该会在主 MetaMask 屏幕中看到它，如下图所示：</p> <p></p> <p>您现在已成功从 Trezor 设备导入了与 Moonbeam 兼容的帐户，并且可以开始使用您的硬件钱包签署交易。</p>"}, {"location": "tokens/connect/trezor/#signing-a-transaction-using-your-trezor", "title": "使用您的 Trezor 设备签署交易", "text": "<p>如果您已成功地将您的 Trezor 帐户导入到 MetaMask，您就可以使用您的 Trezor 设备在 Moonbeam 上签署交易。本教程将向您展示如何在 Moonbase Alpha 测试网上发送一个简单的交易，但它也适用于其他的 Moonbeam 生态系统网络。</p> <p>首先，确保您的 Trezor 帐户已充值 DEV 代币。接下来，点击 发送 按钮。</p> <p></p> <p>此时会弹出一个 <code>TrezorConnect</code> 标签页，请求允许从您的设备读取公钥，并准备您的 Trezor 设备以进行交易和数据签名。准备就绪后，点击 允许本次会话。您也可以选择勾选 不再询问 复选框。</p> <p></p> <p>与标准交易一样，设置接收者地址，输入要发送的代币数量，检查交易的详情并确认。这将启动您 Trezor 设备中的交易签名向导。在此，请按照以下步骤操作：</p> <ol> <li>检查所有交易详情。请注意，该代币与 MetaMask 连接的网络相对应。在这种情况下，它是 DEV 代币而不是 UNKN！</li> <li>检查完所有详情后，按住按钮确认</li> </ol> <p>Note</p> <p>在撰写本文时，所有 Moonbeam 相关网络的代币名称始终显示为 <code>UNKN</code>。请注意，正在处理的代币是与 MetaMask 连接的网络相对应的代币。</p> <p></p> <p>在您批准交易后，MetaMask 会立即将其发送到网络。一旦交易被确认，它将在 MetaMask 的主屏幕上显示为 发送。</p> <p></p> <p>就这样！您已经使用您的 Trezor 硬件钱包在 Moonbase Alpha 上签署了一笔交易。</p> <p>使用您的 Trezor 设备与智能合约交互的过程类似。在确认交易之前，请务必仔细检查您 Trezor 设备上正在签名的数据。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "tokens/governance/proposals/", "title": "如何在 OpenGov (治理 v2) 中提议行动", "text": ""}, {"location": "tokens/governance/proposals/#introduction", "title": "简介", "text": "<p>提案是提交到链上的一种方式，代币持有者可以在其中建议系统执行某项操作。提案是治理系统的核心要素之一，因为它们是社区成员提出行动/变更的主要工具，其他代币持有者可以对这些提案进行投票。</p> <p>在 Moonbeam 中，用户可以使用他们的 H160 地址和私钥（即他们的常规以太坊帐户）来创建提案并对其进行投票！</p> <p>本指南将概述在 OpenGov（治理 v2）中提交提案，供其他代币持有者投票的流程，并提供逐步说明。本指南将向您展示如何在 Moonbase Alpha 上提交提案，但它可以很容易地适用于 Moonbeam 和 Moonriver。有关如何在 OpenGov 中投票的单独指南，请参见如何在 OpenGov 中进行提案投票。</p> <p>有关 Moonbeam 治理系统的更多信息，请参阅 Moonbeam 上的治理 概述页面。</p>"}, {"location": "tokens/governance/proposals/#definitions", "title": "定义", "text": "<p>本指南的一些关键参数如下：</p> <ul> <li>Proposal — an action or item, defined by the preimage hash, being proposed by a token holder and open for consideration and discussion by token holders</li> <li> <p>Referendum — a proposal that is up for token-holder voting. Each referendum is tied to a specific proposal for a change to the Moonbeam system including values for key parameters, code upgrades, or changes to the governance system itself</p> </li> <li> <p>Preimage hash — hash of the proposal to be enacted. The first step to make a proposal is to submit a preimage. The hash is just its identifier. The proposer of the preimage can be different than the user that proposes that preimage as a formal proposal</p> </li> <li> <p>Preimage deposit — amount of tokens that the proposer needs to bond when submitting a preimage. It is calculated as the sum of a base deposit per network plus a fee per byte of the preimage being proposed</p> </li> <li> <p>提交保证金 - 提交公开投票提案的最低保证金金额</p> </li> <li> <p>Lead-in Period — the initial proposal voting and discussion period. At this stage, proposals are in an undecided state until they pass some criteria for the given Track. The criteria include:</p> <ul> <li>Prepare Period — the minimum time the referendum needs to wait before it can progress to the next phase after submission</li> <li>Capacity — limit for the number of referenda on a given Track that can be decided at once</li> <li>Decision Deposit — the minimum deposit amount required for a referendum to progress to the decision phase after the end of the Lead-in Period. Since each Track has a defined Capacity, this deposit is larger than the submission deposit, and its goal is to mitigate spam </li> </ul> </li> </ul> <p>请务必查看每个网络和跟踪的治理参数。</p>"}, {"location": "tokens/governance/proposals/#roadmap-of-a-proposal", "title": "提案路线图", "text": "<p>本指南将介绍提案路线图中概述的前几个步骤，如下面的图表所示。您将学习如何将您的提案想法提交到 Moonbeam 社区论坛，提交 preimages，并使用 preimage 哈希在链上提交您的提案。</p> <p>您可以在治理概述页面的 提案路线图 部分找到完整的解释。</p> <p></p>"}, {"location": "tokens/governance/proposals/#submitting-your-idea-to-the-forum", "title": "向社区论坛提交您的想法", "text": "<p>在深入了解提交提案的步骤之前，您需要熟悉 Moonbeam 社区论坛。强烈建议您在论坛上发布任何提案之前，先征求反馈。在提交预图像和提案之前，您应该预留五天的时间，让社区讨论并提供对 Moonbeam 论坛帖子的反馈。</p> <p>要访问 Moonbeam 社区论坛，您必须是 Moonbeam Discord 社区的成员。然后，您可以注册使用您的 Discord 凭据访问论坛。</p> <p>登录后，您可以浏览最新的讨论、加入对话，并为您可能有的提案想法创建自己的讨论。在首次发帖或评论之前，请务必熟悉 常见问题解答，以了解社区准则。</p> <p></p> <p>当您准备好创建包含提案详细信息的帖子时，您可以前往治理页面，然后单击民主提案。</p> <p></p> <p>从那里，您可以单击打开草稿并开始使用提供的模板起草您的提案。确保更新帖子的标题并添加任何可选标签，例如，如果提案是针对 Moonbeam 网络的，则添加 Moonbeam。标题应遵循与预先填充的标题相同的格式：[提案：XX][状态：想法] 提案标题。例如，[提案：XX][状态：想法] 注册 XC-20 xcMYTOK。一旦提案已在链上正式提交，则需要使用提案 ID 更新 XX。</p> <p></p> <p>填写完提案详细信息后，您可以单击创建主题以将其保存到论坛并开始讨论您的想法。根据您收到的反馈，您可以在继续提交提案之前更新提案。</p>"}, {"location": "tokens/governance/proposals/#proposing-an-action", "title": "提出一项行动", "text": "<p>本节介绍在 Moonbase Alpha 上使用 OpenGov（治理 v2）创建提案的流程。这些步骤可以适用于 Moonbeam 和 Moonriver。</p> <p>要在网络中提出提案，您可以使用 Polkadot.js Apps 界面。为此，您需要首先导入一个以太坊风格的帐户（H160 地址），您可以按照创建或导入 H160 帐户 指南进行操作。在本示例中，导入了三个帐户，并使用了超级原始名称命名：Alice、Bob 和 Charlie。</p> <p></p> <p>对于提案，您可以选择您想要提出的任何内容，只需确保将其分配给正确的 Origin 和 Track，以便它具有执行操作的正确权限。</p> <p>在本指南中，该操作将使用 General Admin Origin 和 Track 设置链上备注。</p>"}, {"location": "tokens/governance/proposals/#submitting-a-preimage-of-the-proposal", "title": "提交提案的 Preimage", "text": "<p>第一步是提交提案的 preimage。这是因为大型 preimage 的存储成本可能非常高昂，因为 preimage 包含有关提案本身的所有信息。通过此配置，一个具有更多资金的帐户可以提交 preimage，而另一个帐户可以提交提案。</p> <p>首先，导航至 Moonbase Alpha 的 Polkadot.js Apps 界面。与治理相关的所有内容都位于 治理 选项卡下，包括 preimage。因此，从 治理 下拉列表中，您可以选择 Preimage。进入后，单击 添加 preimage 按钮。</p> <p></p> <p>在这里，您需要提供以下信息：</p> <ol> <li>选择您要从中提交 preimage 的帐户</li> <li>选择您要与之交互的 pallet 以及要提议的可调度函数（或操作）。您选择的操作将决定需要在以下步骤中填写的字段。在本例中，它是 system pallet 和 remark extrinsic</li> <li>输入调度 extrinsic 所需的任何其他字段。对于此示例，您可以以十六进制或 ascii 格式输入备注</li> <li>复制 preimage 哈希。这代表提案。您将在提交实际提案时使用此哈希</li> <li>单击 提交 preimage 按钮并签署交易</li> </ol> <p></p> <p>Note</p> <p>请确保您复制 preimage 哈希，因为提交提案需要它。</p> <p>请注意，preimage 的存储成本可以计算为基本费用（每个网络）加上每个建议的 preimage 的每字节费用。</p> <p>提交交易后，您将在 Polkadot.js Apps 界面的右上角看到一些确认信息，并且 preimage 将被添加到 preimages 列表中。</p>"}, {"location": "tokens/governance/proposals/#submitting-a-proposal-v2", "title": "提交提案", "text": "<p>一旦您提交了原像（请查看上一节），路线图的下一个主要里程碑就是提交与之相关的提案。为此，请从治理下拉菜单中选择Referenda，然后点击提交提案。</p> <p>为了提交提案，您需要选择要使用哪个 Origin 类来执行您的提案。选择错误的 Track/Origin 可能会导致您的提案执行失败。有关每个 Origin 类的更多信息，请参阅 Moonbeam 治理概述页面上的通用定义部分。</p> <p></p> <p>在这里，您需要提供以下信息：</p> <ol> <li>选择您要从中提交提案的账户（在本例中为 Alice）</li> <li>选择要将提案提交到的 Track。与 Track 关联的 Origin 将需要有足够的权限来执行提议的操作。对于本示例，要添加链上备注，您可以从提交 Track 下拉菜单中选择 2 / General Admin</li> <li>在 origin 下拉菜单中，选择 Origins</li> <li>在 Origins 下拉菜单中，选择 Origin，在本例中为 GeneralAdmin</li> <li>输入与提案相关的原像哈希。在本示例中，它是上一节中 <code>system.remark</code> 原像的哈希值</li> <li>选择颁布的时间，可以是在特定数量的区块之后，也可以是在特定区块。它必须满足最低颁布期，您可以在 OpenGov 的治理参数中找到该参数</li> <li>输入区块数或要在其上颁布提案的特定区块</li> <li>点击提交提案并签署交易</li> </ol> <p></p> <p>Note</p> <p>代币可能会被锁定一段不确定的时间，因为无法知道提案何时可能成为全民公投（如果会成为全民公投）。</p> <p>提交交易后，您将在 Polkadot.js Apps 界面的右上角看到一些确认信息。您还应该在相关的 Origin 部分看到列出的提案，其中显示了提议的操作、提案人等。</p> <p>如果您使用用于创建提案的同一个账户登录Polkassembly，您将能够编辑提案的描述，以包含指向Moonbeam 社区论坛上提案讨论的链接。这是一个有用的步骤，因为虽然 Polkassembly 会为每个提案自动生成帖子，但它没有提供有关提案内容的上下文信息。</p> <p>该提案现在处于导入期，可以进行投票了！为了使您的提案从导入期进入下一阶段，至少需要经过准备期，以便有足够的时间讨论提案，所选 Track 中需要有足够的容量，并且需要提交决策保证金。保证金可以由任何代币持有人支付。如果没有足够的容量或尚未提交决策保证金，但准备期已经过去，则该提案将保留在导入期，直到满足所有条件为止。</p> <p>要了解如何对提案进行投票，请参阅如何在 OpenGov 中对提案进行投票指南。</p>"}, {"location": "tokens/governance/treasury-spend/", "title": "如何提出国库支出提案", "text": ""}, {"location": "tokens/governance/treasury-spend/#introduction", "title": "简介", "text": "<p>国库支出提案允许社区成员为有益于 Moonbeam 网络的项目申请资金，例如基础设施改进、资源、活动和生态系统工具。国库委员会审查提案并权衡在 Moonbeam 论坛收到的社区反馈。 但是，最终的赞成/否决决定权在于委员会。 有关国库委员会结构的更多信息，请参见国库页面。</p> <p>在本指南中，您将学习如何准备和提交国库支出提案，并了解国库提案的完整生命周期。</p>"}, {"location": "tokens/governance/treasury-spend/#definitions", "title": "定义", "text": "<p>本指南的一些关键参数如下：</p> <ul> <li>国库地址 — 国库资金累积和支付的地址</li> <li>受益人 — 将收到国库提案资金的地址，例如 Moonbeam Safe 多重签名</li> <li>价值 — 请求的金额，如果国库提案获得通过，将分配给受益人地址</li> </ul>"}, {"location": "tokens/governance/treasury-spend/#submitting-your-idea-to-the-forum", "title": "向论坛提交您的想法", "text": "<p>正如上述顺利流程中所述，国库提案的第一步是将提案提交到 Moonbeam 论坛。您需要在 Moonbeam 论坛 上拥有一个帐户并登录后才能提交国库支出提案。要提交国库支出提案，请按照以下步骤操作：</p> <ol> <li>在 治理 部分 中，单击 新主题。通过在 治理 部分中启动主题，提案将预先填充一个模板，以确保您涵盖所有必要的要点</li> <li>提供提案的标题</li> <li>输入提案的内容，包括：标题 和 提案状态、简短的 摘要、动机、项目概述 和 团队经验、理由、任何 关键术语、总体成本、国库资金的使用、技术规范 和 实施步骤</li> <li>选择 Moonbeam 或 Moonriver 作为标签，以表明您的国库提案适用于哪个网络</li> <li>按 创建主题</li> </ol> <p></p>"}, {"location": "tokens/governance/treasury-spend/#next-steps", "title": "后续步骤", "text": "<p>提出支出后，无需执行任何后续步骤。国库委员会的成员将完成所有链上操作。 如果获得国库委员会的批准，国库付款将自动交付给指定的受益人。有关国库委员会投票过程的更多信息，请参见国库页面。</p>"}, {"location": "tokens/governance/voting/", "title": "如何在 Governance v2 中对提案进行投票：OpenGov", "text": ""}, {"location": "tokens/governance/voting/#introduction", "title": "简介", "text": "<p>公民投票是简单、包容和基于权益的投票方案。每个公民投票都附带一个提案，该提案建议采取行动。在 OpenGov 中，每个公民投票都有一个特定的 Origin 类，提案将通过该类执行，并且每个 Origin 都有其自己的 Track，提案将通过该 Track 进行处理。虽然公民投票通过一个共同的流程完成，但批准要求是特定于轨道的。</p> <p>代币持有者可以使用他们自己的代币对公民投票进行投票，包括那些锁定在质押中的代币。投票的权重由两个因素决定：锁定的代币数量和锁定持续时间（称为信念）。这是为了确保有经济投入以防止出售选票。因此，您愿意锁定代币的时间越长，您的投票权重就越大。您也可以选择完全不锁定代币，但投票权重会大大降低。</p> <p>在 Moonbeam 中，用户可以使用他们的 H160 地址和私钥（即他们常规的以太坊帐户！）来创建提案并进行投票！</p> <p>本指南将概述在 Governance v2: OpenGov 中对公民投票进行投票的过程，并提供分步说明。本指南将向您展示如何在 Moonbase Alpha 上进行投票，但它可以很容易地适用于 Moonbeam 和 Moonriver。</p> <p>Note</p> <p>本页面从更技术的层面介绍了如何投票的机制。代币持有者可以利用诸如 Polkassembly 等平台，使用户界面更友好的方式进行投票。</p>"}, {"location": "tokens/governance/voting/#definitions", "title": "定义", "text": "<p>本指南的一些关键参数如下：</p> <ul> <li> <p>Voting — a mechanism for token holders to support (Aye), oppose (Nay), or remain neutral (Abstain) on a proposal. For Aye and Nay, the voting weight is determined by both the number of tokens locked and the lock duration (Conviction). Abstain votes do not receive additional weighting</p> <ul> <li>Conviction — the time that token holders voluntarily lock their tokens when voting; the longer they are locked, the more weight their vote has</li> <li>Lock balance — the number of tokens that a user commits to a vote (note, this is not the same as a user's total account balance) Moonbeam uses the concept of voluntary locking, which allows token holders to increase their voting power by locking tokens for a longer period of time. Specifying no Lock Period means a user's vote is valued at 10% of their lock balance. Specifying a greater Conviction increases voting power. For each increase in Conviction (vote multiplier), the Lock Periods double</li> </ul> </li> <li> <p>最大投票数 — 每个账户的并发投票最大数</p> MoonbeamMoonriverMoonbase Alpha <p>text 512 votes</p> <p>text 512 votes</p> <p>text 512 votes</p> </li> <li> <p>Approval — minimum \"Aye\" votes as a percentage of overall Conviction-weighted votes needed for approval</p> </li> <li> <p>Support — the minimum portion of Aye and Abstain votes (ignoring conviction) needed as a percentage of the total active supply for a proposal to pass. Nay votes do not count toward Support</p> </li> <li> <p>Lead-in Period — the initial proposal voting and discussion period. At this stage, proposals are in an undecided state until they pass some criteria for the given Track. The criteria include:</p> <ul> <li>Prepare Period — the minimum time the referendum needs to wait before it can progress to the next phase after submission</li> <li>Capacity — limit for the number of referenda on a given Track that can be decided at once</li> <li>Decision Deposit — the minimum deposit amount required for a referendum to progress to the decision phase after the end of the Lead-in Period. Since each Track has a defined Capacity, this deposit is larger than the submission deposit, and its goal is to mitigate spam </li> </ul> </li> <li> <p>决定期 - 代币持有人继续对全民公投进行投票。如果全民公投在期限结束时未通过，则将被拒绝，并且决策保证金将被退还</p> </li> <li>确认期 - 决定期内的一段时间，在此期间，全民公投需要保持足够的批准和支持才能获得批准并进入颁布期</li> <li> <p>颁布期 - 指定的时间，该时间在创建提案时定义，至少要满足批准的全民公投在可以发送之前等待的最短时间</p> </li> <li> <p>Vote Delegation — a voter can give their voting power, including Conviction voting, to another token holder (delegate), who may be more knowledgeable and able to make specific decisions</p> </li> <li>Multirole Delegation — the ability to delegate voting power on a Track-by-Track basis, where a token holder can specify different delegates for each Track</li> </ul> <p>有关特定于 Track 的参数（例如决定期、确认期和颁布期的长度、批准和支持要求等）的概述，请参阅治理概述页面的 OpenGov（治理 v2）的治理参数部分。</p>"}, {"location": "tokens/governance/voting/#roadmap-of-a-proposal", "title": "提案路线图", "text": "<p>本指南将介绍如何对公共提案进行投票，如下面的提案路线图图中突出显示的步骤所示。除了学习如何对提案进行投票外，您还将了解提案如何通过导入期、决策和确认期以及执行期。</p> <p>您可以在治理概述页面上找到有关 OpenGov 提案的开心路径的完整说明。</p> <p></p>"}, {"location": "tokens/governance/voting/#forum-discussion", "title": "论坛讨论", "text": "<p>针对民主投票的全民公投只有是或否两种结果。但是，代币持有者的意见往往比简单的赞成或反对更为细致。因此，强烈建议您在提出任何提案之前，先在 Moonbeam 社区论坛 上发布帖子。</p> <p>论坛的关键作用是提供一个讨论平台，让提案者在进行链上操作之前能够收到社区的反馈。在论坛上创建帖子既快速又简单，如使用 Moonbeam 社区论坛 指南中所示。论坛中有对应于每种提案类型的类别，包括民主、金库和赠款提案。虽然此步骤是可选的，但解释提案的详细信息并跟进提出的任何问题，可能会增加该倡议被接受并随后被社区通过的机会。</p> <p></p>"}, {"location": "tokens/governance/voting/#voting-on-a-referendum", "title": "对全民公投进行投票", "text": "<p>本节介绍如何在 Moonbase Alpha 上的 OpenGov（治理 v2）中对公共全民公投进行投票。这些步骤可以适用于 Moonbeam 和 Moonriver。本指南假定已经有一个正在进行的全民公投。如果您想对一个公开的全民公投进行投票，您可以按照这些说明来学习投票方法。</p> <p>要在网络上对提案进行投票，您需要使用 Polkadot.js Apps 界面。为此，您需要首先导入一个以太坊样式的帐户（H160 地址），您可以通过遵循创建或导入 H160 帐户 指南来完成。在本示例中，导入了三个帐户，并使用超级原始名称对其进行了命名：Alice、Bob 和 Charlie。</p> <p></p> <p>首先，您需要导航到 Moonbase Alpha 的 Polkadot.js Apps 界面。与治理相关的所有内容都位于“治理”选项卡下。要查看所有全民公投，您可以从“治理”下拉菜单中选择“全民公投”。在“全民公投”页面上，您将看到一个按轨道组织的全民公投列表。要查看特定全民公投的详细信息，您可以单击描述旁边的箭头。操作和描述旁边的数字称为全民公投索引。</p>"}, {"location": "tokens/governance/voting/#submit-decision-deposit", "title": "如何通过贡献决策保证金来支持提案", "text": "<p>为了使全民公投从准备阶段进入决定阶段，必须提交决策保证金。提案的作者或任何其他代币持有者都可以提交此保证金。保证金根据提案的轨道而有所不同。</p> <p>例如，在 General Admin Track 中的全民公投在 Moonbase Alpha 链上的决策保证金为 500。</p> <p>从 Polkadot.js Apps 上的全民公投列表 中，您可能会注意到一些提案处于准备中状态。如果全民公投需要提交决策保证金，您将看到一个决策保证金按钮。要提交保证金，您可以直接点击此按钮。</p> <p></p> <p>然后按照以下步骤从特定账户提交保证金：</p> <ol> <li>选择从账户存款。此账户不必是提案的作者；它可以来自任何代币持有者。但是，如果提案被认为是恶意的，决策保证金将被销毁。因此，在存入保证金之前，建议您进行尽职调查，以确保提案不是恶意的</li> <li>全民公投 ID 和决策保证金字段将根据全民公投及其所属的轨道自动为您填充</li> <li>点击存入保证金并签署交易</li> </ol> <p></p> <p>一旦存入保证金，Polkadot.js Apps 将更新并显示支付决策保证金的账户以及保证金金额。现在，此全民公投离满足准备阶段的标准又近了一步。</p> <p>如果准备阶段已过，并且在 General Admin Track 中有足够的空间进行全民公投，则此提案将进入决定阶段。</p>"}, {"location": "tokens/governance/voting/#how-to-vote", "title": "如何投票", "text": "<p>您可能已经注意到，在导入期内，投票不是必需的。但是，在决定期内，投票至关重要。本节中的步骤将适用于导入期和决定期内的全民投票。</p> <p>要投票并锁定支持或反对全民投票的代币，您可以先单击要投票的全民投票旁边的“投票”按钮。</p> <p></p> <p>然后，您可以按照以下步骤填写投票的详细信息：</p> <ol> <li>选择用账户投票</li> <li>选择您希望如何对全民投票进行投票。您可以选择赞成以支持全民投票，选择反对以反对它，或者如果您想指定一个“赞成”投票值和一个“反对”投票值，则选择拆分</li> <li>输入投票值</li> <li>设置投票信念，它决定了您的投票权重 (<code>vote_weight = tokens * conviction_multiplier</code>)。请参阅信念乘数文档以获取更多信息</li> <li>单击“投票”并签署交易</li> </ol> <p></p> <p>Note</p> <p>先前图像中显示的锁定时间不应作为参考，因为它们可能会发生变化。</p> <p>要查看您的投票和所有其他全民投票的投票如何影响批准和支持曲线，您可以单击“投票”按钮旁边的箭头。您会注意到有两个图表，每个曲线一个。如果将鼠标悬停在图表上，您可以看到特定区块所需的最低赞成或支持以及当前的赞成或支持。</p> <p></p> <p>Moonbase Alpha 上通用管理通道中的提案将具有以下特征：</p> <ul> <li>批准曲线从 100% 开始于 Day 0 并在 Day 4 时变为 80%</li> <li>支持曲线从 50% 开始于 Day 0 并在 Day 7 时变为 10%</li> <li>全民投票以 0% 的“赞成”票开始决定期（在导入期内无人投票）</li> <li>代币持有者开始投票，并且批准度在 Day 4 时增加到 80% 以上的值</li> <li>如果在确认期（14400 个区块，约 1 day）内满足批准和支持阈值，则全民投票获得批准</li> <li>如果在决定期内未满足批准和支持阈值，则提案将被拒绝。请注意，需要在确认期的持续时间内满足阈值。因此，如果满足阈值，但在确认期完成之前决定期结束，则提案将被拒绝</li> </ul> <p>在下面的图像中，您会注意到已收到足够的批准和支持，因此确认期正在进行中。如果全民投票保持批准和支持水平，则在区块 124,962 处，确认期将结束，然后颁布期将开始。您可以将鼠标悬停在图表上，以了解有关每个期间的更多信息。假设此全民投票保持其已收到的批准和支持水平，则颁布期将在区块 132,262 处结束，并且将发送提案操作。</p> <p></p> <p>如果在确认期内全民投票没有持续收到足够的批准和支持，只要再次满足批准和支持要求并在确认期的持续时间内持续满足，它仍然有机会通过。如果全民投票进入确认期，但决定期设置为在确认期结束之前结束，则决定期实际上将延长至确认期结束。如果决定期结束并且全民投票仍未获得足够的批准和支持，则全民投票将被拒绝，并且可以退还决定保证金。</p> <p>颁布期由提案的作者在最初提交时定义，但它至少需要是最短的颁布期。</p>"}, {"location": "tokens/governance/voting/#delegate-voting", "title": "委托投票", "text": "<p>代币持有人可以选择将其投票权委托给他们信任的另一个帐户。被委托的帐户不需要采取任何特定操作。当他们投票时，投票权重（即代币乘以委托人选择的信念乘数）将添加到他们的投票中。</p> <p>随着 OpenGov（治理 v2）的推出，代币持有人甚至可以按 Track-by-Track 的方式委托其投票权，并为每个 Track 指定不同的受托人，这被称为多角色委托。</p> <p>从 Polkadot.js Apps 上的 referenda 页面，您可以单击Delegate开始。</p> <p></p> <p>然后，您可以按照以下步骤填写委托的详细信息：</p> <ol> <li>输入delegate from account，这应该是您希望从中委托投票的帐户</li> <li>选择submission track，或者如果您希望其他帐户代表您在任何 Track 上投票，请将apply delegation to all tracks滑块切换为开启</li> <li>输入delegated vote value</li> <li>设置投票信念，这决定了您的投票权重 (<code>vote_weight = tokens * conviction_multiplier</code>)。有关更多信息，请参阅 信念乘数 文档</li> <li>单击Next</li> <li>在下一个屏幕上，选择delegate to address，这应该是您希望将投票委托给的帐户</li> <li>单击Delegate并签署交易</li> </ol> <p></p> <p>现在，您选择将投票委托给的帐户将能够代表您投票。一旦此帐户投票，委托的总投票权重将分配给该帐户选择的选项。对于本示例，Baltahar 可以使用 Charleth 委托给他的投票权重，以 20000 的总权重（10000 个代币，x2 信念因子）投票赞成 referendum。</p> <p>您可以继续上述过程为每个 Track 委托一个具有不同投票权重的不同帐户。</p> <p>要取消委托，您需要前往Developer选项卡并单击Extrinsics。从那里，您可以按照以下步骤操作：</p> <ol> <li>选择您已从中委托的帐户</li> <li>选择 convictionVoting pallet 和 undelegate extrinsic</li> <li>输入 Origin 的 class。对于 General Admin Track，它是 <code>2</code>。有关 Track ID 的完整列表，请参阅 治理概述页面的 OpenGov 部分</li> <li>单击Submit transaction并签署交易</li> </ol> <p></p>"}, {"location": "tokens/governance/voting/#refund-the-decision-deposit", "title": "退还决策保证金", "text": "<p>如果一项全民投票获得批准或拒绝，则决策保证金将有资格获得退还，只要它不是因为恶意提案而被拒绝。恶意提案将导致决策保证金被削减。任何代币持有人都可以触发将保证金退还到最初放置保证金的原始帐户。要退还保证金，您可以按照Polkadot.js Apps 上的全民投票页面上的以下步骤操作。如果全民投票符合条件且保证金尚未退还，您将看到一个退还保证金按钮。因此，您可以继续单击该按钮以开始。</p> <p></p> <p>然后，要提交退款交易，您可以：</p> <ol> <li>选择您要触发退款的帐户。这不需要是最初放置存款的帐户</li> <li>单击退还保证金并签署交易</li> </ol> <p></p>"}, {"location": "tokens/governance/voting/#unlocking-locked-tokens", "title": "解锁锁定的代币", "text": "<p>当代币持有人投票时，使用的代币会被锁定，无法转移。您可以通过展开地址的帐户详细信息，在“帐户”选项卡中验证您是否有任何锁定的代币。在那里，您将看到不同类型的余额。如果您有任何代币锁定在全民公投中，您将在您的余额详细信息中看到referenda，您可以将鼠标悬停在它上面，以了解您的代币为哪个全民公投锁定的详细信息。不同的锁定状态包括：</p> <ul> <li>因正在进行的全民公投而被锁定，这意味着您已经使用了您的代币，必须等到全民公投结束，即使您已经以无锁定信念因子投票</li> <li>因选择的信念乘数而被锁定，显示剩余的区块数和时间</li> <li>锁定已过期，这意味着您现在可以取回您的代币</li> </ul> <p></p> <p>一旦锁定过期，您可以请求取回您的代币。为此，请导航到“开发者”选项卡下的“Extrinsics”菜单。在这里，需要发送两个不同的外部操作。首先，您需要提供以下信息：</p> <ol> <li>选择您要从中恢复代币的帐户</li> <li>选择您要与之交互的 pallet。在本例中，它是 <code>convictionVoting</code> pallet 和用于交易的外部操作。这将决定您需要在以下步骤中填写的字段。在本例中，它是 <code>removeVote</code> 外部操作。此步骤对于解锁代币是必要的。此外部操作也可用于从全民公投中移除您的投票</li> <li>（可选）您可以指定要移除投票的 Track ID。为此，只需切换“包含选项”滑块，并在“class u16”字段中输入 Track ID</li> <li>输入全民公投索引。这是出现在“全民公投”选项卡左侧的数字</li> <li>单击“提交交易”按钮并签署交易</li> </ol> <p></p> <p>对于下一个外部操作，您需要提供以下信息：</p> <ol> <li>选择您要从中恢复代币的帐户</li> <li>选择您要与之交互的 pallet。在本例中，它是 <code>convictionVoting</code> pallet</li> <li>选择用于交易的外部操作方法。这将决定需要在以下步骤中填写的字段。在本例中，它是 <code>unlock</code> 外部操作</li> <li>输入要移除投票锁定的 Track ID</li> <li>输入将接收解锁代币的目标帐户。在本例中，代币将返回给 Alice</li> <li>单击“提交交易”按钮并签署交易</li> </ol> <p></p> <p>一旦交易完成，锁定的代币应该被解锁。要仔细检查，您可以返回到“帐户”选项卡，并查看您的完整余额现在是可转移的。</p>"}, {"location": "tokens/manage/identity/", "title": "管理您的帐户身份", "text": ""}, {"location": "tokens/manage/identity/#introduction", "title": "简介", "text": "<p>Substrate Identity pallet 是一个开箱即用的解决方案，用于向您的链上账户添加个人信息。个人信息可以包括默认字段，如您的法定姓名、显示名称、网站、Twitter 账号、Riot（现在称为 Element）名称。您还可以利用自定义字段来包含任何其他相关信息。</p> <p>一旦您的身份信息上链，您可以向注册员请求验证您的身份。注册员将进行适当的尽职调查，以验证提交的身份信息，并根据他们的调查结果在链上提供他们的判断，您的账户旁边将出现一个绿色的复选标记。</p> <p>本指南将向您展示如何在 Moonbase Alpha TestNet 上设置身份、清除身份以及请求判断。本指南也可以调整后在 Moonbeam 和 Moonriver 上使用。</p>"}, {"location": "tokens/manage/identity/#general-definitions", "title": "通用定义", "text": "<p>要将您的信息存储在链上，您必须绑定一些资金，这些资金最终将在身份验证完成后退还。字段分为两类：默认字段和自定义字段。如果使用自定义字段，您需要为每个字段提交额外的保证金。</p> <ul> <li> <p>默认字段包括 - 您的法定姓名、显示名称、网站、Twitter 句柄、Riot（现在称为 Element）名称</p> </li> <li> <p>自定义字段包括 - 任何其他相关信息。例如，您可以包括您的 Discord 句柄</p> </li> </ul> MoonbeamMoonriverMoonbase Alpha Variable Definition Value Basic deposit The amount held on deposit for setting an identity 1.0258 GLMR Field deposit The amount held on deposit per additional field for setting an identity 0.0066 GLMR Max additional fields Maximum number of additional fields that may be stored in an ID 100 Variable Definition Value Basic deposit The amount held on deposit for setting an identity 1.0258 MOVR Field deposit The amount held on deposit per additional field for setting an identity 0.0066 MOVR Max additional fields Maximum number of additional fields that may be stored in an ID 100 Variable Definition Value Basic deposit The amount held on deposit for setting an identity 1.0258 DEV Field deposit The amount held on deposit per additional field for setting an identity 0.0066 DEV Max additional fields Maximum number of additional fields that may be stored in an ID 100"}, {"location": "tokens/manage/identity/#checking-prerequisites", "title": "检查先决条件", "text": "<p>对于本指南，您将需要以下内容：</p> <ul> <li>要在 Polkadot.js Apps 浏览器上连接到 Moonbase Alpha TestNet。您也可以按照并调整 Moonbeam 或 Moonriver 的说明进行操作。</li> <li>要将 创建或导入帐户 到 Polkadot.js Apps</li> <li>确保您已为您的帐户充值。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"}, {"location": "tokens/manage/identity/#get-started", "title": "开始", "text": "<p>根据要包含的信息，可以使用 Polkadot.js Apps 通过几种不同的方式来设置和清除身份。如果您打算仅使用默认字段注册您的身份，则可以按照通过 Accounts UI 管理身份的说明进行操作。这是设置和管理您的身份的推荐方式。</p> <p>如果您正在寻找更可定制的体验，并且想要在默认字段之外添加自定义字段，则可以按照通过 Extrinsics UI 管理身份的说明进行操作。</p> <p>Note</p> <p>请注意，建议在 Polkadot.js Apps 上使用 Accounts UI 来管理您的身份，因为它提供了一个易于使用的界面，可以强制执行字符限制。如果您使用 Extrinsics UI，请注意，您对每个字段（即名称、电子邮件等）的输入必须小于或等于 32 个字符，否则，您的信息将被截断。</p>"}, {"location": "tokens/manage/identity/#manage-via-accounts", "title": "通过帐户管理身份", "text": ""}, {"location": "tokens/manage/identity/#set-identity-accounts", "title": "设置身份", "text": "<p>要开始使用 Accounts UI 设置身份，请前往 Polkadot.js Apps 浏览器的帐户选项卡。</p> <p>您应该已经连接了一个帐户，因此您可以继续单击您的帐户名称以验证并记下您的余额。 在您发送交易以设置身份后，您提交的存款将从您的可转让余额转移到您的预留余额。</p> <p></p> <p>要设置您的身份，您需要：</p> <ol> <li>单击要为其设置身份的帐户旁边的 3 个垂直点</li> <li>将弹出一个菜单。 点击设置链上身份</li> </ol> <p></p> <p>接下来，将弹出注册和设置您身份的菜单，您可以开始填写您的信息。 您不需要为每个字段都输入信息，您可以选择只填写一个字段或者全部填写，这取决于您。 对于本例：</p> <ol> <li>设置您的显示名称</li> <li>单击电子邮件的包含字段切换按钮，然后输入您的电子邮件</li> <li>单击 Twitter 的包含字段切换按钮，然后输入您的 Twitter 句柄</li> <li>填写完您的信息并且存款金额对您来说没有问题后，单击设置身份</li> </ol> <p></p> <p>然后将提示您签署交易。 如果一切看起来都不错，您可以输入您的密码并单击签名并提交以签名并发送交易。</p> <p>您应该在右上角看到状态通知弹出。 交易确认后，您可以再次单击您的帐户名称，面板将从页面右侧滑出。 您的余额将会改变，您还会看到您的新身份信息。</p> <p></p> <p>如果身份信息与您输入的信息匹配，则您已成功设置身份！</p> <p>清除身份后，您预留余额中的存款将转回您的可转让余额。 如果您需要更改您的身份，您可以再次进行设置身份的过程。 请注意，您需要确保重新输入所有字段，即使只需要更改一个字段，否则它们将被覆盖。 除非使用自定义字段，否则您无需支付另一笔存款，但您需要支付 gas 费用。</p>"}, {"location": "tokens/manage/identity/#clear-identity-accounts", "title": "清除身份信息", "text": "<p>要从 Polkadot.js Apps UI 的账户选项卡中清除您的身份信息，您需要：</p> <ol> <li>点击您想要添加身份信息的账户旁边的 3 个垂直点</li> <li>将弹出一个菜单。点击 设置链上身份</li> </ol> <p></p> <p>身份信息菜单将会弹出，其中已经填写了您的信息。您需要点击 清除身份。</p> <p></p> <p>然后，系统会提示您签署交易。如果一切看起来都很好，您可以输入您的密码并点击 签名并提交 以签名并发送交易。</p> <p>您应该会在右上角看到状态通知弹出。交易确认后，您可以再次点击您的帐户名，面板将从页面右侧滑出。您可以看到您保留的余额已转回您的可转账余额，并且您的身份信息已被删除。</p> <p>就是这样！您已成功清除您的身份信息。如果您想添加新的身份信息，您可以随时进行。</p>"}, {"location": "tokens/manage/identity/#manage-via-extrinsics", "title": "通过外部因素管理身份", "text": ""}, {"location": "tokens/manage/identity/#set-identity-extrinsics", "title": "设置身份", "text": "<p>要使用 extrinsic 用户界面注册身份，请导航至 Polkadot.js Apps 上的Extrinsics 页面。然后，您需要：</p> <ol> <li>选择您的帐户</li> <li>从submit the following extrinsic下拉菜单中选择 identity</li> <li>然后选择 setIdentity(info) 函数</li> <li>开始填写您的身份信息。请确保对于每个字段，您的输入不超过 32 个字符<ol> <li>选择数据的格式。对于此示例，您可以使用 Raw 数据，但您也可以输入 BlackTwo256、Sha256、Keccak256 和 ShaThree256 哈希格式的数据</li> <li>以该格式输入数据</li> </ol> </li> </ol> <p></p> <p>（可选）如果您想输入自定义字段，您可以这样做：</p> <ol> <li>滚动到顶部并单击 Add item</li> <li>将出现两个字段：第一个用于字段名称，第二个用于值。请确保每个字段和值的输入都不超过 32 个字符。填写字段名称<ol> <li>选择字段名称的数据格式。同样，您可以使用 Raw 数据</li> <li>以选定的格式输入字段名称</li> </ol> </li> <li>填写值<ol> <li>选择值的数据格式。同样，您可以使用 Raw 数据</li> <li>以选定的格式输入值</li> </ol> </li> </ol> <p></p> <p>最后，一旦添加了所有身份信息，您可以滚动到页面底部并单击 Submit Transaction。</p> <p></p> <p>然后系统会提示您签署交易。请记住，每个额外的自定义字段都需要额外的存款。如果一切看起来都不错，您可以输入您的密码并单击 Sign and Submit 以签名并发送交易。</p> <p>您应该在右上角看到状态通知弹出窗口，确认交易。如果成功，您就设置了身份！恭喜！为了确保一切顺利进行并且您的身份信息看起来不错，接下来您可以确认您的身份。</p>"}, {"location": "tokens/manage/identity/#confirm-identity-extrinsics", "title": "确认身份", "text": "<p>要验证您的身份信息的添加，您可以点击开发者选项卡，然后导航至链状态。</p> <p>在链状态用户界面上，确保已选择“存储”。然后，您可以开始请求您的身份信息：</p> <ol> <li>将选择的状态查询设置为身份</li> <li>选择 identityOf(AccountId) 函数</li> <li>选择您的帐户</li> <li>点击 + 按钮以获取您的身份信息</li> </ol> <p></p> <p>您现在可以看到您已成功设置身份！一旦您清除您的身份，您保留余额中的存款将转回您的可转让余额。如果您需要更改您的身份，您可以再次进行设置身份的过程。 请注意，您需要确保重新输入所有字段，即使只需要更改一个字段，否则它们将被覆盖。 除非使用自定义字段，否则您无需支付另一笔存款，但您需要支付燃料费。</p>"}, {"location": "tokens/manage/identity/#clear-identity-extrinsics", "title": "清除身份信息", "text": "<p>要从 Polkadot.js Apps UI 的 Extrinsics 选项卡 中清除您的身份信息，您需要：</p> <ol> <li>从使用所选账户下拉列表中选择您的账户</li> <li>从提交以下 extrinsic 下拉列表中选择 identity</li> <li>然后选择 clearIdentity() 函数</li> <li>点击 Submit Transaction</li> </ol> <p></p> <p>然后，系统将提示您签署交易。如果一切正常，您可以输入密码并点击 Sign and Submit 以签署并发送交易。</p> <p>您应该会在右上角看到状态通知弹出窗口，确认交易。</p> <p>要验证您的身份信息是否已删除，您可以再次按照 确认身份信息 部分中的步骤进行操作。这次您将收到 none 的响应，而不是看到您的身份信息。这意味着您不再有与您的账户相关的任何身份信息。如果您检查您的余额，您应该会看到设置您的身份信息的初始存款已退回到您的可转移余额中。就这样！您的身份信息已清除。</p>"}, {"location": "tokens/manage/identity/#identity-judgement", "title": "身份判断", "text": "<p>提交您的身份信息后，您可以向注册员请求验证您的身份。注册员的任务是验证提交的身份信息，并可以为他们的服务设置费用。当您请求判断时，您需要指定您希望哪个注册员验证您的信息，以及您愿意为他们提供判断支付的最高费用。只有当选定的注册员收取的费用低于您指定的最高费用时，该请求才会被处理，否则交易将失败。费用将被锁定，直到注册员完成判断过程，之后费用才会转移给注册员。注册员费用是您最初创建身份时支付的押金之外的费用。</p> <p>注册员申请人通过链上民主选举产生。如果被任命的注册员做出不正确的判断或被证明不可信，他们可以通过民主程序被撤职。</p> <p>注册员将进行适当的尽职调查，以验证提交的身份信息，并根据他们的调查结果提供判断，并分配最多七个级别的可信度：</p> <ul> <li>未知 - 尚未做出判断。这是默认值</li> <li>已支付费用 - 表示用户已请求判断，且正在进行中</li> <li>合理 - 信息看起来是合理的，但没有使用法律身份文件进行深入检查</li> <li>已知良好 - 信息是正确的，并且基于对法律身份文件的审查</li> <li>已过期 - 信息曾经是好的，但现在已过期</li> <li>低质量 - 信息质量低或不精确，但可以根据需要进行更新</li> <li>错误 - 信息是错误的，可能表明有恶意。此状态无法修改，只有在整个身份被删除后才能删除</li> </ul>"}, {"location": "tokens/manage/identity/#current-registrars", "title": "当前注册人", "text": "<p>在请求身份判断时，您需要提供您希望完成请求的注册人的索引。</p> <p>目前的注册人如下：</p> MoonbeamMoonriverMoonbase Alpha 注册人 运营商 地址 索引 注册人 #0 Moonbeam 基金会 0xbE6E642b25Fa7925AFA1600C48Ab9aA3461DC7f1 0 注册人 #1 Chevdor 0xeaB597B91b66d9C3EA5E3a39e22C524c287d61a5 1 注册人 运营商 地址 索引 注册人 #0 Moonbeam 基金会 0x031590D13434CC554f7257A89B2E0B10d67CCCBa 0 注册人 #1 Chevdor 0x2d18250E01312A155E81381F938B8bA8bb4d97B3 1 注册人 运营商 地址 索引 注册人 #1 Chevdor 0x4aD549e07E96BaD335A8b99C8fd32e95EE538904 1 <p>您可以通过访问 Polkadot.js Apps，选择 开发者 选项卡，从下拉菜单中选择 链状态，并按照以下步骤操作，获取当前注册人的完整列表，包括每个注册人收取的费用：</p> <ol> <li>选择 identity 托盘</li> <li>选择 registrars 外部函数</li> <li>点击 + 按钮</li> </ol> <p></p>"}, {"location": "tokens/manage/identity/#request-judgement", "title": "请求身份判断", "text": "<p>要请求身份判断，请在Extrinsics页面中执行以下步骤：</p> <ol> <li>从使用所选帐户下拉列表中选择您的帐户</li> <li>从提交以下外部因素下拉列表中选择身份</li> <li>然后选择 requestJudgement() 函数</li> <li>输入您想要审查的注册器的索引，并提供关于您的身份信息的判断</li> <li>输入您愿意支付的最高费用（以Wei为单位）。这必须高于注册器设置的费用，否则交易将失败</li> <li>点击 提交交易</li> </ol> <p></p> <p>一旦交易完成，费用将从您的可用余额中扣除并锁定，直到判断完成。</p> <p>判断完成后，如果您已成功通过验证，则您的帐户旁边会出现一个绿色复选标记。 如果成功，您的身份将被分配以下三个可信度级别之一：低质量、合理或已知良好。 在帐户页面中，您可以点击您的帐户名以查看您的身份信息和您的身份判断结果。</p> <p></p>"}, {"location": "tokens/manage/identity/#cancel-judgement-request", "title": "取消身份判断请求", "text": "<p>如果注册人尚未完成您的判断，您可以取消该请求并取回锁定的费用。为此，请从Extrinsics页面执行以下步骤：</p> <ol> <li>从using the selected account下拉菜单中选择您的帐户</li> <li>从submit the following extrinsic下拉菜单中选择identity </li> <li>然后选择 cancelRequest() 函数</li> <li>点击 Submit Transaction</li> </ol> <p></p> <p>然后，系统将提示您签名并发送交易。一旦交易完成，您锁定的资金将退还给您。</p>"}, {"location": "tokens/manage/multisig-safe/", "title": "与 Moonbeam Safe 交互", "text": ""}, {"location": "tokens/manage/multisig-safe/#introduction", "title": "简介", "text": "<p>单签名钱包（简称 singlesig）是一种只有一个所有者持有私钥的钱包，因此可以控制该帐户持有的所有资产。此外，如果私钥丢失，则对钱包和资金的访问权限将永远丢失。</p> <p>为了解决这个问题，引入了多签名钱包（简称 multisig）。使用多重签名钱包时，会有多个所有者，因此一个所有者可能会丢失其密钥，而其他所有者仍然可以访问钱包和资金。此外，多重签名钱包可能需要阈值签名，只有在获得一定数量的批准后，提案才会作为交易执行。因此，创建了一个额外的安全层。</p> <p>为了帮助管理 singlesig 和 multisig 钱包，Gnosis Safe 被 fork 以创建 Moonbeam Safe。Safe 可以配置为多重签名合约，允许多个所有者持有资金并将其转移到 Safe 以及从 Safe 转移资金。您还可以将 Safe 配置为只有一个所有者的 singlesig 合约。</p> <p>本指南将向您展示如何在 Moonbase Alpha TestNet 上创建多重签名 Safe。您还将学习如何将 DEV 和 ERC-20 代币发送到 Safe 以及从 Safe 发送，以及如何使用 Safe 与智能合约交互。本指南适用于 Moonbeam 和 Moonriver。</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."}, {"location": "tokens/manage/multisig-safe/#checking-prerequisites", "title": "检查先决条件", "text": "<p>在深入本指南之前，您需要准备一些加载了资金的 MetaMask 账户，一些可用于发送到 Safe 的 ERC-20 代币，以及一个可与之交互的 已部署的智能合约。</p>"}, {"location": "tokens/manage/multisig-safe/#metamask-accounts", "title": "MetaMask 账户", "text": "<p>在本指南中，你将在 Moonbase Alpha 上创建一个 Safe，以便进行交互和管理资金。要连接到 Safe，你需要具备以下条件：</p> <ul> <li>已安装 MetaMask 并连接到 Moonbase Alpha</li> <li>至少有两个已加载资金的帐户。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul> <p>你至少需要两个帐户，因为你将设置一个具有 3 个所有者的多重签名 Safe，并且任何交易都需要 2/3 的确认才能执行。因此，在本指南中，你需要在至少两个帐户之间来回切换，才能确认和发送交易。</p> <p>本指南将使用以下帐户：</p> <ul> <li>Alice — 0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</li> <li>Bob — 0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</li> <li>Charlie — 0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</li> </ul>"}, {"location": "tokens/manage/multisig-safe/#erc20-tokens", "title": "ERC-20 代币", "text": "<p>在本指南的后面部分，您将学习如何向 Safe 发送和接收 ERC-20 代币。因此，您需要部署一些 ERC-20 代币并将它们添加到您的 MetaMask 帐户中。为此，您可以查看使用 Remix 部署到 Moonbeam 指南，特别是将合约部署到 Moonbeam和与基于 Moonbeam 的 ERC-20 交互部分将向您展示如何部署 ERC-20 代币并将其导入到 MetaMask 中。</p>"}, {"location": "tokens/manage/multisig-safe/#deployed-smart-contract", "title": "部署的智能合约", "text": "<p>在本指南的结尾，您将学习如何使用 Safe 与智能合约进行交互。因此，您需要部署一个智能合约来进行交互。如果您需要详细的说明，可以参考使用 Remix 将合约部署到 Moonbeam 指南。</p> <p>您可以前往 Remix 并为以下 <code>SetText.sol</code> 合约创建一个新文件：</p> <pre><code>pragma solidity ^0.8.30;\n\ncontract SetText {\n    string public text;\n\n    function setTextData(string calldata _text) public {\n        text = _text;\n    }\n}\n</code></pre> <p>这是一个简单的合约，只有一个函数 <code>setTextData</code>，它接受一个字符串并用它来设置 <code>text</code> 变量。</p> <p>您将需要合约地址和 ABI，因此请确保您已将其复制到某处或可以访问它们以供以后使用。</p>"}, {"location": "tokens/manage/multisig-safe/#create-a-safe", "title": "创建 Safe", "text": "<p>要开始创建 Safe，请导航至 Moonbeam Safe。在本指南中，您将在 Moonbase Alpha 上创建一个 Safe，但您也可以调整说明以在 Moonbeam 或 Moonriver 上创建 Safe。要切换网络，只需单击页面右上角的网络下拉菜单。</p>"}, {"location": "tokens/manage/multisig-safe/#connect-metamask", "title": "连接 MetaMask", "text": "<p>进入 Moonbase Alpha 页面后，您可以首先连接您的钱包，从而开始创建一个 Safe：</p> <ol> <li>点击 连接钱包</li> <li>选择一个钱包来连接到 Moonbeam Safe。在此示例中，您可以使用 MetaMask。如果 MetaMask 没有出现在选项列表中，请点击 显示更多 并选择 MetaMask</li> </ol> <p></p> <p>如果您尚未登录 MetaMask，系统将提示您登录。然后，系统将引导您添加和连接您的帐户，并添加和切换到 Moonbase Alpha 网络：</p> <ol> <li>选择一个帐户并连接到 Safe。您需要选择至少 3 个所有者帐户中的 2 个，然后点击 下一步。在此示例中，已选择 Alice、Bob 和 Charlie 的帐户</li> <li>点击 连接 以连接到所选帐户</li> <li>如果您未连接到 Moonbase Alpha，也没有在 MetaMask 中添加该网络，请点击 批准 以将 Moonbase Alpha 添加为自定义网络</li> <li>点击 切换网络 以将网络切换到 Moonbase Alpha</li> </ol> <p></p> <p>现在，在右上角，您可以确认您已在 Moonbase Alpha 网络上连接到您的 MetaMask 帐户。如果您使用的是开发帐户，您应该会看到 Alice 的帐户地址。如果不是，请仔细检查您的 MetaMask 并切换到 Alice 的帐户。</p>"}, {"location": "tokens/manage/multisig-safe/#create-new-safe", "title": "创建新保险箱", "text": "<p>要在 Moonbase Alpha 上创建新的保险箱，请单击创建新保险箱。您将被带到一个向导，它将引导您创建新的保险箱。通过执行这些步骤并创建您的保险箱，您同意使用条款和隐私政策。因此，在开始之前，请随时查看这些条款和政策。</p> <p></p> <p>您需要为您的保险箱指定一个名称：</p> <ol> <li>输入您的新保险箱的名称，您可以使用 <code>moonbeam-tutorial</code></li> <li>单击开始</li> </ol> <p></p> <p>接下来是向导的所有者和确认部分。在本节中，您将添加保险箱的所有者并指定阈值。阈值决定了在执行交易之前需要多少所有者确认交易。</p> <p>创建保险箱时可以使用许多不同的设置。保险箱可以有 1 个或多个所有者，以及不同的阈值级别。请注意，不建议仅使用 1 个所有者创建保险箱，因为它会造成单点故障的可能性。</p> <p>在本指南中，您将创建一个具有 3 个所有者并需要阈值为 2 的多重签名设置，因此至少需要 3 个所有者密钥中的 2 个才能通过保险箱执行交易。</p> <p>您的帐户将自动预填充为第一个所有者，但是如果您想使用其他帐户，则可以更改此设置。在此示例中，Alice 的帐户已预先填充。除了 Alice 之外，您还可以添加 Bob 和 Charlie 作为所有者：</p> <ol> <li>单击添加其他所有者</li> <li>输入 Bob 作为第二个所有者，以及他的地址：<code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>输入 Charlie 作为第三个所有者，以及他的地址：<code>0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</code></li> <li>将确认阈值设置为 3 个所有者中的 2 个</li> <li>单击审查以转到向导的最后一步</li> </ol> <p></p> <p>最后，您可以查看所有保险箱和所有者详细信息，如果一切正常：</p> <ol> <li>单击提交以创建您的新保险箱。在 Moonbase Alpha 上创建保险箱的成本大约低于 0.001 DEV 代币。MetaMask 将弹出并提示您确认交易</li> <li>单击确认以发送交易并创建保险箱</li> </ol> <p></p> <p>处理交易并创建保险箱可能需要几分钟时间，但是一旦创建完成，您应该会看到一条消息，提示“您的保险箱已成功创建”。从那里，您可以单击开始使用以加载您的保险箱并开始与之交互。</p> <p></p>"}, {"location": "tokens/manage/multisig-safe/#configure-safe", "title": "配置 Safe", "text": "<p>您可以随时管理您的 Safe，并更改创建时设置的一些参数。为此，您可以点击左侧菜单中的 Settings 选项。</p> <p></p> <p>在其中，您有以下选项：</p> <ul> <li>Safe 详情 — 允许您更改 Safe 名称。这是一个本地操作，不需要链上交互</li> <li>所有者 — 允许您发起链上提案，以添加/删除 Safe 的所有者</li> <li>策略 — 允许您发起链上提案，以更改多重签名阈值以执行交易提案</li> <li>高级 — 允许您检查 Safe 的其他参数，例如 nonce、模块和交易保护</li> </ul>"}, {"location": "tokens/manage/multisig-safe/#receive-and-send-tokens", "title": "接收和发送代币", "text": ""}, {"location": "tokens/manage/multisig-safe/#receive-tokens", "title": "接收代币", "text": "<p>既然您已经创建了您的Safe，那么您可以开始与之交互了。首先，通过向其发送一些DEV代币来加载Safe。您可以从任何拥有DEV代币的帐户向Safe发送资金。对于此示例，您可以使用Alice的帐户。将鼠标悬停在资产列表中的DEV上，以显示“发送”和“接收”按钮。然后单击“接收”。</p> <p></p> <p>将会出现一个弹窗，其中包含Safe的地址。复制地址，然后单击“完成”。</p> <p></p> <p>接下来，打开您的MetaMask以启动交易：</p> <ol> <li>单击“发送”以发送交易</li> <li>粘贴Safe的地址</li> <li>输入您要发送到Safe的DEV代币数量。对于此示例，您可以使用2个DEV代币</li> <li>单击“下一步”</li> <li>查看交易的详细信息，然后单击“确认”</li> </ol> <p></p> <p>交易将被发送，并且您的 Safe 上的 DEV 代币余额将被更新。</p>"}, {"location": "tokens/manage/multisig-safe/#send-tokens", "title": "发送代币", "text": "<p>既然您在 Safe 中有资金，您可以将资金从 Safe 发送到另一个帐户。对于此示例，您可以将 1 个 DEV 代币发送到 Bob 的地址。将鼠标悬停在资产列表中的 DEV 上，这次单击 Send。</p> <p></p> <p>将出现一个弹出窗口，您可以在其中输入收件人和要发送的 DEV 代币数量：</p> <ol> <li>输入 Bob 的地址</li> <li>从资产列表中选择 DEV</li> <li>输入 1 个 DEV 代币</li> <li>单击 Review</li> </ol> <p></p> <ol> <li>检查详细信息，然后单击 Submit。MetaMask 将会弹出，您会注意到您发送的不是交易，而是消息</li> <li>单击 Sign 以签署消息</li> </ol> <p></p> <p>现在，如果您返回到 Safe，在“Transactions”选项卡下，您应该能够看到已发起交易提案，以将 1 个 DEV 代币发送到 Bob 的地址。但是，您还应该看到仅收到 2 个确认中的 1 个，并且需要再有 1 个所有者确认交易，然后才能执行交易。</p> <p></p>"}, {"location": "tokens/manage/multisig-safe/#transaction-confirmation", "title": "交易确认", "text": "<p>对于多重签名 Safe 的所有用例，确认（或拒绝）交易提议的过程是相似的。其中一个所有者发起执行操作的提议。其他所有者可以批准或拒绝该提议。一旦达到签名阈值，任何所有者都可以在批准后执行交易提议，或者在拒绝后放弃交易提议。</p> <p>在此示例中，如果 3 个所有者中的 2 个决定拒绝该提议，那么资产将保留在 Safe 中。但是，在这种情况下，您可以从 Bob 或 Charlie 的帐户确认交易。</p> <p>在 MetaMask 中将帐户切换到 Bob 的帐户（或 Charlie 的帐户）。然后返回到以 Bob 身份连接的 Safe。确认 按钮现在应该已启用。以 Bob 的身份，继续单击确认以达到阈值并发送交易。将出现一个弹出窗口，供您批准交易：</p> <ol> <li>选中执行交易框，以便在确认后立即执行交易。您可以取消选中它，以便稍后手动执行交易</li> <li>单击提交</li> <li>MetaMask 将弹出并要求您确认交易，如果一切正常，您可以单击确认</li> </ol> <p>Note</p> <p>如果您收到错误，指出交易可能失败，则您可能需要增加 gas 限制。您可以在高级选项或 MetaMask 中执行此操作。</p> <p></p> <p>该交易将从 QUEUE 选项卡中删除，并且现在可以在 HISTORY 选项卡下找到该交易的记录。此外，Bob 的余额现在增加了 1 个 DEV 代币，而 Safe 的 DEV 代币余额减少了。</p> <p></p> <p>恭喜，您已成功地从 Safe 中接收和发送 DEV 代币！</p>"}, {"location": "tokens/manage/multisig-safe/#receive-and-send-erc20-tokens", "title": "接收和发送 ERC-20 代币", "text": ""}, {"location": "tokens/manage/multisig-safe/#receive-erc20-tokens", "title": "接收 ERC-20 代币", "text": "<p>接下来是在 Safe 中接收和发送 ERC-20 代币。您应该已经使用 MYTOK ERC-20 代币加载了您的 MetaMask。如果还没有，请参考先决条件的 ERC-20 代币 部分。</p> <p>在此示例中，您仍应连接到 Bob 的帐户。因此，您将从 Bob 的帐户向 Safe 发送 MYTOK 代币。</p> <p>您需要再次获取 Safe 的地址，您可以通过单击左上角的复制到剪贴板图标来执行此操作。复制 Safe 的地址后，打开 MetaMask：</p> <ol> <li>切换到 “资产” 选项卡，然后从列表中选择 MYTOK</li> <li>点击 发送</li> <li>粘贴 Safe 的地址</li> <li>输入要发送的 MYTOK 数量。您应该已经在 使用 Remix 部署到 Moonbeam 指南中铸造了 800 万个 MYTOK 代币。因此，在本示例中，您可以输入 1000 个 MYTOK 作为要发送的数量</li> <li>点击 下一步</li> <li>查看交易详情，然后单击确认以发送交易。</li> </ol> <p></p> <p>如果您导航回 Safe，在资产列表中，您现在应该看到 MyToken 和 1000 个 MYTOK 的余额。MyToken 可能需要几分钟才能显示，但您无需执行任何操作即可添加资产，它会自动显示。</p>"}, {"location": "tokens/manage/multisig-safe/#send-erc20-tokens", "title": "发送 ERC-20 代币", "text": "<p>现在您已经将 MYTOK 加载到您的 Safe 中，您可以将一些从 Safe 发送到另一个帐户。对于此示例，您可以将 10 个 MYTOK 发送给 Charlie。</p> <p>将鼠标悬停在资产列表中的 MyToken 上，这次点击 Send。</p> <p></p> <p>将出现一个弹出窗口，您可以在其中输入收件人和要发送的 MYTOK 代币数量：</p> <ol> <li>输入 Charlie 的地址</li> <li>从资产列表中选择 MyToken</li> <li>输入 10 个 MYTOK 代币</li> <li>点击 Review 并查看详细信息</li> </ol> <p></p> <p>如果一切正常，您可以：</p> <ol> <li>点击 Submit。MetaMask 将会弹出，您会注意到您发送的不是交易，而是消息</li> <li>点击 Sign 以签署消息</li> </ol> <p></p> <p>现在，如果您返回到 Safe，在 Transactions 选项卡下，您应该能够看到已启动了一项交易提案，以将 10 个 MYTOK 代币发送到 Charlie 的地址。但是，您还应该看到仅收到了 2 个确认中的 1 个，并且需要 1 个所有者才能确认交易才能执行。</p> <p></p> <p>您将需要将帐户切换到 Alice 或 Charlie，并确认交易以执行它。您可以按照上面 交易确认 部分中概述的相同步骤进行操作。</p> <p>一旦交易已从其他两个帐户之一确认，则该交易将移至 HISTORY 选项卡。</p> <p></p> <p>恭喜！您已成功地将 ERC-20 代币发送到 Safe 并从 Safe 中发送！</p>"}, {"location": "tokens/manage/multisig-safe/#interact-with-a-smart-contract", "title": "与智能合约交互", "text": "<p>在本节中，您将使用 Safe 与智能合约进行交互。您应该已经使用 Remix 部署了 <code>SetText.sol</code> 合约，如果还没有，请返回到先决条件的已部署智能合约部分。</p> <p>在本指南的这一部分，您应该仍然连接到 Alice 的帐户。</p> <p>从 Safe 中：</p> <ol> <li>在左侧，单击新交易</li> <li>然后选择合约交互</li> </ol> <p></p> <p>将出现合约交互弹出窗口，您可以填写合约详细信息：</p> <ol> <li>在合约地址字段中输入合约地址</li> <li>在 ABI 文本框中，粘贴 ABI</li> <li>将出现一个方法下拉列表。选择 <code>setTextData</code> 函数</li> <li>然后会出现一个 <code>_text</code> 输入字段。您可以输入任何您想要的内容，对于此示例，您可以使用 <code>polkadots and moonbeams</code></li> <li>单击审查</li> </ol> <p></p> <p>如果详细信息看起来没问题，请继续：</p> <ol> <li>单击提交。MetaMask 将弹出，您会注意到您发送的不是交易，而是消息</li> <li>单击签名以签署消息</li> </ol> <p></p> <p>现在，如果您返回 Safe，在交易选项卡下，您应该能够看到已启动了一个针对合约交互的交易提案。但是，您还应该看到只收到了 2 个确认中的 1 个，并且需要 1 个所有者才能确认交易才能执行。</p> <p></p> <p>您需要将帐户切换到 Bob 或 Charlie，并确认交易才能执行。您可以按照上面交易确认部分中概述的相同步骤进行操作。</p> <p>一旦交易已从其他两个帐户之一确认，该交易将移至 HISTORY 选项卡。</p> <p></p> <p>要仔细检查是否设置了正确的文本，您可以再次执行该过程，只是不要从方法下拉列表中选择setTextData，您可以选择text来读取 <code>text</code> 的值。这将是一个调用而不是交易，因此会出现一个调用按钮。单击它，直接在弹出窗口中，您应该看到调用的结果 <code>polkadots and moonbeams</code>。</p> <p></p> <p>恭喜，您已成功使用 Safe 与智能合约进行了交互！</p>"}, {"location": "tokens/manage/multisig-safe/#using-moonbeam-safe-apis", "title": "使用 Moonbeam Safe API", "text": "<p>有一些 API 可用于读取和与 Moonbeam、Moonriver 和 Moonbase Alpha 的 Moonbeam Safe 进行交互。</p> <p>===</p> <pre><code> text\n https://transaction.multisig.moonbeam.network/\n</code></pre> <p>===</p> <pre><code> text\n https://transaction.moonriver.multisig.moonbeam.network/\n</code></pre> <p>===</p> <pre><code> text\n https://transaction.moonbase.multisig.moonbeam.network/\n</code></pre> <p>作为使用 API 的示例，请尝试从 Moonbeam Safe API 中检索有关 Safe 的信息。在 Safe 页面中，复制您的 Safe 地址：</p> <p></p> <p>现在您可以使用该 API：</p> <ol> <li>打开相应网络的 API 页面</li> <li>向下滚动到 safes 部分，然后单击 /safes/{address}/ 端点部分以展开其面板</li> <li>点击右侧的 Try it out 按钮</li> </ol> <p></p> <p>一个大的 Execute 按钮应出现在面板中。</p> <ol> <li>将您的 Safe 地址粘贴到 address 输入框中</li> <li>按 Execute</li> <li>有关您的 safe 的信息将出现在下方</li> </ol> <p></p> <p>恭喜！您已成功使用 Moonbeam Safe 的 API。还有许多其他端点可供使用，无论是为了方便还是添加到您自己的应用程序中。</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "tokens/manage/proxy-accounts/", "title": "设置代理帐户", "text": ""}, {"location": "tokens/manage/proxy-accounts/#introduction", "title": "介绍", "text": "<p>可以设置代理账户来代表用户执行有限数量的操作，这对于保持底层账户的安全非常有用。它们允许用户将其主账户安全地保存在冷存储中，同时使代理能够主动执行功能并以主账户中代币的权重参与网络。</p> <p>可以设置代理账户来执行特定的 Substrate 功能，例如作者映射、质押、余额等。例如，这可以允许您授予受信任的个人代表您执行 collator 或 delegator 功能的权限。代理也可以用于将质押账户安全地保存在冷存储中。</p> <p>本指南将向您展示如何在 Moonbase Alpha TestNet 上设置代理帐户以进行余额转移以及如何执行代理交易。</p>"}, {"location": "tokens/manage/proxy-accounts/#checking-prerequisites", "title": "检查先决条件", "text": "<p>要学习本教程，您需要具备：</p> <ul> <li>打开 Polkadot.js Apps 并连接到 Moonbase Alpha</li> <li>在 Moonbase Alpha 上创建或拥有两个帐户</li> <li>至少一个帐户必须有 <code>DEV</code> 代币。  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul> <p>如果您在将帐户导入 Polkadot.js Apps 时需要帮助，请查看使用 Polkadot.js Apps 与 Moonbeam 交互 指南。</p>"}, {"location": "tokens/manage/proxy-accounts/#general-definitions", "title": "常规定义", "text": "<p>设置代理账户时，代理的保证金将从您的可用余额中取出，并转移到您的保留余额中。添加代理需要链上存储空间，因此需要保证金，并且每次添加或删除代理时都会重新计算保证金。从您的账户中删除所有代理后，保证金将返还到您的可用余额中。</p> <p>存款根据存款基数和存款因子计算：</p> <ul> <li>存款基数 - 为账户保留代理列表所需的金额</li> <li>存款因子 - 主账户拥有的每个代理需要保留的额外金额</li> </ul> <p>计算存款的公式为：</p> <pre><code>存款基数 + 存款因子 * 代理数量\n</code></pre> MoonbeamMoonriverMoonbase Alpha 变量 值 存款基数 10.08 GLMR 存款因子 0.21 GLMR 最大代理数 32 proxies 变量 值 存款基数 1.0008 MOVR 存款因子 0.0021 MOVR 最大代理数 32 proxies 变量 值 存款基数 1.0008 DEV 存款因子 0.0021 DEV 最大代理数 32 proxies"}, {"location": "tokens/manage/proxy-accounts/#proxy-types", "title": "代理类型", "text": "<p>创建代理帐户时，您必须选择一种代理类型，该类型将定义代理的使用方式。可用选项包括：</p> <ul> <li><code>AuthorMapping</code> - 此类型的代理帐户供收集人用于将服务从一台服务器迁移到另一台服务器</li> <li><code>CancelProxy</code> - 允许代理帐户拒绝和删除任何已宣布的代理调用</li> <li><code>Staking</code> - 允许代理帐户执行与 Staking 相关的交易，例如收集人或委托人功能，包括 <code>authorMapping()</code></li> <li><code>Governance</code> - 允许代理帐户进行与治理相关的交易，例如投票或提出民主提案</li> <li><code>NonTransfer</code> - 此类型的代理帐户可以提交任何类型的交易，但余额转账除外</li> <li><code>Balances</code> - 允许代理帐户仅进行与发送资金相关的交易</li> <li><code>IdentityJudgement</code> - 允许代理帐户从注册服务商处请求对帐户身份进行判断。可以发布以下判断：<ul> <li>unknown -（默认）尚未做出任何判断</li> <li>fee paid - 表示用户已请求判断，并且正在进行中</li> <li>reasonable - 该信息看起来合理，但未执行深入检查（即正式的 KYC 流程）</li> <li>known good - 该信息已被证明是正确的</li> <li>out of date - 该信息曾经是好的，但现在已过期</li> <li>low quality - 该信息质量低或不精确，但可以通过更新进行修复</li> <li>erroneous - 该信息是错误的，可能表明存在恶意意图</li> </ul> </li> <li><code>Any</code> - 允许代理帐户使用代理 pallet 支持的任何功能</li> </ul> <p>在本指南中，您将使用余额代理类型设置代理帐户。由于此类型允许代理代表主帐户支出资金，因此您应谨慎行事，并且仅向您信任的帐户提供访问权限。代理将有权转移主帐户中的所有资金，如果不信任，代理可能会耗尽主帐户。另外，请确保不要忘记在需要时删除代理。</p>"}, {"location": "tokens/manage/proxy-accounts/#creating-a-proxy-account", "title": "创建代理帐户", "text": ""}, {"location": "tokens/manage/proxy-accounts/#create-via-the-moonbeam-dapp", "title": "通过 Moonbeam DApp", "text": "<p>在 Moonbeam dApp 上创建代理账户非常简单。为此，请按照以下步骤操作：</p> <ol> <li>切换网络切换器按钮以选择您想要的网络</li> <li>导航到 Proxy 页面</li> <li>确保您已连接到您希望添加代理的主账户  </li> <li>输入您想要委托代理控制权的地址</li> <li>从 proxyType 下拉菜单中，选择所需的代理类型，例如余额代理</li> <li>（可选）您可以使用指定的区块数来添加时间延迟，这可以为主账户提供审查待处理交易的时间</li> <li>点击 添加代理 并在您的钱包中确认交易</li> </ol> <p></p>"}, {"location": "tokens/manage/proxy-accounts/#create-via-polkadot-js-apps", "title": "通过 Polkadot.js Apps 创建", "text": "<p>您可以通过几种方式在 Polkadot.js Apps 中创建代理账户，可以从 Extrinsics 页面或 Accounts 页面创建。但是，要创建时间延迟代理，您需要使用 Extrinsics 页面。时间延迟通过指定基于区块数量的延迟期，为代理提供额外的安全层。这将阻止代理账户执行交易，直到延迟期结束。延迟使控制代理的主账户有时间审查待处理的交易，可能会发现恶意行为，并在必要时在执行前取消。</p> <p>要开始创建您的代理账户，请前往 Developer 选项卡，然后从下拉菜单中选择 Extrinsics。接下来，您需要执行以下步骤：</p> <ol> <li>选择主账户</li> <li>从 submit the following extrinsic 下拉菜单中，选择 proxy</li> <li>选择 addProxy extrinsic</li> <li>选择代理的 delegate 账户</li> <li>从 proxyType 下拉菜单中，选择 Balances</li> <li>（可选）您可以使用指定的区块数量添加时间延迟，这可以使主账户有时间审查待处理的交易</li> <li>点击 Submit Transaction</li> </ol> <p></p> <p>然后，系统将提示您授权并签署交易。继续并点击 Sign and Submit 以创建代理关系。</p> <p>成功提交交易后，您将收到一些确认交易的通知。</p> <p>如前所述，您也可以从 Accounts 页面创建代理。为此，请导航到 Accounts 页面，然后执行以下步骤：</p> <ol> <li>选择主账户旁边的 3 个垂直点</li> <li>选择 Add proxy</li> </ol> <p></p> <p>Note</p> <p>如果账户已经有代理，则将显示 Manage proxies 作为选项，而不是 Add proxy。</p> <p>将出现一个弹出窗口，您将可以在其中输入所需的信息，例如被代理/主账户、代理账户和代理类型，以便创建代理账户。首先点击 Add Proxy。</p> <p></p> <p>然后按照以下步骤操作：</p> <ol> <li>选择您要设置为代理的账户</li> <li>选择代理类型</li> <li>点击 Submit 并签署交易</li> </ol> <p></p> <p>在下一节中，您将学习如何验证您的代理账户是否已成功设置。</p>"}, {"location": "tokens/manage/proxy-accounts/#verifying-your-proxy-account", "title": "验证您的代理帐户", "text": ""}, {"location": "tokens/manage/proxy-accounts/#verify-via-the-moonbeam-dapp", "title": "通过 Moonbeam DApp", "text": "<p>当您使用主帐户连接到 Moonbeam DApp 时，您可以在您的代理部分中看到具有对您连接的主帐户的代理控制权的帐户列表。</p> <p></p> <p>或者，通过将代理帐户连接到 Moonbeam DApp，您可以在代理给您的帐户部分中看到连接的帐户具有代理控制权的帐户列表。</p> <p></p>"}, {"location": "tokens/manage/proxy-accounts/#verify-via-polkadot-js-apps", "title": "通过 Polkadot.js Apps", "text": "<p>您可以通过几种方式验证您的代理账户是否已成功设置。可以通过账户页面或链状态页面进行验证。</p> <p>要从 链状态 页面 检查您的代理账户，您可以按照以下步骤操作：</p> <ol> <li>从选择状态查询下拉菜单中，选择 proxy</li> <li>选择 proxies extrinsic</li> <li>选择您的主（代理）账户</li> <li>点击 + 按钮发送查询</li> </ol> <p></p> <p>结果将显示在页面上，其中包含有关您的所有代理的信息，包括委托/代理账户地址、代理类型、指定的延迟时间以及您的所有代理在 Wei 中的总绑定金额。</p> <p>如前所述，您还可以从账户页面检查您的代理账户。为此，您可以导航到账户页面，主账户旁边应该有一个代理图标。将鼠标悬停在该图标上，然后单击管理代理以查看您的代理。</p> <p></p> <p>将出现一个弹出窗口，您可以在其中查看所有代理账户的概览。</p> <p></p>"}, {"location": "tokens/manage/proxy-accounts/#executing-a-proxy-transaction", "title": "执行代理交易", "text": "<p>既然您已经创建了代理账户并验证已成功设置，您就可以使用代理账户代表主账户执行交易。</p> <p>要执行交易，请返回 Extrinsics 页面 并执行以下步骤：</p> <ol> <li>从使用选择账户下拉菜单中选择要提交交易的代理账户</li> <li>从提交以下外部操作菜单中，选择 proxy</li> <li>选择 proxy 外部操作</li> <li>从 real 下拉菜单中选择主账户</li> <li>选择 balances 调用</li> <li>选择 transfer 外部操作</li> <li>在 dest 字段中，输入您要发送资金的地址</li> <li>在 value 字段中，输入要以 Wei 为单位发送的资金量。对于此示例，您可以发送 2 个 DEV 代币，即 Wei 为单位的 <code>2000000000000000000</code></li> <li>点击 Submit Transaction</li> </ol> <p></p> <p>将弹出一个窗口，供您授权和签署交易。输入您的代理账户密码，然后点击 Sign and Submit。</p> <p>如果交易成功完成，您应该会看到几个通知弹出，并且如果您转到 Accounts 页面，您会看到您的主账户余额已减少。如果您检查您将资金发送到的账户的余额，您会注意到那里的余额增加了。</p> <p>就这样！您已成功使用代理账户代表您的主账户执行了交易。</p>"}, {"location": "tokens/manage/proxy-accounts/#removing-a-proxy-account", "title": "删除代理帐户", "text": ""}, {"location": "tokens/manage/proxy-accounts/#remove-via-the-moonbeam-dapp", "title": "通过 Moonbeam DApp", "text": "<p>要删除代理账户，请将您的主账户连接到 Moonbeam DApp，然后按您要删除的代理账户旁边的 删除。或者，您可以使用 删除所有代理 删除主账户的所有代理账户。在任何一种情况下，您都必须在您的钱包中确认交易。</p> <p></p>"}, {"location": "tokens/manage/proxy-accounts/#remove-via-polkadot-js-apps", "title": "通过 Polkadot.js Apps", "text": "<p>与添加代理帐户类似，您可以通过几种方式删除代理帐户，可以从Extrinsics页面或Accounts页面删除。无论您使用哪个页面，您都可以选择删除单个代理帐户或与您的主帐户关联的所有代理。</p> <p>要从 Extrinsics 页面删除代理，您可以按照以下步骤操作：</p> <ol> <li>从使用所选帐户下拉菜单中，选择您的主帐户</li> <li>然后选择代理</li> <li>选择 removeProxy 以删除单个代理，或选择 removeProxies 以删除所有关联的代理</li> <li>如果删除单个代理，请在 delegate 字段中输入要删除的代理帐户</li> <li>选择要删除的 proxyType，在本例中选择 Balances</li> <li>（可选）选择以区块数为单位的延迟期</li> <li>单击提交交易</li> </ol> <p></p> <p>将弹出一个窗口，供您授权并签署交易。虽然任何帐户通常都可以签署交易，但删除代理必须由主帐户执行。输入您的密码，然后单击签名并提交。</p> <p>您可以按照验证您的代理帐户部分中的步骤检查代理是否已删除。</p> <p>如前所述，您也可以从“Accounts”页面删除代理。为此，在“Accounts”页面上，选择主帐户旁边的 3 个垂直点，然后选择“Manage Proxies”。</p> <p></p> <p>将弹出一个窗口，显示您的代理帐户的概览。要删除单个代理，您可以选择要删除的代理旁边的 X 按钮。代理将从列表中消失，然后您需要单击“Submit”。接下来，您将能够输入您的密码并提交交易。或者要删除所有代理，您可以单击“Clear all”，然后您将自动被提示输入您的密码并提交交易。</p> <p></p> <p>成功提交交易后，您可以查看您当前的代理，或者如果您删除了所有代理，您会注意到代理图标不再显示在主帐户旁边。</p> <p>就这样！您已成功创建代理、查看与您的主帐户关联的所有代理帐户、执行代理交易并删除代理帐户！</p>"}, {"location": "tokens/staking/stake/", "title": "如何质押您的代币", "text": ""}, {"location": "tokens/staking/stake/#introduction", "title": "简介", "text": "<p>在网络中拥有最高权益的 Collator 候选者将加入 Collator（区块生产者）的活跃池，他们将从中被选中，向中继链提供区块。</p> <p>代币持有者可以使用他们的代币来增加候选者的权益，这个过程称为委托（也称为质押）。当他们这样做时，他们相当于在为该特定候选者担保，并且他们的委托是一种信任信号。在委托时，代币会被立即扣除并添加到用户质押的总金额中。退出头寸分为两个步骤操作：计划和执行。首先，代币持有者必须计划一个退出其头寸的请求，并等待给定的延迟或解绑期，这取决于网络。一旦解绑期到期，用户可以执行他们计划的操作。</p> <p>一旦候选人加入 Collator 的活跃集合，他们就有资格生产区块并获得部分区块奖励，作为代币通胀模型的一部分。他们会与他们的委托人分享这些奖励作为质押奖励，考虑到他们对网络中权益的按比例贡献。委托人可以选择自动复投他们的奖励，以便将其奖励的设定百分比自动应用于他们的总委托金额。</p> <p>本指南将向您展示如何通过 Polkadot.js Apps 在 Moonbase Alpha 上进行质押，但对于 Moonbeam 和 Moonriver，可以采取类似的步骤。想要轻松质押代币的代币持有者可以使用 Moonbeam dApp 来进行质押。</p> <p>有关质押的更多一般信息，请查看 Moonbeam 上的质押 概述。</p>"}, {"location": "tokens/staking/stake/#extrinsics-definitions", "title": "外在函数定义", "text": "<p>有许多与Staking Pallet相关的外在函数；您可以直接在 Polkadot.js Apps 中或通过查看链元数据来浏览完整列表。</p> <p>以下列表涵盖了您将在本指南中使用并与委托流程相关的外在函数。</p> <p>Note</p> <p>随着Staking Pallet的更新，外在函数将来可能会发生变化。</p>"}, {"location": "tokens/staking/stake/#join-or-leave-the-delegator-set", "title": "加入委托人集合", "text": "<ul> <li>delegateWithAutoCompound(address candidate, uint256 amount, uint8 autoCompound, uint256 candidateDelegationCount, uint256 candidateAutoCompoundingDelegationCount, uint256 delegatorDelegationCount) - 用于将给定数量委托给整理人的外部因素。金额需要大于最小委托股份。这也会设置自动复利奖励的百分比</li> </ul>"}, {"location": "tokens/staking/stake/#bond-more-or-less", "title": "增加或减少质押", "text": "<ul> <li>delegatorBondMore(address candidate, uint256 more) - 用于请求增加已委托的整理人的质押代币数量的外部函数</li> <li>scheduleDelegatorBondLess(address candidate, uint256 less) - 用于请求减少已委托的整理人的质押代币数量的外部函数。该数量不得使您的总质押量低于最低委托质押量。在您可以通过 <code>executeDelegationRequest</code> 外部函数执行请求之前，会有一个减少质押延迟</li> <li>executeDelegationRequest(address delegator, address candidate) - 用于执行和挂起的委托请求的外部函数。此外部函数应仅在请求已安排且退出延迟已过后使用</li> <li>scheduleCandidateBondLess(uint256 less) - 允许整理人候选人请求减少其自抵押一定数量的外部函数。在您可以通过 <code>executeCandidateBondLess</code> 外部函数执行请求之前，会有一个减少质押延迟</li> <li>executeCandidateBondLess(address candidate) - 用于执行减少候选人的自抵押金额的外部函数。此外部函数应仅在抵押请求已安排且退出延迟已过后使用</li> <li>cancelCandidateBondLess() - 用于取消已安排的增加或减少特定候选人的抵押的请求的外部函数</li> </ul>"}, {"location": "tokens/staking/stake/#revoke-delegations", "title": "撤销委托", "text": "<ul> <li>scheduleRevokeDelegation(address collator) - 用于安排完全移除现有委托的外部函数。在您通过 <code>executeDelegationRequest</code> 外部函数执行请求之前，会有一个撤销委托延迟</li> <li>cancelDelegationRequest(address candidate) - 外部函数，用于取消计划撤销委托的请求</li> </ul>"}, {"location": "tokens/staking/stake/#set-change-auto-compounding", "title": "设置或更改自动复利百分比", "text": "<ul> <li>setAutoCompound(address candidate, uint8 value, uint256 candidateAutoCompoundingDelegationCount, uint256 delegatorDelegationCount) - 为现有委托设置自动复利值</li> </ul>"}, {"location": "tokens/staking/stake/#retrieving-staking-parameters", "title": "检索 Staking 值", "text": "<p>您可以使用 Polkadot.js Apps 查看任何恒定的 Staking 值，例如最大委托数、最低抵押要求、委托请求的退出延迟等。</p> <p>为此，您可以导航到 Polkadot.js Apps Chain state UI，并且为了本指南的目的，连接到 Moonbase Alpha。或者，您可以连接到 Moonbeam 或 Moonriver。</p> <p>然后，要检索各种 Staking 参数，请在 Chain state UI 上选择 Constants 选项卡，并按照以下步骤操作：</p> <ol> <li>从 selected constant query（选择的常量查询） 下拉列表中，选择 parachainStaking</li> <li>选择您想要获取数据的任何函数。对于此示例，您可以使用 maxDelegationsPerDelegator。这将返回您可以委托的最大候选人数</li> <li>单击 + 以返回当前值</li> </ol> <p></p> <p>然后，您应该会看到每个委托人的最大委托数，这也可以在 Moonbeam 上的 Staking 概述中找到。</p>"}, {"location": "tokens/staking/stake/#how-to-delegate-a-candidate", "title": "如何通过 Polkadot.js Apps 质押和自动复利奖励", "text": "<p>本节介绍了委托整理人候选人的过程。在本指南中使用的 Moonbase Alpha 上的整理人候选人的地址是 <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>。</p> <p>在使用 Polkadot.js Apps 进行质押之前，您需要检索一些重要参数，例如候选人列表、您要委托的候选人的委托计数以及您的委托数量。要自动复利您的委托奖励，您还需要您要委托的候选人的自动复利委托计数。</p>"}, {"location": "tokens/staking/stake/#retrieving-the-list-of-candidates", "title": "检索候选人列表", "text": "<p>在开始质押代币之前，重要的是检索网络中可用的整理人候选人列表。为此，请前往Developer选项卡，点击Chain State，然后按照以下步骤操作：</p> <ol> <li>选择要交互的 pallet。在本例中，它是 parachainStaking pallet</li> <li>选择要查询的状态。在本例中，它是 selectedCandidates 或 candidatePool 状态</li> <li>通过点击 + 按钮发送状态查询</li> </ol> <p>每个 extrinsic 提供不同的响应：</p> <ul> <li>selectedCandidates — 返回当前活跃的整理人集合，即按质押代币总数（包括委托）排名的顶部整理人候选人。例如，在 Moonbase Alpha 上，它是顶部 7 个候选人</li> <li>candidatePool — 返回当前所有候选人的列表，包括那些不在活跃集合中的候选人</li> </ul> <p></p>"}, {"location": "tokens/staking/stake/#get-the-candidate-delegation-count", "title": "获取候选人委托计数", "text": "<p>首先，你需要获取<code>candidateInfo</code>，其中包含委托人计数，因为你需要在后续交易中提交此参数。要检索该参数，请确保你仍在开发者页面的链状态选项卡上，然后执行以下步骤：</p> <ol> <li>选择要交互的 parachainStaking pallet</li> <li>选择要查询的 candidateInfo 状态</li> <li>确保已启用 include option 滑块</li> <li>输入 collator 候选人的地址</li> <li>单击 + 按钮发送状态查询</li> <li>复制结果，因为在发起委托时需要它</li> </ol> <p></p>"}, {"location": "tokens/staking/stake/#get-candidate-auto-compounding-count", "title": "获取候选人自动复利委托计数", "text": "<p>自动复利委托计数是已配置自动复利的委托数量。要确定设置了自动复利的委托数量，您可以使用以下代码段在 Polkadot.js Apps 上查询候选人的自动复利委托：</p> <pre><code>// Simple script to get the number of auto-compounding delegations for a given candidate.\n// Remember to replace INSERT_CANDIDATE_ADDRESS with the candidate's address you want to delegate.\nconst candidateAccount = 'INSERT_CANDIDATE_ADDRESS';\nconst autoCompoundingDelegations =\n  await api.query.parachainStaking.autoCompoundingDelegations(candidateAccount);\nconsole.log(autoCompoundingDelegations.toHuman().length);\n</code></pre> <p>要运行此代码段，请确保您位于 Polkadot.js Apps 的 JavaScript 页面（可以从开发者下拉菜单中选择），并执行以下步骤：</p> <ol> <li>从前面的代码段中复制代码并将其粘贴到代码编辑器框中</li> <li>（可选）单击保存图标并为代码段设置一个名称，例如，获取自动复利委托计数。这将在本地保存代码段</li> <li>要执行代码，请单击运行按钮</li> <li>复制结果，因为在启动委托时需要它</li> </ol> <p></p>"}, {"location": "tokens/staking/stake/#staking-your-tokens", "title": "质押您的代币", "text": "<p>要访问质押功能，您需要使用 Polkadot.js Apps 界面。为此，您需要首先导入/创建一个以太坊风格的帐户（H160 地址），您可以通过遵循 Polkadot.js 指南的创建或导入 H160 帐户部分来完成。</p> <p>在此示例中，导入了一个帐户，并以一个超级原始的名称命名：Alice。Alice 的地址是 <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code>。</p> <p>要委托一个侯选人并为您的质押奖励设置自动复利，请执行以下步骤：</p> <ol> <li>选择您要从中质押代币的帐户</li> <li>选择 parachainStaking pallet</li> <li>选择 delegateWithAutoCompound extrinsic</li> <li>设置要委托的侯选人的地址。在本例中，它被设置为 <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>设置您要质押的代币数量</li> <li>通过输入 0-100 之间的数字来设置自动复利的奖励百分比</li> <li>输入您之前从查询 <code>candidateInfo</code> 中检索到的 <code>candidateDelegationCount</code></li> <li>输入您之前从查询 <code>autoCompoundingDelegations</code> 中检索到的 <code>candidateAutoCompoundingDelegationCount</code></li> <li>输入您从 JavaScript 控制台中检索到的 <code>delegationCount</code>。如果您尚未委托任何侯选人，则为 <code>0</code></li> <li>单击 提交交易 按钮并签署交易</li> </ol> <p></p> <p>Note</p> <p>步骤 7-9 中使用的参数用于 gas 估算，不需要完全准确。但是，它们不应低于实际值。</p>"}, {"location": "tokens/staking/stake/#verifying-delegations", "title": "验证委托", "text": "<p>交易确认后，您可以通过导航至开发者选项卡下的链状态来验证您的委托。在此处，提供以下信息：</p> <ol> <li>选择您想要交互的 pallet。在本例中，它是 parachainStaking pallet</li> <li>选择要查询的状态。在本例中，它是 delegatorState</li> <li>验证所选地址是否正确。在本例中，您正在查看 Alice 的帐户</li> <li>确保启用 include option 滑块</li> <li>点击 + 按钮发送状态查询</li> </ol> <p></p> <p>在响应中，您应该看到您的帐户（在本例中为 Alice 的帐户）以及委托列表。每个委托都包含候选人的目标地址和数量。</p> <p>您可以按照所述的相同步骤来委托网络中的其他候选人。</p>"}, {"location": "tokens/staking/stake/#verifying-auto-compounding-percentage", "title": "验证自动复利百分比", "text": "<p>如果您想验证为特定委托设置自动复利的奖励百分比，您可以使用以下脚本查询 <code>autoCompoundingDelegations</code> extrinsic，并根据委托人的地址过滤结果：</p> <pre><code>// 简单的脚本来验证给定候选人的自动复利百分比。\n// 请记住将 INSERT_CANDIDATE_ADDRESS 替换为您要委托的候选人的地址，并将 INSERT_DELEGATOR_ADDRESS 替换为\n// 用于委托的地址\nconst candidateAccount = 'INSERT_CANDIDATE_ADDRESS';\nconst delegationAccount = 'INSERT_DELEGATOR_ADDRESS';\nconst autoCompoundingDelegations =\n  await api.query.parachainStaking.autoCompoundingDelegations(candidateAccount);\nconst delegation = autoCompoundingDelegations.find(\n  (del) =&gt; del.delegator == delegationAccount\n);\n\nconsole.log(`${delegation.value}%`);\n</code></pre> <p>在 Polkadot.js Apps 中，您可以前往 Developer 选项卡，然后从下拉列表中选择 JavaScript。然后，您可以按照以下步骤操作：</p> <ol> <li>从前面的代码段中复制代码，并将其粘贴到代码编辑器框中</li> <li>（可选）单击保存图标，并为代码段设置一个名称，例如 Get auto-compounding percentage。这会将代码段保存在本地</li> <li>要执行代码，请单击运行按钮</li> <li>结果将返回到右侧的终端中</li> </ol> <p></p>"}, {"location": "tokens/staking/stake/#set-or-change-auto-compounding", "title": "设置或更改自动复利百分比", "text": "<p>如果您最初设置委托时未启用自动复利，或者您想要更新已设置自动复利的现有委托的百分比，您可以使用 Solidity 界面的 <code>setAutoCompound</code> 函数。</p> <p>您需要获取要设置或更新自动复利的候选人的已设置自动复利的委托数量。您还需要检索您自己的委托数量。获得必要的信息后，您可以单击开发者选项卡，从下拉列表中选择Extrinsics，然后按照以下步骤操作：</p> <ol> <li>选择您最初从中委托并要设置或更新自动复利的帐户</li> <li>选择 parachainStaking pallet</li> <li>选择 setAutoCompound extrinsic</li> <li>设置您委托的候选人地址。在此示例中，它设置为 <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>通过输入一个 0-100 的数字来设置要自动复利的奖励百分比</li> <li>对于 candidateAutoCompoundingDelegationHint 字段，输入配置了自动复利的候选人的委托数量</li> <li>对于 delegationCountHint 字段，输入您的委托数量</li> <li>单击提交交易按钮并签署交易</li> </ol> <p></p>"}, {"location": "tokens/staking/stake/#how-to-stop-delegations", "title": "如何停止委托", "text": "<p>从 运行时版本 1001 开始，用户与各种质押功能互动的方式发生了重大变化。包括处理质押退出的方式。</p> <p>如果您想退出并停止委托，您必须首先安排它，等待退出延迟，然后执行退出请求。如果您已经是委托人，您可以使用 <code>scheduleRevokeDelegation</code> extrinsic 请求停止您的委托，以请求从特定的整理人候选人处取消质押您的代币。安排请求不会自动撤销您的委托，您必须等待 退出延迟，然后使用 <code>executeDelegationRequest</code> 方法执行请求。</p>"}, {"location": "tokens/staking/stake/#schedule-request-to-stop-delegations", "title": "安排请求停止委托", "text": "<p>要安排撤销您对特定候选人的委托的请求，请导航到开发者选项卡下的 Extrinsics 菜单。在此处，提供以下信息：</p> <ol> <li>选择您要从中删除委托的帐户</li> <li>选择 <code>parachainStaking</code> pallet</li> <li>选择 <code>scheduleRevokeDelegation</code> extrinsic</li> <li>设置您要从中删除委托的候选人的地址。在这种情况下，它设置为 <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>单击 Submit Transaction 按钮并签署交易</li> </ol> <p></p> <p>Note</p> <p>每个候选人只能有一个待处理的计划请求。</p> <p>安排退出后，您必须等待一个 退出延迟 才能执行它。如果您尝试在退出延迟结束前执行它，则 extrinsic 将失败，并且您会从 Polkadot.js Apps 看到 <code>parachainStaking.PendingDelegationRequest</code> 的错误。</p>"}, {"location": "tokens/staking/stake/#execute-request-to-stop-delegations", "title": "执行停止委托的请求", "text": "<p>在启动计划请求后经过退出延迟后，您可以返回Extrinsics菜单的Developer选项卡，并按照以下步骤执行请求：</p> <ol> <li>选择要执行撤销的帐户</li> <li>选择 parachainStaking pallet</li> <li>选择 executeDelegationRequest extrinsic</li> <li>设置您要删除其委托的委托人的地址。对于此示例，它将是 Alice 的地址 <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>设置您要从中删除委托的候选人的地址。在这种情况下，它被设置为 <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>点击Submit Transaction按钮并签署交易</li> </ol> <p></p> <p>交易确认后，您可以通过转到Developer选项卡下的Chain state选项来验证您的委托是否已删除。在这里，提供以下信息：</p> <ol> <li>选择 parachainStaking pallet</li> <li>选择 delegatorState 状态以进行查询</li> <li>选择您的帐户</li> <li>确保启用include options滑块</li> <li>通过单击 + 按钮发送状态查询</li> </ol> <p></p> <p>在响应中，您应该看到您的帐户（在本例中为 Alice 的帐户）以及剩余委托的列表。每个委托都包含候选人的目标地址和金额。不应再有 <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code> 的条目。如果您不再有任何委托，将返回 <code>&lt;none&gt;</code>。</p> <p>为确保撤销按预期进行，您可以按照上面验证委托部分中的步骤操作。</p>"}, {"location": "tokens/staking/stake/#cancel-request-to-stop-delegations", "title": "取消停止委托的请求", "text": "<p>如果您已安排停止委托的请求但改变了主意，只要该请求尚未执行，您可以随时取消该请求，并且您的所有委托将保持不变。要取消请求，您可以按照以下步骤操作：</p> <ol> <li>选择要取消计划请求的帐户</li> <li>选择 parachainStaking pallet</li> <li>选择 cancelDelegationRequest extrinsic</li> <li>输入与您要取消的到期请求相对应的候选人地址</li> <li>单击 提交交易 按钮并签署交易</li> </ol> <p></p>"}, {"location": "tokens/staking/stake/#staking-rewards", "title": "质押奖励", "text": "<p>由于整理人的活跃集合中的候选人会从区块生产中获得奖励，因此委托人也会获得奖励。有关如何计算奖励的简要概述，请参见 Moonbeam 质押概述页面的奖励分配部分。</p> <p>总而言之，委托人将根据其在获得奖励的整理人的总委托中所占的股份（包括整理人的股份）来获得奖励。</p> <p>委托人可以选择自动复投其奖励，以便将其奖励自动应用于其总委托金额。如果委托人有多个委托，则需要为每个委托设置自动复投。</p>"}, {"location": "tokens/staking/stake/#risks", "title": "Risks", "text": "<p>Holders of MOVR/GLMR tokens should perform careful due diligence on collators before delegating. Being listed as a collator is not an endorsement or recommendation from the Moonbeam Network, the Moonriver Network, or Moonbeam Foundation. Neither the Moonbeam Network, Moonriver Network, nor Moonbeam Foundation has vetted the list collators and assumes no responsibility with regard to the selection, performance, security, accuracy, or use of any third-party offerings.  You alone are responsible for doing your own diligence to understand the applicable fees and all risks present, including actively monitoring the activity of your collators.</p> <p>You agree and understand that neither the Moonbeam Network, the Moonriver Network, nor Moonbeam Foundation guarantees that you will receive staking rewards and any applicable percentage provided (i) is an estimate only and not guaranteed, (ii) may change at any time and (iii) may be more or less than the actual staking rewards you receive. The Moonbeam Foundation makes no representations as to the monetary value of any rewards at any time.</p> <p>Staking MOVR/GLMR tokens is not free of risk. 质押的 MOVR/GLMR 代币会被锁定，取回它们需要 2 天/7 天的等待期。 Additionally, if a collator fails to perform required functions or acts in bad faith, a portion of their total stake can be slashed (i.e. destroyed). This includes the stake of their delegators. If a collators behaves suspiciously or is too often offline, delegators can choose to unbond from them or switch to another collator. Delegators can also mitigate risk by electing to distribute their stake across multiple collators.</p>"}, {"location": "tutorials/eth-api/using-tenderly/", "title": "使用 Tenderly 模拟和调试交易", "text": ""}, {"location": "tutorials/eth-api/using-tenderly/#introduction", "title": "简介", "text": "<p>Tenderly 是一个适用于 EVM 网络的all-in-one开发平台，使 Web3 开发者能够构建、测试、监控和运营其智能合约。Tenderly 拥有一整套产品，可以在智能合约的整个生命周期中为您提供帮助，从最早的开发阶段到实时生产 dApp 的维护和警报。</p> <p>Tenderly 提供的多数服务均可免费使用，但是您需要订阅付费计划才能使用高级功能，例如实时警报和作战室功能。Tenderly 支持 Moonbeam 和 Moonriver，但目前不支持 Moonbase Alpha。有关 Tenderly 产品的更多信息，请务必熟悉Tenderly 简介。</p> <p>在本教程中，我们将探讨 Tenderly 的两个最强大的功能：调试器和模拟器。</p>"}, {"location": "tutorials/eth-api/using-tenderly/#checking-prerequisites", "title": "检查必备条件", "text": "<p>要开始，您需要以下条件：</p> <ul> <li>拥有一个免费的 Tenderly 帐户。您不需要付费计划即可完成本教程</li> </ul>"}, {"location": "tutorials/eth-api/using-tenderly/#create-a-tenderly-project", "title": "创建 Tenderly 项目", "text": "<p>即使不是严格要求，创建一个 Tenderly 项目来保持组织性并访问更多 Tenderly 的可用功能也是一个好主意。在选择项目下拉菜单下，您可以按创建项目或直接前往仪表板上的创建项目页面。</p> <p>给您的项目命名，然后按创建项目。虽然您可以在稍后更改您的项目名称，但 URL 将保留您创建的原始名称。</p> <p></p> <p>一个免费账户只能创建一个项目；但是，您可以在单个项目下拥有多个智能合约。</p>"}, {"location": "tutorials/eth-api/using-tenderly/#add-smart-contracts", "title": "添加智能合约", "text": "<p>将智能合约添加到您的 Tenderly 项目就像将其添加到书签一样。虽然不是必需的，但添加合约将解锁额外的 Tenderly 功能，而不仅仅是在 Tenderly 平台上搜索合约。</p> <p>要将智能合约添加到您的 Tenderly 项目，请单击Inspect标题下的Contracts选项卡，然后单击Add Contracts。然后，执行以下步骤：</p> <ol> <li>输入合约的地址。在本教程中，我们将使用 FRAX 稳定币合约 <code>0x322E86852e492a7Ee17f28a78c663da38FB33bfb</code></li> <li>选择合约部署到的网络。 在这种情况下，我们将选择 Moonbeam</li> <li>给合约起个名字，以帮助您在仪表板上识别它</li> <li>按 Add Contract</li> </ol> <p></p>"}, {"location": "tutorials/eth-api/using-tenderly/#simulate-a-transaction", "title": "模拟交易", "text": "<p>模拟允许您查看交易的执行方式，而无需实际将其发送到区块链上。您可以针对任何时间点或仅是最新的区块模拟交易。</p> <p>前往 Simulator 选项卡，让我们按照以下步骤创建一个针对 Moonbeam 网络的模拟交易：</p> <ol> <li>选择您要交互的合约。此处显示的名称是您在将其添加到 Tenderly 工作区时为合约指定的昵称。</li> <li>选择您要调用的合约函数。为了演示目的，此处选择了 <code>Transfer</code></li> <li>接下来，我们将输入相关的函数参数。对于目标地址，您可以输入任何地址，例如 Alith 的地址：<code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>对于金额，您也可以指定任何金额，例如 <code>10000000000</code></li> <li>选择 Pending Block 以针对最新生成的 Moonbeam 区块运行模拟</li> <li>将发件人地址指定为 Baltathar：<code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code> 或您选择的另一个地址</li> <li>按 Simulate Transaction</li> </ol> <p></p> <p>显然，此模拟交易将会失败，因为我们试图发送我们没有的 10,000 FRAX。但是，通过 Tenderly 模拟器，我们可以调整区块链状态并运行假设不同条件的模拟。例如，让我们运行假设 Baltathar 实际上持有 10,000 FRAX 余额的模拟。按右上角的 Re-Simulate，然后执行以下步骤：</p> <ol> <li>展开 State Overrides 部分</li> <li>按 Add State Override</li> <li>选择相关的合约，在本例中为 FRAX 合约</li> <li>在 Storage Variables 部分下，我们将通过将密钥指定为 <code>balanceOf[0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0]</code>，并将值指定为 <code>10000000000</code>，来覆盖保存 Baltathar 余额的映射。请务必注意，您是在 Storage Variables 部分而不是 Balance 部分执行此步骤</li> <li>按 Add 以确认添加状态覆盖</li> <li>按 Simulate Transaction</li> </ol> <p></p> <p>Note</p> <p>请记住，Alith 和 Baltathar 账户是公共开发者账户列表的一部分，具有已知的私钥。您将丢失发送到这些地址的任何资金。</p> <p>如果正确添加了状态覆盖，您现在应该会在运行模拟时看到交易模拟成功界面。如果出现错误，您可以按 Re-Simulate 并验证您是否已正确配置状态覆盖。</p> <p></p> <p>您还可以通过 Simulations API 访问 Tenderly 的交易模拟器。</p>"}, {"location": "tutorials/eth-api/using-tenderly/#debugging", "title": "调试", "text": "<p>Debugger 是 Tenderly 最强大和最受赞誉的功能之一。它速度很快，并且只需要最少的设置。实际上，如果您正在调查的合约已经在链上验证，那么启动调试器就像在 Tenderly 上搜索交易哈希一样简单。让我们来试试。</p> <p>在顶部的搜索栏中，您可以粘贴合约地址或交易哈希。请记住，Tenderly 支持 Moonbeam 和 Moonriver，但目前不支持 Moonbase Alpha。这是一个 GLMR / FRAX 在 StellaSwap 上进行交换的交易哈希示例：</p> <p>text 0x80c87ab47e077ca491045047389e6bd88a748ca24971a288d09608834a3bda07</p> <p>找到交易哈希后，您会在顶部看到有关交易的所有典型统计信息，例如状态、gas 价格、gas 使用量等。接下来，您将看到已传输的代币的细目分类。在底部，您将看到每个函数调用的长列表。鉴于交换是一个相对复杂的交互，并且鉴于 StellaSwap 使用可升级的代理合约，您将在此示例中看到一个相当长的列表。</p> <p></p> <p>如果您单击左侧导航栏上的 合约，您将看到与该交易交互的每个合约的列表。您可以单击合约以查看更多详细信息，如果合约已验证，则可以查看整个源代码。</p> <p></p> <p>在左侧导航栏向下，您将看到一个 事件 选项卡，后跟一个 状态更改 选项卡，该选项卡以可视方式表示由于此交易而发生的链状态的每次更改。</p> <p></p> <p>如果您向下滚动到 调试器 选项卡，您将能够逐行单步执行合约，并在底部看到关键状态信息，从而使您能够查明任何错误的来源。</p> <p></p> <p>最后，您将看到一个 Gas 分析器，它将以可视方式表示在整个交易过程中 gas 的使用位置和方式。您可以单击任何函数调用（以蓝色矩形表示）以查看每个调用中花费了多少 gas。</p> <p></p> <p>要了解更多详细信息，请务必查看 如何使用 Tenderly 调试器 指南。就这样！您已在掌握 Tenderly 的道路上走得很远，这肯定会节省您的时间并简化您在 Moonbeam 上构建 dApp 的开发体验。</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}, {"location": "tutorials/integrations/0xgasless/", "title": "使用 0xGasless 启用无 Gas 交易", "text": ""}, {"location": "tutorials/integrations/0xgasless/#gas", "title": "为什么需要无 Gas 交易？", "text": "<p>区块链开发的主要挑战之一是要求用户持有原生代币（如ETH或GLMR）来支付交易费用。这种传统的基于 EOA 的模型会产生不必要的摩擦，尤其是在引导期望获得类似 Web2 体验的用户时。</p> <p>无 Gas 交易可以通过账户抽象 (ERC-4337) 帮助解决这一问题，实现将用户操作与费用支付分离的元交易。这种架构允许 dApp 或第三方付费方代表用户支付 Gas 费用，而智能合约钱包处理交易执行。0xGasless 在其 SDK 中利用了这些原则，使 Moonbeam 开发人员能够实现复杂的功能，如社交登录、交易批处理和自定义钱包控制——所有这些都抽象了最终用户的 Gas 管理复杂性。</p> <p>在以下教程中，我们将完成在 0xGasless 上设置付费方并将无 Gas 交易分发到 Moonbeam 上的智能合约状态的端到端步骤。</p>"}, {"location": "tutorials/integrations/0xgasless/#_1", "title": "创建并资助支付方", "text": "<p>首先，您需要在 0xGasless 上注册一个帐户。然后，通过按 创建支付方 为 Moonbeam 网络 创建一个支付方，然后执行以下步骤：</p> <ol> <li>输入您的支付方的名称</li> <li>选择 Moonbeam 作为链</li> <li>按 创建</li> </ol> <p></p> <p>您的支付方需要资金来支付赞助交易的 gas 费用。要将 GLMR 存入您的支付方，请执行以下步骤：</p> <ol> <li>输入您要存入的金额</li> <li>按 存款 并在您的钱包中确认交易</li> </ol> <p></p> <p>您存入的资金仍然灵活 - 使用它们来赞助无 gas 交易或随时提取它们。</p>"}, {"location": "tutorials/integrations/0xgasless/#gas_1", "title": "调度无Gas交易", "text": "<p>在以下部分中，我们将创建一个脚本来演示如何调度无Gas交易。</p>"}, {"location": "tutorials/integrations/0xgasless/#_2", "title": "前提条件", "text": "<p>在项目的根目录中创建一个包含以下内容的 <code>.env</code> 文件：</p> <pre><code>PRIVATE_KEY=INSERT_PRIVATE_KEY\nRPC_URL=https://rpc.api.moonbeam.network\n</code></pre> <p>为什么要在 <code>.env</code> 中指定私钥？虽然此交易是无 Gas 的，但您仍然需要一个私钥来签署交易。与此私钥关联的帐户：</p> <ul> <li>不需要任何 GLMR 代币</li> <li>不会支付 Gas 费用</li> <li>仅用于交易签名</li> </ul> <p>Note</p> <p>永远不要提交您的 .env 文件或分享您的私钥。将 .env 添加到您的 .gitignore 文件中。</p> <p>另外，请确保您已安装 0xGasless SDK 以及支持的 <code>ethers</code> 和 <code>dotenv</code> 包：</p> <pre><code>npm install ethers dotenv @0xgasless/smart-account\n</code></pre> <p>首先，我们将按如下方式导入所需的包：</p> <pre><code>require('dotenv').config();\nconst ethers = require('ethers');\nconst {\n  PaymasterMode,\n  createSmartAccountClient,\n} = require('@0xgasless/smart-account');\n</code></pre> <p>接下来，我们将设置关键常量。我们必须定义 <code>CHAIN_ID</code>、<code>BUNDLER_URL</code> 和 <code>PAYMASTER_URL</code>。您可以从 0xGasless 仪表板上的支付方获取唯一的支付方 URL。</p> <p>我们在此处定义的合约地址是 Moonbeam 上的 Incrementer 合约 的地址，我们将调用函数选择器指定的 increment 函数。这个简单的合约将使我们能够轻松地看到无 Gas 交易是否已成功分派。</p> <pre><code>const CHAIN_ID = 1284; // Moonbeam mainnet\nconst BUNDLER_URL = `https://bundler.0xgasless.com/${CHAIN_ID}`;\nconst PAYMASTER_URL =\n  'https://paymaster.0xgasless.com/v1/1284/rpc/INSERT_API_KEY';\nconst CONTRACT_ADDRESS = '0x3aE26f2c909EB4F1EdF97bf60B36529744b09213';\nconst FUNCTION_SELECTOR = '0xd09de08a';\n</code></pre> <p>Warning</p> <p>Paymaster URL 格式最近已更改。请使用：</p> <pre><code>https://paymaster.0xgasless.com/v1/1284/rpc/INSERT_API_KEY\n</code></pre> <p>不要使用已弃用的格式：</p> <pre><code>https://paymaster.0xgasless.com/api/v1/1284/rpc/INSERT_API_KEY\n</code></pre> <p>区别在于 <code>/api</code> 已从路径中删除。请确保您的代码使用当前格式。</p>"}, {"location": "tutorials/integrations/0xgasless/#_3", "title": "验证完成", "text": "<p>运行脚本后，您会看到如下输出：</p> 0xgasless % node dispatch.js Starting the script... Setting up provider and wallet... Checking network connection... Connected to network: unknown (Chain ID: 1284) Wallet balance: 8.781249287153010128 GLMR Initializing smart account... Smart Account Address: 0xbBf77D3B43d81D426c4c3D200a76F4D3a914ccE3 Creating contract transaction... Sending transaction... UserOp Hash: undefined Waiting for transaction receipt... Transaction successful! Transaction hash: 0x9cb49cc0acc21abc364c13dd52b3f65c206ec61c57a13c23b635f59e1919cf7c <p>由于我们发起的无 Gas 交易与 Moonbeam 上的 Incrementer 智能合约交互，因此很容易检查交易是否成功发起。您可以返回 Moonscan 上的 Incrementer 合约的读取合约部分 并检查存储在合约中的数字。或者，您可以前往内部交易选项卡，然后将高级模式切换为开启，以查看合约调用递增合约。</p> <p>有关将对无 Gas 交易的支持集成到您的 dApp 中的更多信息，请务必查看 0xGasless 文档。</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}]}