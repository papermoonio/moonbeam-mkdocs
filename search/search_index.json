{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"ai-resources/ai-resources/","title":"AI Resources","text":"<p>Moonbeam provides <code>.txt</code> files containing the documentation content and navigation structure, optimized for use with large language models (LLMs) and AI tools. These resources help build AI assistants, power code search, or enable custom tooling trained on Moonbeam\u2019s documentation.</p> <p>Each category file includes foundational content from the Basics and Reference categories to ensure LLMs have the necessary context.</p>"},{"location":"ai-resources/ai-resources/#download-llm-files","title":"Download LLM Files","text":"Category Description File Actions Index Navigation index of all Moonbeam documentation pages <code>llms.txt</code> Full Documentation Full content of all documentation pages <code>llms-full.txt</code> Basics Moonbeam's framework, architecture, and core components <code>llms-basics.txt</code> Reference Reference material including network endpoints, JSON-RPC methods, and contract or token addresses <code>llms-reference.txt</code> Ethereum Toolkit Useful tools and smart contracts to work with Moonbeam's EVM <code>llms-ethereum-toolkit.txt</code> Substrate Toolkit Useful tools and smart contracts to work with Substrate <code>llms-substrate-toolkit.txt</code> GMP Providers How to use General Message Passing (GMP) for cross-chain communication <code>llms-gmp-providers.txt</code> XCM Learn about and use Cross-Consensus Messaging (XCM) <code>llms-xcm.txt</code> XC-20 Guides for interacting with XC-20 tokens <code>llms-xc-20.txt</code> XCM Remote Execution How to make cross-chain calls with XCM <code>llms-xcm-remote-execution.txt</code> Precompiles Guides to using Moonbeam's precompiles <code>llms-precompiles.txt</code> Libraries and SDKs Resources for commonly used libraries and SDKs <code>llms-libraries-and-sdks.txt</code> Dev Environments How to set up developer environments such as Hardhat and Foundry <code>llms-dev-environments.txt</code> JSON-RPC APIs RPC usage and tracing <code>llms-json-rpc-apis.txt</code> Node Operators and Collators How to run a full node or a block-producing collator <code>llms-node-operators-and-collators.txt</code> Oracle Nodes How to integrate with oracle node providers <code>llms-oracle-nodes.txt</code> Indexers and Queries How to integrate with indexer and query node providers <code>llms-indexers-and-queries.txt</code> Tokens and Accounts How to manage tokens and accounts on Moonbeam <code>llms-tokens-and-accounts.txt</code> Staking Guides to delegate and collate <code>llms-staking.txt</code> Governance Guides to governance including voting and treasury <code>llms-governance.txt</code> Integrations Guides to integrating Moonbeam with various tools such as wallets and analytics <code>llms-integrations.txt</code> Tutorials Comprehensive, step-by-step, guided project builds <code>llms-tutorials.txt</code> <p>Note</p> <p>The <code>llms-full.txt</code> file may exceed the input limits of some language models due to its size. If you encounter limitations, consider using the files by category.</p>"},{"location":"builders/build/historical-updates/","title":"Historical Updates","text":""},{"location":"builders/build/historical-updates/#introduction","title":"Introduction","text":"<p>This page overviews historical updates on Moonbeam and Moonriver, such as bug fixes to the Moonbeam source code and data migrations applied.</p> <p>This page aims to provide information about unexpected behaviors or data inconsistencies associated with updates that require forced data migrations.</p>"},{"location":"builders/build/historical-updates/#bugs","title":"Bugs","text":""},{"location":"builders/build/historical-updates/#invalid-transactions-stored","title":"Invalid Transactions Stored","text":"<p>For invalid transactions where the transaction cost couldn't be paid, the EVM pallet inserted the transaction metadata into storage instead of discarding it because there was no transaction cost validation. As a result, the runtime storage was unnecessarily bloated with invalid transaction data.</p> <p>This bug only impacted Moonriver and Moonbase Alpha and existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonriver RT49 RT600 0 - 455106 Moonbase Alpha RT40 RT600 0 - 675175 <p>For more information, you can review the relative Frontier PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#ethereum-fees-to-treasury","title":"Ethereum Fees Weren't Sent to Treasury","text":"<p>The Moonbeam transaction fee model before Runtime 3401 and the passage of MB101 mandated a 20% allocation of fees sent to the on-chain Treasury and 80% burned as a deflationary force. However, before runtime 800, Ethereum transactions did not correctly allocate 20% of the transaction fees to the on-chain Treasury.</p> <p>This bug only impacted Moonriver and Moonbase Alpha and existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonriver RT49 RT800 0 - 684728 Moonbase Alpha RT40 RT800 0 - 915684 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#missing-refunds","title":"Missing Refunds","text":"<p>Moonbeam is configured to set the existential deposit to 0, meaning that accounts do not need a minimum balance to be considered active. For Substrate-based chains with this configuration, some refunds were missing from zeroed accounts because the account was interpreted as not existing.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT900 RT1001 0 - 5164 Moonriver RT49 RT1001 0 - 1052241 Moonbase Alpha RT40 RT1001 0 - 1285915 <p>For more information, you can review the relative Frontier PR and the associated Substrate PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#incorrect-collator-selection","title":"Incorrect Collator Selection","text":"<p>The total delegations for collator candidates were not correctly updated when a delegation was increased via the <code>delegatorBondMore</code> extrinsic. This led to issues where the increased delegation amount wasn't included in the candidates' total amount bonded, which is used to determine which candidates are in the active set of collators. As a result, some candidates may not have been selected to be in the active set when they should have been, impacting their own and their delegators' rewards.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT900 RT1300 0 - 524762 Moonriver RT49 RT1300 0 - 1541735 Moonbase Alpha RT40 RT1300 0 - 1761128 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#new-account-event","title":"New Account Event Bug","text":"<p>The <code>System.NewAccount</code> event is emitted when a new account is created. However, a bug prevented this event from being emitted for some accounts at creation time. A hotfix was applied that patched the impacted accounts and emitted the <code>System.NewAccount</code> at a later time.</p> <p>The hotfix was applied in the following block ranges:</p> Network Block Range Moonbeam 1041355 - 1041358 and 1100752 Moonriver 1835760 - 1835769 Moonbase Alpha 2097782 - 2097974 <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT900 RT1401 0 - 915320 Moonriver RT49 RT1401 0 - 1705939 Moonbase Alpha RT40 RT1400 0 - 1962557 <p>For more information, you can review the relative Frontier PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#incorrect-timestamp-units","title":"Incorrect Timestamp Units","text":"<p>EIP-2612 and Ethereum blocks deal with timestamps in seconds; however, the Substrate timestamp pallet that Moonbeam implements uses milliseconds. This only affected the EIP-2612 implementation, not the <code>block.timestamp</code> value.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT900 RT1606 0 - 1326697 Moonriver RT49 RT1605 0 - 2077598 Moonbase Alpha RT40 RT1603 0 - 2285346 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#substrate-tips","title":"Substrate Tips Missing Treasury Distribution","text":"<p>Tips for Substrate-based transactions weren't handled properly. The entire portion of the tip was burned because it was not handled in the runtime code. A fix was applied so that 20% was paid to the Treasury and 80% was burned, consistent with all other fee behavior at that time.</p> <p>Note that RT3401 introduced a parameters pallet fee configuration allowing governance to adjust how fees are split between the Treasury and burning. After this runtime upgrade combined with the passage of MB101, 100% of all transaction fees on both Moonbeam and Moonriver are now burned.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT900 RT2403 0 - 4163078 Moonriver RT49 RT2401 0 - 4668844 Moonbase Alpha RT40 RT2401 0 - 4591616 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#incorrect-delegation-reward-calculation","title":"Incorrect Delegation Reward Calculation","text":"<p>The reward payouts for all delegations and collators were underestimated whenever there were pending requests. Delegation rewards are calculated based on the amount of tokens bonded by each delegator with respect to the total stake of the given collator. By counting delegation amounts for pending requests, the rewards to collators and their delegations were less than they should have been.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1001 RT1802 5165 - 1919457 Moonriver RT1001 RT1801 1052242 - 2572555 Moonbase Alpha RT1001 RT1800 1285916 - 2748785 <p>You can review the relative PR on GitHub for more information.</p>"},{"location":"builders/build/historical-updates/#block-parent-hash-calculated-incorrectly","title":"Block Parent Hash Calculated Incorrectly","text":"<p>After EIP-1559 support was introduced, which included the transition to new Ethereum transaction types, the block header parent hash was miscalculated to <code>H256::default</code>.</p> <p>This bug only impacted Moonbase Alpha and only impacted the following block:</p> Network Introduced Fixed Impacted Block Moonbase Alpha RT1200 RT1201 1648995 <p>While the root issue was fixed in RT1201, the incorrect hash was corrected in RT2601.</p> <p>For more information on the root fix, you can review the relative Frontier PR on GitHub. To take a look at the correction of the parent hash, check out the corresponding Moonbeam PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#incorrect-gas-fees-eip1559","title":"Incorrect Handling of EIP-1559 Gas Fees","text":"<p>With the introduction of EIP-1559 support, the logic for handling <code>maxFeePerGas</code> and <code>maxPriorityFeePerGas</code> was implemented incorrectly. As a result, the <code>maxPriorityFeePerGas</code> was added to the <code>baseFee</code> even if the total amount was over the <code>maxFeePerGas</code>.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1201 RT1401 415946 - 915320 Moonriver RT1201 RT1401 1471037 - 1705939 Moonbase Alpha RT1200 RT1400 1648994 - 1962557 <p>For more information, you can review the relative Frontier PR.</p>"},{"location":"builders/build/historical-updates/#transaction-fees-paid-to-collators","title":"Transaction Fees Paid to Collators","text":"<p>For blocks that included EIP-1559 transactions where a priority fee was applied, the transaction fees were incorrectly calculated and distributed to the block's collator. The fee model on Moonbeam for transactions and smart contract execution was previously handled so that 20% of the fees went to the on-chain Treasury and 80% were burned as a deflationary force. Due to this bug, the transaction fees of the impacted transactions were not burned as expected.</p> <p>Note that RT3401 introduced a parameters pallet fee configuration allowing governance to adjust how fees are split between the Treasury and burning. After this runtime upgrade combined with the passage of MB101, 100% of all transaction fees on both Moonbeam and Moonriver are now burned.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1201 RT1504 415946 - 1117309 Moonriver RT1201 RT1504 1471037 - 1910639 Moonbase Alpha RT1200 RT1504 1648994 - 2221772 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#incorrect-state-root-hash","title":"Incorrect State Root Hash","text":"<p>The state root hash was miscalculated for non-legacy transactions as the transaction-type byte was not considered. With the support of EIP-2930 and EIP-1559, the transaction types introduced are <code>0x01</code> (1) and <code>0x02</code> (2), respectively. These transaction types were omitted from the state root hash calculation.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1201 RT1701 415946 - 1581456 Moonriver RT1201 RT1701 1471037 - 2281722 Moonbase Alpha RT1200 RT1700 1648994 - 2529735 <p>For more information, you can review the relative Frontier PR and Moonbeam PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#ethereum-transactions-duplicated-in-storage","title":"Ethereum Transactions Duplicated in Storage","text":"<p>An upstream bug was introduced to Frontier in the Ethereum Pallet, causing pending transactions that existed during a runtime upgrade to be duplicated in storage across two different blocks. This only impacted the first two blocks after the runtime upgrade in which this bug was introduced.</p> <p>Only Moonriver and Moonbase Alpha were impacted. The bug was introduced in the following runtimes and affected the following blocks:</p> Network Introduced Impacted Blocks Moonriver RT1605 2077599 and 2077600 Moonbase Alpha RT1603 2285347 and 2285348 <p>The following transactions were duplicated:</p> MoonriverMoonbase Alpha <pre><code>'0x2cceda1436e32ae3b3a2194a8cb5bc4188259600c714789bae1fedc0bbc5125f',\n'0x3043660e35e89cafd7b0e0dce9636f5fcc218fce2a57d1104cf21aabbff9a1c0',\n'0x514411fb5c08f7c5aa6c61c38f33edfa74ff7e160831f6140e8dd3783648dbca',\n'0xf1647c357d8e1b05c522d11cff1f5090a4df114595d0f4b9e4ac5bb746473eea',\n'0x4be94803fe7839d5ef13ddd2633a293b4a7dddbe526839c15c1646c72e7b0b23',\n'0x15fceb009bd49692b598859f9146303ed4d8204b38e35c147fcdb18956679dbe',\n'0xa7460d23d5c633feec3d8e8f4382240d9b71a0d770f7541c3c32504b5403b70c',\n'0x1c838b4c4e7796a9db5edfd0377aee6e0d89b623bf1d7803f766f4cf71daefb9',\n'0xfb233a893e62d717ed627585f14b1ee8b3e300ac4e2c3016eb63e546a60820f0',\n'0xfaf8908838683ad51894eb3c68196afb99ba2e2bb698a40108960ee55417b56a',\n'0xa53973acbeac9fe948015dcfad6e0cb28d91b93c8115347c178333e73fd332d3',\n'0x9df769c96c5fdd505c67fee27eaff3714bf8f3d45a2afc02dd2984884b3cecac',\n'0x8f912ae91b408f082026992a87060ed245dac6e382a84288bd38fc08dbac30fe',\n'0xb22af459d24cb25bc53785bdd0ae6a573e24f226c94fd8d2e4663b87d3b07a88',\n'0x8ab9cd2bde7d679f798528b0c75325787f5fc7997e00589445b35b3954a815aa',\n'0xd08a1f82f4d3dc553b4b559925f997ef8bb85cb24cb4d0b893f017129fb33b78',\n'0xa1d40bce7cc607c19ca4b37152b6d8d3a408e3de6b9789c5977fcdef7ef14d97',\n'0xe442227634db10f5d0e8c1da09f8721c2a57267edbf97c4325c4f8432fd48ade',\n'0x0b4f5d8338a7c2b1604c1c42e96b12dc2a9d5ab264eb74ff730354e9765de13f',\n'0x0b00fc907701003aad75560d8b1a33cbf4b75f76c81d776b8b92d20e1d2e9d31',\n'0x9c18bd783f28427d873970ff9deaf1549db2f9a76e3edd6bdeae11358e447ef4',\n'0x8b2523f163989969dd0ebcac85d14805756bc0075b89da1274fd2c53ccaa396a',\n'0x47e80a0c533265974a55ea62131814e31b10f42895709f7e531e3e7b69f1387c'\n</code></pre> <pre><code>'0x006a6843eb35ad35a9ea9a99affa8d81f1ed500253c98cc9c080d84171a0afb3',\n'0x64c102f664eb435206ad4fcb49b526722176bcf74801c79473c3b5b2c281a243',\n'0xf546335453b6e35ce7e236ee873c96ba3a22602b3acc4f45f5d68b33a76d79ca',\n'0x4ed713ccd474fc33d2022a802f064cc012e3e37cd22891d4a89c7ba3d776f2db',\n'0xa5355f86844bb23fe666b10b509543fa377a9e324513eb221e0a2c926a64cae4',\n'0xc14791a3a392018fc3438f39cac1d572e8baadd4ed350e0355d1ca874a169e6a'\n</code></pre> <p>The duplicated transactions belong to the first block. So, on Moonriver, the transactions belong to block 2077599, and on Moonbase Alpha, the impacted transactions belong to block 2285347.</p> <p>For more information, you can review the relative Frontier PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#gas-limit-too-high-for-non-transactional-calls","title":"Gas Limit Too High for Non-Transactional Calls","text":"<p>When a non-transactional call, such as <code>eth_call</code> or <code>eth_estimateGas</code>, is made without specifying a gas limit for a past block, the client defaults to using the gas limit multiplier (10x), which causes the gas limit validation to fail as it is validating against an upper bound of the block gas limit. So, if the gas limit is greater than the block gas limit for a given call, a gas limit too high error is returned.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1701 RT1802 1581457 - 1919457 Moonriver RT1701 RT1802 2281723 - 2616189 Moonbase Alpha RT1700 RT1802 2529736 - 2879402 <p>You can review the relative Frontier PR on GitHub for more information.</p>"},{"location":"builders/build/historical-updates/#remote-evm-calls-return-identical-tx-hashes","title":"Remote EVM Calls Return Identical Transaction Hashes","text":"<p>When multiple remote EVM calls were sent from different accounts with the same transaction payload and nonce, the same transaction hash was returned for each call. This was possible because remote EVM calls are executed from a keyless account, so if the senders all had the same nonce and were sending the same transaction object, there was no differentiation in the calculation of the transaction hash. This was fixed by adding a global nonce to the Ethereum XCM Pallet, which is the pallet that makes remote EVM calls possible.</p> <p>This bug only existed on Moonbase Alpha during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbase Alpha RT1700 RT1900 2529736 - 3069634 <p>You can review the relative PR on GitHub for more information.</p>"},{"location":"builders/build/historical-updates/#gas-estimation-discrepancy","title":"Gas Estimation Discrepancy","text":"<p>There was a difference between estimating the gas for a transaction using a non-transaction call, such as <code>eth_call</code>, and the execution of it on-chain. The discrepancy occurred because the non-transactional calls were not properly accounting for <code>maxFeePerGas</code> and <code>maxPriorityFeePerGas</code>, as such, the (Proof of Validity) consumed by the Ethereum transaction was counted differently. This was fixed by properly accounting for these fields when estimating the size of the on-chain transaction.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1201 RT2501 415946 - 4543267 Moonriver RT1201 RT2500 1471037 - 5175574 Moonbase Alpha RT1200 RT2500 1648994 - 5053547 <p>You can review the relative PR on GitHub for more information.</p>"},{"location":"builders/build/historical-updates/#incorrect-effective-gas-price","title":"Incorrect Effective Gas Price In Transaction Receipts","text":"<p>The <code>effectiveGasPrice</code> value returned by <code>eth_getTransactionReceipt</code> was different from the on-chain value due to an incorrect calculation of the base fee. Specifically, the transaction receipt's value was computed using the <code>NextFeeMultiplier</code> from the block in which the transaction was included rather than the previous block, which is the correct source for computing the base fee.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1201 RT2801 415946 - 5899847 Moonriver RT1201 RT2801 1471037 - 6411588 Moonbase Alpha RT1200 RT2801 1648994 - 6209638 <p>You can review the relative Frontier PR and Moonbeam PR on GitHub for more information.</p>"},{"location":"builders/build/historical-updates/#skipped-ethereum-transaction-traces","title":"Skipped Ethereum Transaction Traces","text":"<p>Runtimes with the <code>evm-tracing</code> feature enabled introduced additional <code>ref_time</code> overhead due to special logic that traces Ethereum transactions (emitting events for each component: gasometer, runtime, EVM) used to fill information for RPC calls like <code>debug_traceTransaction</code> and <code>trace_filter</code>. </p> <p>Since the real <code>ref_time</code> in production runtimes is smaller, this could cause the block weight limits to be reached when replaying a block in an EVM-tracing runtime, resulting in skipped transaction traces. This was observed in Moonbeam block 9770044.</p> <p>The fix consisted of resetting the previously consumed weight before tracing each Ethereum transaction. It's important to note that this issue only affected code under <code>evm-tracing</code>, which is not included in any production runtime.</p> <p>This bug was fixed in the following runtime:</p> Network Fixed Impacted Block Moonbeam RT3501 9770044 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#notify-inactive-collator-fails","title":"Notify Inactive Collator Fails for Long-Inactive Collators","text":"<p>The <code>notifyInactiveCollator</code> extrinsic, designed to remove collators from the pool if they haven't produced any blocks in the last two rounds, failed for collators who had been inactive for significantly longer than two rounds. The transaction would only succeed within the first few blocks of a new round.</p> <p>The bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbase Alpha RT2601 RT3500 5474345 \u2013 10750816 Moonriver RT2602 RT3501 5638536 \u2013 10665393 Moonbeam RT2602 RT3501 4977160 \u2013 10056989"},{"location":"builders/build/historical-updates/#for-more-information-you-can-review-the-relative-pr-on-github","title":"For more information, you can review the relative PR on GitHub.","text":""},{"location":"builders/build/historical-updates/#migrations","title":"Migrations","text":"<p>Migrations are necessary when a storage item is changed or added and needs to be populated with data. The migrations listed below have been organized by the impacted pallet(s).</p>"},{"location":"builders/build/historical-updates/#author-mapping","title":"Author Mapping Pallet","text":""},{"location":"builders/build/historical-updates/#update-mapping-storage-item","title":"Update the Mapping Storage Item","text":"<p>This migration updated the now deprecated <code>Mapping</code> storage item of the author mapping pallet to use a more secure hasher type. The hasher type was updated to Blake2_128Concat instead of Twox64Concat.</p> <p>This migration was only applied to Moonriver and Moonbase Alpha and was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonriver RT800 684728 Moonbase Alpha RT800 915684 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#add-support-for-vrf-keys","title":"Add Support for VRF Keys","text":"<p>When VRF key support was introduced, the <code>MappingWithDeposit</code> storage item of the author mapping pallet was updated to include a <code>keys</code> field to support VRF keys that can be looked up via the Nimbus ID. A migration was applied to update the existing storage items with this new field.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1502 1107285 Moonriver RT1502 1814458 Moonbase Alpha RT1502 2112058 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#one-nimbus-id-per-account-id","title":"One Nimbus ID per Account ID","text":"<p>A migration was applied to ensure that an account ID can have only one Nimbus ID. The migration accepted the first Nimbus ID owned by a given account and cleared any additional Nimbus IDs associated with the account. For any cleared associations, the bond for the association was returned.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1606 1326697 Moonriver RT1605 2077599 Moonbase Alpha RT1603 2285347 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#base-fee","title":"Base Fee Pallet","text":""},{"location":"builders/build/historical-updates/#set-elasticity","title":"Set Elasticity Storage Item Value","text":"<p>This migration sets the <code>Elasticity</code> storage item of the base fee pallet to zero, which results in a constant <code>BaseFeePerGas</code>.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1300 524762 Moonriver RT1300 1541735 Moonbase Alpha RT1300 1761128 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#democracy","title":"Democracy Pallet","text":""},{"location":"builders/build/historical-updates/#preimage-storage-moved-to-new-preimage-pallet","title":"Preimage Storage Moved to New Preimage Pallet","text":"<p>A migration was applied, which moved preimages stored in the democracy pallet to a new preimage pallet. This migration on Moonbeam was required as a result of an upstream change to Polkadot.</p> <p>There was one preimage that was affected in Moonbeam, which was dropped from the scheduler queue and never executed: <code>0x14262a42aa6ccb3cae0a169b939ca5b185bc317bb7c449ca1741a0600008d306</code>. This preimage was manually removed by the account that initially submitted the preimage.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2000 3310369 Moonriver RT2000 3202604 Moonbase Alpha RT2000 2673234 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#remove-gov-v1-collectives","title":"Remove Governance V1 Collectives","text":"<p>A migration was applied to remove the governance V1 collectives, which included the Council and Technical Committee. The governance V1 collectives were replaced with the OpenGov (governance V2) Technical Committee.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2801 5899847 Moonriver RT2801 6411588 Moonbase Alpha RT2801 6209638 <p>For more information, you can review the relative PR on GitHub.</p> <p>A follow-up migration was required to properly clear the storage entries associated with the governance V1 collectives, which was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2901 6197065 Moonriver RT2901 6699589 Moonbase Alpha RT2901 6710531 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#remove-gov-v1-collectives","title":"Remove Governance V1 Democracy Pallet","text":"<p>A migration was applied to remove the storage associated with the Democracy Pallet used in governance V1. The Democracy Pallet was replaced with the Preimage, Referenda, and Collective Voting OpenGov (governance V2) pallets.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2901 6197065 Moonriver RT2901 6699589 Moonbase Alpha RT2901 6710531 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#evm-pallet","title":"EVM Pallet","text":""},{"location":"builders/build/historical-updates/#evm-contract-metadata","title":"EVM Contract Metadata","text":"<p>A migration was introduced to automate the manual process of setting EVM contract metadata for contracts deployed more than two years ago that hadn't been interacted with after the introduction of metadata storage item. This migration replaces the need to manually call <code>createContractMetadata(address)</code> on these contracts to make them compatible with the current runtime. </p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT3200 7985204 Moonriver RT3200 8519187"},{"location":"builders/build/historical-updates/#moonbeam-orbiter","title":"Moonbeam Orbiter Pallet","text":""},{"location":"builders/build/historical-updates/#remove-orbiter-minimum-bond","title":"Remove the Minimum Bond Requirement for Orbiter Collators","text":"<p>A migration was applied to the Moonbeam Orbiter Pallet that sets the bonds of the existing orbiter collators to zero. This change enabled payouts to be even for future orbiter program expansions.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2602 4977160 Moonriver RT2602 5638536 Moonbase Alpha RT2601 5474345 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#parachain-staking","title":"Parachain Staking Pallet","text":""},{"location":"builders/build/historical-updates/#update-collator-state-storage-item","title":"Update Collator State Storage Item","text":"<p>A migration was applied that updated the <code>Collator</code> storage item of the parachain staking pallet to the new <code>Collator2</code> storage item. This change updated the collator state to include the following items:</p> <ul> <li>The <code>nominators</code> set is a list of all of the nominator (delegator) account IDs without their respective balance bonded</li> <li>A new <code>top_nominators</code> storage item that returns a list of all of the top nominators ordered by greatest bond amount to least</li> <li>A new <code>bottom_nominators</code> storage item that returns a list of all of the bottom nominators ordered by least bond amount to greatest</li> <li>The <code>total</code> storage item was replaced with <code>total_counted</code> and <code>total_backing</code>. The <code>total_counted</code> item returns the sum of the top nominations and the collator's self-bond, whereas the <code>total_backing</code> item returns the sum of all of the nominations and the collator's self-bond</li> </ul> <p>This migration was only applied to Moonriver and Moonbase Alpha and was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonriver RT53 9696 Moonbase Alpha RT52 238827 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#patch-total-staked-amount","title":"Patch Total Staked Amount","text":"<p>A migration was applied to the <code>total</code> staked amount of the <code>CollatorState</code> storage item in the Parachain Staking Pallet due to a potential bug that may have led to an incorrect amount.</p> <p>This migration was only applied to Moonriver and Moonbase Alpha and was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonriver RT53 9696 Moonbase Alpha RT52 238827 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#support-delayed-nominator-exits","title":"Support Delayed Nominator (Delegator) Exits","text":"<p>The exit queue for handling candidate exits had been updated to include support for delayed nominator (delegator) exits and revocations, which required a migration to update the <code>ExitQueue</code> parachain staking pallet storage item to <code>ExitQueue2</code>. The <code>NominatorState</code> storage item was also migrated to <code>NominatorState2</code> to prevent a nominator from performing more nominations when they already have scheduled an exit.</p> <p>These migrations were only applied to Moonriver and Moonbase Alpha and were executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonriver RT200 259002 Moonbase Alpha RT200 457614 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#purge-staking-storage-bloat","title":"Purge Staking Storage Bloat","text":"<p>A migration was applied to purge staking storage bloat for the <code>Points</code> and <code>AtStake</code> storage items of the parachain staking pallet that are older than two rounds.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1001 5165 Moonriver RT1001 1052242 Moonbase Alpha RT1001 1285916 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#support-manual-exits-dpos-terminology","title":"Support Manual Exits and DPoS Terminology","text":"<p>The parachain staking pallet was updated to include manual exits. If a candidate or delegator wanted to decrease or revoke their bond or leave the candidate or delegator pool, they would need to schedule a request first, wait for a delay period to pass, and then manually execute the request. As such, a migration was applied to replace the automatic exit queue, including the <code>ExitQueue2</code> storage item, with a manual exits API.</p> <p>In addition, a change was made to switch from Nominated Proof of Stake (NPoS) to Delegated Proof of Stake (DPoS) terminology; this marked the sweeping change from \"nominate\" to \"delegate\". This required the migration of the following parachain staking pallet storage items:</p> <ul> <li><code>CollatorState2</code> was migrated to <code>CandidateState</code></li> <li><code>NominatorState2</code> was migrated to <code>DelegatorState</code></li> </ul> <p>These migrations were executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1001 5165 Moonriver RT1001 1052242 Moonbase Alpha RT1001 1285916 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#increase-max-delegations-per-candidate","title":"Increase Max Delegations per Candidate","text":"<p>A migration was applied to increase the maximum number of delegations per candidate in the parachain staking pallet. It increased the delegations from 100 to 500 on Moonbase Alpha and Moonriver and from 100 to 1000 on Moonbeam.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1101 171061 Moonriver RT1101 1188000 Moonbase Alpha RT1100 1426319 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#split-candidate-delegations-top-bottom","title":"Split Candidate Delegations into Top and Bottom","text":"<p>This migration splits the deprecated <code>CandidateState</code> storage item of the parachain staking pallet into the following three new storage items to avoid unnecessary storage reads:</p> <ul> <li><code>CandidateInfo</code></li> <li><code>TopDelegations</code></li> <li><code>BottomDelegations</code></li> </ul> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1201 415946 Moonriver RT1201 1471037 Moonbase Alpha RT1200 1648994 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#patch-incorrect-total-delegations","title":"Patch Incorrect Total Delegations","text":"<p>There was a migration applied to fix the Incorrect Collator Selection bug and patch the delegations total for all candidates.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1300 524762 Moonriver RT1300 1541735 Moonbase Alpha RT1300 1761128 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#split-delegator-state","title":"Split Delegator State into Delegation Scheduled Requests","text":"<p>A migration was applied that moved pending delegator requests from the <code>DelegatorState</code> storage item of the parachain staking pallet into a new <code>DelegationScheduledRequests</code> storage item.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1502 1107285 Moonriver RT1502 1814458 Moonbase Alpha RT1502 2112058 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#replace-staking-reserves","title":"Replace Staking Reserves with Locks","text":"<p>A migration was applied that changed users' staking reserved balances to locked balances. The locked balance is the same type as democracy-locked funds, allowing users to use their staked funds to participate in democracy.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1701 1581457 Moonriver RT1701 2281723 Moonbase Alpha RT1700 2529736 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#auto-compounding-support","title":"Auto-Compounding Support","text":"<p>To support auto-compounding, two migrations were applied to the <code>AtStake</code> storage item in the parachain staking pallet:</p> <ul> <li><code>RemovePaidRoundsFromAtStake</code> - to remove any stale <code>AtStake</code> entries relating to already paid-out rounds with candidates that didn't produce any blocks. This migration is a prerequisite for the <code>MigrateAtStakeAutoCompound</code> migration</li> <li><code>MigrateAtStakeAutoCompound</code> - migrates the snapshots for unpaid rounds for <code>AtStake</code> entries</li> </ul> <p>These migrations were executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1901 2317683 Moonriver RT1901 2911863 Moonbase Alpha RT1900 3069635 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#block-based-staking-rounds","title":"Switch to Block-Based Staking Rounds","text":"<p>A migration was applied to switch from time-based staking rounds to fixed block-based rounds.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2801 5899847 Moonriver RT2801 6411588 Moonbase Alpha RT2801 6209638 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#renaming-of-parachain-bond-reserve-events","title":"Renaming of Parachain Bond Reserve Events","text":"<p>Prior to Runtime 3300, the <code>ReservedForParachainBond</code> event was emitted once per round to indicate parachain bond reserve funding through inflation. In Runtime 3300, this same event was renamed to <code>InflationDistributed</code>.</p> <p>This change took effect at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT3300 8381443 Moonriver RT3300 8894417 Moonbase Alpha RT3300 9062316 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#referenda-pallet","title":"Referenda Pallet","text":""},{"location":"builders/build/historical-updates/#refunds-for-submission-deposits","title":"Refunds for Submission Deposits","text":"<p>A migration was introduced to support refunds for submission deposits on closed referenda that updated the <code>ReferendumInfo</code> type. The following invariants of <code>ReferendumInfo</code> were changed so that the second parameter, <code>Deposit&lt;AccountId, Balance&gt;</code>, is now optional, <code>Option&lt;Deposit&lt;AccountId, Balance&gt;&gt;</code>: <code>Approved</code>, <code>Rejected</code>, <code>Cancelled</code>, and <code>TimedOut</code>.</p> <p>This stemmed from an upstream change to the Substrate repository.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2302 3456477 Moonriver RT2302 4133065 Moonbase Alpha RT2301 4172407 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#restore-corrupted-referenda-deposits","title":"Restore Corrupted Referenda Deposits","text":"<p>A migration was introduced to support restoring referenda deposits affected by corrupted storage values. The issue arose when a migration was applied twice due to a pallet version error, resulting in invalid values and non-refundable submission deposits. As the number of values to correct was finite and small, this migration created a list to update them by hand.</p> <p>This migration was only applied to Moonbeam and was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT3100 7303601"},{"location":"builders/build/historical-updates/#xcm-related-pallets","title":"XCM-Related Pallets","text":""},{"location":"builders/build/historical-updates/#update-transaction-info","title":"Update Transact Info Storage Item","text":"<p>There was a migration applied to the <code>TransactInfo</code> storage item of the XCM Transactor Pallet that changed the following items:</p> <ul> <li><code>max_weight</code> is added to prevent transactors from stalling the queue in the destination chain</li> <li>Removes <code>fee_per_byte</code>, <code>metadata_size</code>, and <code>base_weight</code> as these items are not necessary for XCM transactions</li> <li><code>fee_per_second</code> replaces <code>fee_per_weight</code> to better reflect cases (like Kusama) in which the <code>fee_per_weight</code> unit is lower than one</li> </ul> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1201 415946 Moonriver RT1201 1471037 Moonbase Alpha RT1200 1648994 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#add-support-statemine-prefix","title":"Add Support for Kusama Asset Hub (Statemine) Prefix Breaking Change","text":"<p>The following three migrations were added to the asset manager pallet to avoid issues with Kusama Asset Hub's (previously referred to as Statemine) breaking change to the way it represents assets and possible future breaking changes:</p> <ul> <li><code>UnitsWithAssetType</code> - updates the <code>AssetTypeUnitsPerSecond</code> storage item to a mapping of the <code>AssetType</code> to <code>units_per_second</code>, instead of the mapping <code>AssetId</code> to <code>units_per_second</code>. This is done to avoid additional migrations whenever a breaking change arises</li> <li><code>PopulateAssetTypeIdStorage</code> - creates a new <code>AssetTypeId</code> storage item that holds the <code>AssetType</code> to <code>AssetId</code> mapping, which allows the decoupling of <code>assetIds</code> and <code>AssetTypes</code></li> <li><code>ChangeStateminePrefixes</code> - updates already registered Kusama Asset Hub (Statemine) assets to their new form</li> </ul> <p>These migrations were executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1201 415946 Moonriver RT1201 1471037 Moonbase Alpha RT1200 1648994 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#add-supported-fee-payment-assets","title":"Add New Supported Fee Payment Assets Storage Item","text":"<p>A migration was applied to the asset manager pallet, creating a new <code>SupportedFeePaymentAssets</code> storage item by reading the supported asset data from the <code>AssetTypeUnitsPerSecond</code> storage item. This storage item will hold all the assets we accept for XCM fee payment. It will be read when an incoming XCM message is received, and if the asset is not in storage, the message will not be processed.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1300 524762 Moonriver RT1300 1541735 Moonbase Alpha RT1300 1761128 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#update-xcm-transactor","title":"Update the XCM Transactor Storage from V2 to V3","text":"<p>With the support of XCM V3, a migration was applied to update the XCM Transactor pallet's storage from XCM V2 to V3. The <code>transactInfoWithWeightLimit</code> and <code>destinationAssetFeePerSecond</code> storage items were updated to support XCM V3 multilocations.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2302 3456477 Moonriver RT2302 4133065 Moonbase Alpha RT2301 4172407 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#remove-local-assets","title":"Remove Mintable XC-20s","text":"<p>Mintable XC-20s were deprecated in favor of XCM-enabled ERC-20s; as such, a migration was applied to remove the local assets pallet and clear the assets in storage.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2801 5899847 Moonriver RT2801 6411588 Moonbase Alpha RT2801 6209638 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#foreign-assets-migration","title":"Manage Foreign Assets via Smart Contracts","text":"<p>A migration was applied to transition existing foreign assets to a new design that manages XCM derivative assets on Moonbeam through EVM smart contracts instead of the previous implementation using the Asset and Asset Manager pallets. The migration process involved several extrinsics in the Moonbeam Lazy Migration pallet:</p> <ul> <li><code>approve_assets_to_migrate</code> - sets the list of asset IDs approved for migration</li> <li><code>start_foreign_asset_migration</code> - initiates migration for a specific foreign asset by freezing the original asset and creating a new EVM smart contract</li> <li><code>migrate_foreign_asset_balances</code> - migrates asset balances in batches from old assets pallet to the new system</li> <li><code>migrate_foreign_asset_approvals</code> - migrates asset approvals in batches while unreserving deposits from the old approval system</li> <li><code>finish_foreign_asset_migration</code> - completes migration after all balances and approvals are migrated and performs final cleanup</li> </ul> <p>This migration preserves compatibility with existing foreign assets by identifying each foreign asset with the same AssetID integer as before. This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT3501 10056989 Moonriver RT3501 10665393 Moonbase Alpha RT3500 10750816 <p>For more information, you can review the relative PRs on GitHub: 2869 and 3020.</p>"},{"location":"builders/build/historical-updates/#nimbus","title":"Nimbus Author Filter Pallet","text":""},{"location":"builders/build/historical-updates/#replace-eligible-ratio","title":"Replace Eligible Ratio with Eligible Count","text":"<p>A breaking change was applied to the Nimbus repository, deprecating <code>EligibleRatio</code> in favor of the <code>EligibleCount</code> config. As a result, a migration was applied to the Moonbeam repository, populating the new <code>EligibleCount</code> value as a percentage of the potential authors defined at that block height if the <code>EligibleRatio</code> value existed. Otherwise, the value was set to a default value of <code>50</code>.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1502 1107285 Moonriver RT1502 1814458 Moonbase Alpha RT1502 2112058 <p>For more information, you can review the relative Nimbus PR and Moonbeam PR on GitHub.</p>"},{"location":"builders/build/runtime-upgrades/","title":"Runtime Upgrades","text":""},{"location":"builders/build/runtime-upgrades/#introduction","title":"Introduction","text":"<p>Moonbeam runtime upgrades allow for the maintenance and evolution of the chain logic without the need for a hard fork. These runtime upgrades can introduce new features, improve performance, fix bugs, and respond to changing requirements.</p> <p>This page provides a historical record of runtime upgrades by block for each of the Moonbeam-based networks.</p>"},{"location":"builders/build/runtime-upgrades/#runtime-upgrades-by-block","title":"Runtime Upgrades by Block","text":"<p>The following table contains a list of the runtime upgrades and the block at which the upgrade occurred for each network. Runtime upgrades occur first on Moonbase Alpha before being released on Moonriver and then on Moonbeam. You can read the release notes for each runtime on the Moonbeam releases GitHub page.</p> <p>Not all runtime upgrades are released on each network, as sometimes after releasing the initial runtime upgrade, the need for a subsequent upgrade arises. If a runtime upgrade version has been skipped or hasn't been released yet (only applicable to the latest runtime upgrade), you'll see a <code>-</code> in that row.</p> Runtime Moonbeam Moonriver Moonbase Alpha 40 - - 0 44 - - 142863 47 - - 209144 49 - 0 - 52 - - 238827 53 - 9696 - 155 - 67938 278703 159 - 166749 383465 200 - 259002 457614 300 - 344698 485543 400 - 400458 610935 501 - 430442 653692 600 - 455107 675176 701 - 581187 797200 800 - 684728 915684 900 0 923864 1075626 901 - - 1130271 902 - - 1175311 1001 5165 1052242 1285916 1002 32532 1141593 1396972 1101 171061 1188000 1426319 1102 214641 1295420 1517440 1103 312036 1389122 1591913 1200 - - 1648994 1201 415946 1471037 1679619 1300 524762 1541735 1761128 1400 - - 1962557 1401 915320 1705939 1967358 1502 1107285 1814458 2112058 1503 1115896 1909326 2220736 1504 1117310 1910640 2221773 1603 - - 2285347 1605 - 2077599 2318567 1606 1326697 2105127 2379759 1700 - - 2529736 1701 1581457 2281723 2534200 1702 1821212 2524247 - 1800 - - 2748786 1801 - 2572556 2830542 1802 1919458 2616190 2879403 1803 2073477 2767174 3004714 1900 - - 3069635 1901 2317683 2911863 3073562 2000 2673234 3202604 3310369 2100 3011798 3588831 3609708 2201 3290853 3858885 3842850 2301 - - 4172407 2302 3456477 4133065 4193323 2401 - 4668844 4591616 2402 - - 4772817 2403 4163078 4770488 4804425 2500 - 5175574 5053547 2501 4543267 5211264 5194594 2601 - - 5474345 2602 4977160 5638536 5576588 2700 5504531 6041969 5860584 2801 5899847 6411588 6209638 2901 6197065 6699589 6710531 2902 - - 6732678 3000 - 7043011 7299818 3001 6593037 - - 3100 7303601 7829527 8034666 3102 7586782 - - 3200 7985204 8519187 8722328 3300 8381443 8894417 9062316 3400 9376921 9774989 9830392 3401 9661355 10269872 10422450 3500 - - 10750816 3501 10056989 10665393 10833906 3600 10746745 11251274 11452321 3601 10999397 11692212 - 3700 - - 12152458 3701 11426910 12003279 12242104 3702 11499659 12156948 12683255 3800 12120762 12540836 12853655 3900 - - 13744972"},{"location":"builders/ethereum/canonical-contracts/","title":"Canonical Contracts","text":""},{"location":"builders/ethereum/canonical-contracts/#common-goods-contracts","title":"Common-good Contracts","text":"<p>The following contracts addresses have been established:</p> MoonbeamMoonriverMoonbase Alpha Contract Address WGLMR 0xAcc15dC74880C9944775448304B263D191c6077F Multicall 0x83e3b61886770de2F64AAcaD2724ED4f08F7f36B Multicall2 0x6477204E12A7236b9619385ea453F370aD897bb2 Multicall3 0xcA11bde05977b3631167028862bE2a173976CA11 Multisig Factory 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2 EIP-1820 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24 Contract Address WMOVR 0x98878B06940aE243284CA214f92Bb71a2b032B8A Multicall* 0x30f283Cc0284482e9c29dFB143bd483B5C19954b Multicall2 0xaef00a0cf402d9dedd54092d9ca179be6f9e5ce3 Multicall3 0xcA11bde05977b3631167028862bE2a173976CA11 Multisig Factory 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2 EIP-1820 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24 <p>*Deployed by SushiSwap</p> Contract Address WDEV 0xD909178CC99d318e4D46e7E66a972955859670E1 Multicall* 0x4E2cfca20580747AdBA58cd677A998f8B261Fc21 Multicall2 0x37084d0158C68128d6Bc3E5db537Be996f7B6979 Multicall3 0xcA11bde05977b3631167028862bE2a173976CA11 Multisig Factory 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2 EIP-1820 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24 <p>*Deployed in the UniswapV2 Demo Repo</p>"},{"location":"builders/ethereum/canonical-contracts/#precompiled-contracts","title":"Precompiled Contracts","text":"<p>There are a set of precompiled contracts included on Moonbeam, Moonriver, and Moonbase Alpha that are categorized by address and based on the origin network. If you were to convert the precompiled addresses to decimal format, and break them into categories by numeric value, the categories are as follows:</p> <ul> <li>0-1023 - Ethereum MainNet precompiles</li> <li>1024-2047 - precompiles that are not in Ethereum and not Moonbeam specific</li> <li>2048-4095 - Moonbeam specific precompiles</li> </ul>"},{"location":"builders/ethereum/canonical-contracts/#ethereum-mainnet-precompiles","title":"Ethereum MainNet Precompiles","text":"MoonbeamMoonriverMoonbase Alpha Contract Address ECRECOVER 0x0000000000000000000000000000000000000001 SHA256 0x0000000000000000000000000000000000000002 RIPEMD160 0x0000000000000000000000000000000000000003 Identity 0x0000000000000000000000000000000000000004 Modular Exponentiation 0x0000000000000000000000000000000000000005 BN128Add 0x0000000000000000000000000000000000000006 BN128Mul 0x0000000000000000000000000000000000000007 BN128Pairing 0x0000000000000000000000000000000000000008 Blake2 0x0000000000000000000000000000000000000009 P256Verify 0x0000000000000000000000000000000000000100 Contract Address ECRECOVER 0x0000000000000000000000000000000000000001 SHA256 0x0000000000000000000000000000000000000002 RIPEMD160 0x0000000000000000000000000000000000000003 Identity 0x0000000000000000000000000000000000000004 Modular Exponentiation 0x0000000000000000000000000000000000000005 BN128Add 0x0000000000000000000000000000000000000006 BN128Mul 0x0000000000000000000000000000000000000007 BN128Pairing 0x0000000000000000000000000000000000000008 Blake2 0x0000000000000000000000000000000000000009 P256Verify 0x0000000000000000000000000000000000000100 Contract Address ECRECOVER 0x0000000000000000000000000000000000000001 SHA256 0x0000000000000000000000000000000000000002 RIPEMD160 0x0000000000000000000000000000000000000003 Identity 0x0000000000000000000000000000000000000004 Modular Exponentiation 0x0000000000000000000000000000000000000005 BN128Add 0x0000000000000000000000000000000000000006 BN128Mul 0x0000000000000000000000000000000000000007 BN128Pairing 0x0000000000000000000000000000000000000008 Blake2 0x0000000000000000000000000000000000000009 P256Verify 0x0000000000000000000000000000000000000100"},{"location":"builders/ethereum/canonical-contracts/#non-moonbeam-specific-nor-ethereum-precompiles","title":"Non-Moonbeam Specific nor Ethereum Precompiles","text":"MoonbeamMoonriverMoonbase Alpha Contract Address SHA3FIPS256 0x0000000000000000000000000000000000000400 Dispatch [Removed] 0x0000000000000000000000000000000000000401 ECRecoverPublicKey 0x0000000000000000000000000000000000000402 Contract Address SHA3FIPS256 0x0000000000000000000000000000000000000400 Dispatch [Removed] 0x0000000000000000000000000000000000000401 ECRecoverPublicKey 0x0000000000000000000000000000000000000402 Contract Address SHA3FIPS256 0x0000000000000000000000000000000000000400 Dispatch [Removed] 0x0000000000000000000000000000000000000401 ECRecoverPublicKey 0x0000000000000000000000000000000000000402"},{"location":"builders/ethereum/canonical-contracts/#moonbeam-specific-precompiles","title":"Moonbeam-Specific Precompiles","text":"MoonbeamMoonriverMoonbase Alpha Contract Address Parachain Staking 0x0000000000000000000000000000000000000800 Crowdloan Rewards 0x0000000000000000000000000000000000000801 ERC-20 Interface 0x0000000000000000000000000000000000000802 Democracy [Removed] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 Relay Encoder 0x0000000000000000000000000000000000000805 XCM Transactor V1 0x0000000000000000000000000000000000000806 Author Mapping 0x0000000000000000000000000000000000000807 Batch 0x0000000000000000000000000000000000000808 Randomness 0x0000000000000000000000000000000000000809 Call Permit 0x000000000000000000000000000000000000080a Proxy 0x000000000000000000000000000000000000080b XCM Utilities 0x000000000000000000000000000000000000080C XCM Transactor V2 0x000000000000000000000000000000000000080d Council Collective [Removed] 0x000000000000000000000000000000000000080e Technical Committee Collective [Removed] 0x000000000000000000000000000000000000080f Treasury Council Collective 0x0000000000000000000000000000000000000810 Referenda 0x0000000000000000000000000000000000000811 Conviction Voting 0x0000000000000000000000000000000000000812 Preimage 0x0000000000000000000000000000000000000813 OpenGov Tech Committee 0x0000000000000000000000000000000000000814 Precompile Registry 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM Transactor V3 0x0000000000000000000000000000000000000817 Identity 0x0000000000000000000000000000000000000818 XCM Interface 0x000000000000000000000000000000000000081A Contract Address Parachain Staking 0x0000000000000000000000000000000000000800 Crowdloan Rewards 0x0000000000000000000000000000000000000801 ERC-20 Interface 0x0000000000000000000000000000000000000802 Democracy [Removed] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 Relay Encoder 0x0000000000000000000000000000000000000805 XCM Transactor V1 0x0000000000000000000000000000000000000806 Author Mapping 0x0000000000000000000000000000000000000807 Batch 0x0000000000000000000000000000000000000808 Randomness 0x0000000000000000000000000000000000000809 Call Permit 0x000000000000000000000000000000000000080a Proxy 0x000000000000000000000000000000000000080b XCM Utilities 0x000000000000000000000000000000000000080C XCM Transactor V2 0x000000000000000000000000000000000000080d Council Collective [Removed] 0x000000000000000000000000000000000000080e Technical Committee Collective [Removed] 0x000000000000000000000000000000000000080f Treasury Council Collective 0x0000000000000000000000000000000000000810 Referenda 0x0000000000000000000000000000000000000811 Conviction Voting 0x0000000000000000000000000000000000000812 Preimage 0x0000000000000000000000000000000000000813 OpenGov Tech Committee 0x0000000000000000000000000000000000000814 Precompile Registry 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM Transactor V3 0x0000000000000000000000000000000000000817 Identity 0x0000000000000000000000000000000000000818 XCM Interface 0x000000000000000000000000000000000000081A Contract Address Parachain Staking 0x0000000000000000000000000000000000000800 Crowdloan Rewards 0x0000000000000000000000000000000000000801 ERC-20 Interface 0x0000000000000000000000000000000000000802 Democracy [Removed] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 Relay Encoder 0x0000000000000000000000000000000000000805 XCM Transactor V1 0x0000000000000000000000000000000000000806 Author Mapping 0x0000000000000000000000000000000000000807 Batch 0x0000000000000000000000000000000000000808 Randomness 0x0000000000000000000000000000000000000809 Call Permit 0x000000000000000000000000000000000000080a Proxy 0x000000000000000000000000000000000000080b XCM Utilities 0x000000000000000000000000000000000000080C XCM Transactor V2 0x000000000000000000000000000000000000080d Council Collective [Removed] 0x000000000000000000000000000000000000080e Technical Committee Collective [Removed] 0x000000000000000000000000000000000000080f Treasury Council Collective 0x0000000000000000000000000000000000000810 Referenda 0x0000000000000000000000000000000000000811 Conviction Voting 0x0000000000000000000000000000000000000812 Preimage 0x0000000000000000000000000000000000000813 OpenGov Tech Committee 0x0000000000000000000000000000000000000814 Precompile Registry 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM Transactor V3 0x0000000000000000000000000000000000000817 Identity 0x0000000000000000000000000000000000000818 XCM Interface 0x000000000000000000000000000000000000081A"},{"location":"builders/ethereum/dev-env/ape/","title":"Using Ape to Deploy To Moonbeam","text":""},{"location":"builders/ethereum/dev-env/ape/#introduction","title":"Introduction","text":"<p>Ape is an Ethereum development environment that helps Python developers manage and automate the recurring tasks inherent to building smart contracts and DApps. Ape can directly interact with Moonbeam's Ethereum API, so you can also use Ape to deploy smart contracts on Moonbeam.</p> <p>This guide will walk you through using Ape to compile, deploy, and interact with Ethereum smart contracts on the Moonbase Alpha TestNet. You can adapt this guide for Moonbeam, Moonriver, or a Moonbeam development node.</p>"},{"location":"builders/ethereum/dev-env/ape/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, ensure you have the following:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul>"},{"location":"builders/ethereum/dev-env/ape/#creating-an-ape-project","title":"Creating an Ape Project","text":"<p>If you don't already have an Ape project, you must install Ape and create a new one. You can follow the steps below to get started and create an empty project:</p> <ol> <li> <p>Create a directory for your project</p> <pre><code>mkdir ape &amp;&amp; cd ape\n</code></pre> </li> <li> <p>If you don't have <code>pipx</code> installed, install it</p> <pre><code>python3 -m pip install --user pipx\npython3 -m pipx ensurepath\n</code></pre> </li> <li> <p>Install Ape using <code>pipx</code></p> <pre><code>pipx install eth-ape\n</code></pre> </li> <li> <p>Create a project</p> <pre><code>ape init\n</code></pre> </li> <li> <p>Enter a name for your project</p> <p> ape init Please enter project name: ape-demo SUCCESS: ape-demo is written in ape-config.yaml ls ape-config.yaml  contracts  scripts  tests </p> </li> </ol> <p>Your Ape project contains a bare-bones <code>ape-config.yaml</code> file for customizing specific settings and the following empty directories:</p> <ul> <li><code>contracts</code> - an empty directory for storing smart contracts</li> <li><code>scripts</code> - an empty directory for storing Python scripts, such as deployment scripts and scripts to interact with your deployed contracts</li> <li><code>tests</code> - an empty directory for pytest testing scripts</li> </ul>"},{"location":"builders/ethereum/dev-env/ape/#configure-accounts","title":"Configure Accounts","text":"<p>You'll need to import an account before you can deploy smart contracts or interact with previously deployed contracts from your Ape project. You can run the following command, which will import your account and give it a name:</p> <pre><code>ape accounts import INSERT_ACCOUNT_NAME\n</code></pre> <p>You'll then be prompted to enter your private key and add a password to encrypt your account.</p> ape accounts import alice Enter Private Key: Create Passphrase to encrypt account: Repeat for confirmation: SUCCESS: A new account '0x097D9Eea23DE2D3081169e0225173d0C55768338' has been added with the id 'alice' <p>Note</p> <p>If you wish to use a mnemonic instead, you can append the <code>--use-mnemonic</code> option to the import command.</p>"},{"location":"builders/ethereum/dev-env/ape/#the-contract-file","title":"Create Smart Contracts","text":"<p>Now that you have set up your account, you can start writing smart contracts. As a basic example, you can use the following <code>Box</code> contract to store a value you can retrieve later.</p> <p>Start by creating a file named <code>Box.sol</code> inside the contracts directory:</p> <pre><code>touch contracts/Box.sol\n</code></pre> <p>Open the file and add the following contract to it:</p> <pre><code>// SPDX-License-Identifier: MIT \npragma solidity ^0.8.1;\n\ncontract Box {\n    uint256 private value;\n\n    event ValueChanged(uint256 newValue);\n\n    function store(uint256 newValue) public {\n        value = newValue;\n        emit ValueChanged(newValue);\n    }\n\n    function retrieve() public view returns (uint256) {\n        return value;\n    }\n}\n</code></pre> <p>You can store any additional contracts in the <code>contracts</code> directory.</p>"},{"location":"builders/ethereum/dev-env/ape/#compiling-solidity","title":"Compile the Solidity Contract","text":"<p>Before compiling the Solidity, you must install the Solidity compiler plugin. Running the following command will install the latest version of the plugin:</p> <pre><code>ape plugins install solidity\n</code></pre> <p>To use a specific version of Solidity or a specific EVM version, you can modify your <code>ape-config.yaml</code> file as follows:</p> <pre><code>solidity:\n  version: INSERT_VERSION\n  evm_version: INSERT_VERSION\n</code></pre> <p>For more information on the Solidity plugin, please refer to the README of the <code>ape-solidity</code> repository on GitHub.</p> <p>With the Solidity plugin installed, the next step is to compile the smart contract:</p> <pre><code>ape compile\n</code></pre> ape compile INFO: Compiling 'Box.sol'. INFO: Compiling using Solidity compiler '0.8.23+commit.f704f362'. <p>After compilation, you can find the bytecode and ABI for your contracts in the <code>.build</code> directory.</p>"},{"location":"builders/ethereum/dev-env/ape/#test-the-contract","title":"Test the Contract","text":"<p>Before you deploy your contract, you can test it out directly inside your Ape project using the pytest framework to make sure it works as you expect.</p> <p>You should already have a <code>tests</code> directory where you'll create your tests, but if not, please create one, as all tests must be located in a directory named <code>tests</code>. Additionally, each test file name must start with <code>test_</code> and end with <code>.py</code>. So, first, you can create a test file for the <code>Box.sol</code> contract:</p> <pre><code>touch tests/test_box.py\n</code></pre> <p>In addition to the test file, you can create a <code>conftest.py</code> file that will define a couple of essential fixtures. Fixtures allow you to define functions that set up the necessary environment or resources to run your tests. Note that while the <code>Box.sol</code> contract is simple, incorporating fixtures into your testing process is good practice.</p> <p>To create the file, you can run the following command:</p> <pre><code>touch tests/conftest.py\n</code></pre> <p>Since your tests will rely on the injection of the fixtures, you must define the fixtures first. When defining fixtures, you need to apply the <code>pytest.fixture</code> decorator above each function. For this example, you'll create two fixtures: one that defines the owner of the contract and one that deploys the contract from the owner's account.</p> <p>The <code>owner</code> fixture will use the built-in <code>accounts</code> fixture to take the first account in the list of test accounts provided by Ape and return it. The <code>box</code> fixture will deploy the <code>Box</code> contract type using the built-in <code>project</code> fixture, you simply have to provide the name of the contract and use the <code>owner</code> fixture to deploy it.</p> tests/conftest.py<pre><code>import pytest\n\n\n@pytest.fixture\ndef owner(accounts):\n    return accounts[0]\n\n\n@pytest.fixture\ndef box(owner, project):\n    return owner.deploy(project.Box)\n</code></pre> <p>Now that you've created the fixtures, you can start creating your tests. Each test function name must start with <code>test_</code> and describe what the test does. For this example, you can use <code>test_store_value</code>, as you'll create a test for the <code>store</code> function. The test will store a value and then retrieve it, asserting that the retrieved value is equal to the value passed into the <code>store</code> function.</p> <p>To use the <code>owner</code> and <code>box</code> fixtures, you must pass them into your test function, which will inject the fixtures automatically for you to use. The <code>owner</code> account will be used to call the <code>store</code> function of the <code>box</code> contract instance.</p> tests/test_box.py<pre><code>def test_store_value(box, owner):\n    new_value = 5\n    box.store(new_value, sender=owner)\n    assert box.retrieve() == new_value\n</code></pre> <p>And that's it! That's all you'll need inside your test file. You can use the following command to run the test:</p> <pre><code>ape test\n</code></pre> <p>The results of running the test will be printed to the terminal.</p> ape test ===================== test session starts ====================== platform darwin -- Python 3.10.4, pytest-7.2.1, pluggy-1.4.0 rootdir: /Users/moonbeam/ape plugins: eth-ape-0.7.7, web3-6.15.1 collected 1 item tests/test_box.py .                                      [100%] ====================== 1 passed in 0.70s ======================= <p>Now that you have confidence in your contract, the next step is to deploy it.</p>"},{"location":"builders/ethereum/dev-env/ape/#deploy-the-contract","title":"Deploy the Contract","text":"<p>To deploy your contracts, create a deployment script named <code>deploy.py</code> inside of the <code>scripts</code> directory:</p> <pre><code>touch scripts/deploy.py\n</code></pre> <p>Next, you'll need to write the deployment script. You'll need to load the account you will use to deploy the contract and access it by its name using the project manager.</p> scripts/deploy.py<pre><code>from ape import project, accounts\n\n\ndef main():\n    # Load your account by its name\n    account = accounts.load(\"alice\")\n    # Deploy the contract using your account\n    return account.deploy(project.Box)\n</code></pre> <p>Now you're ready to deploy the <code>Box</code> contract! To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>Take the following steps to initiate and send the deployment transaction. Note that there are some nuances associated with using Ape with a local Moonbeam node.</p> <ol> <li> <p>Run the deployment script using the <code>ape run deploy</code> command</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>ape run deploy --network moonbeam:mainnet\n</code></pre> <pre><code>ape run deploy --network moonbeam:moonriver\n</code></pre> <pre><code>ape run deploy --network moonbeam:moonbase\n</code></pre> <pre><code>ape run deploy --network ethereum:local_moonbeam:http://127.0.0.1:9944\n</code></pre> <p>Note</p> <p>For the <code>ape run deploy</code> command to work as intended, the deployment script must be named <code>deploy.py</code> and stored in the <code>scripts</code> directory, and the script must define a <code>main()</code> method.</p> </li> <li> <p>Review the transaction details and enter y to sign the transaction</p> </li> <li>Enter your passphrase for your account</li> <li>Enter y to leave your account unlocked or n to lock it</li> </ol> <p>After you follow the prompts and submit the transaction, the transaction hash, total fees paid, and contract address will be displayed in the terminal.</p> ape run deploy --network https://rpc.api.moonbase.moonbeam.network INFO: Connecting to a 'moonbase' node. DynamicFeeTransaction:   chainId: 1287   from: 0x097D9Eea23DE2D3081169e0225173d0C55768338   gas: 123964   nonce: 372   value: 0   data: 0x307836...303333   type: 2   maxFeePerGas: 125000000   maxPriorityFeePerGas: 0   accessList: [] Sign:  [y/N]: y Enter passphrase to unlock 'alice' []: Leave 'alice' unlocked? [y/N]: n INFO: Confirmed 0x365cd903e7fac5ad1f815d7a6f211b1aa32bd7d78630c2e81d67514cfb9e55bb (total fees paid = 15326250000000) SUCCESS: Contract 'Box' deployed to: 0x68039277300E8B104dDf848029dCA04C2EFe8610 <p>Congratulations! Your contract is live! Save the address to interact with your contract in the following section.</p>"},{"location":"builders/ethereum/dev-env/ape/#interact-with-the-contract","title":"Interact with the Contract","text":"<p>You can interact with contracts using the Ape console for quick debugging and testing, or write a script.</p>"},{"location":"builders/ethereum/dev-env/ape/#using-ape-console","title":"Using The Ape Console","text":"<p>To interact with your newly deployed contract, you can launch the Ape console by running:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>ape console --network moonbeam:mainnet\n</code></pre> <pre><code>ape console --network moonbeam:moonriver\n</code></pre> <pre><code>ape console --network moonbeam:moonbase\n</code></pre> <pre><code>ape console --network ethereum:local_moonbeam:http://127.0.0.1:9944\n</code></pre> <p>Next, you'll need to create a contract instance using the contract's address:</p> <pre><code>box = Contract(\"INSERT_CONTRACT_ADDRESS\")\n</code></pre> ape console --network https://rpc.api.moonbase.moonbeam.network INFO: Connecting to a 'moonbase' node.  alice = accounts.load(\"alice\")  box = Contract(\"0x68039277300E8B104dDf848029dCA04C2EFe8610\") <p>Now, you can interact with your contract instance! For example, you can set the variable to be stored in the <code>Box</code> contract using the following commands:</p> <ol> <li> <p>Call the <code>store</code> method by passing in a value to store and the account you want to use to send the transaction:</p> <pre><code>box.store(5, sender=alice)\n</code></pre> </li> <li> <p>Review the transaction details and enter y to sign the transaction</p> </li> <li>If you previously locked your account, you must enter your passphrase to unlock it. Otherwise, Ape will use the cached key for your account</li> <li>If you unlocked your account in the previous step, you'll be asked if you want to leave your account unlocked. You can enter y to leave it unlocked or n to lock it</li> </ol> <p>After you follow the prompts and submit the transaction, the transaction hash and total fees paid will be displayed in the terminal.</p>  box.store(4, sender=alice) DynamicFeeTransaction:   chainId: 1287   to: 0x68039277300E8B104dDf848029dCA04C2EFe8610   from: 0x097D9Eea23DE2D3081169e0225173d0C55768338   gas: 45668   nonce: 373   value: 0   data: 0x307836...303034   type: 2   maxFeePerGas: 125000000   maxPriorityFeePerGas: 0   accessList: [] Sign:  [y/N]: y Enter passphrase to unlock 'alice' []: Leave 'alice' unlocked? [y/N]: n INFO: Confirmed 0xd2e8305f22f33c1ab8ccaaef94252a93ff0f69c9bf98503fc2744bf257f1ef67 (total fees paid = 5573750000000)  Receipt 0xd2e8305f22f33c1ab8ccaaef94252a93ff0f69c9bf98503fc2744bf257f1ef67 <p>Then, you can retrieve the stored value by calling the <code>retrieve</code> method:</p> <pre><code>box.retrieve()\n</code></pre> <p>The number you just stored in the previous steps will be printed to the console.</p>  contract.retrieve()  5"},{"location":"builders/ethereum/dev-env/ape/#using-a-script","title":"Using a Script","text":"<p>You can also write a script to interact with your newly deployed contract. To get started, you can create a new file in the <code>scripts</code> directory:</p> <pre><code>touch scripts/store-and-retrieve.py\n</code></pre> <p>Next, you can write a script that stores and retrieves a value. Note that when creating a contract instance to interact with, you must pass in the address of the deployed contract.</p> scripts/store-and-retrieve.py<pre><code>from ape import Contract, accounts\n\n\ndef main():\n    account = accounts.load(\"alice\")\n    box = Contract(\"INSERT_CONTRACT_ADDRESS\")\n    store = box.store(4, sender=account)\n    print(\"Transaction hash for updating the stored value:\", store.txn_hash)\n\n    retrieve = box.retrieve()\n    print(\"Stored value:\", retrieve)\n</code></pre> <p>Now, you can run the script to set the stored value and retrieve it:</p> <ol> <li> <p>Run the script</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>ape run store-and-retrieve --network moonbeam:mainnet\n</code></pre> <pre><code>ape run store-and-retrieve --network moonbeam:moonriver\n</code></pre> <pre><code>ape run store-and-retrieve --network moonbeam:moonbase\n</code></pre> <pre><code>ape run store-and-retrieve --network ethereum:local_moonbeam:http://127.0.0.1:9944\n</code></pre> </li> <li> <p>Review the transaction details and enter y to sign the transaction</p> </li> <li>If you previously locked your account, you must enter your passphrase to unlock it. Otherwise, Ape will use the cached key for your account</li> <li>If you unlocked your account in the previous step, you'll be asked if you want to leave your account unlocked. You can enter y to leave it unlocked or n to lock it</li> </ol> <p>Once completed, you should see a transaction hash and a value of <code>5</code> printed to the console.</p> ape run store-and-retrieve --network https://rpc.api.moonbase.moonbeam.network DynamicFeeTransaction:   chainId: 1287   to: 0x68039277300E8B104dDf848029dCA04C2EFe8610   from: 0x097D9Eea23DE2D3081169e0225173d0C55768338   gas: 25974   nonce: 374   value: 0   data: 0x307836...303035   type: 2   maxFeePerGas: 125000000   maxPriorityFeePerGas: 0   accessList: [] Sign:  [y/N]: y Enter passphrase to unlock 'alice' []: Leave 'alice' unlocked? [y/N]: n INFO: Confirmed 0x6d74e48c23fd48438bf48baad34e235693c737bd880ef0077c0fb996f3896f5f (total fees paid = 3086250000000) Transaction hash for updating the stored value:  0x6d74e48c23fd48438bf48baad34e235693c737bd880ef0077c0fb996f3896f5f Stored value: 5 <p>Congratulations! You have successfully deployed and interacted with a contract using Ape!</p>"},{"location":"builders/ethereum/dev-env/ape/#using-ape-with-a-local-node","title":"Using Ape with a Local Node","text":"<p>There are some nuances associated with using Ape with a local Moonbeam node. As a Moonbeam local node is not included as a preset network with Ape, you'll need to customize your <code>ape-config.yaml</code> before using Ape with a local Moonbeam node. Adjust your <code>ape-config.yaml</code> as follows: </p> <pre><code># ape-config.yaml\nname: ape-demo\n\ndefault_ecosystem: ethereum\n\nethereum:\n  default_network: local_moonbeam\n\n  local_moonbeam:\n    default_transaction_type: 0\n    gas_limit: \"auto\"\n    block_time: 6\n    transaction_acceptance_timeout: 60\n    max_receipt_retries: 10\n\nnetworks:\n  custom:\n    - name: local_moonbeam\n      chain_id: 1281                    \n      ecosystem: ethereum\n      base_ecosystem_plugin: ethereum\n      default_provider: node\n\nnode:\n  ethereum:\n    local_moonbeam:\n      uri: http://127.0.0.1:9944\n</code></pre> <p>After configuring your <code>ape-config.yaml</code>, you can target your local Moonbeam node by appending the following network configuration flag to your Ape command:</p> <pre><code>--network ethereum:local_moonbeam:http://127.0.0.1:9944\n</code></pre> <p>Additionally, when deploying or interacting with contracts on a local Moonbeam node using Ape, the CLI will, by default, wait for two block confirmations before allowing you to proceed. However, because a local Moonbeam node employs instant sealing, only producing blocks when new transactions occur, this can lead to a stalemate situation that may lead you to think something is wrong. To circumvent this, you can run your local Moonbeam node with a sealing flag to produce blocks at a set interval, such as every <code>6</code> seconds, with the command: <code>--sealing 6000</code>. Alternatively, you can submit dummy transactions to your local Moonbeam node to force new blocks to be authored. </p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/dev-env/foundry/","title":"Using Foundry to Deploy To Moonbeam","text":""},{"location":"builders/ethereum/dev-env/foundry/#introduction","title":"Introduction","text":"<p>Foundry is an Ethereum development environment written in Rust that helps developers manage dependencies, compile projects, run tests, deploy contracts, and interact with blockchains from the command line. Foundry can directly interact with Moonbeam's Ethereum API so it can be used to deploy smart contracts into Moonbeam.</p> <p>Four tools make up Foundry:  </p> <ul> <li>Forge - compiles, tests, and deploys contracts</li> <li>Cast - a command line interface for interacting with contracts</li> <li>Anvil - a local TestNet node for development purposes that can fork preexisting networks</li> <li>Chisel - a Solidity REPL for quickly testing Solidity snippets</li> </ul> <p>This guide will cover how to use Foundry to compile, deploy, and debug Ethereum smart contracts on the Moonbase Alpha TestNet. This guide can also be adapted for Moonbeam, Moonriver, or a Moonbeam development node.</p>"},{"location":"builders/ethereum/dev-env/foundry/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you will need the following:</p> <ul> <li>Have an account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> <li>Have Foundry installed</li> </ul>"},{"location":"builders/ethereum/dev-env/foundry/#creating-a-foundry-project","title":"Creating a Foundry Project","text":"<p>You will need to create a Foundry project if you don't already have one. You can create one by completing the following steps:</p> <ol> <li> <p>Install Foundry if you haven't already. If on Linux or MacOS, you can run these commands:</p> <pre><code>curl -L https://foundry.paradigm.xyz | bash\nfoundryup\n</code></pre> <p>If on Windows, you'll have to install Rust and then build Foundry from source:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs/ | sh\ncargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked\n</code></pre> </li> <li> <p>Create the project, which will create a folder with three folders within it, and open it:</p> <pre><code>forge init foundry &amp;&amp; cd foundry\n</code></pre> </li> </ol> <p>With the default project created, you should see three folders.  </p> <ul> <li><code>lib</code> - all of the project's dependencies in the form of git submodules</li> <li><code>src</code> - where to put your smart contracts (with functionality)</li> <li><code>test</code> - where to put the forge tests for your project, which are written in Solidity</li> </ul> <p>In addition to these three folders, a git project will also be created along with a prewritten <code>.gitignore</code> file with relevant file types and folders ignored.</p>"},{"location":"builders/ethereum/dev-env/foundry/#the-src-folder","title":"The Source Folder","text":"<p>The <code>src</code> folder may already contain <code>Counter.sol</code>, a minimal Solidity contract. Feel free to delete it. To avoid errors, you should also delete the <code>Counter.s.sol</code> file in the <code>scripts</code> folder and the <code>Counter.t.sol</code> file in the <code>test</code> folder. In the following steps, you will be deploying an ERC-20 contract. In the contracts directory, you can create the <code>MyToken.sol</code> file:</p> <pre><code>cd src\ntouch MyToken.sol\n</code></pre> <p>Open the file and add the following contract to it:</p> <pre><code>pragma solidity ^0.8.0;\n\n// Import OpenZeppelin Contract\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// This ERC-20 contract mints the specified amount of tokens to the contract creator\ncontract MyToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MYTOK\") {\n        _mint(msg.sender, initialSupply);\n    }\n}\n</code></pre> <p>Before you attempt to compile, install OpenZeppelin contracts as a dependency. You may have to commit previous changes to git beforehand. By default, Foundry uses git submodules instead of npm packages, so the traditional npm import path and command are not used. Instead, use the name of OpenZeppelin's GitHub repository:</p> <pre><code>forge install OpenZeppelin/openzeppelin-contracts\n</code></pre>"},{"location":"builders/ethereum/dev-env/foundry/#compiling-solidity","title":"Compiling Solidity","text":"<p>Once all dependencies have been installed, you can compile the contract:</p> <pre><code>forge build\n</code></pre> forge build [\u2812] Compiling... [\u2830] Compiling 30 files with 0.8.23 [\u2814] Solc 0.8.23 finished in 2.29s Compiler run successful! <p>After compilation, two folders will be created: <code>out</code> and <code>cache</code>. The ABI and bytecode for your contracts will be contained within the <code>out</code> folder. These two folders are already ignored by the <code>.gitignore</code> included in the default Foundry project initialization.</p>"},{"location":"builders/ethereum/dev-env/foundry/#deploying-the-contract","title":"Deploying the Contract","text":"<p>There are two primary ways to deploy contracts using Foundry. The first is the straightforward command <code>forge create</code>. There's also the more flexible and powerful option of foundry scripting, which runs simulations before any deployments. In the following sections, <code>forge create</code> and foundry scripting will both be covered.</p>"},{"location":"builders/ethereum/dev-env/foundry/#using-forge-create","title":"Using Forge Create","text":"<p>Before deploying, you'll need to set up your keystore by importing your private key. You can do this using the <code>cast wallet import</code> command as follows:</p> <pre><code>cast wallet import deployer --interactive\n</code></pre> <p>This will prompt you to:</p> <ol> <li>Enter your private key</li> <li>Enter a password to encrypt the keystore</li> </ol> <p>The account will be saved as \"deployer\" in your keystore. You can then use this account name in the deployment commands. You'll be prompted for your keystore password when deploying contracts or sending transactions. </p> <p>Deploying the contract with <code>forge create</code> takes a single command, but you must include an RPC endpoint and constructor arguments. <code>MyToken.sol</code> asks for an initial supply of tokens in its constructor, so each of the following commands includes 100 as a constructor argument. You can deploy the <code>MyToken.sol</code> contract using the following command for the correct network:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>forge create src/MyToken.sol:MyToken \\\n--rpc-url INSERT_RPC_API_ENDPOINT \\\n--broadcast \\\n--account deployer \\\n--constructor-args 100\n</code></pre> <pre><code>forge create src/MyToken.sol:MyToken \\\n--rpc-url INSERT_RPC_API_ENDPOINT \\\n--broadcast \\\n--account deployer \\\n--constructor-args 100\n</code></pre> <pre><code>forge create src/MyToken.sol:MyToken \\\n--rpc-url https://rpc.api.moonbase.moonbeam.network \\\n--broadcast \\\n--account deployer \\\n--constructor-args 100\n</code></pre> <pre><code>forge create src/MyToken.sol:MyToken \\\n--rpc-url http://127.0.0.1:9944 \\\n--broadcast \\\n--account deployer \\\n--constructor-args 100\n</code></pre> <p>After you've deployed the contract and a few seconds have passed, you should see the address in the terminal.</p> forge create src/MyToken.sol:MyToken \\ --rpc-url https://rpc.api.moonbase.moonbeam.network \\ --account deployer \\ --constructor-args 100 [\u2812] Compiling... No files changed, compilation skipped Deployer: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Deployed to: 0xc111402Aa1136ff6224106709ae51864512eC68f Transaction hash: 0xd77fc26aa296e81f35718b5878cda98e8371f6bf33b0f57e7d92997a36cf6465 <p>Congratulations! Your contract is live! Save the address, as you will use it to interact with this contract instance in the next step.</p>"},{"location":"builders/ethereum/dev-env/foundry/#deploying-via-solidity-scripting","title":"Deploying via Solidity Scripting","text":"<p>Solidity scripting is a more powerful and flexible way to deploy contracts than <code>forge create</code>. Writing a Solidity script is identical to writing a typical Solidity smart contract, though you won't ever deploy this contract.</p> <p>You can tailor the behavior of <code>forge script</code> with various parameters. All components are optional except for local simulation, which is a required part of every run. The <code>forge script</code> command will attempt to execute all applicable steps in the following order:</p> <ol> <li>Local simulation - simulate the transaction(s) in a local EVM</li> <li>Onchain simulation - simulate the transaction(s) via the provided RPC URL</li> <li>Broadcasting - when the <code>--broadcast</code> flag is provided, and simulations succeed, the transaction(s) are dispatched</li> <li>Verification - API-based smart contract verification when the <code>--verify</code> flag and a valid API key are provided</li> </ol> <p>Now, go ahead and write the script. In the script folder, create a file named <code>MyToken.s.sol</code>. Copy and paste the contents of the below file. </p> <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Script.sol\";\nimport \"../src/MyToken.sol\";\n\ncontract MyScript is Script {\n    function run() external {\n        vm.startBroadcast();\n\n        MyToken mytoken = new MyToken(1000000000);\n\n        vm.stopBroadcast();\n    }\n}\n</code></pre> <p>Notice that even though the above script is not being deployed, it still requires all the typical formatting for a Solidity contract, such as the pragma statement.</p> <p>For this example, Foundry will first attempt a local simulation and a simulation against the provided RPC before deploying the contract. Remember that it will execute all relevant steps in order. Foundry won't proceed with the deployment if any of the simulations fail. You can deploy the <code>MyToken.sol</code> contract with this command.</p> <pre><code>forge script script/MyToken.s.sol --rpc-url https://rpc.api.moonbase.moonbeam.network --broadcast --account deployer\n</code></pre> <p>If your script's execution succeeds, your terminal should resemble the output below.</p> forge script script/MyToken.s.sol --rpc-url https://rpc.api.moonbase.moonbeam.network --broadcast --account deployer --sender 0x3b939fead1557c741ff06492fd0127bd287a421e [\u2812] Compiling... No files changed, compilation skipped EIP-3855 is not supported in one or more of the RPCs used. Unsupported Chain IDs: 1287. Contracts deployed with a Solidity version equal or higher than 0.8.20 might not work properly. For more information, please see https://eips.ethereum.org/EIPS/eip-3855 Script ran successfully. ## Setting up 1 EVM. ========================== Chain 1287 Estimated gas price: 0.0625 gwei Estimated total gas used for script: 1196500 Estimated amount required: 0.00007478125 ETH ========================== Enter keystore password: ## Sending transactions [0 - 0]. \u2801 [00:00:00] [########################################################################################################] 1/1 txes (0.0s)## Waiting for receipts. \u2809 [00:00:07] [#########################################################################################################################] 1/1 receipts (0.0s) ##### moonbase \u2705  [Success]Hash: 0xb70942942d731486872e7faba8a800e86809f44c2c3bd3f6306373562712e9d3 Contract Address: 0x98c3fC51d3487c1689e39ee63Ba110cfD8e1F552 Block: 11847291 Paid: 0.000027472875 ETH (879132 gas * 0.03125 gwei) ========================== ONCHAIN EXECUTION COMPLETE &amp; SUCCESSFUL. Total Paid: 0.000027472875 ETH (879132 gas * avg 0.03125 gwei) Transactions saved to: /Users/ubuntu-jammy/foundry/foundry/broadcast/MyToken.s.sol/1287/run-latest.json Sensitive values saved to: /Users/ubuntu-jammy/foundry/foundry/cache/MyToken.s.sol/1287/run-latest.json <p>And that's it! For more information about Solidity scripting with Foundry, be sure to check out Foundry's documentation site.</p>"},{"location":"builders/ethereum/dev-env/foundry/#interacting-with-the-contract","title":"Interacting with the Contract","text":"<p>Foundry includes cast, a CLI for performing Ethereum RPC calls.</p> <p>Try to retrieve your token's name using Cast, where <code>INSERT_YOUR_CONTRACT_ADDRESS</code> is the address of the contract that you deployed in the previous section:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url https://rpc.api.moonbase.moonbeam.network\n</code></pre> <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url http://127.0.0.1:9944\n</code></pre> <p>You should get this data in hexadecimal format:</p> <pre><code>0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000\n</code></pre> <p>This is far from readable, but you can use Cast to convert it into your desired format. In this case, the data is text, so you can convert it into ASCII characters to see \"My Token\":</p> cast --to-ascii 0x000000000000000000000000000000000000000000000000000000000000002000     000000000000000000000000000000000000000000000000000000000000074d7954     6f6b656e00000000000000000000000000000000000000000000000000  MyToken <pre><code>cast --to-ascii 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000\n</code></pre> <p>You can also mutate data with cast as well. Try burning tokens by sending them to the zero address.</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n--rpc-url INSERT_RPC_API_ENDPOINT \\\n--chain 1284 \\\nINSERT_YOUR_CONTRACT_ADDRESS \\\n\"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n--rpc-url INSERT_RPC_API_ENDPOINT \\\n--chain 1285 \\\nINSERT_YOUR_CONTRACT_ADDRESS \\\n\"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n--rpc-url https://rpc.api.moonbase.moonbeam.network \\\n--chain 1287 \\\nINSERT_YOUR_CONTRACT_ADDRESS \\\n\"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n--rpc-url http://127.0.0.1:9944 \\\n--chain 1281 \\\nINSERT_YOUR_CONTRACT_ADDRESS \\\n\"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <p>The transaction will be signed by your Moonbase account and be broadcast to the network. The output should look similar to:</p> cast send --private-key INSERT_PRIVATE_KEY \\ --rpc-url https://rpc.api.moonbase.moonbeam.network \\ --chain 1287 \\ INSERT_CONTRACT_ADDRESS \\ \"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1 blockHash               0x6f99fac1bb49feccb7b0476e0ffcd3cef4c456aa9111e193ce11c7a1ab62314e blockNumber             5892860 contractAddress cumulativeGasUsed       51332 effectiveGasPrice       3125000000 gasUsed                 51332 logs                    [{\"address\":\"0xc111402aa1136ff6224106709ae51864512ec68f\",\"topics\":[\"0xddf252ad1be2c89b69     c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",     \"0x0000000000000000000000003b939fead155     7c741ff06492fd0127bd287a421e\",     \"0x0000000000000000000000000000000000000000000000000000000000000001\"],     \"data\":\"0x0000000000000000000000000000000000000     000000000000000000000000001\",     \"blockHash\":\"0x6f99fac1bb49feccb7b0476e0ffcd3cef4c4     56aa9111e193ce11c7a1ab62314e\",     \"blockNumber\":\"0x59eafc\",     \"transactionHash\":\"0xdd5f11be68d5     2967356ccf34b9a4b2632d0d5ac8932ff27e72c544320dec33e3\",     \"transactionIndex\":\"0x0\",\"logIndex\":\"0x0\",\"transactionLogIndex\":\"0x0\",\"removed\":false}] logsBloom               0x000000000000000000000000000000000000000000000000000000000000000000000000000000004     00000000000000000000000000000000000000000040000000000000000000000000008000000000000     00000004000000000000000000000000000000000000000100000000000000000000000000000000001     00000010000000000000000000000000000000000000000000000000000000002000000040000000000     00000000000000000000000000000000000000000000000000000000002000000000000000000000000     00000000000000000000000000004000000000000000000000000000000000000000000000000000000     0001000000 root status                  1 transactionHash         0xdd5f11be68d52967356ccf34b9a4b2632d0d5ac8932ff27e72c544320dec33e3 transactionIndex        0 type                    2 <p>Congratulations, you have successfully deployed and interacted with a contract using Foundry!</p>"},{"location":"builders/ethereum/dev-env/foundry/#forking-with-cast-anvil","title":"Forking with Anvil","text":"<p>As previously mentioned, Anvil is a local TestNet node for development purposes that can fork preexisting networks. Forking Moonbeam allows you to interact with live contracts deployed on the network.</p> <p>There are some limitations to be aware of when forking with Anvil. Since Anvil is based on an EVM implementation, you cannot interact with any of the Moonbeam precompiled contracts and their functions. Precompiles are a part of the Substrate implementation and therefore cannot be replicated in the simulated EVM environment. This prohibits you from interacting with cross-chain assets on Moonbeam and Substrate-based functionality such as staking and governance.</p> <p>To fork Moonbeam or Moonriver, you will need to have your own endpoint and API key which you can get from one of the supported Endpoint Providers.</p> <p>To fork Moonbeam from the command line, you can run the following command from within your Foundry project directory:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>anvil --fork-url INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>anvil --fork-url INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>anvil --fork-url https://rpc.api.moonbase.moonbeam.network\n</code></pre> <p>Your forked instance will have 10 development accounts that are pre-funded with 10,000 test tokens. The forked instance is available at <code>http://127.0.0.1:8545/</code>. The output in your terminal should resemble the following:</p> anvil --fork-url https://rpc.api.moonbase.moonbeam.network Available Accounts ================== (0) \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\" (10000.000000000000000000 ETH) (1) \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\" (10000.000000000000000000 ETH) (2) \"0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC\" (10000.000000000000000000 ETH) (3) \"0x90F79bf6EB2c4f870365E785982E1f101E93b906\" (10000.000000000000000000 ETH) (4) \"0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65\" (10000.000000000000000000 ETH) (5) \"0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc\" (10000.000000000000000000 ETH) (6) \"0x976EA74026E726554dB657fA54763abd0C3a0aa9\" (10000.000000000000000000 ETH) (7) \"0x14dC79964da2C08b23698B3D3cc7Ca32193d9955\" (10000.000000000000000000 ETH) (8) \"0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f\" (10000.000000000000000000 ETH) (9) \"0xa0Ee7A142d267C1f36714E4a8F75612F20a79720\" (10000.000000000000000000 ETH) Private Keys ================== (0) 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 (1) 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d (2) 0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a (3) 0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6 (4) 0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a (5) 0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba (6) 0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e (7) 0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356 (8) 0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97 (9) 0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6 Wallet ================== Mnemonic: test test test test test test test test test test test junk Derivation path: m/44'/60'/0'/0/ Fork ================== Endpoint: https://rpc.api.moonbase.moonbeam.network Block number: 5892944 Block hash: 0xc9579299f55d507c305d5357d4c1b9d9c550788ddb471b0231d8d0146e7144b7 Chain ID: 1287 Base Fee ================== 125000000 Gas Limit ================== 30000000 Genesis Timestamp ================== 1705278817 Listening on 127.0.0.1:8545 <p>To verify you have forked the network, you can query the latest block number:</p> <pre><code>curl --data '{\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}' -H \"Content-Type: application/json\" -X POST localhost:8545 \n</code></pre> <p>If you convert the <code>result</code> from hex to decimal, you should get the latest block number from the time you forked the network. You can cross reference the block number using a block explorer.</p> <p>From here you can deploy new contracts to your forked instance of Moonbeam or interact with contracts already deployed. Building off of the previous example in this guide, you can make a call using Cast to check the balance of the minted MYTOK tokens in the account you deployed the contract with:</p> <pre><code>cast call INSERT_CONTRACT_ADDRESS  \"balanceOf(address)(uint256)\" INSERT_YOUR_ADDRESS --rpc-url http://localhost:8545\n</code></pre>"},{"location":"builders/ethereum/dev-env/foundry/#using-chisel","title":"Using Chisel","text":"<p>Chisel is a Solidity REPL or shell. It allows a developer to write Solidity directly in the console for testing small snippets of code, letting developers skip the project setup and contract deployment steps for what should be a quick process.  </p> <p>Since Chisel is mainly useful for quick testing, it can be used outside of a Foundry project. But, if executed within a Foundry project, it will keep the configurations within <code>foundry.toml</code> when running.  </p> <p>For this example, you will be testing out some of the features of <code>abi</code> within Solidity because it is complex enough to demonstrate how Chisel could be useful. To get started using Chisel, run the following in the command line to start the shell:</p> <pre><code>chisel\n</code></pre> <p>In the shell, you can write Solidity code as if it were running within a function:</p> <pre><code>bytes memory myData = abi.encode(100, true, \"Develop on Moonbeam\");\n</code></pre> <p>Let's say you were interested in how <code>abi</code> encoded data because you're looking into how to most efficiently store data on the blockchain and thus save gas. To view how the <code>myData</code> is stored in memory, you can use the following command while in the Chisel shell:</p> <pre><code>!memdump\n</code></pre> <p><code>memdump</code> will dump all of the data in your current session. You'll likely see something like this below. If you aren't good at reading hexadecimal or if you don't know how ABI encoding works, then you might not be able to find where the <code>myData</code> variable has been stored.</p> chisel Welcome to Chisel! Type `!help` to show available commands.  bytes memory myData = abi.encode(100, true, \"Develop on Moonbeam\");  !memdump [0x00:0x20]: 0x0000000000000000000000000000000000000000000000000000000000000000 [0x20:0x40]: 0x0000000000000000000000000000000000000000000000000000000000000000 [0x40:0x60]: 0x0000000000000000000000000000000000000000000000000000000000000140 [0x60:0x80]: 0x0000000000000000000000000000000000000000000000000000000000000000 [0x80:0xa0]: 0x00000000000000000000000000000000000000000000000000000000000000a0 [0xa0:0xc0]: 0x0000000000000000000000000000000000000000000000000000000000000064 [0xc0:0xe0]: 0x0000000000000000000000000000000000000000000000000000000000000001 [0xe0:0x100]: 0x0000000000000000000000000000000000000000000000000000000000000060 [0x100:0x120]: 0x0000000000000000000000000000000000000000000000000000000000000013 [0x120:0x140]: 0x446576656c6f70206f6e204d6f6f6e6265616d00000000000000000000000000 <p>Fortunately, Chisel lets you easily figure out where this information is stored. Using the <code>!rawstack</code> command, you can find the location in the stack where the value of a variable:  </p> <pre><code>!rawstack myData\n</code></pre> <p>In this situation, since bytes is over 32 bytes in length, the memory pointer is displayed instead. But that's exactly what's needed since you already know the entirety of the stack from the <code>!memdump</code> command.</p> chisel Welcome to Chisel! Type `!help` to show available commands.  bytes memory myData = abi.encode(100, true, \"Develop on Moonbeam\");  !memdump [0x00:0x20]: 0x0000000000000000000000000000000000000000000000000000000000000000 [0x20:0x40]: 0x0000000000000000000000000000000000000000000000000000000000000000 [0x40:0x60]: 0x0000000000000000000000000000000000000000000000000000000000000140 [0x60:0x80]: 0x0000000000000000000000000000000000000000000000000000000000000000 [0x80:0xa0]: 0x00000000000000000000000000000000000000000000000000000000000000a0 [0xa0:0xc0]: 0x0000000000000000000000000000000000000000000000000000000000000064 [0xc0:0xe0]: 0x0000000000000000000000000000000000000000000000000000000000000001 [0xe0:0x100]: 0x0000000000000000000000000000000000000000000000000000000000000060 [0x100:0x120]: 0x0000000000000000000000000000000000000000000000000000000000000013 [0x120:0x140]: 0x446576656c6f70206f6e204d6f6f6e6265616d00000000000000000000000000  !rawstack myData  Type: bytes32  \u2514 Data: 0x0000000000000000000000000000000000000000000000000000000000000080 <p>The <code>!rawstack</code> command shows that the <code>myData</code> variable is stored at <code>0x80</code>, so when comparing this with the memory dump retrieved from the <code>!memdump</code> command, it looks like <code>myData</code> is stored like this:  </p> <pre><code>[0x80:0xa0]: 0x00000000000000000000000000000000000000000000000000000000000000a0\n[0xa0:0xc0]: 0x0000000000000000000000000000000000000000000000000000000000000064\n[0xc0:0xe0]: 0x0000000000000000000000000000000000000000000000000000000000000001\n[0xe0:0x100]: 0x0000000000000000000000000000000000000000000000000000000000000060\n[0x100:0x120]: 0x0000000000000000000000000000000000000000000000000000000000000013\n[0x120:0x140]: 0x446576656c6f70206f6e204d6f6f6e6265616d00000000000000000000000000\n</code></pre> <p>At first glance, this makes sense, since <code>0xa0</code> has a value of <code>0x64</code> which is equal to 100, and <code>0xc0</code> has a value of <code>0x01</code> which is equal to true. If you want to learn more about how ABI-encoding works, the Solidity documentation for ABI is helpful. In this case, there are a lot of zeros in this method of data packing, so as a smart contract developer you might instead try to use structs or pack the data together more efficiently with bitwise code.  </p> <p>Since you're done with this code, you can clear the state of Chisel so that it doesn't mess with any future logic that you want to try out (while running the same instance of Chisel):  </p> <pre><code>!clear\n</code></pre> <p>There's an even easier way to test with Chisel. When writing code that ends with a semicolon (<code>;</code>), Chisel will run it as a statement, storing its value in Chisel's runtime state. But if you only needed to see how the ABI-encoded data was represented, then you could get away with running the code as an expression. To try this out with the same <code>abi</code> example, write the following in the Chisel shell:</p> <pre><code>abi.encode(100, true, \"Develop on Moonbeam\")\n</code></pre> <p>You should see something like the following:  </p>  !clear Cleared session!  abi.encode(100, true, \"Develop on Moonbeam\") Type: dynamic bytes \u251c Hex (Memory): \u251c\u2500 Length ([0x00:0x20]): 0x00000000000000000000000000000000000000000000000000000000000000a0 \u251c\u2500 Contents ([0x20:..]): 0x0000000000000000000000000000000000000000000000000000000000000064 0000000000000000000000000000000000000000000000000000000000000001 0000000000000000000000000000000000000000000000000000000000000060 0000000000000000000000000000000000000000000000000000000000000001 34446576656c6f70206f6e204d6f6f6e6265616d00000000000000000000000000 \u251c Hex (Tuple Encoded): \u251c\u2500 Pointer ([0x00:0x20]): 0x0000000000000000000000000000000000000000000000000000000000000020 \u251c\u2500 Length ([0x20:0x40]): 0x00000000000000000000000000000000000000000000000000000000000000a0 \u2514\u2500 Contents ([0x40:..]): 0x0000000000000000000000000000000000000000000000000000000000000064 0000000000000000000000000000000000000000000000000000000000000001 0000000000000000000000000000000000000000000000000000000000000060 0000000000000000000000000000000000000000000000000000000000000001 34446576656c6f70206f6e204d6f6f6e6265616d00000000000000000000000000 <p>While it doesn't display the data in the same way, you still get the contents of the data, and it also further breaks down how the information is coded, such as letting you know that the <code>0xa0</code> value defines the length of the data.  </p> <p>By default, when you leave the Chisel shell, none of the data is persisted. But you can instruct chisel to do so. For example, you can take the following steps to store a variable:</p> <ol> <li> <p>Store a <code>uint256</code> in Chisel     <pre><code>uint256 myNumber = 101;\n</code></pre></p> </li> <li> <p>Store the session with <code>!save</code>. For this example, you can use the number <code>1</code> as a save ID     <pre><code>!save 1\n</code></pre></p> </li> <li> <p>Quit the session <pre><code>!quit\n</code></pre></p> </li> </ol> <p>Then to view and interact with your stored Chisel states, you can take the following steps:</p> <ol> <li> <p>View a list of saved Chisel states      <pre><code>chisel list\n</code></pre></p> </li> <li> <p>Load your stored states     <pre><code>chisel load 1\n</code></pre></p> </li> <li> <p>View the <code>uint256</code> saved in Chisel from the previous set of steps     <pre><code>!rawstack myNumber\n</code></pre></p> </li> </ol>  uint256 myNumber = 101;  !save 1  Saved session to cache with ID = 1  !quit chisel list \u2692\ufe0f Chisel Sessions \u251c\u2500 \"2024-01-15 01:17:34\" - chisel-1.json chisel load 1 Welcome to Chisel! Type `!help` to show available commands.  !rawstack myNumber Type: bytes32 \u2514 Data: 0x0000000000000000000000000000000000000000000000000000000000000065 <p>You can even fork networks while using Chisel:</p> <pre><code>!fork https://rpc.api.moonbase.moonbeam.network\n</code></pre> <p>Then, for example, you can query the balance of one of Moonbase Alpha's collators:  </p> <pre><code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5.balance\n</code></pre>  !fork https://rpc.api.moonbase.moonbeam.network Set fork URL to https://rpc.api.moonbase.moonbeam.network  0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5.balance Type: uint \u251c Hex: 0x000000000000000000000000000000000000000000000358affd3d76ebb78555 \u2514 Decimal: 15803094286802091476309 <p>If you want to learn more about Chisel, download Foundry and refer to its official reference page.</p>"},{"location":"builders/ethereum/dev-env/foundry/#foundry-with-hardhat","title":"Foundry With Hardhat","text":"<p>Often, there will be the case where a project that you wish to integrate with has all of its setup within Hardhat, making it an arduous task to convert the entirety of the project into Foundry. This additional work is avoidable by creating a hybrid project that uses both Hardhat and Foundry features together. This is possible with Hardhat's hardhat-foundry plugin.  </p> <p>To convert your preexisting Foundry project to a hybrid project, you will essentially have to install a Hardhat project into the same folder:  </p> <pre><code>npm init\nnpm install --save-dev hardhat @nomicfoundation/hardhat-foundry\nnpx hardhat init\n</code></pre> <p>For more information, please refer to our documentation on Creating a Hardhat Project.</p> <p>After initializing the new Hardhat project, a few new folders and files should appear: <code>contracts</code>, <code>hardhat.config.js</code>, <code>scripts</code>, and <code>test/Lock.js</code>. You'll need to make a few modifications to create a hybrid project:</p> <ol> <li> <p>Edit the <code>hardhat.config.js</code> file within your repository. Open it up, and at the top, add the following:  </p> <pre><code>require(\"@nomicfoundation/hardhat-foundry\");\n</code></pre> <p>After adding the <code>hardhat-foundry</code> plugin, the typical <code>contracts</code> folders for Hardhat will not work because now Hardhat expects all smart contracts to be stored within Foundry's <code>src</code> folder</p> </li> <li> <p>Move all smart contracts within the <code>contracts</code> folder into the <code>src</code> folder, and then delete the <code>contracts</code> folder</p> </li> <li> <p>Edit the <code>foundry.toml</code> file to ensure that dependencies installed via Git submodules and npm can be compiled by the Forge tool. Edit the <code>profile.default</code> to ensure that the <code>libs</code> entry has both <code>lib</code> and <code>node_modules</code>:  </p> <pre><code>[profile.default]\nsrc = 'src'\nout = 'out'\nlibs = ['lib', 'node_modules']\nsolc = '0.8.20'\nevm_version = 'london'\n</code></pre> </li> </ol> <p>Now both <code>forge build</code> and <code>npx hardhat compile</code> should work regardless of the dependencies.  </p> <p>Both <code>forge test</code> and <code>npx hardhat test</code> should now be able to access all smart contracts and dependencies. <code>forge test</code> will only test the Solidity tests, whereas <code>npx hardhat test</code> will only test the JavaScript tests. If you would like to use them in conjunction, then you can create a new script within your <code>package.json</code> file:  </p> <pre><code>\"scripts\": {\n    \"test\": \"npx hardhat test &amp;&amp; forge test\"\n}\n</code></pre> <p>You can run this command with:  </p> <pre><code>npm run test\n</code></pre> <p>Finally, while not necessary, it could be worthwhile to move all JavaScript scripts from the <code>scripts</code> folder into Foundry's <code>script</code> folder and delete the <code>scripts</code> folder so that you don't have two folders that serve the same purpose.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/dev-env/hardhat/","title":"Using Hardhat to Deploy To Moonbeam","text":""},{"location":"builders/ethereum/dev-env/hardhat/#introduction","title":"Introduction","text":"<p>Hardhat is a flexible and extensible Ethereum development environment that streamlines the smart contract development process. Since Moonbeam is Ethereum-compatible, you can use Hardhat to develop and deploy smart contracts on Moonbeam.</p> <p>Hardhat takes a task-based approach to development, where you can define and execute tasks that perform specific actions. These actions include compiling and deploying contracts, running tests, and more. Tasks are highly configurable, so you can create, customize, and execute tasks that are tailored to meet your needs.</p> <p>You can also extend Hardhat's functionality through the use of plugins. Plugins are external extensions that integrate with Hardhat to provide additional features and tools for your workflow. For example, there are plugins for common Ethereum libraries, like Ethers.js and viem, a plugin that extends the Chai assertion library to include Ethereum-specific functionality, and more. All of these plugins can be used to extend your Hardhat project on Moonbeam.</p> <p>This guide will provide a brief introduction to Hardhat and show you how to use Hardhat to compile, deploy, and debug Ethereum smart contracts on the Moonbase Alpha TestNet. This guide can also be adapted for Moonbeam, Moonriver, or a Moonbeam development node.</p> <p>Please note that although Hardhat comes with a Hardhat Network component, which provides a local development environment, you should use a local Moonbeam development node instead. You can connect a Moonbeam development node to Hardhat just like you would with any other network.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you will need the following:</p> <ul> <li>Have MetaMask installed and connected to Moonbase Alpha</li> <li>Have an account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul>"},{"location":"builders/ethereum/dev-env/hardhat/#creating-a-hardhat-project","title":"Create a Hardhat Project","text":"<p>You will need to create a Hardhat project if you don't already have one. You can create one by completing the following steps:</p> <ol> <li> <p>Create a directory for your project</p> <pre><code>mkdir hardhat &amp;&amp; cd hardhat\n</code></pre> </li> <li> <p>Initialize the project, which will create a <code>package.json</code> file</p> <pre><code>npm init -y\n</code></pre> </li> <li> <p>Install Hardhat</p> <pre><code>npm install hardhat\n</code></pre> </li> <li> <p>Create a Hardhat project</p> <pre><code>npx hardhat --init\n</code></pre> <p>Note</p> <p><code>npx</code> is used to run executables installed locally in your project. Although Hardhat can be installed globally, installing it locally in each project is recommended so you can control the version on a project-by-project basis.</p> </li> <li> <p>You'll be prompted with a series of questions to set up your project:</p> <ul> <li>Choose Hardhat 3 Beta (recommended for new projects) rather than Hardhat 2</li> <li>Choose where to initialize the project (default is current directory)</li> <li>Confirm converting to ESM (required for Hardhat v3)</li> <li>Select the type of project to initialize:<ul> <li>A TypeScript Hardhat project using Node Test Runner and Viem</li> <li>A TypeScript Hardhat project using Mocha and Ethers.js</li> </ul> </li> </ul> <p>For this example, you can choose either option based on your preference. If you choose the Mocha and Ethers.js option, you'll get a project structure with:</p> <ul> <li>A sample contract in <code>contracts/Counter.sol</code></li> <li>A test file in <code>test/Counter.ts</code></li> <li>TypeScript configuration</li> <li>Mocha and Ethers.js dependencies</li> </ul> <p>The project will be set up with all necessary dependencies and configurations for you to start developing.</p> </li> </ol> npx hardhat init 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 8888888888\u00a0\u00a08888b.\u00a0\u00a0888d888\u00a0.d88888\u00a088888b.\u00a0\u00a0\u00a08888b.\u00a0\u00a0888888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\"88b\u00a0888P\"\u00a0\u00a0d88\"\u00a0888\u00a0888\u00a0\"88b\u00a0\u00a0\u00a0\u00a0\u00a0\"88b\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0.d888888\u00a0888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0.d888888\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0Y88b\u00a0888\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0Y88b. 888\u00a0\u00a0\u00a0\u00a0888\u00a0\"Y888888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\"Y88888\u00a0888\u00a0\u00a0888\u00a0\"Y888888\u00a0\u00a0\"Y888 \ud83d\udc77 Welcome to Hardhat v3.0.4 \ud83d\udc77\u200d \u00a0Which version of Hardhat would you like to use? \u2026 \u00a0Hardhat 3 Beta (recommended for new projects) \u00a0\u00a0Hardhat 2 (older version) \u00a0Where would you like to initialize the project? \u00a0. \u00a0Hardhat only supports ESM projects. Would you like to change \"package.json\" to turn your project into ESM? (Y/n) \u00b7 true \u00a0What type of project would you like to initialize? \u2026 \u00a0\u00a0A TypeScript Hardhat project using Node Test Runner and Viem \u00a0A TypeScript Hardhat project using Mocha and Ethers.js"},{"location":"builders/ethereum/dev-env/hardhat/#hardhat-configuration-file","title":"Hardhat Configuration File","text":"<p>The Hardhat configuration file is the entry point into your Hardhat project. It defines various settings and options for your Hardhat project, such as the Solidity compiler version to use and the networks you can deploy your contracts to.</p> <p>To start, your <code>hardhat.config.js</code> should resemble the following:</p> <pre><code>/** @type import('hardhat/config').HardhatUserConfig */\nmodule.exports = {\n  solidity: '0.8.28',\n};\n</code></pre> <p>For this example, you can leave the Solidity compiler version to <code>0.8.28</code>; however, if you are using a different contract that requires a newer version, don't forget to update the version here.</p> <p>Next, you'll need to modify your configuration file to add the network configurations for the network you want to deploy your contract to. For Moonbeam networks, you'll need to specify the following:</p> <ul> <li><code>url</code> - the RPC endpoint of the node</li> <li><code>chainId</code> - the chain ID, which is used to validate the network</li> <li><code>accounts</code> - the accounts that can be used to deploy and interact with contracts. You can either enter an array of the private keys for your accounts or use an HD Wallet</li> </ul> <p>Hardhat 3 includes an encrypted secrets manager that makes it easier to handle sensitive information like private keys. This ensures you don't have to hardcode secrets in your source code or store them in plain text.</p> <p>Note</p> <p>The encrypted secrets manager is only available in Hardhat 3 or higher. You can install the latest version with:</p> <pre><code>npm install hardhat\n</code></pre> <p>For the latest releases and updates, check the Hardhat releases page.</p> <p>To use encrypted secrets, you'll need to:</p> <ol> <li> <p>Install Hardhat (latest version): <pre><code>npm install hardhat\n</code></pre></p> </li> <li> <p>Set up your secrets using the keystore:</p> </li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>npx hardhat keystore set MOONBEAM_RPC_URL\nnpx hardhat keystore set MOONBEAM_PRIVATE_KEY\n</code></pre> <pre><code>npx hardhat keystore set MOONRIVER_RPC_URL\nnpx hardhat keystore set MOONRIVER_PRIVATE_KEY\n</code></pre> <pre><code>npx hardhat keystore set MOONBASE_RPC_URL\nnpx hardhat keystore set MOONBASE_PRIVATE_KEY\n</code></pre> <pre><code>npx hardhat keystore set DEV_RPC_URL\nnpx hardhat keystore set DEV_PRIVATE_KEY\n</code></pre> <p>Then, update your configuration file to use the encrypted secrets:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>module.exports = {\n  solidity: '0.8.28',\n  networks: {\n    moonbeam: {\n      type: \"http\",\n      chainType: \"generic\",\n      url: configVariable(\"MOONBEAM_RPC_URL\"),\n      chainId: 1284, // (hex: 0x504),\n      accounts: [configVariable(\"MOONBEAM_PRIVATE_KEY\")],\n    },\n  },\n};\n</code></pre> <pre><code>module.exports = {\n  solidity: '0.8.28',\n  networks: {\n    moonriver: {\n      type: \"http\",\n      chainType: \"generic\",\n      url: configVariable(\"MOONRIVER_RPC_URL\"),\n      chainId: 1285, // (hex: 0x505),\n      accounts: [configVariable(\"MOONRIVER_PRIVATE_KEY\")],\n    },\n  },\n};\n</code></pre> <pre><code>module.exports = {\n  solidity: '0.8.28',\n  networks: {\n    moonbase: {\n      type: \"http\",\n      chainType: \"generic\",\n      url: configVariable(\"MOONBASE_RPC_URL\"),\n      chainId: 1287, // (hex: 0x507),\n      accounts: [configVariable(\"MOONBASE_PRIVATE_KEY\")],\n    },\n  },\n};\n</code></pre> <pre><code>module.exports = {\n  solidity: '0.8.28',\n  networks: {\n    dev: {\n      type: \"http\",\n      chainType: \"generic\",\n      url: configVariable(\"DEV_RPC_URL\"),\n      chainId: 1281, // (hex: 0x501),\n      accounts: [configVariable(\"DEV_PRIVATE_KEY\")],\n    },\n  },\n};\n</code></pre> <p>When you run tasks that require these secrets, Hardhat will prompt you for the password to decrypt them. The secrets are only decrypted when needed, meaning you only need to enter the password if a Hardhat task uses a secret.</p> <p>If you are planning on using any plugins with your project, you'll need to install the plugin and import it into the <code>hardhat.config.js</code> file. Once a plugin has been imported, it becomes part of the Hardhat Runtime Environment, and you can leverage the plugin's functionality within tasks, scripts, and more.</p> <p>For this example, you can install the <code>hardhat-ethers</code> plugin and import it into the configuration file. This plugin provides a convenient way to use the Ethers.js library to interact with the network.</p> <pre><code>npm install @nomicfoundation/hardhat-ethers ethers\n</code></pre> <p>Additionally, you'll need to install the <code>hardhat-ignition-ethers</code> plugin to enable deployment of smart contracts with Hardhat Ignition. You can install it with the following command:</p> <pre><code>npm install --save-dev @nomicfoundation/hardhat-ignition-ethers\n</code></pre> <p>To import both plugins, add the following <code>require</code> statements to the top of the Hardhat configuration file:</p> <pre><code>/** @type import('hardhat/config').HardhatUserConfig */\nrequire('@nomicfoundation/hardhat-ethers');\nrequire('@nomicfoundation/hardhat-ignition-ethers');\n\nmodule.exports = {\n  solidity: '0.8.28',\n  networks: {\n    moonbase: {\n      url: configVariable(\"MOONBASE_RPC_URL\"),\n      chainId: 1287, // 0x507 in hex,\n      accounts: [configVariable(\"MOONBASE_PRIVATE_KEY\")]\n    }\n  }\n};\n</code></pre> <p>For more information on the available configuration options, please refer to Hardhat's documentation on Configuration.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#the-contract-file","title":"The Contract File","text":"<p>Now that you've configured your project, you can begin the development process by creating your smart contract. The contract will be a simple one that will let you store a value that can be retrieved later, called <code>Box</code>.</p> <p>To add the contract, you'll take the following steps:</p> <ol> <li> <p>Change into the <code>contracts</code> directory</p> <pre><code>cd contracts\n</code></pre> </li> <li> <p>Create a <code>Box.sol</code> file</p> <pre><code>touch Box.sol\n</code></pre> </li> <li> <p>Open the file and add the following contract to it:</p> <pre><code>// contracts/Box.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\ncontract Box {\n    uint256 private value;\n\n    // Emitted when the stored value changes\n    event ValueChanged(uint256 newValue);\n\n    // Stores a new value in the contract\n    function store(uint256 newValue) public {\n        value = newValue;\n        emit ValueChanged(newValue);\n    }\n\n    // Reads the last stored value\n    function retrieve() public view returns (uint256) {\n        return value;\n    }\n}\n</code></pre> </li> </ol>"},{"location":"builders/ethereum/dev-env/hardhat/#compiling-solidity","title":"Compile the Contract","text":"<p>The next step is to compile the <code>Box.sol</code> smart contract. For this, you can use the built-in <code>compile</code> task, which will look for Solidity files in the <code>contracts</code> directory and compile them using the version and compiler settings defined in the <code>hardhat.config.js</code> file.</p> <p>To use the <code>compile</code> task, all you have to do is run:</p> <pre><code>npx hardhat compile\n</code></pre> npx hardhat compile Compiled 1 Solidity files successfully (evm target: paris). ls -l artifacts cache contracts hardhat.config.js node_modules package.json package-lock.json <p>After compilation, an <code>artifacts</code> directory is created that holds the bytecode and metadata of the contract, which are <code>.json</code> files. It's a good idea to add this directory to a <code>.gitignore</code> file.</p> <p>If you make changes to the contract after you've compiled it, you can compile it again using the same command. Hardhat will look for any changes and recompile the contract. If no changes are found, nothing will be compiled. If needed, you can force a compilation using the <code>clean</code> task, which will clear the cache and delete the old artifacts.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#deploying-the-contract","title":"Deploy the Contract","text":"<p>To deploy the contract, you'll use Hardhat Ignition, a declarative framework for deploying smart contracts. Hardhat Ignition is designed to make it easy to manage recurring tasks surrounding smart contract deployment and testing. For more information, be sure to check out the Hardhat Ignition docs. </p> <p>To set up the proper file structure for your Ignition module, create a folder named <code>ignition</code> and a subdirectory called <code>modules</code>. Then add a new file to it called <code>Box.js</code>. You can take all three of these steps with the following command:</p> <pre><code>cd ignition/modules &amp;&amp; touch Box.js\n</code></pre> <p>Next, you can write your Hardhat Ignition module. To get started, take the following steps:</p> <ol> <li>Import the <code>buildModule</code> function from the Hardhat Ignition module</li> <li>Export a module using <code>buildModule</code></li> <li>Use the <code>getAccount</code> method to select the deployer account</li> <li>Deploy the <code>Box</code> contract</li> <li>Return an object from the module. This makes the <code>Box</code> contract accessible for interaction in Hardhat tests and scripts</li> </ol> <pre><code>// 1. Import the `buildModule` function from the Hardhat Ignition module\nimport { buildModule } from \"@nomicfoundation/hardhat-ignition/modules\";\n\n// 2. Export a module using `buildModule`\n// Use `export default` instead of `module.exports`\nexport default buildModule(\"BoxModule\", (m) =&gt; {\n  // 3. Use the `getAccount` method to select the deployer account\n  const deployer = m.getAccount(0);\n\n  // 4. Deploy the `Box` contract\n  const box = m.contract(\"Box\", [], {\n    from: deployer, \n  });\n\n  // 5. Return an object from the module\n  return { box };\n});\n</code></pre> <p>To run the script and deploy the <code>Box.sol</code> contract, use the following command, which requires you to specify the network name as defined in your <code>hardhat.config.js</code>. If you don't specify a network, hardhat will deploy the contract to a local Hardhat network by default. </p> <pre><code>npx hardhat ignition deploy ./Box.js --network moonbase\n</code></pre> <p>Note</p> <p>If you're using another Moonbeam network, make sure that you specify the correct network. The network name needs to match the one defined in the <code>hardhat.config.js</code> file.</p> <p>You'll be prompted to enter your password for the Hardhat secrets manager. Next, you'll be prompted to confirm the network you wish to deploy to. A few seconds after you confirm, the contract is deployed, and you'll see the contract address in the terminal.</p>  npx hardhat ignition deploy ./Box.js --network moonbase \u2705 Confirm deploy to network moonbase (1287)? \u2026 yes Hardhat Ignition \ud83d\ude80 Deploying [ BoxModule ] Batch #1 Executed BoxModule#Box [ BoxModule ] successfully deployed \ud83d\ude80 Deployed Addresses BoxModule#Box - 0xfBD78CE8C9E1169851119754C4Ea2f70AB159289 <p>Congratulations, your contract is live! Save the address, as you will use it to interact with this contract instance in the next step.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#interacting-with-the-contract","title":"Interact with the Contract","text":"<p>There are a couple of ways that you can interact with your newly deployed contract using Hardhat: you can use the <code>console</code> task, which spins up an interactive JavaScript console, or you can create another script and use the <code>run</code> task to execute it.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#hardhat-console","title":"Using the Hardhat Console","text":"<p>The Hardhat console uses the same execution environment as the tasks and scripts, so it automatically uses the configurations and plugins defined in the <code>hardhat.config.js</code>.</p> <p>To launch the Hardhat <code>console</code>, you can run:</p> <pre><code>npx hardhat console --network moonbase\n</code></pre> <p>Next, you can take the following steps, entering one line at a time:</p> <ol> <li> <p>Create a local instance of the <code>Box.sol</code> contract</p> <pre><code>const Box = await ethers.getContractFactory('Box');\n</code></pre> </li> <li> <p>Connect the local instance to the deployed contract, using the address of the contract shown in the prior step under Deployed Addresses</p> <pre><code>const box = await Box.attach('INSERT-CONTRACT-ADDRESS');\n</code></pre> </li> <li> <p>Interact with the attached contract. For this example, you can call the <code>store</code> method and store a simple value</p> <pre><code>await box.store(5);\n</code></pre> </li> </ol> <p>The transaction will be signed by your account configured in the <code>hardhat.config.js</code> file and broadcasted to the network. The output should look similar to:</p> npx hardhat console --network moonbase Welcome to Node.js v20.9.0. Type \".help\" for more information.  const Box = await ethers.getContractFactory('Box'); undefined  const box = await Box.attach('0xfBD78CE8C9E1169851119754C4Ea2f70AB159289'); undefined  await box.store(5); ContractTransactionResponse {       provider: HardhatEthersProvider { ... },       blockNumber: null,       blockHash: null,       index: undefined,       hash: '0x1c49a64a601fc5dd184f0a368a91130cb49203ec0f533c6fcf20445c68e20264',       type: 2,       to: '0xa84caB60db6541573a091e5C622fB79e175E17be',       from: '0x3B939FeaD1557C741Ff06492FD0127bd287A421e',       nonce: 87,       gasLimit: 45881n,       gasPrice: 1107421875n,       maxPriorityFeePerGas: 1n,       maxFeePerGas: 1107421875n,       data: '0x6057361d0000000000000000000000000000000000000000000000000000000000000005',       value: 0n,       chainId: 5678n,       signature: Signature { r: \"0x9233b9cc4ae6879b7e08b9f1a4bfb175c8216eee0099966eca4a305c7f369ecc\", s: \"0x7663688633006b5a449d02cb08311569fadf2f9696bd7fe65417860a3b5fc57d\", yParity: 0, networkV: null },       accessList: [],       blobVersionedHashes: null}  await box.retrieve(); 5n <p>Notice your address labeled <code>from</code>, the address of the contract, and the <code>data</code> that is being passed. Now, you can retrieve the value by running:</p> <pre><code>await box.retrieve();\n</code></pre> <p>You should see <code>5</code>, or the value you initially stored.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#using-a-script","title":"Using a Script","text":"<p>Similarly to the deployment script, you can create a script to interact with your deployed contract, store it in the <code>scripts</code> directory, and run it using the built-in <code>run</code> task.</p> <p>To get started, create a <code>set-value.js</code> file in the <code>scripts</code> directory:</p> <pre><code>cd scripts &amp;&amp; touch set-value.js\n</code></pre> <p>Now paste the following contract into the <code>set-value.js</code> file:</p> <pre><code>// scripts/set-value.js\nasync function main() {\n  // Create instance of the Box contract\n  const Box = await ethers.getContractFactory('Box');\n\n  // Connect the instance to the deployed contract\n  const box = await Box.attach('INSERT-CONTRACT-ADDRESS');\n\n  // Store a new value\n  await box.store(2);\n\n  // Retrieve the value\n  const value = await box.retrieve();\n  console.log(`The new value is: ${value}`);\n}\n\nmain()\n  .then(() =&gt; process.exit(0))\n  .catch(error =&gt; {\n    console.error(error);\n    process.exit(1);\n  });\n</code></pre> <p>To run the script, you can use the following command:</p> <pre><code>npx hardhat run --network moonbase set-value.js\n</code></pre> <p>The script should return <code>2</code> as the value.</p> npx hardhat run --network moonbase scripts/set-value.js The new value is: 2"},{"location":"builders/ethereum/dev-env/hardhat/#hardhat-forking","title":"Hardhat Forking","text":"<p>You can fork any EVM-compatible chain using Hardhat, including Moonbeam. Forking simulates the live Moonbeam network locally, enabling you to interact with deployed contracts on Moonbeam in a local test environment. Since Hardhat forking is based on an EVM implementation, you can interact with the fork using standard Ethereum JSON-RPC methods supported by Moonbeam and Hardhat.</p> <p>There are some limitations to be aware of when using Hardhat forking. You cannot interact with any of the Moonbeam precompiled contracts or their functions. Precompiles are a part of the Substrate implementation and therefore cannot be replicated in the simulated EVM environment. This prohibits you from interacting with cross-chain assets on Moonbeam and Substrate-based functionality such as staking and governance.</p> <p>There is currently an issue related to forking Moonbeam, so in order to fix the issue, you'll need to manually patch Hardhat first. You can find out more information by following the issue on GitHub as well as the related PR.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#patching-hardhat","title":"Patching Hardhat","text":"<p>Before getting started, you'll need to apply a temporary patch to workaround an RPC error until Hardhat fixes the root issue. The error is as follows:</p> <pre><code>Error HH604: Error running JSON-RPC server: Invalid JSON-RPC response's result.\n\nErrors: Invalid value null supplied to : RpcBlockWithTransactions | null/transactions: RpcTransaction Array/0: RpcTransaction/accessList: Array&lt;{ address: DATA, storageKeys: Array&lt;DATA&gt; | null }&gt; | undefined, Invalid value null supplied to : RpcBlockWithTransactions | null/transactions: RpcTransaction Array/1: RpcTransaction/accessList: Array&lt;{ address: DATA, storageKeys: Array&lt;DATA&gt; | null }&gt; | undefined, Invalid value null supplied to : RpcBlockWithTransactions | null/transactions: RpcTransaction Array/2: RpcTransaction/accessList: Array&lt;{ address: DATA, storageKeys: Array&lt;DATA&gt; | null }&gt; | undefined\n</code></pre> <p>To patch Hardhat, you'll need to open the <code>node_modules/hardhat/internal/hardhat-network/jsonrpc/client.js</code> file of your project. Next, you'll add an <code>addAccessList</code> function and update the <code>_perform</code> and <code>_performBatch</code> functions.</p> <p>To get started, you can remove the preexisting <code>_perform</code> and <code>_performBatch</code> functions and, in their place, add the following code snippet:</p> <pre><code>  addAccessList(method, rawResult) {\n    if (\n      method.startsWith('eth_getBlock') &amp;&amp;\n      rawResult &amp;&amp;\n      rawResult.transactions?.length\n    ) {\n      rawResult.transactions.forEach((t) =&gt; {\n        if (t.accessList == null) t.accessList = [];\n      });\n    }\n  }\n  async _perform(method, params, tType, getMaxAffectedBlockNumber) {\n    const cacheKey = this._getCacheKey(method, params);\n    const cachedResult = this._getFromCache(cacheKey);\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n    if (this._forkCachePath !== undefined) {\n      const diskCachedResult = await this._getFromDiskCache(\n        this._forkCachePath,\n        cacheKey,\n        tType\n      );\n      if (diskCachedResult !== undefined) {\n        this._storeInCache(cacheKey, diskCachedResult);\n        return diskCachedResult;\n      }\n    }\n    const rawResult = await this._send(method, params);\n    this.addAccessList(method, rawResult);\n    const decodedResult = (0, decodeJsonRpcResponse_1.decodeJsonRpcResponse)(\n      rawResult,\n      tType\n    );\n    const blockNumber = getMaxAffectedBlockNumber(decodedResult);\n    if (this._canBeCached(blockNumber)) {\n      this._storeInCache(cacheKey, decodedResult);\n      if (this._forkCachePath !== undefined) {\n        await this._storeInDiskCache(this._forkCachePath, cacheKey, rawResult);\n      }\n    }\n    return decodedResult;\n  }\n  async _performBatch(batch, getMaxAffectedBlockNumber) {\n    // Perform Batch caches the entire batch at once.\n    // It could implement something more clever, like caching per request\n    // but it's only used in one place, and those other requests aren't\n    // used anywhere else.\n    const cacheKey = this._getBatchCacheKey(batch);\n    const cachedResult = this._getFromCache(cacheKey);\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n    if (this._forkCachePath !== undefined) {\n      const diskCachedResult = await this._getBatchFromDiskCache(\n        this._forkCachePath,\n        cacheKey,\n        batch.map((b) =&gt; b.tType)\n      );\n      if (diskCachedResult !== undefined) {\n        this._storeInCache(cacheKey, diskCachedResult);\n        return diskCachedResult;\n      }\n    }\n    const rawResults = await this._sendBatch(batch);\n    const decodedResults = rawResults.map((result, i) =&gt; {\n      this.addAccessList(batch[i].method, result);\n      return (0, decodeJsonRpcResponse_1.decodeJsonRpcResponse)(\n        result,\n        batch[i].tType\n      );\n    });\n    const blockNumber = getMaxAffectedBlockNumber(decodedResults);\n    if (this._canBeCached(blockNumber)) {\n      this._storeInCache(cacheKey, decodedResults);\n      if (this._forkCachePath !== undefined) {\n        await this._storeInDiskCache(this._forkCachePath, cacheKey, rawResults);\n      }\n    }\n    return decodedResults;\n  }\n</code></pre> <p>Then you can use patch-package to automatically patch the package by running the following command:</p> <pre><code>npx patch-package hardhat\n</code></pre> <p>A <code>patches</code> directory will be created, and now you should be all set to fork Moonbeam without running into any errors.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#forking-moonbeam","title":"Forking Moonbeam","text":"<p>You can fork Moonbeam from the command line or configure your Hardhat project to always run the fork from your <code>hardhat.config.js</code> file. To fork Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>To fork Moonbeam from the command line, you can run the following command from within your Hardhat project directory:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>npx hardhat node --fork INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>npx hardhat node --fork INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>npx hardhat node --fork https://rpc.api.moonbase.moonbeam.network\n</code></pre> <p>If you prefer to configure your Hardhat project, you can update your <code>hardhat.config.js</code> file with the following configurations:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>...\nnetworks: {\n  hardhat: {\n    forking: {\n      url: 'INSERT_RPC_API_ENDPOINT',\n    },\n  },\n},\n...\n</code></pre> <pre><code>...\nnetworks: {\n  hardhat: {\n    forking: {\n      url: 'INSERT_RPC_API_ENDPOINT',\n    },\n  },\n},\n...\n</code></pre> <pre><code>...\nnetworks: {\n  hardhat: {\n    forking: {\n      url: 'https://rpc.api.moonbase.moonbeam.network',\n    },\n  },\n},\n...\n</code></pre> <p>When you spin up the Hardhat fork, you'll have 20 development accounts that are pre-funded with 10,000 test tokens. The forked instance is available at <code>http://127.0.0.1:8545/</code>. The output in your terminal should resemble the following:</p> Private Key: Oxdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97 Account #9: Oxa0Ee7A142d267C1f36714E4a8F75612F20a79720 (10000 ETH) Private Key: 0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6 Account #10: OxBcd4042DE499D14e55001CcbB24a551F3b954096 (10000 ETH) Private Key: Oxf214f2b2cd398c806f84e317254e0f0b801d0643303237d97a22a48e01628897 Account #11: 0x71bE63f3384f5fb98995898A86B02Fb2426c5788 (10000 ETH) Private Key: 0x701b615bbdfb9de65240bc28bd21bbc0d996645a3dd57e7b12bc2bdf6f192c82 Account #12: OxFABBOac9d68B0B445fB7357272F202C5651694a (10000 ETH) Private Key: Oxa267530f49f8280200edf313ee7af6b827f2a8bce2897751d06a843f644967b1 Account #13: 0x1CBd3b2770909D4e10f157cABC84C7264073C9Ec (10000 ETH) Private Key: 0x47c99abed3324a2707c28affff1267e45918ec8c3f20b8aa892e8b065d2942dd Account #14: OxdF3e18d64BC6A983f673Ab319CCaE4f1a5707097 (10000 ETH) Private Key: Oxc526ee95bf44d8fc405a158bb884d9d1238d990612e9f33d006bb0789009aaa Account #15: Oxcd3B766CCDd6AE721141F452C550Ca635964ce71 (10000 ETH) Private Key: 0x8166f546bab6da521a8369cab06c5d2b9e46670292d85c875ee9ec20e84ffb61 Account #16: 0\u00d72546BcD3c84621e976D8185a91A922aE77ECEc30 (10000 ETH) Private Key: Oxea6c44ac03bff858b476bba40716402b03e41b8e97e276d1baec7c37d42484a0 Account #17: OxbDA5747bFD65F08deb54cb465eB87D40e51B197E (10000 ETH) Private Key: 0x689af8efa8c651a91ad287602527f3af2fe9f6501a7ac4b06166765a93e037fd Account #18: OxdD2FD4581271e230360230F9337D5c0430Bf44C0 (10000 ETH) Private Key: Oxde9be858da4a475276426320d5e9262ecfc3ba460bfac56360bfa6c4c28b4ee0 Account #19: 0\u00d78626f6940E2eb28930eFb4CeF49B2d1F2C9C1199 (10000 ETH) Private Key: Oxdf57089febbacf7ba0bc227dafbffa9fc08a93fdc68e1e42411a14efcf23656e WARNING: These accounts, and their private keys, are publicly known.Any funds sent to them on Mainnet or any other live network WILL BE LOST. <p>To verify you have forked the network, you can query the latest block number:</p> <pre><code>curl --data '{\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}' -H \"Content-Type: application/json\" -X POST localhost:8545 \n</code></pre> <p>If you convert the <code>result</code> from hex to decimal, you should get the latest block number from the time you forked the network. You can cross-reference the block number using a block explorer.</p> <p>From here, you can deploy new contracts to your forked instance of Moonbeam or interact with contracts already deployed by creating a local instance of the deployed contract.</p> <p>To interact with an already deployed contract, you can create a new script in the <code>scripts</code> directory using <code>ethers</code>. Because you'll be running it with Hardhat, you don't need to import any libraries. Inside the script, you can access a live contract on the network using the following snippet:</p> <pre><code>const hre = require('hardhat');\n\nasync function main() {\n  const provider = new ethers.JsonRpcProvider(\n    'http://127.0.0.1:8545/'\n  );\n\n  const contract = new ethers.Contract(\n    'INSERT_CONTRACT_ADDRESS',\n    'INSERT_CONTRACT_ABI',\n    provider\n  );\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/dev-env/remix/","title":"Using Remix to Deploy to Moonbeam","text":""},{"location":"builders/ethereum/dev-env/remix/#introduction","title":"Introduction","text":"<p>Remix is an integrated development environment (IDE) for developing smart contracts on Ethereum and Ethereum-compatible chains. It provides an easy-to-use interface for writing, compiling, and deploying smart contracts. Given Moonbeam\u2019s Ethereum compatibility features, you can use Remix directly with any Moonbeam network.</p> <p>This guide walks through the process of creating and deploying a Solidity smart contract to a Moonbeam development node using the Remix IDE. This guide can be adapted for Moonbeam, Moonriver, or Moonbase Alpha.</p> <p>If you're familiar with Remix, you can skip ahead to the Connect Remix to Moonbeam section to learn how to use Remix with Moonbeam.</p>"},{"location":"builders/ethereum/dev-env/remix/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the purposes of this guide, you'll need to have the following:</p> <ul> <li>A locally running Moonbeam development node</li> <li>MetaMask installed and connected to your development node</li> </ul> <p>If you followed the guides above, you should have a local Moonbeam node, which will begin to author blocks as transactions arrive.</p> <p></p> <p>Your development node comes with 10 pre-funded accounts. You should have MetaMask connected to your Moonbeam development node and have imported at least one of the pre-funded accounts. You can refer to the Import Accounts section of the MetaMask docs for step-by-step instructions on how to import a development account.</p> <p></p> <p>If you're adapting this guide for Moonbeam, Moonriver, or Moonbase Alpha, make sure you are connected to the correct network and have an account with funds. You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet.</p>"},{"location":"builders/ethereum/dev-env/remix/#get-familiar-with-remix","title":"Get Familiar with Remix","text":"<p>If you navigate to https://remix.ethereum.org/, you'll see that the layout of Remix is split into four sections:</p> <ol> <li>The plugin panel</li> <li>The side panel</li> <li>The main panel</li> <li>The terminal</li> </ol> <p></p> <p>The plugin panel displays icons for each of the preloaded plugins, the plugin manager, and the settings menu. You'll see a few icons there for each of the preloaded plugins, which are the File explorer, Search in files, Solidity compiler, and Deploy and run transactions plugins. As additional plugins are activated, their icons will appear in this panel.</p> <p>The side panel displays the content of the plugin that is currently being viewed. By default, you'll see the File explorer plugin, which displays the default workspace and some preloaded files and folders. However, if you select one of the other icons from the plugin panel, you'll see the content for the selected plugin.</p> <p>The main panel is automatically loaded with the Home tab, which contains links to a variety of resources. You can close this tab at any time and reopen it by clicking on the blue Remix icon in the top left corner of the plugin panel. The main panel is where you'll be able to see each of the files you're working with. For example, you can double-click on any file in the File explorer side panel and it will appear as a tab in the main panel.</p> <p>The terminal panel is similar to a standard terminal that you have on your OS; you can execute scripts from it, and logs are printed to it. All transactions and contract interactions are automatically logged to the terminal. You can also interact with the Ethers and Web3 JavaScript libraries directly from the terminal.</p>"},{"location":"builders/ethereum/dev-env/remix/#add-a-smart-contract-to-the-file-explorer","title":"Add a Smart Contract to the File Explorer","text":"<p>For this example, you will create a new file that contains an ERC-20 token contract. This will be a simple ERC-20 contract based on the current OpenZeppelin ERC-20 template. The contract will create a <code>MyToken</code> token with the <code>MYTOK</code> symbol that mints the entirety of the initial supply to the creator of the contract.</p> <p>From the File explorer tab on the plugin panel, you can create a new file by taking the following steps:</p> <ol> <li>Click on the file icon</li> <li>Enter the name of the contract: <code>MyToken.sol</code></li> </ol> <p></p> <p>The main panel will switch to an empty file where you can add the Solidity code for the contract. Paste the <code>MyToken.sol</code> smart contract into the new file:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MYTOK\") {\n        _mint(msg.sender, initialSupply);\n    }\n}\n</code></pre> <p></p>"},{"location":"builders/ethereum/dev-env/remix/#compile-a-solidity-smart-contract","title":"Compile a Solidity Smart Contract","text":"<p>Before you compile a contract, make sure you've selected the file of the contract from the File explorer tab. Then, select the Solidity Compiler option from the plugin panel.</p> <p>Make sure that the compiler version in the top-left corner meets the version defined in your contract and the version defined in OpenZeppelin's <code>ERC20.sol</code> contract. For example, the <code>MyToken.sol</code> contract requires Solidity ^0.8.0, but at the time of writing, OpenZeppelin's <code>ERC20.sol</code> contract requires ^0.8.20, so the compiler needs to be set to version 0.8.20 or newer.</p> <p>The Solidity compiler plugin also lets you change some settings and apply advanced configurations for the compiler. If you're planning on iterating over the smart contract, you can check the Auto compile box, and whenever you make a change, the contract will automatically be recompiled.</p> <p>Additionally, from the Advanced Configurations menu, you can change the EVM version, enable optimizations, and set the number of times the bytecode is expected to be run throughout the contract's lifetime; the default is set to 200 times. For more information on contract optimization, please refer to the Solidity docs on The Optimizer.</p> <p>For this example, no additional configurations are needed. To compile the <code>MyToken.sol</code> contract, simply click on the Compile MyToken.sol contract. If the compilation was successful, you'll see a green check mark appear on the plugin panel next to the Solidity compiler plugin.</p> <p></p>"},{"location":"builders/ethereum/dev-env/remix/#debug-compilation-errors","title":"Debug Compilation Errors","text":"<p>If you tried to compile your smart contract but there was an error or warning, you can easily debug the issue with the help of ChatGPT directly from the Solidity compiler plugin in Remix.</p> <p>For example, if you only provided the token name to the ERC-20 constructor but forgot the token symbol and tried to compile the contract, an error would appear in the side panel. You can scroll down to read the error, and you'll see that there is also an ASK GPT button. To get help debugging the issue, you can click on ASK GPT, and a response will be returned in the Remix terminal that will guide you in the right direction to try and fix the issue. If you need additional help, you can go straight to the source and ask ChatGPT directly.</p> <p></p> <p>Once you successfully fix the issue and recompile the contract, you'll see a green check mark appear on the plugin panel next to the Solidity compiler plugin.</p> <p></p>"},{"location":"builders/ethereum/dev-env/remix/#deploy-a-solidity-smart-contract","title":"Deploy a Solidity Smart Contract","text":"<p>The Deploy and run transactions plugin enables you to configure contract deployment options, deploy contracts, and interact with deployed contracts.</p> <p>The side panel consists of the following deployment options:</p> <ul> <li>Environment - allows you to choose the execution environment for deployment</li> <li>Account - the account from which the deployment transaction will be sent</li> <li>Gas Limit - the maximum amount of gas that the deployment transaction can consume</li> <li>Value - the amount of the native asset to send along with the deployment transaction</li> <li>Contract - the contract to deploy</li> <li>Deploy - sends the deployment transaction to the specified environment using the selected account, gas limit, value, and the values for any constructor arguments</li> <li>At Address - allows you to interact with an existing contract by specifying its address</li> </ul> <p>The following section will cover how to configure the environment for deployment to be Moonbeam.</p>"},{"location":"builders/ethereum/dev-env/remix/#connect-remix-to-moonbeam","title":"Connect Remix to Moonbeam","text":"<p>To deploy the smart contract to Moonbeam, you'll need to make sure that you've connected your wallet to your Moonbeam development node or the Moonbeam network of your choice. Then, from the Deploy and run transactions tab, you can connect Remix to your wallet by selecting your wallet from the ENVIRONMENT dropdown. For example, if you have Trust Wallet installed, you'll see Injected Provider - TrustWallet from the dropdown. Aside from injected providers, you can also connect to Moonbeam via WalletConnect.</p> <p>For this example, MetaMask will be used. You should already have MetaMask installed and connected to your local Moonbeam development node. If not, please refer to the Interacting with Moonbeam Using MetaMask guide for step-by-step instructions.</p> <p>From the ENVIRONMENT dropdown, select Injected Provider - MetaMask.</p> <p></p> <p>MetaMask will pop up automatically and prompt you to connect to Remix. You'll need to:</p> <ol> <li>Select the account you want to connect to Remix</li> <li>Click Next</li> <li>Click Connect to connect your account to Remix</li> </ol> <p></p> <p>Once you've connected MetaMask to Remix, the side panel will update to reveal the network and account you're connected to. For a Moonbeam development node, you should see Custom (1281) network.</p> <p></p>"},{"location":"builders/ethereum/dev-env/remix/#deploy-the-contract-to-moonbeam","title":"Deploy the Contract to Moonbeam","text":"<p>Now that you've connected your wallet, you're ready to deploy the contract. Since you're deploying a simple ERC-20 token smart contract, the default gas limit set by Remix of 3 million is more than enough, and you don't need to specify a value to send along with the deployment. As such, you can take the following steps to deploy the contract:</p> <ol> <li>Make sure the ENVIRONMENT is set to Injected Provider - MetaMask</li> <li>Make sure the connected account is the one you want to deploy the transaction from</li> <li>Use the default GAS LIMIT of <code>3000000</code></li> <li>Leave the VALUE as <code>0</code></li> <li>Make sure <code>MyToken.sol</code> is the selected contract</li> <li>Expand the DEPLOY dropdown</li> <li>Specify the initial supply. For this example, you can set it to 8 million tokens. Since this contract uses the default of 18 decimals, the value to put in the box is <code>8000000000000000000000000</code></li> <li>Click transact to send the deployment transaction</li> <li>MetaMask will pop up, and you can click Confirm to deploy the contract</li> </ol> <p></p> <p>Once the transaction has been deployed, you'll see details about the deployment transaction in the Remix terminal. Additionally, the contract will appear under the Deployed Contracts section of the side panel.</p>"},{"location":"builders/ethereum/dev-env/remix/#interact-with-deployed-smart-contracts","title":"Interact with Deployed Smart Contracts","text":"<p>Once you've deployed a smart contract or accessed an existing contract via the At Address button, the contract will appear under the Deployed Contracts section of the side panel. You can expand the contract to view all of the contract's functions you can interact with.</p> <p>To interact with a given function, you can click on the function name, which will be contained in an orange, red, or blue button. Orange buttons are for functions that write to the blockchain and are non-payable; red buttons are for functions that write to the blockchain and are payable; and blue buttons are for functions that read data from the blockchain.</p> <p>Depending on the function you're interacting with, you may need to input parameter values. If the function requires inputs, you'll be able to enter them by expanding the function and entering a value for each of the parameters.</p> <p>If the function you're interacting with is payable, you'll be able to enter an amount in the VALUE field towards the top of the side panel, in the same value field used for contracts that have payable constructors.</p>"},{"location":"builders/ethereum/dev-env/remix/#call-the-smart-contract-functions","title":"Call the Smart Contract Functions","text":"<p>If you expand the MYTOKEN contract dropdown, you'll be able to see all of the available functions you can interact with. To interact with a given function, you can provide any inputs, if needed, and then click on the button containing the function name you want to interact with.</p> <p>For example, if you wanted to call the <code>totalSupply</code> function, you wouldn't need to sign a transaction, as you'd get a response right away.</p> <p></p> <p>On the other hand, if you call the <code>approve</code> function, which will approve an account as a spender of a given amount of MYTOK tokens, you'll need to submit the approval in MetaMask. To test this out, you can take the following steps:</p> <ol> <li>Set the spender to an account that you want to be able to spend tokens on your behalf. For this example, you can use Bob's account (one of the pre-funded development accounts): <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>Enter the amount the spender can spend. For this example, you can approve Bob to spend 10 MYTOK by entering in <code>10000000000000000000</code></li> <li>Press transact</li> <li>MetaMask will pop up and you'll need to review the details of the approval and submit the approval</li> </ol> <p></p> <p>To view your balance or approvals, or transfer MYTOKs, you can add the MYTOK to your wallet. For information on how to add a token to MetaMask, you can refer to the Add an ERC-20 Token section of our MetaMask documentation.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/dev-env/scaffold-eth/","title":"Using Scaffold-ETH 2 to Deploy a DApp on Moonbeam","text":""},{"location":"builders/ethereum/dev-env/scaffold-eth/#introduction","title":"Introduction","text":"<p>Scaffold-ETH 2 is a collection of commonly used Ethereum development tools to quickly deploy a Solidity smart contract and launch a DApp with a React frontend.</p> <p>Scaffold-ETH 2 consists of several sub-components, including Hardhat for creating, deploying, and testing smart contracts and Next.js for building a React frontend. These components can be used on Moonbeam networks with some slight modifications.</p> <p>This guide will walk through the steps to deploy and run the default example contract and DApp that Scaffold-ETH 2 comes with on a Moonbeam network.</p>"},{"location":"builders/ethereum/dev-env/scaffold-eth/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you will need the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>An Etherscan API key</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul>"},{"location":"builders/ethereum/dev-env/scaffold-eth/#installing-scaffold-eth","title":"Installing Scaffold-ETH 2","text":"<p>First, download Scaffold-ETH 2 from GitHub.</p> <p>From the command line, enter:</p> <pre><code>git clone https://github.com/scaffold-eth/scaffold-eth-2.git\n</code></pre> <p>After the download completes, run:</p> <pre><code>yarn install\n</code></pre>"},{"location":"builders/ethereum/dev-env/scaffold-eth/#development-process","title":"The Development Process with Scaffold-ETH 2","text":"<p>The process for developing a project with Scaffold-ETH 2 can be outlined as follows:</p> <ol> <li>Update the network configurations in Hardhat for Moonbeam</li> <li>Add your smart contracts to the <code>packages/hardhat/contracts</code></li> <li>Edit your deployment scripts in the <code>packages/hardhat/deploy</code></li> <li>Deploy your smart contracts to Moonbeam</li> <li>Verify your smart contracts with the Etherscan plugin and your Etherscan API key</li> <li>Configure your frontend to target Moonbeam in the <code>packages/nextjs/scaffold.config.ts</code> file</li> <li>Edit your frontend as needed in the <code>packages/nextjs/pages</code> directory</li> </ol> <p>In this guide, you can use the default contract and frontend that you get out of the box when you clone the Scaffold-ETH 2 repository. All you'll have to do is modify these components for Moonbeam.</p>"},{"location":"builders/ethereum/dev-env/scaffold-eth/#hardhat-component","title":"The Hardhat Component","text":"<p>In the following sections, you'll update the network configurations in the Hardhat configuration file to target the Moonbeam-based network you want to interact with, and deploy and verify the example contract to that network.</p>"},{"location":"builders/ethereum/dev-env/scaffold-eth/#configure-hardhat-for-moonbeam","title":"Configure Hardhat for Moonbeam","text":"<p>You can begin by making modifications to the Hardhat component under the <code>packages/hardhat</code> folder. You'll primarily be editing the <code>hardhat.config.js</code> file to configure it for Moonbeam. However, you'll also need to create a <code>.env</code> file to store a couple of variables that will be consumed by the <code>hardhat.config.js</code> file.</p> <p>You can refer to the <code>.env.example</code> file for the variables that are already used in the <code>hardhat.config.js</code> file. For Moonbeam, you'll only need to manually create one variable, the <code>ETHERSCAN_API_KEY</code>.</p> <p>Check out the Etherscan Plugins documentation to learn how to generate an Etherscan API key.</p> <p>To get started, create a <code>.env</code> file:</p> <pre><code>touch packages/hardhat/.env\n</code></pre> <p>Edit your <code>.env</code> file to include the following variables:</p> <pre><code>ETHERSCAN_API_KEY=INSERT_ETHERSCAN_API_KEY\n</code></pre> <p>Next, import your deployment account by either generating a new one with <code>yarn generate</code> or importing an existing one using <code>yarn account:import</code>. If importing, you'll need to provide your private key and create a password to encrypt it. The encrypted key will be saved in your <code>.env</code> file. Keep your password safe as you'll need it to decrypt the private key for future deployments. Remember to never share or commit your private keys or <code>.env</code> file. For this example, we'll import an existing private key with the following command: </p> <pre><code>yarn account:import\n</code></pre> yarn account:import \ud83d\udc5b Importing Wallet Paste your private key: [hidden] Enter a password to encrypt your private key: [hidden] Confirm password: [hidden] \ud83d\udcc4 Encrypted Private Key saved to packages/hardhat/.env file \ud83e\ude84 Imported wallet address: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e \u26a0\ufe0f Make sure to remember your password! You'll need it to decrypt the private key. <p>The private key you add in the account import workflow corresponds to the account that will deploy and interact with the smart contracts in your Hardhat project. Additionally, the Etherscan API key will correspond to your Etherscan API key and will be used to verify your deployed smart contracts. To learn how to generate an Etherscan API key, check out the Etherscan Plugins documentation.</p> <p>With the deployment account and the Etherscan API key taken care of, next you can modify the <code>hardhat.config.js</code> file for Moonbeam:</p> <ol> <li> <p>Set the constant <code>defaultNetwork</code> to the network you are deploying the smart contract to</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>defaultNetwork = 'moonbeam';\n</code></pre> <pre><code>defaultNetwork = 'moonriver';\n</code></pre> <pre><code>defaultNetwork = 'moonbaseAlpha';\n</code></pre> <pre><code>defaultNetwork = 'moonbeamDevNode';\n</code></pre> </li> <li> <p>Add the network configurations for the Moonbeam network you want to interact with under the <code>networks</code> configuration object</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>moonbeam: {\n  url: \"INSERT_RPC_API_ENDPOINT\",\n  accounts: [deployerPrivateKey],\n},\n</code></pre> <pre><code>moonriver: {\n  url: \"INSERT_RPC_API_ENDPOINT\",\n  accounts: [deployerPrivateKey],\n},\n</code></pre> <pre><code>moonbaseAlpha: {\n  url: \"https://rpc.api.moonbase.moonbeam.network\",\n  accounts: [deployerPrivateKey],\n},\n</code></pre> <pre><code>moonbeamDevNode: {\n  url: \"http://127.0.0.1:9944\",\n  accounts: [deployerPrivateKey],\n},\n</code></pre> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> </li> </ol> <p>For more information on using Hardhat with Moonbeam, please check the dedicated Hardhat page for more details.</p>"},{"location":"builders/ethereum/dev-env/scaffold-eth/#deploy-contract","title":"Deploy Your Contract to Moonbeam","text":"<p>After all the modifications to the configuration files are done, you can deploy your contract to the configured Moonbeam-based network.</p> <p>First, you can compile your contract by running:</p> <pre><code>yarn compile\n</code></pre> yarn compile Generating typings for: 2 artifacts in dir: typechain-types for target: ethers-v6 Successfully generated 6 typings! Compiled 2 Solidity files successfully (evm target: paris). <p>Then, you can run the following command from the root directory of your project:</p> <pre><code>yarn deploy\n</code></pre> yarn deploy Enter password to decrypt private key: [hidden] Nothing to compile No need to generate any newer typings. deploying \"YourContract\" (tx: 0xda4b71904cae30fad60669b321e1dd51b28a6cf197fc7ea13b5d85035b41d92c)...: deployed at 0xB527D4Ed38249d35cfCBAb92b51f45895622c6Eb with 837042 gas \ud83d\udc4b Initial greeting: Building Unstoppable Apps!!! \ud83d\udcdd Updated TypeScript contract definition file on ../nextjs/contracts/deployedContracts.ts <p>Note</p> <p>If you did not set the <code>defaultNetwork</code> config in the <code>hardhat.config.js</code> file, you can append <code>--network INSERT_NETWORK</code> to the command. For example, the following command would deploy a contract to Moonbeam.</p> <pre><code>yarn deploy --network moonbeam\n</code></pre>"},{"location":"builders/ethereum/dev-env/scaffold-eth/#verify-contracts","title":"Verify Your Deployed Contract","text":"<p>If you would also like to use Scaffold-ETH 2 to verify the deployed smart contract and have entered your Etherscan API key into the <code>.env</code> file, you can go ahead and verify your deployed contract.</p> <p>If the smart contract you are verifying has constructor method parameters, you will also need to append the parameters used to the end of the command.</p> <p>You can use the following command to verify the smart contract:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>yarn verify --api-url https://api-moonbeam.moonscan.io\n</code></pre> <pre><code>yarn verify --api-url https://api-moonriver.moonscan.io\n</code></pre> <pre><code>yarn verify --api-url https://api-moonbase.moonscan.io\n</code></pre> <p>Note</p> <p>If you did not set the <code>defaultNetwork</code> configuration in the <code>hardhat.config.js</code> file, you can append <code>--network INSERT_NETWORK</code> to the command. For example, the following command would verify a contract on Moonbeam.</p> <pre><code>yarn verify --network moonbeam --api-url https://api-moonbeam.moonscan.io\n</code></pre> <p>After a short wait, the console output will display the verification result and, if successful, the URL to the verified contract on Moonscan.</p> yarn verify --api-url https://api-moonbase.moonscan.io verifying YourContract (0xB527D4Ed38249d35cfCBAb92b51f45895622c6Eb) ... waiting for result... =&gt; contract YourContract is now verified <p>For more information about verifying smart contracts on Moonbeam using the Hardhat Etherscan plugin, please refer to the Etherscan Plugins page.</p>"},{"location":"builders/ethereum/dev-env/scaffold-eth/#nextjs-component","title":"The Next.js Component","text":"<p>In the following sections, you'll modify the Next.js configuration so that it targets the Moonbeam-based network that your contract has been deployed to, and then you'll launch the dApp.</p>"},{"location":"builders/ethereum/dev-env/scaffold-eth/#configure-dapp","title":"Configure the DApp for Moonbeam","text":"<p>To target the Moonbeam-based network that you deployed your smart contract to, you'll need to edit the configurations in the <code>packages/nextjs/scaffold.config.ts</code> file. More specifically, you'll need to modify the <code>targetNetworks</code> array in the <code>scaffoldConfig</code> object. You can use the list of chains that viem provides to specify the chain(s) you've deployed your contract to.</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>targetNetworks: [chains.moonbeam],\n</code></pre> <pre><code>targetNetworks: [chains.moonriver],\n</code></pre> <pre><code>targetNetworks: [chains.moonbaseAlpha],\n</code></pre> <pre><code>targetNetworks: [chains.moonbeamDev],\n</code></pre> <p>That's all you have to do to configure Next.js! Next, you can launch the dApp.</p>"},{"location":"builders/ethereum/dev-env/scaffold-eth/#launch-the-dapp","title":"Launch the DApp","text":"<p>After all the modifications to the configuration files are done, you can launch the example dApp. To do so, you can run:</p> <pre><code>yarn start\n</code></pre> yarn start   \u25b2 Next.js 14.2.11   - Local:        http://localhost:3000  \u2713 Starting...    Downloading swc package @next/swc-darwin-arm64...  \u2713 Ready in 3.7s  \u25cb Compiling / ... \ud83c\udf3c   daisyUI 4.12.10 \u251c\u2500 \u2714\ufe0e 2 themes added        https://daisyui.com/docs/themes \u2570\u2500 \u2605 Star daisyUI on GitHub https://github.com/saadeghi/daisyui  \u2713 Compiled / in 10.8s (7727 modules)  GET / 200 in 11353ms  HEAD / 200 in 31ms <p>This will launch the React-based DApp frontend at <code>http://localhost:3000/</code> by default. You can then point your browser to <code>http://localhost:3000/</code> and interact with the React frontend by connecting your wallet or checking out the contract debugger page.</p> <p></p> <p>And that's it! Now that you have the basics down, feel free to create and deploy your own smart contracts and modify the frontend to fit your dApp's needs! For more information, you can check out the Scaffold-ETH 2 docs.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/dev-env/tenderly/","title":"Using Tenderly on Moonbeam","text":""},{"location":"builders/ethereum/dev-env/tenderly/#introduction","title":"Introduction","text":"<p>Tenderly is a Web3 development platform that contains a suite of tools designed to help developers throughout the DApp development life cycle. With Tenderly, you can build, debug, test, optimize, monitor, set up alerts, and view analytics for your smart contracts on Moonbeam and Moonriver.</p> <p>The Tenderly platform provides the following features:</p> <ul> <li> <p>Contract Verification - as it is essential to verify your smart contracts to take full advantage of all of Tenderly's features, Tenderly provides several methods of verification. You can verify smart contracts through the Tenderly dashboard, the Tenderly CLI and Foundry, or the Tenderly Hardhat plugin</p> </li> <li> <p>Debugger - use the visual debugger to inspect transactions and get better insight into the behavior of your code. With the debugger, you can review a transaction's stack trace, view the calls made in a transaction, step through a contract, and review decoded inputs, outputs, and state variables. You can use the debugger on the Tenderly dashboard or the Tenderly Debugger Chrome Extension</p> </li> <li> <p>Gas Profiler - view how much gas you're spending on a granular level, so you can optimize your smart contracts and reduce transaction gas costs</p> </li> <li> <p>Simulator - simulate transactions in a TestNet development environment to learn how your transactions will behave without having to send them on-chain. This way, you can know the transaction's outcome and ensure it works as expected before sending it to the network. You can experiment with different parameters, simulate historical and current transactions, and edit the contract source code. You can access the simulator from the Tenderly dashboard, or you can use the Tenderly Simulation API to take advantage of the simulator programmatically</p> </li> <li> <p>Virtual TestNets - simulate the live Moonbeam network in an isolated environment to interact with deployed contracts and real-time on-chain data. These test environments enable controlled development, testing, and debugging across smart contracts, UI, backend, and data indexing. They support sequential transaction simulations for complex scenarios. There are some limitations to be aware of when using this feature. Moonbeam precompiled contracts are not supported, as they are part of the Substrate implementation and cannot be replicated in the simulated EVM environment, prohibiting you from interacting with cross-chain assets, staking, and governance.</p> </li> <li> <p>Alerting - configure real-time alerts to notify you whenever a specific event occurs, allowing you to stay informed about what's going on with your smart contracts</p> </li> <li> <p>Web3 Actions - create programmable functions in JavaScript or TypeScript that are executed automatically by Tenderly when a specific smart contract or chain event occurs</p> </li> </ul> <p>Note</p> <p>Tenderly supports Moonbeam, Moonriver, and Moonbase Alpha, except for the Web3 Gateway. For more information, check out Tenderly's documentation on Supported Networks.</p>"},{"location":"builders/ethereum/dev-env/tenderly/#getting-started","title":"Getting Started","text":"<p>The Tenderly dashboard provides access to an all-in-one Web3 development platform. To get started with the dashboard, you'll need to sign up for an account. Once you've signed up, you'll be able to start exploring your Tenderly dashboard.</p> <p></p> <p>If you prefer not to set up an account, you can also access limited features using Tenderly's explorer. Without an account, you can still gain insights into contracts and transactions. However, you won't be able to simulate transactions or create Virtual TestNets.</p> <p>To interact with Tenderly's features programmatically, you can check out the Tenderly CLI GitHub repository for more information.</p> <p>The following sections will show you how to get started with Tenderly on Moonbeam. For more detailed documentation, please refer to Tenderly's documentation site.</p>"},{"location":"builders/ethereum/dev-env/tenderly/#add-a-contract","title":"Add a Contract","text":"<p>A good place to start with the Tenderly dashboard is to add a deployed smart contract. Once you've added a contract, you'll be able to create transaction simulations and Virtual TestNets, use the debugger, set up monitoring and alerts, and more.</p> <p>To add a new contract, you can click on Contracts on the left-side panel and click Add Contract. A pop-up will appear, and you can take the following steps:</p> <ol> <li>Enter the contract address</li> <li>(Optional) You can give your contract a name</li> <li>Choose Moonbeam, Moonriver, or Moonbase Alpha as the network, depending on which network you've deployed your smart contract to</li> <li>(Optional) Toggle the Add more slider to add additional contracts after the initial one</li> <li>Finally, to add the contract to the dashboard, click Save</li> </ol> <p></p> <p>After a contract has been added, it will appear in the list of contracts on the Contracts dashboard. If the contract hasn't been verified yet, the dashboard will display an Unverified status along with a Verify button.</p> <p></p> <p>To take full advantage of the Tenderly tool set, it is recommended that you verify your smart contracts, which you can do by clicking on Verify. You can choose to verify your contract by uploading the contract's JSON, ABI, or source code. For more information, please refer to Tenderly's documentation on Smart Contract Verification.</p>"},{"location":"builders/ethereum/dev-env/tenderly/#virtual-testnets-moonbeam","title":"Create a Virtual TestNet","text":"<p>Tenderly's Virtual TestNets feature simulates the live Moonbeam network in an isolated environment, which enables you to interact with deployed contracts and live on-chain data.</p> <p>There are some limitations to be aware of when using this feature. You cannot interact with any of the Moonbeam precompiled contracts and their functions. Precompiles are a part of the Substrate implementation and, therefore, cannot be replicated in the simulated EVM environment. This prohibits you from interacting with cross-chain assets on Moonbeam and Substrate-based functionality such as staking and governance.</p> <p>Tenderly makes creating a TestNet through the dashboard quite simple. To get started, click on Virtual TestNets on the left-side menu and then click Create Virtual TestNet. From there, you can take the following steps:</p> <ol> <li>Select Moonbeam, Moonriver, or Moonbase Alpha from the Parent network dropdown</li> <li>(Optional) Give your TestNet a name</li> <li>Select your Chain ID; you can use a custom one or the original network ID. It is recommended to set a custom Chain ID to prevent replay attacks and avoid issues when adding the Virtual TestNet to wallets</li> <li>Choose whether to turn on or off the Public Explorer</li> <li>Enable State Sync if you want to keep your Virtual TestNet updated in real-time with the parent network</li> <li>To limit data, disable Use latest block and enter a block number, or keep it enabled to include all blocks</li> <li>Click Create</li> </ol> <p></p> <p>Once you've created your Virtual TestNet, you can start using it by deploying a contract or creating a transaction simulation.</p> <p>To deploy a contract, go to Contracts in the left menu. Use one from Watched Contracts or add a new one via Watch Contract. Once added, it will appear in Contracts, where you can view its details.</p> <p>To create a simulation, click the Simulation button and enter the configurations for the simulation. For more information on simulations, please refer to Tenderly's Simulator UI Overview documentation.</p> <p></p> <p>Now that you've learned how to get started with a few of Tenderly's features on Moonbeam, please feel free to dive in and check out the other tools available in their development platform. You can visit Tenderly's documentation site for more information. You can also check out Moonbeam's tutorial on Using Tenderly to Simulate and Debug Transactions.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/dev-env/thirdweb/","title":"Using thirdweb on Moonbeam","text":""},{"location":"builders/ethereum/dev-env/thirdweb/#introduction","title":"Introduction","text":"<p>thirdweb is a complete Web3 development framework that provides everything you need to develop smart contracts, build dApps, and more.</p> <p>With thirdweb, you can access tools to help you through every phase of the dApp development cycle. You can create your own custom smart contracts or use any of thirdweb's prebuilt contracts to get started quickly. From there, you can use thirdweb's CLI to deploy your smart contracts. Then you can interact with your smart contracts by creating a Web3 application using the language of your choice, including but not limited to React and TypeScript. </p> <p>This guide will show you some of the thirdweb features you can use to develop smart contracts and dApps on Moonbeam. To check out all of the features thirdweb has to offer, please refer to the thirdweb documentation site. For a comprehensive step-by-step tutorial for building a dApp on Moonbeam with thirdweb, be sure to check out Moonbeam's thirdweb tutorial in the tutorials section.</p>"},{"location":"builders/ethereum/dev-env/thirdweb/#create-contract","title":"Create Contract","text":"<p>To create a new smart contract using the thirdweb CLI, follow these steps:</p> <ol> <li> <p>In your CLI, run the following command:</p> <pre><code>npx thirdweb create contract\n</code></pre> </li> <li> <p>Input your preferences for the command line prompts:</p> <ol> <li>Give your project a name</li> <li>Choose your preferred framework: Hardhat or Foundry</li> <li>Name your smart contract</li> <li>Choose the type of base contract: Empty, ERC20, ERC721, or ERC1155</li> <li>Add any desired extensions</li> </ol> </li> <li>Once created, navigate to your project\u2019s directory and open in your preferred code editor</li> <li> <p>If you open the <code>contracts</code> folder, you will find your smart contract; this is your smart contract written in Solidity</p> <p>The following is code for an <code>ERC721Base</code> contract without specified extensions. It implements all of the logic inside the <code>ERC721Base.sol</code> contract; which implements the <code>ERC721A</code> standard.</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@thirdweb-dev/contracts/base/ERC721Base.sol';\n\ncontract Contract is ERC721Base {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _royaltyRecipient,\n        uint128 _royaltyBps\n    ) ERC721Base(_name, _symbol, _royaltyRecipient, _royaltyBps) {}\n}\n</code></pre> <p>This contract inherits the functionality of <code>ERC721Base</code> through the following steps:</p> <ul> <li>Importing the <code>ERC721Base</code> contract</li> <li>Inheriting the contract by declaring that your contract is an <code>ERC721Base</code> contract</li> <li>Implementing any required methods, such as the constructor</li> </ul> </li> <li> <p>After modifying your contract with your desired custom logic, you can deploy it to Moonbeam. That will be covered in the next section!</p> </li> </ol> <p>Alternatively, you can deploy a prebuilt contract for NFTs, tokens, or marketplace directly from the thirdweb Explore page:</p> <ol> <li> <p>Go to the thirdweb Explore page</p> <p></p> </li> <li> <p>Choose the type of contract you want to deploy from the available options: NFTs, tokens, marketplace, and more</p> </li> <li>Follow the on-screen prompts to configure and deploy your contract</li> </ol> <p>For more information on different contracts available on Explore, check out thirdweb\u2019s documentation on prebuilt contracts.</p>"},{"location":"builders/ethereum/dev-env/thirdweb/#deploy-contract","title":"Deploy a Contract","text":"<p>thirdweb allows you to easily deploy a smart contract to any EVM compatible network without configuring RPC URLs, exposing your private keys, writing scripts, and other additional setup such as verifying your contract.</p> <ol> <li> <p>To deploy your smart contract using the CLI, navigate to the <code>contracts</code> directory of your project and execute the following command:</p> <pre><code>npx thirdweb deploy\n</code></pre> <p>Executing this command will trigger the following actions:</p> <ul> <li>Compiling all the contracts in the current directory</li> <li>Providing the option to select which contract(s) you wish to deploy</li> <li>Uploading your contract source code (ABI) to IPFS</li> </ul> </li> <li> <p>When it is completed, it will open a dashboard interface to finish filling out the parameters</p> <ul> <li><code>_name</code> - contract name</li> <li><code>_symbol</code> - symbol or \"ticker\"</li> <li><code>_royaltyRecipient</code> - wallet address to receive royalties from secondary sales</li> <li><code>_royaltyBps</code> - basis points (bps) that will be given to the royalty recipient for each secondary sale, e.g. 500 = 5%</li> </ul> </li> <li> <p>Select the desired Moonbeam network, e.g., Moonbeam, Moonriver, or Moonbase Alpha</p> </li> <li> <p>Manage additional settings on your contract\u2019s dashboard as needed such as uploading NFTs, configuring permissions, and more</p> <p></p> </li> </ol> <p>For additional information on deploying contracts, please reference thirdweb\u2019s documentation.</p>"},{"location":"builders/ethereum/dev-env/thirdweb/#create-application","title":"Create Application","text":"<p>thirdweb offers SDKs for a range of programming languages, such as React, React Native, TypeScript, and Unity. You'll start off by creating an application and then you can choose which SDK to use:</p> <ol> <li> <p>In your CLI run the following command:</p> <pre><code>npx thirdweb create --app\n</code></pre> </li> <li> <p>Input your preferences for the command line prompts:</p> <ol> <li>Give your project a name</li> <li>Choose your preferred framework: Next.js, Vite, or React Native. For this example, select Vite</li> </ol> </li> <li> <p>Use the React or TypeScript SDK to interact with your application\u2019s functions. This will be covered in the following section on interacting with a contract</p> </li> </ol>"},{"location":"builders/ethereum/dev-env/thirdweb/#specify-client-id","title":"Specify Client ID","text":"<p>Before you launch your dApp (locally or publicly deployed), you must have a thirdweb Client ID associated with your project. A thirdweb Client ID is synonymous with an API key. You can create a free API key by signing into your thirdweb account, navigating to Settings, and clicking on API Keys.</p> <p>Press Create API Key then take the following steps:</p> <ol> <li>Give your API key a name</li> <li>Enter the allowed domains that the API key should accept requests from. It's recommended that you allow only necessary domains, but for development purposes, you can select Allow all domains</li> <li>Press Next and confirm the prompt on the next page</li> </ol> <p></p> <p>Note</p> <p>The respective name for your Client ID variable will vary with the framework you've chosen, e.g., Vite will be <code>VITE_TEMPLATE_CLIENT_ID</code>, Next.js will be <code>NEXT_PUBLIC_TEMPLATE_CLIENT_ID</code>, and React Native will be <code>EXPO_PUBLIC_THIRDWEB_CLIENT_ID</code>.</p> <p>Finally, specify your Client ID (API Key) in your <code>.env</code> file. Your <code>.env</code> file must be located at the root directory of the project (e.g., not the <code>src</code> folder).</p> <p>If you generated your thirdweb app with Vite, you'll have a <code>client.ts</code> file that looks like the below. As long you've created a <code>.env</code> file with your thirdweb API Key (Client ID) defined in <code>VITE_TEMPLATE_CLIENT_ID</code>, you can leave the <code>client.ts</code> as is and proceed to the next section.</p> client.ts<pre><code>import { createThirdwebClient } from 'thirdweb';\n\n// Replace this with your client ID string.\n// Refer to https://portal.thirdweb.com/typescript/v5/client on how to get a client ID\nconst clientId = import.meta.env.VITE_TEMPLATE_CLIENT_ID;\n\nexport const client = createThirdwebClient({\n  clientId: clientId,\n});\n</code></pre> <p>Note</p> <p>If you don't create a Client ID and specify is correctly in your <code>.env</code> file, you'll get a blank screen when trying to build the web app. There is no error message shown without digging into the console, so ensure you've set your Client ID correctly first and foremost.</p>"},{"location":"builders/ethereum/dev-env/thirdweb/#run-locally","title":"Run Locally","text":"<p>To run your dApp locally for testing and debugging purposes, use the command: </p> <pre><code>yarn dev\n</code></pre> <p>The app will compile and specify the localhost and port number for you to visit in your browser.</p> <p></p>"},{"location":"builders/ethereum/dev-env/thirdweb/#configure-chain","title":"Configure Chain","text":"<p>thirdweb offers a small number of chains from <code>@thirdweb/chains</code> and does not include Moonbeam networks in that list, so you'll need to specify the network details including chain ID and RPC URL. You can create a custom chain with <code>defineChain</code> as follows:</p> MoonbeamMoonriverMoonbase Alpha chains.ts<pre><code>import { defineChain } from 'thirdweb';\nconst moonbeam = defineChain({\n  id: 1284,\n  rpc: 'https://rpc.api.moonbeam.network',\n});\n</code></pre> chains.ts<pre><code>import { defineChain } from 'thirdweb';\nconst moonriver = defineChain({\n  id: 1285,\n  rpc: 'https://rpc.api.moonriver.moonbeam.network',\n});\n</code></pre> chains.ts<pre><code>import { defineChain } from 'thirdweb';\nconst moonbase = defineChain({\n  id: 1287,\n  rpc: 'https://rpc.api.moonbase.moonbeam.network',\n});\n</code></pre>"},{"location":"builders/ethereum/dev-env/thirdweb/#thirdweb-sdk","title":"thirdweb SDK","text":"<p>The following sections will provide an overview of fundamental methods of the thirdweb SDK and how to interact with them. Each code snippet will showcase the relevant import statements and demonstrate using the method in a typical scenario. This guide is intended to be a quick reference guide to the most common thirdweb methods that dApp developers will use. However, it does not include information on each and every thirdweb offering. For details on the entirety of thirdweb's offerings, be sure to visit the thirdweb documentation site.</p> <p>For a comprehensive, step-by-step guide to building a dApp with thirdweb be sure to check out Moonbeam's thirdweb tutorial in the tutorials section. The following sections will cover everything from connecting wallets, to preparing transactions, and more.</p>"},{"location":"builders/ethereum/dev-env/thirdweb/#accounts-and-wallets","title":"Accounts and Wallets","text":"<p>thirdweb distinguishes between accounts and wallets in the SDK. In the eyes of the thirdweb SDK, an account always has a single blockchain address and can sign messages, transactions, and typed data, but it cannot be \"connected\" or \"disconnected.\" In contrast, a wallet contains one or more accounts, can be connected or disconnected, and delegates the signing tasks to its accounts. </p> <p>The below code snippet demonstrates how to initialize and connect a MetaMask wallet using the thirdweb SDK, then sign and send a transaction, retrieving the transaction hash. This process is applicable to any of the 300+ wallet connectors supported by the SDK.</p> initialize.ts <pre><code>import { sendTransaction } from 'thirdweb';\n// MetaMask wallet used for example, the pattern is the same for all wallets\nimport { createWallet } from 'thirdweb/wallets';\n\n// Initialize the wallet. thirdweb supports 300+ wallet connectors\nconst wallet = createWallet('io.metamask');\n\n// Connect the wallet. This returns a promise that resolves to the connected account\nconst account = await wallet.connect({\n  // Pass the client you created with `createThirdwebClient()`\n  client,\n});\n\n// Sign and send a transaction with the account. Returns the transaction hash\nconst { transactionHash } = await sendTransaction({\n  // Assuming you have called `prepareTransaction()` or `prepareContractCall()` before, which returns the prepared transaction to send\n  transaction,\n  // Pass the account to sign the transaction with\n  account,\n});\n</code></pre>"},{"location":"builders/ethereum/dev-env/thirdweb/#get-contract","title":"Get Contract","text":"<p>To connect to your contract, use the SDK\u2019s <code>getContract</code> method. As an example, you could fetch data from an incrementer contract on Moonbase Alpha.</p> <pre><code>import { getContract } from 'thirdweb';\nimport { client } from './client';\n\nconst myContract = getContract({\n  client,\n  chain: moonbase,\n  address: 0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8, // Incrementer contract address on Moonbase Alpha\n  abi: '[{\"inputs\":[],\"name\":\"increment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]';\n});\n</code></pre>"},{"location":"builders/ethereum/dev-env/thirdweb/#calling-contract-functions","title":"Calling Contract Functions","text":"<p>To call a contract in the latest version of the SDK, you can use <code>prepareContractCall</code>.</p> <pre><code>import { prepareContractCall, toWei } from 'thirdweb';\n\nconst tx = prepareContractCall({\n  contract,\n  // Pass the method signature that you want to call\n  method: 'function mintTo(address to, uint256 amount)',\n  // Pass the params for that method.\n  // Their types are automatically inferred based on the method signature\n  params: ['0x123...', toWei('100')],\n});\n</code></pre> <p>Returning to our incrementer contract, preparing a call to increment the contract looks like the following:</p> <pre><code>import { prepareContractCall } from 'thirdweb';\n\nconst tx = prepareContractCall({\n  contract,\n  // Pass the method signature that you want to call\n  method: 'function increment()',\n  // Increment takes no params so we are leaving an empty array\n  params: [],\n});\n</code></pre>"},{"location":"builders/ethereum/dev-env/thirdweb/#preparing-raw-transactions","title":"Preparing Raw Transactions","text":"<p>You can also prepare a transaction directly with encoded data. To do so, you'll use thirdweb's <code>prepareTransaction</code> method and specify the <code>to</code>, <code>value</code>, <code>chain</code>, and <code>client</code> values directly. </p> <pre><code>import { prepareTransaction, toWei } from 'thirdweb';\n\nconst transaction = prepareTransaction({\n  // The account that will be the receiver\n  to: '0x456...',\n  // The value is the amount of ether you want to send with the transaction\n  value: toWei('1'),\n  // The chain to execute the transaction on. This assumes you already set up\n  // moonbase as a custom chain as shown in the configure chain section\n  chain: moonbase,\n  // Your thirdweb client\n  client,\n});\n</code></pre>"},{"location":"builders/ethereum/dev-env/thirdweb/#read-contract-state","title":"Reading Contract State","text":"<p>Use the <code>readContract</code> function to call any read functions on your contract by passing in the Solidity method signature and any parameters.</p> <pre><code>import { readContract } from 'thirdweb';\n\nconst balance = await readContract({\n  contract: contract,\n  method: 'function balanceOf(address) view returns (uint256)',\n  params: ['0x123...'],\n});\n</code></pre> <p>For a function that takes no parameters, such as the number function that returns the current number stored in the incrementer contract, you simply need to provide the function name as follows: </p> <pre><code>import { readContract } from 'thirdweb';\n\nconst number = await readContract({\n  contract: contract,\n  method: 'number',\n  params: [],\n});\n</code></pre> <p>Did you know? With the thirdweb CLI, you can easily and generate functions for all of the possible calls to a contract. To do so, run the following command in the command line: </p> <pre><code>npx thirdweb generate INSERT_CHAIN_ID/INSERT_CONTRACT_ADDRESS\n</code></pre> <p>Both the chain ID and the contract address are required. As an example, if you wanted to generate the functions for the incrementer contract on Moonbase Alpha , you would use the following command:</p> <pre><code>npx thirdweb generate 1287/0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8\n</code></pre> <p>The file generated with all of the corresponding methods will be placed in a directory labelled <code>thirdweb/CHAIN_ID/CONTRACT_ADDRESS</code>. In the example shown above, the output file is located at <code>thirdweb/1287/0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8.ts</code>. For more information, see the thirdweb's docs on the CLI.</p>"},{"location":"builders/ethereum/dev-env/thirdweb/#sending-a-transaction","title":"Sending a Transaction","text":"<p>Every transaction sent using the SDK must first be prepared. This preparation process is synchronous and lightweight, requiring no network requests. Additionally, it provides type-safe definitions for your contract calls.</p> <p>You can prepare a transaction as follows:</p> Prepare a transaction<pre><code>import { prepareTransaction, toWei } from 'thirdweb';\n\nconst transaction = prepareTransaction({\n  to: '0x1234567890123456789012345678901234567890',\n  chain: moonbase,\n  client: thirdwebClient,\n  value: toWei('1.0'),\n  gasPrice: 150n,\n});\n</code></pre> <p>After the transaction is prepared, you can send it as follows:</p> Send a transaction<pre><code>import { sendTransaction } from 'thirdweb';\n\nconst { transactionHash } = await sendTransaction({\n  account,\n  transaction,\n});\n</code></pre> <p>You can optionally use <code>sendAndConfirmTransaction</code> to wait for the transaction to be mined. This is relevant if you want to block the user from continuing until the transaction is confirmed. </p> Send and Confirm a Transaction<pre><code>import { sendAndConfirmTransaction } from 'thirdweb';\nimport { createWallet } from 'thirdweb/wallets';\n\nconst wallet = createWallet('io.metamask');\nconst account = await wallet.connect({ client });\n\nconst receipt = await sendAndConfirmTransaction({\n  transaction,\n  account,\n});\n</code></pre>"},{"location":"builders/ethereum/dev-env/thirdweb/#transaction-utilities","title":"Transaction Utilities","text":"<p>thirdweb provides a number of helpful utility methods surrounding preparing and sending transactions. </p> <p>You can estimate the gas used by a transaction as follows: </p> Estimating gas<pre><code>import { estimateGas } from 'thirdweb';\n\nconst gasEstimate = await estimateGas({ transaction });\nconsole.log('estmated gas used', gasEstimate);\n</code></pre> <p>You can estimate the gas cost in Ether and Wei as follows: </p> Estimating gas cost<pre><code>import { estimateGas } from 'thirdweb';\n\nconst gasCost = await estimateGasCost({ transaction });\nconsole.log('cost in ether', gasCost.ether);\n</code></pre> <p>thirdweb also provides a handy way to simulate transactions and verify their integrity before actually submitting it to the blockchain. You can simulate a transaction as follows:</p> Simulate a transaction<pre><code>import { simulateTransaction } from 'thirdweb';\n\nconst result = await simulateTransaction({ transaction });\nconsole.log('simulation result', result);\n</code></pre> <p>You can encode transaction data to act on later by taking the following steps: </p> Encode transaction data<pre><code>import { encode } from 'thirdweb';\n\nconst data = await encode(transaction);\nconsole.log('encoded data', data);\n</code></pre>"},{"location":"builders/ethereum/dev-env/thirdweb/#connect-button","title":"ConnectButton","text":"<p>Perhaps the first and most important interaction users will have with your dApp is connecting their wallet. thirdweb provides an easy and highly customizable way for you to enable this. thirdweb provides a highly customizable <code>ConnectButton</code> to tailor it to your desired wallets. The <code>ConnectButton</code> accepts an optional <code>wallets</code> parameter with an array of wallets. You can add or remove wallets from the <code>wallets</code> array to change the options available to users. thirdweb also offers a <code>ConnectButton</code> Playground to customize and view changes for the <code>ConnectButton</code> in real-time, given the button's high degree of flexibility.</p> ConnectButton<pre><code>import { ConnectButton } from 'thirdweb/react';\nimport { createWallet, inAppWallet } from 'thirdweb/wallets';\n\nconst wallets = [\n  inAppWallet(),\n  createWallet('io.metamask'),\n  createWallet('com.coinbase.wallet'),\n  createWallet('me.rainbow'),\n];\n\nfunction Example() {\n  return (\n    &lt;div&gt;\n      &lt;ConnectButton client={client} wallets={wallets} /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"builders/ethereum/dev-env/thirdweb/#deploy-application","title":"Deploy Application","text":"<p>As a reminder, you can build your example project locally by running:</p> <pre><code>yarn dev\n</code></pre> <p>To host your static web application on decentralized storage, run:</p> <pre><code>npx thirdweb deploy --app\n</code></pre> <p>By running this command, your application is built for production and stored using Storage, thirdweb's decentralized file management solution. The built application is uploaded to IPFS, a decentralized storage network, and a unique URL is generated for your application. This URL serves as a permanent hosting location for your application on the web.</p> <p>If you have any further questions or encounter any issues during the process, please reach out to thirdweb support at support.thirdweb.com.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/dev-env/waffle-mars/","title":"Using Waffle &amp; Mars to Deploy to Moonbeam","text":""},{"location":"builders/ethereum/dev-env/waffle-mars/#introduction","title":"Introduction","text":"<p>Waffle is a library for compiling and testing smart contracts, and Mars is a deployment manager. Together, Waffle and Mars can be used to write, compile, test, and deploy Ethereum smart contracts. Since Moonbeam is Ethereum compatible, Waffle and Mars can be used to deploy smart contracts to a Moonbeam development node or the Moonbase Alpha TestNet.</p> <p>Waffle uses minimal dependencies, has syntax that is easy to learn and extend, and provides fast execution times when compiling and testing smart contracts. Furthermore, it is TypeScript compatible and uses Chai matchers to make tests easy to read and write.</p> <p>Mars provides a simple, TypeScript compatible framework for creating advanced deployment scripts and staying in sync with state changes. Mars focuses on infrastructure-as-code, allowing developers to specify how their smart contracts should be deployed and then using those specifications to automatically handle state changes and deployments.</p> <p>In this guide, you'll be creating a TypeScript project to write, compile, and test a smart contract using Waffle, then deploy it on to the Moonbase Alpha TestNet using Mars.</p>"},{"location":"builders/ethereum/dev-env/waffle-mars/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>You will need to have the following:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul> <p>Once you've created an account you'll need to export the private key to be used in this guide.</p>"},{"location":"builders/ethereum/dev-env/waffle-mars/#create-a-typescript-project-with-waffle-mars","title":"Create a TypeScript Project with Waffle &amp; Mars","text":"<p>To get started, you'll create a TypeScript project and install and configure a few dependencies.</p> <ol> <li> <p>Create the project directory and change to it:</p> <pre><code>mkdir waffle-mars &amp;&amp; cd waffle-mars\n</code></pre> </li> <li> <p>Initialize the project. Which will create a <code>package.json</code> in the directory:</p> <pre><code>npm init -y\n</code></pre> </li> <li> <p>Install the following dependencies:</p> <pre><code>npm install ethereum-waffle ethereum-mars ethers \\\n@openzeppelin/contracts typescript ts-node chai \\\n@types/chai mocha @types/mocha\n</code></pre> <ul> <li>Waffle - for writing, compiling, and testing smart contracts</li> <li>Mars - for deploying smart contracts to Moonbeam</li> <li>Ethers - for interacting with Moonbeam's Ethereum API</li> <li>OpenZeppelin Contracts - the contract you'll be creating will use OpenZeppelin's ERC-20 base implementation</li> <li>TypeScript - the project will be a TypeScript project</li> <li>TS Node - for executing the deployment script you'll create later in this guide</li> <li>Chai - an assertion library used alongside Waffle for writing tests</li> <li>@types/chai - contains the type definitions for chai</li> <li>Mocha - a testing framework for writing tests alongside Waffle</li> <li>@types/mocha - contains the type definitions for mocha</li> </ul> </li> <li> <p>Create a TypeScript configuration file:</p> <pre><code>touch tsconfig.json\n</code></pre> </li> <li> <p>Add a basic TypeScript configuration:</p> <pre><code>{\n    \"compilerOptions\": {\n        \"strict\": true,\n        \"target\": \"ES2019\",\n        \"moduleResolution\": \"node\",\n        \"resolveJsonModule\": true,\n        \"esModuleInterop\": true,\n        \"module\": \"CommonJS\",\n        \"composite\": true,\n        \"sourceMap\": true,\n        \"declaration\": true,\n        \"noEmit\": true\n    }\n}\n</code></pre> </li> </ol> <p>Now, you should have a basic TypeScript project with the necessary dependencies to get started building with Waffle and Mars.</p>"},{"location":"builders/ethereum/dev-env/waffle-mars/#add-a-contract","title":"Add a Contract","text":"<p>For this guide, you will create an ERC-20 contract that mints a specified amount of tokens to the contract creator. It's based on the OpenZeppelin ERC-20 template.</p> <ol> <li> <p>Create a directory to store your contracts and a file for the smart contract:</p> <pre><code>mkdir contracts &amp;&amp; cd contracts &amp;&amp; touch MyToken.sol\n</code></pre> </li> <li> <p>Add the following contract to <code>MyToken.sol</code>:</p> <pre><code>pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor() ERC20(\"MyToken\", \"MYTOK\") {}\n\n    function initialize(uint initialSupply) public {\n      _mint(msg.sender, initialSupply);\n    }\n}\n</code></pre> </li> </ol> <p>In this contract, you are creating an ERC-20 token called MyToken with the symbol MYTOK, that allows you, as the contract creator, to mint as many MYTOKs as desired.</p>"},{"location":"builders/ethereum/dev-env/waffle-mars/#use-waffle-to-compile-and-test","title":"Use Waffle to Compile and Test","text":""},{"location":"builders/ethereum/dev-env/waffle-mars/#compile-with-waffle","title":"Compile with Waffle","text":"<p>Now that you have written a smart contract, the next step is to use Waffle to compile it. Before diving into compiling your contract, you will need to configure Waffle:</p> <ol> <li> <p>Go back to the root project directory and create a <code>waffle.json</code> file to configure Waffle:</p> <pre><code>cd .. &amp;&amp; touch waffle.json\n</code></pre> </li> <li> <p>Edit the <code>waffle.json</code> to specify compiler configurations, the directory containing your contracts, and more. For this example, we'll use <code>solcjs</code> and the Solidity version you used for the contract, which is <code>0.8.0</code>:</p> <pre><code>{\n    \"compilerType\": \"solcjs\",\n    \"compilerVersion\": \"0.8.0\",\n    \"compilerOptions\": {\n        \"optimizer\": {\n            \"enabled\": true,\n            \"runs\": 20000\n        }\n    },\n    \"sourceDirectory\": \"./contracts\",\n    \"outputDirectory\": \"./build\",\n    \"typechainEnabled\": true\n}\n</code></pre> </li> <li> <p>Add a script to run Waffle in the <code>package.json</code>:</p> <pre><code>\"scripts\": {\n    \"build\": \"waffle\"\n},\n</code></pre> </li> </ol> <p>That is all you need to do to configure Waffle, now you're all set to compile the <code>MyToken</code> contract using the <code>build</code> script:</p> <pre><code>npm run build\n</code></pre> npm run build &gt;\ufeff\ufeffwaffle-mars@1.0.0 build &gt;\ufeff\ufeffwaffle Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: \u00abSPDX-License&gt;\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information. --&gt; contracts/MyToken.sol <p>After compiling your contracts, Waffle stores the JSON output in the <code>build</code> directory. Since the contract in this guide is based on OpenZeppelin's ERC-20 template, relevant ERC-20 JSON files will appear in the <code>build</code> directory too.</p>"},{"location":"builders/ethereum/dev-env/waffle-mars/#test-with-waffle","title":"Test with Waffle","text":"<p>Before deploying your contract and sending it off into the wild, you should test it first. Waffle provides an advanced testing framework and has plenty of tools to help you with testing.</p> <p>You'll be running tests against the Moonbase Alpha TestNet and will need the corresponding RPC URL to connect to it: <code>https://rpc.api.moonbase.moonbeam.network</code>.</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>Since you will be running tests against the TestNet, it might take a couple minutes to run all of the tests. If you want a more efficient testing experience, you can spin up a Moonbeam development node using <code>instant seal</code>. Running a local Moonbeam development node with the <code>instant seal</code> feature is similar to the quick and iterative experience you would get with Hardhat Network.</p> <ol> <li> <p>Create a directory to contain your tests and a file to test your <code>MyToken</code> contract:</p> <pre><code>mkdir test &amp;&amp; cd test &amp;&amp; touch MyToken.test.ts\n</code></pre> </li> <li> <p>Open the <code>MyToken.test.ts</code> file and setup your test file to use Waffle's Solidity plugin and use Ethers custom JSON-RPC provider to connect to Moonbase Alpha:</p> <pre><code>import { use, expect } from 'chai';\nimport { Provider } from '@ethersproject/providers';\nimport { solidity } from 'ethereum-waffle';\nimport { ethers, Wallet } from 'ethers';\nimport { MyToken, MyTokenFactory } from '../build/types';\n\n// Tell Chai to use Waffle's Solidity plugin\nuse(solidity);\n\ndescribe ('MyToken', () =&gt; {\n  // Use custom provider to connect to Moonbase Alpha\n  let provider: Provider = new ethers.providers.JsonRpcProvider(\n    'https://rpc.api.moonbase.moonbeam.network'\n  );\n  let wallet: Wallet;\n  let walletTo: Wallet;\n  let token: MyToken;\n\n  beforeEach(async () =&gt; {\n    // Logic for setting up the wallet and deploying MyToken will go here\n  });\n\n  // Tests will go here\n})\n</code></pre> </li> <li> <p>Before each test is run, you'll want to create wallets and connect them to the provider, use the wallets to deploy an instance of the <code>MyToken</code> contract, and then call the <code>initialize</code> function once with an initial supply of 10 tokens:</p> <pre><code>  beforeEach(async () =&gt; {\n    // This is for demo purposes only. Never store your private key in a JavaScript/TypeScript file\n    const privateKey = 'INSERT_PRIVATE_KEY'\n    // Create a wallet instance using your private key &amp; connect it to the provider\n    wallet = new Wallet(privateKey).connect(provider);\n\n    // Create a random account to transfer tokens to &amp; connect it to the provider\n    walletTo = Wallet.createRandom().connect(provider);\n\n    // Use your wallet to deploy the MyToken contract\n    token = await new MyTokenFactory(wallet).deploy();\n\n    // Mint 10 tokens to the contract owner, which is you\n    let contractTransaction = await token.initialize(10);\n\n    // Wait until the transaction is confirmed before running tests\n    await contractTransaction.wait();\n  });\n</code></pre> </li> <li> <p>Now you can create your first test. The first test will check your initial balance to ensure you received the initial supply of 10 tokens. However, to follow good testing practices, write a failing test first:</p> <pre><code>it('Mints the correct initial balance', async () =&gt; {\n  expect(await token.balanceOf(wallet.address)).to.equal(1); // This should fail\n});\n</code></pre> </li> <li> <p>Before you can run your first test, you'll need to go back to the root direction and add a <code>.mocharc.json</code> Mocha configuration file:</p> <pre><code>cd .. &amp;&amp; touch .mocharc.json\n</code></pre> </li> <li> <p>Now edit the <code>.mocharc.json</code> file to configure Mocha:</p> <pre><code>{\n    \"require\": \"ts-node/register/transpile-only\",\n    \"timeout\": 600000,\n    \"extension\": \"test.ts\"\n}\n</code></pre> </li> <li> <p>You'll also need to add a script in the <code>package.json</code> to run your tests:</p> <pre><code>\"scripts\": {\n    \"build\": \"waffle\",\n    \"test\": \"mocha\"\n},\n</code></pre> </li> <li> <p>You're all set to run the tests, simply use the <code>test</code> script you just created and run:</p> <pre><code>npm run test\n</code></pre> <p>Please note that it could take a few minutes to process because the tests are running against Moonbase Alpha, but if all worked as expected, you should have one failing test.</p> </li> <li> <p>Next, you can go back and edit the test to check for 10 tokens:</p> <pre><code>it('Mints the correct initial balance', async () =&gt; {\n  expect(await token.balanceOf(wallet.address)).to.equal(10); // This should pass\n});\n</code></pre> </li> <li> <p>If you run the tests again, you should now see one passing test:</p> <pre><code>npm run test\n</code></pre> </li> <li> <p>You've tested the ability to mint tokens, next you'll test the ability to transfer the minted tokens. If you want to write a failing test first again that is up to, however the final test should look like this:</p> <pre><code>it('Should transfer the correct amount of tokens to the destination account', async () =&gt; {\n  // Send the destination wallet 7 tokens\n  await (await token.transfer(walletTo.address, 7)).wait();\n\n  // Expect the destination wallet to have received the 7 tokens\n  expect(await token.balanceOf(walletTo.address)).to.equal(7);\n});\n</code></pre> </li> </ol> <p>Congratulations, you should now have two passing tests! Altogether, your test file should look like this:</p> <pre><code>import { use, expect } from 'chai';\nimport { Provider } from '@ethersproject/providers';\nimport { solidity } from 'ethereum-waffle';\nimport { ethers, Wallet } from 'ethers';\nimport { MyToken, MyTokenFactory } from '../build/types';\n\nuse(solidity);\n\ndescribe('MyToken', () =&gt; {\n  let provider: Provider = new ethers.providers.JsonRpcProvider(\n    'https://rpc.api.moonbase.moonbeam.network'\n  );\n  let wallet: Wallet;\n  let walletTo: Wallet;\n  let token: MyToken;\n\n  beforeEach(async () =&gt; {\n    // For demo purposes only. Never store your private key in a JavaScript/TypeScript file\n    const privateKey = 'INSERT_PRIVATE_KEY';\n    wallet = new Wallet(privateKey).connect(provider);\n    walletTo = Wallet.createRandom().connect(provider);\n    token = await new MyTokenFactory(wallet).deploy();\n    let contractTransaction = await token.initialize(10);\n    await contractTransaction.wait();\n  });\n\n  it('Mints the correct initial balance', async () =&gt; {\n    expect(await token.balanceOf(wallet.address)).to.equal(10);\n  });\n\n  it('Should transfer the correct amount of tokens to the destination account', async () =&gt; {\n    await (await token.transfer(walletTo.address, 7)).wait();\n    expect(await token.balanceOf(walletTo.address)).to.equal(7);\n  });\n});\n</code></pre> <p>If you want to write more tests on your own, you could consider testing transfers from accounts without any funds or transfers from accounts without enough funds.</p>"},{"location":"builders/ethereum/dev-env/waffle-mars/#use-mars-to-deploy-to-moonbase-alpha","title":"Use Mars to Deploy to Moonbase Alpha","text":"<p>After you compile your contracts and before deployment, you will have to generate contract artifacts for Mars. Mars uses the contract artifacts for typechecks in deployments. Then you'll need to create a deployment script and deploy the <code>MyToken</code> smart contract.</p> <p>Remember, you will be deploying to Moonbase Alpha and will need to use the TestNet RPC URL:</p> <pre><code>https://rpc.api.moonbase.moonbeam.network\n</code></pre> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>The deployment will be broken up into three sections: generate artifacts, create a deployment script, and deploy with Mars.</p>"},{"location":"builders/ethereum/dev-env/waffle-mars/#generate-artifacts","title":"Generate Artifacts","text":"<p>Artifacts need to be generated for Mars so that typechecks are enabled within deployment scripts.</p> <ol> <li> <p>Update existing script to run Waffle in the <code>package.json</code> to include Mars:</p> <pre><code>\"scripts\": {\n    \"build\": \"waffle &amp;&amp; mars\",\n    \"test\": \"mocha\"\n},\n</code></pre> </li> <li> <p>Generate the artifacts and create the <code>artifacts.ts</code> file needed for deployments:</p> <pre><code>npm run build\n</code></pre> </li> </ol> npm run build  &gt; waffle-mars@1.0.0 build  &gt; waffle &amp;&amp; mars Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: \" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information. --&gt; contracts/MyToken.sol <p>If you open the <code>build</code> directory, you should now see an <code>artifacts.ts</code> file containing the artifact data needed for deployments. To continue on with the deployment process, you'll need to write a deployment script. The deployment script will be used to tell Mars which contract to deploy, to what network, and which account is to be used to trigger the deployment.</p>"},{"location":"builders/ethereum/dev-env/waffle-mars/#create-a-deployment-script","title":"Create a Deployment Script","text":"<p>Now you need to configure the deployment for the <code>MyToken</code> contract to the Moonbase Alpha TestNet.</p> <p>In this step, you'll create the deployment script which will define how the contract should be deployed. Mars offers a <code>deploy</code> function that you can pass options to such as the private key of the account to deploy the contract, the network to deploy to, and more. Inside of the <code>deploy</code> function is where the contracts to be deployed are defined. Mars has a <code>contract</code> function that accepts the <code>name</code>, <code>artifact</code>, and <code>constructorArgs</code>. This function will be used to deploy the <code>MyToken</code> contract with an initial supply of 10 MYTOKs.</p> <ol> <li> <p>Create a <code>src</code> directory to contain your deployment scripts and create the script to deploy the <code>MyToken</code> contract:</p> <pre><code>mkdir src &amp;&amp; cd src &amp;&amp; touch deploy.ts\n</code></pre> </li> <li> <p>In <code>deploy.ts</code>, use Mars' <code>deploy</code> function to create a script to deploy to Moonbase Alpha using your account's private key:</p> <pre><code>import { deploy } from 'ethereum-mars';\n\n// For demo purposes only. Never store your private key in a JavaScript/TypeScript file\nconst privateKey = 'INSERT_PRIVATE_KEY';\ndeploy(\n  { network: 'https://rpc.api.moonbase.moonbeam.network', privateKey },\n  (deployer) =&gt; {\n    // Deployment logic will go here\n  }\n);\n</code></pre> </li> <li> <p>Set up the <code>deploy</code> function to deploy the <code>MyToken</code> contract created in the previous steps:</p> <pre><code>import { deploy, contract } from 'ethereum-mars';\nimport { MyToken } from '../build/artifacts';\n\n// For demo purposes only. Never store your private key in a JavaScript/TypeScript file\nconst privateKey = 'INSERT_PRIVATE_KEY';\ndeploy({ network: 'https://rpc.api.moonbase.moonbeam.network', privateKey }, () =&gt; {\n  contract('myToken', MyToken);\n});\n</code></pre> </li> <li> <p>Add a deploy script to the <code>scripts</code> object in the <code>package.json</code>:</p> <pre><code>\"scripts\": {\n    \"build\": \"waffle &amp;&amp; mars\",\n    \"test\": \"mocha\",\n    \"deploy\": \"ts-node src/deploy.ts\"\n}\n</code></pre> </li> </ol> <p>So far, you should have created a deployment script in <code>deploy.ts</code> that will deploy the <code>MyToken</code> contract to Moonbase Alpha, and added the ability to easily call the script and deploy the contract.</p>"},{"location":"builders/ethereum/dev-env/waffle-mars/#deploy-with-mars","title":"Deploy with Mars","text":"<p>You've configured the deployment, now it's time to actually deploy to Moonbase Alpha.</p> <ol> <li> <p>Deploy the contract using the script you just created:</p> <pre><code>npm run deploy\n</code></pre> </li> <li> <p>In your Terminal, Mars will prompt you to press <code>ENTER</code> to send your transaction</p> <p> npm run deploy  &gt; waffle-mars@1.0.0 deploy  &gt; ts-node src/deploy.ts Transaction: Deploy myToken Fee: $0.00, \u039e0.0 Balance\uff1a $4142380208.17\uff0c\u039e1207925.819614629174706176 ENTER to submit, Ctrl+C to exit... </p> </li> </ol> <p>If successful, you should see details about your transaction including its hash, the block it was included in, and it's address.</p> npm run deploy  &gt; waffle-mars@1.0.0 deploy  &gt; ts-node src/deploy.ts Transaction: Deploy myToken Fee\uff1a $0.00\uff0c\u039e0.0 Balance: Sending Block: 1 $4142380208.17, \u039e1207925.819614629174706176 Hash: Oxfa8bcad89cb8efdabfc@e5575dbe7151ce1c38f8aa67229fd5122bbdafe8b2f9 Address: 0xC2Bf5F29a4384b1aB0C063e1c666f02121B6084a <p>Congratulations! You've deployed a contract to Moonbase Alpha using Waffle and Mars!</p>"},{"location":"builders/ethereum/dev-env/waffle-mars/#example-project","title":"Example Project","text":"<p>If you want to see a completed example of a Waffle and Mars project on Moonbeam, check out the moonbeam-waffle-mars-example created by the team behind Waffle and Mars, EthWorks.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/dev-env/openzeppelin/contracts/","title":"Using OpenZeppelin Contracts and Remix To Deploy To Moonbeam","text":""},{"location":"builders/ethereum/dev-env/openzeppelin/contracts/#introduction","title":"Introduction","text":"<p>OpenZeppelin contracts and libraries have become a standard in the industry. They help developers minimize risk, as their open-source code templates are battle-tested for Ethereum and other blockchains. Their code includes the most used implementations of ERC standards and add-ons and often appears in guides and tutorials around the community.</p> <p>Because Moonbeam is fully Ethereum compatible, all of OpenZeppelin's contracts and libraries can be implemented without any changes.</p> <p>This guide is divided into two sections. The first part describes the OpenZeppelin Contracts Wizard, a great online tool to help you create smart contracts using OpenZeppelin code. The second section provides a step-by-step guide on how you can deploy these contracts using Remix on Moonbeam.</p>"},{"location":"builders/ethereum/dev-env/openzeppelin/contracts/#openzeppelin-contract-wizard","title":"OpenZeppelin Contract Wizard","text":"<p>OpenZeppelin has developed an online web-based interactive contract generator tool that is probably the easiest and fastest way to write your smart contract using OpenZeppelin code, called Contracts Wizard.</p> In this video, Open Zeppelin Wizard is used to deploy an ERC-20 token to Moonbase Alpha <p>Currently, the Contracts Wizard support the following ERC standards:</p> <ul> <li>ERC-20 \u2014 a fungible token standard that follows EIP-20. Fungible means that all tokens are equivalent and interchangeable that is, of equal value. One typical example of fungible tokens is fiat currencies, where each equal-denomination bill has the same value</li> <li>ERC-721 \u2014 a non-fungible token contract that follows EIP-721. Non-fungible means that each token is different, and therefore, unique. An ERC-721 token can represent ownership of that unique item, whether it is a collectible item in a game, real estate, and so on</li> <li>ERC-1155 \u2014 also known as the multi-token contract, because it can represent both fungible and non-fungible tokens in a single smart contract. It follows EIP-1155</li> </ul> <p>The wizard is comprised of the following sections:</p> <ol> <li>Token standard selection \u2014 shows all the different standards supported by the wizard</li> <li>Settings \u2014 provides the baseline settings for each token standard, such as token name, symbol, pre-mint (token supply when the contract is deployed), and URI (for non-fungible tokens)</li> <li>Features \u2014 list of all features available for each token standard. You can find more information about the different features in the following links:<ul> <li>ERC-20</li> <li>ERC-721</li> <li>ERC-1155</li> </ul> </li> <li>Access Control \u2014 list of all the available access control mechanisms for each token standard</li> <li>Interactive code display \u2014 shows the smart contract code with the configuration as set by the user</li> </ol> <p></p> <p>Once you have set up your contract with all the settings and features, it is just as easy as copying and pasting the code into your contract file.</p>"},{"location":"builders/ethereum/dev-env/openzeppelin/contracts/#deploying-openzeppelin-contracts-on-moonbeam","title":"Deploying OpenZeppelin Contracts on Moonbeam","text":"<p>This section goes through the steps for deploying OpenZeppelin contracts on Moonbeam. It covers the following contracts:</p> <ul> <li>ERC-20 (fungible tokens)</li> <li>ERC-721 (non-fungible tokens)</li> <li>ERC-1155 (multi-token standard)</li> </ul> <p>All the code of the contracts was obtained using OpenZeppelin Contract Wizard.</p>"},{"location":"builders/ethereum/dev-env/openzeppelin/contracts/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The steps described in this section assume you have MetaMask installed and connected to the Moonbase Alpha TestNet. If you're adapting this guide for Moonbeam or Moonriver, make sure you're connected to the correct network. Contract deployment is done using the Remix IDE via the Injected Provider environment. You can find corresponding tutorials in the following links:</p> <ul> <li>Interacting with Moonbeam using MetaMask</li> <li>Interacting with Moonbeam using Remix</li> </ul>"},{"location":"builders/ethereum/dev-env/openzeppelin/contracts/#deploying-an-erc-20-token","title":"Deploying an ERC-20 Token","text":"<p>For this example, an ERC-20 token will be deployed to Moonbase Alpha. The final code used combines different contracts from OpenZeppelin:</p> <ul> <li><code>ERC20.sol</code> \u2014 ERC-20 token implementation with the optional features from the base interface. Includes the supply mechanism with a <code>mint</code> function but needs to be explicitly called from within the main contract</li> <li><code>Ownable.sol</code> \u2014 extension to restrict access to certain functions</li> </ul> <p>The mintable ERC-20 OpenZeppelin token contract provides a <code>mint</code> function that the owner of the contract can only call. By default, the owner is the contract's deployer address. There is also a premint of <code>1000</code> tokens sent to the contract's deployer configured in the <code>constructor</code> function.</p> <p>The first step is to go to Remix and take the following steps:</p> <ol> <li>Click on the Create New File icon and set a file name. For this example, it was set to <code>ERC20.sol</code></li> <li>Make sure the file was created successfully. Click on the file to open it up in the text editor</li> <li>Write your smart contract using the file editor. For this example, the following code was used:</li> </ol> <pre><code>// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.0.0\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\ncontract MyToken is ERC20, Ownable, ERC20Permit {\n    constructor(address initialOwner)\n        ERC20(\"MyToken\", \"MTK\")\n        Ownable(initialOwner)\n        ERC20Permit(\"MyToken\")\n    {\n        _mint(msg.sender, 1000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n</code></pre> <p>This ERC-20 token smart contract was extracted from the Contract Wizard, setting a premint of <code>1000</code> tokens and activating the <code>Mintable</code> and <code>Permit</code> features.</p> <p></p> <p>Once your smart contract is written, you can compile it by taking the following steps:</p> <ol> <li>Head to the Solidity Compiler</li> <li>Click on the compile button</li> <li>Alternatively, you can check the Auto compile feature</li> </ol> <p></p> <p>With the contract compiled, you are ready to deploy it taking the following steps:</p> <ol> <li>Head to the Deploy &amp; Run Transactions tab</li> <li>Change the environment to Injected Provider. This will use MetaMask's injected provider. Consequently, the contract will be deployed to whatever network MetaMask is connected to. MetaMask might show a pop-up outlining that Remix is trying to connect to your wallet</li> <li>Select the proper contract to deploy. In this example, it is the <code>MyToken</code> contract inside the <code>ERC20.sol</code> file</li> <li>Enter the address of the initial owner and click on the Deploy button. Review the transaction information in MetaMask and confirm it</li> <li>After a few seconds, the transaction should get confirmed, and you should see your contract under Deployed Contracts</li> </ol> <p></p> <p>And that is it! You've deployed an ERC-20 token contract using OpenZeppelin's contracts and libraries. Next, you can interact with your token contract via Remix, or add it to MetaMask.</p>"},{"location":"builders/ethereum/dev-env/openzeppelin/contracts/#deploying-an-erc-721-token","title":"Deploying an ERC-721 Token","text":"<p>For this example, an ERC-721 token will be deployed to Moonbase Alpha. The final code used combines different contracts from OpenZeppelin:</p> <ul> <li><code>ERC721.sol</code> \u2014 ERC-721 token implementation with the optional features from the base interface. Includes the supply mechanism with a <code>_mint</code> function but needs to be explicitly called from within the main contract</li> <li><code>ERC721Burnable.sol</code> \u2014 extension to allow tokens to be destroyed by their owners (or approved addresses)</li> <li><code>ERC721Enumerable.sol</code> \u2014 extension to allow on-chain enumeration of tokens</li> <li><code>Ownable.sol</code> \u2014 extension to restrict access to certain functions</li> </ul> <p>The mintable ERC-721 OpenZeppelin token contract provides a <code>mint</code> function that can only be called by the owner of the contract. By default, the owner is the contract's deployer address.</p> <p>As with the ERC-20 contract, the first step is to go to Remix and create a new file. For this example, the file name will be <code>ERC721.sol</code>.</p> <p>Next, you'll need to write the smart contract and compile it. For this example, the following code is used:</p> <pre><code>// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.0.0\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyToken is ERC721, ERC721Enumerable, ERC721Burnable, Ownable {\n    constructor(address initialOwner)\n        ERC721(\"MyToken\", \"MTK\")\n        Ownable(initialOwner)\n    {}\n\n    function _baseURI() internal pure override returns (string memory) {\n        return \"Test\";\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n\n    // The following functions are overrides required by Solidity\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        override(ERC721, ERC721Enumerable)\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n\n    function _increaseBalance(address account, uint128 value)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._increaseBalance(account, value);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n</code></pre> <p>This ERC-721 token smart contract was extracted from the Contract Wizard, setting the <code>Base URI</code> as <code>Test</code> and activating the <code>Mintable</code>, <code>Burnable</code>, and <code>Enumerable</code> features.</p> <p>With the contract compiled, next you will need to:</p> <ol> <li>Head to the Deploy &amp; Run Transactions tab</li> <li>Change the environment to Injected Provider. This will use MetaMask's injected provider. Consequently, the contract will be deployed to whatever network MetaMask is connected to. MetaMask might show a pop-up outlining that Remix is trying to connect to your wallet</li> <li>Select the proper contract to deploy. In this example, it is the <code>MyToken</code> contract inside the <code>ERC721.sol</code> file</li> <li>Enter the address of the initial owner and click on the Deploy button. Review the transaction information in MetaMask and confirm it</li> <li>After a few seconds, the transaction should get confirmed, and you should see your contract under Deployed Contracts</li> </ol> <p></p> <p>And that is it! You've deployed an ERC-721 token contract using OpenZeppelin's contracts and libraries. Next, you can interact with your token contract via Remix, or add it to MetaMask.</p>"},{"location":"builders/ethereum/dev-env/openzeppelin/contracts/#deploying-an-erc-1155-token","title":"Deploying an ERC-1155 Token","text":"<p>For this example, an ERC-1155 token will be deployed to Moonbase Alpha. The final code used combines different contracts from OpenZeppelin:</p> <ul> <li><code>ERC1155.sol</code> \u2014 ERC-1155 token implementation with the optional features from the base interface. Includes the supply mechanism with a <code>_mint</code> function but needs to be explicitly called from within the main contract</li> <li><code>Pausable.sol</code> \u2014 extension to allows pausing tokens transfer, mintings and burnings</li> <li><code>Ownable.sol</code> \u2014 extension to restrict access to certain functions</li> </ul> <p>OpenZeppelin's ERC-1155 token contract provides a <code>_mint</code> function that can only be called in the <code>constructor</code> function. Therefore, this example creates 1000 tokens with an ID of <code>0</code>, and 1 unique token with an ID of <code>1</code>.</p> <p>The first step is to go to Remix and create a new file. For this example, the file name will be <code>ERC1155.sol</code>.</p> <p>As shown for the ERC-20 token, you'll need to write the smart contract and compile it. For this example, the following code is used:</p> <pre><code>// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.0.0\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Pausable.sol\";\n\ncontract MyToken is ERC1155, Ownable, ERC1155Pausable {\n    constructor() ERC1155(\"\") Ownable() {\n        _mint(msg.sender, 0, 1000 * 10 ** 18, \"\");\n        _mint(msg.sender, 1, 1, \"\");\n    }\n\n    function setURI(string memory newuri) public onlyOwner {\n        _setURI(newuri);\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    // The following function is an override required by Solidity\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values)\n        internal\n        override(ERC1155, ERC1155Pausable)\n    {\n        super._update(from, to, ids, values);\n    }\n}\n</code></pre> <p>This ERC-1155 token smart contract was extracted from the Contract Wizard, setting no <code>Base URI</code> and activating <code>Pausable</code> feature. The constructor function was modified to include the minting of both a fungible and a non-fungible token.</p> <p>With the contract compiled, next you will need to:</p> <ol> <li>Head to the Deploy &amp; Run Transactions tab</li> <li>Change the environment to Injected Provider. This will use MetaMask's injected provider. Consequently, the contract will be deployed to whatever network MetaMask is connected to. MetaMask might show a pop-up outlining that Remix is trying to connect to your wallet</li> <li>Select the proper contract to deploy. In this example, it is the <code>MyToken</code> contract inside the <code>ERC1155.sol</code> file</li> <li>Enter the address of the initial owner and click on the Deploy button. Review the transaction information in MetaMask and confirm it</li> <li>After a few seconds, the transaction should get confirmed, and you should see your contract under Deployed Contracts</li> </ol> <p></p> <p>And that is it! You've deployed an ERC-1155 token contract using OpenZeppelin's contracts and libraries. Next, you can interact with your token contract via Remix.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/dev-env/openzeppelin/overview/","title":"OpenZeppelin","text":""},{"location":"builders/ethereum/dev-env/openzeppelin/overview/#introduction","title":"Introduction","text":"<p>OpenZeppelin is well known in the Ethereum developer community as their set of audited smart contracts and libraries are a standard in the industry. For example, most of the tutorials that show developers how to deploy an ERC-20 token use OpenZeppelin contracts.</p> <p>You can find more information about OpenZeppelin on their documentation site.</p> <p>As part of its Ethereum compatibility features, OpenZeppelin products can be seamlessly used on Moonbeam. This page will provide information on different OpenZeppelin solutions that you can test.</p>"},{"location":"builders/ethereum/dev-env/openzeppelin/overview/#openzeppelin-on-moonbeam","title":"OpenZeppelin on Moonbeam","text":"<p>Currently, the following OpenZeppelin products/solutions work on the different networks available on Moonbeam:</p> Product Moonbeam Moonriver Moonbase Alpha Moonbase Dev Node Contracts &amp; libraries \u2713 \u2713 \u2713 \u2713 Contracts Wizard \u2713 \u2713 \u2713 \u2713 <p>You will find a corresponding tutorial for each product in the following links:</p> <ul> <li>Contracts Wizard \u2014 where you'll find a guide on how to use OpenZeppelin web-based wizard to create different token contracts with different functionalities</li> <li>Contracts &amp; libraries \u2014 where you'll find tutorials to deploy the most common token contracts using OpenZeppelin's templates: ERC-20, ERC-721 and ERC-1155</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/json-rpc/debug-trace/","title":"Debug API &amp; Trace Module","text":""},{"location":"builders/ethereum/json-rpc/debug-trace/#introduction","title":"Introduction","text":"<p>Geth's debug and txpool APIs and OpenEthereum's trace module provide non-standard RPC methods for deeper insight into transaction processing. Some of these non-standard RPC methods are supported as part of Moonbeam's goal of providing a seamless Ethereum experience for developers. Supporting these RPC methods is an essential milestone because many projects like The Graph rely on them to index blockchain data.</p> <p>This guide will cover the supported RPC methods available on Moonbeam and how to invoke them using curl commands against a tracing node with the debug, txpool, and tracing flags enabled. You can access a tracing node in one of two ways: through a supported tracing RPC provider or by spinning up a tracing node of your own.</p> <p>To view a list of tracing RPC providers, please check out the Network Endpoints page.</p> <p>If you wish to set up your own tracing node, you can follow the Running a Tracing Node guide. The RPC HTTP endpoint of your tracing node should be at <code>http://127.0.0.1:9944</code> and your node should display similar logs to the following:</p> docker run --network host  \\     -u $(id -u ${USER}):$(id -g ${USER}) \\         moonbeamfoundation/moonbeam-tracing:v0.47.0-3900-b897 \\     --name=\"Moonbean-Tracing-Tutorial\" \\     --unsafe-rpc-external \\     --ethapi=debug,trace,txpool \\     --wasm-runtime-overrides=/moonbeam/moonbase-substitutes-tracing \\     --runtime-cache-size 64 \\     --dev     2025-07-10 09:04:26 Moonbeam Parachain Collator      2025-07-10 09:04:26 \u270c\ufe0f  version 0.47.0-d7df89e7161      2025-07-10 09:04:26 \u2764\ufe0f  by PureStake, 2019-2025      2025-07-10 09:04:26 \ud83d\udccb Chain specification: Moonbase Development Testnet      2025-07-10 09:04:26 \ud83c\udff7  Node name: Moonbean-Tracing-Tutorial      2025-07-10 09:04:26 \ud83d\udc64 Role: AUTHORITY      2025-07-10 09:04:26 \ud83d\udcbe Database: RocksDb at /tmp/substrateO3YeRz/chains/moonbase_dev/db/full      2025-07-10 09:04:26 Found wasm override. version=moonbase-300 (moonbase-0.tx2.au3) file=/moonbeam/moonbase-substitutes-tracing/moonbase-runtime-300-substitute-tracing.wasm      ...      2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0x18e6\u20262eb1), finalized #0 (0x18e6\u20262eb1), \u2b07 0 \u2b06 0"},{"location":"builders/ethereum/json-rpc/debug-trace/#supported-methods","title":"Supported Debug and Trace JSON-RPC Methods","text":"debug_traceTransaction <p>This method attempts to replay a transaction in the same manner as it was executed on the network. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <ul> <li><code>transaction_hash</code> string - the hash of the transaction to be traced</li> <li><code>tracer_config</code> string - (optional) a JSON object for configuring the tracer that contains the following field: <ul> <li><code>tracer</code> string - sets the type of tracer</li> </ul> </li> </ul> <p>If no <code>tracer_config</code> is provided, the opcode logger will be the default tracer. The opcode logger provides the following additional fields:</p> <ul> <li><code>opcode_config</code> string - (optional) a JSON object for configuring the opcode logger:<ul> <li><code>disableStorage</code> boolean \u2014 (optional, default: <code>false</code>) setting this to <code>true</code> disables storage capture</li> <li><code>disableMemory</code> boolean \u2014 (optional, default: <code>false</code>) setting this to <code>true</code> disables memory capture</li> <li><code>disableStack</code> boolean \u2014 (optional, default: <code>false</code>) setting this to <code>true</code> disables stack capture</li> </ul> </li> </ul> <p>If you supplied a <code>tracer_config</code>, the <code>result</code> object contains the following fields:</p> <ul> <li><code>type</code> - the type of the call</li> <li><code>from</code> - the address the transaction is sent from</li> <li><code>to</code> - the address the transaction is directed to</li> <li><code>value</code> - the integer of the value sent with this transaction</li> <li><code>gas</code> - the integer of the gas provided for the transaction execution</li> <li><code>gasUsed</code> - the integer of the gas used</li> <li><code>input</code> - the data given at the time of input</li> <li><code>output</code> - the data which is returned as an output</li> <li><code>error</code> - the type of error, if any</li> <li><code>revertReason</code> - the type solidity revert reason, if any</li> <li><code>calls</code> - a list of sub-calls, if any</li> </ul> <p> If you used the default opcode logger, the <code>result</code> object contains the following fields:</p> <ul> <li><code>gas</code>- the integer of the gas provided for the transaction execution</li> <li><code>returnValue</code> - the output produced by the execution of the transaction</li> <li><code>structLogs</code> - an array of objects containing a detailed log of each opcode executed during the transaction</li> <li><code>failed</code> - a boolean indicating whether the transaction execution failed or succeeded</li> </ul> <p>Using the <code>tracer_config</code>:</p> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n'{\n  \"jsonrpc\":\"2.0\",\n  \"id\": 1,\n  \"method\": \"debug_traceTransaction\",\n  \"params\": [\"INSERT_TRANSACTION_HASH\", {\"tracer\": \"callTracer\"}]\n}'\n</code></pre> <p> Using the default opcode logger:</p> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n'{\n  \"jsonrpc\":\"2.0\",\n  \"id\": 1,\n  \"method\": \"debug_traceTransaction\",\n  \"params\": [\"INSERT_TRANSACTION_HASH\"]\n}'\n</code></pre> debug_traceBlockByNumber <p>This method attempts to replay a block in the same manner as it was executed on the network. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <ul> <li><code>block_number</code> string - the block number of the block to be traced</li> <li><code>tracer_config</code> string - a JSON object for configuring the tracer that contains the following field: <ul> <li><code>tracer</code> string - sets the type of tracer. This must be set to <code>callTracer</code>, which only returns transactions and sub-calls. Otherwise, the tracer will attempt to default to the opcode logger, which is not supported at this time due to the heavy nature of the call</li> </ul> </li> </ul> <p>The method returns a JSON object with a top-level result property that is an array. Each element in this array corresponds to a single transaction in the block and includes a <code>txHash</code> and a <code>result</code> object as follows: </p> <ul> <li><code>txHash</code> - the transaction hash</li> </ul> <p>The <code>result</code> object contains the following fields:</p> <ul> <li><code>type</code> - the type of the call</li> <li><code>from</code> - the address the transaction is sent from</li> <li><code>to</code> - the address the transaction is directed to</li> <li><code>value</code> - the integer of the value sent with this transaction</li> <li><code>gas</code> - the integer of the gas provided for the transaction execution</li> <li><code>gasUsed</code> - the integer of the gas used</li> <li><code>input</code> - the data given at the time of input</li> <li><code>output</code> - the data which is returned as an output</li> <li><code>error</code> - the type of error, if any</li> <li><code>revertReason</code> - the type solidity revert reason, if any</li> <li><code>calls</code> - a list of sub-calls, if any</li> </ul> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"debug_traceBlockByNumber\",\n    \"params\": [\"INSERT_BLOCK_NUMBER\", {\"tracer\": \"callTracer\"}]\n  }'\n</code></pre> debug_traceBlockByHash <p>This method attempts to replay a block in the same manner as it was executed on the network. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <ul> <li><code>block_hash</code> string - the block hash of the block to be traced</li> <li><code>tracer_config</code> string - a JSON object for configuring the tracer that contains the following field: <ul> <li><code>tracer</code> string - sets the type of tracer. This must be set to <code>callTracer</code>, which only returns transactions and sub-calls. Otherwise, the tracer will attempt to default to the opcode logger, which is not supported at this time due to the heavy nature of the call</li> </ul> </li> </ul> <p>The method returns a JSON object with a top-level result property that is an array. Each element in this array corresponds to a single transaction in the block and includes a <code>txHash</code> and a <code>result</code> object as follows: </p> <ul> <li><code>txHash</code> - the transaction hash</li> </ul> <p>The <code>result</code> object contains the following fields:</p> <ul> <li><code>type</code> - the type of the call</li> <li><code>from</code> - the address the transaction is sent from</li> <li><code>to</code> - the address the transaction is directed to</li> <li><code>value</code> - the integer of the value sent with this transaction</li> <li><code>gas</code> - the integer of the gas provided for the transaction execution</li> <li><code>gasUsed</code> - the integer of the gas used</li> <li><code>input</code> - the data given at the time of input</li> <li><code>output</code> - the data which is returned as an output</li> <li><code>error</code> - the type of error, if any</li> <li><code>revertReason</code> - the type solidity revert reason, if any</li> <li><code>calls</code> - a list of sub-calls</li> </ul> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"debug_traceBlockByHash\",\n    \"params\": [\"INSERT_BLOCK_HASH\", {\"tracer\": \"callTracer\"}]\n  }'\n</code></pre> debug_traceCall <p>This method executes an eth_call within the context of the given block using the final state of the parent block as the base. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <ul> <li><code>call_object</code> object the transaction object to be executed</li> <li><code>block_hash</code> string - the block hash of the base block</li> </ul> <ul> <li><code>gas</code>- the integer of the gas provided for the transaction execution</li> <li><code>returnValue</code> - the output produced by the execution of the transaction</li> <li><code>structLogs</code> - an array of objects containing a detailed log of each opcode executed during the transaction</li> </ul> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"debug_traceCall\",\n    \"params\": [{\n        \"from\": \"INSERT_FROM_ADDRESS\",\n        \"to\":\"INSERT_TO_ADDRESS\",\n        \"data\":\"INSERT_CALL_DATA\"\n        }, \"INSERT_BLOCK_HASH\"]\n  }'\n</code></pre> trace_filter <p>This method returns matching traces for the given filters. Refer to Open Ethereum's documentation for more information.</p> ParametersReturnsExample <ul> <li><code>fromBlock</code> string \u2014 (optional) either block number (hex), <code>earliest</code>, which is the genesis block, or <code>latest</code> (default), which is the best block available. The trace starting block</li> <li><code>toBlock</code> string \u2014 (optional) either block number (hex), <code>earliest</code>, which is the genesis block, or <code>latest</code>, which is the best block available. The trace-ending block</li> <li><code>fromAddress</code> array \u2014 (optional) filter transactions from these addresses only. If an empty array is provided, no filtering is done with this field</li> <li><code>toAddress</code> array \u2014 (optional) filter transactions to these addresses only. If an empty array is provided, no filtering is done with this field</li> <li><code>after</code> uint \u2014 (optional) the default offset is <code>0</code>. The trace offset (or starting) number</li> <li><code>count</code> uint \u2014 (optional) number of traces to display in a batch</li> </ul> <p>There are a couple of default values that you should be aware of:</p> <ul> <li>The maximum number of trace entries a single request of <code>trace_filter</code> is allowed to return is <code>500</code>. A request exceeding this limit will return an error</li> <li>Blocks processed by requests are temporarily stored in the cache for <code>300</code> seconds, after which they are deleted</li> </ul> <p>You can configure additional flags when spinning up your tracing node to change the default values.</p> <p>The <code>result</code> array contains an array of objects for the block traces. All objects will contain the following fields:</p> <ul> <li><code>blockHash</code>- the hash of the block where this transaction was in</li> <li><code>blockNumber</code> - the block number where this transaction was in</li> <li><code>subtraces</code> - the traces of contract calls made by the transaction</li> <li><code>traceAddress</code> - the list of addresses where the call was executed, the address of the parents, and the order of the current sub-call</li> <li><code>transactionHash</code> - the hash of the transaction</li> <li><code>transactionPosition</code> - the transaction position</li> <li><code>type</code> - the value of the method, such as <code>call</code> or <code>create</code></li> </ul> <p> If the <code>type</code> of the transaction is a <code>call</code>, these additional fields will exist:</p> <ul> <li><code>action</code> - an object containing the call information:<ul> <li><code>from</code> - the address of the sender</li> <li><code>callType</code> - the type of method, such as <code>call</code> and <code>delegatecall</code></li> <li><code>gas</code> - the gas provided by the sender, encoded as hexadecimal</li> <li><code>input</code> - the data sent along with the transaction</li> <li><code>to</code> - the address of the receiver</li> <li><code>value</code> - the integer of the value sent with this transaction, encoded as hexadecimal</li> </ul> </li> <li><code>result</code> - an object containing the result of the transaction<ul> <li><code>gasUsed</code>- the amount of gas used by this specific transaction alone</li> <li><code>output</code>- the value returned by the contract call, and it only contains the actual value sent by the return method. If the return method was not executed, the output is empty bytes</li> </ul> </li> </ul> <p>If the <code>type</code> of the transaction is a <code>create</code>, these additional fields will exist:</p> <ul> <li><code>action</code> - an object containing information on the contract creation:<ul> <li><code>from</code> - the address of the sender</li> <li><code>creationMethod</code> - the creation method, such as <code>create</code></li> <li><code>gas</code> - the gas provided by the sender, encoded as hexadecimal</li> <li><code>init</code> - the initialization code of the contract</li> <li><code>value</code> - the integer of the value sent with this transaction, encoded as hexadecimal</li> </ul> </li> <li><code>result</code> - an object containing the result of the transaction<ul> <li><code>address</code> - the address of the contract</li> <li><code>code</code> - the bytecode of the contract</li> <li><code>gasUsed</code>- the amount of gas used by this specific transaction alone</li> </ul> </li> </ul> <p>This example starts with a zero offset and provides the first 20 traces:</p> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"trace_filter\", \"params\": \n    [{\n      \"fromBlock\": \"INSERT_FROM_BLOCK\",\n      \"toBlock\": \"INSERT_TO_BLOCK\",\n      \"toAddress\": [\"INSERT_ADDRESS_TO_FILTER\"],\n      \"after\": 0,\n      \"count\": 20\n    }]\n  }'\n</code></pre> txpool_content <p>Returns the details for all currently pending transactions waiting to be included in the next block(s) and all queued transactions for future execution. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <p>None</p> <p>The <code>result</code> object contains the following fields:</p> <ul> <li><code>pending</code> - an object containing the pending transaction details, which maps an address to a batch of scheduled transactions<ul> <li><code>address</code> - the address initiating a transaction, which maps the addresses' associating nonces with their transactions<ul> <li><code>nonce</code> - the nonce of the sending address<ul> <li><code>blockHash</code> - the hash of the block where this transaction was included. For pending transactions, this is an empty 32-byte string in hexadecimal format</li> <li><code>blockNumber</code> - the block number where this transaction was added encoded as a hexadecimal. For pending transactions, this is <code>null</code></li> <li><code>from</code> - the address of the sender</li> <li><code>gas</code> - the total amount of gas units used in the transaction</li> <li><code>gasPrice</code> - the total amount in Wei the sender is willing to pay for the transaction</li> <li><code>maxFeePerGas</code> - the maximum amount of gas willing to be paid for the transaction</li> <li><code>maxPriorityFeePerGas</code> - the maximum amount of gas to be included as a tip to the miner</li> <li><code>hash</code> - the hash of the transaction</li> <li><code>input</code> - the encoded transaction input data</li> <li><code>nonce</code> - the number of transactions the sender has sent till now</li> <li><code>to</code> - the address of the receiver. <code>null</code> when it's a contract creation transaction</li> <li><code>transactionIndex</code> - an integer of the transactions index position in the block encoded as a hexadecimal format. For pending transactions, this is <code>null</code></li> <li><code>value</code> - the value transferred in Wei encoded as a hexadecimal format</li> </ul> </li> </ul> </li> </ul> </li> <li><code>queued</code> - an object containing the queued transaction details, which maps an address to a batch of scheduled transactions<ul> <li><code>address</code> - the address initiating a transaction, which maps the addresses' associating nonces with their transactions<ul> <li><code>nonce</code> - the nonce of the sending address<ul> <li><code>blockHash</code> - the hash of the block where this transaction was included. For queued transactions, this is an empty 32-byte string in hexadecimal format</li> <li><code>blockNumber</code> - the block number where this transaction was added encoded as a hexadecimal. For queued transactions, this is <code>null</code></li> <li><code>from</code> - the address of the sender</li> <li><code>gas</code> - the total amount of gas units used in the transaction</li> <li><code>gasPrice</code> - the total amount in wei the sender is willing to pay for the transaction</li> <li><code>maxFeePerGas</code> - the maximum amount of gas willing to be paid for the transaction</li> <li><code>maxPriorityFeePerGas</code> - the maximum amount of gas to be included as a tip to the miner</li> <li><code>hash</code> - the hash of the transaction</li> <li><code>input</code> - the encoded transaction input data</li> <li><code>nonce</code> - the number of transactions the sender has sent till now</li> <li><code>to</code> - the address of the receiver. <code>null</code> when it's a contract creation transaction</li> <li><code>transactionIndex</code> - an integer of the transactions index position in the block encoded as a hexadecimal format. For queued transactions, this is <code>null</code></li> <li><code>value</code> - the value transferred in Wei encoded as a hexadecimal format</li> </ul> </li> </ul> </li> </ul> </li> </ul> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"txpool_content\", \"params\":[]\n  }'\n</code></pre> txpool_inspect <p>Returns a summary for all currently pending transactions waiting to be included in the next block(s) and all queued transactions for future execution. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <p>None</p> <p>The <code>result</code> object contains the following fields:</p> <ul> <li><code>pending</code> - an object containing the pending transaction summary strings, which maps an address to a batch of scheduled transactions<ul> <li><code>address</code> - the address initiating a transaction, which maps the addresses' associating nonces with their transaction summary strings</li> </ul> </li> <li><code>queued</code> - an object containing the queued transaction summary strings, which maps an address to a batch of scheduled transactions<ul> <li><code>address</code> - the address initiating a transaction, which maps the addresses' associating nonces with their transaction summary strings</li> </ul> </li> </ul> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"txpool_inspect\", \"params\":[]\n  }'\n</code></pre> txpool_status <p>Returns the total number of transactions currently pending transactions waiting to be included in the next block(s) and all queued transactions for future execution. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <p>None</p> <p>The <code>result</code> object contains the following fields:</p> <ul> <li><code>pending</code> - a counter representing the number of pending transactions</li> <li><code>queued</code> - a counter representing the number of queued transactions</li> </ul> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"txpool_status\", \"params\":[]\n  }'\n</code></pre>"},{"location":"builders/ethereum/json-rpc/eth-rpc/","title":"Supported Ethereum RPC Methods","text":""},{"location":"builders/ethereum/json-rpc/eth-rpc/#introduction","title":"Introduction","text":"<p>The Moonbeam team has collaborated closely with Parity on developing Frontier, an Ethereum compatibility layer for Substrate-based chains. This layer enables developers to run unmodified Ethereum dApps on Moonbeam seamlessly.</p> <p>Nevertheless, not all Ethereum JSON-RPC methods are supported; some of those supported return default values (those related to Ethereum's PoW consensus mechanism in particular). This guide provides a comprehensive list of supported Ethereum JSON-RPC methods on Moonbeam. Developers can quickly reference this list to understand the available functionality for interfacing with Moonbeam's Ethereum-compatible blockchain.</p>"},{"location":"builders/ethereum/json-rpc/eth-rpc/#basic-rpc-methods","title":"Standard Ethereum JSON-RPC Methods","text":"<p>The basic JSON-RPC methods from the Ethereum API supported by Moonbeam are:</p> <ul> <li>eth_protocolVersion \u2014 returns <code>1</code> by default</li> <li>eth_syncing \u2014 returns an object with data about the sync status or <code>false</code></li> <li>eth_hashrate \u2014 returns <code>\"0x0\"</code> by default</li> <li>eth_coinbase \u2014 returns the latest block author. Not necessarily a finalized block</li> <li>eth_mining \u2014 returns <code>false</code> by default</li> <li>eth_chainId \u2014 returns the chain ID used for signing at the current block</li> <li>eth_gasPrice \u2014 returns the base fee per unit of gas used. This is currently the minimum gas price for each network</li> <li>eth_accounts \u2014 returns a list of addresses owned by the client</li> <li>eth_blockNumber \u2014 returns the highest available block number</li> <li>eth_getBalance \u2014 returns the balance of the given address. Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_getStorageAt \u2014 returns the content of the storage at a given address. Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_getBlockByHash \u2014 returns information about the block of the given hash, including <code>baseFeePerGas</code> on post-London blocks</li> <li>eth_getBlockByNumber \u2014 returns information about the block specified by block number, including <code>baseFeePerGas</code> on post-London blocks. Instead of providing a block number as the first parameter, you can provide a default block parameter</li> <li>eth_getBlockReceipts \u2014 returns all transaction receipts for a given block</li> <li>eth_getTransactionCount \u2014 returns the number of transactions sent from the given address (nonce). Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_getBlockTransactionCountByHash \u2014 returns the number of transactions in a block with a given block hash</li> <li>eth_getBlockTransactionCountByNumber \u2014 returns the number of transactions in a block with a given block number</li> <li>eth_getUncleCountByBlockHash \u2014  returns <code>\"0x0\"</code> by default</li> <li>eth_getUncleCountByBlockNumber \u2014 returns <code>\"0x0\"</code> by default</li> <li>eth_getCode \u2014 returns the code at the given address at the given block number. Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_sendTransaction \u2014 creates a new message call transaction or a contract creation, if the data field contains code. Returns the transaction hash or the zero hash if the transaction is not yet available</li> <li>eth_sendRawTransaction \u2014 creates a new message call transaction or a contract creation for signed transactions. Returns the transaction hash or the zero hash if the transaction is not yet available</li> <li>eth_call \u2014 executes a new message call immediately without creating a transaction on the blockchain, returning the value of the executed call<ul> <li>Moonbeam supports the use of the optional state override set object. This address-to-state mapping object allows the user to specify some state to be ephemerally overridden before executing a call to <code>eth_call</code>. The state override set is commonly used for tasks like debugging smart contracts. Visit the go-ethereum documentation to learn more</li> <li>Instead of providing a block number as a parameter, you can provide a default block parameter</li> </ul> </li> <li>eth_estimateGas \u2014 returns an estimated amount of gas necessary for a given transaction to succeed. You can optionally specify a <code>gasPrice</code> or <code>maxFeePerGas</code> and <code>maxPriorityFeePerGas</code>. Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_maxPriorityFeePerGas - returns an estimate of how much priority fee, in Wei, is needed for inclusion in a block</li> <li>eth_feeHistory \u2014 returns <code>baseFeePerGas</code>, <code>gasUsedRatio</code>, <code>oldestBlock</code>, and <code>reward</code> for a specified range of up to 1024 blocks</li> <li>eth_getTransactionByHash \u2014 returns the information about a transaction with a given hash. EIP-1559 transactions have <code>maxPriorityFeePerGas</code> and <code>maxFeePerGas</code> fields</li> <li>eth_getTransactionByBlockHashAndIndex \u2014 returns information about a transaction at a given block hash and a given index position. EIP-1559 transactions have <code>maxPriorityFeePerGas</code> and <code>maxFeePerGas</code> fields</li> <li>eth_getTransactionByBlockNumberAndIndex \u2014 returns information about a transaction at a given block number and a given index position. EIP-1559 transactions have <code>maxPriorityFeePerGas</code> and <code>maxFeePerGas</code> fields. Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_getTransactionReceipt \u2014 returns the transaction receipt of a given transaction hash</li> <li>eth_getUncleByBlockHashAndIndex \u2014 returns <code>null</code> by default</li> <li>eth_getUncleByBlockNumberAndIndex \u2014 returns <code>null</code> by default</li> <li>eth_getLogs \u2014 returns an array of all logs matching a given filter object. Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_newFilter \u2014 creates a filter object based on the input provided. Returns a filter ID</li> <li>eth_newBlockFilter \u2014 creates a filter in the node to notify when a new block arrives. Returns a filter ID</li> <li>eth_newPendingTransactionFilter - creates a filter in the node to notify when new pending transactions arrive. Returns a filter ID</li> <li>eth_getFilterChanges \u2014 polling method for filters (see methods above). Returns an array of logs that occurred since the last poll</li> <li>eth_getFilterLogs \u2014 returns an array of all the logs matching the filter with a given ID</li> <li>eth_uninstallFilter \u2014 uninstall a filter with a given ID. It should be used when polling is no longer needed. Filters timeout when they are not requested using <code>eth_getFilterChanges</code> after some time</li> </ul>"},{"location":"builders/ethereum/json-rpc/eth-rpc/#default-block-parameters","title":"Default Block Parameters","text":"<p>Moonbeam supports several default block parameters that allow you to query a subset of JSON-RPC methods at significant block heights. Moonbeam supports the following default block parameters: </p> <ul> <li><code>finalized</code> - Refers to the most recent block that Polkadot validators have finalized</li> <li><code>safe</code> - Synonymous with <code>finalized</code> in Moonbeam. In Ethereum, <code>safe</code> refers to the most recent block that is considered safe by the network, meaning it is unlikely to be reverted but has not yet been finalized. With Moonbeam's fast and deterministic finality, <code>finalized</code> and <code>safe</code> refer to the same blocks. </li> <li><code>earliest</code> - Refers to the genesis block of the blockchain</li> <li><code>pending</code> - Represents the latest state, including pending transactions that have not yet been mined into a block. This is a live view of the mempool</li> <li><code>latest</code> - Refers to the latest confirmed block in the blockchain, which may not be finalized</li> </ul>"},{"location":"builders/ethereum/json-rpc/eth-rpc/#unsupported-rpc-methods","title":"Unsupported Ethereum JSON-RPC Methods","text":"<p>Moonbeam does not support the following Ethereum API JSON-RPC methods:</p> <ul> <li>eth_getProof - returns the account and storage values of the specified account including the Merkle-proof</li> <li>eth_blobBaseFee - returns the expected base fee for blobs in the next block</li> <li>eth_createAccessList - creates an EIP-2930 type <code>accessList</code> based on a given transaction object</li> <li>eth_sign - allows the user to sign an arbitrary hash to be sent at a later time. Presents a security risk as the arbitrary hash can be fraudulently applied to other transactions</li> <li>eth_signTransaction - allows the user to sign a transaction to be sent at a later time. It is rarely used due to associated security risks</li> </ul>"},{"location":"builders/ethereum/json-rpc/eth-rpc/#additional-rpc-methods","title":"Additional RPC Methods","text":"<p>Check out some of the non-standard Ethereum and Moonbeam-specific RPC methods:</p> <ul> <li>Debug and Trace</li> <li>Event Subscription</li> <li>Custom Moonbeam</li> </ul>"},{"location":"builders/ethereum/json-rpc/moonbeam-custom-api/","title":"Moonbeam Custom API","text":""},{"location":"builders/ethereum/json-rpc/moonbeam-custom-api/#introduction","title":"Introduction","text":"<p>Moonbeam nodes include support for custom JSON-RPC endpoints: </p> <ul> <li><code>moon_isBlockFinalized</code> </li> <li><code>moon_isTxFinalized</code></li> <li><code>moon_getEthSyncBlockRange</code></li> </ul> <p>These endpoints provide valuable functionality for checking the finality of on-chain events.</p> <p>To begin exploring Moonbeam's custom JSON-RPC endpoints, you can try out the provided curl examples below. These examples demonstrate how to query the public RPC endpoint of Moonbase Alpha. However, you can easily modify them to use with your own Moonbeam or Moonriver endpoint by changing the URL and API key. If you haven't already, you can obtain your endpoint and API key from one of our supported Endpoint Providers.</p>"},{"location":"builders/ethereum/json-rpc/moonbeam-custom-api/#rpc-methods","title":"Supported Custom RPC Methods","text":"moon_isBlockFinalized <p>Checks for the finality of the block given by its block hash.</p> ParametersReturnsExample <ul> <li><code>block_hash</code> string - the hash of the block, accepts either Substrate-style or Ethereum-style block hash as its input</li> </ul> <p>Returns a boolean: <code>true</code> if the block is finalized, <code>false</code> if the block is not finalized or not found.</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"moon_isBlockFinalized\",\n  \"params\": [\"INSERT_BLOCK_HASH\"]\n}' https://rpc.api.moonbase.moonbeam.network\n</code></pre> moon_isTxFinalized <p>Checks for the finality of a transaction given its EVM transaction hash.</p> ParametersReturnsExample <ul> <li><code>tx_hash</code> string - the EVM transaction hash of the transaction </li> </ul> <p>Returns a boolean: <code>true</code> if the transaction is finalized, <code>false</code> if the transaction is not finalized or not found.</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"moon_isTxFinalized\",\n  \"params\": [\"INSERT_TRANSACTION_HASH\"]\n}' https://rpc.api.moonbase.moonbeam.network\n</code></pre> moon_getEthSyncBlockRange <p>Returns the range of blocks that are fully indexed in Frontier's backend.</p> ParametersReturnsExample <p>None</p> <p>Returns the range of blocks that are fully indexed in Frontier's backend. An example response below includes the Substrate block hashes of block <code>0</code> and the latest fully indexed block:</p> <p><code>[ \"0x91bc6e169807aaa54802737e1c504b2577d4fafedd5a02c10293b1cd60e39527\", \"0xb1b49bd709ca9fe0e751b8648951ffbb2173e1258b8de8228cfa0ab27003f612\" ]</code></p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"moon_getEthSyncBlockRange\",\n  \"params\": []\n}' https://rpc.api.moonbase.moonbeam.network\n</code></pre>"},{"location":"builders/ethereum/json-rpc/pubsub/","title":"Subscribe to Events","text":""},{"location":"builders/ethereum/json-rpc/pubsub/#introduction","title":"Introduction","text":"<p>Moonbeam supports event subscriptions for Ethereum-style events, which allows you to wait for events and handle them accordingly instead of polling for them.</p> <p>It works by subscribing to particular events; an ID is returned for each subscription. For each event that matches the subscription, a notification with relevant data is sent together with the subscription ID.</p> <p>In this guide, you will learn how to subscribe to event logs, incoming pending transactions, and incoming block headers on Moonbase Alpha. This guide can also be adapted for Moonbeam or Moonriver.</p>"},{"location":"builders/ethereum/json-rpc/pubsub/#filter-rpc-methods","title":"Supported Pubsub JSON-RPC Methods","text":"<p>Please note that the examples in this section require installing wscat.</p> eth_subscribe <p>Creates a subscription for a given subscription name.</p> ParametersReturnsExample <ul> <li><code>subscription_name</code> string - the type of the event to subscribe to. The supported subscription types are:<ul> <li><code>newHeads</code> \u2014 triggers a notification each time a new header is appended to the chain</li> <li><code>logs</code> \u2014 returns logs that are included in new imported blocks and match a given filter criteria</li> <li><code>newPendingTransactions</code> \u2014 returns the hash for all transactions that are added to the pending state</li> <li><code>syncing</code> \u2014 indicates when the node starts or stops synchronizing with the network</li> </ul> </li> </ul> <p>The <code>result</code> returns the subscription ID.</p> <pre><code>wscat -c wss://wss.api.moonbase.moonbeam.network -x '\n  {\n    \"jsonrpc\": \"2.0\", \n    \"id\": 1, \n    \"method\": \"eth_subscribe\", \n    \"params\": [\"INSERT_SUBSCRIPTION_NAME\"]\n  }'\n</code></pre> eth_unsubscribe <p>Cancels an existing subscription given its subscription ID.</p> ParametersReturnsExample <ul> <li><code>subscription_id</code> string - the subscription ID</li> </ul> <p>The <code>result</code> returns a boolean indicating whether or not the subscription was successfully canceled.</p> <pre><code>wscat -c wss://wss.api.moonbase.moonbeam.network -x '\n  {\n    \"jsonrpc\": \"2.0\", \n    \"id\": 1, \n    \"method\": \"eth_unsubscribe\", \n    \"params\": [\"INSERT_SUBSCRIPTION_ID\"]\n  }'\n</code></pre>"},{"location":"builders/ethereum/json-rpc/pubsub/#subscribe-to-events","title":"Subscribe to Events Using Ethereum Libraries","text":"<p>This section will show you how to use Ethereum libraries, like Web3.js, to programmatically subscribe to events on Moonbeam.</p>"},{"location":"builders/ethereum/json-rpc/pubsub/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The examples in this guide are based on an Ubuntu 22.04 environment. You will also need the following:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To deploy your own ERC-20 token on Moonbase Alpha. You can do this by following our Remix tutorial while first pointing MetaMask to Moonbase Alpha</li> <li> <p>Web3.js or the Ethereum library of your choice installed. You can install Web3.js via npm:</p> <pre><code>npm install web3\n</code></pre> </li> </ul>"},{"location":"builders/ethereum/json-rpc/pubsub/#subscribing-to-event-logs-in-moonbase-alpha","title":"Subscribe to Event Logs","text":"<p>Any contract that follows the ERC-20 token standard emits an event related to a token transfer, that is, <code>event Transfer(address indexed from, address indexed to, uint256 value)</code>. In this section, you'll learn how to subscribe to these events using the Web3.js library.</p> <p>Use the following code snippet to set up a subscription to listen for token transfer events:</p> <pre><code>const { Web3 } = require('web3');\nconst web3 = new Web3('wss://wss.api.moonbase.moonbeam.network');\n\nconst main = async () =&gt; {\n  const subscsription = await web3.eth.subscribe(\n    'logs',\n    {\n      address: 'INSERT_CONTRACT_ADDRESS',\n      topics: [\n        '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n      ],\n    },\n    (error, result) =&gt; {\n      if (error) console.error(error);\n    }\n  );\n\n  console.log('\ud83d\udd54 Subscription set up. Waiting for new logs');\n\n  subscsription.on('connected', function (subscriptionId) {\n    console.log(subscriptionId);\n  });\n  subscsription.on('data', function (log) {\n    console.log(log);\n  });\n};\n\nmain();\n</code></pre> <p>Note</p> <p>Make sure to replace <code>'INSERT_CONTRACT_ADDRESS'</code> with the actual address of the ERC-20 token contract that you should have already deployed (as a prerequisite).</p> <p>In the provided code:</p> <ul> <li>A subscription is set up using the <code>web3.subscribe('logs', options)</code> method to receive logs emitted by the contract, which listens for new data and logs it to the console</li> <li> <p>The <code>topics</code> array filters logs to include only events with the specified event signature. For this example, logs are filtered using the signature of the <code>Transfer</code> event, which can be calculated as follows:</p> <pre><code>EventSignature = keccak256(Transfer(address,address,uint256))\n</code></pre> <p>This translates to <code>0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</code>, as seen in the code snippet.</p> </li> </ul> <p>If you do not provide any topics, you subscribe to all events emitted by the contract. More information about topics can be found in the Understanding event logs on the Ethereum blockchain Medium post.</p> <p>By executing this code, you'll establish a subscription to monitor ERC-20 token transfer events on Moonbeam. The terminal will display a subscription ID indicating a successful setup and await any new events emitted by the contract.</p>  node contract-events.js 0x35547a6f7777444f35306f5353556271"},{"location":"builders/ethereum/json-rpc/pubsub/#understanding-event-logs","title":"Understanding Event Logs","text":"<p>To illustrate the process, assume that an ERC-20 token transfer has been sent with the following parameters:</p> <ul> <li>From address - <code>0x44236223aB4291b93EEd10E4B511B37a398DEE55</code></li> <li>To address - <code>0x8841701Dba3639B254D9CEe712E49D188A1e941e</code></li> <li>Value (tokens) - <code>1000000000000000000</code> (1 DEV in Wei)</li> </ul> <p>The event logs emitted by the transaction are as follows:</p>  node contract-events.js 0x35547a6f7777444f35306f5353556271 {   address: '0xCc17F1FAEAab9Fe70Dc2D616Ea768a4336f3c506',   blockHash: '0x12d1f37db14f8d4efa2540ecb63d7f8b95236bb11c405e58691a45070d2c7e7f',   blockNumber: 16736,   data: '0x0000000000000000000000000000000000000000000000000d0b6b3a7640000',   logIndex: 0,   removed: false,   topics: [     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',     '0x00000000000000000000000044236223ab4291b93eed10e4b511b37a398dee55',     '0x0000000000000000000000008841701dba3639b254d9cee712e49d188a1e941e'   ],   transactionHash: '0xd53891693a731e0bca3287adc6375d04fe3b6605d00b186a669c6bbc8d22e88d',   transactionIndex: 0,   transactionLogIndex: '0x0',   id: 'log_83c933b0' } <p>If you look at the <code>topics</code> array, there are a total of three topics present (in this order):</p> <ol> <li>The event signature of the <code>Transfer</code> event</li> <li>The <code>from</code> address</li> <li>The <code>to</code> address</li> </ol> <p>As there are a total of three topics (the maximum is four), this corresponds to the LOG3 opcode:</p> <p></p> <p>Indexed topics, such as the <code>from</code> and <code>to</code> addresses, are typically represented by 256-bit (64 hexadecimal character) values. If necessary, they are padded with zeros to reach the full length.</p> <p>Unindexed data, such as the value of tokens transferred, is not included in the <code>topics</code> array. Instead, it is returned within the logs' <code>data</code> field, encoded in bytes32/hex format. To decode it, you can use, for example, this Web3 Type Converter tool and verify that the <code>data</code> is 1 DEV token formatted in Wei.</p> <p>If the event returns multiple unindexed values, they will be appended one after the other in the same order the event emits them. Therefore, each value is obtained by deconstructing data into separate 32-byte (or 64-hex-character-long) pieces.</p>"},{"location":"builders/ethereum/json-rpc/pubsub/#using-wildcards-and-conditional-formatting","title":"Use Wildcards and Conditional Formatting","text":"<p>Using the same example as in the previous section, you can subscribe to all of the events of the token contract with the following code:</p> <pre><code>const { Web3 } = require('web3');\nconst web3 = new Web3('wss://wss.api.moonbase.moonbeam.network');\n\nconst main = async () =&gt; {\n  const subscription = await web3.eth.subscribe(\n    'logs',\n    {\n      address: 'INSERT_CONTRACT_ADDRESS',\n      topics: [\n        null,\n        [\n          '0x00000000000000000000000044236223aB4291b93EEd10E4B511B37a398DEE55',\n          '0x0000000000000000000000008841701Dba3639B254D9CEe712E49D188A1e941e',\n        ],\n      ],\n    },\n    (error, result) =&gt; {\n      if (error) console.error(error);\n    }\n  );\n\n  console.log(\"\ud83d\udd54 Subscription set up. Waiting for new logs\")\n\n  subscription.on('connected', function (subscriptionId) {\n    console.log(subscriptionId);\n  });\n  subscription.on('data', function (log) {\n    console.log(log);\n  });\n};\n\nmain();\n</code></pre> <p>Here, by using the wildcard <code>null</code> in place of the event signature, you'll filter to listen to all events emitted by the contract you subscribe to. However, with this configuration, you can also use a second input field (<code>topic_1</code>) to filter by address.</p> <p>In the case of this subscription, you are notifying that you want to only receive events where <code>topic_1</code> is one of the addresses you are providing. Note that addresses need to be in H256 format. For example, the address <code>0x44236223aB4291b93EEd10E4B511B37a398DEE55</code> needs to be entered as <code>0x00000000000000000000000044236223aB4291b93EEd10E4B511B37a398DEE55</code>.</p> <p>As before, this subscription's output will display the event signature in <code>topic_0</code> to tell you which event the contract emitted.</p>  node contract-events.js 0x51583364703338703441507476516675 {   address: '0xCc17F1FAEAab9Fe70Dc2D616Ea768a4336f3c506',   blockHash: '0xc7fa1139a35fb7a634514907feeb771e6aac7717906922a8589f029f709dcaef',   blockNumber: 16739,   data: '0x0000000000000000000000000000000000000000000000000de0b6b3a7640000',   logIndex: 0,   removed: false,   topics: [     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',     '0x00000000000000000000000044236223ab4291b93eed10e4b511b37a398dee55',     '0x0000000000000000000000008841701dba3639b254d9cee712e49d188a1e941e'   ],   transactionHash: '0x84154ea6ee44a4ffc446acd17579966691105694ce370f01de09d3a9f1b9506',   transactionIndex: 0,   transactionLogIndex: '0x0',   id: 'log_188dbef1' } {   address: '0xCc17F1FAEAab9Fe70Dc2D616Ea768a4336f3c506',   blockHash: '0xf21ded1bc724d2be74bc97c2045e31754d5326f3964796d62a1cba3e1d06203',   blockNumber: 16740,   data: '0x0000000000000000000000000000000000000000000000000de0b6b3a7640000',   logIndex: 0,   removed: false,   topics: [     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',     '0x0000000000000000000000008841701dba3639b254d9cee712e49d188a1e941e',     '0x00000000000000000000000044236223ab4291b93eed10e4b511b37a398dee55'   ],   transactionHash: '0x091b736bd31457a9b0725a98926dc3ebfb0608e71197c10d4d9ccb80de6d9ac3',   transactionIndex: 0,   transactionLogIndex: '0x0',   id: 'log_401c7925' } <p>As shown, after you provided the two addresses with conditional formatting, you should have received two logs with the same subscription ID. Events emitted by transactions from different addresses will not throw any logs to this subscription.</p> <p>This example showed how you could subscribe to just the event logs of a specific contract, but the Web3.js library provides other subscription types that will be covered in the following sections.</p>"},{"location":"builders/ethereum/json-rpc/pubsub/#subscribe-to-incoming-pending-transactions","title":"Subscribe to Incoming Pending Transactions","text":"<p>To subscribe to pending transactions, you can use the <code>web3.eth.subscribe('pendingTransactions')</code> method, implementing the same callback function to check for the response. The transaction hash of the pending transactions is returned.</p>  node pending-tx.js 0x3350757676747651354e4553724e7269 0x5e3870e2c38274f4344cb86f3719dad84193b610a13b7e60c7ee65868b7ebc9a 0x54a28da6915df1ec83af4aafeab57364bbf4239d5ba71b596faabc76ba355eab <p>You can try this by sending a transaction and verifying that the transaction hash returned by the subscription is the same one returned by the development tool or wallet you are using.</p>"},{"location":"builders/ethereum/json-rpc/pubsub/#subscribe-to-incoming-block-headers","title":"Subscribe to Incoming Block Headers","text":"<p>You can also subscribe to new block headers using the <code>web3.eth.subscribe('newHeads')</code> method, implementing the same callback function to check for the response. This subscription provides incoming block headers and can be used to track changes in the blockchain.</p>  node block-headers.js 0x6472456d30776b636c615a317158514e {   author: '0x0000000000000000000000000000000000000000',   difficulty: '0',   extraData: '0x',   gasLimit: 0,   gasUsed: 0,   hash: '0x1a28a9a7a176ed0d627f1bc521bda4eaca1e8186bf6642f089578067b713da43',   logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',   miner: '0x0000000000000000000000000000000000000000',   number: 16756,   parentHash: '0x89401a45d6226a5eb509fd3abfd90cb74aa5d7b5f747ef2506013d1afa36a418',   receiptsRoot: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',   sealFields: [     '0x0000000000000000000000000000000000000000000000000000000000000000',     '0x0000000000000000'   ],   sha3Uncles: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',   size: 509,   stateRoot: '0x92f3417ed90a81fecb2587fd820c1479f88f27228b8f508dfde601061d14371d',   timestamp: 1607710710159,   transactionsRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421' } <p>Note that only one block header is shown in the image. These messages are displayed for every block produced so they can quickly fill up the terminal.</p>"},{"location":"builders/ethereum/json-rpc/pubsub/#check-if-a-node-is-synchronized-with-the-network","title":"Check If a Node Is Synchronized with the Network","text":"<p>With pubsub, checking whether a particular node is currently synchronizing with the network is also possible. You can use the <code>web3.eth.subscribe('syncing')</code> method, implementing the same callback function to check for the response. This subscription will either return a boolean when <code>syncing</code> is false or an object describing the syncing progress when <code>syncing</code> is true, as seen below.</p>  node syncing.js 0x3252615570630563274436770446371 {   syncing: true,   startingBlock: 120237,   currentBlock: 146952,   highestBlock: 2553484 } <p>Note</p> <p>The pubsub implementation in Frontier is still in active development. This current version allows users to subscribe to specific event types, but there may still be some limitations.</p>"},{"location":"builders/ethereum/libraries/ethersjs/","title":"Ethers.js JavaScript Library","text":""},{"location":"builders/ethereum/libraries/ethersjs/#introduction","title":"Introduction","text":"<p>The Ethers.js library provides a set of tools to interact with Ethereum Nodes with JavaScript, similar to Web3.js. Moonbeam has an Ethereum-like API available that is fully compatible with Ethereum-style JSON-RPC invocations. Therefore, developers can leverage this compatibility and use the Ethers.js library to interact with a Moonbeam node as if they were doing so on Ethereum. For more information on Ethers.js, check their documentation site.</p> <p>In this guide, you'll learn how to use the Ethers.js library to send a transaction and deploy a contract on Moonbase Alpha. This guide can be adapted for Moonbeam, Moonriver, or a Moonbeam development node.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#install-ethersjs","title":"Installing Ethers.js","text":"<p>To get started, you'll need to start a basic JavaScript project. First, create a directory to store all of the files you'll be creating throughout this guide and initialize the project with the following command:</p> <pre><code>mkdir ethers-examples &amp;&amp; cd ethers-examples &amp;&amp; npm init --y\n</code></pre> <p>For this guide, you'll need to install the Ethers.js library and the Solidity compiler. To install both NPM packages, you can run the following command:</p> npmyarn <pre><code>npm install ethers solc@0.8.0\n</code></pre> <pre><code>yarn add ethers solc@0.8.0\n</code></pre>"},{"location":"builders/ethereum/libraries/ethersjs/#setting-up-the-ethers-provider","title":"Setting up the Ethers Provider","text":"<p>Throughout this guide, you'll be creating a bunch of scripts that provide different functionality such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts you'll need to create an Ethers provider to interact with the network.</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>To create a provider, you can take the following steps:</p> <ol> <li>Import the <code>ethers</code> library</li> <li>Define the <code>providerRPC</code> object, which can include the network configurations for any of the networks you want to send a transaction on. You'll include the <code>name</code>, <code>rpc</code>, and <code>chainId</code> for each network</li> <li>Create the <code>provider</code> using the <code>ethers.JsonRpcProvider</code> method</li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>// 1. Import ethers\nconst ethers = require('ethers');\n\n// 2. Define network configurations\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT', // Insert your RPC URL here\n    chainId: 1284, // 0x504 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n</code></pre> <pre><code>// 1. Import ethers\nconst ethers = require('ethers');\n\n// 2. Define network configurations\nconst providerRPC = {\n  moonriver: {\n    name: 'moonriver',\n    rpc: 'INSERT_RPC_API_ENDPOINT', // Insert your RPC URL here\n    chainId: 1285, // 0x505 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonriver.rpc, {\n  chainId: providerRPC.moonriver.chainId,\n  name: providerRPC.moonriver.name,\n});\n</code></pre> <pre><code>// 1. Import ethers\nconst ethers = require('ethers');\n\n// 2. Define network configurations\nconst providerRPC = {\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287, // 0x507 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n});\n</code></pre> <pre><code>// 1. Import ethers\nconst ethers = require('ethers');\n\n// 2. Define network configurations\nconst providerRPC = {\n  dev: {\n    name: 'moonbeam-development',\n    rpc: 'http://127.0.0.1:9944',\n    chainId: 1281, // 0x501 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.dev.rpc, {\n  chainId: providerRPC.dev.chainId,\n  name: providerRPC.dev.name,\n});\n</code></pre> <p>Save this code snippet as you'll need it for the scripts that are used in the following sections.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#send-a-transaction","title":"Send a Transaction","text":"<p>During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.</p> <p>You can also use the balance script to check the account balances after the transaction has been sent.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#check-balances-script","title":"Check Balances Script","text":"<p>You'll only need one file to check the balances of both addresses before and after the transaction is sent.  To get started, you can create a <code>balances.js</code> file by running:</p> <pre><code>touch balances.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Ethers provider</li> <li>Define the <code>addressFrom</code> and <code>addressTo</code> variables</li> <li>Create the asynchronous <code>balances</code> function which wraps the <code>provider.getBalance</code> method</li> <li>Use the <code>provider.getBalance</code> function to fetch the balances for the <code>addressFrom</code> and <code>addressTo</code> addresses. You can also leverage the <code>ethers.formatEther</code> function to transform the balance into a more readable number in ETH</li> <li>Lastly, run the <code>balances</code> function</li> </ol> <pre><code>// 1. Add the Ethers provider logic here:\n// {...}\n\n// 2. Create address variables\nconst addressFrom = 'INSERT_FROM_ADDRESS';\nconst addressTo = 'INSERT_TO_ADDRESS';\n\n// 3. Create balances function\nconst balances = async () =&gt; {\n  // 4. Fetch balances\n  const balanceFrom = ethers.formatEther(await provider.getBalance(addressFrom));\n  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} DEV`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} DEV`);\n};\n\n// 5. Call the balances function\nbalances();\n</code></pre> View the complete script <pre><code>// Import ethers\nconst ethers = require('ethers');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Define addresses\nconst addressFrom = 'INSERT_FROM_ADDRESS';\nconst addressTo = 'INSERT_TO_ADDRESS';\n\n// Create balances function\nconst balances = async () =&gt; {\n  // Fetch balances\n  const balanceFrom = ethers.formatEther(\n    await provider.getBalance(addressFrom)\n  );\n  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} DEV`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} DEV`);\n};\n\n// Call the balances function\nbalances();\n</code></pre> <p>To run the script and fetch the account balances, you can run the following command:</p> <pre><code>node balances.js\n</code></pre> <p>If successful, the balances for the origin and receiving address will be displayed in your terminal in DEV.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#send-transaction-script","title":"Send Transaction Script","text":"<p>You'll only need one file for executing a transaction between accounts. For this example, you'll be transferring 1 DEV token from an origin address (from which you hold the private key) to another address. To get started, you can create a <code>transaction.js</code> file by running:</p> <pre><code>touch transaction.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Ethers provider</li> <li>Define the <code>privateKey</code> and the <code>addressTo</code> variables. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create a wallet using the <code>privateKey</code> and <code>provider</code> from the previous steps. The wallet instance is used to sign transactions</li> <li>Create the asynchronous <code>send</code> function which wraps the transaction object and the <code>wallet.sendTransaction</code> method</li> <li>Create the transaction object which only requires the recipient's address and the amount to send. Note that <code>ethers.parseEther</code> can be used, which handles the necessary unit conversions from Ether to Wei - similar to using <code>ethers.parseUnits(value, 'ether')</code></li> <li>Send the transaction using the <code>wallet.sendTransaction</code> method and then use <code>await</code> to wait until the transaction is processed and the transaction receipt is returned</li> <li>Lastly, run the <code>send</code> function</li> </ol> <pre><code>// 1. Add the Ethers provider logic here:\n// {...}\n\n// 2. Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst addressTo = 'INSERT_TO_ADDRESS';\n\n// 3. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 4. Create send function\nconst send = async () =&gt; {\n  console.log(`Attempting to send transaction from ${wallet.address} to ${addressTo}`);\n\n  // 5. Create tx object\n  const tx = {\n    to: addressTo,\n    value: ethers.parseEther('1'),\n  };\n\n  // 6. Sign and send tx - wait for receipt\n  const createReceipt = await wallet.sendTransaction(tx);\n  await createReceipt.wait();\n  console.log(`Transaction successful with hash: ${createReceipt.hash}`);\n};\n\n// 7. Call the send function\nsend();\n</code></pre> View the complete script <pre><code>// Import ethers\nconst ethers = require('ethers');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Define accounts and wallet\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst addressTo = 'INSERT_TO_ADDRESS';\nconst wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${wallet.address} to ${addressTo}`\n  );\n\n  // Create transaction\n  const tx = {\n    to: addressTo,\n    value: ethers.parseEther('1'),\n  };\n\n  // Send transaction and get hash\n  const createReceipt = await wallet.sendTransaction(tx);\n  await createReceipt.wait();\n  console.log(`Transaction successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the send function\nsend();\n</code></pre> <p>To run the script, you can run the following command in your terminal:</p> <pre><code>node transaction.js\n</code></pre> <p>If the transaction was successful, in your terminal you'll see the transaction hash has been printed out.</p> <p>You can also use the <code>balances.js</code> script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:</p> node balances.js The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3604.673685275447543445 DEV The balance of 0xFFA0352d300cdd8aCdA5c947D87CbCc3f0B3485A is: 0 DEV node transaction.js Attempting to send transaction from 0x3B939FeaD1557C741Ff06492FD0127bd287A421e to 0xFFA0352d300cdd8aCdA5c947D87CbCc3f0B3485A Transaction successful with hash: 0x01e42c627fe79b1d5649a64d39fceec34aba3904e37d768e74ec71fcd62b897f node balances.js The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3603.673682650447543445 DEV The balance of 0xFFA0352d300cdd8aCdA5c947D87CbCc3f0B3485A is: 1.0 DEV"},{"location":"builders/ethereum/libraries/ethersjs/#deploy-a-contract","title":"Deploy a Contract","text":"<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (the default is <code>0</code>). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only and does not handle values wrapping around.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#compile-contract-script","title":"Compile Contract Script","text":"<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.js</code> file by running:</p> <pre><code>touch compile.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>fs</code> and <code>solc</code> packages</li> <li>Using the <code>fs.readFileSync</code> function, you'll read and save the file contents of <code>Incrementer.sol</code> to <code>source</code></li> <li>Build the <code>input</code> object for the Solidity compiler by specifying the <code>language</code>, <code>sources</code>, and <code>settings</code> to be used</li> <li>Using the <code>input</code> object, you can compile the contract using <code>solc.compile</code></li> <li>Extract the compiled contract file and export it to be used in the deployment script</li> </ol> <pre><code>// 1. Import packages\nconst fs = require('fs');\nconst solc = require('solc');\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n   language: 'Solidity',\n   sources: {\n      'Incrementer.sol': {\n         content: source,\n      },\n   },\n   settings: {\n      outputSelection: {\n         '*': {\n            '*': ['*'],\n         },\n      },\n   },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nmodule.exports = contractFile;\n</code></pre>"},{"location":"builders/ethereum/libraries/ethersjs/#deploy-contract-script","title":"Deploy Contract Script","text":"<p>With the script for compiling the <code>Incrementer.sol</code> contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called <code>deploy.js</code>:</p> <pre><code>touch deploy.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the contract file from <code>compile.js</code></li> <li>Set up the Ethers provider</li> <li>Define the <code>privateKey</code> for the origin account. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create a wallet using the <code>privateKey</code> and <code>provider</code> from the previous steps. The wallet instance is used to sign transactions</li> <li>Load the contract <code>bytecode</code> and <code>abi</code> for the compiled contract</li> <li>Create a contract instance with signer using the <code>ethers.ContractFactory</code> function, providing the <code>abi</code>, <code>bytecode</code>, and <code>wallet</code> as parameters</li> <li>Create the asynchronous <code>deploy</code> function that will be used to deploy the contract</li> <li>Within the <code>deploy</code> function, use the <code>incrementer</code> contract instance to call <code>deploy</code> and pass in the initial value. For this example, you can set the initial value to <code>5</code>. This will send the transaction for contract deployment. To wait for a transaction receipt you can use the <code>deployed</code> method of the contract deployment transaction</li> <li>Lastly, run the <code>deploy</code> function</li> </ol> <pre><code>// 1. Import the contract file\nconst contractFile = require('./compile');\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\n\n// 4. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Load contract information\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// 6. Create contract instance with signer\nconst incrementer = new ethers.ContractFactory(abi, bytecode, wallet);\n\n// 7. Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${wallet.address}`);\n\n  // 8. Send tx (initial value set to 5) and wait for receipt\n  const contract = await incrementer.deploy(5);\n  const txReceipt = await contract.deploymentTransaction().wait();\n\n  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);\n};\n\n// 9. Call the deploy function\ndeploy();\n</code></pre> View the complete script <pre><code>// Import ethers and compile\nconst ethers = require('ethers');\nconst contractFile = require('./compile');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Define accounts and wallet\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Load contract info\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// Create contract instance with signer\nconst incrementer = new ethers.ContractFactory(abi, bytecode, wallet);\n\n// Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${wallet.address}`);\n\n  // Send tx (initial value set to 5) and wait for receipt\n  const contract = await incrementer.deploy(5);\n  const txReceipt = await contract.deploymentTransaction().wait();\n\n  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);\n};\n\n// Call the deploy function\ndeploy();\n</code></pre> <p>To run the script, you can enter the following command into your terminal:</p> <pre><code>node deploy.js\n</code></pre> <p>If successful, the contract's address will be displayed in the terminal.</p> node deploy.js Attempting to deploy from account: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Contract deployed at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A"},{"location":"builders/ethereum/libraries/ethersjs/#read-contract-data","title":"Read Contract Data (Call Methods)","text":"<p>Call methods are the type of interaction that don't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.</p> <p>To get started, you can create a file and name it <code>get.js</code>:</p> <pre><code>touch get.js\n</code></pre> <p>Then you can take the following steps to create the script:</p> <ol> <li>Import the <code>abi</code> from the <code>compile.js</code> file</li> <li>Set up the Ethers provider</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract</li> <li>Create an instance of the contract using the <code>ethers.Contract</code> function and passing in the <code>contractAddress</code>, <code>abi</code>, and <code>provider</code></li> <li>Create the asynchronous <code>get</code> function</li> <li>Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you will call the <code>number</code> method which doesn't require any inputs. You can use <code>await</code> which will return the value requested once the request promise resolves</li> <li>Lastly, call the <code>get</code> function</li> </ol> <pre><code>// 1. Import the ABI\nconst { abi } = require('./compile');\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Contract address variable\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create contract instance\nconst incrementer = new ethers.Contract(contractAddress, abi, provider);\n\n// 5. Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // 6. Call contract \n  const data = await incrementer.number();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 7. Call get function\nget();\n</code></pre> View the complete script <pre><code>// Import ethers and compile\nconst ethers = require('ethers');\nconst { abi } = require('./compile');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Contract address variable\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create contract instance\nconst incrementer = new ethers.Contract(contractAddress, abi, provider);\n\n// Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // Call contract\n  const data = await incrementer.number();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// Call get function\nget();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node get.js\n</code></pre> <p>If successful, the value will be displayed in the terminal.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#interact-with-contract","title":"Interact with Contract (Send Methods)","text":"<p>Send methods are the type of interaction that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them <code>increment.js</code> and <code>reset.js</code>:</p> <pre><code>touch increment.js reset.js\n</code></pre> <p>Open the <code>increment.js</code> file and take the following steps to create the script:</p> <ol> <li>Import the <code>abi</code> from the <code>compile.js</code> file</li> <li>Set up the Ethers provider</li> <li>Define the <code>privateKey</code> for the origin account, the <code>contractAddress</code> of the deployed contract, and the <code>_value</code> to increment by. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create a wallet using the <code>privateKey</code> and <code>provider</code> from the previous steps. The wallet instance is used to sign transactions</li> <li>Create an instance of the contract using the <code>ethers.Contract</code> function and passing in the <code>contractAddress</code>, <code>abi</code>, and <code>provider</code></li> <li>Create the asynchronous <code>increment</code> function</li> <li>Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you will call the <code>increment</code> method which requires the value to increment by as an input. You can use <code>await</code> which will return the value requested once the request promise resolves</li> <li>Lastly, call the <code>increment</code> function</li> </ol> <pre><code>// 1. Import the contract ABI\nconst { abi } = require('./compile');\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// 4. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Create contract instance with signer\nconst incrementer = new ethers.Contract(contractAddress, abi, wallet);\n\n// 6. Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // 7. Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.increment(_value);\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// 8. Call the increment function\nincrement();\n</code></pre> View the complete script <pre><code>// Import ethers and compile\nconst ethers = require('ethers');\nconst { abi } = require('./compile');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create contract instance with signer\nconst incrementer = new ethers.Contract(contractAddress, abi, wallet);\n\n// Create reset function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.increment(_value);\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the reset function\nincrement();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node increment.js\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.js</code> script alongside the <code>increment.js</code> script to make sure that value is changing as expected:</p> node get.js Making a call to contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A The current number stored is: 5 node increment.js Calling the increment by 3 function in contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A Tx successful with hash: 0xc7fe935db03cfacf56c5649cd79a566d1a7b68417f904f0095a1b1c203875bf2 node get.js Making a call to contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A The current number stored is: 8 <p>Next you can open the <code>reset.js</code> file and take the following steps to create the script:</p> <ol> <li>Import the <code>abi</code> from the <code>compile.js</code> file</li> <li>Set up the Ethers provider</li> <li>Define the <code>privateKey</code> for the origin account and the <code>contractAddress</code> of the deployed contract. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create a wallet using the <code>privateKey</code> and <code>provider</code> from the previous steps. The wallet instance is used to sign transactions</li> <li>Create an instance of the contract using the <code>ethers.Contract</code> function and passing in the <code>contractAddress</code>, <code>abi</code>, and <code>provider</code></li> <li>Create the asynchronous <code>reset</code> function</li> <li>Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you will call the <code>reset</code> method which doesn't require any inputs. You can use <code>await</code> which will return the value requested once the request promise resolves</li> <li>Lastly, call the <code>reset</code> function</li> </ol> <pre><code>// 1. Import the contract ABI\nconst { abi } = require('./compile');\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Create contract instance with signer\nconst incrementer = new ethers.Contract(contractAddress, abi, wallet);\n\n// 6. Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // 7. sign and send tx and wait for receipt\n  const createReceipt = await incrementer.reset();\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// 8. Call the reset function\nreset();\n</code></pre> View the complete script <pre><code>// Import ethers and compile\nconst ethers = require('ethers');\nconst { abi } = require('./compile');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create contract instance with signer\nconst incrementer = new ethers.Contract(contractAddress, abi, wallet);\n\n// Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.reset();\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the reset function\nreset();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node reset.js\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.js</code> script alongside the <code>reset.js</code> script to make sure that value is changing as expected:</p> node get.js Making a call to contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A The current number stored is: 8 node reset.js Calling the reset function in contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A Tx successful with hash: 0xc452d21d8c2be6b81aadab7414103d68149c94a6399149ab8b79a58f0a3b5db7 node get.js Making a call to contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A The current number stored is: 0    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/libraries/ethersrs/","title":"Ethers.rs Rust Library","text":""},{"location":"builders/ethereum/libraries/ethersrs/#introduction","title":"Introduction","text":"<p>The Ethers.rs library provides a set of tools to interact with Ethereum Nodes via the Rust programming language that works similar to Ethers.js. Moonbeam has an Ethereum-like API available that is fully compatible with Ethereum-style JSON-RPC invocations. Therefore, developers can leverage this compatibility and use the Ethers.rs library to interact with a Moonbeam node as if they were doing so on Ethereum. You can read more about how to use Ethers.rs on their official crate documentation.</p> <p>In this guide, you'll learn how to use the Ethers.rs library to send a transaction and deploy a contract on Moonbase Alpha. This guide can be adapted for Moonbeam, Moonriver, or a Moonbeam development node.</p>"},{"location":"builders/ethereum/libraries/ethersrs/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> <li>Have Rust installed on your device</li> <li>Have solc installed on your device. Using solc-select is recommended by the Ethers.rs package</li> </ul> <p>Note</p> <p>The examples in this guide assumes you have a MacOS or Ubuntu 20.04-based environment and will need to be adapted accordingly for Windows.</p>"},{"location":"builders/ethereum/libraries/ethersrs/#create-a-rust-project","title":"Create a Rust Project","text":"<p>To get started, you can create a new Rust project with the Cargo tool:</p> <pre><code>cargo init ethers-examples &amp;&amp; cd ethers-examples\n</code></pre> <p>For this guide, you'll need to install the Ethers.rs library among others. To tell the Rust project to install it, you must edit the <code>Cargo.toml</code> file that was created with the project:</p> <pre><code>[package]\nname = \"ethers-examples\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nethers = \"1.0.2\"\nethers-solc = \"1.0.2\"\ntokio = { version = \"1\", features = [\"full\"] }\nserde_json = \"1.0.89\"\nserde = \"1.0.149\"\n</code></pre> <p>This example is using the <code>ethers</code> and <code>ethers-solc</code> crate versions <code>1.0.2</code> for RPC interactions and Solidity compiling. It also includes the <code>tokio</code> crate to run asynchronous Rust environments, since interacting with RPCs requires asynchronous code. Finally, it includes the <code>serde_json</code> and <code>serde</code> crates to help serialize/deserialize this example's code.</p> <p>If this is your first time using <code>solc-select</code>, you'll need to install and configure the Solidity version using the following commands:</p> <pre><code>solc-select install 0.8.17 &amp;&amp; solc-select use 0.8.17\n</code></pre>"},{"location":"builders/ethereum/libraries/ethersrs/#setting-up-the-ethers-provider-and-client","title":"Setting up the Ethers Provider and Client","text":"<p>Throughout this guide, you'll be writing multiple functions that provide different functionality such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts you'll need to use an Ethers provider or an Ethers signer client to interact with the network.</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>There are multiple ways to create a provider and signer, but the easiest way is through <code>try_from</code>. In the <code>src/main.rs</code> file, you can take the following steps:</p> <ol> <li>Import <code>Provider</code> and <code>Http</code> from the <code>ethers</code> crate</li> <li>Add a <code>Client</code> type for convenience, which will be used once you start to create the functions for sending a transaction and deploying a contract</li> <li>Add a <code>tokio</code> attribute above <code>async fn main()</code> for asynchronous execution</li> <li>Use <code>try_from</code> to attempt to instantiate a JSON-RPC provider object from an RPC endpoint</li> <li>Use a private key to create a wallet object (the private key will be used to sign transactions). Note: This is for example purposes only. Never store your private keys in a plain Rust file</li> <li>Wrap the provider and wallet together into a client by providing them to a <code>SignerMiddleware</code> object</li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>// 1. Import ethers crate\nuse ethers::providers::{Provider, Http};\n\n// 2. Add client type\ntype Client = SignerMiddleware&lt;Provider&lt;Http&gt;, Wallet&lt;k256::ecdsa::SigningKey&gt;&gt;;\n\n// 3. Add annotation\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // 4. Use try_from with RPC endpoint\n    let provider = Provider::&lt;Http&gt;::try_from(\n        \"INSERT_RPC_API_ENDPOINT\"\n    )?;\n    // 5. Use a private key to create a wallet\n    // Do not include the private key in plain text in any production code\n    // This is just for demonstration purposes\n    // Do not include '0x' at the start of the private key\n    let wallet: LocalWallet = \"INSERT_YOUR_PRIVATE_KEY\"\n        .parse::&lt;LocalWallet&gt;()?\n        .with_chain_id(Chain::Moonbeam);\n\n    // 6. Wrap the provider and wallet together to create a signer client\n    let client = SignerMiddleware::new(provider.clone(), wallet.clone());\n    Ok(())\n}\n</code></pre> <pre><code>// 1. Import ethers crate\nuse ethers::providers::{Provider, Http};\n\n// 2. Add client type\ntype Client = SignerMiddleware&lt;Provider&lt;Http&gt;, Wallet&lt;k256::ecdsa::SigningKey&gt;&gt;;\n\n// 3. Add annotation\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // 4. Use try_from with RPC endpoint\n    let provider = Provider::&lt;Http&gt;::try_from(\n        \"INSERT_RPC_API_ENDPOINT\"\n    )?;\n    // 5. Use a private key to create a wallet\n    // Do not include the private key in plain text in any production code\n    // This is just for demonstration purposes\n    // Do not include '0x' at the start of the private key\n    let wallet: LocalWallet = \"INSERT_YOUR_PRIVATE_KEY\"\n        .parse::&lt;LocalWallet&gt;()?\n        .with_chain_id(Chain::Moonriver);\n\n    // 6. Wrap the provider and wallet together to create a signer client\n    let client = SignerMiddleware::new(provider.clone(), wallet.clone());\n    Ok(())\n}\n</code></pre> <pre><code>// 1. Import ethers crate\nuse ethers::providers::{Provider, Http};\n\n// 2. Add client type\ntype Client = SignerMiddleware&lt;Provider&lt;Http&gt;, Wallet&lt;k256::ecdsa::SigningKey&gt;&gt;;\n\n// 3. Add annotation\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // 4. Use try_from with RPC endpoint\n    let provider = Provider::&lt;Http&gt;::try_from(\n        \"https://rpc.api.moonbase.moonbeam.network\"\n    )?;\n    // 5. Use a private key to create a wallet\n    // Do not include the private key in plain text in any production code\n    // This is just for demonstration purposes\n    // Do not include '0x' at the start of the private key\n    let wallet: LocalWallet = \"INSERT_YOUR_PRIVATE_KEY\"\n        .parse::&lt;LocalWallet&gt;()?\n        .with_chain_id(Chain::Moonbase);\n\n    // 6. Wrap the provider and wallet together to create a signer client\n    let client = SignerMiddleware::new(provider.clone(), wallet.clone());\n    Ok(())\n}\n</code></pre> <pre><code>// 1. Import ethers crate\nuse ethers::providers::{Provider, Http};\n\n// 2. Add client type\ntype Client = SignerMiddleware&lt;Provider&lt;Http&gt;, Wallet&lt;k256::ecdsa::SigningKey&gt;&gt;;\n\n// 3. Add annotation\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // 4. Use try_from with RPC endpoint\n    let provider = Provider::&lt;Http&gt;::try_from(\n        \"http://127.0.0.1:9944\"\n    )?;\n    // 5. Use a private key to create a wallet\n    // Do not include the private key in plain text in any production code\n    // This is just for demonstration purposes\n    // Do not include '0x' at the start of the private key\n    let wallet: LocalWallet = \"INSERT_YOUR_PRIVATE_KEY\"\n        .parse::&lt;LocalWallet&gt;()?\n        .with_chain_id(Chain::MoonbeamDev);\n\n    // 6. Wrap the provider and wallet together to create a signer client\n    let client = SignerMiddleware::new(provider.clone(), wallet.clone());\n    Ok(())\n}\n</code></pre>"},{"location":"builders/ethereum/libraries/ethersrs/#send-a-transaction","title":"Send a Transaction","text":"<p>During this section, you'll be creating a couple of functions, which will be contained in the same <code>main.rs</code> file to avoid additional complexity from implementing modules. The first function will be to check the balances of your accounts before trying to send a transaction. The second function will actually send the transaction. To run each of these functions, you will edit the <code>main</code> function and run the <code>main.rs</code> script.  </p> <p>You should already have your provider and client set up in <code>main.rs</code> in the way described in the previous section. In order to send a transaction, you'll need to add a few more lines of code:</p> <ol> <li>Add <code>use ethers::{utils, prelude::*};</code> to your imports, which will provide you access to utility functions and the prelude imports all of the necessary data types and traits</li> <li>As you'll be sending a transaction from one address to another, you can specify the sending and receiving addresses in the <code>main</code> function. Note: the <code>address_from</code> value should correspond to the private key that is used in the <code>main</code> function</li> </ol> <pre><code>// ...\n// 1. Add to imports\nuse ethers::{utils, prelude::*};\n\n// ...\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // ...\n\n    // 2. Add from and to address\n    let address_from = \"YOUR_FROM_ADDRESS\".parse::&lt;Address&gt;()?\n    let address_to = \"YOUR_TO_ADDRESS\".parse::&lt;Address&gt;()?\n}\n</code></pre>"},{"location":"builders/ethereum/libraries/ethersrs/#check-balances-function","title":"Check Balances Function","text":"<p>Next, you will create the function for getting the sending and receiving accounts' balances by completing the following steps:</p> <ol> <li>Create a new asynchronous function named <code>print_balances</code> that takes a provider object's reference and the sending and receiving addresses as input</li> <li>Use the <code>provider</code> object's <code>get_balance</code> function to get the balances of the sending and receiving addresses of the transaction</li> <li>Print the resultant balances for the sending and receiving addresses</li> <li>Call the <code>print_balances</code> function in the <code>main</code> function</li> </ol> <pre><code>// ...\n\n// 1. Create an asynchronous function that takes a provider reference and from and to address as input\nasync fn print_balances(provider: &amp;Provider&lt;Http&gt;, address_from: Address, address_to: Address) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // 2. Use the get_balance function\n    let balance_from = provider.get_balance(address_from, None).await?;\n    let balance_to = provider.get_balance(address_to, None).await?;\n\n    // 3. Print the resultant balance\n    println!(\"{} has {}\", address_from, balance_from);\n    println!(\"{} has {}\", address_to, balance_to);\n\n    Ok(())\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // ...\n\n    // 4. Call print_balances function in main\n    print_balances(&amp;provider).await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"builders/ethereum/libraries/ethersrs/#send-transaction-script","title":"Send Transaction Script","text":"<p>For this example, you'll be transferring 1 DEV from an origin address (of which you hold the private key) to another address.  </p> <ol> <li>Create a new asynchronous function named <code>send_transaction</code> that takes a client object's reference and the sending and receiving addresses as input</li> <li>Create the transaction object, and include the <code>to</code>, <code>value</code>, and <code>from</code>. When writing the <code>value</code> input, use the <code>ethers::utils::parse_ether</code> function</li> <li>Use the <code>client</code> object to send the transaction</li> <li>Print the transaction after it is confirmed</li> <li>Call the <code>send_transaction</code> function in the <code>main</code> function</li> </ol> <pre><code>// ...\n\n// 1. Define an asynchronous function that takes a client provider and the from and to addresses as input\nasync fn send_transaction(client: &amp;Client, address_from: Address, address_to: Address) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\n        \"Beginning transfer of 1 native currency from {} to {}.\",\n        address_from, address_to\n    );\n\n    // 2. Create a TransactionRequest object\n    let tx = TransactionRequest::new()\n        .to(address_to)\n        .value(U256::from(utils::parse_ether(1)?))\n        .from(address_from);\n\n    // 3. Send the transaction with the client\n    let tx = client.send_transaction(tx, None).await?.await?;\n\n    // 4. Print out the result\n    println!(\"Transaction Receipt: {}\", serde_json::to_string(&amp;tx)?);\n\n    Ok(())\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // ...\n\n    // 5. Call send_transaction function in main\n    send_transaction(&amp;client, address_from, address_to).await?;\n\n    Ok(())\n}\n</code></pre> View the complete script <pre><code>use ethers::providers::{Provider, Http};\nuse ethers::{utils, prelude::*};\n\ntype Client = SignerMiddleware&lt;Provider&lt;Http&gt;, Wallet&lt;k256::ecdsa::SigningKey&gt;&gt;;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let provider: Provider&lt;Http&gt; = Provider::&lt;Http&gt;::try_from(\"https://rpc.api.moonbase.moonbeam.network\")?; // Change to correct network\n    // Do not include the private key in plain text in any production code. This is just for demonstration purposes\n    let wallet: LocalWallet = \"INSERT_PRIVATE_KEY\"\n        .parse::&lt;LocalWallet&gt;()?\n        .with_chain_id(Chain::Moonbase);  // Change to correct network\n    let client = SignerMiddleware::new(provider.clone(), wallet.clone());\n\n    let address_from = \"INSERT_FROM_ADDRESS\".parse::&lt;Address&gt;()?;\n    let address_to = \"INSERT_TO_ADDRESS\".parse::&lt;Address&gt;()?;\n\n    send_transaction(&amp;client, &amp;address_from, &amp;address_to).await?;\n    print_balances(&amp;provider, &amp;address_from, &amp;address_to).await?;\n\n    Ok(())\n}\n\n// Print the balance of a wallet\nasync fn print_balances(provider: &amp;Provider&lt;Http&gt;, address_from: &amp;Address, address_to: &amp;Address) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let balance_from = provider.get_balance(address_from.clone(), None).await?;\n    let balance_to = provider.get_balance(address_to.clone(), None).await?;\n\n    println!(\"{} has {}\", address_from, balance_from);\n    println!(\"{} has {}\", address_to, balance_to);\n    Ok(())\n}\n\n\n// Sends some native currency\nasync fn send_transaction(client: &amp;Client, address_from: &amp;Address, address_to: &amp;Address) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\n        \"Beginning transfer of 1 native currency {} to {}.\",\n        address_from, address_to\n    );\n    let tx = TransactionRequest::new()\n        .to(address_to.clone())\n        .value(U256::from(utils::parse_ether(1)?))\n        .from(address_from.clone());\n    let tx = client.send_transaction(tx, None).await?.await?;\n\n    println!(\"Transaction Receipt: {}\", serde_json::to_string(&amp;tx)?);\n\n    Ok(())\n}\n</code></pre> <p>To run the script, which will send the transaction and then check the balances once the transaction has been sent, you can run the following command:</p> <pre><code>cargo run\n</code></pre> <p>If the transaction was successful, in your terminal you'll see the transaction details printed out along with the balance of your address.</p> cargo run Compiling ethers-examples v0.1.0 (/Users/moonbeam/workspace/ethers-examples) Finished dev [unoptimized + debuginfo] target(s) in 32.76s Running `target/debug/ethers-examples` Beginning transfer of 1 native currency 0x3b93\u2026421e to 0xe773\u20268dde. Transaction Receipt: {\"transactionHash\":\"0x6f2338c63286f8b27951ddb6748191149d82647b44a00465f1f776624f490ce9\",\"transactionIndex\":\"0x0\",\"blockHash\":\"0x8234eb2083e649ab45c7c5fcdf2026d8f47676f7e29305023d1d00cc349ba215\",\"blockNumber\":\"0x7ac12d\",\"from\":\"0x3b939fead1557c741ff06492fd0127bd287a421e\",\"to\":\"0xe773f740828a968c8a9e1e8e05db486937768dde\",\"cumulativeGasUsed\":\"0x5208\",\"gasUsed\":\"0x5208\",\"contractAddress\":null,\"logs\":[],\"status\":\"0x1\",\"logsBloom\":\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\"type\":\"0x0\",\"effectiveGasPrice\":\"0x7735940\"} 0x3b93\u2026421e has 3601703984470865589125 0xe773\u20268dde has 1000000000000000000"},{"location":"builders/ethereum/libraries/ethersrs/#deploy-a-contract","title":"Deploy a Contract","text":"<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (the default is <code>0</code>). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only and does not handle values wrapping around.</p> <p>During the rest of this section, you'll be creating a couple of functions, which will be contained in the <code>main.rs</code> file to avoid additional complexity from implementing modules. The first function will be to compile and deploy the contract. The remaining functions will interact with the deployed contract.  </p> <p>You should already have your provider and client set up in <code>main.rs</code> in the way described in the Setting up the Ethers Provider and Client section.</p> <p>Before getting started with the contract deployment, you'll need to add a few more imports to your <code>main.rs</code> file:</p> <pre><code>use ethers_solc::Solc;\nuse ethers::{prelude::*};\nuse std::{path::Path, sync::Arc};\n</code></pre> <p>The <code>ethers_solc</code> import will be used to compile the smart contract. The <code>prelude</code> from Ethers imports some necessary data types and traits. Lastly, the <code>std</code> imports will enables you to store your smart contracts and wrap the client into an <code>Arc</code> type for thread safety.</p>"},{"location":"builders/ethereum/libraries/ethersrs/#compile-and-deploy-contract-script","title":"Compile and Deploy Contract Script","text":"<p>This example function will compile and deploy the <code>Incrementer.sol</code> smart contract you created in the previous section. The <code>Incrementer.sol</code> smart contract should be in the root directory. In the <code>main.rs</code> file, you can take the following steps:</p> <ol> <li>Create a new asynchronous function named <code>compile_deploy_contract</code> that takes a client object's reference as input, and returns an address in the form of <code>H160</code></li> <li>Define a variable named <code>source</code> as the path for the directory that hosts all of the smart contracts that should be compiled, which is the root directory</li> <li>Use the <code>Solc</code> crate to compile all of the smart contracts in the root directory</li> <li>Get the ABI and bytecode from the compiled result, searching for the <code>Incrementer.sol</code> contract</li> <li>Create a contract factory for the smart contract using the ABI, bytecode, and client. The client must be wrapped into an <code>Arc</code> type for thread safety</li> <li>Use the factory to deploy. For this example, the value <code>5</code> is used as the initial value in the constructor</li> <li>Print out the address after the deployment</li> <li>Return the address</li> <li>Call the <code>compile_deploy_contract</code> function in <code>main</code></li> </ol> <pre><code>// ...\n\n// 1. Define an asynchronous function that takes a client provider as input and returns H160\nasync fn compile_deploy_contract(client: &amp;Client) -&gt; Result&lt;H160, Box&lt;dyn std::error::Error&gt;&gt; {\n    // 2. Define a path as the directory that hosts the smart contracts in the project\n    let source = Path::new(&amp;env!(\"CARGO_MANIFEST_DIR\"));\n\n    // 3. Compile all of the smart contracts\n    let compiled = Solc::default()\n        .compile_source(source)\n        .expect(\"Could not compile contracts\");\n\n    // 4. Get ABI &amp; Bytecode for Incrementer.sol\n    let (abi, bytecode, _runtime_bytecode) = compiled\n        .find(\"Incrementer\")\n        .expect(\"could not find contract\")\n        .into_parts_or_default();\n\n    // 5. Create a contract factory which will be used to deploy instances of the contract\n    let factory = ContractFactory::new(abi, bytecode, Arc::new(client.clone()));\n\n    // 6. Deploy\n    let contract = factory.deploy(U256::from(5))?.send().await?;\n\n    // 7. Print out the address\n    let addr = contract.address();\n    println!(\"Incrementer.sol has been deployed to {:?}\", addr);\n\n    // 8. Return the address\n    Ok(addr)\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // ...\n\n    // 9. Call compile_deploy_contract function in main\n    let addr = compile_deploy_contract(&amp;client).await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"builders/ethereum/libraries/ethersrs/#read-contract-data","title":"Read Contract Data (Call Methods)","text":"<p>Call methods are the type of interaction that don't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.  </p> <p>Rust is typesafe, which is why the ABI for the <code>Incrementer.sol</code> contract is required to generate a typesafe Rust struct. For this example, you should create a new file in the root of the Cargo project called <code>Incrementer_ABI.json</code>:</p> <pre><code>touch Incrementer_ABI.json\n</code></pre> <p>The ABI for <code>Incrementer.sol</code> is below, which should be copied and pasted into the <code>Incrementer_ABI.json</code> file:</p> <pre><code>[\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"_value\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"increment\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"number\",\n        \"outputs\": [\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"reset\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    }\n]\n</code></pre> <p>Then you can take the following steps to create a function that reads and returns the <code>number</code> method of the <code>Incrementer.sol</code> contract:</p> <ol> <li>Generate a type-safe interface for the <code>Incrementer</code> smart contract with the <code>abigen</code> macro</li> <li>Create a new asynchronous function named <code>read_number</code> that takes a client object's reference and a contract address reference as input, and returns a U256</li> <li>Create a new instance of the <code>Incrementer</code> object generated by the abigen macro with the client and contract address values</li> <li>Call the <code>number</code> function in the new <code>Incrementer</code> object</li> <li>Print out the resultant value</li> <li>Return the resultant value</li> <li>Call the <code>read_number</code> function in <code>main</code></li> </ol> <pre><code>// ...\n\n// 1. Generate a type-safe interface for the Incrementer smart contract\nabigen!(\n    Incrementer,\n    \"./Incrementer_ABI.json\",\n    event_derives(serde::Deserialize, serde::Serialize)\n);\n\n// 2. Define an asynchronous function that takes a client provider and address as input and returns a U256\nasync fn read_number(client: &amp;Client, contract_addr: &amp;H160) -&gt; Result&lt;U256, Box&lt;dyn std::error::Error&gt;&gt; {\n    // 3. Create contract instance\n    let contract = Incrementer::new(contract_addr.clone(), Arc::new(client.clone()));\n\n    // 4. Call contract's number function\n    let value = contract.number().call().await?;\n\n    // 5. Print out number\n    println!(\"Incrementer's number is {}\", value);\n\n    // 6. Return the number\n    Ok(value)\n}\n\n// ...\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // ...\n\n    // 7. Call read_number function in main\n    read_number(&amp;client, &amp;addr).await?;\n\n    Ok(())\n}\n</code></pre> View the complete script <pre><code>use ethers::providers::{Provider, Http};\nuse ethers::{prelude::*};\nuse ethers_solc::Solc;\nuse std::{path::Path, sync::Arc};\n\ntype Client = SignerMiddleware&lt;Provider&lt;Http&gt;, Wallet&lt;k256::ecdsa::SigningKey&gt;&gt;;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let provider: Provider&lt;Http&gt; = Provider::&lt;Http&gt;::try_from(\"https://rpc.api.moonbase.moonbeam.network\")?; // Change to correct network\n    // Do not include the private key in plain text in any production code. This is just for demonstration purposes\n    // Do not include '0x' at the start of the private key\n    let wallet: LocalWallet = \"INSERT_PRIVATE_KEY\"\n        .parse::&lt;LocalWallet&gt;()?\n        .with_chain_id(Chain::Moonbase);\n    let client = SignerMiddleware::new(provider.clone(), wallet.clone());\n\n    // Deploy contract and read initial incrementer value\n    let addr = compile_deploy_contract(&amp;client).await?;\n    read_number(&amp;client, &amp;addr).await?;\n\n    // Increment and read the incremented number\n    increment_number(&amp;client, &amp;addr).await?;\n    read_number(&amp;client, &amp;addr).await?;\n\n    // Reset the incremented number and read it\n    reset(&amp;client, &amp;addr).await?;\n    read_number(&amp;client, &amp;addr).await?;\n\n    Ok(())\n}\n\n// Need to install solc for this tutorial: https://github.com/crytic/solc-select\nasync fn compile_deploy_contract(client: &amp;Client) -&gt; Result&lt;H160, Box&lt;dyn std::error::Error&gt;&gt; {\n    // Incrementer.sol is located in the root directory\n    let source = Path::new(&amp;env!(\"INSERT_CARGO_MANIFEST_DIR\"));\n\n    // Compile it\n    let compiled = Solc::default()\n        .compile_source(source)\n        .expect(\"Could not compile contracts\");\n\n    // Get ABI &amp; Bytecode for Incrementer.sol\n    let (abi, bytecode, _runtime_bytecode) = compiled\n        .find(\"Incrementer\")\n        .expect(\"could not find contract\")\n        .into_parts_or_default();\n\n    // Create a contract factory which will be used to deploy instances of the contract\n    let factory = ContractFactory::new(abi, bytecode, Arc::new(client.clone()));\n\n    // Deploy\n    let contract = factory.deploy(U256::from(5))?.send().await?;\n    let addr = contract.address();\n\n    println!(\"Incrementer.sol has been deployed to {:?}\", addr);\n\n    Ok(addr)\n}\n\n// Generates a type-safe interface for the Incrementer smart contract\nabigen!(\n    Incrementer,\n    \"./Incrementer_ABI.json\",\n    event_derives(serde::Deserialize, serde::Serialize)\n);\n\nasync fn read_number(client: &amp;Client, contract_addr: &amp;H160) -&gt; Result&lt;U256, Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create contract instance\n    let contract = Incrementer::new(contract_addr.clone(), Arc::new(client.clone()));\n\n    // Call contract's number function\n    let value = contract.number().call().await?;\n\n    // Print out value\n    println!(\"Incrementer's number is {}\", value);\n\n    Ok(value)\n}\n\nasync fn increment_number(client: &amp;Client, contract_addr: &amp;H160) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"Incrementing number...\");\n\n    // Create contract instance\n    let contract = Incrementer::new(contract_addr.clone(), Arc::new(client.clone()));\n\n    // Send contract transaction\n    let tx = contract.increment(U256::from(5)).send().await?.await?;\n    println!(\"Transaction Receipt: {}\", serde_json::to_string(&amp;tx)?);\n\n    Ok(())\n}\n\nasync fn reset(client: &amp;Client, contract_addr: &amp;H160) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"Resetting number...\");\n\n    // Create contract instance\n    let contract = Incrementer::new(contract_addr.clone(), Arc::new(client.clone()));\n\n    // Send contract transaction\n    let tx = contract.reset().send().await?.await?;\n    println!(\"Transaction Receipt: {}\", serde_json::to_string(&amp;tx)?);\n\n    Ok(())\n}\n</code></pre> <p>To run the script, which will deploy the contract and return the current value stored in the <code>Incrementer</code> contract, you can enter the following command into your terminal:</p> <pre><code>cargo run\n</code></pre> <p>If successful, you'll see the deployed contract's address and initial value set, which should be <code>5</code>, displayed in the terminal.</p> cargo run Compiling ethers-examples v0.1.0 (/Users/moonbeam/workspace/ethers-examples) Finished dev [unoptimized + debuginfo] target(s) in 1.09s Running `/Users/moonbeam/workspace/ethers-examples/target/debug/ethers-examples` Incrementer.sol has been deployed to 0xeb8a4d5c7cd56c65c9dbd25f793b50a2c917bb5d Incrementer's number is 5"},{"location":"builders/ethereum/libraries/ethersrs/#interact-with-contract","title":"Interact with Contract (Send Methods)","text":"<p>Send methods are the type of interaction that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two functions: one to increment and one to reset the incrementer. This section will also require the <code>Incrementer_ABI.json</code> file initialized when reading from the smart contract.  </p> <p>Take the following steps to create the function to increment:</p> <ol> <li>Ensure that the abigen macro is called for the <code>Incrementer_ABI.json</code> somewhere in the <code>main.rs</code> file (if it is already in the <code>main.rs</code> file, you do not have to have a second one)</li> <li>Create a new asynchronous function named <code>increment_number</code> that takes a client object's reference and an address as input</li> <li>Create a new instance of the <code>Incrementer</code> object generated by the abigen macro with the client and contract address values</li> <li>Call the <code>increment</code> function in the new <code>Incrementer</code> object by including a <code>U256</code> object as input. In this instance, the value provided is <code>5</code></li> <li>Call the <code>read_number</code> function in <code>main</code></li> </ol> <pre><code>// ...\n\n// 1. Generate a type-safe interface for the Incrementer smart contract\nabigen!(\n    Incrementer,\n    \"./Incrementer_ABI.json\",\n    event_derives(serde::Deserialize, serde::Serialize)\n);\n\n// 2. Define an asynchronous function that takes a client provider and address as input\nasync fn increment_number(client: &amp;Client, contract_addr: &amp;H160) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"Incrementing number...\");\n\n    // 3. Create contract instance\n    let contract = Incrementer::new(contract_addr.clone(), Arc::new(client.clone()));\n\n    // 4. Send contract transaction\n    let tx = contract.increment(U256::from(5)).send().await?.await?;\n    println!(\"Transaction Receipt: {}\", serde_json::to_string(&amp;tx)?);\n\n    Ok(())\n}\n\n// ...\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // ...\n\n    // 5. Call increment_number function in main\n    increment_number(&amp;client, &amp;addr).await?;\n\n    Ok(())\n}\n</code></pre> View the complete script <pre><code>use ethers::providers::{Provider, Http};\nuse ethers::{prelude::*};\nuse ethers_solc::Solc;\nuse std::{path::Path, sync::Arc};\n\ntype Client = SignerMiddleware&lt;Provider&lt;Http&gt;, Wallet&lt;k256::ecdsa::SigningKey&gt;&gt;;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let provider: Provider&lt;Http&gt; = Provider::&lt;Http&gt;::try_from(\"https://rpc.api.moonbase.moonbeam.network\")?; // Change to correct network\n    // Do not include the private key in plain text in any production code. This is just for demonstration purposes\n    // Do not include '0x' at the start of the private key\n    let wallet: LocalWallet = \"INSERT_PRIVATE_KEY\"\n        .parse::&lt;LocalWallet&gt;()?\n        .with_chain_id(Chain::Moonbase);\n    let client = SignerMiddleware::new(provider.clone(), wallet.clone());\n\n    // Deploy contract and read initial incrementer value\n    let addr = compile_deploy_contract(&amp;client).await?;\n    read_number(&amp;client, &amp;addr).await?;\n\n    // Increment and read the incremented number\n    increment_number(&amp;client, &amp;addr).await?;\n    read_number(&amp;client, &amp;addr).await?;\n\n    // Reset the incremented number and read it\n    reset(&amp;client, &amp;addr).await?;\n    read_number(&amp;client, &amp;addr).await?;\n\n    Ok(())\n}\n\n// Need to install solc for this tutorial: https://github.com/crytic/solc-select\nasync fn compile_deploy_contract(client: &amp;Client) -&gt; Result&lt;H160, Box&lt;dyn std::error::Error&gt;&gt; {\n    // Incrementer.sol is located in the root directory\n    let source = Path::new(&amp;env!(\"INSERT_CARGO_MANIFEST_DIR\"));\n\n    // Compile it\n    let compiled = Solc::default()\n        .compile_source(source)\n        .expect(\"Could not compile contracts\");\n\n    // Get ABI &amp; Bytecode for Incrementer.sol\n    let (abi, bytecode, _runtime_bytecode) = compiled\n        .find(\"Incrementer\")\n        .expect(\"could not find contract\")\n        .into_parts_or_default();\n\n    // Create a contract factory which will be used to deploy instances of the contract\n    let factory = ContractFactory::new(abi, bytecode, Arc::new(client.clone()));\n\n    // Deploy\n    let contract = factory.deploy(U256::from(5))?.send().await?;\n    let addr = contract.address();\n\n    println!(\"Incrementer.sol has been deployed to {:?}\", addr);\n\n    Ok(addr)\n}\n\n// Generates a type-safe interface for the Incrementer smart contract\nabigen!(\n    Incrementer,\n    \"./Incrementer_ABI.json\",\n    event_derives(serde::Deserialize, serde::Serialize)\n);\n\nasync fn read_number(client: &amp;Client, contract_addr: &amp;H160) -&gt; Result&lt;U256, Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create contract instance\n    let contract = Incrementer::new(contract_addr.clone(), Arc::new(client.clone()));\n\n    // Call contract's number function\n    let value = contract.number().call().await?;\n\n    // Print out value\n    println!(\"Incrementer's number is {}\", value);\n\n    Ok(value)\n}\n\nasync fn increment_number(client: &amp;Client, contract_addr: &amp;H160) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"Incrementing number...\");\n\n    // Create contract instance\n    let contract = Incrementer::new(contract_addr.clone(), Arc::new(client.clone()));\n\n    // Send contract transaction\n    let tx = contract.increment(U256::from(5)).send().await?.await?;\n    println!(\"Transaction Receipt: {}\", serde_json::to_string(&amp;tx)?);\n\n    Ok(())\n}\n\nasync fn reset(client: &amp;Client, contract_addr: &amp;H160) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"Resetting number...\");\n\n    // Create contract instance\n    let contract = Incrementer::new(contract_addr.clone(), Arc::new(client.clone()));\n\n    // Send contract transaction\n    let tx = contract.reset().send().await?.await?;\n    println!(\"Transaction Receipt: {}\", serde_json::to_string(&amp;tx)?);\n\n    Ok(())\n}\n</code></pre> <p>To run the script, you can enter the following command into your terminal:</p> <pre><code>cargo run\n</code></pre> <p>If successful, the transaction receipt will be displayed in the terminal. You can use the <code>read_number</code> function in the <code>main</code> function to make sure that value is changing as expected. If you're using the <code>read_number</code> function after incrementing, you'll also see the incremented number, which should be <code>10</code>.</p> cargo run Compiling ethers-examples v0.1.0 (/Users/moonbeam/workspace/ethers-examples) Finished dev [unoptimized + debuginfo] target(s) in 1.09s Running `/Users/moonbeam/workspace/ethers-examples/target/debug/ethers-examples` Incrementer.sol has been deployed to 0xeb8a4d5c7cd56c65c9dbd25f793b50a2c917bb5d Incrementer's number is 5 Incrementing number... Transaction Receipt: {\"transactionHash\":\"0x6f5c204e74b96b6cf6057512ba142ad727718646d4ebb7abe8bbabada198dafb\",\"transactionIndex\":\"0x0\",\"blockHash\":\"0x635a8a234b30c6ee907198ddda3a1478ae52c6adbcc4a67353dd9597ee626950\",\"blockNumber\":\"0x7ac238\",\"from\":\"0x3b939fead1557c741ff06492fd0127bd287a421e\",\"to\":\"0xeb8a4d5c7cd56c65c9dbd25f793b50a2c917bb5d\",\"cumulativeGasUsed\":\"0x68a6\",\"gasUsed\":\"0x68a6\",\"contractAddress\":null,\"logs\":[],\"status\":\"0x1\",\"logsBloom\":\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\"type\":\"0x2\",\"effectiveGasPrice\":\"0xba43b740\"} Incrementer's number is 10 <p>Next you can interact with the <code>reset</code> function:</p> <ol> <li>Ensure that the abigen macro is called for the <code>Incrementer_ABI.json</code> somewhere in the <code>main.rs</code> file (if it is already in the <code>main.rs</code> file, you do not have to have a second one)</li> <li>Create a new asynchronous function named <code>reset</code> that takes a client object's reference and an address as input</li> <li>Create a new instance of the <code>Incrementer</code> object generated by the abigen macro with the client and contract address values</li> <li>Call the <code>reset</code> function in the new <code>Incrementer</code> object</li> <li>Call the <code>reset</code> function in <code>main</code></li> </ol> <pre><code>// ...\n\n// 1. Generate a type-safe interface for the Incrementer smart contract\nabigen!(\n    Incrementer,\n    \"./Incrementer_ABI.json\",\n    event_derives(serde::Deserialize, serde::Serialize)\n);\n\n// 2. Define an asynchronous function that takes a client provider and address as input\nasync fn reset(client: &amp;Client, contract_addr: &amp;H160) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"Resetting number...\");\n\n    // 3. Create contract instance\n    let contract = Incrementer::new(contract_addr.clone(), Arc::new(client.clone()));\n\n    // 4. Send contract transaction\n    let tx = contract.reset().send().await?.await?;\n    println!(\"Transaction Receipt: {}\", serde_json::to_string(&amp;tx)?);\n\n    Ok(())\n}\n\n// ...\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // ...\n\n    // 5. Call reset function in main\n    reset(&amp;client, &amp;addr).await?;\n\n    Ok(())\n}\n</code></pre> <p>If successful, the transaction receipt will be displayed in the terminal. You can use the <code>read_number</code> function in the <code>main</code> function to make sure that value is changing as expected. If you're using the <code>read_number</code> function after resetting the number, you should see <code>0</code> printed to the terminal.</p> cargo run Compiling ethers-examples v0.1.0 (/Users/moonbeam/workspace/ethers-examples) Finished dev [unoptimized + debuginfo] target(s) in 1.09s Running `/Users/moonbeam/workspace/ethers-examples/target/debug/ethers-examples` Incrementer.sol has been deployed to 0xeb8a4d5c7cd56c65c9dbd25f793b50a2c917bb5d Incrementer's number is 5 Incrementing number... Transaction Receipt: {\"transactionHash\":\"0x6f5c204e74b96b6cf6057512ba142ad727718646d4ebb7abe8bbabada198dafb\",\"transactionIndex\":\"0x0\",\"blockHash\":\"0x635a8a234b30c6ee907198ddda3a1478ae52c6adbcc4a67353dd9597ee626950\",\"blockNumber\":\"0x7ac238\",\"from\":\"0x3b939fead1557c741ff06492fd0127bd287a421e\",\"to\":\"0xeb8a4d5c7cd56c65c9dbd25f793b50a2c917bb5d\",\"cumulativeGasUsed\":\"0x68a6\",\"gasUsed\":\"0x68a6\",\"contractAddress\":null,\"logs\":[],\"status\":\"0x1\",\"logsBloom\":\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\"type\":\"0x2\",\"effectiveGasPrice\":\"0xba43b740\"} Incrementer's number is 10 Resetting number... Transaction Receipt: {\"transactionHash\":\"0xf1010597c6ab3d3cfcd6e8e68bf2eddf4ed38eb93a3052591c88b675ed1e83a4\",\"transactionIndex\":\"0x0\",\"blockHash\":\"0x5d4c09abf104cbd88e80487c170d8709aae7475ca84c1f3396f3e35222fbe87f\",\"blockNumber\":\"0x7ac23b\",\"from\":\"0x3b939fead1557c741ff06492fd0127bd287a421e\",\"to\":\"0xeb8a4d5c7cd56c65c9dbd25f793b50a2c917bb5d\",\"cumulativeGasUsed\":\"0x53c4\",\"gasUsed\":\"0x53c4\",\"contractAddress\":null,\"logs\":[],\"status\":\"0x1\",\"logsBloom\":\"0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\"type\":\"0x2\",\"effectiveGasPrice\":\"0xba43b740\"} Incrementer's number is 0 View the complete script <pre><code>use ethers::providers::{Provider, Http};\nuse ethers::{prelude::*};\nuse ethers_solc::Solc;\nuse std::{path::Path, sync::Arc};\n\ntype Client = SignerMiddleware&lt;Provider&lt;Http&gt;, Wallet&lt;k256::ecdsa::SigningKey&gt;&gt;;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let provider: Provider&lt;Http&gt; = Provider::&lt;Http&gt;::try_from(\"https://rpc.api.moonbase.moonbeam.network\")?; // Change to correct network\n    // Do not include the private key in plain text in any production code. This is just for demonstration purposes\n    // Do not include '0x' at the start of the private key\n    let wallet: LocalWallet = \"INSERT_PRIVATE_KEY\"\n        .parse::&lt;LocalWallet&gt;()?\n        .with_chain_id(Chain::Moonbase);\n    let client = SignerMiddleware::new(provider.clone(), wallet.clone());\n\n    // Deploy contract and read initial incrementer value\n    let addr = compile_deploy_contract(&amp;client).await?;\n    read_number(&amp;client, &amp;addr).await?;\n\n    // Increment and read the incremented number\n    increment_number(&amp;client, &amp;addr).await?;\n    read_number(&amp;client, &amp;addr).await?;\n\n    // Reset the incremented number and read it\n    reset(&amp;client, &amp;addr).await?;\n    read_number(&amp;client, &amp;addr).await?;\n\n    Ok(())\n}\n\n// Need to install solc for this tutorial: https://github.com/crytic/solc-select\nasync fn compile_deploy_contract(client: &amp;Client) -&gt; Result&lt;H160, Box&lt;dyn std::error::Error&gt;&gt; {\n    // Incrementer.sol is located in the root directory\n    let source = Path::new(&amp;env!(\"INSERT_CARGO_MANIFEST_DIR\"));\n\n    // Compile it\n    let compiled = Solc::default()\n        .compile_source(source)\n        .expect(\"Could not compile contracts\");\n\n    // Get ABI &amp; Bytecode for Incrementer.sol\n    let (abi, bytecode, _runtime_bytecode) = compiled\n        .find(\"Incrementer\")\n        .expect(\"could not find contract\")\n        .into_parts_or_default();\n\n    // Create a contract factory which will be used to deploy instances of the contract\n    let factory = ContractFactory::new(abi, bytecode, Arc::new(client.clone()));\n\n    // Deploy\n    let contract = factory.deploy(U256::from(5))?.send().await?;\n    let addr = contract.address();\n\n    println!(\"Incrementer.sol has been deployed to {:?}\", addr);\n\n    Ok(addr)\n}\n\n// Generates a type-safe interface for the Incrementer smart contract\nabigen!(\n    Incrementer,\n    \"./Incrementer_ABI.json\",\n    event_derives(serde::Deserialize, serde::Serialize)\n);\n\nasync fn read_number(client: &amp;Client, contract_addr: &amp;H160) -&gt; Result&lt;U256, Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create contract instance\n    let contract = Incrementer::new(contract_addr.clone(), Arc::new(client.clone()));\n\n    // Call contract's number function\n    let value = contract.number().call().await?;\n\n    // Print out value\n    println!(\"Incrementer's number is {}\", value);\n\n    Ok(value)\n}\n\nasync fn increment_number(client: &amp;Client, contract_addr: &amp;H160) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"Incrementing number...\");\n\n    // Create contract instance\n    let contract = Incrementer::new(contract_addr.clone(), Arc::new(client.clone()));\n\n    // Send contract transaction\n    let tx = contract.increment(U256::from(5)).send().await?.await?;\n    println!(\"Transaction Receipt: {}\", serde_json::to_string(&amp;tx)?);\n\n    Ok(())\n}\n\nasync fn reset(client: &amp;Client, contract_addr: &amp;H160) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"Resetting number...\");\n\n    // Create contract instance\n    let contract = Incrementer::new(contract_addr.clone(), Arc::new(client.clone()));\n\n    // Send contract transaction\n    let tx = contract.reset().send().await?.await?;\n    println!(\"Transaction Receipt: {}\", serde_json::to_string(&amp;tx)?);\n\n    Ok(())\n}\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/libraries/viem/","title":"viem TypeScript Ethereum Library","text":""},{"location":"builders/ethereum/libraries/viem/#introduction","title":"Introduction","text":"<p>viem is a modular TypeScript library that allows developers to interact with abstractions over the JSON-RPC API, making it easy to interact with Ethereum nodes. Since Moonbeam has an Ethereum-like API available that is fully compatible with Ethereum-style JSON RPC invocations, developers can leverage this compatibility to interact with Moonbeam nodes. For more information on viem, check out their documentation site.</p> <p>In this guide, you'll learn how to use viem to send a transaction and deploy a contract on the Moonbase Alpha TestNet. This guide can be adapted for Moonbeam, Moonriver, or a Moonbeam development node.</p>"},{"location":"builders/ethereum/libraries/viem/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"},{"location":"builders/ethereum/libraries/viem/#installing-viem","title":"Installing viem","text":"<p>To get started, you'll need to create a basic TypeScript project. First, create a directory to store all of the files you'll be creating throughout this guide, and initialize the project with the following command:</p> <pre><code>mkdir viem-examples &amp;&amp; cd viem-examples &amp;&amp; npm init --y\n</code></pre> <p>For this guide, you'll need to install the viem library and the Solidity compiler. To install both packages, you can run the following command:</p> npmyarn <pre><code>npm install typescript ts-node viem solc@0.8.0\n</code></pre> <pre><code>yarn add typescript ts-node viem solc@0.8.0\n</code></pre> <p>You can create a TypeScript configuration file by running:</p> <pre><code>npx tsc --init\n</code></pre> <p>Note</p> <p>This tutorial was created using Node.js v18.18.0.</p>"},{"location":"builders/ethereum/libraries/viem/#setting-up-a-viem-provider","title":"Set Up a viem Client (Provider)","text":"<p>Throughout this guide, you'll be creating a bunch of scripts that provide different functionality, such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts, you'll need to create a viem client to interact with the network.</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>You can create a viem client for reading chain data, like balances or contract data, using the <code>createPublicClient</code> function, or you can create a viem client for writing chain data, like sending transactions, using the <code>createWalletClient</code> function.</p>"},{"location":"builders/ethereum/libraries/viem/#for-reading-chain-data","title":"For Reading Chain Data","text":"<p>To create a client for reading chain data, you can take the following steps:</p> <ol> <li>Import the <code>createPublicClient</code> and <code>http</code> functions from <code>viem</code> and the network you want to interact with from <code>viem/chains</code>. The chain can be any of the following: <code>moonbeam</code>, <code>moonriver</code>, or <code>moonbaseAlpha</code></li> <li>Create the <code>client</code> using the <code>createPublicClient</code> function and pass in the network and the HTTP RPC endpoint</li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>import { createPublicClient, http } from 'viem';\nimport { moonbeam } from 'viem/chains';\n\nconst rpcUrl = 'INSERT_RPC_API_ENDPOINT'\nconst publicClient = createPublicClient({\n  chain: moonbeam,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createPublicClient, http } from 'viem';\nimport { moonriver } from 'viem/chains';\n\nconst rpcUrl = 'INSERT_RPC_API_ENDPOINT'\nconst publicClient = createPublicClient({\n  chain: moonriver,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createPublicClient, http } from 'viem';\nimport { moonbaseAlpha } from 'viem/chains';\n\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network'\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createPublicClient, http } from 'viem';\nimport { moonbeamDev } from 'viem/chains';\n\nconst rpcUrl = 'http://127.0.0.1:9944'\nconst publicClient = createPublicClient({\n  chain: moonbeamDev,\n  transport: http(rpcUrl),\n})\n</code></pre>"},{"location":"builders/ethereum/libraries/viem/#for-writing-chain-data","title":"For Writing Chain Data","text":"<p>To create a client for writing chain data, you can take the following steps:</p> <ol> <li>Import the <code>createWalletClient</code> and <code>http</code> functions from <code>viem</code>, the <code>privateKeyToAccount</code> function for loading your accounts via their private keys, and the network you want to interact with from <code>viem/chains</code>. The chain can be any of the following: <code>moonbeam</code>, <code>moonriver</code>, or <code>moonbaseAlpha</code></li> <li>Create your account using the <code>privateKeyToAccount</code> function</li> <li>Create the <code>client</code> using the <code>createWalletClient</code> function and pass in the account, network, and the HTTP RPC endpoint</li> </ol> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a TypeScript file.</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>import { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbeam } from 'viem/chains';\n\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'INSERT_RPC_API_ENDPOINT'\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbeam,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonriver } from 'viem/chains';\n\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'INSERT_RPC_API_ENDPOINT'\nconst walletClient = createWalletClient({\n  account,\n  chain: moonriver,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbaseAlpha } from 'viem/chains';\n\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network'\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbeamDev } from 'viem/chains';\n\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'http://127.0.0.1:9944'\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbeamDev,\n  transport: http(rpcUrl),\n});\n</code></pre> <p>Note</p> <p>To interact with browser-based wallets, you can use the following code to create an account:</p> <pre><code>const [account] = await window.ethereum.request({\n  method: 'eth_requestAccounts',\n});\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbeam,\n  transport: custom(window.ethereum),\n});\n</code></pre>"},{"location":"builders/ethereum/libraries/viem/#send-transaction","title":"Send a Transaction","text":"<p>During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.</p> <p>You can also use the balance script to check the account balances after the transaction has been sent.</p>"},{"location":"builders/ethereum/libraries/viem/#check-balances-script","title":"Check Balances Script","text":"<p>You'll only need one file to check the balances of both addresses before and after the transaction is sent. To get started, you can create a <code>balances.ts</code> file by running:</p> <pre><code>touch balances.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Update your imports to include the <code>createPublicClient</code>, <code>http</code>, and <code>formatEther</code> functions from <code>viem</code> and the network you want to interact with from <code>viem/chains</code></li> <li>Set up a public viem client, which can be used for reading chain data, such as account balances</li> <li>Define the <code>addressFrom</code> and <code>addressTo</code> variables</li> <li>Create the asynchronous <code>balances</code> function that wraps the <code>publicClient.getBalance</code> method</li> <li>Use the <code>publicClient.getBalance</code> function to fetch the balances for the <code>addressFrom</code> and <code>addressTo</code> addresses. You can also leverage the <code>formatEther</code> function to transform the balance into a more readable number (in GLMR, MOVR, or DEV)</li> <li>Lastly, run the <code>balances</code> function</li> </ol> <pre><code>// 1. Imports\nimport { createPublicClient, http, formatEther } from 'viem';\nimport { moonbaseAlpha } from 'viem/chains';\n\n// 2. Create a public client for reading chain data\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network';\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 3. Create address variables\nconst addressFrom = 'INSERT_FROM_ADDRESS';\nconst addressTo = 'INSERT_TO_ADDRESS';\n\n// 4. Create balances function\nconst balances = async () =&gt; {\n  // 5. Fetch balances\n  const balanceFrom = formatEther(\n    await publicClient.getBalance({ address: addressFrom })\n  );\n  const balanceTo = formatEther(\n    await publicClient.getBalance({ address: addressTo })\n  );\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} DEV`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} DEV`);\n};\n\n// 6. Call the balances function\nbalances();\n</code></pre> <p>To run the script and fetch the account balances, you can run the following command:</p> <pre><code>npx ts-node balances.ts\n</code></pre> <p>If successful, the balances for the origin and receiving address will be displayed in your terminal in DEV.</p> npx ts-node balances.ts The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3601.72 DEV The balance of 0x78F34038c82638E0563b974246D421154C26b004 is: 0 DEV"},{"location":"builders/ethereum/libraries/viem/#send-transaction-script","title":"Send Transaction Script","text":"<p>You'll only need one file to execute a transaction between accounts. For this example, you'll be transferring 1 DEV token from an origin address (from which you hold the private key) to another address. To get started, you can create a <code>transaction.ts</code> file by running:</p> <pre><code>touch transaction.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Update your imports to include the <code>createWalletClient</code>, <code>http</code>, and <code>parseEther</code> functions from <code>viem</code>, the <code>privateKeyToAccount</code> function from <code>viem/accounts</code>, and the network you want to interact with from <code>viem/chains</code></li> <li>Set up a viem wallet client for writing chain data, which can be used along with your private key to send transactions. Note: This is for example purposes only. Never store your private keys in a TypeScript file</li> <li>Set up a public viem client for reading chain data, which will be used to wait for the transaction receipt</li> <li>Define the <code>addressTo</code> variable</li> <li>Create the asynchronous <code>send</code> function, which wraps the transaction object and the <code>walletClient.sendTransaction</code> method</li> <li>Use the <code>walletClient.sendTransaction</code> function to sign and send the transaction. You'll need to pass in the transaction object, which only requires the recipient's address and the amount to send. Note that <code>parseEther</code> can be used, which handles the necessary unit conversions from Ether to Wei, similar to using <code>parseUnits(value, decimals)</code>. Use <code>await</code> to wait until the transaction is processed and the transaction hash is returned</li> <li>Use the <code>publicClient.waitForTransactionReceipt</code> function to wait for the transaction receipt, signaling that the transaction has been completed. This is particularly helpful if you need the transaction receipt or if you're running the <code>balances.ts</code> script directly after this one to check if the balances have been updated as expected</li> <li>Lastly, run the <code>send</code> function</li> </ol> <pre><code>// 1. Imports\nimport { createPublicClient, createWalletClient, http, parseEther } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbaseAlpha } from 'viem/chains';\n\n// 2. Create a wallet client for writing chain data\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network';\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 3. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 4. Create to address variable\nconst addressTo = 'INSERT_ADDRESS';\n\n// 5. Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${account.address} to ${addressTo}`\n  );\n\n  // 6. Sign and send tx\n  const hash = await walletClient.sendTransaction({\n    to: addressTo,\n    value: parseEther('1'),\n  });\n\n  // 7. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Transaction successful with hash: ${hash}`);\n};\n\n// 8. Call the send function\nsend();\n</code></pre> <p>To run the script, you can run the following command in your terminal:</p> <pre><code>npx ts-node transaction.ts\n</code></pre> <p>If the transaction was successful, in your terminal you'll see the transaction hash has been printed out.</p> <p>Note</p> <p>Viem requires that you prepend your private key with <code>0x</code>. Many wallets omit this <code>0x</code>, so verify you've included it as you replace <code>INSERT_PRIVATE_KEY</code>.</p> <p>You can also use the <code>balances.ts</code> script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:</p> npx ts-node balances.ts The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3601.72 DEV The balance of 0x78F34038c82638E0563b974246D421154C26b004 is: 0 DEV npx ts-node transaction.ts Attempting to send transaction from 0x3B939FeaD1557C741Ff06492FD0127bd287A421e to 0x78F34038c82638E0563b974246D421154C26b004 Transaction successful with hash: 0xc482d907b2ae4ca1202c6cc5b486694b8439a9853caad9c2cdafec39defa1968 npx ts-node balances.ts The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3600.72 DEV The balance of 0x78F34038c82638E0563b974246D421154C26b004 is: 1 DEV"},{"location":"builders/ethereum/libraries/viem/#deploy-contract","title":"Deploy a Contract","text":"<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (the default is <code>0</code>). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only and does not handle values wrapping around.</p>"},{"location":"builders/ethereum/libraries/viem/#compile-contract-script","title":"Compile Contract Script","text":"<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.ts</code> file by running:</p> <pre><code>touch compile.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>fs</code> and <code>solc</code> packages</li> <li>Using the <code>fs.readFileSync</code> function, you'll read and save the file contents of <code>Incrementer.sol</code> to <code>source</code></li> <li>Build the <code>input</code> object for the Solidity compiler by specifying the <code>language</code>, <code>sources</code>, and <code>settings</code> to be used</li> <li>Using the <code>input</code> object, you can compile the contract using <code>solc.compile</code></li> <li>Extract the compiled contract file and export it to be used in the deployment script</li> </ol> <pre><code>// 1. Import packages\nconst fs = require('fs');\nconst solc = require('solc');\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n   language: 'Solidity',\n   sources: {\n      'Incrementer.sol': {\n         content: source,\n      },\n   },\n   settings: {\n      outputSelection: {\n         '*': {\n            '*': ['*'],\n         },\n      },\n   },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nexport default contractFile;\n</code></pre>"},{"location":"builders/ethereum/libraries/viem/#deploy-contract-script","title":"Deploy Contract Script","text":"<p>With the script for compiling the <code>Incrementer.sol</code> contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called <code>deploy.ts</code>:</p> <pre><code>touch deploy.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Update your imports to include the <code>createPublicClient</code>, <code>createWalletClient</code>, and <code>http</code> functions from <code>viem</code>, the <code>privateKeyToAccount</code> function from <code>viem/accounts</code>, the network you want to interact with from <code>viem/chains</code>, and the <code>contractFile</code> from the <code>compile.ts</code> file you created in the Compile Contract Script section</li> <li>Set up a viem wallet client for writing chain data, which will be used along with your private key to deploy the <code>Incrementer</code> contract. Note: This is for example purposes only. Never store your private keys in a TypeScript file</li> <li>Set up a public viem client for reading chain data, which will be used to read the transaction receipt for the deployment</li> <li>Load the contract <code>bytecode</code> and <code>abi</code> for the compiled contract</li> <li>Create the asynchronous <code>deploy</code> function that will be used to deploy the contract via the <code>walletClient.deployContract</code> method</li> <li>Use the <code>walletClient.deployContract</code> function to sign and send the transaction. You'll need to pass in the contract's ABI and bytecode, the account to deploy the transaction from, and the initial value for the incrementer. Use <code>await</code> to wait until the transaction is processed and the transaction hash is returned</li> <li>Use the <code>publicClient.readContract</code> function to get the transaction receipt for the deployment. Use <code>await</code> to wait until the transaction is processed and the contract address is returned</li> <li>Lastly, run the <code>deploy</code> function</li> </ol> <pre><code>// 1. Update imports\nimport { createPublicClient, createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbaseAlpha } from 'viem/chains';\nimport contractFile from './compile';\n\n// 2. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network';\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n// 3. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 4. Load contract information\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\nconst _initialNumber = 5;\n\n// 5. Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${account.address}`);\n\n  // 6. Send tx (initial value set to 5)\n  const contract = await walletClient.deployContract({\n    abi,\n    account,\n    bytecode,\n    args: [_initialNumber],\n  });\n\n  // 7. Get the transaction receipt for the deployment\n  const transaction = await publicClient.waitForTransactionReceipt({\n    hash: contract,\n  });\n\n  console.log(`Contract deployed at address: ${transaction.contractAddress}`);\n};\n\n// 8. Call the deploy function\ndeploy();\n</code></pre> <p>To run the script, you can enter the following command into your terminal:</p> <pre><code>npx ts-node deploy.ts\n</code></pre> <p>If successful, the contract's address will be displayed in the terminal.</p> npx ts-node deploy.ts Attempting to deploy from account: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Contract deployed at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9"},{"location":"builders/ethereum/libraries/viem/#read-contract-data","title":"Read Contract Data (Call Methods)","text":"<p>Call methods are the type of interaction that doesn't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.</p> <p>To get started, you can create a file and name it <code>get.ts</code>:</p> <pre><code>touch get.ts\n</code></pre> <p>Then you can take the following steps to create the script:</p> <ol> <li>Update your imports to include the <code>createPublicClient</code> and <code>http</code> functions from <code>viem</code>, the network you want to interact with from <code>viem/chains</code>, and the <code>contractFile</code> from the <code>compile.ts</code> file you created in the Compile Contract Script section</li> <li>Set up a public viem client for reading chain data, which will be used to read the current number of the <code>Incrementer</code> contract</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract and the <code>abi</code> variable using the <code>contractFile</code> from the <code>compile.ts</code> file</li> <li>Create the asynchronous <code>get</code> function</li> <li>Call the contract using the <code>publicClient.readContract</code> function, passing in the <code>abi</code>, the name of the function, the <code>contractAddress</code>, and any arguments (if needed). You can use <code>await</code>, which will return the value requested once the request promise resolves</li> <li>Lastly, call the <code>get</code> function</li> </ol> <pre><code>// 1. Update imports\nimport { createPublicClient, http } from 'viem';\nimport { moonbaseAlpha } from 'viem/chains';\nimport contractFile from './compile';\n\n// 2. Create a public client for reading chain data\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network';\nconst client = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 3. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\n\n// 4. Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // 5. Call contract\n  const data = await client.readContract({\n    abi,\n    functionName: 'number',\n    address: contractAddress,\n    args: [],\n  });\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 6. Call get function\nget();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>npx ts-node get.ts\n</code></pre> <p>If successful, the value will be displayed in the terminal.</p> npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 5"},{"location":"builders/ethereum/libraries/viem/#interact-with-contract","title":"Interact with Contract (Send Methods)","text":"<p>Send methods are the type of interactions that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them <code>increment.ts</code> and <code>reset.ts</code>:</p> <pre><code>touch increment.ts reset.ts\n</code></pre> <p>Open the <code>increment.ts</code> file and take the following steps to create the script:</p> <ol> <li>Update your imports to include the <code>createWalletClient</code> and <code>http</code> functions from <code>viem</code>, the network you want to interact with from <code>viem/chains</code>, and the <code>contractFile</code> from the <code>compile.ts</code> file you created in the Compile Contract Script section</li> <li>Set up a viem wallet client for writing chain data, which will be used along with your private key to send a transaction. Note: This is for example purposes only. Never store your private keys in a TypeScript file</li> <li>Set up a public viem client for reading chain data, which will be used to wait for the transaction receipt</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract, the <code>abi</code> variable using the <code>contractFile</code> from the <code>compile.ts</code> file, and the <code>_value</code> to increment the contract by</li> <li>Create the asynchronous <code>increment</code> function</li> <li>Call the contract using the <code>walletClient.writeContract</code> function, passing in the <code>abi</code>, the name of the function, the <code>contractAddress</code>, and the <code>_value</code>. You can use <code>await</code>, which will return the transaction hash once the request promise resolves</li> <li>Use the <code>publicClient.waitForTransactionReceipt</code> function to wait for the transaction receipt, signaling that the transaction has been completed. This is particularly helpful if you need the transaction receipt or if you're running the <code>get.ts</code> script directly after this one to check that the current number has been updated as expected</li> <li>Lastly, call the <code>increment</code> function</li> </ol> <pre><code>// 1. Update imports\nimport { createPublicClient, createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbaseAlpha } from 'viem/chains';\nimport contractFile from './compile';\n\n// 2. Create a wallet client for writing chain data\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network';\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 3. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 4. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\nconst _value = 3;\n\n// 5. Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n  // 6. Call contract\n  const hash = await walletClient.writeContract({\n    abi,\n    functionName: 'increment',\n    address: contractAddress,\n    args: [_value],\n  });\n\n  // 7. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Tx successful with hash: ${hash}`);\n};\n\n// 8. Call increment function\nincrement();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>npx ts-node increment.ts\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.ts</code> script alongside the <code>increment.ts</code> script to make sure that value is changing as expected.</p> npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 5 npx ts-node increment.ts Calling the increment by 3 function in contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 Tx successful with hash: 0x041c9767e7a96f60f372341647430560569fd6ff64a27b4b9c6241e55dde57e1 npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 8 <p>Next, you can open the <code>reset.ts</code> file and take the following steps to create the script:</p> <ol> <li>Update your imports to include the <code>createWalletClient</code> and <code>http</code> functions from <code>viem</code>, the network you want to interact with from <code>viem/chains</code>, and the <code>contractFile</code> from the <code>compile.ts</code> file you created in the Compile Contract Script section</li> <li>Set up a viem wallet client for writing chain data, which will be used along with your private key to send a transaction. Note: This is for example purposes only. Never store your private keys in a TypeScript file</li> <li>Set up a public viem client for reading chain data, which will be used to wait for the transaction receipt</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract and the <code>abi</code> variable using the <code>contractFile</code> from the <code>compile.ts</code> file to increment the contract by</li> <li>Create the asynchronous <code>reset</code> function</li> <li>Call the contract using the <code>walletClient.writeContract</code> function, passing in the <code>abi</code>, the name of the function, the <code>contractAddress</code>, and an empty array for the arguments. You can use <code>await</code>, which will return the transaction hash once the request promise resolves</li> <li>Use the <code>publicClient.waitForTransactionReceipt</code> function to wait for the transaction receipt, signaling that the transaction has been completed. This is particularly helpful if you need the transaction receipt or if you're running the <code>get.ts</code> script directly after this one to check that the current number has been reset to <code>0</code></li> <li>Lastly, call the <code>reset</code> function</li> </ol> <pre><code>// 1. Update imports\nimport { createPublicClient, createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbaseAlpha } from 'viem/chains';\nimport contractFile from './compile';\n\n// 2. Create a wallet client for writing chain data\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network';\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 3. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 4. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\n\n// 5. Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // 6. Call contract\n  const hash = await walletClient.writeContract({\n    abi,\n    functionName: 'reset',\n    address: contractAddress,\n    args: [],\n  });\n\n  // 7. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Tx successful with hash: ${hash}`);\n};\n\n// 8. Call reset function\nreset();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>npx ts-node reset.ts\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.ts</code> script alongside the <code>reset.ts</code> script to make sure that value is changing as expected.</p> npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 8 npx ts-node reset.ts Calling the reset function in contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 Tx successful with hash: 0xc1a772131ccf6a03675ff3e88798a6e70a99e145eeb0e98170ff2e3345ee14a7 npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 0    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/libraries/web3js/","title":"Web3.js JavaScript Library","text":""},{"location":"builders/ethereum/libraries/web3js/#introduction","title":"Introduction","text":"<p>Warning</p> <p>Web3.js has been sunset. You can find tutorials on using Ethers.js and viem on the Libraries page.</p> <p>Web3.js is a set of libraries that allow developers to interact with Ethereum nodes using HTTP, IPC, or WebSocket protocols with JavaScript. Moonbeam has an Ethereum-like API available that is fully compatible with Ethereum-style JSON-RPC invocations. Therefore, developers can leverage this compatibility and use the Web3.js library to interact with a Moonbeam node as if they were doing so on Ethereum.</p> <p>In this guide, you'll learn how to use the Web3.js library to send a transaction and deploy a contract on Moonbase Alpha. This guide can be adapted for Moonbeam, Moonriver, or a Moonbeam development node.</p>"},{"location":"builders/ethereum/libraries/web3js/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"},{"location":"builders/ethereum/libraries/web3js/#install-web3js","title":"Installing Web3.js","text":"<p>To get started, you'll need to start a basic JavaScript project. First, create a directory to store all of the files you'll be creating throughout this guide, and initialize the project with the following command:</p> <pre><code>mkdir web3-examples &amp;&amp; cd web3-examples &amp;&amp; npm init --y\n</code></pre> <p>For this guide, you'll need to install the Web3.js library and the Solidity compiler. To install both NPM packages, you can run the following command:</p> npmyarn <pre><code>npm install web3 solc@0.8.0\n</code></pre> <pre><code>yarn add web3 solc@0.8.0\n</code></pre>"},{"location":"builders/ethereum/libraries/web3js/#setup-web3-with-moonbeam","title":"Setup Web3.js with Moonbeam","text":"<p>You can configure Web3.js to work with any of the Moonbeam networks. To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>The simplest way to get started with each of the networks is as follows:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>const { Web3 } = require('web3');\n\n// Create Web3 instance\nconst web3 = new Web3('INSERT_RPC_API_ENDPOINT'); // Insert your RPC URL here\n</code></pre> <pre><code>const { Web3 } = require('web3');\n\n// Create Web3 instance\nconst web3 = new Web3('INSERT_RPC_API_ENDPOINT'); // Insert your RPC URL here\n</code></pre> <pre><code>const { Web3 } = require('web3');\n\n// Create Web3 instance\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n</code></pre> <pre><code>const { Web3 } = require('web3');\n\n// Create Web3 instance\nconst web3 = new Web3('http://127.0.0.1:9944');\n</code></pre> <p>Save this code snippet, as you'll need it for the scripts that are used in the following sections.</p>"},{"location":"builders/ethereum/libraries/web3js/#send-a-transaction","title":"Send a Transaction","text":"<p>During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.</p> <p>You can also use the balance script to check the account balances after the transaction has been sent.</p>"},{"location":"builders/ethereum/libraries/web3js/#check-balances-script","title":"Check Balances Script","text":"<p>You'll only need one file to check the balances of both addresses before and after the transaction is sent.  To get started, you can create a <code>balances.js</code> file by running:</p> <pre><code>touch balances.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Web3 provider</li> <li>Define the <code>addressFrom</code> and <code>addressTo</code> variables</li> <li>Create the asynchronous <code>balances</code> function, which wraps the <code>web3.eth.getBalance</code> method</li> <li>Use the <code>web3.eth.getBalance</code> function to fetch the balances for the <code>addressFrom</code> and <code>addressTo</code> addresses. You can also leverage the <code>web3.utils.fromWei</code> function to transform the balance into a more readable number in DEV</li> <li>Lastly, run the <code>balances</code> function</li> </ol> <pre><code>// 1. Add the Web3 provider logic\n// {...}\n\n// 2. Create address variables\nconst addressFrom = 'INSERT_FROM_ADDRESS';\nconst addressTo = 'INSERT_TO_ADDRESS';\n\n// 3. Create balances function\nconst balances = async () =&gt; {\n  // 4. Fetch balance info\n  const balanceFrom = web3.utils.fromWei(\n    await web3.eth.getBalance(addressFrom),\n    'ether'\n  );\n  const balanceTo = web3.utils.fromWei(\n    await web3.eth.getBalance(addressTo),\n    'ether'\n  );\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} DEV`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} DEV`);\n};\n\n// 5. Call balances function\nbalances();\n</code></pre> View the complete script <pre><code>const { Web3 } = require('web3');\n\n// 1. Add the Web3 provider logic here:\nconst providerRPC = {\n  development: 'http://localhost:9944',\n  moonbase: 'https://rpc.api.moonbase.moonbeam.network',\n};\nconst web3 = new Web3(providerRPC.moonbase); // Change to correct network\n\n// 2. Create address variables\nconst addressFrom = 'INSERT_FROM_ADDRESS';\nconst addressTo = 'INSERT_TO_ADDRESS';\n\n// 3. Create balances function\nconst balances = async () =&gt; {\n  // 4. Fetch balance info\n  const balanceFrom = web3.utils.fromWei(await web3.eth.getBalance(addressFrom), 'ether');\n  const balanceTo = web3.utils.fromWei(await web3.eth.getBalance(addressTo), 'ether');\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} DEV`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} DEV`);\n};\n\n// 5. Call balances function\nbalances();\n</code></pre> <p>To run the script and fetch the account balances, you can run the following command:</p> <pre><code>node balances.js\n</code></pre> <p>If successful, the balances for the origin and receiving address will be displayed in your terminal in DEV.</p>"},{"location":"builders/ethereum/libraries/web3js/#send-transaction-script","title":"Send Transaction Script","text":"<p>You'll only need one file to execute a transaction between accounts. For this example, you'll be transferring 1 DEV token from an origin address (from which you hold the private key) to another address. To get started, you can create a <code>transaction.js</code> file by running:</p> <pre><code>touch transaction.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Web3 provider</li> <li>Define the <code>accountFrom</code>, including the <code>privateKey</code>, and the <code>addressTo</code> variables. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create the asynchronous <code>send</code> function, which wraps the transaction object, and the sign and send transaction functions</li> <li>Create and sign the transaction using the <code>web3.eth.accounts.signTransaction</code> function. Pass in the <code>gas</code>, <code>addressTo</code>, <code>value</code>, <code>gasPrice</code>, and <code>nonce</code> for the transaction along with the sender's <code>privateKey</code></li> <li>Send the signed transaction using the <code>web3.eth.sendSignedTransaction</code> method and pass in the raw transaction. Then use <code>await</code> to wait until the transaction is processed and the transaction receipt is returned</li> <li>Lastly, run the <code>send</code> function</li> </ol> <pre><code>// 1. Add the Web3 provider logic\n// {...}\n\n// 2. Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\nconst addressTo = 'INSERT_TO_ADDRESS'; // Change addressTo\n\n// 3. Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${accountFrom.address} to ${addressTo}`\n  );\n\n  // 4. Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      gas: 21000,\n      to: addressTo,\n      value: web3.utils.toWei('1', 'ether'),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom.address),\n    },\n    accountFrom.privateKey\n  );\n\n  // 5. Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(\n    `Transaction successful with hash: ${createReceipt.transactionHash}`\n  );\n};\n\n// 6. Call send function\nsend();\n</code></pre> View the complete script <pre><code>const { Web3 } = require('web3');\n\n// 1. Add the Web3 provider logic\nconst providerRPC = {\n  development: 'http://localhost:9944',\n  moonbase: 'https://rpc.api.moonbase.moonbeam.network',\n};\nconst web3 = new Web3(providerRPC.moonbase); // Change to correct network\n\n// 2. Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\nconst addressTo = 'INSERT_TO_ADDRESS';\n\n// 3. Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${accountFrom.address} to ${addressTo}`\n  );\n\n  // 4. Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      gas: 21000,\n      to: addressTo,\n      value: web3.utils.toWei('1', 'ether'),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom.address),\n    },\n    accountFrom.privateKey\n  );\n\n  // 5. Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(\n    `Transaction successful with hash: ${createReceipt.transactionHash}`\n  );\n};\n\n// 6. Call send function\nsend();\n</code></pre> <p>To run the script, you can run the following command in your terminal:</p> <pre><code>node transaction.js\n</code></pre> <p>If the transaction was successful, in your terminal, you'll see the transaction hash has been printed out.</p> <p>You can also use the <code>balances.js</code> script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:</p> node balances.js The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3603.67979115380310679 DEV The balance of 0xe29A0699e079FeBEe94A02f35C31B026f90F6040 is: 0. DEV node transaction.js Attempting to send transaction from 0x3B939FeaD1557C741Ff06492FD0127bd287A421e to 0xe29A0699e079FeBEe94A02f35C31B026f90F6040 Transaction successful with hash: 0xf1d628ed12c5f40e03e29aa2c23c8c09680ee595c60607c7363a81c0be8ef3cb node balances.js The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3602.67978852880310679 DEV The balance of 0xe29A0699e079FeBEe94A02f35C31B026f90F6040 is: 1 DEV"},{"location":"builders/ethereum/libraries/web3js/#common-errors","title":"Common Errors When Sending Transactions","text":"<p>When sending a transaction with Web3.js, it is important that you have all of the required data for the transaction. You'll need to provide the <code>from</code> address or the <code>nonce</code> of the sender, the <code>gas</code> or <code>gasLimit</code>, and the <code>gasPrice</code>.</p> <p>If you do not specify the <code>from</code> address or the <code>nonce</code> of the sender, you may receive the following error:</p> <pre><code>UnableToPopulateNonceError: Invalid value given \"UnableToPopulateNonceError\". Error: unable to populate nonce, no from address available.\n</code></pre> <p>To fix this, simply add either the <code>from</code> or <code>nonce</code> field to the transaction object.</p> <p>If you do not specify the gas correctly, you may receive the following error:</p> <pre><code>MissingGasError: Invalid value given \"gas: 0x5208, gasPrice: undefined, maxPriorityFeePerGas: undefined, maxFeePerGas: undefined\". Error: \"gas\" is missing.\n</code></pre> <p>To resolve this error, you'll need to make sure that you've provided a <code>gasPrice</code> for the transaction. You can use <code>await web3.eth.getGasPrice()</code> to programmatically get this value.</p>"},{"location":"builders/ethereum/libraries/web3js/#deploy-a-contract","title":"Deploy a Contract","text":"<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (the default is <code>0</code>). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only and does not handle values wrapping around.</p>"},{"location":"builders/ethereum/libraries/web3js/#compile-contract-script","title":"Compile Contract Script","text":"<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.js</code> file by running:</p> <pre><code>touch compile.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>fs</code> and <code>solc</code> packages</li> <li>Using the <code>fs.readFileSync</code> function, you'll read and save the file contents of <code>Incrementer.sol</code> to <code>source</code></li> <li>Build the <code>input</code> object for the Solidity compiler by specifying the <code>language</code>, <code>sources</code>, and <code>settings</code> to be used</li> <li>Using the <code>input</code> object, you can compile the contract using <code>solc.compile</code></li> <li>Extract the compiled contract file and export it to be used in the deployment script</li> </ol> <pre><code>// 1. Import packages\nconst fs = require('fs');\nconst solc = require('solc');\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n   language: 'Solidity',\n   sources: {\n      'Incrementer.sol': {\n         content: source,\n      },\n   },\n   settings: {\n      outputSelection: {\n         '*': {\n            '*': ['*'],\n         },\n      },\n   },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nmodule.exports = contractFile;\n</code></pre>"},{"location":"builders/ethereum/libraries/web3js/#deploy-contract-script","title":"Deploy Contract Script","text":"<p>With the script for compiling the <code>Incrementer.sol</code> contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called <code>deploy.js</code>:</p> <pre><code>touch deploy.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the contract file from <code>compile.js</code></li> <li>Set up the Web3 provider</li> <li>Define the <code>accountFrom</code>, including the <code>privateKey</code>, and the <code>addressTo</code> variables. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Save the <code>bytecode</code> and <code>abi</code> for the compiled contract</li> <li>Create the asynchronous <code>deploy</code> function that will be used to deploy the contract</li> <li>Create the contract instance using the <code>web3.eth.Contract</code> function</li> <li>Create the constructor and pass in the <code>bytecode</code> and the initial value for the incrementer. For this example, you can set the initial value to <code>5</code></li> <li>Create and sign the transaction using the <code>web3.eth.accounts.signTransaction</code> function. Pass in the <code>data</code>, <code>gas</code>, <code>gasPrice</code>, and <code>nonce</code> for the transaction along with the sender's <code>privateKey</code></li> <li>Send the signed transaction using the <code>web3.eth.sendSignedTransaction</code> method and pass in the raw transaction. Then use <code>await</code> to wait until the transaction is processed and the transaction receipt is returned</li> <li>Lastly, run the <code>deploy</code> function</li> </ol> <pre><code>// 1. Import the contract file\nconst contractFile = require('./compile');\n\n// 2. Add the Web3 provider logic\n// {...}\n\n// 3. Create address variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\n\n// 4. Get the bytecode and ABI\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// 5. Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account ${accountFrom.address}`);\n\n  // 6. Create contract instance\n  const incrementer = new web3.eth.Contract(abi);\n\n  // 7. Create constructor transaction\n  const incrementerTx = incrementer.deploy({\n    data: bytecode,\n    arguments: [5],\n  });\n\n  // 8. Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: incrementerTx.encodeABI(),\n      gas: await incrementerTx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom.address),\n    },\n    accountFrom.privateKey\n  );\n\n  // 9. Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);\n};\n\n// 10. Call deploy function\ndeploy();\n</code></pre> View the complete script <pre><code>// 1. Import web3 and the contract file\nconst { Web3 } = require('web3');\nconst contractFile = require('./compile');\n\n// 2. Add the Web3 provider logic\nconst providerRPC = {\n  development: 'http://localhost:9944',\n  moonbase: 'https://rpc.api.moonbase.moonbeam.network',\n};\nconst web3 = new Web3(providerRPC.moonbase); // Change to correct network\n\n// 3. Create address variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\n\n// 4. Get the bytecode and API\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// 5. Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account ${accountFrom.address}`);\n\n  // 6. Create contract instance\n  const incrementer = new web3.eth.Contract(abi);\n\n  // 7. Create constructor transaction\n  const incrementerTx = incrementer.deploy({\n    data: bytecode,\n    arguments: [5],\n  });\n\n  // 8. Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: incrementerTx.encodeABI(),\n      gas: await incrementerTx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom.address),\n    },\n    accountFrom.privateKey\n  );\n\n  // 9. Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);\n};\n\n// 10. Call deploy function\ndeploy();\n</code></pre> <p>To run the script, you can enter the following command into your terminal:</p> <pre><code>node deploy.js\n</code></pre> <p>If successful, the contract's address will be displayed in the terminal.</p> node deploy.js Attempting to deploy from account 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Contract deployed at address: 0x6dcb33a7f6235e74fd553b50c96f900707142892"},{"location":"builders/ethereum/libraries/web3js/#read-contract-data","title":"Read Contract Data (Call Methods)","text":"<p>Call methods are the type of interaction that doesn't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.</p> <p>To get started, you can create a file and name it <code>get.js</code>:</p> <pre><code>touch get.js\n</code></pre> <p>Then you can take the following steps to create the script:</p> <ol> <li>Import the <code>abi</code> from the <code>compile.js</code> file</li> <li>Set up the Web3 provider</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract</li> <li>Create an instance of the contract using the <code>web3.eth.Contract</code> function and passing in the <code>abi</code> and  <code>contractAddress</code></li> <li>Create the asynchronous <code>get</code> function</li> <li>Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you will call the <code>number</code> method which doesn't require any inputs. You can use <code>await</code>, which will return the value requested once the request promise resolves</li> <li>Lastly, call the <code>get</code> function</li> </ol> <pre><code>// 1. Import the contract ABI\nconst { abi } = require('./compile');\n\n// 2. Add the Web3 provider logic\n// {...}\n\n// 3. Create address variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // 6. Call contract\n  const data = await incrementer.methods.number().call();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 7. Call get function\nget();\n</code></pre> View the complete script <pre><code>// 1. Import Web3js and the contract ABI\nconst { Web3 } = require('web3');\nconst { abi } = require('./compile');\n\n// 2. Add the Web3 provider logic\nconst providerRPC = {\n  development: 'http://localhost:9944',\n  moonbase: 'https://rpc.api.moonbase.moonbeam.network',\n};\nconst web3 = new Web3(providerRPC.moonbase); // Change to correct network\n\n// 3. Create address variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // 6. Call contract\n  const data = await incrementer.methods.number().call();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 7. Call get function\nget();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node get.js\n</code></pre> <p>If successful, the value will be displayed in the terminal.</p>"},{"location":"builders/ethereum/libraries/web3js/#interact-with-contract","title":"Interact with Contract (Send Methods)","text":"<p>Send methods are the type of interaction that modifies the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them <code>increment.js</code> and <code>reset.js</code>:</p> <pre><code>touch increment.js reset.js\n</code></pre> <p>Open the <code>increment.js</code> file and take the following steps to create the script:</p> <ol> <li>Import the <code>abi</code> from the <code>compile.js</code> file</li> <li>Set up the Web3 provider</li> <li>Define the <code>privateKey</code> for the origin account, the <code>contractAddress</code> of the deployed contract, and the <code>_value</code> to increment by. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create an instance of the contract using the <code>web3.eth.Contract</code> function and passing in the <code>abi</code> and  <code>contractAddress</code></li> <li>Use the contract instance to build the increment transaction using the <code>methods.increment</code> function and passing in the <code>_value</code> as an input</li> <li>Create the asynchronous <code>increment</code> function</li> <li>Use the contract instance and the increment transaction you previously created to sign the transaction with the sender's private key. You'll use the <code>web3.eth.accounts.signTransaction</code> function and specify the <code>to</code> address, <code>data</code>, <code>gas</code>, <code>gasPrice</code>, and <code>nonce</code> for the transaction</li> <li>Send the signed transaction using the <code>web3.eth.sendSignedTransaction</code> method and pass in the raw transaction. Then use <code>await</code> to wait until the transaction is processed and the transaction receipt is returned</li> <li>Lastly, call the <code>increment</code> function</li> </ol> <pre><code>// 1. Import the contract ABI\nconst { abi } = require('./compile');\n\n// 2. Add the Web3 provider logic\n// {...}\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// 4. Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Build the increment transaction\nconst incrementTx = incrementer.methods.increment(_value);\n\n// 6. Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // 7. Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: incrementTx.encodeABI(),\n      gas: await incrementTx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom.address),\n    },\n    accountFrom.privateKey\n  );\n\n  // 8. Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);\n};\n\n// 9. Call increment function\nincrement();\n</code></pre> View the complete script <pre><code>// 1. Import Web3js and the contract ABI\nconst { Web3 } = require('web3');\nconst { abi } = require('./compile');\n\n// 2. Add the Web3 provider logic\nconst providerRPC = {\n  development: 'http://localhost:9944',\n  moonbase: 'https://rpc.api.moonbase.moonbeam.network',\n};\nconst web3 = new Web3(providerRPC.moonbase); // Change to correct network\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// 4. Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Build increment transaction\nconst incrementTx = incrementer.methods.increment(_value);\n\n// 6. Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // 7. Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: incrementTx.encodeABI(),\n      gas: await incrementTx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom.address),\n    },\n    accountFrom.privateKey\n  );\n\n  // 8. Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);\n};\n\n// 9. Call increment function\nincrement();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node increment.js\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.js</code> script alongside the <code>increment.js</code> script to make sure that value is changing as expected:</p> node get.js Making a call to contract at address: 0x6dcb33a7f6235e74fd553b50c96f900707142892 The current number stored is: 5 node increment.js Calling the increment by 3 function in contract at address: 0x6dcb33a7f6235e74fd553b50c96f900707142892 Tx successful with hash: 0xb03d1426376e7efc49d8b6c69aaf91e548578db7fd4a9ba575dbd8030821f6a3 node get.js Making a call to contract at address: 0x6dcb33a7f6235e74fd553b50c96f900707142892 The current number stored is: 8 <p>Next, you can open the <code>reset.js</code> file and take the following steps to create the script:</p> <ol> <li>Import the <code>abi</code> from the <code>compile.js</code> file</li> <li>Set up the Web3 provider</li> <li>Define the <code>privateKey</code> for the origin account and the <code>contractAddress</code> of the deployed contract. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create an instance of the contract using the <code>web3.eth.Contract</code> function and passing in the <code>abi</code> and  <code>contractAddress</code></li> <li>Use the contract instance to build the reset transaction using the <code>methods.reset</code> function</li> <li>Create the asynchronous <code>reset</code> function</li> <li>Use the contract instance and the reset transaction you previously created to sign the transaction with the sender's private key. You'll use the <code>web3.eth.accounts.signTransaction</code> function and specify the <code>to</code> address, <code>data</code>, <code>gas</code>, <code>gasPrice</code>, and <code>nonce</code> for the transaction</li> <li>Send the signed transaction using the <code>web3.eth.sendSignedTransaction</code> method and pass in the raw transaction. Then use <code>await</code> to wait until the transaction is processed and the transaction receipt is returned</li> <li>Lastly, call the <code>reset</code> function</li> </ol> <pre><code>// 1. Import the contract ABI\nconst { abi } = require('./compile');\n\n// 2. Add the Web3 provider logic\n// {...}\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create a contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Build reset transaction\nconst resetTx = incrementer.methods.reset();\n\n// 6. Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // 7. Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: resetTx.encodeABI(),\n      gas: await resetTx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom.address),\n    },\n    accountFrom.privateKey\n  );\n\n  // 8. Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);\n};\n\n// 9. Call reset function\nreset();\n</code></pre> View the complete script <pre><code>// 1. Import Web3js and the contract ABI\nconst { Web3 } = require('web3');\nconst { abi } = require('./compile');\n\n// 2. Add the Web3 provider logic\nconst providerRPC = {\n  development: 'http://localhost:9944',\n  moonbase: 'https://rpc.api.moonbase.moonbeam.network',\n};\nconst web3 = new Web3(providerRPC.moonbase); // Change to correct network\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Build reset transaction\nconst resetTx = incrementer.methods.reset();\n\n// 6. Create reset function\nconst reset = async () =&gt; {\n  console.log(`Calling the reset function in contract at address: ${contractAddress}`);\n\n  // 7. Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: resetTx.encodeABI(),\n      gas: await resetTx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom.address),\n    },\n    accountFrom.privateKey\n  );\n\n  // 8. Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(createTransaction.rawTransaction);\n  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);\n};\n\n// 9. Call reset function\nreset();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node reset.js\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.js</code> script alongside the <code>reset.js</code> script to make sure that value is changing as expected:</p> node get.js Making a call to contract at address: 0x6dcb33a7f6235e74fd553b50c96f900707142892 The current number stored is: 8 node reset.js Calling the reset function in contract at address: 0x6dcb33a7f6235e74fd553b50c96f900707142892 Tx successful with hash: 0x557e908ca4da05d5af50983dbc116fbf8049bb2e86b9ec1e9f7d3f516b8a4c55 node get.js Making a call to contract at address: 0x6dcb33a7f6235e74fd553b50c96f900707142892 The current number stored is: 0    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/libraries/web3py/","title":"Web3.py Python Library","text":""},{"location":"builders/ethereum/libraries/web3py/#introduction","title":"Introduction","text":"<p>Web3.py is a set of libraries that allow developers to interact with Ethereum nodes using HTTP, IPC, or WebSocket protocols with Python. Moonbeam has an Ethereum-like API available that is fully compatible with Ethereum-style JSON-RPC invocations. Therefore, developers can leverage this compatibility and use the Web3.py library to interact with a Moonbeam node as if they were doing so on Ethereum.</p> <p>In this guide, you'll learn how to use the Web3.py library to send a transaction and deploy a contract on Moonbase Alpha. This guide can be adapted for Moonbeam, Moonriver, or a Moonbeam development node.</p>"},{"location":"builders/ethereum/libraries/web3py/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"},{"location":"builders/ethereum/libraries/web3py/#create-a-python-project","title":"Create a Python Project","text":"<p>To get started, you can create a directory to store all of the files you'll be creating throughout this guide:</p> <pre><code>mkdir web3-examples &amp;&amp; cd web3-examples\n</code></pre> <p>For this guide, you'll need to install the Web3.py library and the Solidity compiler. To install both packages, you can run the following command:</p> <pre><code>pip3 install web3 py-solc-x solc-select\n</code></pre>"},{"location":"builders/ethereum/libraries/web3py/#setup-web3-with-moonbeam","title":"Setup Web3.py with Moonbeam","text":"<p>Throughout this guide, you'll be creating a bunch of scripts that provide different functionalities, such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts, you'll need to create a Web3.py provider to interact with the network.</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>To create a provider, you can take the following steps:</p> <ol> <li>Import the <code>web3</code> library</li> <li>Create the <code>web3</code> provider using the <code>Web3(Web3.HTTPProvider())</code> method and providing the endpoint URL</li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nweb3 = Web3(Web3.HTTPProvider(\"INSERT_RPC_API_ENDPOINT\")) # Insert your RPC URL here\n</code></pre> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nweb3 = Web3(Web3.HTTPProvider(\"INSERT_RPC_API_ENDPOINT\")) # Insert your RPC URL here\n</code></pre> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n</code></pre> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nweb3 = Web3(Web3.HTTPProvider(\"http://127.0.0.1:9944\"))\n</code></pre> <p>Save this code snippet, as you'll need it for the scripts that are used in the following sections.</p>"},{"location":"builders/ethereum/libraries/web3py/#send-a-transaction","title":"Send a Transaction","text":"<p>During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.</p> <p>You can also use the balance script to check the account balances after the transaction has been sent.</p>"},{"location":"builders/ethereum/libraries/web3py/#check-balances-script","title":"Check Balances Script","text":"<p>You'll only need one file to check the balances of both addresses before and after the transaction is sent.  To get started, you can create a <code>balances.py</code> file by running:</p> <pre><code>touch balances.py\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Web3 provider</li> <li>Define the <code>address_from</code> and <code>address_to</code> variables</li> <li>Get the balance for the accounts using the <code>web3.eth.get_balance</code> function and format the results using the <code>web3.from_wei</code></li> </ol> <pre><code>from web3 import Web3\n\n# 1. Add the Web3 provider logic here:\nprovider_rpc = {\n    \"development\": \"http://localhost:9944\",\n    \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network\n\n# 2. Create address variables\naddress_from = 'INSERT_FROM_ADDRESS'\naddress_to = 'INSERT_TO_ADDRESS'\n\n# 3. Fetch balance data\nbalance_from = web3.from_wei(\n    web3.eth.get_balance(Web3.to_checksum_address(address_from)), \"ether\"\n)\nbalance_to = web3.from_wei(\n    web3.eth.get_balance(Web3.to_checksum_address(address_to)), \"ether\"\n)\n\nprint(f\"The balance of { address_from } is: { balance_from } DEV\")\nprint(f\"The balance of { address_to } is: { balance_to } DEV\")\n</code></pre> <p>To run the script and fetch the account balances, you can run the following command:</p> <pre><code>python3 balances.py\n</code></pre> <p>If successful, the balances for the origin and receiving address will be displayed in your terminal in ETH.</p>"},{"location":"builders/ethereum/libraries/web3py/#send-transaction-script","title":"Send Transaction Script","text":"<p>You'll only need one file for executing a transaction between accounts. For this example, you'll be transferring 1 DEV token from an origin address (from which you hold the private key) to another address. To get started, you can create a <code>transaction.py</code> file by running:</p> <pre><code>touch transaction.py\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Add imports, including Web3.py and the <code>rpc_gas_price_strategy</code>, which will be used in the following steps to get the gas price used for the transaction</li> <li>Set up the Web3 provider</li> <li>Define the <code>account_from</code>, including the <code>private_key</code>, and the <code>address_to</code> variables. The private key is required to sign the transaction. Note: This is for example purposes only. Never store your private keys in a Python file</li> <li>Use the Web3.py Gas Price API to set a gas price strategy. For this example, you'll use the imported <code>rpc_gas_price_strategy</code></li> <li>Create and sign the transaction using the <code>web3.eth.account.sign_transaction</code> function. Pass in the <code>nonce</code> <code>gas</code>, <code>gasPrice</code>, <code>to</code>, and <code>value</code> for the transaction along with the sender's <code>private_key</code>. To get the <code>nonce</code> you can use the <code>web3.eth.get_transaction_count</code> function and pass in the sender's address. To predetermine the <code>gasPrice</code> you'll use the <code>web3.eth.generate_gas_price</code> function. For the <code>value</code>, you can format the amount to send from an easily readable format to Wei using the <code>web3.to_wei</code> function</li> <li>Using the signed transaction, you can then send it using the <code>web3.eth.send_raw_transaction</code> function and wait for the transaction receipt by using the <code>web3.eth.wait_for_transaction_receipt</code> function</li> </ol> <pre><code># 1. Add imports\nfrom web3.gas_strategies.rpc import rpc_gas_price_strategy\nfrom web3 import Web3\n\n# 2. Add the Web3 provider logic here:\nprovider_rpc = {\n    \"development\": \"http://localhost:9944\",\n    \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network\n\n# 3. Create address variables\naccount_from = {\n    'private_key': 'INSERT_YOUR_PRIVATE_KEY',\n    'address': 'INSERT_PUBLIC_ADDRESS_OF_PK',\n}\naddress_to = 'INSERT_TO_ADDRESS'\n\nprint(\n    f'Attempting to send transaction from { account_from[\"address\"] } to { address_to }'\n)\n\n# 4. Set the gas price strategy\nweb3.eth.set_gas_price_strategy(rpc_gas_price_strategy)\n\n# 5. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(\n    {\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n        \"gasPrice\": web3.eth.generate_gas_price(),\n        \"gas\": 21000,\n        \"to\": Web3.to_checksum_address(address_to),\n        \"value\": web3.to_wei(\"1\", \"ether\"),\n    },\n    account_from[\"private_key\"],\n)\n\n# 6. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Transaction successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>To run the script, you can run the following command in your terminal:</p> <pre><code>python3 transaction.py\n</code></pre> <p>If the transaction was successful, in your terminal you'll see the transaction hash has been printed out.</p> <p>You can also use the <code>balances.py</code> script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:</p> python3 balances.py The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3563.79 DEV The balance of 0x9Bf5Ae10540a1ab9B363bEA02A9406E6b2efA9af is: 0 DEV python3 transaction.py Attempting to send transaction from 0x3B939FeaD1557C741Ff06492FD0127bd287A421e to 0x9Bf5Ae10540a1ab9B363bEA02A9406E6b2efA9af Transaction successful with hash: 0xac70452510657ed43c27510578d3ce4b3b880d4cca1a24ade1497c6e0ee7f5d6 python3 balances.py The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3562.79 DEV The balance of 0x9Bf5Ae10540a1ab9B363bEA02A9406E6b2efA9af is: 1 DEV"},{"location":"builders/ethereum/libraries/web3py/#deploy-a-contract","title":"Deploy a Contract","text":"<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (the default is <code>0</code>). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only and does not handle values wrapping around.</p>"},{"location":"builders/ethereum/libraries/web3py/#compile-contract-script","title":"Compile Contract Script","text":"<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.py</code> file by running:</p> <pre><code>touch compile.py\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>solcx</code> package</li> <li>Optional - If you haven't already installed the Solidity compiler, you can do so with by using the <code>solcx.install_solc</code> function</li> <li>Compile the <code>Incrementer.sol</code> function using the <code>solcx.compile_files</code> function</li> <li>Export the contract's ABI and bytecode</li> </ol> <pre><code># 1. Import solcx\nimport solcx\n\n# 2. If you haven't already installed the Solidity compiler, uncomment the following line\n# solcx.install_solc()\n\n# 3. Compile contract\ntemp_file = solcx.compile_files(\n    'Incrementer.sol',\n    output_values=['abi', 'bin'],\n    # solc_version='0.8.19'\n)\n\n# 4. Export contract data\nabi = temp_file['Incrementer.sol:Incrementer']['abi']\nbytecode = temp_file['Incrementer.sol:Incrementer']['bin']\n</code></pre> <p>Note</p> <p>If you see an error stating that <code>Solc is not installed</code>, uncomment step 2 described in the code snippet.</p>"},{"location":"builders/ethereum/libraries/web3py/#deploy-contract-script","title":"Deploy Contract Script","text":"<p>With the script for compiling the <code>Incrementer.sol</code> contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called <code>deploy.py</code>:</p> <pre><code>touch deploy.py\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Add imports, including Web3.py and the ABI and bytecode of the <code>Incrementer.sol</code> contract</li> <li>Set up the Web3 provider</li> <li>Define the <code>account_from</code>, including the <code>private_key</code>. The private key is required to sign the transaction. Note: This is for example purposes only. Never store your private keys in a Python file</li> <li>Create a contract instance using the <code>web3.eth.contract</code> function and passing in the ABI and bytecode of the contract</li> <li>Build a constructor transaction using the contract instance and passing in the value to increment by. For this example, you can use <code>5</code>. You'll then use the <code>build_transaction</code> function to pass in the transaction information including the <code>from</code> address and the <code>nonce</code> for the sender. To get the <code>nonce</code> you can use the <code>web3.eth.get_transaction_count</code> function </li> <li>Sign the transaction using the <code>web3.eth.account.sign_transaction</code> function and pass in the constructor transaction and the <code>private_key</code> of the sender</li> <li>Using the signed transaction, you can then send it using the <code>web3.eth.send_raw_transaction</code> function and wait for the transaction receipt by using the <code>web3.eth.wait_for_transaction_receipt</code> function</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi, bytecode\nfrom web3 import Web3\n\n# 2. Add the Web3 provider logic here:\nprovider_rpc = {\n    \"development\": \"http://localhost:9944\",\n    \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network\n\n# 3. Create address variable\naccount_from = {\n    'private_key': 'INSERT_YOUR_PRIVATE_KEY',\n    'address': 'INSERT_PUBLIC_ADDRESS_OF_PK',\n}\n\nprint(f'Attempting to deploy from account: { account_from[\"address\"] }')\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(abi=abi, bytecode=bytecode)\n\n# 5. Build constructor tx\nconstruct_txn = Incrementer.constructor(5).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(\n    construct_txn, account_from[\"private_key\"]\n)\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Contract deployed at address: { tx_receipt.contractAddress }\")\n</code></pre> <p>To run the script, you can enter the following command into your terminal:</p> <pre><code>python3 deploy.py\n</code></pre> <p>If successful, the contract's address will be displayed in the terminal.</p> python3 deploy.py Attempting to deploy from account: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Contract deployed at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08"},{"location":"builders/ethereum/libraries/web3py/#read-contract-data","title":"Read Contract Data (Call Methods)","text":"<p>Call methods are the type of interaction that don't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.</p> <p>To get started, you can create a file and name it <code>get.py</code>:</p> <pre><code>touch get.py\n</code></pre> <p>Then you can take the following steps to create the script:</p> <ol> <li>Add imports, including Web3.py and the ABI of the <code>Incrementer.sol</code> contract</li> <li>Set up the Web3 provider</li> <li>Define the <code>contract_address</code> of the deployed contract</li> <li>Create a contract instance using the <code>web3.eth.contract</code> function and passing in the ABI and address of the deployed contract</li> <li>Using the contract instance, you can then call the <code>number</code> function</li> </ol> <pre><code># 1. Import the ABI\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Add the Web3 provider logic here:\nprovider_rpc = {\n    \"development\": \"http://localhost:9944\",\n    \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network\n\n# 3. Create address variable\ncontract_address = 'INSERT_CONTRACT_ADDRESS'\n\nprint(f\"Making a call to contract at address: { contract_address }\")\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Call Contract\nnumber = Incrementer.functions.number().call()\nprint(f\"The current number stored is: { number } \")\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>python3 get.py\n</code></pre> <p>If successful, the value will be displayed in the terminal.</p>"},{"location":"builders/ethereum/libraries/web3py/#interact-with-contract","title":"Interact with Contract (Send Methods)","text":"<p>Send methods are the type of interaction that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them <code>increment.py</code> and <code>reset.py</code>:</p> <pre><code>touch increment.py reset.py\n</code></pre> <p>Open the <code>increment.py</code> file and take the following steps to create the script:</p> <ol> <li>Add imports, including Web3.py and the ABI of the <code>Incrementer.sol</code> contract</li> <li>Set up the Web3 provider</li> <li>Define the <code>account_from</code>, including the <code>private_key</code>, the <code>contract_address</code> of the deployed contract, and the <code>value</code> to increment by. The private key is required to sign the transaction. Note: This is for example purposes only. Never store your private keys in a Python file</li> <li>Create a contract instance using the <code>web3.eth.contract</code> function and passing in the ABI and address of the deployed contract</li> <li>Build the increment transaction using the contract instance and passing in the value to increment by. You'll then use the <code>build_transaction</code> function to pass in the transaction information including the <code>from</code> address and the <code>nonce</code> for the sender. To get the <code>nonce</code> you can use the <code>web3.eth.get_transaction_count</code> function</li> <li>Sign the transaction using the <code>web3.eth.account.sign_transaction</code> function and pass in the increment transaction and the <code>private_key</code> of the sender</li> <li>Using the signed transaction, you can then send it using the <code>web3.eth.send_raw_transaction</code> function and wait for the transaction receipt by using the <code>web3.eth.wait_for_transaction_receipt</code> function</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Add the Web3 provider logic here:\nprovider_rpc = {\n    \"development\": \"http://localhost:9944\",\n    \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network\n\n# 3. Create variables\naccount_from = {\n    'private_key': 'INSERT_YOUR_PRIVATE_KEY',\n    'address': 'INSERT_PUBLIC_ADDRESS_OF_PK',\n}\ncontract_address = 'INSERT_CONTRACT_ADDRESS'\nvalue = 3\n\nprint(\n    f\"Calling the increment by { value } function in contract at address: { contract_address }\"\n)\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Build increment tx\nincrement_tx = Incrementer.functions.increment(value).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(increment_tx, account_from[\"private_key\"])\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Tx successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>python3 increment.py\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.py</code> script alongside the <code>increment.py</code> script to make sure that value is changing as expected:</p> python get.py Making a call to contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 The current number stored is: 5 python increment.py Calling the increment by 3 function in contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 Tx successful with hash: 0x47757fd97e3ef8db973e335d1f2d19c46b37d0dbd53fea1636ec559ccf119a13 python get.py Making a call to contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 The current number stored is: 8 <p>Next you can open the <code>reset.py</code> file and take the following steps to create the script:</p> <ol> <li>Add imports, including Web3.py and the ABI of the <code>Incrementer.sol</code> contract</li> <li>Set up the Web3 provider</li> <li>Define the <code>account_from</code>, including the <code>private_key</code>, and the <code>contract_address</code> of the deployed contract. The private key is required to sign the transaction. Note: This is for example purposes only. Never store your private keys in a Python file</li> <li>Create a contract instance using the <code>web3.eth.contract</code> function and passing in the ABI and address of the deployed contract</li> <li>Build the reset transaction using the contract instance. You'll then use the <code>build_transaction</code> function to pass in the transaction information including the <code>from</code> address and the <code>nonce</code> for the sender. To get the <code>nonce</code> you can use the <code>web3.eth.get_transaction_count</code> function</li> <li>Sign the transaction using the <code>web3.eth.account.sign_transaction</code> function and pass in the reset transaction and the <code>private_key</code> of the sender</li> <li>Using the signed transaction, you can then send it using the <code>web3.eth.send_raw_transaction</code> function and wait for the transaction receipt by using the <code>web3.eth.wait_for_transaction_receipt</code> function</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Add the Web3 provider logic here:\nprovider_rpc = {\n    \"development\": \"http://localhost:9944\",\n    \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network\n\n# 3. Create variables\naccount_from = {\n    'private_key': 'INSERT_YOUR_PRIVATE_KEY',\n    'address': 'INSERT_PUBLIC_ADDRESS_OF_PK',\n}\ncontract_address = 'INSERT_CONTRACT_ADDRESS'\n\nprint(f\"Calling the reset function in contract at address: { contract_address }\")\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Build reset tx\nreset_tx = Incrementer.functions.reset().build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(reset_tx, account_from[\"private_key\"])\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Tx successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>python3 reset.py\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.py</code> script alongside the <code>reset.py</code> script to make sure that value is changing as expected:</p> python get.py Making a call to contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 The current number stored is: 8 python reset.py Calling the reset function in contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 Tx successful with hash: 0x152f07430b524838da848b44d58577db252681fba6fbeaf117b2f9d432e301b2 python get.py Making a call to contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 The current number stored is: 0    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/precompiles/overview/","title":"Overview of the Precompiled Contracts on Moonbeam","text":""},{"location":"builders/ethereum/precompiles/overview/#introduction","title":"Overview","text":"<p>On Moonbeam, a precompiled contract is native Substrate code that has an Ethereum-style address and can be called using the Ethereum API, like any other smart contract. The precompiles allow you to call the Substrate runtime directly which is not normally accessible from the Ethereum side of Moonbeam.</p> <p>The Substrate code responsible for implementing precompiles can be found in the EVM pallet. The EVM pallet includes the standard precompiles found on Ethereum and some additional precompiles that are not specific to Ethereum. It also provides the ability to create and execute custom precompiles through the generic <code>Precompiles</code> trait. There are several custom Moonbeam-specific precompiles that have been created, all of which can be found in the Moonbeam codebase. It is important to highlight that the precompiles from this list with the <code>CallableByContract</code> check are not callable inside the contract constructor.</p> <p>The Ethereum precompiled contracts contain complex functionality that is computationally intensive, such as hashing and encryption. The custom precompiled contracts on Moonbeam provide access to Substrate-based functionality such as staking, governance, XCM-related functions, and more.</p> <p>The Moonbeam-specific precompiles can be interacted with through familiar and easy-to-use Solidity interfaces using the Ethereum API, which are ultimately used to interact with the underlying Substrate interface. This flow is depicted in the following diagram:</p> <p></p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/overview/#precompiled-contract-addresses","title":"Precompiled Contract Addresses","text":"<p>The precompiled contracts are categorized by address and based on the origin network. If you were to convert the precompiled addresses to decimal format, and break them into categories by numeric value, the categories are as follows:</p> <ul> <li>0-1023 - Ethereum MainNet precompiles</li> <li>1024-2047 - precompiles that are not in Ethereum and not Moonbeam specific</li> <li>2048-4095 - Moonbeam specific precompiles</li> </ul>"},{"location":"builders/ethereum/precompiles/overview/#ethereum-mainnet-precompiles","title":"Ethereum MainNet Precompiles","text":"MoonbeamMoonriverMoonbase Alpha Contract Address ECRECOVER 0x0000000000000000000000000000000000000001 SHA256 0x0000000000000000000000000000000000000002 RIPEMD160 0x0000000000000000000000000000000000000003 Identity 0x0000000000000000000000000000000000000004 Modular Exponentiation 0x0000000000000000000000000000000000000005 BN128Add 0x0000000000000000000000000000000000000006 BN128Mul 0x0000000000000000000000000000000000000007 BN128Pairing 0x0000000000000000000000000000000000000008 Blake2 0x0000000000000000000000000000000000000009 P256Verify 0x0000000000000000000000000000000000000100 Contract Address ECRECOVER 0x0000000000000000000000000000000000000001 SHA256 0x0000000000000000000000000000000000000002 RIPEMD160 0x0000000000000000000000000000000000000003 Identity 0x0000000000000000000000000000000000000004 Modular Exponentiation 0x0000000000000000000000000000000000000005 BN128Add 0x0000000000000000000000000000000000000006 BN128Mul 0x0000000000000000000000000000000000000007 BN128Pairing 0x0000000000000000000000000000000000000008 Blake2 0x0000000000000000000000000000000000000009 P256Verify 0x0000000000000000000000000000000000000100 Contract Address ECRECOVER 0x0000000000000000000000000000000000000001 SHA256 0x0000000000000000000000000000000000000002 RIPEMD160 0x0000000000000000000000000000000000000003 Identity 0x0000000000000000000000000000000000000004 Modular Exponentiation 0x0000000000000000000000000000000000000005 BN128Add 0x0000000000000000000000000000000000000006 BN128Mul 0x0000000000000000000000000000000000000007 BN128Pairing 0x0000000000000000000000000000000000000008 Blake2 0x0000000000000000000000000000000000000009 P256Verify 0x0000000000000000000000000000000000000100"},{"location":"builders/ethereum/precompiles/overview/#non-moonbeam-specific-nor-ethereum-precompiles","title":"Non-Moonbeam Specific nor Ethereum Precompiles","text":"MoonbeamMoonriverMoonbase Alpha Contract Address SHA3FIPS256 0x0000000000000000000000000000000000000400 Dispatch [Removed] 0x0000000000000000000000000000000000000401 ECRecoverPublicKey 0x0000000000000000000000000000000000000402 Contract Address SHA3FIPS256 0x0000000000000000000000000000000000000400 Dispatch [Removed] 0x0000000000000000000000000000000000000401 ECRecoverPublicKey 0x0000000000000000000000000000000000000402 Contract Address SHA3FIPS256 0x0000000000000000000000000000000000000400 Dispatch [Removed] 0x0000000000000000000000000000000000000401 ECRecoverPublicKey 0x0000000000000000000000000000000000000402"},{"location":"builders/ethereum/precompiles/overview/#moonbeam-specific-precompiles","title":"Moonbeam Specific Precompiles","text":"MoonbeamMoonriverMoonbase Alpha Contract Address Parachain Staking 0x0000000000000000000000000000000000000800 Crowdloan Rewards 0x0000000000000000000000000000000000000801 ERC-20 Interface 0x0000000000000000000000000000000000000802 Democracy [Removed] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 Relay Encoder 0x0000000000000000000000000000000000000805 XCM Transactor V1 0x0000000000000000000000000000000000000806 Author Mapping 0x0000000000000000000000000000000000000807 Batch 0x0000000000000000000000000000000000000808 Randomness 0x0000000000000000000000000000000000000809 Call Permit 0x000000000000000000000000000000000000080a Proxy 0x000000000000000000000000000000000000080b XCM Utilities 0x000000000000000000000000000000000000080C XCM Transactor V2 0x000000000000000000000000000000000000080d Council Collective [Removed] 0x000000000000000000000000000000000000080e Technical Committee Collective [Removed] 0x000000000000000000000000000000000000080f Treasury Council Collective 0x0000000000000000000000000000000000000810 Referenda 0x0000000000000000000000000000000000000811 Conviction Voting 0x0000000000000000000000000000000000000812 Preimage 0x0000000000000000000000000000000000000813 OpenGov Tech Committee 0x0000000000000000000000000000000000000814 Precompile Registry 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM Transactor V3 0x0000000000000000000000000000000000000817 XCM interface 0x000000000000000000000000000000000000081A Identity 0x0000000000000000000000000000000000000818 Contract Address Parachain Staking 0x0000000000000000000000000000000000000800 Crowdloan Rewards 0x0000000000000000000000000000000000000801 ERC-20 Interface 0x0000000000000000000000000000000000000802 Democracy [Disabled] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 Relay Encoder 0x0000000000000000000000000000000000000805 XCM Transactor V1 0x0000000000000000000000000000000000000806 Author Mapping 0x0000000000000000000000000000000000000807 Batch 0x0000000000000000000000000000000000000808 Randomness 0x0000000000000000000000000000000000000809 Call Permit 0x000000000000000000000000000000000000080a Proxy 0x000000000000000000000000000000000000080b XCM Utilities 0x000000000000000000000000000000000000080C XCM Transactor V2 0x000000000000000000000000000000000000080d Council Collective [Removed] 0x000000000000000000000000000000000000080e Technical Committee Collective [Removed] 0x000000000000000000000000000000000000080f Treasury Council Collective 0x0000000000000000000000000000000000000810 Referenda 0x0000000000000000000000000000000000000811 Conviction Voting 0x0000000000000000000000000000000000000812 Preimage 0x0000000000000000000000000000000000000813 OpenGov Tech Committee 0x0000000000000000000000000000000000000814 Precompile Registry 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM Transactor V3 0x0000000000000000000000000000000000000817 XCM interface 0x000000000000000000000000000000000000081A Identity 0x0000000000000000000000000000000000000818 Contract Address Parachain Staking 0x0000000000000000000000000000000000000800 Crowdloan Rewards 0x0000000000000000000000000000000000000801 ERC-20 Interface 0x0000000000000000000000000000000000000802 Democracy [Removed] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 Relay Encoder 0x0000000000000000000000000000000000000805 XCM Transactor V1 0x0000000000000000000000000000000000000806 Author Mapping 0x0000000000000000000000000000000000000807 Batch 0x0000000000000000000000000000000000000808 Randomness 0x0000000000000000000000000000000000000809 Call Permit 0x000000000000000000000000000000000000080a Proxy 0x000000000000000000000000000000000000080b XCM Utilities 0x000000000000000000000000000000000000080C XCM Transactor V2 0x000000000000000000000000000000000000080d Council Collective [Removed] 0x000000000000000000000000000000000000080e Technical Committee Collective [Removed] 0x000000000000000000000000000000000000080f Treasury Council Collective 0x0000000000000000000000000000000000000810 Referenda 0x0000000000000000000000000000000000000811 Conviction Voting 0x0000000000000000000000000000000000000812 Preimage 0x0000000000000000000000000000000000000813 OpenGov Tech Committee 0x0000000000000000000000000000000000000814 Precompile Registry 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM Transactor V3 0x0000000000000000000000000000000000000817 XCM Interface 0x000000000000000000000000000000000000081A Identity 0x0000000000000000000000000000000000000818"},{"location":"builders/ethereum/precompiles/account/identity/","title":"Identity Precompile on Moonbeam","text":""},{"location":"builders/ethereum/precompiles/account/identity/#introduction","title":"Introduction","text":"<p>The Identity Precompile is a Solidity interface that allows you to create, manage, and retrieve information on on-chain identities. Identities are attached to accounts and include personal information, such as your legal name, display name, website, Twitter handle, Riot (now known as Element) name, and more. You can also take advantage of custom fields to include any other relevant information.</p> <p>The Identity Precompile interacts directly with Substrate's Identity Pallet to provide the functionality needed to create and manage identities. This pallet is coded in Rust and is normally not accessible from the Ethereum side of Moonbeam. However, the Identity Precompile allows you to access this functionality directly from the Solidity interface.</p> <p>The Identity Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000818\n</code></pre> <pre><code>0x0000000000000000000000000000000000000818\n</code></pre> <pre><code>0x0000000000000000000000000000000000000818\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/account/identity/#the-solidity-interface","title":"The Identity Precompile Solidity Interface","text":"<p><code>Identity.sol</code> is a Solidity interface that allows developers to interact with the precompile's methods.</p> Identity.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Identity contract's address.\naddress constant IDENTITY_ADDRESS = 0x0000000000000000000000000000000000000818;\n\n/// @dev The Identity contract's instance.\nIdentity constant IDENTITY_CONTRACT = Identity(IDENTITY_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Pallet Identity Interface\n/// @title The interface through which solidity contracts will interact with the Identity pallet\n/// @custom:address 0x0000000000000000000000000000000000000818\ninterface Identity {\n    /// @dev Associated raw data.\n    struct Data {\n        /// Is `true` if it represents data, else the absence of data is represented by `false`.\n        bool hasData;\n        /// The contained value.\n        bytes value;\n    }\n\n    /// @dev The super-identity of an alternative \"sub\" identity.\n    struct SuperOf {\n        /// Is `true` if the struct is valid, `false` otherwise.\n        bool isValid;\n        /// The super account.\n        address account;\n        /// The associated data.\n        Data data;\n    }\n\n    /// @dev Alternative \"sub\" identities of an account.\n    struct SubsOf {\n        /// The deposit against this identity.\n        uint256 deposit;\n        /// The sub accounts\n        address[] accounts;\n    }\n\n    /// @dev Registrar judgements are limited to attestations on these fields.\n    struct IdentityFields {\n        /// Set to `true` if the display field is supported, `false` otherwise.\n        bool display;\n        /// Set to `true` if the legal field is supported, `false` otherwise.\n        bool legal;\n        /// Set to `true` if the web field is supported, `false` otherwise.\n        bool web;\n        /// Set to `true` if the riot field is supported, `false` otherwise.\n        bool riot;\n        /// Set to `true` if the email field is supported, `false` otherwise.\n        bool email;\n        /// Set to `true` if the PGP Fingerprint field is supported, `false` otherwise.\n        bool pgpFingerprint;\n        /// Set to `true` if the image field is supported, `false` otherwise.\n        bool image;\n        /// Set to `true` if the twitter field is supported, `false` otherwise.\n        bool twitter;\n    }\n\n    /// @dev Registrar info.\n    struct Registrar {\n        /// Is `true` if the struct is valid, `false` otherwise.\n        bool isValid;\n        /// The registrar's index.\n        uint32 index;\n        /// The account address.\n        address account;\n        /// Amount required to be given to the registrar for them to provide judgement.\n        uint256 fee;\n        /// Relevant fields for this registrar.\n        IdentityFields fields;\n    }\n\n    /// @dev Represents an additional field in identity info.\n    struct Additional {\n        /// The assciated key.\n        Data key;\n        /// The assciated value.\n        Data value;\n    }\n\n    /// @dev The identity information set for an account.\n    struct IdentityInfo {\n        /// Represents the additional fields for the identity.\n        Additional[] additional;\n        /// Represents the display info for the identity.\n        Data display;\n        /// Represents the legal info for the identity.\n        Data legal;\n        /// Represents the web info for the identity.\n        Data web;\n        /// Represents the riot info for the identity.\n        Data riot;\n        /// Represents the email info for the identity.\n        Data email;\n        /// Set to `true` if `pgpFingerprint` is set, `false` otherwise.\n        bool hasPgpFingerprint;\n        /// Represents a 20-byte the PGP fingerprint info for the identity.\n        bytes pgpFingerprint;\n        /// Represents the image info for the identity.\n        Data image;\n        /// Represents the twitter info for the identity.\n        Data twitter;\n    }\n\n    /// @dev Judgement provided by a registrar.\n    struct Judgement {\n        /// The default value; no opinion is held.\n        bool isUnknown;\n        /// No judgement is yet in place, but a deposit is reserved as payment for providing one.\n        bool isFeePaid;\n        /// The deposit reserved for providing a judgement.\n        uint256 feePaidDeposit;\n        /// The data appears to be reasonably acceptable in terms of its accuracy.\n        bool isReasonable;\n        /// The target is known directly by the registrar and the registrar can fully attest to it.\n        bool isKnownGood;\n        /// The data was once good but is currently out of date.\n        bool isOutOfDate;\n        /// The data is imprecise or of sufficiently low-quality to be problematic.\n        bool isLowQuality;\n        /// The data is erroneous. This may be indicative of malicious intent.\n        bool isErroneous;\n    }\n\n    /// @dev Judgement item provided by a registrar.\n    struct JudgementInfo {\n        /// The registrar's index that provided this judgement.\n        uint32 registrarIndex;\n        /// The registrar's provided judgement.\n        Judgement judgement;\n    }\n\n    /// @dev Registrar info.\n    struct Registration {\n        /// Is `true` if the struct is valid, `false` otherwise.\n        bool isValid;\n        /// The judgments provided on this identity.\n        JudgementInfo[] judgements;\n        /// Amount required to be given to the registrar for them to provide judgement.\n        uint256 deposit;\n        /// The associated identity info.\n        IdentityInfo info;\n    }\n\n    /// @dev Alternative \"sub\" identity of an account.\n    struct SubAccount {\n        /// The account address.\n        address account;\n        /// The associated data.\n        Data data;\n    }\n\n    /// @dev Retrieve identity information for an account.\n    /// @custom:selector f0eb5e54\n    /// @param who The requested account\n    function identity(address who) external view returns (Registration memory);\n\n    /// @dev Retrieve super account for an account.\n    /// @custom:selector c18110d6\n    /// @param who The requested account\n    function superOf(address who) external view returns (SuperOf memory);\n\n    /// @dev Retrieve sub accounts for an account.\n    /// @custom:selector 3f08986b\n    /// @param who The requested account\n    function subsOf(address who) external view returns (SubsOf memory);\n\n    /// @dev Retrieve the registrars.\n    /// @custom:selector e88e512e\n    function registrars() external view returns (Registrar[] memory);\n\n    /// @dev Set identity info for the caller.\n    /// @custom:selector 7e08b4cb\n    /// @param info The identity info\n    function setIdentity(IdentityInfo memory info) external;\n\n    /// @dev Set sub accounts for the caller.\n    /// @custom:selector 5a5a3591\n    /// @param subs The sub accounts\n    function setSubs(SubAccount[] memory subs) external;\n\n    /// @dev Clears identity of the caller.\n    /// @custom:selector 7a6a10c7\n    function clearIdentity() external;\n\n    /// @dev Requests registrar judgement on caller's identity.\n    /// @custom:selector d523ceb9\n    /// @param regIndex The registrar's index\n    /// @param maxFee The maximum fee the caller is willing to pay\n    function requestJudgement(uint32 regIndex, uint256 maxFee) external;\n\n    /// @dev Cancels the caller's request for judgement from a registrar.\n    /// @custom:selector c79934a5\n    /// @param regIndex The registrar's index\n    function cancelRequest(uint32 regIndex) external;\n\n    /// @dev Sets the registrar's fee for providing a judgement. Caller must be the account at the index.\n    /// @custom:selector a541b37d\n    /// @param regIndex The registrar's index\n    /// @param fee The fee the registrar will charge\n    function setFee(uint32 regIndex, uint256 fee) external;\n\n    /// @dev Sets the registrar's account. Caller must be the account at the index.\n    /// @custom:selector 889bc198\n    /// @param regIndex The registrar's index\n    /// @param newAccount The new account to set\n    function setAccountId(uint32 regIndex, address newAccount) external;\n\n    /// @dev Sets the registrar's identity fields. Caller must be the account at the index.\n    /// @custom:selector 05297450\n    /// @param regIndex The registrar's index\n    /// @param fields The identity fields\n    function setFields(uint32 regIndex, IdentityFields memory fields) external;\n\n    /// @dev Provides judgement on an accounts identity.\n    /// @custom:selector cd7663a4\n    /// @param regIndex The registrar's index\n    /// @param target The target account to provide judgment for\n    /// @param judgement The judgement to provide\n    /// @param identity The hash of the identity info\n    function provideJudgement(\n        uint32 regIndex,\n        address target,\n        Judgement memory judgement,\n        bytes32 identity\n    ) external;\n\n    /// @dev Add a \"sub\" identity account for the caller.\n    /// @custom:selector 98717196\n    /// @param sub The sub account\n    /// @param data The associated data\n    function addSub(address sub, Data memory data) external;\n\n    /// @dev Rename a \"sub\" identity account of the caller.\n    /// @custom:selector 452df561\n    /// @param sub The sub account\n    /// @param data The new associated data\n    function renameSub(address sub, Data memory data) external;\n\n    /// @dev Removes a \"sub\" identity account of the caller.\n    /// @custom:selector b0a323e0\n    /// @param sub The sub account\n    function removeSub(address sub) external;\n\n    /// @dev Removes the sender as a sub-account.\n    /// @custom:selector d5a3c2c4\n    function quitSub() external;\n\n    /// @dev An identity was set or reset (which will remove all judgements).\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param who Address of the target account\n    event IdentitySet(address who);\n\n    /// @dev An identity was cleared, and the given balance returned.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param who Address of the target account\n    event IdentityCleared(address who);\n\n    /// @dev A judgement was asked from a registrar.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param who Address of the requesting account\n    /// @param registrarIndex The registrar's index\n    event JudgementRequested(address who, uint32 registrarIndex);\n\n    /// @dev A judgement request was retracted.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param who Address of the target account.\n    /// @param registrarIndex The registrar's index\n    event JudgementUnrequested(address who, uint32 registrarIndex);\n\n    /// @dev A judgement was given by a registrar.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param target Address of the target account\n    /// @param registrarIndex The registrar's index\n    event JudgementGiven(address target, uint32 registrarIndex);\n\n    /// @dev A sub-identity was added to an identity and the deposit paid.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param sub Address of the sub account\n    /// @param main Address of the main account\n    event SubIdentityAdded(address sub, address main);\n\n    /// @dev A sub-identity was removed from an identity and the deposit freed.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param sub Address of the sub account\n    /// @param main Address of the main account\n    event SubIdentityRemoved(address sub, address main);\n\n    /// @dev A sub-identity was cleared and the given deposit repatriated from the main identity account to the sub-identity account\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param sub Address of the sub account\n    event SubIdentityRevoked(address sub);\n}\n</code></pre> <p>The Identity Precompile contains some functions that can be called by anyone and some judgment-related functions that can only be called by a registrar. The functions that can be called by anyone are as follows:</p> identity(address who) - returns registration information for a given account Parameters <ul> <li><code>who</code> - address of the account to query the identity information for</li> </ul> superOf(address who) - retrieves the super account for a sub-account. If the given account is not a sub-account, the address returned is <code>0x0000000000000000000000000000000000000000</code> Parameters <ul> <li><code>who</code> - address of the account to query the super-account for</li> </ul> subsOf(address who) - returns the sub-accounts for a given account. If the given account doesn't have any sub-accounts, an empty array is returned (<code>[]</code>) Parameters <ul> <li><code>who</code> - address of the account to query the sub-accounts for</li> </ul> registrars() - returns the list of registrars Parameters <p>None.</p> setIdentity(IdentityInfo memory info) - sets the identity for the caller Parameters <ul> <li><code>info</code> - IdentityInfo memory struct containing the identity information to be set</li> </ul> setSubs(SubAccount[] memory subs) - sets the sub-accounts for the caller Parameters <ul> <li><code>subs</code> - SubAccount[] memory array containing the sub-accounts to be set</li> </ul> clearIdentity() - clears the identity for the caller Parameters <p>None.</p> requestJudgement(uint32 regIndex, uint256 maxFee) - requests judgment from a given registrar along with the maximum fee the caller is willing to pay Parameters <ul> <li><code>regIndex</code> - uint32 index of the registrar to request judgment from</li> <li><code>maxFee</code> - uint256 maximum fee the caller is willing to pay for the judgment</li> </ul> cancelRequest(uint32 regIndex) - cancels the caller's request for judgment from a given registrar Parameters <ul> <li><code>regIndex</code> - uint32 index of the registrar to cancel the judgment request from</li> </ul> addSub(address sub, Data memory data) - adds a sub-identity account for the caller Parameters <ul> <li><code>sub</code> - address of the sub-account to add</li> <li><code>data</code> - Data memory struct containing the sub-account information</li> </ul> renameSub(address sub, Data memory data) - renames a sub-identity account for the caller Parameters <ul> <li><code>sub</code> - address of the sub-account to rename</li> <li><code>data</code> - Data memory struct containing the new sub-account information</li> </ul> removeSub(address sub) - removes a sub identity account for the caller Parameters <ul> <li><code>sub</code> - address of the sub-account to remove</li> </ul> quitSub(address sub) - removes the caller as a sub-identity account Parameters <ul> <li><code>sub</code> - address of the sub-account to quit</li> </ul> <p>The judgment-related functions that must be called by a registrar and the caller must be the registrar account that corresponds to the <code>regIndex</code> are:</p> setFee(uint32 regIndex, uint256 fee) - sets the fee for a registrar Parameters <ul> <li><code>regIndex</code> - uint32 index of the registrar setting the fee</li> <li><code>fee</code> - uint256 new fee amount to be set for the registrar</li> </ul> setAccountId(uint32 regIndex, address newAccount) - sets a new account for a registrar Parameters <ul> <li><code>regIndex</code> - uint32 index of the registrar being updated</li> <li><code>newAccount</code> - address of the new account to be set for the registrar</li> </ul> setFields(uint32 regIndex, IdentityFields memory fields) - sets the registrar's identity Parameters <ul> <li><code>regIndex</code> - uint32 index of the registrar setting their identity fields</li> <li><code>fields</code> - IdentityFields memory struct containing the identity fields to be set</li> </ul> provideJudgement(uint32 regIndex, address target, Judgement memory judgement, bytes32 identity) - provides judgment on an account's identity Parameters <ul> <li><code>regIndex</code> - uint32 index of the registrar providing the judgment</li> <li><code>target</code> - address of the account receiving the judgment</li> <li><code>judgement</code> - Judgement memory struct containing the judgment details</li> <li><code>identity</code> - bytes32 hash of the identity information being judged</li> </ul>"},{"location":"builders/ethereum/precompiles/account/identity/#interact-with-interface","title":"Interact with the Solidity Interface","text":"<p>The following sections will cover how to interact with the Identity Precompile using Ethereum libraries, such as Ethers.js, Web3.js, and Web3.py.</p> <p>The examples in this guide will be on Moonbase Alpha. To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/ethereum/precompiles/account/identity/#use-ethereum-libraries","title":"Using Ethereum Libraries","text":"<p>To interact with the Identity Precompile's Solidity interface with an Ethereum library, you'll need the Identity Precompile's ABI.</p> Identity Precompile ABI <pre><code>[\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"IdentityCleared\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"IdentitySet\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"target\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint32\",\n                \"name\": \"registrarIndex\",\n                \"type\": \"uint32\"\n            }\n        ],\n        \"name\": \"JudgementGiven\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint32\",\n                \"name\": \"registrarIndex\",\n                \"type\": \"uint32\"\n            }\n        ],\n        \"name\": \"JudgementRequested\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint32\",\n                \"name\": \"registrarIndex\",\n                \"type\": \"uint32\"\n            }\n        ],\n        \"name\": \"JudgementUnrequested\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"main\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"SubIdentityAdded\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"main\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"SubIdentityRemoved\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"SubIdentityRevoked\",\n        \"type\": \"event\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            },\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"hasData\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bytes\",\n                        \"name\": \"value\",\n                        \"type\": \"bytes\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Data\",\n                \"name\": \"data\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"name\": \"addSub\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            }\n        ],\n        \"name\": \"cancelRequest\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"clearIdentity\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"identity\",\n        \"outputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isValid\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"uint32\",\n                                \"name\": \"registrarIndex\",\n                                \"type\": \"uint32\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isUnknown\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isFeePaid\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"uint256\",\n                                        \"name\": \"feePaidDeposit\",\n                                        \"type\": \"uint256\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isReasonable\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isKnownGood\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isOutOfDate\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isLowQuality\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isErroneous\",\n                                        \"type\": \"bool\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Judgement\",\n                                \"name\": \"judgement\",\n                                \"type\": \"tuple\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.JudgementInfo[]\",\n                        \"name\": \"judgements\",\n                        \"type\": \"tuple[]\"\n                    },\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"deposit\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"components\": [\n                                    {\n                                        \"components\": [\n                                            {\n                                                \"internalType\": \"bool\",\n                                                \"name\": \"hasData\",\n                                                \"type\": \"bool\"\n                                            },\n                                            {\n                                                \"internalType\": \"bytes\",\n                                                \"name\": \"value\",\n                                                \"type\": \"bytes\"\n                                            }\n                                        ],\n                                        \"internalType\": \"struct Identity.Data\",\n                                        \"name\": \"key\",\n                                        \"type\": \"tuple\"\n                                    },\n                                    {\n                                        \"components\": [\n                                            {\n                                                \"internalType\": \"bool\",\n                                                \"name\": \"hasData\",\n                                                \"type\": \"bool\"\n                                            },\n                                            {\n                                                \"internalType\": \"bytes\",\n                                                \"name\": \"value\",\n                                                \"type\": \"bytes\"\n                                            }\n                                        ],\n                                        \"internalType\": \"struct Identity.Data\",\n                                        \"name\": \"value\",\n                                        \"type\": \"tuple\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Additional[]\",\n                                \"name\": \"additional\",\n                                \"type\": \"tuple[]\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"display\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"legal\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"web\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"riot\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"email\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasPgpFingerprint\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"pgpFingerprint\",\n                                \"type\": \"bytes\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"image\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"twitter\",\n                                \"type\": \"tuple\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.IdentityInfo\",\n                        \"name\": \"info\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Registration\",\n                \"name\": \"\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"target\",\n                \"type\": \"address\"\n            },\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isUnknown\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isFeePaid\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"feePaidDeposit\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isReasonable\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isKnownGood\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isOutOfDate\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isLowQuality\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isErroneous\",\n                        \"type\": \"bool\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Judgement\",\n                \"name\": \"judgement\",\n                \"type\": \"tuple\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"identity\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"provideJudgement\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"quitSub\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"registrars\",\n        \"outputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isValid\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"uint32\",\n                        \"name\": \"index\",\n                        \"type\": \"uint32\"\n                    },\n                    {\n                        \"internalType\": \"address\",\n                        \"name\": \"account\",\n                        \"type\": \"address\"\n                    },\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"fee\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"display\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"legal\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"web\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"riot\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"email\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"pgpFingerprint\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"image\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"twitter\",\n                                \"type\": \"bool\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.IdentityFields\",\n                        \"name\": \"fields\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Registrar[]\",\n                \"name\": \"\",\n                \"type\": \"tuple[]\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"removeSub\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            },\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"hasData\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bytes\",\n                        \"name\": \"value\",\n                        \"type\": \"bytes\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Data\",\n                \"name\": \"data\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"name\": \"renameSub\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"maxFee\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"requestJudgement\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"newAccount\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"setAccountId\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"fee\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"setFee\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"display\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"legal\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"web\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"riot\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"email\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"pgpFingerprint\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"image\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"twitter\",\n                        \"type\": \"bool\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.IdentityFields\",\n                \"name\": \"fields\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"name\": \"setFields\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"components\": [\n                    {\n                        \"components\": [\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"key\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"value\",\n                                \"type\": \"tuple\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Additional[]\",\n                        \"name\": \"additional\",\n                        \"type\": \"tuple[]\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"display\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"legal\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"web\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"riot\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"email\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"hasPgpFingerprint\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bytes\",\n                        \"name\": \"pgpFingerprint\",\n                        \"type\": \"bytes\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"image\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"twitter\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.IdentityInfo\",\n                \"name\": \"info\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"name\": \"setIdentity\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"address\",\n                        \"name\": \"account\",\n                        \"type\": \"address\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"data\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.SubAccount[]\",\n                \"name\": \"subs\",\n                \"type\": \"tuple[]\"\n            }\n        ],\n        \"name\": \"setSubs\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"subsOf\",\n        \"outputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"deposit\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"internalType\": \"address[]\",\n                        \"name\": \"accounts\",\n                        \"type\": \"address[]\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.SubsOf\",\n                \"name\": \"\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"superOf\",\n        \"outputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isValid\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"address\",\n                        \"name\": \"account\",\n                        \"type\": \"address\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"data\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.SuperOf\",\n                \"name\": \"\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    }\n]\n</code></pre> <p>Once you have the ABI, you can interact with the precompile using the Ethereum library of your choice. Generally speaking, you'll take the following steps:</p> <ol> <li>Create a provider</li> <li>Create a contract instance of the Identity Precompile</li> <li>Interact with the Identity Precompile's functions</li> </ol> <p>In the examples below, you'll learn how to assemble the data required to set an identity, how to set an identity, and how to retrieve the identity information once it's been set.</p> <p>Remember</p> <p>The following snippets are for demo purposes only. Never store your private keys in a JavaScript or Python file.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport ABI from './identityPrecompileABI.js'; // Import Identity Precompile ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst identityPrecompileAddress = '0x0000000000000000000000000000000000000818';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n// Create interface for the Identity Precompile\nconst identityPrecompile = new ethers.Contract(\n  identityPrecompileAddress,\n  ABI,\n  signer\n);\n\n// Interact with the Precompile Registry\nconst setIdentity = async () =&gt; {\n  // Assemble identity info\n  const identityInfo = {\n    additional: [],\n    display: {\n      hasData: true,\n      value: '0x416c696365', // Alice in hex\n    },\n    legal: {\n      hasData: false,\n      value: '0x',\n    },\n    web: {\n      hasData: false,\n      value: '0x',\n    },\n    riot: {\n      hasData: false,\n      value: '0x',\n    },\n    email: {\n      hasData: false,\n      value: '0x',\n    },\n    hasPgpFingerprint: false,\n    pgpFingerprint: '0x',\n    image: {\n      hasData: false,\n      value: '0x',\n    },\n    twitter: {\n      hasData: false,\n      value: '0x',\n    },\n  };\n\n  // Set the identity\n  const submitIdentity = await identityPrecompile.setIdentity(identityInfo);\n  console.log(`Identity set. Transaction hash: ${submitIdentity.hash}`);\n\n  // Retrieve the identity\n  const identity = await identityPrecompile.identity(signer.address);\n  console.log(`Identity is valid: ${identity[0]}`);\n  console.log(`Judgements provided for this identity: ${identity[1]}`);\n  console.log(`Deposit paid for this identity: ${identity[2]}`);\n  console.log(`Identity information: ${identity[3]}`);\n  console.log(`Display name: ${ethers.toUtf8String(identity[3][1][1])}`);\n};\n\nsetIdentity();\n</code></pre> <pre><code>import { Web3 } from 'web3';\nimport ABI from './identityPrecompileABI.js'; // Import Identity Precompile ABI\n\nconst from = {\n  privateKey: 'INSERT_PRIVATE_KEY',\n  address: 'INSERT_ADDRESS',\n};\nconst identityPrecompileAddress = '0x0000000000000000000000000000000000000818';\n\n// Create provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\n// Create interface for the Identity Precompile\nconst identityPrecompile = new web3.eth.Contract(\n  ABI,\n  identityPrecompileAddress,\n  { from: from.address }\n);\n\n// Interact with the Precompile Registry\nconst setIdentity = async () =&gt; {\n  // Assemble identity info\n  const identityInfo = {\n    additional: [],\n    display: {\n      hasData: true,\n      value: '0x416c696365', // Alice in hex\n    },\n    legal: {\n      hasData: false,\n      value: '0x',\n    },\n    web: {\n      hasData: false,\n      value: '0x',\n    },\n    riot: {\n      hasData: false,\n      value: '0x',\n    },\n    email: {\n      hasData: false,\n      value: '0x',\n    },\n    hasPgpFingerprint: false,\n    pgpFingerprint: '0x',\n    image: {\n      hasData: false,\n      value: '0x',\n    },\n    twitter: {\n      hasData: false,\n      value: '0x',\n    },\n  };\n\n  // Set the identity\n  const submitIdentity = await identityPrecompile.methods.setIdentity(\n    identityInfo\n  );\n  const sendTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: identityPrecompileAddress,\n      data: submitIdentity.encodeABI(),\n      gas: await submitIdentity.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(from.address),\n    },\n    from.privateKey\n  );\n  // Sign and send the transaction to set the identity\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    sendTransaction.rawTransaction\n  );\n  console.log(\n    `Identity set. Transaction hash: ${createReceipt.transactionHash}`\n  );\n\n  // Retrieve the identity\n  const identity = await identityPrecompile.methods.identity(address).call();\n  console.log(`Identity is valid: ${identity[0]}`);\n  console.log(`Judgements provided for this identity: ${identity[1]}`);\n  console.log(`Deposit paid for this identity: ${identity[2]}`);\n  console.log(`Identity information: ${identity[3]}`);\n  console.log(`Display name: ${web3.utils.hexToUtf8(identity[3][1][1])}`);\n};\n\nsetIdentity();\n</code></pre> <pre><code>from web3 import Web3\n\n# Paste or import the Identity Precompile ABI\nabi = \"INSERT_IDENTITY_PRECOMPILE_ABI\"\naccount_from = {\n    \"private_key\": \"INSERT_PRIVATE_KEY\",\n    \"address\": \"INSERT_ADDRESS\",\n}\nidentity_precompile_address = \"0x0000000000000000000000000000000000000818\"\n\n# Create provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create interface for the Precompile Registry\nidentity_precompile = web3.eth.contract(address=identity_precompile_address, abi=abi)\n\n\ndef set_identity():\n    # Assemble identity info\n    identity_info = {\n        \"additional\": [],\n        \"display\": {\n            \"hasData\": True,\n            \"value\": \"0x416c696365\",  # Alice in hex\n        },\n        \"legal\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"web\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"riot\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"email\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"hasPgpFingerprint\": False,\n        \"pgpFingerprint\": \"0x\",\n        \"image\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"twitter\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n    }\n\n    # Set the identity\n    submit_identity = identity_precompile.functions.setIdentity(\n        identity_info\n    ).build_transaction(\n        {\n            \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n            \"nonce\": web3.eth.get_transaction_count(\n                Web3.to_checksum_address(account_from[\"address\"])\n            ),\n        }\n    )\n    # Sign and send the transaction to set the identity\n    tx_create = web3.eth.account.sign_transaction(\n        submit_identity, account_from[\"private_key\"]\n    )\n    tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\n    tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n    print(f\"Identity set. Transaction hash: { tx_receipt.transactionHash.hex() }\")\n\n    # Retrieve the identity\n    identity = identity_precompile.functions.identity(account_from[\"address\"]).call()\n    print(f\"Identity is valid: { identity[0] }\")\n    print(f\"Judgements provided for this identity: { identity[1] }\")\n    print(f\"Deposit paid for this identity: { identity[2] }\")\n    print(f\"Identity information: { identity[3] }\")\n    print(f\"Display name: { web3.to_text(identity[3][1][1]) }\")\n\n\nset_identity()\n</code></pre>"},{"location":"builders/ethereum/precompiles/account/proxy/","title":"Interacting with the Proxy Precompile","text":""},{"location":"builders/ethereum/precompiles/account/proxy/#introduction","title":"Introduction","text":"<p>The Proxy Precompile on Moonbeam allows accounts to set proxy accounts that can perform specific limited actions on their behalf, such as governance, staking, or balance transfers.</p> <p>If a user wanted to provide a second user access to a limited number of actions on their behalf, traditionally the only method to do so would be by providing the first account's private key to the second. However, Moonbeam has included the Substrate Proxy Pallet, which enables proxy accounts. Proxy accounts ought to be used due to the additional layer of security that they provide, where many accounts can perform actions for a main account. This is best if, for example, a user wants to keep their wallet safe in cold storage but still wants to access parts of the wallet's functionality like governance or staking.  </p> <p>The Proxy Precompile can only be called from an Externally Owned Account (EOA) or by the Batch Precompile.</p> <p>To learn more about proxy accounts and how to set them up for your own purposes without use of the Proxy Precompile, view the Setting up a Proxy Account page.</p> <p>The Proxy Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x000000000000000000000000000000000000080b\n</code></pre> <pre><code>0x000000000000000000000000000000000000080b\n</code></pre> <pre><code>0x000000000000000000000000000000000000080b\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/account/proxy/#the-proxy-solidity-interface","title":"The Proxy Solidity Interface","text":"<p><code>Proxy.sol</code> is an interface through which Solidity contracts can interact with the Proxy Pallet. You do not have to be familiar with the Substrate API since you can interact with it using the Ethereum interface you're familiar with.</p> <p>The interface includes the following functions:</p> addProxy(address delegate, ProxyType proxyType, uint32 delay) - registers a proxy account for the sender after a specified number of <code>delay</code> blocks (generally zero). Will fail if a proxy for the caller already exists Parameters <ul> <li><code>delegate</code> - address of the account to be registered as a proxy</li> <li><code>proxyType</code> - ProxyType enumeration specifying the type of proxy to be registered</li> <li><code>delay</code> - uint32 number of blocks before the proxy registration becomes active</li> </ul> removeProxy(address delegate, ProxyType proxyType, uint32 delay) - removes a registered proxy for the sender Parameters <ul> <li><code>delegate</code> - address of the proxy account to be removed</li> <li><code>proxyType</code> - ProxyType enumeration of the proxy type to be removed</li> <li><code>delay</code> - uint32 delay value of the proxy to be removed</li> </ul> removeProxies() - removes all of the proxy accounts delegated to the sender Parameters <p>None.</p> isProxy(address real, address delegate, ProxyType proxyType, uint32 delay) - returns a boolean, <code>true</code> if the delegate address is a proxy of type <code>proxyType</code>, for address <code>real</code>, with the specified <code>delay</code> Parameters <ul> <li><code>real</code> - address of the account that might be represented by the proxy</li> <li><code>delegate</code> - address of the potential proxy account</li> <li><code>proxyType</code> - ProxyType enumeration of the proxy type to check</li> <li><code>delay</code> - uint32 delay value to check</li> </ul> <p>The <code>proxyType</code> parameter is defined by the following <code>ProxyType</code> enum, where the values start at <code>0</code> with the most permissive proxy type and are represented as <code>uint8</code> values:</p> <pre><code>enum ProxyType {\n    Any,\n    NonTransfer,\n    Governance,\n    Staking,\n    CancelProxy,\n    Balances,\n    AuthorMapping,\n    IdentityJudgement\n}\n</code></pre>"},{"location":"builders/ethereum/precompiles/account/proxy/#proxy-types","title":"Proxy Types","text":"<p>There are multiple types of proxy roles that can be delegated to accounts, where are represented in <code>Proxy.sol</code> through the <code>ProxyType</code> enum. The following list includes all of the possible proxies and the type of transactions they can make on behalf of the primary account:</p> <ul> <li>Any \u2014 the any proxy will allow the proxy account to make any type of transaction that the <code>Governance</code>, <code>Staking</code>, <code>Balances</code>, and <code>AuthorMapping</code> proxy types can perform. Note that balance transfers are only allowed to EOAs, not contracts or Precompiles</li> <li>NonTransfer \u2014 the non-transfer proxy will allow the proxy account to make any type of transaction through the <code>Governance</code>, <code>Staking</code> and <code>AuthorMapping</code> Precompiles, where the <code>msg.value</code> is checked to be zero</li> <li>Governance - the governance proxy will allow the proxy account to make any type of governance related transaction (includes both democracy or council pallets)</li> <li>Staking - the staking proxy will allow the proxy account to make staking related transactions through the <code>Staking</code> Precompile, including calls to the <code>AuthorMapping</code> Precompile</li> <li>CancelProxy - the cancel proxy will allow the proxy account to reject and remove delayed proxy announcements (of the primary account). Currently, this is not an action supported by the Proxy Precompile</li> <li>Balances - the balances proxy will allow the proxy account to only make balance transfers to EOAs</li> <li>AuthorMapping - this type of proxy account is used by collators to migrate services from one server to another</li> <li>IdentityJudgement - the identity judgement proxy will allow the proxy account to judge and certify the personal information associated with accounts on Polkadot. Currently, this is not an action supported by the Proxy Precompile</li> </ul>"},{"location":"builders/ethereum/precompiles/account/proxy/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":"<p>The following section will cover how to interact with the Proxy Precompile from Remix. Please note that the Proxy Precompile can only be called from an EOA or by the Batch Precompile.</p>"},{"location":"builders/ethereum/precompiles/account/proxy/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The below example is demonstrated on Moonbase Alpha, however, similar steps can be taken for Moonbeam and Moonriver. You should:  </p> <ul> <li>Have MetaMask installed and connected to Moonbase Alpha</li> <li>Have an account with some DEV tokens.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>Have a second account that you control to use as a proxy account (funding optional)</li> </ul>"},{"location":"builders/ethereum/precompiles/account/proxy/#remix-set-up","title":"Remix Set Up","text":"<p>To get started, get a copy of <code>Proxy.sol</code> and take the following steps:</p> <ol> <li>Click on the File explorer tab</li> <li>Copy and paste the file contents into a Remix file named <code>Proxy.sol</code></li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/account/proxy/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile Proxy.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/account/proxy/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure Proxy.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the Precompile in the At Address field</li> <li>Provide the address of the Proxy Precompile for Moonbase Alpha: <code>0x000000000000000000000000000000000000080b</code> and click At Address</li> <li>The Proxy Precompile will appear in the list of Deployed Contracts</li> </ol>"},{"location":"builders/ethereum/precompiles/account/proxy/#add-proxy","title":"Add a Proxy","text":"<p>You can add a proxy for your account via the Proxy Precompile if your account doesn't already have a proxy. In this example, you will add a balances proxy to an account by taking the following steps:</p> <ol> <li>Expand the Proxy Precompile contract to see the available functions</li> <li>Find the addProxy function and press the button to expand the section</li> <li>Insert your second account's address as the delegate, <code>5</code> as proxyType, and <code>0</code> as delay</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p>Note</p> <p>When constructing the transaction in Remix, the proxyType is represented as a <code>uint8</code>, instead of the expected enum <code>ProxyType</code>. In Solidity, enums are compiled as <code>uint8</code>, so when you pass in <code>5</code> for proxyType, you indicate the sixth element in the <code>ProxyType</code> enum, which is the balances proxy.</p> <p></p>"},{"location":"builders/ethereum/precompiles/account/proxy/#check-proxy","title":"Check a Proxy's Existence","text":"<p>You can determine whether or not an account is a proxy account for a primary account. In this example, you will insert the parameters of the previously added proxy to determine if the proxy account was successfully added:</p> <ol> <li>Find the isProxy function and press the button to expand the section</li> <li>Insert your primary account's address as real, your second account's address as delegate, <code>5</code> as proxyType, and <code>0</code> as delay</li> <li>Press call</li> </ol> <p>If everything went correctly, the output should be <code>true</code>.</p> <p></p>"},{"location":"builders/ethereum/precompiles/account/proxy/#remove-proxy","title":"Remove a Proxy","text":"<p>You can remove a proxy from your account via the Proxy Precompile. In this example, you will remove the balances proxy previously added to your delegate account by taking the following steps:</p> <ol> <li>Expand the Proxy Precompile contract to see the available functions</li> <li>Find the removeProxy function and press the button to expand the section</li> <li>Insert your second account's address as the delegate, <code>5</code> as proxyType, <code>0</code> and as delay</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p>After the transaction is confirmed, if you repeat the steps to check for a proxy's existence, the result should be <code>false</code>.</p> <p></p> <p>And that's it! You've completed your introduction to the Proxy Precompile. Additional information on setting up proxies is available on the Setting up a Proxy Account page and the Proxy Accounts page on Polkadot's documentation. Feel free to reach out on Discord if you have any questions about any aspect of the Proxy Precompile.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/","title":"Interacting with the Randomness Precompile","text":""},{"location":"builders/ethereum/precompiles/features/randomness/#introduction","title":"Introduction","text":"<p>Moonbeam utilizes verifiable random functions (VRF) to generate randomness that can be verified on-chain. A VRF is a cryptographic function that takes some input and produces random values, along with a proof of authenticity that these random values were generated by the submitter. The proof can be verified by anyone to ensure the random values generated were calculated correctly.</p> <p>There are two available sources of randomness that provide random inputs based on block producers' VRF keys and past randomness results: local VRF and BABE epoch randomness. Local VRF is determined directly within Moonbeam using the collator of the block's VRF key and the last block's VRF output. On the other hand, BABE epoch randomness is based on all the VRF produced by the relay chain validators during a complete epoch.</p> <p>For more information on the two sources of randomness, how the request and fulfillment process works, and security considerations, please refer to the Randomness on Moonbeam page.</p> <p>Moonbeam provides a randomness precompile, which is a Solidity interface that enables smart contract developers to generate randomness via local VRF or BABE epoch randomness using the Ethereum API. Moonbeam also provides a randomness consumer Solidity contract that your contract must inherit from in order to consume fulfilled randomness requests.</p> <p>This guide will show you how to use the randomness precompile and randomness consumer contract to create a lottery where the winners will randomly be selected. You'll also learn how to interact with the randomness precompile directly to perform actions such as purging an expired randomness request.</p> <p>The randomness precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000809\n</code></pre> <pre><code>0x0000000000000000000000000000000000000809\n</code></pre> <pre><code>0x0000000000000000000000000000000000000809\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#the-randomness-interface","title":"The Randomness Solidity Interface","text":"<p>Randomness.sol is a Solidity interface that allows developers to interact with the precompile's methods.</p> Randomness.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Randomness contract's address.\naddress constant RANDOMNESS_ADDRESS = 0x0000000000000000000000000000000000000809;\n\n/// @dev The Randomness contract's instance.\nRandomness constant RANDOMNESS_CONTRACT = Randomness(RANDOMNESS_ADDRESS);\n\n/// @dev Maximum number of random words being requested\nuint32 constant MAX_RANDOM_WORDS = 100;\n/// @dev Minimum number of blocks before a request can be fulfilled for Local VRF Request\nuint32 constant MIN_VRF_BLOCKS_DELAY = 2;\n/// @dev Maximum number of blocks before a request can be fulfilled for Local VRF Request\nuint32 constant MAX_VRF_BLOCKS_DELAY = 2000;\n/// @dev The deposit amount needed to request random words. There is 1 deposit per request\nuint256 constant REQUEST_DEPOSIT_AMOUNT = 1000000000000000000;\n\n/// @author The Moonbeam Team\n/// @title Pallet Randomness Interface\n/// @dev The interface through which solidity contracts will interact with Randomness\n/// @custom:address 0x0000000000000000000000000000000000000809\ninterface Randomness {\n    /// @notice Event emitted when the request has been successfully executed\n    event FulFillmentSucceeded();\n    /// @notice Event emitted when the request has failed to execute fulfillment\n    event FulFillmentFailed();\n\n    /// @notice The status of the request\n    /// @param DoesNotExist The request doesn't exist\n    /// @param Pending The request cannot be fulfilled yet\n    /// @param Ready The request is ready to be fulfilled\n    /// @param Expired The request has expired\n    enum RequestStatus {\n        DoesNotExist,\n        Pending,\n        Ready,\n        Expired\n    }\n\n    /// @notice The type of randomness source\n    /// @param LocalVRF Randomness VRF using the parachain material as seed\n    /// @param RelayBabeEpoch Randomness VRF using relay material from previous epoch\n    enum RandomnessSource {\n        LocalVRF,\n        RelayBabeEpoch\n    }\n\n    /// @notice The request details\n    /// @param id The id of the request (is always &lt; 2**64)\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param contractAddress The address of the contract being called back during fulfillment\n    /// @param fee The amount to set aside to pay for the fulfillment\n    /// @param gasLimit The gas limit to use for the fulfillment\n    /// @param salt A string being mixed with the randomness seed to obtain different random words. This should be as unique as possible; using the same salt will lead to same randomness result.\n    /// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n    /// @param randomnessSource The type of randomness source used to generate the random words\n    /// @param fulfillmentBlock The parachain block number at which the request can be fulfilled (for LocalVRF only)\n    /// @param fulfillmentEpochIndex The relay epoch index at which the request can be fulfilled (for RelayBabeEpoch)\n    /// @param expirationBlock The parachain block number at which the request expires (for LocalVRF only)\n    /// @param expirationEpochIndex The relay epoch index at which the request expires (for RelayBabeEpoch)\n    /// @param status The current status of the request\n    struct Request {\n        uint256 id;\n        address refundAddress;\n        address contractAddress;\n        uint256 fee;\n        uint256 gasLimit;\n        bytes32 salt;\n        uint32 numWords;\n        RandomnessSource randomnessSource;\n        uint32 fulfillmentBlock;\n        uint64 fulfillmentEpochIndex;\n        uint32 expirationBlock;\n        uint64 expirationEpochIndex;\n        RequestStatus status;\n    }\n\n    /// Return the current relay epoch index\n    /// @dev An epoch represents real time and not a block number\n    /// @dev Currently, time between epoch changes cannot be longer than:\n    /// @dev  - Kusama/Westend/Rococo: 600 relay blocks (1 hour)\n    /// @dev  - Polkadot: 2400 relay blocks (4 hours)\n    /// @custom:selector 81797566\n    function relayEpochIndex() external view returns (uint64);\n\n    /// Return the deposit required to perform a request\n    /// @dev Each request will need a deposit.\n    /// @custom:selector fb7cfdd7\n    function requiredDeposit() external view returns (uint256);\n\n    /// @notice Returns the request status\n    /// @param requestId The id of the request to check (must be &lt; 2**64)\n    /// @return status Status of the request\n    /// @custom:selector d8a4676f\n    function getRequestStatus(uint256 requestId)\n        external\n        view\n        returns (RequestStatus status);\n\n    /// @notice Returns the request or revert\n    /// @param requestId The id of the request to check (must be &lt; 2**64)\n    /// @return request The request\n    /// @custom:selector c58343ef\n    function getRequest(uint256 requestId)\n        external\n        view\n        returns (Request memory request);\n\n    /// @notice Request random words generated from the parachain VRF\n    /// @dev This is using pseudo-random VRF executed by the collator at the fulfillment\n    /// @dev Warning:\n    /// @dev The collator in charge of producing the block at fulfillment can decide to skip\n    /// @dev producing the block in order to have a different random word generated by the next\n    /// @dev collator, at the cost of a block reward. It is therefore economically viable to use\n    /// @dev this randomness source only if the financial reward at stake is lower than the block\n    /// @dev reward.\n    /// @dev In order to reduce the risk of a collator being able to predict the random words\n    /// @dev when the request is performed, it is possible to increase the delay to multiple blocks\n    /// @dev The higher the delay is, the less likely the collator will be able to know which\n    /// @dev collator will be in charge of fulfilling the request.\n    /// @dev Fulfillment is manual and can be executed by anyone (for free) after the given delay\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param fee The amount to set aside to pay for the fulfillment\n    /// @param gasLimit The gas limit to use for the fulfillment\n    /// @param salt A string being mixed with the randomness seed to obtain different random words\n    /// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n    /// @param delay The number of blocks until the request can be fulfilled (between MIN_DELAY_BLOCKS and MAX_DELAY_BLOCKS)\n    /// @return requestId The id of the request requestLocalVRFRandomWords\n    /// @custom:selector 9478430c\n    function requestLocalVRFRandomWords(\n        address refundAddress,\n        uint256 fee,\n        uint64 gasLimit,\n        bytes32 salt,\n        uint8 numWords,\n        uint64 delay\n    ) external returns (uint256);\n\n    /// @notice Request random words generated from the relaychain Babe consensus\n    /// @dev The random words are generated from the hash of the all the VRF provided by the\n    /// @dev relaychain validator during 1 epoch.\n    /// @dev It requires a delay of at least 1 epoch after the current epoch to be unpredictable\n    /// @dev at the time the request is performed.\n    /// @dev Warning:\n    /// @dev The validator (on the relaychain) of the last block of an epoch can decide to skip\n    /// @dev producing the block in order to choose the previous generated epoch random number\n    /// @dev at the cost of a relaychain block rewards. It is therefore economically viable to use\n    /// @dev this randomness source only if the financial reward at stake is lower than the relaychain\n    /// @dev block reward.\n    /// @dev (see https://crates.parity.io/pallet_babe/struct.RandomnessFromOneEpochAgo.html)\n    /// @dev Fulfillment is manual and can be executed by anyone (for free) at\n    /// @dev the beginning of the 2nd relay epoch following the current one\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param fee Amount to set aside to pay for the fulfillment. Those fees are taken from the contract\n    /// @param gasLimit Gas limit for the fulfillment\n    /// @param salt Salt to be mixed with raw randomness to get output\n    /// @param numWords Number of random words to be returned (limited to MAX_RANDOM_WORDS)\n    /// @return requestId The id of the request\n    /// @custom:selector 33c14a63\n    function requestRelayBabeEpochRandomWords(\n        address refundAddress,\n        uint256 fee,\n        uint64 gasLimit,\n        bytes32 salt,\n        uint8 numWords\n    ) external returns (uint256);\n\n    /// @dev fulFill the request which will call the contract method \"fulfillRandomWords\"\n    /// @dev Fees of the caller are refunded if the request is fulfillable\n    /// @param requestId Request to be fulfilled (must be &lt; 2**64)\n    /// @custom:selector 9a91eb0d\n    function fulfillRequest(uint256 requestId) external;\n\n    /// @param requestId Request receiving the additional fees (must be &lt; 2**64)\n    /// @param feeIncrease Amount to increase\n    /// @custom:selector d0408a7f\n    function increaseRequestFee(uint256 requestId, uint256 feeIncrease)\n        external;\n\n    /// @param requestId Request to be purged (must be &lt; 2**64)\n    /// @custom:selector 1d26cbab\n    function purgeExpiredRequest(uint256 requestId) external;\n}\n</code></pre> <p>The interface includes functions, constants, events, and enums, as covered in the following sections.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#functions","title":"Functions","text":"<p>The interface includes the following functions:</p> relayEpochIndex() - returns the current relay epoch index, where an epoch represents real time and not a block number ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> current relay epoch index</li> </ul> requiredDeposit() - returns the deposit required to perform a randomness request ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> required deposit amount</li> </ul> getRequestStatus(uint256 requestId) - returns the request status of a given randomness request ParametersReturns <ul> <li><code>requestId</code> - uint256 ID of the randomness request</li> </ul> <ul> <li><code>uint8</code> status code of the request</li> </ul> getRequest(uint256 requestId) - returns the request details of a given randomness request ParametersReturns <ul> <li><code>requestId</code> - uint256 ID of the randomness request</li> </ul> <ul> <li><code>bool</code> whether the request is ready or not</li> <li><code>bool</code> whether the request is expired or not</li> <li><code>uint256</code> deposit amount</li> <li><code>uint256</code> fee amount</li> </ul> requestLocalVRFRandomWords(address refundAddress, uint256 fee, uint64 gasLimit, bytes32 salt, uint8 numWords, uint64 delay) - request random words generated from the parachain VRF ParametersReturns <ul> <li><code>refundAddress</code> - address receiving the left-over fees after the fulfillment</li> <li><code>fee</code> - uint256 amount to set aside to pay for the fulfillment</li> <li><code>gasLimit</code> - uint64 gas limit to use for the fulfillment</li> <li><code>salt</code> - bytes32 string that is mixed with the randomness seed to obtain different random words</li> <li><code>numWords</code> - uint8 number of random words requested, up to the maximum number of random words</li> <li><code>delay</code> - uint64 number of blocks that must pass before the request can be fulfilled. This value will need to be between the minimum and maximum number of blocks before a local VRF request can be fulfilled</li> </ul> <ul> <li><code>uint256</code> ID of the created request</li> </ul> requestRelayBabeEpochRandomWords(address refundAddress, uint256 fee, uint64 gasLimit, bytes32 salt, uint8 numWords) - request random words generated from the relay chain BABE consensus ParametersReturns <ul> <li><code>refundAddress</code> - address receiving the left-over fees after the fulfillment</li> <li><code>fee</code> - uint256 amount to set aside to pay for the fulfillment</li> <li><code>gasLimit</code> - uint64 gas limit to use for the fulfillment</li> <li><code>salt</code> - bytes32 string that is mixed with the randomness seed to obtain different random words</li> <li><code>numWords</code> - uint8 number of random words requested, up to the maximum number of random words</li> </ul> <ul> <li><code>uint256</code> ID of the created request</li> </ul> fulfillRequest(uint256 requestId) - fulfill the request which will call the consumer contract method <code>fulfillRandomWords</code>. Fees of the caller are refunded if the request is fulfillable ParametersReturns <ul> <li><code>requestId</code> - uint256 ID of the randomness request</li> </ul> <p>None.</p> increaseRequestFee(uint256 requestId, uint256 feeIncrease) - increases the fee associated with a given randomness request. This is needed if the gas price increases significantly before the request is fulfilled ParametersReturns <ul> <li><code>requestId</code> - uint256 ID of the randomness request</li> <li><code>feeIncrease</code> - uint256 amount to increase fees by</li> </ul> <p>None.</p> purgeExpiredRequest(uint256 requestId) - removes a given expired request from storage and transfers the request fees to the caller and the deposit back to the original requester ParametersReturns <ul> <li><code>requestId</code> - uint256 ID of the randomness request</li> </ul> <p>None.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#constants","title":"Constants","text":"<p>The interface includes the following constants:</p> <ul> <li>maxRandomWords - the maximum number of random words being requested</li> <li>minBlockDelay - the minimum number of blocks before a request can be fulfilled for local VRF requests</li> <li>maxBlockDelay - the maximum number of blocks before a request can be fulfilled for local VRF requests</li> <li>deposit - the deposit amount needed to request random words. There is one deposit per request</li> </ul> MoonbeamMoonriverMoonbase Alpha Variable Value MAX_RANDOM_WORDS 100 words MIN_VRF_BLOCKS_DELAY 2 blocks MAX_VRF_BLOCKS_DELAY 2000 blocks REQUEST_DEPOSIT_AMOUNT 100 GLMR Variable Value MAX_RANDOM_WORDS 100 words MIN_VRF_BLOCKS_DELAY 2 blocks MAX_VRF_BLOCKS_DELAY 2000 blocks REQUEST_DEPOSIT_AMOUNT 1 MOVR Variable Value MAX_RANDOM_WORDS 100 words MIN_VRF_BLOCKS_DELAY 2 blocks MAX_VRF_BLOCKS_DELAY 2000 blocks REQUEST_DEPOSIT_AMOUNT 1 DEV"},{"location":"builders/ethereum/precompiles/features/randomness/#events","title":"Events","text":"<p>The interface includes the following events:</p> <ul> <li>FulfillmentSucceeded() - emitted when the request has been successfully executed</li> <li>FulfillmentFailed() - emitted when the request has failed to execute fulfillment</li> </ul>"},{"location":"builders/ethereum/precompiles/features/randomness/#enums","title":"Enums","text":"<p>The interface includes the following enums:</p> <ul> <li>RequestStatus - the status of the request, which can be <code>DoesNotExist</code> (0), <code>Pending</code> (1), <code>Ready</code> (2), or <code>Expired</code> (3)</li> <li>RandomnessSource - the type of the randomness source, which can be <code>LocalVRF</code> (0) or <code>RelayBabeEpoch</code> (1)</li> </ul>"},{"location":"builders/ethereum/precompiles/features/randomness/#randomness-consumer-solidity-interface","title":"The Randomness Consumer Solidity Interface","text":"<p>The <code>RandomnessConsumer.sol</code> Solidity interface makes it easy for smart contracts to interact with the randomness precompile. Using the randomness consumer ensures the fulfillment comes from the randomness precompile.</p> RandomnessConsumer.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Randomness contract's address.\naddress constant RANDOMNESS_ADDRESS = 0x0000000000000000000000000000000000000809;\n\n/// @dev The Randomness contract's instance.\nRandomness constant RANDOMNESS_CONTRACT = Randomness(RANDOMNESS_ADDRESS);\n\n/// @dev Maximum number of random words being requested\nuint32 constant MAX_RANDOM_WORDS = 100;\n/// @dev Minimum number of blocks before a request can be fulfilled for Local VRF Request\nuint32 constant MIN_VRF_BLOCKS_DELAY = 2;\n/// @dev Maximum number of blocks before a request can be fulfilled for Local VRF Request\nuint32 constant MAX_VRF_BLOCKS_DELAY = 2000;\n/// @dev The deposit amount needed to request random words. There is 1 deposit per request\nuint256 constant REQUEST_DEPOSIT_AMOUNT = 1000000000000000000;\n\n/// @author The Moonbeam Team\n/// @title Pallet Randomness Interface\n/// @dev The interface through which solidity contracts will interact with Randomness\n/// @custom:address 0x0000000000000000000000000000000000000809\ninterface Randomness {\n    /// @notice Event emitted when the request has been successfully executed\n    event FulFillmentSucceeded();\n    /// @notice Event emitted when the request has failed to execute fulfillment\n    event FulFillmentFailed();\n\n    /// @notice The status of the request\n    /// @param DoesNotExist The request doesn't exist\n    /// @param Pending The request cannot be fulfilled yet\n    /// @param Ready The request is ready to be fulfilled\n    /// @param Expired The request has expired\n    enum RequestStatus {\n        DoesNotExist,\n        Pending,\n        Ready,\n        Expired\n    }\n\n    /// @notice The type of randomness source\n    /// @param LocalVRF Randomness VRF using the parachain material as seed\n    /// @param RelayBabeEpoch Randomness VRF using relay material from previous epoch\n    enum RandomnessSource {\n        LocalVRF,\n        RelayBabeEpoch\n    }\n\n    /// @notice The request details\n    /// @param id The id of the request (is always &lt; 2**64)\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param contractAddress The address of the contract being called back during fulfillment\n    /// @param fee The amount to set aside to pay for the fulfillment\n    /// @param gasLimit The gas limit to use for the fulfillment\n    /// @param salt A string being mixed with the randomness seed to obtain different random words. This should be as unique as possible; using the same salt will lead to same randomness result.\n    /// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n    /// @param randomnessSource The type of randomness source used to generate the random words\n    /// @param fulfillmentBlock The parachain block number at which the request can be fulfilled (for LocalVRF only)\n    /// @param fulfillmentEpochIndex The relay epoch index at which the request can be fulfilled (for RelayBabeEpoch)\n    /// @param expirationBlock The parachain block number at which the request expires (for LocalVRF only)\n    /// @param expirationEpochIndex The relay epoch index at which the request expires (for RelayBabeEpoch)\n    /// @param status The current status of the request\n    struct Request {\n        uint256 id;\n        address refundAddress;\n        address contractAddress;\n        uint256 fee;\n        uint256 gasLimit;\n        bytes32 salt;\n        uint32 numWords;\n        RandomnessSource randomnessSource;\n        uint32 fulfillmentBlock;\n        uint64 fulfillmentEpochIndex;\n        uint32 expirationBlock;\n        uint64 expirationEpochIndex;\n        RequestStatus status;\n    }\n\n    /// Return the current relay epoch index\n    /// @dev An epoch represents real time and not a block number\n    /// @dev Currently, time between epoch changes cannot be longer than:\n    /// @dev  - Kusama/Westend/Rococo: 600 relay blocks (1 hour)\n    /// @dev  - Polkadot: 2400 relay blocks (4 hours)\n    /// @custom:selector 81797566\n    function relayEpochIndex() external view returns (uint64);\n\n    /// Return the deposit required to perform a request\n    /// @dev Each request will need a deposit.\n    /// @custom:selector fb7cfdd7\n    function requiredDeposit() external view returns (uint256);\n\n    /// @notice Returns the request status\n    /// @param requestId The id of the request to check (must be &lt; 2**64)\n    /// @return status Status of the request\n    /// @custom:selector d8a4676f\n    function getRequestStatus(uint256 requestId)\n        external\n        view\n        returns (RequestStatus status);\n\n    /// @notice Returns the request or revert\n    /// @param requestId The id of the request to check (must be &lt; 2**64)\n    /// @return request The request\n    /// @custom:selector c58343ef\n    function getRequest(uint256 requestId)\n        external\n        view\n        returns (Request memory request);\n\n    /// @notice Request random words generated from the parachain VRF\n    /// @dev This is using pseudo-random VRF executed by the collator at the fulfillment\n    /// @dev Warning:\n    /// @dev The collator in charge of producing the block at fulfillment can decide to skip\n    /// @dev producing the block in order to have a different random word generated by the next\n    /// @dev collator, at the cost of a block reward. It is therefore economically viable to use\n    /// @dev this randomness source only if the financial reward at stake is lower than the block\n    /// @dev reward.\n    /// @dev In order to reduce the risk of a collator being able to predict the random words\n    /// @dev when the request is performed, it is possible to increase the delay to multiple blocks\n    /// @dev The higher the delay is, the less likely the collator will be able to know which\n    /// @dev collator will be in charge of fulfilling the request.\n    /// @dev Fulfillment is manual and can be executed by anyone (for free) after the given delay\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param fee The amount to set aside to pay for the fulfillment\n    /// @param gasLimit The gas limit to use for the fulfillment\n    /// @param salt A string being mixed with the randomness seed to obtain different random words\n    /// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n    /// @param delay The number of blocks until the request can be fulfilled (between MIN_DELAY_BLOCKS and MAX_DELAY_BLOCKS)\n    /// @return requestId The id of the request requestLocalVRFRandomWords\n    /// @custom:selector 9478430c\n    function requestLocalVRFRandomWords(\n        address refundAddress,\n        uint256 fee,\n        uint64 gasLimit,\n        bytes32 salt,\n        uint8 numWords,\n        uint64 delay\n    ) external returns (uint256);\n\n    /// @notice Request random words generated from the relaychain Babe consensus\n    /// @dev The random words are generated from the hash of the all the VRF provided by the\n    /// @dev relaychain validator during 1 epoch.\n    /// @dev It requires a delay of at least 1 epoch after the current epoch to be unpredictable\n    /// @dev at the time the request is performed.\n    /// @dev Warning:\n    /// @dev The validator (on the relaychain) of the last block of an epoch can decide to skip\n    /// @dev producing the block in order to choose the previous generated epoch random number\n    /// @dev at the cost of a relaychain block rewards. It is therefore economically viable to use\n    /// @dev this randomness source only if the financial reward at stake is lower than the relaychain\n    /// @dev block reward.\n    /// @dev (see https://crates.parity.io/pallet_babe/struct.RandomnessFromOneEpochAgo.html)\n    /// @dev Fulfillment is manual and can be executed by anyone (for free) at\n    /// @dev the beginning of the 2nd relay epoch following the current one\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param fee Amount to set aside to pay for the fulfillment. Those fees are taken from the contract\n    /// @param gasLimit Gas limit for the fulfillment\n    /// @param salt Salt to be mixed with raw randomness to get output\n    /// @param numWords Number of random words to be returned (limited to MAX_RANDOM_WORDS)\n    /// @return requestId The id of the request\n    /// @custom:selector 33c14a63\n    function requestRelayBabeEpochRandomWords(\n        address refundAddress,\n        uint256 fee,\n        uint64 gasLimit,\n        bytes32 salt,\n        uint8 numWords\n    ) external returns (uint256);\n\n    /// @dev fulFill the request which will call the contract method \"fulfillRandomWords\"\n    /// @dev Fees of the caller are refunded if the request is fulfillable\n    /// @param requestId Request to be fulfilled (must be &lt; 2**64)\n    /// @custom:selector 9a91eb0d\n    function fulfillRequest(uint256 requestId) external;\n\n    /// @param requestId Request receiving the additional fees (must be &lt; 2**64)\n    /// @param feeIncrease Amount to increase\n    /// @custom:selector d0408a7f\n    function increaseRequestFee(uint256 requestId, uint256 feeIncrease)\n        external;\n\n    /// @param requestId Request to be purged (must be &lt; 2**64)\n    /// @custom:selector 1d26cbab\n    function purgeExpiredRequest(uint256 requestId) external;\n}\n</code></pre> <p>The consumer interface includes the following functions:</p> <ul> <li>fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) - handles the VRF response for a given request. This method is triggered by a call to <code>rawFulfillRandomWords</code></li> <li>rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) - executed when the <code>fulfillRequest</code> function of the randomness precompile is called. The origin of the call is validated, ensuring the randomness precompile is the origin, and then the <code>fulfillRandomWords</code> method is called</li> </ul>"},{"location":"builders/ethereum/precompiles/features/randomness/#request-and-fulfill-process","title":"Request &amp; Fulfill Process","text":"<p>To consume randomness, you must have a contract that does the following:</p> <ul> <li>Imports the <code>Randomness.sol</code> precompile and <code>RandomnessConsumer.sol</code> interface</li> <li>Inherits from the <code>RandomnessConsumer.sol</code> interface</li> <li>Requests randomness through the precompile's <code>requestLocalVRFRandomWords</code> method or <code>requestRelayBabeEpochRandomWords</code> method, depending on the source of randomness you want to use</li> <li>Requests fulfillment through the precompile's <code>fulfillRequest</code> method</li> <li>Consumes randomness through a <code>fulfillRandomWords</code> method with the same signature as the <code>fulfillRandomWords</code> method of the <code>RandomnessConsumer.sol</code> contract</li> </ul> <p>When randomness is requested through the precompile's <code>requestLocalVRFRandomWords</code> or <code>requestRelayBabeEpochRandomWords</code> method, a fee is set aside to pay for the fulfillment of the request. When using local VRF, to increase unpredictability, a specified delay period (in blocks) must pass before the request can be fulfilled. At the very least, the delay period must be greater than one block. For BABE epoch randomness, you do not need to specify a delay but can fulfill the request at the beginning of the 2nd epoch following the current one.</p> <p>After the delay, fulfillment of the request can be manually executed by anyone through the <code>fulfillRequest</code> method using the fee that was initially set aside for the request.</p> <p>When fulfilling the randomness request via the precompile's <code>fulfillRequest</code> method, the <code>rawFulfillRandomWords</code> function in the <code>RandomnessConsumer.sol</code> contract will be called, which will verify that the sender is the randomness precompile. From there, <code>fulfillRandomWords</code> is called and the requested number of random words are computed using the current block's randomness result and a given salt and returned. If the fulfillment was successful, the <code>FulfillmentSucceeded</code> event will be emitted; otherwise the <code>FulfillmentFailed</code> event will be emitted.</p> <p>For fulfilled requests, the cost of execution will be refunded from the request fee to the caller of <code>fulfillRequest</code>. Then any excess fees and the request deposit are transferred to the specified refund address.</p> <p>Your contract's <code>fulfillRandomWords</code> callback is responsible for handling the fulfillment. For example, in a lottery contract, the callback would use the random words to choose a winner and payout the winnings.</p> <p>If a request expires it can be purged through the precompile's <code>purgeExpiredRequest</code> function. When this function is called the request fee is paid out to the caller and the deposit will be returned to the original requester.</p> <p>The happy path for a randomness request is shown in the following diagram:</p> <p></p>"},{"location":"builders/ethereum/precompiles/features/randomness/#interact-with-the-solidity-interfaces","title":"Generate a Random Number using the Randomness Precompile","text":"<p>In the following sections of this tutorial, you'll learn how to create a smart contract that generates a random number using the Randomness Precompile and the Randomness Consumer. If you want to just explore some of the functions of the Randomness Precompile, you can skip ahead to the Use Remix to Interact Directly with the Randomness Precompile section.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For this guide, you will need to have the following:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account funded with DEV tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/features/randomness/#create-random-generator-contract","title":"Create a Random Number Generator Contract","text":"<p>The contract that will be created in this section includes the functions that you'll need at a bare minimum to request randomness and consume the results from fulfilling randomness requests.</p> <p>This contract is for educational purposes only and is not meant for production use.</p> <p>The contract will include the following functions:</p> <ul> <li>A constructor that accepts the deposit required to request randomness</li> <li>A function that submits randomness requests. For this example, the source of randomness will be local VRF, but you can easily modify the contract to use BABE epoch randomness</li> <li>A function that fulfills the request by calling the <code>fulfillRequest</code> function of the Randomness Precompile. This function will be <code>payable</code> as the fulfillment fee will need to be submitted at the time of the randomness request</li> <li>A function that consumes the fulfillment results. This function's signature must match the signature of the <code>fulfillRandomWords</code> method of the Randomness Consumer contract</li> </ul> <p>Without further ado, the contract is as follows:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.0;\n\nimport \"https://github.com/moonbeam-foundation/moonbeam/blob/master/precompiles/randomness/Randomness.sol\";\nimport {RandomnessConsumer} from \"https://github.com/moonbeam-foundation/moonbeam/blob/master/precompiles/randomness/RandomnessConsumer.sol\";\n\ncontract RandomNumber is RandomnessConsumer {\n    // The Randomness Precompile Interface\n    Randomness public randomness =\n        Randomness(0x0000000000000000000000000000000000000809);\n\n    // Variables required for randomness requests\n    uint256 public requiredDeposit = randomness.requiredDeposit();\n    uint64 public FULFILLMENT_GAS_LIMIT = 100000;\n    // The fee can be set to any value as long as it is enough to cover\n    // the fulfillment costs. Any leftover fees will be refunded to the\n    // refund address specified in the requestRandomness function below.\n    // 150 Gwei should be sufficient for all networks.\n    // For Moonbase Alpha and Moonriver, you can specify 5 Gwei \n    uint256 public MIN_FEE = FULFILLMENT_GAS_LIMIT * 150 gwei; \n    uint32 public VRF_BLOCKS_DELAY = MIN_VRF_BLOCKS_DELAY;\n    bytes32 public SALT_PREFIX = \"INSERT_ANY_STRING_FOR_SALT\";\n\n    // Storage variables for the current request\n    uint256 public requestId;\n    uint256[] public random;\n\n    constructor() payable RandomnessConsumer() {\n        // Because this contract can only perform 1 random request at a time,\n        // We only need to have 1 required deposit\n        require(msg.value &gt;= requiredDeposit);\n    }\n\n    function requestRandomness() public payable {\n        // Make sure that the value sent is enough\n        require(msg.value &gt;= MIN_FEE);\n        // Request local VRF randomness\n        requestId = randomness.requestLocalVRFRandomWords(\n            msg.sender, // Refund address\n            msg.value, // Fulfillment fee\n            FULFILLMENT_GAS_LIMIT, // Gas limit for the fulfillment\n            SALT_PREFIX ^ bytes32(requestId++), // A salt to generate unique results\n            1, // Number of random words\n            VRF_BLOCKS_DELAY // Delay before request can be fulfilled\n        );\n    }\n\n    function fulfillRequest() public {\n        randomness.fulfillRequest(requestId);\n    }\n\n    function fulfillRandomWords(\n        uint256, // requestId\n        uint256[] memory randomWords\n    ) internal override {\n        // Save the randomness results\n        random = randomWords;\n    }\n}\n</code></pre> <p>As you can see, there are also some constants in the contract that can be edited as you see fit, especially the <code>SALT_PREFIX</code> which can be used to produce unique results.</p> <p>In the following sections, you'll use Remix to deploy and interact with the contract.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#remix-set-up","title":"Remix Set Up","text":"<p>To add the contract to Remix and follow along with this section of the tutorial, you will need to create a new file named <code>RandomnessNumber.sol</code> in Remix and paste the <code>RandomNumber</code> contract into the file.</p> <p></p>"},{"location":"builders/ethereum/precompiles/features/randomness/#compile-deploy-random-number","title":"Compile &amp; Deploy the Random Number Generator Contract","text":"<p>To compile the <code>RandomNumber.sol</code> contract in Remix, you'll need to take the following steps:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Click on the Compile RandomNumber.sol button</li> </ol> <p>If the contract was compiled successfully, you will see a green checkmark next to the Compile tab.</p> <p></p> <p>Now you can go ahead and deploy the contract by taking these steps:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT dropdown. Once you select Injected Provider - Metamask, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Enter the deposit amount in the VALUE field, which is <code>1000000000000000000</code> in Wei (<code>1</code> Ether)</li> <li>Ensure RandomNumber - RandomNumber.sol is selected in the CONTRACT dropdown</li> <li>Click Deploy</li> <li>Confirm the MetaMask transaction that appears by clicking Confirm</li> </ol> <p></p> <p>The RANDOMNUMBER contract will appear in the list of Deployed Contracts.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#request-randomness","title":"Submit a Request to Generate a Random Number","text":"<p>To request randomness, you're going to use the <code>requestRandomness</code> function of the contract, which will require you to submit a deposit as defined in the Randomness Precompile. You can submit the randomness request and pay the deposit by taking these steps:</p> <ol> <li>Enter an amount in the VALUE field for the fulfillment fee, it must be equal to or greater than the minimum fee specified in the <code>RandomNumber</code> contract, which is <code>15000000</code> Gwei.</li> <li>Expand the RANDOMNUMBER contract</li> <li>Click on the requestRandomness button</li> <li>Confrm the transaction in MetaMask</li> </ol> <p></p> <p>Once you submit the transaction, the <code>requestId</code> will be updated with the ID of the request. You can use the <code>requestId</code> call of the Random Number contract to get the request ID and the <code>getRequestStatus</code> function of the Randomness Precompile to check the status of this request ID.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#fulfill-request-save-number","title":"Fulfill the Request and Save the Random Number","text":"<p>After submitting the randomness request, you'll need to wait for the duration of the delay before you can fulfill the request. For the <code>RandomNumber.sol</code> contract, the delay was set to the minimum block delay defined in the Randomness Precompile, which is 2 blocks. You must also fulfill the request before it is too late. For local VRF, the request expires after 10000 blocks and for BABE epoch randomness, the request expires after 10000 epochs.</p> <p>Assuming you've waited for the minimum blocks (or epochs if you're using BABE epoch randomness) to pass and the request hasn't expired, you can fulfill the request by taking the following steps:</p> <ol> <li>Click on the fulfillRequest button</li> <li>Confirming the transaction in MetaMask</li> </ol> <p></p> <p>Once the request has been fulfilled, you can check the random number that was generated:</p> <ol> <li>Expand the random function</li> <li>Since the contract only requested one random word, you can get the random number by accessing the <code>0</code> index of the <code>random</code> array</li> <li>Click call</li> <li>The random number will appear below the call button</li> </ol> <p></p> <p>Upon successful fulfillment, the excess fees and deposit will be sent to the address specified as the refund address.</p> <p>If the request happened to expire before it could be fulfilled, you can interact with the Randomness Precompile directly to purge the request and unlock the deposit and fees. Please refer to the following section for instructions on how to do this.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#interact-directly","title":"Use Remix to Interact Directly with the Randomness Precompile","text":"<p>In addition to interacting with the randomness precompile via a smart contract, you can also interact with it directly in Remix to perform operations such as creating a randomness request, checking on the status of a request, and purging expired requests. Remember, you need to have a contract that inherits from the consumer contract in order to fulfill requests, as such if you fulfill a request using the precompile directly there will be no way to consume the results.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#remix-set-up","title":"Remix Set Up","text":"<p>To add the interfaces to Remix and follow along with this section of the tutorial, you will need to:</p> <ol> <li>Get a copy of <code>Randomness.sol</code></li> <li>Paste the file contents into a Remix file named Randomness.sol</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/features/randomness/#compile-randomness","title":"Compile &amp; Access the Randomness Precompile","text":"<p>Next, you will need to compile the <code>Randomness.sol</code> file in Remix. To get started, make sure you have the Randomness.sol file open and take the following steps:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>To compile the contract, click on Compile Randomness.sol</li> </ol> <p>If the contract was compiled successfully, you will see a green checkmark next to the Compile tab.</p> <p>Instead of deploying the randomness precompile, you will access the interface given the address of the precompiled contract:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note the precompiled contract is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT dropdown. Once selected, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure Randomness - Randomness.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract, there is no need to deploy any code. Instead we are going to provide the address of the precompile in the At Address Field</li> <li>Provide the address of the batch precompile: <code>0x0000000000000000000000000000000000000809</code> and click At Address</li> </ol> <p></p> <p>The RANDOMNESS precompile will appear in the list of Deployed Contracts. You will use this to fulfill the randomness request made from the lottery contract later on in this tutorial.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#get-request-status-and-purge","title":"Get Request Status &amp; Purge Expired Request","text":"<p>Anyone can purge expired requests. You do not need to be the one who requested the randomness to be able to purge it. When you purge an expired request, the request fees will be transferred to you, and the deposit for the request will be returned to the original requester.</p> <p>To purge a request, first you have to make sure that the request has expired. To do so, you can verify the status of a request using the <code>getRequestStatus</code> function of the precompile. The number that is returned from this call corresponds to the index of the value in the <code>RequestStatus</code> enum. As a result, you'll want to verify the number returned is <code>3</code> for <code>Expired</code>.</p> <p>Once you've verified that the request is expired, you can call the <code>purgeExpiredRequest</code> function to purge the request.</p> <p>To verify and purge a request, you can take the following steps:</p> <ol> <li>Expand the RANDOMNESS contract</li> <li>Enter the request ID of the request you want to verify has expired and click on getRequestStatus</li> <li>The response will appear just underneath the function. Verify that you received a <code>3</code></li> <li>Expand the purgeExpiredRequest function and enter the request ID</li> <li>Click on transact</li> <li>MetaMask will pop-up and you can confirm the transaction</li> </ol> <p></p> <p>Once the transaction goes through, you can verify the request has been purged by calling the getRequestStatus function again with the same request ID. You should receive a status of <code>0</code>, or <code>DoesNotExist</code>. You can also expect the amount of the request fees to be transferred to your account.</p>"},{"location":"builders/ethereum/precompiles/features/staking/","title":"Interacting with the Staking Precompile","text":""},{"location":"builders/ethereum/precompiles/features/staking/#introduction","title":"Introduction","text":"<p>Moonbeam uses a Delegated Proof of Stake system through the Parachain Staking Pallet, allowing token holders (delegators) to express exactly which collator candidates they would like to support and with what quantity of stake. The design of the Parachain Staking Pallet is such that it enforces shared risk/reward on chain between delegators and candidates. For general information on staking, such as general terminology, staking variables, and more, please refer to the Staking on Moonbeam page.</p> <p>The staking module is coded in Rust and it is part of a pallet that is normally not accessible from the Ethereum side of Moonbeam. However, a staking precompile allows developers to access the staking features using the Ethereum API in a precompiled contract located at address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000800\n</code></pre> <pre><code>0x0000000000000000000000000000000000000800\n</code></pre> <pre><code>0x0000000000000000000000000000000000000800\n</code></pre> <p>This guide will cover the available methods in the staking precompile interface. In addition, it will show you how to interact with the Parachain Staking Pallet through the staking precompile and the Ethereum API. The examples in this guide are done on Moonbase Alpha, but they can be adapted for Moonbeam or Moonriver.</p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/features/staking/#exit-delays","title":"Exit Delays","text":"<p>Some of the Parachain Staking Pallet extrinsics include exit delays that you must wait before the request can be executed. The exit delays to note are as follows:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Decrease candidate bond 28 rounds (168 hours) Decrease delegator bond 28 rounds (168 hours) Revoke delegation 28 rounds (168 hours) Leave candidates 28 rounds (168 hours) Leave delegators 28 rounds (168 hours) Variable Value Decrease candidate bond 24 rounds (48 hours) Decrease delegator bond 24 rounds (48 hours) Revoke delegation 24 rounds (48 hours) Leave candidates 24 rounds (48 hours) Leave delegators 24 rounds (48 hours) Variable Value Decrease candidate bond 2 rounds (4 hours) Decrease delegator bond 2 rounds (4 hours) Revoke delegation 2 rounds (4 hours) Leave candidates 2 rounds (4 hours) Leave delegators 2 rounds (4 hours)"},{"location":"builders/ethereum/precompiles/features/staking/#the-parachain-staking-solidity-interface","title":"Parachain Staking Solidity Interface","text":"<p><code>StakingInterface.sol</code> is an interface through which Solidity contracts can interact with parachain-staking. The beauty is that Solidity developers don\u2019t have to learn the Substrate API. Instead, they can interact with staking functions using the Ethereum interface they are familiar with.</p> <p>The Solidity interface includes the following functions:</p> isDelegator(address delegator) - read-only function that checks whether the specified address is currently a staking delegator. Uses the <code>delegatorState</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>delegator</code> - address to check if they are currently a delegator</li> </ul> <ul> <li><code>bool</code> whether the address is currently a delegator</li> </ul> isCandidate(address candidate) - read-only function that checks whether the specified address is currently a collator candidate. Uses the <code>candidateState</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address to check if they are currently a collator candidate</li> </ul> <ul> <li><code>bool</code> whether the address is currently a candidate</li> </ul> isSelectedCandidate(address candidate) - read-only function that checks whether the specified address is currently part of the active collator set. Uses the <code>selectedCandidates</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address to check if they are currently an active collator</li> </ul> <ul> <li><code>bool</code> whether the address is currently an active collator</li> </ul> points(uint256 round) - read-only function that gets the total points awarded to all collators in a given round. Uses the <code>points</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>round</code> - uint256 round number to query points for</li> </ul> <ul> <li><code>uint256</code> total points awarded in the specified round</li> </ul> awardedPoints(uint32 round, address candidate) - read-only function that returns the total points awarded in a given round to a given collator. If <code>0</code> is returned, it could be because no blocks were produced or the storage for that round has been removed. Uses the <code>points</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>round</code> - uint32 round number to query</li> <li><code>candidate</code> - address of the collator to query points for</li> </ul> <ul> <li><code>uint256</code> points awarded to the collator in the specified round</li> </ul> delegationAmount(address delegator, address candidate) - read-only function that returns the amount delegated by a given delegator in support of a given candidate. Uses the <code>delegatorState</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>delegator</code> - address of the delegator</li> <li><code>candidate</code> - address of the candidate</li> </ul> <ul> <li><code>uint256</code> amount delegated</li> </ul> isInTopDelegations(address delegator, address candidate) - read-only function that returns a boolean indicating whether the given delegator is in the top delegations for the given candidate. Uses the <code>topDelegations</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>delegator</code> - address of the delegator to check</li> <li><code>candidate</code> - address of the candidate</li> </ul> <ul> <li><code>bool</code> whether the delegator is in the top delegations</li> </ul> minDelegation() - read-only function that gets the minimum delegation amount. Uses the <code>minDelegation</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> minimum delegation amount</li> </ul> candidateCount() - read-only function that gets the current amount of collator candidates. Uses the <code>candidatePool</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> current number of collator candidates</li> </ul> round() - read-only function that returns the current round number. Uses the <code>round</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> current round number</li> </ul> candidateDelegationCount(address candidate) - read-only function that returns the number of delegations for the specified collator candidate address. Uses the <code>candidateInfo</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the collator candidate to query</li> </ul> <ul> <li><code>uint256</code> number of delegations for the candidate</li> </ul> candidateAutoCompoundingDelegationCount(address candidate) - a read-only function that returns the number of auto-compounding delegations for the specified candidate. Uses the <code>autoCompoundingDelegations</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to query</li> </ul> <ul> <li><code>uint256</code> number of auto-compounding delegations</li> </ul> delegatorDelegationCount(address delegator) - read-only function that returns the number of delegations for the specified delegator address. Uses the <code>delegatorState</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>delegator</code> - address of the delegator to query</li> </ul> <ul> <li><code>uint256</code> number of delegations for the delegator</li> </ul> selectedCandidates() - read-only function that gets the selected candidates for the current round. Uses the <code>selectedCandidates</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <ul> <li><code>address[]</code> array of selected candidate addresses</li> </ul> delegationRequestIsPending(address delegator, address candidate) - returns a boolean to indicate whether there is a pending delegation request made by a given delegator for a given candidate ParametersReturns <ul> <li><code>delegator</code> - address of the delegator</li> <li><code>candidate</code> - address of the candidate</li> </ul> <ul> <li><code>bool</code> whether there is a pending delegation request</li> </ul> candidateExitIsPending(address candidate) - returns a boolean to indicate whether a pending exit exists for a specific candidate. Uses the <code>candidateInfo</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to check</li> </ul> <ul> <li><code>bool</code> whether there is a pending exit request</li> </ul> candidateRequestIsPending(address candidate) - returns a boolean to indicate whether there is a pending bond less request made by a given candidate. Uses the <code>candidateInfo</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to check</li> </ul> <ul> <li><code>bool</code> whether there is a pending bond less request</li> </ul> delegationAutoCompound(address delegator, address candidate) - returns the auto-compound percentage for a delegation given the delegator and candidate ParametersReturns <ul> <li><code>delegator</code> - address of the delegator</li> <li><code>candidate</code> - address of the candidate</li> </ul> <ul> <li><code>uint256</code> auto-compound percentage</li> </ul> getDelegatorTotalStaked(address delegator) - read-only function that returns the total staked amount of a given delegator, regardless of the candidate. Uses the <code>delegatorState</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>delegator</code> - address of the delegator to query</li> </ul> <ul> <li><code>uint256</code> total staked amount</li> </ul> getCandidateTotalCounted(address candidate) - read-only function that returns the total amount staked for a given candidate. Uses the <code>candidateInfo</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to query</li> </ul> <ul> <li><code>uint256</code> total amount staked for the candidate</li> </ul> joinCandidates(uint256 amount, uint256 candidateCount) - allows the account to join the set of collator candidates with the specified bond amount and the current candidate count. Uses the <code>joinCandidates</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>amount</code> - uint256 bond amount to stake as a candidate</li> <li><code>candidateCount</code> - uint256 current number of candidates in the pool</li> </ul> <p>None.</p> scheduleLeaveCandidates(uint256 candidateCount) - schedules a request for a candidate to remove themselves from the candidate pool. Scheduling the request does not automatically execute it. There is an exit delay that must be waited before you can execute the request via the <code>executeLeaveCandidates</code> extrinsic. Uses the <code>scheduleLeaveCandidates</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidateCount</code> - uint256 current number of candidates in the pool</li> </ul> <p>None.</p> executeLeaveCandidates(address candidate, uint256 candidateDelegationCount) - executes the due request to leave the set of collator candidates. Uses the <code>executeLeaveCandidates</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate leaving the pool</li> <li><code>candidateDelegationCount</code> - uint256 number of delegations for the candidate</li> </ul> <p>None.</p> cancelLeaveCandidates(uint256 candidateCount) - allows a candidate to cancel a pending scheduled request to leave the candidate pool. Given the current number of candidates in the pool. Uses the <code>cancelLeaveCandidates</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidateCount</code> - uint256 current number of candidates in the pool</li> </ul> <p>None.</p> goOffline() - temporarily leave the set of collator candidates without unbonding. Uses the <code>goOffline</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <p>None.</p> goOnline() - rejoin the set of collator candidates after previously calling <code>goOffline()</code>. Uses the <code>goOnline</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <p>None.</p> candidateBondMore(uint256 more) - collator candidate increases bond by the specified amount. Uses the <code>candidateBondMore</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>more</code> - uint256 amount to increase the bond by</li> </ul> <p>None.</p> scheduleCandidateBondLess(uint256 less) - schedules a request to decrease a candidates bond by the specified amount. Scheduling the request does not automatically execute it. There is an exit delay that must be waited before you can execute the request via the <code>execute_candidate_bond_request</code> extrinsic. Uses the <code>scheduleCandidateBondLess</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>less</code> - uint256 amount to decrease the bond by</li> </ul> <p>None.</p> executeCandidateBondLess(address candidate) - executes any due requests to decrease a specified candidate's bond amount. Uses the <code>executeCandidateBondLess</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to execute the bond decrease for</li> </ul> <p>None.</p> cancelCandidateBondLess() - allows a candidate to cancel a pending scheduled request to decrease a candidates bond. Uses the <code>cancelCandidateBondLess</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <p>None.</p> delegateWithAutoCompound(address candidate, uint256 amount, uint8 autoCompound, uint256 candidateDelegationCount, uint256 candidateAutoCompoundingDelegationCount, uint256 delegatorDelegationCount) - makes a delegation in support of a collator candidate and automatically sets the percent of rewards to auto-compound given an integer (no decimals) for <code>autoCompound</code> between 0-100. Uses the <code>delegateWithAutoCompound</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to delegate to</li> <li><code>amount</code> - uint256 amount to delegate</li> <li><code>autoCompound</code> - uint8 percentage of rewards to auto-compound (0-100)</li> <li><code>candidateDelegationCount</code> - uint256 current number of delegations for the candidate</li> <li><code>candidateAutoCompoundingDelegationCount</code> - uint256 current number of auto-compounding delegations for the candidate</li> <li><code>delegatorDelegationCount</code> - uint256 current number of delegations from the delegator</li> </ul> <p>None.</p> scheduleRevokeDelegation(address candidate) - schedules a request to revoke a delegation given the address of a candidate. Scheduling the request does not automatically execute it. There is an exit delay that must be waited before you can execute the request via the <code>executeDelegationRequest</code> extrinsic. Uses the <code>scheduleRevokeDelegation</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to revoke delegation from</li> </ul> <p>None.</p> delegatorBondMore(address candidate, uint256 more) - delegator increases bond to a collator by the specified amount. Uses the <code>delegatorBondMore</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to increase delegation for</li> <li><code>more</code> - uint256 amount to increase the delegation by</li> </ul> <p>None.</p> scheduleDelegatorBondLess(address candidate, uint256 less) - schedules a request for a delegator to bond less with respect to a specific candidate. Scheduling the request does not automatically execute it. There is an exit delay that must be waited before you can execute the request via the <code>executeDelegationRequest</code> extrinsic. Uses the <code>scheduleDelegatorBondLess</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to decrease delegation for</li> <li><code>less</code> - uint256 amount to decrease the delegation by</li> </ul> <p>None.</p> executeDelegationRequest(address delegator, address candidate) - executes any due delegation requests provided the address of a delegator and a candidate. Uses the <code>executeDelegationRequest</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>delegator</code> - address of the delegator</li> <li><code>candidate</code> - address of the candidate</li> </ul> <p>None.</p> cancelDelegationRequest(address candidate) - cancels any pending delegation requests provided the address of a candidate. Uses the <code>cancelDelegationRequest</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to cancel the delegation request for</li> </ul> <p>None.</p> setAutoCompound(address candidate, uint8 value, uint256 candidateAutoCompoundingDelegationCount, uint256 delegatorDelegationCount) - sets an auto-compound value for an existing delegation given an integer (no decimals) for the <code>value</code> between 0-100. Uses the <code>setAutoCompound</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate</li> <li><code>value</code> - uint8 percentage to auto-compound (0-100)</li> <li><code>candidateAutoCompoundingDelegationCount</code> - uint256 current number of auto-compounding delegations for the candidate</li> <li><code>delegatorDelegationCount</code> - uint256 current number of delegations from the delegator</li> </ul> <p>None.</p>"},{"location":"builders/ethereum/precompiles/features/staking/#interact-with-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/ethereum/precompiles/features/staking/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The below example is demonstrated on Moonbase Alpha, however, similar steps can be taken for Moonbeam and Moonriver.</p> <ul> <li>Have MetaMask installed and connected to Moonbase Alpha</li> <li>Have an account with at least <code>1</code> token.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul> <p>Note</p> <p>The example below requires more than <code>1</code> token due to the minimum delegation amount plus gas fees. If you need more than the faucet dispenses, please contact us on Discord and we will be happy to help you.</p>"},{"location":"builders/ethereum/precompiles/features/staking/#remix-set-up","title":"Remix Set Up","text":"<ol> <li>Click on the File explorer tab</li> <li>Get a copy of <code>StakingInterface.sol</code> and paste the file contents into a Remix file named <code>StakingInterface.sol</code></li> </ol>"},{"location":"builders/ethereum/precompiles/features/staking/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile StakingInterface.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/features/staking/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure ParachainStaking - StakingInterface.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the staking precompile for Moonbase Alpha: <code>0x0000000000000000000000000000000000000800</code> and click At Address</li> <li>The Parachain Staking precompile will appear in the list of Deployed Contracts</li> </ol>"},{"location":"builders/ethereum/precompiles/features/staking/#delegate-a-collator","title":"Delegate a Collator with Auto-Compounding","text":"<p>For this example, you are going to be delegating a collator and setting up the percentage of rewards to auto-compound on Moonbase Alpha. Delegators are token holders who stake tokens, vouching for specific candidates. Any user that holds a minimum amount of 1 token in their free balance can become a delegator. When delegating a candidate, you can simultaneously set up auto-compounding. You'll be able to specify a percentage of your rewards that will automatically be applied to your total delegation. You don't have to set up auto-compounding right away, you can always do it at a later time.</p> <p>You can do your own research and select the candidate you desire. For this guide, the following candidate address will be used: <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>.</p> <p>In order to delegate a candidate, you'll need to determine the candidate's current delegation count, their auto-compounding delegation count, and your own delegation count.</p> <p>The candidate delegation count is the number of delegations backing a specific candidate. To obtain the candidate delegator count, you can call a function that the staking precompile provides. Expand the PARACHAINSTAKING contract found under the Deployed Contracts list, then:</p> <ol> <li>Find and expand the candidateDelegationCount function</li> <li>Enter the candidate address (<code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>)</li> <li>Click call</li> <li>After the call is complete, the results will be displayed</li> </ol> <p></p> <p>The auto-compounding delegation count is the amount of delegations that have auto-compounding configured. To determine the number of delegations that have auto-compounding set up, you can</p> <ol> <li>Find and expand the candidateAutoCompoundingDelegationCount function</li> <li>Enter the candidate address (<code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>)</li> <li>Click call</li> <li>After the call is complete, the results will be displayed</li> </ol> <p></p> <p>The last item you'll need to retrieve is your delegation count. If you don't know your existing number of delegations, you can easily get them by following these steps:</p> <ol> <li>Find and expand the delegatorDelegationCount function</li> <li>Enter your address</li> <li>Click call</li> <li>After the call is complete, the results will be displayed</li> </ol> <p></p> <p>Now that you have obtained the candidate delegator count, the auto-compounding delegation count, and your number of existing delegations, you have all of the information you need to delegate a candidate and set up auto-compounding. To get started:</p> <ol> <li>Find and expand the delegateWithAutoCompound function</li> <li>Enter the candidate address you would like to delegate. For this example you can use <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>Provide the amount to delegate in Wei. There is a minimum of <code>1</code> token to delegate, so the lowest amount in Wei is <code>1000000000000000000</code></li> <li>Enter an integer (no decimals) between 0-100 to represent the percentage of rewards to auto-compound</li> <li>Enter the delegation count for the candidate</li> <li>Enter the auto-compounding delegation count for the candidate</li> <li>Enter your delegation count</li> <li>Press transact</li> <li>MetaMask will pop up, you can review the details and confirm the transaction</li> </ol> <p></p> <p>If you want to delegate without setting up auto-compounding, you can follow the previous steps, but instead of using delegateWithAutoCompound, you can use the delegate extrinsic.</p>"},{"location":"builders/ethereum/precompiles/features/staking/#verify-delegation","title":"Verify Delegation","text":"<p>To verify your delegation was successful, you can check the chain state in Polkadot.js Apps. First, add your MetaMask address to the address book in Polkadot.js Apps.</p> <p>Navigate to Accounts and then Address Book, click on Add contact, and enter the following information:</p> <ol> <li>Add your MetaMask address</li> <li>Provide a nickname for the account</li> <li>Click Save</li> </ol> <p></p> <p>To verify your delegation was successful, head to Polkadot.js Apps and navigate to Developer and then Chain State</p> <ol> <li>Select the parachainStaking pallet</li> <li>Select the delegatorState query</li> <li>Enter your address</li> <li>Optionally, you can enable the include option slider if you want to provide a specific blockhash to query</li> <li>Click the + button to return the results and verify your delegation</li> </ol> <p>Note</p> <p>You do not have to enter anything in the blockhash to query at field if you are looking for an overview of your delegations.</p> <p></p>"},{"location":"builders/ethereum/precompiles/features/staking/#confirm-auto-compounding","title":"Confirm Auto-Compounding Percentage","text":"<p>You can confirm the percentage of rewards you've set to auto-compound in Remix using the <code>delegationAutoCompound</code> function of the Solidity interface:</p> <ol> <li>Find and expand the delegationAutoCompound function</li> <li>Enter your account you used to delegate with</li> <li>Enter the candidate you've delegated</li> <li>Click call</li> <li>The response will appear below the call button</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/features/staking/#set-or-change-auto-compounding","title":"Set or Change the Auto-Compounding Percentage","text":"<p>If you initially set up your delegation without auto-compounding or if you want to update the percentage on an existing delegation with auto-compounding set up, you can use the <code>setAutoCompound</code> function of the Solidity interface.</p> <p>You'll need to get the number of delegations with auto-compounding set up for the candidate you want to set or update auto-compounding for. You'll also need to retrieve your own delegation count. You can follow the instructions in the Delegate a Collator with Auto-Compounding section to get both of these items.</p> <p>Once you have the necessary information, you can take the following steps in Remix:</p> <ol> <li>Find and expand the setAutoCompound function</li> <li>Enter the candidate's account you want to set or update auto-compounding for</li> <li>Enter a number 0-100 to represent the percentage of rewards you want to auto-compound</li> <li>Enter the auto-compounding delegation count for the candidate</li> <li>Enter your delegation count</li> <li>Press transact</li> <li>MetaMask will pop up, you can review the details and confirm the transaction</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/features/staking/#revoke-a-delegation","title":"Revoke a Delegation","text":"<p>As of runtime version 1001, there have been significant changes to the way users can interact with various staking features. Including the way staking exits are handled.</p> <p>Exits now require you to schedule a request to exit or revoke a delegation, wait a delay period, and then execute the request.</p> <p>To revoke a delegation for a specific candidate and receive your tokens back, you can use the <code>scheduleRevokeDelegation</code> extrinsic. Scheduling a request does not automatically revoke your delegation, you must wait an exit delay, and then execute the request by using the <code>executeDelegationRequest</code> method.</p> <p>To revoke a delegation and receive your tokens back, head back over to Remix, then:</p> <ol> <li>Find and expand the scheduleRevokeDelegation function</li> <li>Enter the candidate address you would like to revoke the delegation for</li> <li>Click transact</li> <li>MetaMask will pop up, you can review the transaction details, and click Confirm</li> </ol> <p></p> <p>Once the transaction is confirmed, you must wait the duration of the exit delay before you can execute and revoke the delegation request. If you try to revoke it before the exit delay is up, your extrinsic will fail.</p> <p>After the exit delay has passed, you can go back to Remix and follow these steps to execute the due request:</p> <ol> <li>Find and expand the executeDelegationRequest function</li> <li>Enter the address of the delegator you would like to revoke the delegation for</li> <li>Enter the candidate address you would like to revoke the delegation from</li> <li>Click transact</li> <li>MetaMask will pop up, you can review the transaction details, and click Confirm</li> </ol> <p>After the call is complete, the results will be displayed and the delegation will be revoked for the given delegator and from the specified candidate. You can also check your delegator state again on Polkadot.js Apps to confirm.</p> <p>If for any reason you need to cancel a pending scheduled request to revoke a delegation, you can do so by following these steps in Remix:</p> <ol> <li>Find and expand the cancelDelegationRequest function</li> <li>Enter the candidate address you would like to cancel the pending request for</li> <li>Click transact</li> <li>MetaMask will pop up, you can review the transaction details, and click Confirm</li> </ol> <p>You can check your delegator state again on Polkadot.js Apps to confirm that your delegation is still intact.</p>"},{"location":"builders/ethereum/precompiles/features/governance/collective/","title":"Interacting with the Collective Precompile","text":""},{"location":"builders/ethereum/precompiles/features/governance/collective/#introduction","title":"Introduction","text":"<p>The Collective Precompile enables a user to directly interact with Substrate's collective pallet directly from a Solidity interface.</p> <p>A collective is a group of members that are responsible for specific democracy-related actions such as proposing, voting on, executing, and closing motions. Each can execute different actions with different origins. Consequently, collectives can be created with very specific scopes. There are currently two collectives: the Treasury Council collective and the OpenGov Technical Committee collective. As such, there is a precompile for each collective. For more information on the OpenGov Technical Committee please refer to the Governance on Moonbeam page, and for more information on the Treasury Council, please refer to the Treasury on Moonbeam page.</p> <p>This guide will show you how to propose, vote on, and close a proposal using the Collective Precompile.</p> <p>The Collective Precompiles are located at the following addresses:</p> MoonbeamMoonriverMoonbase Alpha Collective Address Treasury Council 0x0000000000000000000000000000000000000810 OpenGov Technical Committee 0x0000000000000000000000000000000000000814 Collective Address Treasury Council 0x0000000000000000000000000000000000000810 OpenGov Technical Committee 0x0000000000000000000000000000000000000814 Collective Address Treasury Council 0x0000000000000000000000000000000000000810 OpenGov Technical Committee 0x0000000000000000000000000000000000000814 <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#the-call-permit-interface","title":"The Collective Solidity Interface","text":"<p><code>Collective.sol</code> is a Solidity interface that allows developers to interact with the precompile's five methods.</p> <p>The interface includes the following functions:</p> execute(bytes memory proposal) - executes a proposal as a single member of the collective. The sender must be a member of the collective. This will not revert if the Substrate proposal is dispatched but fails Parameters <ul> <li><code>proposal</code> - bytes memory containing the SCALE encoded Substrate call that proposes an action</li> </ul> propose(uint32 threshold, bytes memory proposal) - adds a new proposal to be voted on. The sender must be a member of the collective. If the threshold is less than two then the proposal will be dispatched and executed directly, with the proposer as dispatcher. If the threshold is met, the index of the new proposal is returned Parameters <ul> <li><code>threshold</code> - uint32 amount of members required to dispatch the proposal</li> <li><code>proposal</code> - bytes memory containing the SCALE encoded Substrate call that proposes an action</li> </ul> vote(bytes32 proposalHash, uint32 proposalIndex, bool approve) - votes on a proposal. The sender must be a member of the collective Parameters <ul> <li><code>proposalHash</code> - bytes32 hash of the proposal</li> <li><code>proposalIndex</code> - uint32 index of the proposal</li> <li><code>approve</code> - bool indicating the vote to approve the proposal or not</li> </ul> close(bytes32 proposalHash, uint32 proposalIndex, uint64 proposalWeightBound, uint32 lengthBound) - closes a proposal. Can be called by anyone once there are enough votes. Returns a boolean indicating whether the proposal was executed or removed Parameters <ul> <li><code>proposalHash</code> - bytes32 hash of the proposal</li> <li><code>proposalIndex</code> - uint32 index of the proposal</li> <li><code>proposalWeightBound</code> - uint64 maximum amount of Substrate weight the proposal can use. If the proposal call uses more, the call will revert</li> <li><code>lengthBound</code> - uint32 value higher or equal to the length of the SCALE encoded proposal in bytes</li> </ul> proposalHash(bytes memory proposal) - computes the hash of a proposal Parameters <ul> <li><code>proposal</code> - bytes memory containing the SCALE encoded Substrate call that proposes an action</li> </ul> <p>The interface includes the following events:</p> <ul> <li>Executed(bytes32 proposalHash) - emitted when a proposal is executed</li> <li>Proposed(address indexed who, uint32 indexed proposalIndex, bytes32 indexed proposalHash, uint32 threshold) - emitted when a proposal has successfully been proposed and can be executed or voted on</li> <li>Voted(address indexed who, bytes32 indexed proposalHash, bool* voted) - emitted when a proposal is voted on</li> <li>Closed(bytes32 indexed proposalHash) - emitted when a proposal has been closed</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#interacting-with-the-solidity-interface","title":"Interacting with the Solidity Interface","text":"<p>The example in this section will show you how to submit a Treasury proposal using the Treasury Council Collective Precompile. As such, the proposal will be subject to meeting the voting requirements of the Treasury Council. The threshold for accepting a Treasury proposal is at least three-fifths of the Treasury Council. On the other hand, the threshold for rejecting a proposal is at least one-half of the Treasury Council. Please keep in mind that in order to propose and vote on the proposal, you must be a member of the Treasury Council.</p> <p>If you are not a member of the Treasury Council on Moonbeam, Moonriver, or Moonbase Alpha, you can test out the features of the Collective Precompile using a Moonbeam development node. The Moonbeam development node comes with ten pre-funded accounts, of which Baltathar, Charleth, and Dorothy are automatically set as members of the Treasury Council collective. You can use any of these three accounts to follow along with the rest of the guide.</p>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The example in this guide will be shown on a Moonbeam development node, however, it can be adapted for any of the Moonbeam-based networks.</p> <p>To get started, you will need to have the following:</p> <ul> <li>Have MetaMask installed and connected to one of the Moonbeam-based networks</li> <li>Have an account with funds. If using a Moonbeam development node, the development accounts are pre-funded. For Moonbeam, Moonriver, or Moonbase Alpha, you'll need to fund your account.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul> <p>If you're using a Moonbeam development node and the development accounts, you'll also need to do the following:</p> <ul> <li>Set your development node to seal blocks on a time interval such as every 6 seconds (6000 milliseconds) using the <code>--sealing 6000</code> flag</li> <li>Connect Polkadot.js Apps to your local Moonbeam development node</li> <li>Import Baltathar's, Charleth's, and/or Dorothy's accounts into Polkadot.js Apps and MetaMask</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#remix-set-up","title":"Remix Set Up","text":"<ol> <li>Get a copy of <code>Collective.sol</code> </li> <li>Copy and paste the file contents into a Remix file named <code>Collective.sol</code></li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile Collective.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: You are not deploying a contract here; instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure Collective - Collective.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address Field</li> <li>Provide the address of the Collective Precompile,<code>0x0000000000000000000000000000000000000810</code>, and click At Address</li> <li>The Collective Precompile will appear in the list of Deployed Contracts</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#create-a-proposal","title":"Create a Proposal","text":"<p>In order to submit a proposal to be voted on by the Treasury Council collective, you must first create a Treasury proposal. If a Treasury proposal that you want to vote on already exists and you have the proposal index, you can skip ahead to the next section.</p> <p>To submit a Treasury proposal, you can do so via the Polkadot.js Apps Treasury page. For this example, you can create a simple proposal to send Alith 10 DEV tokens that can be used to host a community event. To get started, click on Submit proposal, and fill out the following information:</p> <ol> <li>From the submit with account dropdown, select the account you want to submit the proposal with. The bond for the proposal will be taken from this account</li> <li>Select the beneficiary, which can be Alith for this example</li> <li>Enter <code>10</code> for the value</li> <li>Click on Submit proposal and then sign and submit the proposal</li> </ol> <p></p> <p>You should see the proposal appear in the proposals section. If this is the first proposal created, it will have a proposal index of <code>0</code>, which will be needed in the next section. To view all of the proposals, you can navigate to the Developer tab, select Chain State, and take the following steps:</p> <ol> <li>From the selected state query dropdown, choose treasury</li> <li>Select the proposals extrinsic</li> <li>Toggle the include option slider off</li> <li>Click + to submit the query</li> <li>The results will appear below with the proposal index and the proposal details</li> </ol> <p></p> <p>Now that you have the proposal and the proposal index, you'll be able to approve the proposal in the following section using the Collective Precompile.</p>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#propose-the-proposal","title":"Propose the Proposal","text":"<p>In order to propose a proposal using the Collective Precompile, so that the corresponding collective can vote on it, you will need to obtain the encoded call data of the call, to be executed by proposal. You can get the encoded call data from Polkadot.js Apps. For this example, you need to propose the approveProposal extrinsic of the treasury pallet. To do so, navigate to the Developer tab, select Extrinsics, and take the following steps:</p> <ol> <li>Select an account (any account is fine because you're not submitting any transaction here)</li> <li>Select the treasury pallet</li> <li>Choose the approveProposal extrinsic</li> <li>Enter the proposal index that the collective will vote on to approve</li> <li>Copy the encoded call data for the proposal</li> </ol> <p></p> <p>For this example, the extrinsic encoded call data for the proposal in this example is <code>0x110200</code>.</p> <p>With the encoded proposal, you can head back to Remix and expand the COLLECTIVE precompile contract under the Deployed Contracts section. Make sure you're connected to your account that is a member of the Treasury Council, and take the following steps to propose the approval:</p> <ol> <li>Expand the propose function</li> <li>Enter the threshold. Keep in mind that for Treasury proposals to be approved, at least three-fifths of the Treasury Council is needed to vote in approval. As such, you can set the threshold to <code>2</code> for this example</li> <li>For the proposal field, you can paste the encoded proposal you retrieved from Polkadot.js Apps</li> <li>Click transact</li> <li>MetaMask will pop up and you can confirm the transaction</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#vote-on-a-proposal","title":"Vote on a Proposal","text":"<p>To vote on a proposal, you'll need to get the proposal hash by passing in the encoded proposal into the proposalHash function.</p> <p></p> <p>Once you have the proposal hash, make sure you're connected to your account that is a member of the Treasury Council, and take the following steps to vote on a proposal:</p> <ol> <li>Expand the vote function in Remix</li> <li>Enter the proposalHash</li> <li>Enter the proposalIndex</li> <li>Enter <code>true</code> for the approve field</li> <li>Click transact</li> <li>MetaMask will pop up and you can confirm the transaction</li> </ol> <p></p> <p>With the threshold set to <code>2</code>, you'll need to switch accounts in MetaMask to another member of the Treasury Council collective and repeat the steps above to vote and meet the threshold. Once the threshold has been met, you can then close the proposal, which will automatically execute it, and if approved, the proposal enters a queue to be placed into a spend period where the proposed amount will be distributed to the beneficiary. In this case, once the proposal is placed into a spend period, 10 DEV tokens will be distributed to Alith.</p>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#close-a-proposal","title":"Close a Proposal","text":"<p>If a proposal has enough votes, anyone can close a proposal. You do not need to be a member of the Treasury Council in order to close a proposal. To close a proposal, you can take the following steps:</p> <ol> <li>Expand the close function</li> <li>Enter the proposalHash</li> <li>Enter the proposalIndex</li> <li>Enter the proposalWeightBound, which for this example can be <code>1000000000</code></li> <li>Enter the lengthBound, which can be a value equal to or greater than the length of the encoded call data for the proposal. For this example the encoded call data is <code>0x110200</code>, and as such, you can set this value to <code>8</code></li> <li>Click on transact</li> <li>MetaMask will pop up and you can confirm the transaction</li> </ol> <p></p> <p>You can verify the proposal has been approved using Polkadot.js Apps. From the Developer tab, select Chain State, and take the following steps:</p> <ol> <li>Select the treasury pallet</li> <li>Select the approvals extrinsic</li> <li>Click + to submit the query</li> <li>The proposal will appear in the list of approvals</li> </ol> <p></p> <p>Once the proposal is in a spend period, the funds will get distributed to the beneficiary, and the original bond will be returned to the proposer. If the Treasury runs out of funds, the approved proposals will remain in storage until the following spend period when the Treasury has enough funds again.</p>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/","title":"Interacting with the Conviction Voting Precompile","text":""},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#introduction","title":"Introduction","text":"<p>As a Polkadot parachain and decentralized network, Moonbeam features native on-chain governance that enables stakeholders to participate in the direction of the network. With the introduction of OpenGov, also referred to as Governance v2, the Conviction Voting Pallet allows token holders to make, delegate, and manage Conviction-weighted votes on referenda. To learn more about Moonbeam's governance system, such as an overview of related terminology, principles, mechanics, and more, please refer to the Governance on Moonbeam page.</p> <p>The Conviction Voting Precompile interacts directly with Substrate's Conviction Voting Pallet. This pallet is coded in Rust and is normally not accessible from the Ethereum API side of Moonbeam. However, the Conviction Voting Precompile allows you to access governance-related functions of the Substrate Conviction Voting Pallet directly from a Solidity interface. Additionally, this enables a vastly improved end-user experience. For example, token holders can vote on referenda or delegate a vote directly from MetaMask, rather than importing an account in Polkadot.js Apps and navigating a complex UI.</p> <p>The Conviction Voting Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000812\n</code></pre> <pre><code>0x0000000000000000000000000000000000000812\n</code></pre> <pre><code>0x0000000000000000000000000000000000000812\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#the-conviction-voting-solidity-interface","title":"The Conviction Voting Solidity Interface","text":"<p><code>ConvictionVoting.sol</code> is a Solidity interface that allows developers to interact with the precompile's methods.</p> <p>The interfaces includes a <code>Conviction</code> enum that defines the Conviction multiplier types. The enum has the following variables:</p> <ul> <li>None -  0.1x votes, unlocked</li> <li>Locked1x - 1x votes, locked for an Enactment Period following a successful vote</li> <li>Locked2x - 2x votes, locked for 2x Enactment Period following a successful vote</li> <li>Locked3x - 4x votes, locked for 4x Enactments Period following a successful vote</li> <li>Locked4x - 8x votes, locked for 8x Enactments Period following a successful vote</li> <li>Locked5x - 16x votes, locked for 16x Enactments Period following a successful vote</li> <li>Locked6x - 32x votes, locked for 32x Enactments Period following a successful vote</li> </ul> <p>The interface includes the following functions:</p> votingFor(address who, uint16 trackId) - returns the votes for a given account and Track Parameters <ul> <li><code>who</code> - address of the account to query the votes for</li> <li><code>trackId</code> - uint16 Track ID where the requested changes need to occur</li> </ul> classLocksFor(address who) - returns the class locks for a given account Parameters <ul> <li><code>who</code> - address of the account to query the class locks for</li> </ul> voteYes(uint32 pollIndex, uint256 voteAmount, Conviction conviction) - votes a Conviction-weighted \"Aye\" on a poll (referendum) Parameters <ul> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> <li><code>voteAmount</code> - uint256 balance to be locked for the vote</li> <li><code>conviction</code> - Conviction represents a value from the aforementioned <code>Conviction</code> enum</li> </ul> voteNo(uint32 pollIndex, uint256 voteAmount, Conviction conviction) - votes a Conviction-weighted \"Nay\" on a poll (referendum) Parameters <ul> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> <li><code>voteAmount</code> - uint256 balance to be locked for the vote</li> <li><code>conviction</code> - Conviction represents a value from the aforementioned <code>Conviction</code> enum</li> </ul> voteSplit(uint32 pollIndex, uint256 aye, uint256 nay) - votes a split vote, with a given amount locked for \"Aye\" and a given amount locked for \"Nay\", on a poll (referendum) Parameters <ul> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> <li><code>aye</code> - uint256 balance to be locked for the \"Aye\" vote</li> <li><code>nay</code> - uint256 balance to be locked for the \"Nay\" vote</li> </ul> voteSplitAbstain(uint32 pollIndex, uint256 aye, uint256 nay) - votes a split abstained vote, with a given amount locked for \"Aye\", a given amount locked for \"Nay\", and a given amount locked for an abstain vote (support), on a poll (referendum) Parameters <ul> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> <li><code>aye</code> - uint256 balance to be locked for the \"Aye\" vote</li> <li><code>nay</code> - uint256 balance to be locked for the \"Nay\" vote</li> </ul> removeVote(uint32 pollIndex) - removes a vote in a poll (referendum) Parameters <ul> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> </ul> removeVoteForTrack(uint32 pollIndex, uint16 trackId) - removes a vote from a specific track in a poll (referendum) Parameters <ul> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> <li><code>trackId</code> - uint16 Track ID where the requested changes need to occur</li> </ul> removeOtherVote(address target, uint16 trackId, uint32 pollIndex) - removes a vote in a poll (referendum) for another voter Parameters <ul> <li><code>target</code> - address that has a vote or tokens to be removed or unlocked</li> <li><code>trackId</code> - uint16 Track ID where the requested changes need to occur</li> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> </ul> delegate(uint16 trackId, address representative, Conviction conviction, uint256 amount) - delegates another account as a representative to place a Conviction-weighted vote on the behalf of the sending account for a specific Track Parameters <ul> <li><code>trackId</code> - uint16 Track ID where the requested changes need to occur</li> <li><code>representative</code> - address of the account to be delegated as representative</li> <li><code>conviction</code> - Conviction represents a value from the aforementioned <code>Conviction</code> enum</li> <li><code>amount</code> - uint256 balance to be delegated</li> </ul> undelegate(uint16 trackId) - removes the caller's vote delegations for a specific Track Parameters <ul> <li><code>trackId</code> - uint16 Track ID where the requested changes need to occur</li> </ul> unlock(uint16 trackId, address target) - unlocks the locked tokens of a specific account for a specific Track Parameters <ul> <li><code>trackId</code> - uint16 Track ID where the requested changes need to occur</li> <li><code>target</code> - address that has a vote or tokens to be removed or unlocked</li> </ul> <p>The interface also includes the following events:</p> <ul> <li>Voted(uint32 indexed pollIndex, address voter, bool aye, uint256 voteAmount, uint8 conviction) - emitted when an account makes a vote</li> <li>VoteSplit(uint32 indexed pollIndex, address voter, uin256 aye, uint256 nay) - emitted when an account makes a split vote</li> <li>VoteSplitAbstained(uint32 indexed pollIndex, address voter, uin256 aye, uint256 nay, uint256 nay) - emitted when an account makes a split abstained vote</li> <li>VoteRemoved(uint32 indexed pollIndex, address voter) - emitted when an account's (<code>voter</code>) vote has been removed from an ongoing poll (referendum)</li> <li>VoteRemovedForTrack(uint32 indexed pollIndex, uint16 trackId, address voter) - emitted when an account's (<code>voter</code>) vote has been removed from an ongoing poll (referendum) for a specific Track</li> <li>VoteRemovedOther(uint32 indexed pollIndex, address caller, address target, uint16 trackId) - emitted when an account (<code>caller</code>) removed a vote for another account (<code>target</code>)</li> <li>Delegated(uint16 indexed trackId, address from, address to, uint256 delegatedAmount, uint8 conviction) - emitted when an account (<code>from</code>) delegates a Conviction-weighted vote of a given amount to another account (<code>to</code>)</li> <li>Undelegated(uint16 indexed trackId, address caller) - emitted when an account's (<code>caller</code>) delegations are removed for a specific Track</li> <li>Unlocked(uint16 indexed trackId, address caller) - emitted when an account's (<code>caller</code>) locked tokens are unlocked for a specific Track</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The below example is demonstrated on Moonbase Alpha, however, similar steps can be taken for Moonriver. To follow the steps in this guide, you'll need to have the following:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account with some DEV tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#remix-set-up","title":"Remix Set Up","text":"<ol> <li>Click on the File explorer tab</li> <li>Paste a copy of <code>ConvictionVoting.sol</code> into a Remix file named <code>ConvictionVoting.sol</code></li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile ConvictionVoting.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure ConvictionVoting.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the Conviction Voting Precompile for Moonbase Alpha: <code>0x0000000000000000000000000000000000000812</code> and click At Address</li> <li>The Conviction Voting Precompile will appear in the list of Deployed Contracts</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#vote-on-a-referendum","title":"Vote on a Referendum","text":"<p>You can lock tokens and vote on a referendum at anytime during the Lead-in Period or the Decide Period. In order for a referendum to pass, it needs to garner minimum Approval and Support, which vary by track. For more information on each of the relative periods and the Approval and Support requirements by Track, please refer to the OpenGov section of the governance overview page.</p> <p>First, you'll need to get the index of the referendum you wish to vote on. To get the index of a referendum, head to Polkadot.js Apps and take the following steps:</p> <ol> <li>From the Governance tab dropdown, select Referenda</li> <li>Look for the referenda you want to vote on. You can view more details about a specific referendum by clicking on the triangle icon. If there is no triangle icon, this means that only a proposal hash, and no preimage has been submitted for the proposal</li> <li>Take note of the referendum index</li> </ol> <p></p> <p>Now, you're ready to return to Remix to vote on the referendum via the Conviction Voting Precompile. There are two methods you can use to vote on a referendum: <code>voteYes</code> or <code>voteNo</code>. As you probably have already figured out, if you're in agreement with the proposal, you'll use <code>voteYes</code> and if in disagreement, you'll use <code>voteNo</code>. You'll specify the amount of tokens you want to lock with your vote and the Conviction, using index of the Conviction you want to vote with in the aforementioned <code>Conviction</code> enum. For example, if you wanted to lock your tokens for the duration of two Enactment Periods following a successful vote, you would enter <code>2</code> for the <code>Locked2x</code> Conviction. For more information on Convictions, you can check out the Conviction Multiplier section of the Governance v2 documentation.</p> <p>To submit your vote, you can take the following steps:</p> <ol> <li>Expand the Conviction Voting Precompile contract to see the available functions if it is not already open</li> <li>Find the voteYes or voteNo function, however you want to vote, and press the button to expand the section</li> <li>Enter the index of the referendum to vote on</li> <li>Enter the number of tokens to lock in Wei. Avoid entering your full balance here because you need to pay for transaction fees</li> <li>Enter the Conviction you want to vote with</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p></p> <p>Once the referendum has closed, you can use the Conviction Voting precompile to remove your vote and unlock your tokens.</p>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#delegate-a-vote","title":"Delegate a Vote","text":"<p>In addition to voting on a referendum yourself, you can delegate a Conviction-weighted vote to someone who is more knowledgeable on a particular topic to vote on your behalf, a process known as Vote Delegation. You can even delegate a different account for each of the Tracks.</p> <p>To get started, you can take the following steps:</p> <ol> <li>Find the delegate function and press the button to expand the section</li> <li>Enter the Track ID of the Track that you want the delegation to be used on. Track IDs can be found in the Referenda page of Polkadot.js Apps</li> <li>Enter the delegate account that will have the power to vote on your behalf</li> <li>Enter the number of tokens they can vote with in Wei. Avoid entering your full balance here because you need to pay for transaction fees</li> <li>Enter the Conviction they can vote with</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p></p> <p>Now the delegate account can vote on your behalf! If you no longer want a delegate vote to exist, you can remove it using the <code>undelegate</code> function of the Conviction Voting Precompile.</p> <p>And that's it! You've completed your introduction to the Conviction Voting Precompile. There are a few more functions that are documented in <code>ConvictionVoting.sol</code> \u2014 feel free to reach out on Discord if you have any questions about those functions or any other aspect of the Conviction Voting Precompile.</p>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/","title":"Interacting with the Preimage Precompile","text":""},{"location":"builders/ethereum/precompiles/features/governance/preimage/#introduction","title":"Introduction","text":"<p>As a Polkadot parachain and decentralized network, Moonbeam features native on-chain governance that enables stakeholders to participate in the direction of the network. With the introduction of OpenGov, also referred to as Governance v2, the Preimage Pallet allows token holders to take the first step towards creating a proposal by submitting the preimage, which is the action to be carried out in the proposal, on-chain. The hash of the preimage is required to submit the proposal. To learn more about Moonbeam's governance system, such as an overview of related terminology, the roadmap of a proposal, and more, please refer to the Governance on Moonbeam page.</p> <p>The Preimage Precompile interacts directly with Substrate's Preimage Pallet. This pallet is coded in Rust and is normally not accessible from the Ethereum side of Moonbeam. However, the Preimage Precompile allows you to access functions needed to create and manage preimages, all of which are part of the Substrate Preimage Pallet, directly from a Solidity interface.</p> <p>The Preimage Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000813\n</code></pre> <pre><code>0x0000000000000000000000000000000000000813\n</code></pre> <pre><code>0x0000000000000000000000000000000000000813\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/#the-preimage-solidity-interface","title":"The Preimage Solidity Interface","text":"<p><code>Preimage.sol</code> is a Solidity interface that allows developers to interact with the precompile's two methods:</p> notePreimage(bytes memory encodedPropsal) - registers a preimage on-chain for an upcoming proposal. This doesn't require the proposal to be in the dispatch queue but does require a deposit which is returned once enacted. Uses the <code>notePreimage</code> method of the preimage pallet Parameters <ul> <li><code>encodedProposal</code> - bytes memory containing the encoded proposal to be registered. Returns the preimage hash</li> </ul> unnotePreimage(bytes32 hash) - clears an unrequested preimage from storage. Uses the <code>unnotePreimage</code> method of the preimage pallet Parameters <ul> <li><code>hash</code> - bytes32 hash of the preimage to be removed from storage</li> </ul> <p>The interface also includes the following events:</p> <ul> <li>PreimageNoted(bytes32 hash) - emitted when a preimage was registered on-chain</li> <li>PreimageUnnoted(bytes32 hash) - emitted when a preimage was un-registered on-chain</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/ethereum/precompiles/features/governance/preimage/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The below example is demonstrated on Moonbase Alpha, however, similar steps can be taken for Moonriver. To follow the steps in this guide, you'll need to have the following:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account with some DEV tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/#remix-set-up","title":"Remix Set Up","text":"<ol> <li>Click on the File explorer tab</li> <li>Paste a copy of <code>Preimage.sol</code> into a Remix file named <code>Preimage.sol</code></li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile Preimage.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure Preimage.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the Preimage Precompile for Moonbase Alpha: <code>0x0000000000000000000000000000000000000813</code> and click At Address</li> <li>The Preimage Precompile will appear in the list of Deployed Contracts</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/#submit-a-preimage","title":"Submit a Preimage of a Proposal","text":"<p>In order to submit a proposal, you'll first need to submit a preimage of that proposal, which essentially defines the proposed action on-chain. You can submit the preimage using the <code>notePreimage</code> function of the Preimage Precompile. The <code>notePreimage</code> function accepts the encoded proposal, so the first step you'll need to take is to get the encoded proposal, which can easily be done using Polkadot.js Apps.</p> <p>In this section, you'll get the preimage hash and the encoded proposal data for a proposal. To get the preimage hash, you'll first need to navigate to the Preimage page of Polkadot.js Apps:</p> <ol> <li>Navigate to the Governance tab</li> <li>Select Preimages from the dropdown</li> <li>From the Preimages page, click on + Add preimage</li> </ol> <p></p> <p>Then take the following steps:</p> <ol> <li>Select an account (any account is fine because you're not submitting any transaction here)</li> <li>Choose the pallet you want to interact with and the dispatchable function (or action) to propose. The action you choose will determine the fields that need to fill in the following steps. In this example, it is the system pallet and the remark function</li> <li>Enter the text of the remark, ensuring it is unique. Duplicate proposals such as \"Hello World!\" will not be accepted</li> <li>Click the Submit preimage button but don't sign or confirm the transaction on the next page </li> </ol> <p></p> <p>On the next screen, take the following steps:</p> <ol> <li>Press the triangle icon to reveal the encoded proposal in bytes</li> <li>Copy the bytes (encoded proposal) \u2014 you'll need them when calling the <code>notePreimage</code> function</li> </ol> <p></p> <p>Note</p> <p>You should NOT sign and submit the transaction here. You will submit this information via the <code>notePreimage</code> function in the next step.</p> <p>Now you can take the bytes of the encoded proposal that you got from Polkadot.js Apps and submit it via the <code>notePreimage</code> function of the Preimage Precompile. To submit the preimage via the <code>notePreimage</code> function, take the following steps:</p> <ol> <li>Expand the Preimage Precompile contract to see the available functions</li> <li>Find the notePreimage function and press the button to expand the section</li> <li>Provide the bytes of the encoded proposal that you noted in the prior section. Note, the encoded proposal is not the same as the preimage hash. Ensure you are entering the correct value into this field</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p></p> <p>Now that you've submitted the preimage for your proposal your proposal can be submitted! Head over to the Referenda Precompile documentation to learn how to submit your proposal.</p> <p>If you wish to remove a preimage, you can follow the same steps noted above except use the <code>unnotePreimage</code> function and pass in the preimage hash instead of the encoded proposal.</p>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/","title":"Interacting with the Referenda Precompile","text":""},{"location":"builders/ethereum/precompiles/features/governance/referenda/#introduction","title":"Introduction","text":"<p>As a Polkadot parachain and decentralized network, Moonbeam features native on-chain governance that enables stakeholders to participate in the direction of the network. With the introduction of OpenGov, also referred to as Governance v2, the Referenda Pallet allows token holders to get information on existing referenda, submit a proposal to be put forth for referenda, and manage actions related to the Decision Deposit, which is required for a referenda to be decided on. To learn more about Moonbeam's governance system, such as an overview of related terminology, principles, mechanics, and more, please refer to the Governance on Moonbeam page.</p> <p>The Referenda Precompile interacts directly with Substrate's Referenda Pallet. This pallet is coded in Rust and is normally not accessible from the Ethereum side of Moonbeam. However, the Referenda Precompile allows you to access functions needed to view referenda, submit referenda, and manage the required Decision Deposit, all of which are part of the Substrate Referenda Pallet, directly from a Solidity interface.</p> <p>The Referenda Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000811\n</code></pre> <pre><code>0x0000000000000000000000000000000000000811\n</code></pre> <pre><code>0x0000000000000000000000000000000000000811\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#the-referenda-solidity-interface","title":"The Referenda Solidity Interface","text":"<p><code>Referenda.sol</code> is a Solidity interface that allows developers to interact with the precompile's methods.</p> <p>The methods are as follows:</p> referendumCount() - a read-only function that returns the total referendum count ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> total count of referenda</li> </ul> submissionDeposit() - a read-only function that returns the Submission Deposit required for each referendum ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> amount of the required Submission Deposit</li> </ul> decidingCount(uint16 trackId) - a read-only function that returns the total count of deciding referenda for a given Track ParametersReturns <ul> <li><code>trackId</code> - uint16 Track ID to query the deciding count for</li> </ul> <ul> <li><code>uint256</code> count of deciding referenda for the specified Track</li> </ul> trackIds() - a read-only function that returns a list of the Track IDs for all Tracks (and Origins) ParametersReturns <p>None.</p> <ul> <li><code>uint16[]</code> array of Track IDs</li> </ul> trackInfo(uint16 trackId) - a read-only function that returns the following governance parameters configured for a given Track ID ParametersReturns <ul> <li><code>trackId</code> - uint16 Track ID to query the parameters for</li> </ul> <ul> <li><code>string</code> name - the name of the Track</li> <li><code>uint256</code> maxDeciding - the maximum number of referenda that can be decided on at once</li> <li><code>uint256</code> decisionDeposit - the amount of the Decision Deposit</li> <li><code>uint256</code> preparePeriod - the duration of the Prepare Period</li> <li><code>uint256</code> decisionPeriod - the duration of the Decide Period</li> <li><code>uint256</code> confirmPeriod - the duration of the Confirm Period</li> <li><code>uint256</code> minEnactmentPeriod - the minimum amount of time the Enactment Period must be</li> <li><code>bytes</code> minApproval - the minimum \"Aye\" votes as a percentage of overall Conviction-weighted votes needed for an approval</li> <li><code>bytes</code> minSupport - minimum number of \"Aye\" votes, not taking into consideration Conviction-weighted votes, needed as a percent of the total supply needed for an approval</li> </ul> referendumStatus(uint32 referendumIndex) - a read-only function that returns the status for a given referendum ParametersReturns <ul> <li><code>referendumIndex</code> - uint32 index of the referendum to query the status for</li> </ul> <p>ReferendumStatus enum: <pre><code>enum ReferendumStatus {\n     Ongoing,\n     Approved,\n     Rejected,\n     Cancelled,\n     TimedOut,\n     Killed\n}\n</code></pre></p> ongoingReferendumInfo(uint32 referendumIndex) - a read-only function that returns information pertaining to an ongoing referendum ParametersReturns <ul> <li><code>referendumIndex</code> - uint32 index of the ongoing referendum to query</li> </ul> <ul> <li><code>uint16</code> trackId - the Track of this referendum</li> <li><code>bytes</code> origin - the Origin for this referendum</li> <li><code>bytes</code> proposal - the hash of the proposal up for referendum</li> <li><code>bool</code> enactmentType - <code>true</code> if the proposal is scheduled to be dispatched at enactment time and <code>false</code> if after enactment time</li> <li><code>uint256</code> enactmentTime - the time the proposal should be scheduled for enactment</li> <li><code>uint256</code> submissionTime - the time of submission</li> <li><code>address</code> submissionDepositor - the address of the depositor for the Submission Deposit</li> <li><code>uint256</code> submissionDeposit - the amount of the Submission Deposit</li> <li><code>address</code> decisionDepositor - the address of the depositor for the Decision Deposit</li> <li><code>uint256</code> decisionDeposit - the amount of the Decision Deposit</li> <li><code>uint256</code> decidingSince - when this referendum entered the Decide Period</li> <li><code>uint256</code> decidingConfirmingEnd - when this referendum is scheduled to leave the Confirm Period</li> <li><code>uint256</code> ayes - the number of \"Aye\" votes, expressed in terms of post-conviction lock-vote</li> <li><code>uint32</code> support - percent of \"Aye\" votes, expressed pre-conviction, over total votes in the class</li> <li><code>uint32</code> approval - percent of \"Aye\" votes over \"Aye\" and \"Nay\" votes</li> <li><code>bool</code> inQueue - <code>true</code> if this referendum has been placed in the queue for being decided</li> <li><code>uint256</code> alarmTime - the next scheduled wake-up</li> <li><code>bytes</code> taskAddress - scheduler task address if scheduled</li> </ul> closedReferendumInfo(uint32 referendumIndex) - a read-only function that returns information pertaining to a closed referendum ParametersReturns <ul> <li><code>referendumIndex</code> - uint32 index of the closed referendum to query</li> </ul> <ul> <li><code>uint256</code> end - when the referendum ended</li> <li><code>address</code> submissionDepositor - the address of the depositor for the Submission Deposit</li> <li><code>uint256</code> submissionDeposit - the amount of the Submission Deposit</li> <li><code>address</code> decisionDepositor - the address of the depositor for the Decision Deposit</li> <li><code>uint256</code> decisionDeposit - the amount of the Decision Deposit</li> </ul> killedReferendumBlock(uint32 referendumIndex) - a read-only function that returns the block a given referendum was killed ParametersReturns <ul> <li><code>referendumIndex</code> - uint32 index of the killed referendum to query</li> </ul> <ul> <li><code>uint256</code> block number at which the referendum was killed</li> </ul> submitAt(uint16 trackId, bytes32 proposalHash, uint32 proposalLen, uint32 block) - submits a referendum given a Track ID corresponding to the origin from which the proposal is to be dispatched. Returns the referendum index of the submitted referendum ParametersReturns <ul> <li><code>trackId</code> - uint16 Track ID corresponding to the origin from which the proposal is to be dispatched</li> <li><code>proposalHash</code> - bytes32 preimage hash of the proposed runtime call</li> <li><code>proposalLen</code> - uint32 length of the proposal</li> <li><code>block</code> - uint32 block number at which this will be executed</li> </ul> <ul> <li><code>uint32</code> index of the submitted referendum</li> </ul> submitAfter(uint16 trackId, bytes32 proposalHash, uint32 proposalLen, uint32 block) - submits a referendum given a Track ID corresponding to the origin from which the proposal is to be dispatched. Returns the referendum index of the submitted referendum ParametersReturns <ul> <li><code>trackId</code> - uint16 Track ID corresponding to the origin from which the proposal is to be dispatched</li> <li><code>proposalHash</code> - bytes32 preimage hash of the proposed runtime call</li> <li><code>proposalLen</code> - uint32 length of the proposal</li> <li><code>block</code> - uint32 block number after which this will be executed</li> </ul> <ul> <li><code>uint32</code> index of the submitted referendum</li> </ul> placeDecisionDeposit(uint32 index) - posts the Decision Deposit for a referendum given the index of the going referendum ParametersReturns <ul> <li><code>index</code> - uint32 index of the ongoing referendum to place the Decision Deposit for</li> </ul> <p>None.</p> refundDecisionDeposit(uint32 index) - refunds the Decision Deposit for a closed referendum back to the depositor ParametersReturns <ul> <li><code>index</code> - uint32 index of the closed referendum in which the Decision Deposit is still locked</li> </ul> <p>None.</p> refundSubmissionDeposit(uint32 index) - refunds the Submission Deposit for a closed referendum back to the depositor ParametersReturns <ul> <li><code>index</code> - uint32 index of the closed referendum to refund the Submission Deposit for</li> </ul> <p>None.</p> <p>The interface also includes the following events:</p> <ul> <li>SubmittedAt(uint16 indexed trackId, uint32 referendumIndex, bytes32 hash) - emitted when a referenda has been submitted at a given block</li> <li>SubmittedAfter(uint16 indexed trackId, uint32 referendumIndex, bytes32 hash) - emitted when a referenda has been submitted after a given block</li> <li>DecisionDepositPlaced(uint32 index, address caller, uint256 depositedAmount) - emitted when a Decision Deposit for a referendum has been placed</li> <li>DecisionDepositRefunded(uint32 index, address caller, uint256 refundedAmount) - emitted when a Decision Deposit for a closed referendum has been refunded</li> <li>SubmissionDepositRefunded(uint32 index, address caller, uint256 refundedAmount) - emitted when a Submission Deposit for a valid referendum has been refunded</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/ethereum/precompiles/features/governance/referenda/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The below example is demonstrated on Moonbase Alpha, however, similar steps can be taken for Moonriver. To follow the steps in this guide, you'll need to have the following:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account with some DEV tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#remix-set-up","title":"Remix Set Up","text":"<ol> <li>Click on the File explorer tab</li> <li>Paste a copy of <code>Referenda.sol</code> into a Remix file named <code>Referenda.sol</code></li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile Referenda.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure Referenda.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the Referenda Precompile for Moonbase Alpha: <code>0x0000000000000000000000000000000000000811</code> and click At Address</li> <li>The Referenda Precompile will appear in the list of Deployed Contracts</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#submit-a-proposal","title":"Submit a Proposal","text":"<p>In order to submit a proposal, you should have already submitted the preimage hash for the proposal. If you have not done so, please follow the steps outlined in the Preimage Precompile documentation. There are two methods that can be used to submit a proposal: <code>submitAt</code> and <code>submitAfter</code>. The <code>submitAt</code> function submits a proposal to be executed at a given block and the <code>submitAfter</code> function submits a proposal to be executed after a specific block. For this example, <code>submitAt</code> will be used, but the same steps can be applied if you want to use <code>submitAfter</code> instead.</p> <p>To submit the proposal, you'll need to determine which Track your proposal belongs to and the Track ID of that Track. For help with these requirements, you can refer to the OpenGov section of the governance overview page.</p> <p>You'll also need to make sure you have the preimage hash and the length of the preimage handy, both of which you should have received from following the steps in the Preimage Precompile documentation. If you're unsure, you can find your preimage from the Preimage page of Polkadot.js Apps and copy the preimage hash. To get the length of the preimage, you can then query the <code>preimage</code> pallet using the <code>preimageFor</code> method from the Polkadot.js Apps Chain State page.</p> <p>Once you have the Track ID, preimage hash, and preimage length, you can go ahead and submit the proposal using the Referenda Precompile. From Remix, you can take the following steps:</p> <ol> <li>Expand the Referenda Precompile contract to see the available functions</li> <li>Find the submitAt function and press the button to expand the section</li> <li>Enter the track ID that your proposal will be processed through</li> <li>Enter the preimage hash. You should have received this from following the steps in the Preimage Precompile documentation</li> <li>Enter the length of the preimage</li> <li>Enter the block you want the proposal to be executed at</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p></p> <p>After your transaction has been confirmed you'll be able to see the proposal listed on the Referenda page of Polkadot.js Apps. You can also check out your proposal on Polkassembly, which sorts proposals by the Track they belong to.</p>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#submit-decision-deposit","title":"Submit Decision Deposit","text":"<p>Now that you've submitted your proposal, the next step is to submit the Decision Deposit. The Decision Deposit is the minimum deposit amount required for a referendum to progress to the decision phase at the end of the Lead-in Period. For more information on the Decision Deposit, please refer to the OpenGov section of the governance overview page.</p> <p>You can submit the Decision Deposit using the <code>placeDecisionDeposit</code> function of the Referenda Precompile. You'll just need to have the index of the referendum and enough funds to do so. The Decision Deposit varies by Track, to find the minimum amount required you can take a look at the General Parameters by Track table on the governance overview page.</p> <p>To submit the deposit, you can take the following steps:</p> <ol> <li>Find the placeDecisionDeposit function and press the button to expand the section</li> <li>Enter the index of the referendum</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p></p> <p>Now that the Decision Deposit has been placed, the referendum is one step closer to moving to the Decide Period. There will also need to be enough Capacity in the designated Track and the duration of the Prepare Period must pass for it to move to the Decide Period.</p> <p>To vote on referenda, you can follow the steps outlined in the Conviction Voting Precompile documentation.</p>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#refund-decision-deposit","title":"Refund Decision Deposit","text":"<p>Once a referendum has either been approved or rejected, the Decision Deposit can be refunded. This holds true as long as the referendum wasn't cancelled due to the proposal being malicious. If the proposal is deemed malicious and killed via the Root Track or the Emergency Killer Track, the Decision Deposit will be slashed.</p> <p>To refund the Decision Deposit, you can use the <code>refundDecisionDeposit</code> function of the Referenda Precompile. To do so, you can take the following steps:</p> <ol> <li>Find the refundDecisionDeposit function and press the button to expand the section</li> <li>Enter the index of the referendum</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p></p> <p>And that's it! You've completed your introduction to the Referenda Precompile. There are a few more functions that are documented in <code>Referenda.sol</code> \u2014 feel free to reach out on Discord if you have any questions about those functions or any other aspect of the Referenda Precompile.</p>"},{"location":"builders/ethereum/precompiles/interoperability/gmp/","title":"Interacting with the GMP Precompile","text":""},{"location":"builders/ethereum/precompiles/interoperability/gmp/#introduction","title":"Introduction","text":"<p>Moonbeam Routed Liquidity (MRL) refers to Moonbeam\u2019s use case as the port parachain for liquidity from origin chains into other Polkadot parachains. This is possible because of general message passing (GMP), where messages with arbitrary data and tokens can be sent across non-parachain blockchains through chain-agnostic GMP protocols. These GMP protocols can combine with Polkadot's XCM messaging system to allow for seamless liquidity routing.  </p> <p>The GMP precompile acts as an interface for Moonbeam Routed Liquidity, acting as a middleman between token-bearing messages from GMP protocols and parachains connected to Moonbeam via XCMP. Currently, the GMP Precompile only supports the relaying of liquidity through the Wormhole GMP protocol.  </p> <p>The GMP Precompile is located at the following address:  </p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000816\n</code></pre> <pre><code>0x0000000000000000000000000000000000000816\n</code></pre> <pre><code>0x0000000000000000000000000000000000000816\n</code></pre> <p>In practice, it is unlikely that a developer will have to directly interact with the precompile. GMP protocols' relayers interact with the precompile to complete cross-chain actions, so the origin chain that the cross-chain action originates is where the developer has the responsibility to ensure that the GMP precompile is used eventually.  </p>"},{"location":"builders/ethereum/precompiles/interoperability/gmp/#the-gmp-solidity-interface","title":"The GMP Solidity Interface","text":"<p><code>Gmp.sol</code> is a Solidity interface that allows developers to interact with the precompile.   </p> Gmp.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Gmp contract's address.\naddress constant GMP_ADDRESS = 0x0000000000000000000000000000000000000816;\n\n/// @dev The Gmp contract's instance.\nGmp constant GMP_CONTRACT = Gmp(GMP_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Gmp precompile\n/// @dev Provides an endpoint to Gmp protocols which can automatically forward to XCM\n/// @custom:address 0x0000000000000000000000000000000000000816\ninterface Gmp {\n    // TODO: Here we would specify the endpoints for each GMP protocol on a case by case basis.\n    //       These endpoints are basically the hand offs for each protocol -- where they delegate to\n    //       the target contract.\n    //\n    //       This design should allow users to interact with this precompile with no changes to the\n    //       underlying GMP protocols by simply specifying the correct precompile as the target.\n\n    /// Receive a wormhole VAA and process it\n    ///\n    /// @custom:selector f53774ab\n    function wormholeTransferERC20(bytes memory vaa) external;\n}\n</code></pre> <p>The GMP precompile has one method: </p> <ul> <li>wormholeTransferERC20(bytes memory vaa) - receives a Wormhole bridge transfer verified action approval (VAA), mints tokens via the Wormhole token bridge, and forwards the liquidity to the custom payload\u2019s multilocation. The payload is expected to be a precompile-specific SCALE encoded object, as explained in this guide's Building the Payload for Wormhole section</li> </ul> <p>VAAs are payload-containing packages generated after origin-chain transactions and are discovered by Wormhole Guardians.</p> <p>The most common instance in which a user will have to interact with the precompile is during a recovery, where a relayer doesn\u2019t complete an MRL transaction. For example, a user must search for the VAA that comes with their origin chain transaction and manually invoke the <code>wormholeTransferERC20</code> function.</p>"},{"location":"builders/ethereum/precompiles/interoperability/gmp/#building-the-payload-for-wormhole","title":"Building the Payload for Wormhole","text":"<p>Currently, the GMP precompile only supports sending liquidity with Wormhole, through Moonbeam, and into other parachains. The GMP precompile does not assist with a route from parachains back to Moonbeam and subsequently, Wormhole-connected chains.    </p> <p>To send liquidity from a Wormhole-connected origin chain like Ethereum, users must invoke the <code>transferTokensWithPayload</code> method on the origin-chain's deployment of the WormholeTokenBridge smart contract. This function requires a bytes payload, which must be formatted as a SCALE encoded multilocation object wrapped within another precompile-specific versioned type.</p> <p>You may be unfamiliar with SCALE encoding and multilocations if you are unfamiliar with the Polkadot ecosystem. SCALE encoding is a compact form of encoding that Polkadot uses. The <code>MultiLocation</code> type is used to define a relative point in Polkadot, such as a specific account on a specific parachain (Polkadot blockchain).  </p> <p>Moonbeam\u2019s GMP protocol requires a multilocation to represent the destination for liquidity routing, which most likely means an account on another parachain. Whatever it is, this destination must be expressed as relative to Moonbeam.  </p> <p>Remember</p> <p>Multilocations being relative is important, because a parachain team may erroneously give you a multilocation relative to their own chain, which can be different. Providing an incorrect multilocation can result in loss of funds!</p> <p>Each parachain will have its specific methods of interpreting a multilocation, and should confirm with the project that the multilocation that you formed is correct. However, you will most likely be forming a multilocation with an account.</p> <p>Multiple types of accounts can be included in a multilocation, which you must know beforehand when constructing your multilocation. The two most common are:</p> <ul> <li>AccountKey20 \u2014 an account ID that is 20-bytes in length, including Ethereum-compatible account IDs such as those on Moonbeam</li> <li>AccountId32 \u2014 an account ID that is 32-bytes in length, standard in Polkadot and its parachains</li> </ul> <p>The following multilocation templates target accounts on other parachains with Moonbeam as the relative origin. To use them, replace <code>INSERT_PARACHAIN_ID</code> with the parachain ID of the network you wish to send funds to and replace <code>INSERT_ADDRESS</code> with the address of the account you want to send funds to on that parachain.  </p> AccountId32AccountKey20 <pre><code>{\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { Parachain: 'INSERT_PARACHAIN_ID' },\n        {\n          AccountId32: {\n            id: 'INSERT_ADDRESS',\n          },\n        },\n      ],\n    },\n  },\n};\n</code></pre> <pre><code>{\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { Parachain: 'INSERT_PARACHAIN_ID' },\n        {\n          AccountKey20: {\n            key: 'INSERT_ADDRESS',\n          },\n        },\n      ],\n    },\n  }\n};\n</code></pre> <p>It can be challenging to correctly SCALE encode the entire payload without the right tools, mainly due to the custom types expected by the precompile. Fortunately, the Polkadot.js API can assist with this.</p> <p>The versioned user action expected by the precompile accepts two versions: V1 and V2. V1 accepts the <code>XcmRoutingUserAction</code> type, which attempts to route the transferred assets to the destination defined by the multilocation. V2 accepts the <code>XcmRoutingUserActionWithFee</code> type, which also attempts to route the transferred assets to the destination and allows a fee to be paid. Relayers can use V2 to specify a fee on Moonbeam to relay the transaction to the given destination.</p> <p>The following script shows how to create a <code>Uint8Array</code> that can be used as a payload for the GMP precompile:  </p> V1V2 <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nenum MRLTypes {\n  // Runtime defined MultiLocation. Allows for XCM versions 2, 3, and 4\n  XcmVersionedLocation = 'XcmVersionedLocation',\n  // MRL payload (V1) that only defines the destination MultiLocation\n  XcmRoutingUserAction = 'XcmRoutingUserAction',\n  // Wrapper object for the MRL payload\n  VersionedUserAction = 'VersionedUserAction',\n}\n\n// Parachain IDs of each parachain\nenum Parachain {\n  MoonbaseBeta = 888,\n  // Insert additional parachain IDs\n}\n\n// List of parachains that use ethereum (20) accounts\nconst ETHEREUM_ACCOUNT_PARACHAINS = [Parachain.MoonbaseBeta];\n\n// A function that creates a SCALE encoded payload to use with transferTokensWithPayload\nasync function createMRLPayload(\n  parachainId: Parachain,\n  account: string\n): Promise&lt;Uint8Array&gt; {\n  // Create a multilocation object based on the target parachain's account type\n  const isEthereumStyle = ETHEREUM_ACCOUNT_PARACHAINS.includes(parachainId);\n  const multilocation = {\n    V4: {\n      parents: 1,\n      interior: {\n        X2: [\n          { Parachain: parachainId },\n          isEthereumStyle\n            ? { AccountKey20: { key: account } }\n            : { AccountId32: { id: account } },\n        ],\n      },\n    },\n  };\n\n  // Creates an API for Moonbeam that defines MRL's special types\n  const wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n  const api = await ApiPromise.create({\n    provider: wsProvider,\n    types: {\n      [MRLTypes.XcmRoutingUserAction]: {\n        destination: MRLTypes.XcmVersionedLocation,\n      },\n      [MRLTypes.VersionedUserAction]: {\n        _enum: { V1: MRLTypes.XcmRoutingUserAction },\n      },\n    },\n  });\n\n  // Format multilocation object as a Polkadot.js type\n  const versionedLocation = api.createType(\n    MRLTypes.XcmVersionedLocation,\n    multilocation\n  );\n  const userAction = api.createType(MRLTypes.XcmRoutingUserAction, {\n    destination: versionedLocation,\n  });\n\n  // Wrap and format the MultiLocation object into the precompile's input type\n  const versionedUserAction = api.createType(MRLTypes.VersionedUserAction, {\n    V1: userAction,\n  });\n\n  // Disconnect the API\n  api.disconnect();\n\n  // SCALE encode resultant precompile formatted objects\n  return versionedUserAction.toU8a();\n}\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { u256 } from '@polkadot/types';\n\nenum MRLTypes {\n  // Runtime defined MultiLocation. Allows for XCM versions 2 and 3\n  XcmVersionedLocation = 'XcmVersionedLocation',\n  // MRL payload (V2) that defines the destination MultiLocation and a\n  // fee for the relayer\n  XcmRoutingUserActionWithFee = 'XcmRoutingUserActionWithFee',\n  // Wrapper object for the MRL payload\n  VersionedUserAction = 'VersionedUserAction',\n}\n\n// Parachain IDs of each parachain\nenum Parachain {\n  MoonbaseBeta = 888,\n  // Insert additional parachain IDs\n}\n\n// List of parachains that use ethereum (20) accounts\nconst ETHEREUM_ACCOUNT_PARACHAINS = [Parachain.MoonbaseBeta];\n\n// A function that creates a SCALE encoded payload to use with\n// transferTokensWithPayload\nasync function createMRLPayload(\n  parachainId: Parachain,\n  account: string,\n  fee: u256\n): Promise&lt;Uint8Array&gt; {\n  // Create a multilocation object based on the target parachain's account\n  // type\n  const isEthereumStyle = ETHEREUM_ACCOUNT_PARACHAINS.includes(parachainId);\n  const multilocation = {\n    V4: {\n      parents: 1,\n      interior: {\n        X2: [\n          { Parachain: parachainId },\n          isEthereumStyle\n            ? { AccountKey20: { key: account } }\n            : { AccountId32: { id: account } },\n        ],\n      },\n    },\n  };\n\n  // Creates an API for Moonbeam that defines MRL's special types\n  const wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n  const api = await ApiPromise.create({\n    provider: wsProvider,\n    types: {\n      [MRLTypes.XcmRoutingUserActionWithFee]: {\n        destination: MRLTypes.XcmVersionedLocation,\n        fee: 'U256',\n      },\n      [MRLTypes.VersionedUserAction]: {\n        _enum: { V2: MRLTypes.XcmRoutingUserActionWithFee },\n      },\n    },\n  });\n\n  // Format multilocation object as a Polkadot.js type\n  const versionedLocation = api.createType(\n    MRLTypes.XcmVersionedLocation,\n    multilocation\n  );\n  const userAction = api.createType(MRLTypes.XcmRoutingUserActionWithFee, {\n    destination: versionedLocation,\n    fee,\n  });\n\n  // Wrap and format the MultiLocation object into the precompile's input type\n  const versionedUserAction = api.createType(MRLTypes.VersionedUserAction, {\n    V2: userAction,\n  });\n\n    // Disconnect the API\n    api.disconnect();\n\n  // SCALE encode resultant precompile formatted objects\n  return versionedUserAction.toU8a();\n}\n</code></pre>"},{"location":"builders/ethereum/precompiles/interoperability/gmp/#restrictions","title":"Restrictions","text":"<p>The GMP precompile is currently in its early stages. There are many restrictions, and it only supports a \u201chappy path\u201d into parachains. Here are some restrictions that you should be aware of:</p> <ul> <li>There is currently no fee mechanism. Relayers that run the forwarding of liquidity on Moonbeam to a parachain will be subsidizing transactions. This may change in the future</li> <li>The precompile does not check to ensure that the destination chain supports the token that is being sent to it. Incorrect multilocations may result in loss of funds</li> <li>Errors in constructing a multilocation will result in reverts, which will trap tokens and result in a loss of funds</li> <li>There is currently no recommended path backward, from parachains to other chains like Ethereum. There is additional protocol-level work that must be done before a one-click method can be realized</li> <li>Due to a restriction with the ERC-20 XC-assets, the only way to send tokens from a parachain back through Moonbeam is to have xcGLMR on the origin parachain and use it as a fee asset when sending tokens back  </li> </ul>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/","title":"Ethereum MainNet Precompiled Contracts","text":""},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#introduction","title":"Introduction","text":"<p>Precompiled contracts in Ethereum are contracts that include complex cryptographic computations, but do not require the overhead of the EVM. These precompiles can be used within the EVM to handle specific common operations such as hashing and signature schemes.</p> <p>The following precompiles are currently included: ecrecover, sha256, ripemd-160, Bn128Add, Bn128Mul, Bn128Pairing, the identity function, and modular exponentiation.</p> <p>These precompiles are natively available on Ethereum and, to maintain Ethereum compatibility, they are also available on Moonbeam.</p> <p>In this guide, you will learn how to use and/or verify these precompiles.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>You need to install Node.js (for this example, you can use v16.x) and the npm package manager. You can download directly from Node.js or in your terminal:</p> UbuntuMacOS <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n\nsudo apt install -y nodejs\n</code></pre> <pre><code># You can use homebrew (https://docs.brew.sh/Installation)\nbrew install node\n\n# Or you can use nvm (https://github.com/nvm-sh/nvm)\nnvm install node\n</code></pre> <p>You can verify that everything is installed correctly by querying the version for each package:</p> <pre><code>node -v\n</code></pre> <pre><code>npm -v\n</code></pre> <p>As of writing this guide, the versions used were 15.2.1 and 7.0.8, respectively. You will also need to install the Web3 package by executing:</p> <pre><code>npm install --save web3\n</code></pre> <p>To verify the installed version of Web3, you can use the <code>ls</code> command:</p> <pre><code>npm ls web3\n</code></pre> <p>As of writing this guide, the version used was 1.3.0. You will be also using Remix, connecting it to the Moonbase Alpha TestNet via MetaMask.</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#verify-signatures-with-ecrecover","title":"Verify Signatures with ECRECOVER","text":"<p>The main function of this precompile is to verify the signature of a message. In general terms, you feed <code>ecrecover</code> the transaction's signature values and it returns an address. The signature is verified if the address returned is the same as the public address that sent the transaction.</p> <p>The following will be a small example to showcase how to leverage this precompiled function. You'll need to retrieve the transaction's signature values (<code>v</code>, <code>r</code>, <code>s</code>). Therefore, you'll sign and retrieve the signed message where these values are:</p> <pre><code>const { Web3 } = require('web3');\n\n// Provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\n// Address and Private Key\nconst address = '0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b';\nconst pk1 = '99B3C12287537E38C90A9219D4CB074A89A16E9CDB20BF85728EBD97C343E342';\nconst msg = web3.utils.sha3('supercalifragilisticexpialidocious');\n\nasync function signMessage(pk) {\n  try {\n    // Sign and get Signed Message\n    const smsg = await web3.eth.accounts.sign(msg, pk);\n    console.log(smsg);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nsignMessage(pk1);\n</code></pre> <p>This code will return the following object in the terminal:</p> <pre><code>{\n  message: '0xc2ae6711c7a897c75140343cde1cbdba96ebbd756f5914fde5c12fadf002ec97',\n  messageHash: '0xc51dac836bc7841a01c4b631fa620904fc8724d7f9f1d3c420f0e02adf229d50',\n  v: '0x1b',\n  r: '0x44287513919034a471a7dc2b2ed121f95984ae23b20f9637ba8dff471b6719ef',\n  s: '0x7d7dc30309a3baffbfd9342b97d0e804092c0aeb5821319aa732bc09146eafb4',\n  signature: '0x44287513919034a471a7dc2b2ed121f95984ae23b20f9637ba8dff471b6719ef7d7dc30309a3baffbfd9342b97d0e804092c0aeb5821319aa732bc09146eafb41b'\n}\n</code></pre> <p>With the necessary values, you can go to Remix to test the precompiled contract. Note that this can also be verified with the Web3.js library, but in this case, you can go to Remix to be sure that it is using the precompiled contract on the blockchain. The Solidity code you can use to verify the signature is the following:</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract ECRECOVER {\n    address addressTest = 0x12Cb274aAD8251C875c0bf6872b67d9983E53fDd;\n    bytes32 msgHash =\n        0xc51dac836bc7841a01c4b631fa620904fc8724d7f9f1d3c420f0e02adf229d50;\n    uint8 v = 0x1b;\n    bytes32 r =\n        0x44287513919034a471a7dc2b2ed121f95984ae23b20f9637ba8dff471b6719ef;\n    bytes32 s =\n        0x7d7dc30309a3baffbfd9342b97d0e804092c0aeb5821319aa732bc09146eafb4;\n\n    function verify() public view returns (bool) {\n        // Use ECRECOVER to verify address\n        return (ecrecover(msgHash, v, r, s) == (addressTest));\n    }\n}\n</code></pre> <p>Using the Remix compiler and deployment and with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>verify()</code> method that returns true if the address returned by <code>ecrecover</code> is equal to the address used to sign the message (related to the private key and needs to be manually set in the contract).</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#hashing-with-sha256","title":"Hashing with SHA256","text":"<p>This hashing function returns the SHA256 hash from the given data. To test this precompile, you can use this SHA256 Hash Calculator tool to calculate the SHA256 hash of any string you want. In this case, you'll do so with <code>Hello World!</code>. You can head directly to Remix and deploy the following code, where the calculated hash is set for the <code>expectedHash</code> variable:</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract Hash256 {\n    bytes32 public expectedHash =\n        0x7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069;\n\n    function calculateHash() internal pure returns (bytes32) {\n        string memory word = \"Hello World!\";\n        bytes32 hash = sha256(bytes(word));\n\n        return hash;\n    }\n\n    function checkHash() public view returns (bool) {\n        return (calculateHash() == expectedHash);\n    }\n}\n</code></pre> <p>Once the contract is deployed, you can call the <code>checkHash()</code> method that returns true if the hash returned by <code>calculateHash()</code> is equal to the hash provided.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#hashing-with-ripemd-160","title":"Hashing with RIPEMD160","text":"<p>This hashing function returns a RIPEMD160 hash from the given data. To test this precompile, you can use this RIPEMD160 Hash Calculator tool to calculate the RIPEMD160 hash of any string. In this case, you'll do so again with <code>Hello World!</code>. You'll reuse the same code as before, but use the <code>ripemd160</code> function. Note that it returns a <code>bytes20</code> type variable:</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract HashRipmd160 {\n    bytes20 public expectedHash = hex\"8476ee4631b9b30ac2754b0ee0c47e161d3f724c\";\n\n    function calculateHash() internal pure returns (bytes20) {\n        string memory word = \"Hello World!\";\n        bytes20 hash = ripemd160(bytes(word));\n\n        return hash;\n    }\n\n    function checkHash() public view returns (bool) {\n        return (calculateHash() == expectedHash);\n    }\n}\n</code></pre> <p>With the contract deployed, you can call the <code>checkHash()</code> method that returns true if the hash returned by <code>calculateHash()</code> is equal to the hash provided.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#bn128add","title":"BN128Add","text":"<p>The BN128Add precompile implements a native elliptic curve point addition. It returns an elliptic curve point representing <code>(ax, ay) + (bx, by)</code> such that <code>(ax, ay)</code> and <code>(bx, by)</code> are valid points on the curve BN256.</p> <p>Currently there is no BN128Add support in Solidity, so it needs to be called with inline assembly. The following sample code can be used to call this precompile.</p> <pre><code>pragma solidity &gt;=0.4.21;\n\ncontract Precompiles {\n    function callBn256Add(\n        bytes32 ax,\n        bytes32 ay,\n        bytes32 bx,\n        bytes32 by\n    ) public returns (bytes32[2] memory result) {\n        bytes32[4] memory input;\n        input[0] = ax;\n        input[1] = ay;\n        input[2] = bx;\n        input[3] = by;\n        assembly {\n            let success := call(gas, 0x06, 0, input, 0x80, result, 0x40)\n            switch success\n            case 0 {\n                revert(0, 0)\n            }\n        }\n    }\n}\n</code></pre> <p>Using the Remix compiler and deployment and with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>callBn256Add(bytes32 ax, bytes32 ay, bytes32 bx, bytes32 by)</code> method to return the result of the operation.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#bn128mul","title":"BN128Mul","text":"<p>The BN128Mul precompile implements a native elliptic curve multiplication with a scalar value. It returns an elliptic curve point representing <code>scalar * (x, y)</code> such that <code>(x, y)</code> is a valid curve point on the curve BN256.</p> <p>Currently there is no BN128Mul support in Solidity, so it needs to be called with inline assembly. The following sample code can be used to call this precompile.</p> <pre><code>pragma solidity &gt;=0.4.21;\n\ncontract Precompiles {\n    function callBn256ScalarMul(\n        bytes32 x,\n        bytes32 y,\n        bytes32 scalar\n    ) public returns (bytes32[2] memory result) {\n        bytes32[3] memory input;\n        input[0] = x;\n        input[1] = y;\n        input[2] = scalar;\n        assembly {\n            let success := call(gas, 0x07, 0, input, 0x60, result, 0x40)\n            switch success\n            case 0 {\n                revert(0, 0)\n            }\n        }\n    }\n}\n</code></pre> <p>Using the Remix compiler and deployment and with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>callBn256ScalarMul(bytes32 x, bytes32 y, bytes32 scalar)</code> method to return the result of the operation.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#bn128pairing","title":"BN128Pairing","text":"<p>The BN128Pairing precompile implements elliptic curve pairing operation to perform zkSNARK verification. For more information, check out the EIP-197 standard.</p> <p>Currently there is no BN128Pairing support in Solidity, so it needs to be called with inline assembly. The following sample code can be used to call this precompile.</p> <pre><code>pragma solidity &gt;=0.4.21;\n\ncontract Precompiles {\n    function callBn256Pairing(\n        bytes memory input\n    ) public returns (bytes32 result) {\n        // input is a serialized bytes stream of (a1, b1, a2, b2, ..., ak, bk) from (G_1 x G_2)^k\n        uint256 len = input.length;\n        require(len % 192 == 0);\n        assembly {\n            let memPtr := mload(0x40)\n            let success := call(\n                gas(),\n                0x08,\n                0,\n                add(input, 0x20),\n                len,\n                memPtr,\n                0x20\n            )\n            switch success\n            case 0 {\n                revert(0, 0)\n            }\n            default {\n                result := mload(memPtr)\n            }\n        }\n    }\n}\n</code></pre> <p>Using the Remix compiler and deployment and with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>function callBn256Pairing(bytes memory input)</code> method to return the result of the operation.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#the-identity-function","title":"The Identity Function","text":"<p>Also known as datacopy, this function serves as a cheaper way to copy data in memory.</p> <p>Currently there is no Identity Function support in Solidity, so it needs to be called with inline assembly. The following sample code (adapted to Solidity), can be used to call this precompiled contract:</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract Identity {\n    bytes public memoryStored;\n\n    function callDatacopy(bytes memory data) public returns (bytes memory) {\n        bytes memory result = new bytes(data.length);\n        assembly {\n            let len := mload(data)\n            if iszero(\n                call(\n                    gas(),\n                    0x04,\n                    0,\n                    add(data, 0x20),\n                    len,\n                    add(result, 0x20),\n                    len\n                )\n            ) {\n                invalid()\n            }\n        }\n\n        memoryStored = result;\n\n        return result;\n    }\n}\n</code></pre> <p>You can use this Web3 Type Converter tool to get bytes from any string, as this is the input of the <code>callDataCopy()</code> method.</p> <p>With the contract deployed, you can call the <code>callDataCopy()</code> method and verify if <code>memoryStored</code> matches the bytes that you pass in as an input of the function.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#modular-exponentiation","title":"Modular Exponentiation","text":"<p>This precompile calculates the remainder when an integer <code>b</code> (base) is raised to the <code>e</code>-th power (the exponent), and is divided by a positive integer <code>m</code> (the modulus).</p> <p>The Solidity compiler does not support it, so it needs to be called with inline assembly. The following code was simplified to show the functionality of this precompile:</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract ModularCheck {\n    uint public checkResult;\n\n    // Function to Verify ModExp Result\n    function verify(uint _base, uint _exp, uint _modulus) public {\n        checkResult = modExp(_base, _exp, _modulus);\n    }\n\n    function modExp(\n        uint256 _b,\n        uint256 _e,\n        uint256 _m\n    ) public returns (uint256 result) {\n        assembly {\n            // Free memory pointer\n            let pointer := mload(0x40)\n            // Define length of base, exponent and modulus. 0x20 == 32 bytes\n            mstore(pointer, 0x20)\n            mstore(add(pointer, 0x20), 0x20)\n            mstore(add(pointer, 0x40), 0x20)\n            // Define variables base, exponent and modulus\n            mstore(add(pointer, 0x60), _b)\n            mstore(add(pointer, 0x80), _e)\n            mstore(add(pointer, 0xa0), _m)\n            // Store the result\n            let value := mload(0xc0)\n            // Call the precompiled contract 0x05 = bigModExp\n            if iszero(call(not(0), 0x05, 0, pointer, 0xc0, value, 0x20)) {\n                revert(0, 0)\n            }\n            result := mload(value)\n        }\n    }\n}\n</code></pre> <p>You can try this in Remix. Use the function <code>verify()</code>, passing the base, exponent, and modulus. The function will store the value in the <code>checkResult</code> variable.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#p256-verify","title":"P256 Verify","text":"<p>The P256Verify Precompile adds support for RIP-7212, signature verification for Secp256r1 elliptic curve. This precompile adds a WASM implementation of the signature verification and is intended to be replaced by a native runtime function call once available.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\ncontract P256Verify {\n    function verify(\n        bytes32 msg_hash,\n        bytes32[2] memory signature,\n        bytes32[2] memory public_key\n    ) public view returns (bool) {\n        bool output;\n\n        bytes memory args = abi.encodePacked(\n            msg_hash,\n            signature[0],\n            signature[1],\n            public_key[0],\n            public_key[1]\n        );\n\n        bool success;\n        assembly {\n            success := staticcall(not(0), 0x100, add(args, 32), mload(args), output, 0x20)\n        }\n        require(success, \"p256verify precompile call failed\");\n\n        return output;\n    }\n}\n</code></pre> <p>The file below contains two different test cases: one with a valid signature test and a second with an invalid signature test.</p> p256verifywithtests.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\ncontract P256Verify {\n    function verify(\n        bytes32 msg_hash,\n        bytes32[2] memory signature,\n        bytes32[2] memory public_key\n    ) public view returns (bool) {\n        bool output;\n\n        bytes memory args = abi.encodePacked(\n            msg_hash,\n            signature[0],\n            signature[1],\n            public_key[0],\n            public_key[1]\n        );\n\n        bool success;\n        assembly {\n            success := staticcall(not(0), 0x100, add(args, 32), mload(args), output, 0x20)\n        }\n        require(success, \"p256verify precompile call failed\");\n\n        return output;\n    }\n\n    function test() public {\n        bytes32[2] memory msg_hashes;\n        bytes32[2][2] memory signatures;\n        bytes32[2][2] memory public_keys;\n        bool[2] memory expected_result;\n\n        // Case 1 (valid)\n        msg_hashes[0] = hex\"b5a77e7a90aa14e0bf5f337f06f597148676424fae26e175c6e5621c34351955\";\n        signatures[0][0] = hex\"289f319789da424845c9eac935245fcddd805950e2f02506d09be7e411199556\";\n        signatures[0][1] = hex\"d262144475b1fa46ad85250728c600c53dfd10f8b3f4adf140e27241aec3c2da\";\n        public_keys[0][0] = hex\"3a81046703fccf468b48b145f939efdbb96c3786db712b3113bb2488ef286cdc\";\n        public_keys[0][1] = hex\"ef8afe82d200a5bb36b5462166e8ce77f2d831a52ef2135b2af188110beaefb1\";\n        expected_result[0] = true;\n\n        // Case 2 (invalid)\n        msg_hashes[1] = hex\"d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b\";\n        signatures[1][0] = hex\"6162630000000000000000000000000000000000000000000000000000000000\";\n        signatures[1][1] = hex\"6162630000000000000000000000000000000000000000000000000000000000\";\n        public_keys[1][0] = hex\"6162630000000000000000000000000000000000000000000000000000000000\";\n        public_keys[1][1] = hex\"6162630000000000000000000000000000000000000000000000000000000000\";\n        expected_result[0] = false;\n\n        for (uint256 i = 0; i &lt; expected_result.length; i++) {\n            bool result = verify(msg_hashes[i], signatures[i], public_keys[i]);\n            if (expected_result[i]) {\n                require(result, \"Expected success\");\n            } else {\n                require(!result, \"Expected failure\");\n            }\n        }\n    }\n}\n</code></pre> <p>Using the Remix compiler and deployment and with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>verify</code> method with the following parameters: </p> Valid SignatureInvalid Signature Parameter Value <code>msg_hash</code> <code>0xb5a77e7a90aa14e0bf5f337f06f597148676424fae26e175c6e5621c34351955</code> <code>signature</code> <code>[\"0x289f319789da424845c9eac935245fcddd805950e2f02506d09be7e411199556\", \"0xd262144475b1fa46ad85250728c600c53dfd10f8b3f4adf140e27241aec3c2da\"]</code> <code>public_key</code> <code>[\"0x3a81046703fccf468b48b145f939efdbb96c3786db712b3113bb2488ef286cdc\", \"0xef8afe82d200a5bb36b5462166e8ce77f2d831a52ef2135b2af188110beaefb1\"]</code> Expected Result <code>true</code> Parameter Value <code>msg_hash</code> <code>0xd182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b</code> <code>signature</code> <code>[\"0x6162630000000000000000000000000000000000000000000000000000000000\", \"0x6162630000000000000000000000000000000000000000000000000000000000\"]</code> <code>public_key</code> <code>[\"0x6162630000000000000000000000000000000000000000000000000000000000\", \"0x6162630000000000000000000000000000000000000000000000000000000000\"]</code> Expected Result <code>false</code> <p>You'll receive two booleans in response; the first one indicates whether the signature was valid, and the second indicates whether the call to the P256Verify precompile was successful. The second boolean should always return true; the first is the one to check to see if the signature is valid. </p>"},{"location":"builders/ethereum/precompiles/utility/non-specific/","title":"Non-Network Specific Precompiled Smart Contracts","text":""},{"location":"builders/ethereum/precompiles/utility/non-specific/#introduction","title":"Introduction","text":"<p>A precompiled contract, or precompile, is a set of programmed functionalities hard-coded into the blockchain client. Precompiles perform computationally heavy tasks, such as cryptographic processes like hashing. Moving these functionalities to the blockchain client serves the dual purpose of making the computation more efficient than using a traditional smart contract and ensuring everyone has access to the complete and accurate set of processes and algorithms required to operate correctly.</p> <p>Precompile functionality is bundled and shared under a smart contract address, which allows interactions similar to those of a traditional smart contract. Some precompiled contracts are not specific to Ethereum or Moonbeam, but are supported for use in your Moonbeam application. </p> <p>The nonspecific precompiles currently included in this category are the <code>ECRecoverPublicKey</code> and <code>SHA3FIPS256</code> precompiles. </p> <p>In the next section, you will learn more about the functionalities included in these precompiles.  </p>"},{"location":"builders/ethereum/precompiles/utility/non-specific/#retrieve-a-public-key-with-ecrecoverpublickey","title":"Retrieve a Public Key with ECRecoverPublicKey","text":"<p>The primary function of the <code>ECRecoverPublicKey</code> precompile is to recover the public key used to create a digital signature from a given message hash and signature. This precompile is similar to ECRecover, with the exception of returning the public key of the account that signed the message rather than the account address. </p> <p>In the following sections, you will learn how to use the <code>ECRecoverPublicKey</code> precompile.</p>"},{"location":"builders/ethereum/precompiles/utility/non-specific/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>You need to install Node.js (for this example, you can use v16.x) and the npm package manager. You can download directly from Node.js or in your terminal:</p> UbuntuMacOS <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n\nsudo apt install -y nodejs\n</code></pre> <pre><code># You can use homebrew (https://docs.brew.sh/Installation)\nbrew install node\n\n# Or you can use nvm (https://github.com/nvm-sh/nvm)\nnvm install node\n</code></pre> <p>You can verify that everything is installed correctly by querying the version for each package:</p> <pre><code>node -v\n</code></pre> <pre><code>npm -v\n</code></pre> <p>The versions used in this example are v20.15.0 (Node.js) and 10.7.0 (npm). You will also need to install the Web3 package by executing:</p> <pre><code>npm install --save web3\n</code></pre> <p>To verify the installed version of Web3, you can use the <code>ls</code> command:</p> <pre><code>npm ls web3\n</code></pre> <p>This example uses version 4.11.1. You will also use Remix, connecting it to the Moonbase Alpha TestNet via MetaMask.</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/ethereum/precompiles/utility/non-specific/#retrieve-transaction-signature-values","title":"Retrieve Transaction Signature Values","text":"<p>To use the <code>ECRecoverPublicKey</code> precompile, you must first sign a message to create and retrieve the message hash and transaction signature values (<code>v</code>, <code>r</code>, <code>s</code>) to pass as arguments in the contract call. Always use security best practices when handling private keys. </p> <p>Create a new file called <code>signMessage.js</code> in your project directory:</p> <pre><code>touch signMessage.js\n</code></pre> <p>Open <code>signMessage.js</code> in your code editor and add the following script to initialize Web3 with Moonbase Alpha TestNet, sign and hash the message, and return the signature values:</p> signMessage.js<pre><code>const { Web3 } = require('web3');\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\n// Address and private key\nconst address = 'INSERT_RECEIVER_ADDRESS';\nconst pk1 =\n  'INSERT_SENDER_PRIVATE_KEY';\nconst msg = web3.utils.sha3('supercooltestmessage');\n\nasync function signMessage(pk) {\n  try {\n    // Sign and get signed message\n    const smsg = await web3.eth.accounts.sign(msg, pk);\n    console.log(smsg);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nsignMessage(pk1);\n</code></pre> <p>Return to your terminal command line to run the script with this command:</p> <pre><code>node signMessage.js\n</code></pre> <p>This code will return the following object in the terminal:</p> node signMessage.js {   message: '0x5836e21a51f25aad199e2e0feb5ca19673ed56b3811285f5124d7a8171d75851',   messageHash: '0xa69b720d0293b9e8f4e471afb80f9d410b825abe5ce524e7d5755fd2a00bf9de',   v: '0x1b',   r: '0xb7d4783ee3b34d6fbc419d5b7bc67002c511322c5c71b49a7d78a8b7e9c5b30a',   s: '0x4e5939eaef3917b1cb09af9e632cc9a727b64191b7ee40a6ae34f6fdde60a371',   signature: '0xb7d4783ee3b34d6fbc419d5b7bc67002c511322c5c71b49a7d78a8b7e9c5b30a4e5939eaef3917b1cb09af9e632cc9a727b64191b7ee40a6ae34f6fdde60a3711b' } <p>Save these values as you will need them in the next section.</p>"},{"location":"builders/ethereum/precompiles/utility/non-specific/#test-ecrecoverpublickey-contract","title":"Test ECRecoverPublicKey Contract","text":"<p>You can now visit Remix to test the precompiled contract. Note that you could also use the Web3.js library, but in this case, you can go to Remix to ensure it is using the precompiled contract on the blockchain. The Solidity code you can use to retrieve the public key is the following:</p> RecoverPublicKey.sol<pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity &gt;=0.8.2 &lt;0.9.0;\n\ncontract RecoverPublicKey {\n    function recoverPublicKey(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public view returns (bytes memory) {\n        address precompileAddress = 0x0000000000000000000000000000000000000402;\n        (bool success, bytes memory publicKey) = precompileAddress.staticcall(\n            abi.encodeWithSignature(\n                \"ECRecoverPublicKey(bytes32,uint8,bytes32,bytes32)\",\n                hash,\n                v,\n                r,\n                s\n            )\n        );\n        require(success, \"ECRecoverPublicKey failed\");\n        return publicKey;\n    }\n}\n</code></pre> <p>Using the Remix compiler and deployment and with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>recoverPublicKey()</code> method which returns the public key for the account that signed the message. You can now use this public key value for other cryptographic functions and verifications.</p> <p></p>"},{"location":"builders/ethereum/precompiles/utility/non-specific/#create-a-hash-with-sha3fips256","title":"Create a Hash with SHA3FIPS256","text":"<p>SHA3-256 is part of the SHA-3 family of cryptographic hashes codified in FIPS202 that produces an output 256 bits in length. Although the name is similar to SHA256, the SHA-3 family is built with an entirely different algorithm and accordingly produces a different hash output than SHA256 for the same input. You can verify this yourself using this SHA3-256 Hash Calculator tool. After calculating the SHA3-256 output, change the algorithm in the drop-down selector to SHA256 and take note of the resulting output.</p> <p>Currently there is no SHA3-256 support in Solidity, so it needs to be called with inline assembly. The following sample code can be used to call this precompile.</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract Precompiles {\n    function sha3fips(bytes memory data) public view returns (bytes32) {\n        bytes32[1] memory h;\n        assembly {\n            if iszero(\n                staticcall(not(0), 0x400, add(data, 32), mload(data), h, 32)\n            ) {\n                invalid()\n            }\n        }\n        return h[0];\n    }\n}\n</code></pre> <p>Using Remix with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>sha3fips(bytes memory data)</code> method to return the encoded string of the data parameter.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/ethereum/precompiles/utility/registry/","title":"Precompile Registry on Moonbeam","text":""},{"location":"builders/ethereum/precompiles/utility/registry/#introduction","title":"Introduction","text":"<p>The Precompile Registry serves as a single source of truth for the available precompiles on Moonbeam. The Precompile Registry can be used to determine if an address corresponds to a precompile and whether or not a precompile is active or deprecated. This is particularly useful when there are upstream changes within the Substrate and Polkadot ecosystems that result in backward-incompatible changes to precompiles. Developers can design an exit strategy to ensure their dApp recovers gracefully in these scenarios.</p> <p>The Precompile Registry also serves an additional purpose, as it allows any user to set \"dummy code\" (<code>0x60006000fd</code>) for precompiles, which makes precompiles callable from Solidity. This is necessary as precompiles on Moonbeam, by default, don't have bytecode. The \"dummy code\" can bypass checks in Solidity that ensure contract bytecode exists and is non-empty.</p> <p>The Registry Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000815\n</code></pre> <pre><code>0x0000000000000000000000000000000000000815\n</code></pre> <pre><code>0x0000000000000000000000000000000000000815\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/utility/registry/#the-solidity-interface","title":"The Precompile Registry Solidity Interface","text":"<p><code>PrecompileRegistry.sol</code> is a Solidity interface that allows developers to interact with the precompile's methods.</p> PrecompileRegistry.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Precompile Registry contract's address.\naddress constant PRECOMPILE_REGISTRY_ADDRESS = 0x0000000000000000000000000000000000000815;\n\n/// @dev The Precompile Registry contract's instance.\nPrecompileRegistry constant PRECOMPILE_REGISTRY_CONTRACT = PrecompileRegistry(PRECOMPILE_REGISTRY_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Precompile Registry\n/// @dev Interface to the set of available precompiles.\ninterface PrecompileRegistry {\n    /// @dev Query if the given address is a precompile. Note that deactivated precompiles\n    /// are still considered precompiles and will return `true`.\n    /// @param a: Address to query\n    /// @return output Is this address a precompile?\n    /// @custom:selector 446b450e\n    function isPrecompile(address a) external view returns (bool);\n\n    /// @dev Query if the given address is an active precompile. Will return false if the\n    /// address is not a precompile or if this precompile is deactivated.\n    /// @param a: Address to query\n    /// @return output Is this address an active precompile?\n    /// @custom:selector 6f5e23cf\n    function isActivePrecompile(address a) external view returns (bool);\n\n    /// @dev Update the account code of a precompile address.\n    /// As precompiles are implemented inside the Runtime, they don't have a bytecode, and\n    /// their account code is empty by default. However in Solidity calling a function of a\n    /// contract often automatically adds a check that the contract bytecode is non-empty.\n    /// For that reason a dummy code (0x60006000fd) can be inserted at the precompile address\n    /// to pass that check. This function allows any user to insert that code to precompile address\n    /// if they need it.\n    /// @param a: Address of the precompile.\n    /// @custom:selector 48ceb1b4\n    function updateAccountCode(address a) external;\n}\n</code></pre> <p>The interface includes the following functions:</p> isPrecompile(address a) - returns a boolean indicating whether a given address is a precompile or not. Returns <code>true</code> for active and deprecated precompiles ParametersReturns <ul> <li><code>a</code> - address to check if it is a precompile</li> </ul> <ul> <li><code>bool</code> whether the address is a precompile (active or deprecated)</li> </ul> isActivePrecompile(address a) - returns a boolean indicating whether a given address is an active precompile or not. Returns <code>false</code> if a precompile has been deprecated ParametersReturns <ul> <li><code>a</code> - address to check if it is an active precompile</li> </ul> <ul> <li><code>bool</code> whether the address is an active precompile</li> </ul> updateAccountCode(address a) - updates a given precompile's bytecode with dummy code (<code>0x60006000fd</code>) given the address of the precompile. Precompiles, by default, don't have bytecode associated with them. This function can be used to add dummy bytecode to bypass requirements in Solidity that check if a contract's bytecode is not empty before its functions can be called ParametersReturns <ul> <li><code>a</code> - address of the precompile to update with dummy bytecode</li> </ul> <p>None.</p>"},{"location":"builders/ethereum/precompiles/utility/registry/#interact-with-precompile-registry-interface","title":"Interact with the Precompile Registry Solidity Interface","text":"<p>The following sections will cover how to interact with the Registry Precompile from Remix and Ethereum libraries, such as Ethers.js, Web3.js, and Web3.py.</p> <p>The examples in this guide will be on Moonbase Alpha. To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/ethereum/precompiles/utility/registry/#use-remix","title":"Use Remix to Interact with the Precompile Registry","text":"<p>To quickly get started with Remix, the Precompile Registry contract has been loaded from GitHub. You can also create a new file in Remix and manually paste in the contents of the <code>PrecompileRegistry.sol</code> contract.</p> <p></p> <p>Then you can take the following steps to compile, deploy, and interact with the Precompile Registry:</p> <ol> <li> <p>From the Compile tab, click on Compile PrecompileRegistry.sol to compile the contract.  A green checkmark will appear upon successfully compiling the contract</p> <p></p> </li> <li> <p>From the Deploy and run transactions tab, you can load the Precompile Registry using its address:</p> <ol> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down and you've connected MetaMask to Moonbase Alpha</li> <li>Ensure PrecompileRegistry is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the Precompile in the At Address field</li> <li>Provide the address of the Precompile Registry for Moonbase Alpha: <code>0x0000000000000000000000000000000000000815</code> and click At Address</li> <li>The Precompile Registry will appear in the list of Deployed Contracts</li> </ol> <p></p> </li> <li> <p>You can interact with any of the precompile's methods. Under Deployed Contracts, expand the Precompile Registry to view the list of methods. For example, you can use the isPrecompile function to check if an address is a precompile</p> <p></p> </li> </ol>"},{"location":"builders/ethereum/precompiles/utility/registry/#use-ethereum-libraries","title":"Use Ethereum Libraries to Interact with the Precompile Registry","text":"<p>To interact with the Precompile Registry's Solidity interface with an Ethereum library, you'll need the Precompile Registry's ABI.</p> Precompile Registry ABI <pre><code>[\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isActivePrecompile\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isPrecompile\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"updateAccountCode\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    }\n]\n</code></pre> <p>Once you have the ABI, you can interact with the Registry using the Ethereum library of your choice. Generally speaking, you'll take the following steps:</p> <ol> <li>Create a provider</li> <li>Create a contract instance of the Precompile Registry</li> <li>Interact with the Precompile Registry's functions</li> </ol> <p>Remember</p> <p>The following snippets are for demo purposes only. Never store your private keys in a JavaScript or Python file.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport ABI from './precompileRegistryABI.js'; // Import Precompile Registry ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n// Create interface for the Precompile Registry\nconst precompileRegistry = new ethers.Contract(\n  '0x0000000000000000000000000000000000000815',\n  ABI,\n  signer\n);\n\n// Interact with the Precompile Registry\nconst isActivePrecompile = async () =&gt; {\n  const proxyPrecompile = '0x000000000000000000000000000000000000080b';\n\n  // Check if the Proxy Precompile is a precompile\n  const isPrecompile = await precompileRegistry.isPrecompile(proxyPrecompile);\n  // Should return 'Address is a precompile: true'\n  console.log(`Address is a precompile: ${isPrecompile}`);\n\n  // Check if the Proxy Precompile is an active precompile\n  const isActivePrecompile = await precompileRegistry.isActivePrecompile(\n    proxyPrecompile\n  );\n  // Should return 'Address is an active precompile: true'\n  console.log(`Address is an active precompile: ${isActivePrecompile}`);\n};\n\nisActivePrecompile();\n</code></pre> <pre><code>import { Web3 } from 'web3';\nimport ABI from './precompileRegistryABI.js'; // Import Precompile Registry ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\n// Create interface for the Precompile Registry\nconst precompileRegistry = new web3.eth.Contract(\n  ABI,\n  '0x0000000000000000000000000000000000000815',\n  { from: web3.eth.accounts.privateKeyToAccount(privateKey).address }\n);\n\n// Interact with the Precompile Registry\nconst isActivePrecompile = async () =&gt; {\n  const proxyPrecompile = '0x000000000000000000000000000000000000080b';\n\n  // Check if the Proxy Precompile is a precompile\n  const isPrecompile = await precompileRegistry.methods.isPrecompile(\n    proxyPrecompile\n  ).call();\n  // Should return 'Address is a precompile: true'\n  console.log(`Address is a precompile: ${isPrecompile}`);\n\n  // Check if the Proxy Precompile is an active precompile\n  const isActivePrecompile =\n    await precompileRegistry.methods.isActivePrecompile(proxyPrecompile).call();\n  // Should return 'Address is an active precompile: true'\n  console.log(`Address is a precompile: ${isActivePrecompile}`);\n};\n\nisActivePrecompile();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_PRECOMPILE_REGISTRY_ABI\"  # Paste or import the Precompile Registry ABI\nprivate_key = \"INSERT_PRIVATE_KEY\"\n\n# Create provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create interface for the Precompile Registry\nprecompile_registry = web3.eth.contract(\n    address=\"0x0000000000000000000000000000000000000815\", abi=abi\n)\n\n\n# Interact with the Precompile Registry\ndef is_active_precompile():\n    proxy_precompile = \"0x000000000000000000000000000000000000080b\"\n\n    # Check if the Proxy Precompile is a precompile\n    is_precompile = precompile_registry.functions.isPrecompile(proxy_precompile).call()\n    # Should return 'Address is a precompile: true'\n    print(\"Address is a precompile: \", is_precompile)\n\n    # Check if the Proxy Precompile is an active precompile\n    is_active_precompile = precompile_registry.functions.isActivePrecompile(\n        proxy_precompile\n    ).call()\n    # Should return 'Address is an active precompile: true'\n    print(\"Address is an active precompile: \", is_active_precompile)\n\n\nis_active_precompile()\n</code></pre>"},{"location":"builders/ethereum/precompiles/utility/relay-data-verifier/","title":"Interacting with the Relay Data Verifier Precompile","text":""},{"location":"builders/ethereum/precompiles/utility/relay-data-verifier/#introduction","title":"Introduction","text":"<p>Polkadot relies on state proofs to guarantee data integrity at a particular time. A state proof is a concise, cryptographic data structure representing a specific subset of transactions or state data within a trie. It consists of a set of hashes that form a path from the target data to the root hash stored in the block header.</p> <p>A client can independently reconstruct the root hash and compare it with the original stored in the block header by providing a state proof. If the reconstructed root hash matches the original, it confirms the target data's authenticity, validity, and inclusion within the blockchain.</p> <p>Polkadot's unique architecture and parachain block validation process means blockchains like Moonbeam have the relay chain storage root hash in their state. Consequently, Moonbeam can provide a mechanism to verify a relay chain state by checking the proof against the stored storage root hash.</p> <p>Moonbeam's relay data verifier precompiled contract provides an easy way for smart contracts to programmatically build functions that rely on verifying relay chain state in contract calls. Consequently, no oracles are needed to feed relay chain data to Moonbeam. This functionality is readily available at the following contract addresses:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000819\n</code></pre> <pre><code>0x0000000000000000000000000000000000000819\n</code></pre> <pre><code>0x0000000000000000000000000000000000000819\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/utility/relay-data-verifier/#the-relay-data-verifier-solidity-interface","title":"The Relay Data Verifier Solidity Interface","text":"<p><code>RelayDataVerifier.sol</code> is a Solidity interface that allows developers to interact with the precompile's methods.</p> RelayDataVerifier.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The RelayDataVerifier contract's address.\naddress constant RELAY_DATA_VERIFIER_ADDRESS = 0x0000000000000000000000000000000000000819;\n\n/// @dev The RelayDataVerifier contract's instance.\nRelayDataVerifier constant RELAY_DATA_VERIFIER_CONTRACT = RelayDataVerifier(\n    RELAY_DATA_VERIFIER_ADDRESS\n);\n\n/// @author The Moonbeam Team\n/// @title Relay Proof Verifier Interface\n/// @dev The interface that Solidity contracts use to interact with the Relay Proof Verifier\n/// precompile.\n/// A typical workflow to verify relay chain data is the following:\n/// 1. Moonbeam RPC Call: Call `latestRelayBlockNumber` function to get the latest relay\n///    block number tracked by the chain in `pallet-storage-root`.\n/// 2. Relay RPC Call: Call `chain_getBlockHash(blockNumber)` RPC method to get the relay block hash\n///    for the block number obtained in step 1.\n/// 3. Relay RPC Call: Call `state_getReadProof(keys, at)` RPC method where `at`\n///    is the relay block hash obtained in step 2 to get the 'ReadProof` of the entries.\n/// 4. Moonbeam RPC Call: Submit an ethereum transaction (directly or through a SC) to call the\n///    `verifyEntry` or `verifyEntries` function to verify the data against the relay block\n///    number. The call data contain the relay block number obtained in step 1, and the read\n///    proof generated in step 3, along with the key/s to verify.\n/// @custom:address 0x0000000000000000000000000000000000000819\ninterface RelayDataVerifier {\n    /// @dev ReadProof struct returned by the `state_getReadProof` RPC method.\n    struct ReadProof {\n        // The block hash against which the proof is generated\n        bytes32 at;\n        /// The storage proof\n        bytes[] proof;\n    }\n\n    /// @dev Verifies a storage entry in the Relay Chain using a relay block number and a storage\n    /// proof. This function takes a relay block number, a storage proof, and the key of the storage\n    /// entry to verify. It returns the value associated with the key if the verification is\n    /// successful.\n    /// @custom:selector 27001faa\n    /// @param relayBlockNumber The relay block number against which the entry is being verified.\n    /// @param readProof The storage proof used to verify the entry.\n    /// @param key The key of the storage entry to verify.\n    /// @return value The value associated with the key, returned as a bytes array.\n    function verifyEntry(\n        uint32 relayBlockNumber,\n        ReadProof calldata readProof,\n        bytes calldata key\n    ) external returns (bytes memory value);\n\n    /// @dev Verifies a set of entries in the Relay Chain and returns the corresponding values.\n    /// This function takes a relay block number, a storage proof, and an array of keys for the\n    /// storage entries to verify. It returns an array of values associated with the keys, in the\n    /// same order as the keys.\n    /// @custom:selector 2da33a45\n    /// @param relayBlockNumber The relay block number for which the data is being verified.\n    /// @param readProof The storage proof used to verify the data.\n    /// @param keys The keys of the storage entries to verify.\n    /// @return values The values associated with the keys, returned in the same order as the keys.\n    function verifyEntries(\n        uint32 relayBlockNumber,\n        ReadProof calldata readProof,\n        bytes[] calldata keys\n    ) external returns (bytes[] memory values);\n\n    /// @dev Returns the latest relay block number that has a storage root stored on-chain.\n    /// @custom:selector aed36869\n    /// @return relayBlockNumber the lastest relay block number\n    function latestRelayBlockNumber()\n        external\n        view\n        returns (uint32 relayBlockNumber);\n}\n</code></pre> <p>The interface includes the following functions:</p> latestRelayBlockNumber() \u2014 retrieves the most recent relay chain block that has its storage root stored on the blockchain itself ParametersReturns <p>None</p> <p>The latest relay block number that has a storage root stored on-chain.</p> verifyEntry(uint32 relayBlockNumber, ReadProof calldata readProof, bytes callData key) \u2014 verifies a storage entry in the relay chain using a relay block number, a storage proof, and the storage key. It returns the value associated with the key if the verification is successful ParametersReturns <ul> <li><code>relayBlockNumber</code> - the relay block number for which the data is being verified. The latest relay block number can be obtained from the <code>latestRelayBlockNumber()</code> function</li> <li><code>readProof</code> - a struct defined in the precompile contract, containing the storage proof used to verify the data. The <code>ReadProof</code> struct is defined as:   <pre><code>struct ReadProof {\n    // The block hash against which the proof is generated\n    bytes32 at;\n    /// The storage proof\n    bytes[] proof;\n}\n</code></pre></li> <li><code>key</code> - the storage key for the generated proof</li> </ul> <p>When performing a static call on the <code>verifyEntry</code> function, you can view the returned value associated with the key in hexadecimal format.</p> <pre><code>'0x01000000040000000100000000000000f88ce384dca20000000000000000000000370589030a0000000000000000000000203d88792d0000000000000000000000000000000000000000000000000080'\n</code></pre> verifyEntries(uint32 relayBlockNumber, ReadProof calldata readProof, bytes[] callData keys) \u2014 verifies a set of entries in the relay chain and returns the corresponding values. This function takes a relay block number, a storage proof, and an array of storage keys to verify. It returns an array of values associated with the keys, in the same order as the keys ParametersReturns <ul> <li><code>relayBlockNumber</code> - the relay block number for which the data is being verified. The latest relay block number can be obtained from the <code>latestRelayBlockNumber()</code> function</li> <li><code>readProof</code> - a struct defined in the precompile contract, containing the storage proof used to verify the data. The <code>ReadProof</code> struct is defined as: <pre><code>struct ReadProof {\n    // The block hash against which the proof is generated\n    bytes32 at;\n    /// The storage proof\n    bytes[] proof;\n}\n</code></pre></li> <li><code>keys</code> - the storage keys for the generated proof</li> </ul> <p>When performing a static call on the <code>verifyEntries</code> function, you can view an array containing the corresponding values mapped to their respective keys, represented in hexadecimal format.</p> <pre><code>['0x01000000040000000100000000000000f88ce384dca20000000000000000000000370589030a0000000000000000000000203d88792d0000000000000000000000000000000000000000000000000080']\n</code></pre>"},{"location":"builders/ethereum/precompiles/utility/relay-data-verifier/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":"<p>A typical workflow to verify relay chain data involves the following steps:</p> <ol> <li>Moonbeam RPC call - call the <code>latestRelayBlockNumber</code> function to get the latest relay block number tracked by the chain in the <code>pallet-storage-root</code></li> <li>Relay RPC call - call the <code>chain_getBlockHash(blockNumber)</code> RPC method to get the relay block hash for the block number obtained in step one</li> <li>Relay RPC call - call the <code>state_getReadProof(keys, at)</code> RPC method to retrieve the storage proof, where <code>at</code> is the relay block hash obtained in step two, and <code>keys</code> is an array of strings which contains the keys for target storage items. For <code>@polkadot/api</code>, it can be obtained via <code>api.query.module.key()</code> function</li> <li>Moonbeam RPC call - submit an Ethereum transaction to call the <code>verifyEntry</code> or <code>verifyEntries</code> function to verify the data against the relay block number. The call data should contain the relay block number obtained in step one, the read proof generated in step three, and the key(s) to verify</li> </ol> <p>The following sections will cover how to interact with the Relay Data Verifier Precompile using Ethereum libraries, such as Ethers.js, Web3.js, and Web3.py. The examples in this guide will be on Moonbase Alpha.</p>"},{"location":"builders/ethereum/precompiles/utility/relay-data-verifier/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>Create or have an account on Moonbase Alpha to test out the different features in the precompile</li> <li>The account will need to be funded with <code>DEV</code> tokens.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/utility/relay-data-verifier/#using-ethereum-libraries","title":"Using Ethereum Libraries","text":"<p>To interact with the Solidity interface using an Ethereum library, you'll need the precompile's ABI (Application Binary Interface). The ABI for the Relay Chain Data Verifier Precompile is as follows:</p> Relay Data Verifier Precompile ABI <pre><code>[\n  {\n    inputs: [],\n    name: 'latestRelayBlockNumber',\n    outputs: [\n      {\n        internalType: 'uint32',\n        name: 'relayBlockNumber',\n        type: 'uint32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint32',\n        name: 'relayBlockNumber',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'bytes32',\n            name: 'at',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'proof',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct RelayDataVerifier.ReadProof',\n        name: 'readProof',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes[]',\n        name: 'keys',\n        type: 'bytes[]',\n      },\n    ],\n    name: 'verifyEntries',\n    outputs: [\n      {\n        internalType: 'bytes[]',\n        name: 'values',\n        type: 'bytes[]',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint32',\n        name: 'relayBlockNumber',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'bytes32',\n            name: 'at',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'proof',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct RelayDataVerifier.ReadProof',\n        name: 'readProof',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'key',\n        type: 'bytes',\n      },\n    ],\n    name: 'verifyEntry',\n    outputs: [\n      {\n        internalType: 'bytes',\n        name: 'value',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> <p>Once you have the ABI, you can interact with the precompile using the Ethereum library of your choice, such as Ethers.js, Web3.js, or Web3.py. The general steps are as follows:</p> <ol> <li>Create a provider</li> <li>Create a contract instance of the precompile</li> <li>Interact with the precompile's functions</li> </ol> <p>The provided code example demonstrates how to use the Ethers.js library to interact with the Moonbase Alpha network and its relay chain, verifying a data entry using the <code>verifyEntry</code> function.</p> <p>Note</p> <p>The code snippets presented in the following sections are not meant for production environments. Please make sure you adapt it for each use case.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>// For reading local ABI file\nimport * as fs from 'fs';\n// Import Ethers library, to interact with Moonbeam networks\nimport { ethers } from 'ethers';\n// Import Polkadot library, to interact with relay chain\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst abi = JSON.parse(fs.readFileSync('./RelayChainDataVerifierABI.json'));\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst precompileAddress = '0x0000000000000000000000000000000000000819';\nconst moonbeamURL = 'https://rpc.api.moonbase.moonbeam.network';\nconst relayURL = 'wss://relay.api.moonbase.moonbeam.network';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(moonbeamURL);\nconst signer = new ethers.Wallet(privateKey, provider);\nconst precompileContract = new ethers.Contract(precompileAddress, abi, signer);\n\nasync function run() {\n  // Create provider for relay chain\n  const wsProvider = new WsProvider(relayURL);\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Get the storage key for a random account on relay chain\n  const key = api.query.system.account.key(\n    '5CBATpb3yvEM4mhX9Dw3tyuqiWKhq9YBG6ugSbodRUSbodoU'\n  );\n  // Find the latest available relay chain block number from Moonbeam\n  const blockNum = await precompileContract.latestRelayBlockNumber();\n\n  // Get the block hash and storage proof from relay chain\n  const blockHash = await api.rpc.chain.getBlockHash(blockNum);\n  const proof = await api.rpc.state.getReadProof([key], blockHash);\n\n  // This tx will be rejected if the verification failed\n  const receipt = await precompileContract.verifyEntry(blockNum, proof, key);\n  await receipt.wait();\n  console.log(receipt.hash);\n}\n\nawait run();\n</code></pre> <pre><code>// For reading local ABI file\nimport * as fs from 'fs';\n// Import web3js library, to interact with Moonbeam networks\nimport { Web3 } from 'web3';\n// Import Polkadot library, to interact with relay chain\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst abi = JSON.parse(fs.readFileSync('./RelayChainDataVerifierABI.json'));\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst precompileAddress = '0x0000000000000000000000000000000000000819';\nconst moonbeamURL = 'https://rpc.api.moonbase.moonbeam.network';\nconst relayURL = 'wss://relay.api.moonbase.moonbeam.network';\n\n// Create Web3js provider and signer\nconst web3 = new Web3(moonbeamURL);\nconst precompileContract = new web3.eth.Contract(abi, precompileAddress);\n\nconst account = web3.eth.accounts.privateKeyToAccount(privateKey);\n\nasync function run() {\n  // Create provider for relay chain\n  const wsProvider = new WsProvider(relayURL);\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Get the storage key for a random account on relay chain\n  const key = api.query.system.account.key(\n    '5CBATpb3yvEM4mhX9Dw3tyuqiWKhq9YBG6ugSbodRUSbodoU'\n  );\n  // Find the latest available relay chain block number from Moonbeam\n  const blockNum = await precompileContract.methods\n    .latestRelayBlockNumber()\n    .call();\n\n  // Get the block hash and storage proof from relay chain\n  const blockHash = await api.rpc.chain.getBlockHash(blockNum);\n  const proof = await api.rpc.state.getReadProof([key], blockHash);\n\n  const callObject = {\n    to: precompileAddress,\n    data: precompileContract.methods\n      .verifyEntry(blockNum, proof, key)\n      .encodeABI(),\n    gas: await precompileContract.methods\n      .verifyEntry(blockNum, proof, key)\n      .estimateGas(),\n    gasPrice: await web3.eth.getGasPrice(),\n    nonce: await web3.eth.getTransactionCount(account.address),\n  };\n\n  // This tx will be rejected if the verification failed\n  const tx = await web3.eth.accounts.signTransaction(\n    callObject,\n    account.privateKey\n  );\n  const receipt = await web3.eth.sendSignedTransaction(tx.rawTransaction);\n  console.log(receipt.transactionHash);\n}\n\nawait run();\n</code></pre> <pre><code># Import packages\nfrom eth_account import Account\nfrom substrateinterface import SubstrateInterface\nfrom web3 import Web3\n\n# Initialize variables\nabi = INSERT_ABI\n\nprivateKey = \"INSERT_PRIVATE_KEY\"\nprecompileAddress = \"0x0000000000000000000000000000000000000819\"\nmoonbeamURL = \"https://rpc.api.moonbase.moonbeam.network\"\nrelayURL = \"wss://relay.api.moonbase.moonbeam.network\"\n\n# Create provider for Moonbeam network\nweb3 = Web3(Web3.HTTPProvider(moonbeamURL))\naccount = Account.from_key(privateKey)\nprecompileContract = web3.eth.contract(address=precompileAddress, abi=abi)\n\n# Create provider for relay chain\nsubstrate = SubstrateInterface(url=relayURL)\n\n# Get storage key\nkey = substrate.generate_storage_hash(\n    storage_module=\"System\",\n    storage_function=\"Account\",\n    params=[\"5CBATpb3yvEM4mhX9Dw3tyuqiWKhq9YBG6ugSbodRUSbodoU\"],\n)\n\n# Find the latest available relay chain block number from Moonbeam\nblockNum = precompileContract.functions.latestRelayBlockNumber().call()\n\n# Get the block hash from relay chain\nblockHash = substrate.get_block_hash(blockNum)\n\n# Get the storage proof from relay chain\nresponse = substrate.rpc_request(\"state_getReadProof\", [[key], blockHash])\nproof = response[\"result\"]\n\n# Call smart contract\ntx = precompileContract.functions.verifyEntry(blockNum, proof, key).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account.address),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account.address)\n        ),\n    }\n)\ntx_create = web3.eth.account.sign_transaction(tx, privateKey)\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n</code></pre>"},{"location":"builders/ethereum/precompiles/ux/batch/","title":"Interacting with the Batch Precompile","text":""},{"location":"builders/ethereum/precompiles/ux/batch/#introduction","title":"Introduction","text":"<p>The batch precompiled contract on Moonbeam allows developers to combine multiple EVM calls into one.</p> <p>Currently, having users interact with multiple contracts would require multiple transaction confirmations in the user's wallet. An example would be approving a smart contract's access to a token, then transferring it. With the batch precompile, developers can enhance user experience with batched transactions as it minimizes the number of transactions a user is required to confirm to one. Additionally, gas fees can be reduced since batching avoids multiple base gas fees (the initial 21000 units of gas spent to begin a transaction).</p> <p>The precompile interacts directly with Substrate's EVM pallet. The caller of the batch function will have their address act as the <code>msg.sender</code> for all subtransactions, but unlike delegate calls, the target contract will still affect its own storage. It is effectively the same as if the user signed multiple transactions, but with only one confirmation.</p> <p>The precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000808\n</code></pre> <pre><code>0x0000000000000000000000000000000000000808\n</code></pre> <pre><code>0x0000000000000000000000000000000000000808\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#the-batch-interface","title":"The Batch Solidity Interface","text":"<p><code>Batch.sol</code> is a Solidity interface that allows developers to interact with the precompile's three methods.</p> <p>The interface includes the following functions:</p> batchSome(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) - performs multiple calls, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, following subcalls will still be attempted Parameters <ul> <li><code>to</code> - address[] array of addresses to direct subtransactions to, where each entry is a subtransaction</li> <li><code>value</code> - uint256[] array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all the following subtransactions will default to a value of 0</li> <li><code>callData</code> - bytes[] array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all of the following subtransactions will include no call data</li> <li><code>gasLimit</code> - uint64[] array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the to array, all of the following subtransactions will have all remaining gas forwarded</li> </ul> batchSomeUntilFailure(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) - performs multiple calls, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, no following subcalls will be executed Parameters <ul> <li><code>to</code> - address[] array of addresses to direct subtransactions to, where each entry is a subtransaction</li> <li><code>value</code> - uint256[] array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all the following subtransactions will default to a value of 0</li> <li><code>callData</code> - bytes[] array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all of the following subtransactions will include no call data</li> <li><code>gasLimit</code> - uint64[] array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the to array, all of the following subtransactions will have all remaining gas forwarded</li> </ul> batchAll(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) - performs multiple calls atomically, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, all subcalls will revert Parameters <ul> <li><code>to</code> - address[] array of addresses to direct subtransactions to, where each entry is a subtransaction</li> <li><code>value</code> - uint256[] array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all the following subtransactions will default to a value of 0</li> <li><code>callData</code> - bytes[] array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all of the following subtransactions will include no call data</li> <li><code>gasLimit</code> - uint64[] array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the to array, all of the following subtransactions will have all remaining gas forwarded</li> </ul> <p>The interface also includes the following required events:</p> <ul> <li>SubcallSucceeded(uint256 index) - emitted when subcall of the given index succeeds</li> <li>SubcallFailed(uint256 index) - emitted when a subcall of the given index  fails</li> </ul>"},{"location":"builders/ethereum/precompiles/ux/batch/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/ethereum/precompiles/ux/batch/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>Create or have two accounts on Moonbase Alpha to test out the different features in the batch precompile</li> <li>At least one of the accounts will need to be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/ux/batch/#example-contract","title":"Example Contract","text":"<p>The contract <code>SimpleContract.sol</code> will be used as an example of batching contract interactions, but in practice, any contract can be interacted with.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.0;\n\ncontract SimpleContract {\n    mapping(uint256 =&gt; string) public messages;\n\n    function setMessage(uint256 id, string calldata message) external {\n        messages[id] = message;\n    }\n}\n</code></pre>"},{"location":"builders/ethereum/precompiles/ux/batch/#remix-set-up","title":"Remix Set Up","text":"<p>You can interact with the batch precompile using Remix. You'll need a copy of <code>Batch.sol</code> and <code>SimpleContract.sol</code>. To add the precompile to Remix and follow along with the tutorial, you will need to:</p> <ol> <li>Click on the File explorer tab</li> <li>Paste the <code>Batch.sol</code> contract into a Remix file named Batch.sol</li> <li>Paste the <code>SimpleContract.sol</code> contract into a Remix file named SimpleContract.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/ux/batch/#compile-the-contract","title":"Compile the Contract","text":"<p>Next, you will need to compile both files in Remix:</p> <ol> <li>Make sure that you have the Batch.sol file open</li> <li>Click on the Compile tab, second from top</li> <li>To compile the contract, click on Compile Batch.sol</li> </ol> <p></p> <p>If the interface was compiled successfully, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#access-the-precompile","title":"Access the Precompile","text":"<p>Instead of deploying the batch precompile, you will access the interface given the address of the precompiled contract:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note the precompiled contract is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT dropdown. Once you select Injected Provider - Metamask, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure Batch - Batch.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract, there is no need to deploy any code. Instead we are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the batch precompile: <code>0x0000000000000000000000000000000000000808</code> and click At Address</li> </ol> <p></p> <p>The BATCH precompile will appear in the list of Deployed Contracts.</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#deploy-example-contract","title":"Deploy Example Contract","text":"<p>On the other hand, <code>SimpleContract.sol</code> will be deployed as a new contract. Before starting this section, repeat the compilation step with the <code>SimpleContract.sol</code> file.</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT dropdown. Once you select Injected Provider - Metamask, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure SimpleContract - SimpleContract.sol is selected in the CONTRACT dropdown</li> <li>Click Deploy</li> <li>Confirm the MetaMask transaction that appears by clicking Confirm</li> </ol> <p></p> <p>The SIMPLECONTRACT contract will appear in the list of Deployed Contracts.</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#send-native-currency-via-precompile","title":"Send Native Currency via Precompile","text":"<p>Sending native currency with the batch precompile is more involved than pressing a few buttons in Remix or MetaMask. For this example, you will be using the batchAll function to send native currency atomically.</p> <p>Transactions have a value field to specify the amount of native currency being sent with it. In Remix, this is represented by the VALUE input in the DEPLOY &amp; RUN TRANSACTIONS tab. However, for the batch precompile, this data is provided within the value array input of the batch functions.</p> <p>Try transferring native currency to two wallets of your choice via the batch precompile on Moonbase Alpha:</p> <ol> <li>Make sure that you have at least 0.5 DEV in your connected wallet</li> <li>Expand the batch contract under Deployed Contracts</li> <li>Expand the batchAll function</li> <li>For the to input, insert your addresses in the following format: <code>[\"INSERT_ADDRESS_1\", \"INSERT_ADDRESS_2\"]</code>, where the first address corresponds to the first wallet of your choice and the second address corresponds to the second wallet of your choice</li> <li>For the value input, insert the amount you wish to transfer in Wei for each address. For example, <code>[\"100000000000000000\", \"200000000000000000\"]</code> will transfer 0.1 DEV to the first address and 0.2 DEV to the second address</li> <li>For both of the remaining callData and gasLimit inputs, insert <code>[]</code>. Call data and gas limit are not a concern for transferring native currency</li> <li>Press transact</li> <li>Press Confirm in the MetaMask extension to confirm the transaction</li> </ol> <p></p> <p>Once the transaction is complete, be sure to check both of the accounts' balances, either in MetaMask or in a block explorer. Congratulations! You've now sent a batched transfer via the batch precompile.</p> <p>Note</p> <p>Typically if you wanted to send the native currency to or through a contract, you would have to set the value within the overall transaction object and interact with a payable function. However, since the batch precompile interacts directly with Substrate code, this is not a typical Ethereum transaction and is thus not necessary.</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#find-a-contract-interactions-call-data","title":"Find a Contract Interaction's Call Data","text":"<p>Visual interfaces like Remix and handy libraries like Ethers.js hide the way that Ethereum transactions interact with Solidity smart contracts. The name and input types of a function are hashed into a function selector and the input data is encoded. These two pieces are then combined and sent as the transaction's call data. To send a subtransaction within a batch transaction, the sender needs to know its call data beforehand.</p> <p>Try finding a transaction's call data using Remix:</p> <ol> <li>Expand the <code>SimpleContract.sol</code> contract under Deployed Contracts</li> <li>Expand the setMessage function</li> <li>Enter the input of the function. For this example, id will be <code>1</code> and message will be <code>\"moonbeam\"</code></li> <li>Instead of sending the transaction, click the copy button next to the transact button to copy the call data</li> </ol> <p></p> <p>Now you have the transaction's call data! Considering the example values of <code>1</code> and <code>\"moonbeam\"</code>, we can keep an eye out for their encoded values in the call data:</p> <pre><code>0x648345c8                                                        // function selector\n0000000000000000000000000000000000000000000000000000000000000001  // 1 id\n0000000000000000000000000000000000000000000000000000000000000040  // 64 string offset\n0000000000000000000000000000000000000000000000000000000000000008  // 8 length in bytes\n6d6f6f6e6265616d000000000000000000000000000000000000000000000000  // \"moonbeam\" in bytes\n</code></pre> <p>The call data can be broken into five lines, where:</p> <ul> <li>The first line is the function selector</li> <li>The second line is equal to 1, which is the id that was provided</li> <li>What's left has to do with the message input. These last three lines are tricky, since strings are a dynamic type with a dynamic length. The third line refers to an offset to define where the string's data starts. The fourth line refers to the string's length, in this case 8 because \"moonbeam\" is 8 bytes long . Finally, the fifth line is \"moonbeam\" in hexadecimal format (8 ASCII characters are 16 hexadecimal characters) left aligned and with zeros for padding</li> </ul>"},{"location":"builders/ethereum/precompiles/ux/batch/#function-interaction-via-precompile","title":"Function Interaction via Precompile","text":"<p>This section's example will be using the batchAll function that will ensure the transactions are resolved atomically. Keep in mind that there are also two other batch functions that can either continue subtransactions despite errors or halt subsequent subtransactions but not revert previous ones.</p> <p>Interacting with a function is very similar to sending a native currency, since they are both transactions. However, call data is required to properly provide input to functions and a sender may desire to limit the amount of gas spent in each subtransaction.</p> <p>The <code>callData</code> and <code>gasLimit</code> fields are more relevant for subtransactions that interact with contracts. For each function in the batch interface, the <code>callData</code> input is an array where each index corresponds to the call data for each recipient of the subtransaction, that is, each <code>to</code> input. If the size of the <code>callData</code> array is less than the <code>to</code> array, the remaining subtransactions will have no call data (functions with no inputs). The <code>gasLimit</code> input is an array that corresponds to the amount of gas that each can spend for each subtransaction. If its value at an index is 0 or the index is the size of the array or greater (and smaller than the <code>to</code> array's size), all of the remaining gas from the previous subtransaction is forwarded.</p> <p>To use the precompile to send an atomic batch transaction, take the following steps:</p> <ol> <li>Copy the <code>SimpleContract.sol</code> contract's address with the copy button on the right side of its header. Be sure to also have the call data from the previous section</li> <li>Expand the batch contract under Deployed Contracts</li> <li>Expand the batchAll function</li> <li>For the to input, insert the address of the <code>SimpleContract.sol</code> contract that you previously copied in the following format: <code>[\"INSERT_SIMPLE_CONTRACT_ADDRESS\"]</code></li> <li>For the value input, since <code>SimpleContract.sol</code> does not require any native currency to be paid to it, insert <code>[\"0\"]</code> for 0 Wei</li> <li>For the callData input, insert your call data from the previous section in the following format: <code>[\"INSERT_CALL_DATA\"]</code></li> <li>For the gasLimit input, insert <code>[]</code>. You can put in a gas limit value, but it is optional</li> <li>Press transact</li> <li>Press Confirm in the MetaMask extension to confirm the transaction</li> </ol> <p></p> <p>If you used the same call data as the tutorial, check to make sure that the transaction has been successful:</p> <ol> <li>Expand the <code>SimpleContract.sol</code> contract under Deployed Contracts</li> <li>To the right of the messages button, insert <code>1</code></li> <li>Press the blue messages button</li> </ol> <p></p> <p>The phrase \"moonbeam\" should appear underneath it. Congratulations! You have interacted with a function with the batch precompile.</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#combining-subtransactions","title":"Combining Subtransactions","text":"<p>So far, transferring native currency and interacting with functions have been separate, but they can be intertwined.</p> <p>The following four strings can be combined as inputs for a batch transaction. They will transact 1 DEV to the public Gerald (<code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code>) account, and interact with a predeployed <code>SimpleContract.sol</code> contract twice. Here is a break-down:</p> <p>There are three subtransactions, so there are three addresses in the <code>to</code> input array. The first is the public Gerald account, the next two are a predeployed <code>SimpleContract.sol</code> contract. You can replace the last two with your own instance of <code>SimpleContract.sol</code> if you wish. Or, replace only one: you can interact with multiple contracts in a single message.</p> <pre><code>[\n  \"0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b\",\n  \"0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39\", \n  \"0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39\"\n]\n</code></pre> <p>There will also be three values for the <code>value</code> array. The first address in the <code>to</code> input array has to do with sending 1 DEV, so 1 DEV in Wei is within the array. The following two values are 0 because the function that their subtransactions are interacting with do not accept or require native currency.  </p> <pre><code>[\"1000000000000000000\", \"0\", \"0\"]\n</code></pre> <p>You will need three values for the <code>callData</code> array. Since transferring native currency does not require call data, the string is simply blank. The second and third values in the array correspond to invocations of setMessage that set messages to ids 5 and 6.</p> <pre><code>[\n  \"0x\", \n  \"0x648345c8000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000009796f752061726520610000000000000000000000000000000000000000000000\", \n  \"0x648345c800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000e61206d6f6f6e6265616d2070726f000000000000000000000000000000000000\"\n]\n</code></pre> <p>The final input is for <code>gas_input</code>. This array will be left empty to forward all remaining gas to each subtransaction.</p> <pre><code>[]\n</code></pre> <p>Try sending a batched transaction with these inputs in Remix the same way you batched a function call.</p> <p>And that's it! You've successfully interacted with the ERC-20 precompile using MetaMask and Remix!</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#ethereum-development-libraries","title":"Ethereum Development Libraries","text":"<p>If you have followed the Ethers.js tutorial on Moonbeam, you may find it difficult to find the call data for a function. The answer is hidden within Ether's <code>Interface</code> object, where the encodeFunctionData function allows you to input your function name and inputs to receive the resultant call data. Web3.js has a similar function, encodeFunctionCall.</p> <p>Note</p> <p>The code snippets presented in the following sections are not meant for production environments. Please make sure you adapt it for each use-case.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>// Import the contract ABI\nconst { abi } = require('./INSERT_ABI_PATH');\n\n// Use ABI to create an interface\nconst yourContractInterface = new ethers.Interface(abi);\n\n// Find call data for the setMessage function\nconst callData = yourContractInterface.encodeFunctionData(\n  'INSERT_FUNCTION_NAME',\n  [\n    'INSERT_INPUT_1',\n    'INSERT_INPUT_2',\n    // ...\n  ]\n);\n</code></pre> <pre><code>// Import the contract ABI\nconst { abi } = require('./INSERT_ABI_PATH');\n\n// Find call data for the setMessage function\nconst callData = web3.eth.abi.encodeFunctionCall(abi, [\n  'INSERT_INPUT_1',\n  'INSERT_INPUT_2',\n  // ...\n]);\n</code></pre> <pre><code># Import the ABI and bytecode\nfrom compile import abi, bytecode\n\n# Create contract instance\nyour_contract = web3.eth.contract(abi=abi, bytecode=bytecode)\n\n# Encode the contract call\ncall_data = your_contract.encodeABI(\n    fn_name=\"INSERT_FUNCTION_NAME\", args=[\"INSERT_INPUT_1\", \"INSERT_INPUT_2\", ...]\n)\n</code></pre> <p>Afterwards, you should be all set to interact with the batch precompile as one typically would with a contract in Ethers.</p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/","title":"Interacting with the Call Permit Precompile","text":""},{"location":"builders/ethereum/precompiles/ux/call-permit/#introduction","title":"Introduction","text":"<p>The Call Permit Precompile on Moonbeam allows a user to sign a permit, an EIP-712 signed message, for any EVM call and it can be dispatched by anyone or any smart contract. It is similar to the ERC-20 Permit Solidity Interface, except it applies to any EVM call instead of approvals only.</p> <p>When the call permit is dispatched, it is done so on behalf of the user who signed the permit and the user or contract that dispatches the permit is responsible for paying transaction fees. As such, the precompile can be used to perform gas-less transactions.</p> <p>For example, Alice signs a call permit and Bob dispatches it and performs the call on behalf of Alice. Bob pays for the transaction fees and as such, Alice doesn't need to have any of the native currency to pay for the transaction, unless the call includes a transfer.</p> <p>The Call Permit Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x000000000000000000000000000000000000080a\n</code></pre> <pre><code>0x000000000000000000000000000000000000080a\n</code></pre> <pre><code>0x000000000000000000000000000000000000080a\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#the-call-permit-interface","title":"The Call Permit Solidity Interface","text":"<p><code>CallPermit.sol</code> is a Solidity interface that allows developers to interact with the precompile's three methods.</p> <p>The interface includes the following functions:</p> dispatch(address from, address to, uint256 value, bytes data, uint64[] gaslimit, uint256 deadline, uint8 v, bytes32 r, bytes32 s) - dispatches a call on the behalf of another user with a EIP-712 permit. This function can be called by anyone or any smart contract. The transaction will revert if the permit is not valid or if the dispatched call reverts or errors (such as out of gas). If successful, the nonce of the signer is increased to prevent this permit to be replayed Parameters <ul> <li><code>from</code> - address of the signer of the permit. The call will be dispatched on behalf of this address</li> <li><code>to</code> - address the call is made to</li> <li><code>value</code> - uint256 value being transferred from the <code>from</code> account</li> <li><code>data</code> - bytes containing the call data, or action to be executed</li> <li><code>gasLimit</code> - uint64[] gas limit the dispatched call requires. Providing an argument for this parameter prevents the dispatcher from manipulating the gas limit</li> <li><code>deadline</code> - uint256 time in UNIX seconds after which the permit will no longer be valid. In JavaScript, you can get the current time in UNIX seconds by running <code>console.log(Math.floor(Date.now() / 1000))</code> in a JavaScript script or a browser console</li> <li><code>v</code> - uint8 recovery ID of the signature. The last one byte of the concatenated signature</li> <li><code>r</code> - bytes32 first 32 bytes of the concatenated signature</li> <li><code>s</code> - bytes32 second 32 bytes of the concatenated signature</li> </ul> nonces(address owner) - returns the current nonce for given owner Parameters <ul> <li><code>owner</code> - address of the account to query the nonce for</li> </ul> DOMAIN_SEPARATOR() - returns the EIP-712 domain separator which is used to avoid replay attacks. It follows the EIP-2612 implementation Parameters <p>None.</p> <p>The domain separator is defined in the EIP-712 standard and is calculated as:</p> <pre><code>keccak256(PERMIT_DOMAIN, name, version, chain_id, address)\n</code></pre> <p>The parameters of the hash can be broken down as follows:</p> <ul> <li>PERMIT_DOMAIN - is the <code>keccak256</code> of <code>EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)</code></li> <li>name - is the name of the signing domain and must be <code>'Call Permit Precompile'</code> exactly</li> <li>version - is the version of the signing domain. For this case version is set to <code>1</code></li> <li>chainId - is the chain ID of the network</li> <li>verifyingContract - is the address of the contract that will verify the signature. In this case, the Call Permit Precompile address</li> </ul> <p>When <code>dispatch</code> is called, the permit needs to be verified before the call is dispatched. The first step is to compute the domain separator. The calculation can be seen in Moonbeam's implementation or you can check out a practical example in OpenZeppelin's EIP712 contract.</p> <p>From there, a hash of the signature and the given arguments is generated which guarantees that the signature can only be used for the call permit. It uses a given nonce to ensure the signature is not subject to a replay attack. It is similar to OpenZeppelin's <code>ERC20Permit</code> contract, except the <code>PERMIT_TYPEHASH</code> is for a call permit, and the arguments match that of the dispatch function plus the nonce.</p> <p>The domain separator and the hash struct can be used to build the final hash of the fully encoded message. A practical example is shown in OpenZeppelin's EIP712 contract.</p> <p>With the final hash and the v, r, and s values, the signature can be verified and recovered. If successfully verified, the nonce will increase by one and the call will be dispatched.</p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#setup-the-example-contract","title":"Setup the Contracts","text":"<p>For this example, you'll learn how to sign a call permit that updates a message in a simple example contract, <code>SetMessage.sol</code>. Before you can generate the call permit signature, you'll need to deploy the contract and define the <code>dispatch</code> function arguments for the call permit.</p> <p>Once you've setup the example contract, then you can setup the Call Permit Precompile contract.</p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>Create or have two accounts on Moonbase Alpha to test out the different features in the Call Permit Precompile</li> <li>At least one of the accounts will need to be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#example-contract","title":"Example Contract","text":"<p>The <code>SetMessage.sol</code> contract will be used as an example of using a call permit, but in practice, any contract can be interacted with.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.7;\n\ncontract SetMessage {\n    string storedMessage;\n\n    function set(string calldata x) public {\n        storedMessage = x;\n    }\n\n    function get() public view returns (string memory) {\n        return storedMessage;\n    }\n}\n</code></pre>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#remix-set-up","title":"Remix Set Up","text":"<p>You can use Remix to compile the example contract and deploy it. You'll need a copy of <code>SetMessage.sol</code> and <code>CallPermit.sol</code>. To add the contracts to Remix, you can take the following steps:</p> <ol> <li>Click on the File explorer tab</li> <li>Paste the <code>SetMessage.sol</code> contract into a Remix file named <code>SetMessage.sol</code></li> <li>Paste the <code>CallPermit.sol</code> contract into a Remix file named <code>CallPermit.sol</code></li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#compile-deploy-example-contract","title":"Compile &amp; Deploy the Example Contract","text":"<p>First you'll need to compile the example contract:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile SetMessage.sol</li> </ol> <p></p> <p>Then you can deploy it:</p> <ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure SetMessage.sol is selected in the CONTRACT dropdown</li> <li>Click Deploy</li> <li>MetaMask will pop up and you'll need to Confirm the transaction</li> </ol> <p></p> <p>The contract will appear under the list of Deployed Contracts on the left side panel. Copy the contract address as you will need to use it to generate the call permit signature in the next section.</p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#compile-access-call-permit","title":"Compile &amp; Access the Call Permit Precompile","text":"<p>First you'll need to compile the Call Permit Precompile contract:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile CallPermit.sol</li> </ol> <p></p> <p>Then instead of deploying the contract, you'll just need to access it given the address of the precompile:</p> <ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure CallPermit.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the Call Permit Precompile for Moonbase Alpha: <code>0x000000000000000000000000000000000000080a</code> and click At Address</li> <li>The Call Permit Precompile will appear in the list of Deployed Contracts</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#generate-call-permit-signature","title":"Generate Call Permit Signature","text":"<p>In order to interact with the Call Permit Precompile, you have to have or generate a signature to dispatch the call permit with. There are several ways you can generate the signature, this guide will show you two different ways to generate it: in the browser using the MetaMask extension and JSFiddle and using MetaMask's <code>@metamask/eth-sig-util</code> npm package.</p> <p>Regardless of which method you choose to generate the signature, the following steps will be taken:</p> <ol> <li>The <code>message</code> will be created and includes some of the data that is needed to create the call permit. It includes the arguments that will be passed into the <code>dispatch</code> function and the nonce of the signer</li> <li>A JSON structure of the data the user needs to sign will be assembled for the call permit and include all of the types for the <code>dispatch</code> arguments and the nonce. This will result in the <code>CallPermit</code> type and will be saved as the <code>primaryType</code></li> <li>The domain separator will be created using <code>\"Call Permit Precompile\"</code> exactly for the name, the version of your DApp or platform, the chain ID of the network the signature is to be used on, and the address of the contract that will verify the signature</li> <li>All of the assembled data, the <code>types</code>, <code>domain</code>, <code>primaryType</code> and <code>message</code>, will be signed using MetaMask (either in the browser or through the MetaMask's JavaScript signing library)</li> <li>The signature will be returned and you can use Ethers.js <code>Signature.from</code> method to return the <code>v</code>, <code>r</code>, and <code>s</code> values of the signature</li> </ol>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#call-permit-arguments","title":"The Call Permit Arguments","text":"<p>As seen in the Call Permit Interface section, the <code>dispatch</code> function takes the following parameters: <code>from</code>, <code>to</code>, <code>value</code>, <code>data</code>, <code>gasLimit</code>, <code>deadline</code>, <code>v</code>, <code>r</code>, and <code>s</code>.</p> <p>In order to get the signature arguments (<code>v</code>, <code>r</code>, and <code>s</code>), you'll need to sign a message containing the arguments for the remainder of the aforementioned parameters, plus the nonce of the signer.</p> <ul> <li><code>from</code> - the address of the account you want to sign the call permit with</li> <li><code>to</code> - the contract address for the <code>SetMessage.sol</code> contract</li> <li><code>value</code> - can be <code>0</code> for this example as you'll just be setting a message instead of transferring any funds</li> <li><code>data</code> - you can send any message you would like, you'll just need the hex representation of the message you want to set using the <code>SetMessage.sol</code> contract. This will contain the function selector of the <code>set</code> function and the string of the message. For this example, you can send <code>hello world</code>. To do so, you can use this hex representation:      <pre><code>0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000\n</code></pre></li> <li><code>gasLimit</code> - <code>100000</code> will be enough to send the dispatched call</li> <li><code>deadline</code> - you can get the current time in UNIX seconds by running <code>console.log(Math.floor(Date.now() / 1000))</code> in a JavaScript script or a browser console. Once you have the current time, you can add additional time in seconds to represent when the call permit will expire</li> </ul> <p>The nonce of the signer will also be needed. If this is your first time signing a call permit the nonce will be <code>0</code>. You can also check the nonce in Remix:</p> <ol> <li>Expand the call permit contract</li> <li>Next to the nonces function, enter the address of the signer and click on nonces</li> <li>The result will be returned directly under the function</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#use-the-browser","title":"Use the Browser","text":"<p>To get started, you can open JSFiddle or another JavaScript playground in the browser. First, you'll need to add Ethers.js as it will be used to get the <code>v</code>, <code>r</code>, and <code>s</code> values of the signature:</p> <ol> <li>Click on Resources</li> <li>Start to type in <code>ethers</code> and the dropdown should populate matching libraries. Choose ethers</li> <li>Click on the + button</li> </ol> <p>The CDN for Ethers.js will appear in the list of libraries under Resources.</p> <p></p> <p>In the Javascript code box, copy and paste the following JavaScript snippet, making sure to replace the <code>to</code> variables (and any other variables as you see fit):</p> <pre><code>const main = async () =&gt; {\n  await window.ethereum.enable();\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts',\n  });\n\n  const from = accounts[0];\n  const to = 'INSERT_TO_ADDRESS';\n  const value = 0;\n  const data =\n    '0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000';\n  const gaslimit = 100000;\n  const nonce = 'INSERT_SIGNERS_NONCE';\n  const deadline = 'INSERT_DEADLINE';\n\n  const createPermitMessageData = function () {\n    const message = {\n      from: from,\n      to: to,\n      value: value,\n      data: data,\n      gaslimit: gaslimit,\n      nonce: nonce,\n      deadline: deadline,\n    };\n\n    const typedData = JSON.stringify({\n      types: {\n        EIP712Domain: [\n          {\n            name: 'name',\n            type: 'string',\n          },\n          {\n            name: 'version',\n            type: 'string',\n          },\n          {\n            name: 'chainId',\n            type: 'uint256',\n          },\n          {\n            name: 'verifyingContract',\n            type: 'address',\n          },\n        ],\n        CallPermit: [\n          {\n            name: 'from',\n            type: 'address',\n          },\n          {\n            name: 'to',\n            type: 'address',\n          },\n          {\n            name: 'value',\n            type: 'uint256',\n          },\n          {\n            name: 'data',\n            type: 'bytes',\n          },\n          {\n            name: 'gaslimit',\n            type: 'uint64',\n          },\n          {\n            name: 'nonce',\n            type: 'uint256',\n          },\n          {\n            name: 'deadline',\n            type: 'uint256',\n          },\n        ],\n      },\n      primaryType: 'CallPermit',\n      domain: {\n        name: 'Call Permit Precompile',\n        version: '1',\n        chainId: 1287,\n        verifyingContract: '0x000000000000000000000000000000000000080a',\n      },\n      message: message,\n    });\n\n    return {\n      typedData,\n      message,\n    };\n  };\n\n  const method = 'eth_signTypedData_v4';\n  const messageData = createPermitMessageData();\n  const params = [from, messageData.typedData];\n\n  web3.currentProvider.sendAsync(\n    {\n      method,\n      params,\n      from,\n    },\n    function (err, result) {\n      if (err) return console.dir(err);\n      if (result.error) {\n        alert(result.error.message);\n        return console.error('ERROR', result);\n      }\n      console.log('Signature:' + JSON.stringify(result.result));\n\n      const ethersSignature = ethers.Signature.from(result.result);\n      const formattedSignature = {\n        r: ethersSignature.r,\n        s: ethersSignature.s,\n        v: ethersSignature.v,\n      };\n      console.log(formattedSignature);\n    }\n  );\n};\n\nmain();\n</code></pre> <p>To run the code, click Run at the top of the page (or you can also use <code>control</code> and <code>s</code>). MetaMask should pop up and prompt you to connect an account. Make sure to choose the account you want to sign the message with. Then go ahead and sign the message.</p> <p></p> <p>Once you've signed the message, go back to JSFiddle and if the console isn't already open, go ahead and open it to see the signature values include the <code>v</code>, <code>r</code>, and <code>s</code>, values. Copy these values as you'll need them when interacting with the Call Permit Precompile in the following sections.</p> <p></p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#use-metamasks-signing-library","title":"Use MetaMask's JS Signing Library","text":"<p>To generate the call permit signature using JavaScript and MetaMask's <code>@metamask/eth-sig-util</code> npm package, you'll first need to create a project locally. You can do so with the following commands:</p> <pre><code>mkdir call-permit-example &amp;&amp; cd call-permit-example &amp;&amp; touch getSignature.js\nnpm init -y\n</code></pre> <p>You should now have a file where you can create the script to get the signature along with a <code>package.json</code> file. Open the <code>package.json</code> file, and below the <code>\"dependencies\"</code> section, add:</p> <pre><code>\"type\": \"module\"\n</code></pre> <p>Next, you can install the MetaMask signing library and Ethers.js:</p> <pre><code>npm i @metamask/eth-sig-util ethers\n</code></pre> <p>Note</p> <p>Never reveal your private keys as they give direct access to your funds. The following steps are for demonstration purposes only.</p> <p>In the <code>getSignature.js</code> file, you can copy the following code snippet:</p> <pre><code>import { ethers } from 'ethers';\nimport { signTypedData, SignTypedDataVersion } from '@metamask/eth-sig-util';\n\nconst from = 'INSERT_FROM_ADDRESS';\nconst to = 'INSERT_TO_ADDRESS';\nconst value = 0;\nconst data =\n  '0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000';\nconst gaslimit = 100000;\nconst nonce = 'INSERT_SIGNERS_NONCE';\nconst deadline = 'INSERT_DEADLINE';\n\nconst createPermitMessageData = () =&gt; {\n  const message = {\n    from: from,\n    to: to,\n    value: value,\n    data: data,\n    gaslimit: gaslimit,\n    nonce: nonce,\n    deadline: deadline,\n  };\n\n  const typedData = {\n    types: {\n      EIP712Domain: [\n        { name: 'name', type: 'string' },\n        { name: 'version', type: 'string' },\n        { name: 'chainId', type: 'uint256' },\n        { name: 'verifyingContract', type: 'address' },\n      ],\n      CallPermit: [\n        { name: 'from', type: 'address' },\n        { name: 'to', type: 'address' },\n        { name: 'value', type: 'uint256' },\n        { name: 'data', type: 'bytes' },\n        { name: 'gaslimit', type: 'uint64' },\n        { name: 'nonce', type: 'uint256' },\n        { name: 'deadline', type: 'uint256' },\n      ],\n    },\n    primaryType: 'CallPermit',\n    domain: {\n      name: 'Call Permit Precompile',\n      version: '1',\n      chainId: 1287,\n      verifyingContract: '0x000000000000000000000000000000000000080a',\n    },\n    message: message,\n  };\n\n  return {\n    typedData,\n    message,\n  };\n};\n\nconst messageData = createPermitMessageData();\n\n// For demo purposes only. Never store your private key in a JavaScript/TypeScript file\nconst signature = signTypedData({\n  privateKey: Buffer.from('INSERT_FROM_ACCOUNT_PRIVATE_KEY', 'hex'),\n  data: messageData.typedData,\n  version: SignTypedDataVersion.V4,\n});\n\nconsole.log(`Transaction successful with hash: ${signature}`);\n\nconst ethersSignature = ethers.Signature.from(signature);\nconst formattedSignature = {\n  r: ethersSignature.r,\n  s: ethersSignature.s,\n  v: ethersSignature.v,\n};\nconsole.log(formattedSignature);\n</code></pre> <p>To run the script, use the following command:</p> <pre><code>node getSignature.js\n</code></pre> <p>In the console, you should see the concatenated signature along with the values for the signature including the <code>v</code>, <code>r</code>, and <code>s</code> values. Copy these values as you'll need them when interacting with the Call Permit Precompile in the following sections.</p> node getSignature.js Transaction successful with hash: 0x76c23a766ad2135095e56a5d799794a6a9f84ed7a9da9759daa592d58632419948d111bdd46079013aa6a2c733c7a608fa05295b0ec5d8ab6a8bfbca01b3bd291c {   r: \"0x76c23a766ad2135095e56a5d799794a6a9f84ed7a9da9759daa592d586324199\",   s: \"0x48d111bdd46079013aa6a2c733c7a608fa05295b0ec5d8ab6a8bfbca01b3bd29\",   _vs: \"0xc8d111bdd46079013aa6a2c733c7a608fa05295b0ec5d8ab6a8bfbca01b3bd29\",   recoveryParam: 1,   v: 28,   yParityAndS: \"0xc8d111bdd46079013aa6a2c733c7a608fa05295b0ec5d8ab6a8bfbca01b3bd29\",   compact: \"0x76c23a766ad2135095e56a5d799794a6a9f84ed7a9da9759daa592d586324199c8d111bdd46079013aa6a2c733c7a608fa05295b0ec5d8ab6a8bfbca01b3bd29\" }"},{"location":"builders/ethereum/precompiles/ux/call-permit/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":"<p>Now that you have generated the call permit signature you will be able to test out calling the <code>dispatch</code> function of the Call Permit Precompile.</p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#dispatch-a-call","title":"Dispatch a Call","text":"<p>When you send the <code>dispatch</code> function, you'll need the same arguments as you used to sign the call permit. To get started, go back to the Deploy and Run tab in Remix and under the Deployed Contracts section expand the call permit contract. Make sure that you're connected to the account that you want to consume the call permit and pay the transaction fees with. Then take the following steps:</p> <ol> <li>For the from field, enter the account address you used to sign the call permit with</li> <li>Copy and paste the contract address of <code>SetMessage.sol</code></li> <li>Enter <code>0</code> for the value field</li> <li>Enter the hex representation of the function selector for the <code>set</code> function and the string you want to set as the message for the <code>SetMessage.sol</code> contract. For this example, <code>hello world</code> can be used:      <pre><code>0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000\n</code></pre></li> <li>Enter <code>100000</code> for the gasLimit field</li> <li>Enter the <code>deadline</code> you used when signing the call permit</li> <li>Copy the <code>v</code> value you should have retrieved while generating the call permit signature and paste it into the v field</li> <li>Copy the <code>r</code> value you should have retrieved while generating the call permit signature and paste it into the r field</li> <li>Copy the <code>s</code> value you should have retrieved while generating the call permit signature and paste it into the s field</li> <li>Click transact to send the transaction</li> <li>MetaMask should pop-up and you can confirm the transaction</li> </ol> <p></p> <p>Once the transaction goes through, you can verify that the message was updated to <code>hello world</code>. To do so, you can:</p> <ol> <li>Expand the <code>SetMessage.sol</code> contract</li> <li>Click on get</li> <li>The result will appear below the function, and it should show <code>hello world</code></li> </ol> <p></p> <p>Congratulations! You've successfully generated a call permit signature and used it to dispatch a call on behalf of the call permit signer.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/","title":"Native Token ERC-20 Precompile","text":""},{"location":"builders/ethereum/precompiles/ux/erc20/#introduction","title":"Introduction","text":"<p>The native token ERC-20 precompiled contract on Moonbeam allows developers to interact with the native protocol token through an ERC-20 interface. Although GLMR and MOVR are not ERC-20 tokens, now you can interact with them as if they were native ERC-20s!</p> <p>One of the main benefits of this precompile is that it removes the necessity of having a wrapped representation of the protocol token as an ERC-20 smart contract, such as WETH on Ethereum. Furthermore, it prevents having multiple wrapped representations of the same protocol token. Consequently, DApps that need to interact with the protocol token via an ERC-20 interface can do so without needing a separate smart contract.</p> <p>Under the hood, the ERC-20 precompile executes specific Substrate actions related to the Substrate balances pallet, which is coded in Rust. The balances pallet provides functionality for handling the various types of balances on Moonbeam, setting the free balance, transferring balances, and more.</p> <p>This guide will show you how to interact with DEV tokens, the native protocol tokens for the Moonbase Alpha TestNet, via the ERC-20 precompile. You can also follow and adapt this guide to learn how to use GLMR or MOVR as an ERC-20 token.</p> <p>The precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000802\n</code></pre> <pre><code>0x0000000000000000000000000000000000000802\n</code></pre> <pre><code>0x0000000000000000000000000000000000000802\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#the-erc20-interface","title":"The ERC-20 Solidity Interface","text":"<p>The <code>ERC20.sol</code> interface on Moonbeam follows the EIP-20 Token Standard which is the standard API interface for tokens within smart contracts. The standard defines the required functions and events that a token contract must implement to be interoperable with different applications.</p> <p>The interface includes the following functions:</p> name() - read-only function that returns the name of the token Parameters <p>None.</p> symbol() - read-only function that returns the symbol of the token Parameters <p>None.</p> decimals() - read-only function that returns the decimals of the token Parameters <p>None.</p> totalSupply() - read-only function that returns the total number of tokens in existence Parameters <p>None.</p> balanceOf(address who) - read-only function that returns the balance of the specified address Parameters <ul> <li><code>who</code> - address of the account to query the balance of</li> </ul> allowance(address owner, address spender) - read-only function that checks and returns the amount of tokens that a spender is allowed to spend on behalf of the owner Parameters <ul> <li><code>owner</code> - address of the account that owns the tokens</li> <li><code>spender</code> - address of the account allowed to spend the tokens</li> </ul> transfer(address to, uint256 value) - transfers a given amount of tokens to a specified address and returns <code>true</code> if the transfer was successful Parameters <ul> <li><code>to</code> - address of the recipient</li> <li><code>value</code> - uint256 amount of tokens to transfer</li> </ul> approve(address spender, uint256 value) - approves the provided address to spend a specified amount of tokens on behalf of <code>msg.sender</code>. Returns <code>true</code> if successful Parameters <ul> <li><code>spender</code> - address to be approved to spend the tokens</li> <li><code>value</code> - uint256 amount of tokens to be approved for spending</li> </ul> transferFrom(address from, address to, uint256 value) - transfers tokens from one given address to another given address and returns <code>true</code> if successful Parameters <ul> <li><code>from</code> - address to transfer tokens from</li> <li><code>to</code> - address to transfer tokens to</li> <li><code>value</code> - uint256 amount of tokens to transfer</li> </ul> <p>Note</p> <p>The ERC-20 standard does not specify the implications of multiple calls to <code>approve</code>. Changing an allowance with this function numerous times enables a possible attack vector. To avoid incorrect or unintended transaction ordering, you can first reduce the <code>spender</code> allowance to <code>0</code> and then set the desired allowance afterward. For more details on the attack vector, you can check out the ERC-20 API: An Attack Vector on Approve/TransferFrom Methods overview.</p> <p>The interface also includes the following required events:</p> <ul> <li>Transfer(address indexed from, address indexed to, uint256 value) - emitted when a transfer has been performed</li> <li>Approval(address indexed owner, address indexed spender, uint256 value) - emitted when an approval has been registered</li> </ul> <p>Note</p> <p>The ERC-20 precompile does not include <code>deposit</code> and <code>withdraw</code> functions and subsequent events that are expected from a wrapped token contract, such as WETH.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/ethereum/precompiles/ux/erc20/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>Create or have two accounts on Moonbase Alpha to test out the different features in the ERC-20 precompile</li> <li>At least one of the accounts will need to be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/ux/erc20/#add-token-to-metamask","title":"Add Token to MetaMask","text":"<p>If you want to interact with Moonbase Alpha DEV tokens like you would with an ERC-20 in MetaMask, you can create a custom token using the precompile address.</p> <p>To get started, open up MetaMask and make sure you are connected to Moonbase Alpha and:</p> <ol> <li>Switch to the Assets tab</li> <li>Click on Import tokens</li> </ol> <p></p> <p>Now, you can create a custom token:</p> <ol> <li>Enter the precompile address for the token contract address - <code>0x0000000000000000000000000000000000000802</code>. As soon as you enter the address, the Token Symbol and Token Decimal fields should automatically populate. If they don't you can enter <code>DEV</code> for the symbol and <code>18</code> for the decimal places</li> <li>Click Add Custom Token</li> </ol> <p></p> <p>MetaMask will prompt you to import the tokens. You can review the token details and click Import Tokens to import DEV tokens into your wallet.</p> <p></p> <p>And that's it! You've successfully added the DEV token as a custom ERC-20 token on the Moonbase Alpha TestNet.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#remix-set-up","title":"Remix Set Up","text":"<p>You can interact with the ERC-20 precompile using Remix. To add the precompile to Remix, you will need to:</p> <ol> <li>Get a copy of <code>ERC20.sol</code></li> <li>Paste the file contents into a Remix file named <code>IERC20.sol</code></li> </ol>"},{"location":"builders/ethereum/precompiles/ux/erc20/#compile-the-contract","title":"Compile the Contract","text":"<p>Next, you will need to compile the interface in Remix:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Compile the interface by clicking on Compile IERC20.sol</li> </ol> <p></p> <p>If the interface was compiled successfully, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#access-the-contract","title":"Access the Contract","text":"<p>Instead of deploying the ERC-20 precompile, you will access the interface given the address of the precompiled contract:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note the precompiled contract is already deployed</li> <li>Make sure Injected Web3 is selected in the ENVIRONMENT dropdown. Once you select Injected Web3, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure IERC20 - IERC20.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract, there is no need to deploy any code. Instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the ERC-20 precompile: <code>0x0000000000000000000000000000000000000802</code> and click At Address</li> </ol> <p></p> <p>The IERC20 precompile will appear in the list of Deployed Contracts.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#get-basic-token-information","title":"Get Basic Token Information","text":"<p>The ERC-20 interface allows you to quickly obtain token information, including the token's total supply, name, symbol, and decimal places. You can get this information by following these steps:</p> <ol> <li>Expand the IERC20 contract under Deployed Contracts</li> <li>Click decimals to get the decimal places of the Moonbase Alpha native protocol token</li> <li>Click name to get the name of the token</li> <li>Click symbol to get the symbol of the token</li> <li>Click totalSupply to obtain the total supply of tokens in existence on Moonbase Alpha</li> </ol> <p></p> <p>The response for each call will be displayed under the corresponding function.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#get-account-balance","title":"Get Account Balance","text":"<p>You can check the balance of any address on Moonbase Alpha by calling the <code>balanceOf</code> function and passing in an address:</p> <ol> <li>Expand the balanceOf function</li> <li>Enter an address you would like to check the balance of for the owner</li> <li>Click call</li> </ol> <p></p> <p>Your balance will be displayed under the <code>balanceOf</code> function.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#approve-a-spend","title":"Approve a Spend","text":"<p>To approve a spend, you'll need to provide an address for the spender and the number of tokens  that the spender is allowed to spend. The spender can be an externally owned account or a smart contract. For this example, you can approve the spender to spend 1 DEV token. To get started, please follow these steps:</p> <ol> <li>Expand the approve function</li> <li>Enter the address of the spender. You should have created two accounts before starting, so you can use the second account as the spender</li> <li>Enter the amount of tokens the spender can spend for the value. For this example, you can allow the spender to spend 1 DEV token in Wei units (<code>1000000000000000000</code>)</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click View full transaction details to review the amount to be sent and the address of the spender</li> <li>If everything looks ok, you can click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction has successfully gone through, you'll notice that the balance of your account hasn't changed. This is because you have only approved the spend for the given amount, and the spender hasn't spent the funds. In the next section, you will use the <code>allowance</code> function to verify that the spender is able to spend 1 DEV token on your behalf.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#get-allowance-of-spender","title":"Get Allowance of Spender","text":"<p>To check that the spender received the allowance approved in the Approve a Spend section, you can:</p> <ol> <li>Expand the allowance function</li> <li>Enter your address for the owner</li> <li>Enter the address of the spender that you used in the previous section</li> <li>Click call</li> </ol> <p></p> <p>Once the call is complete, the allowance of the spender will be displayed, which should be equivalent to 1 DEV token (<code>1000000000000000000</code>).</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#send-transfer","title":"Send Transfer","text":"<p>To do a standard transfer and send tokens from your account directly to another account, you can call the <code>transfer</code> function by following these steps:</p> <ol> <li>Expand the transfer function</li> <li>Enter the address to send DEV tokens to. You should have created two accounts before starting, so you can use the second account as the recipient</li> <li>Enter the amount of DEV tokens to send. For this example, you can send 1 DEV token (<code>1000000000000000000</code>)</li> <li>Click transact</li> <li>MetaMask will pop up, you can review the transaction details, and if everything looks good, click Confirm</li> </ol> <p></p> <p>Once the transaction is complete, you can check your balance using the <code>balanceOf</code> function or by looking at MetaMask, and notice that this time your balance decreased by 1 DEV token. You can also use the <code>balanceOf</code> function to ensure that the recipients balance has increased by 1 DEV token as expected.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#send-transferfrom","title":"Send Transfer From Specific Account","text":"<p>So far, you should have approved an allowance of 1 DEV token for the spender and sent 1 DEV token via the standard <code>transfer</code> function. The <code>transferFrom</code> function varies from the standard <code>transfer</code> function as it allows you to define the address to which you want to send the tokens. So you can specify an address that has an allowance or your address as long as you have funds. For this example, you will use the spender's account to initiate a transfer of the allowed funds from the owner to the spender. The spender can send the funds to any account, but you can send the funds from the owner to the spender for this example.</p> <p>First, you need to switch to the spender's account in MetaMask. Once you switch to the spender's account, you'll notice that the selected address in Remix under the Accounts tab is now the spender's.</p> <p></p> <p>Next, you can initiate and send the transfer, to do so:</p> <ol> <li>Expand the transferFrom function</li> <li>Enter your address as the owner in the from field</li> <li>Enter the recipient address, which should be the spender's address, in the to field</li> <li>Enter the amount of DEV tokens to send. Again, the spender is currently only allowed to send 1 DEV token, so enter <code>1000000000000000000</code></li> <li>Click transact</li> </ol> <p></p> <p>Once the transaction is complete, you can check the balance of the owner and spender using the <code>balanceOf</code> function. The spender's balance should have increased by 1 DEV token, and their allowance should now be depleted. To verify that the spender no longer has an allowance, you can call the <code>allowance</code> function, passing in the owner and spender's addresses. You should receive a result of 0.</p> <p></p> <p>And that's it! You've successfully interacted with the ERC-20 precompile using MetaMask and Remix!</p>"},{"location":"builders/ethereum/verify-contracts/api-verification/","title":"API-based Contract Verification","text":""},{"location":"builders/ethereum/verify-contracts/api-verification/#introduction","title":"Introduction","text":"<p>Verifying smart contracts greatly improves their transparency and security.  Smart contracts deployed on Moonbeam networks can be verified through API-based tools, including Moonscan API and Sourcify.</p> <p>This page will outline the steps for using these API-based tools for verifying smart contracts, or retrieving verification status and metadata of smart contracts on Moonbeam networks.</p>"},{"location":"builders/ethereum/verify-contracts/api-verification/#using-moonscan-api","title":"Using Moonscan API","text":"<p>Moonscan is an official fork of Etherscan that can be used to view and search on-chain data, and comes with a suite of developer tools and analytics to interact with data on Moonbeam networks.</p> <p>The Etherscan API provides a variety of endpoints for verifying smart contracts, retrieving verified contract ABI and source code, and interacting with verified contracts on Moonbeam networks.</p>"},{"location":"builders/ethereum/verify-contracts/api-verification/#generating-an-etherscan-api-key","title":"Generating an Etherscan API Key","text":"<p>Before using the Moonscan API, you need to generate an Etherscan API key. Please follow the instructions in the key generation section of the Etherscan plug-in verification page, as the API keys generated are used for both.</p>"},{"location":"builders/ethereum/verify-contracts/api-verification/#moonscan-public-api-url","title":"Moonscan Public API URL","text":"<p>The Moonscan API URL for Moonbeam networks is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>https://api-moonbeam.moonscan.io/api\n</code></pre> <pre><code>https://api-moonriver.moonscan.io/api\n</code></pre> <pre><code>https://api-moonbase.moonscan.io/api\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#verify-source-code","title":"Verify Source Code","text":"<p>To verify a deployed contract's source code using the Moonscan API, you must form a POST request containing all the relevant contract creation information, and send the request to Moonscan's REST API. The following is sample code using JavaScript and Axios, an HTTP client:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>// Submit Source Code for Verification\nconst response = await axios.post(\n  'https://api-moonbeam.moonscan.io/api',\n  {\n    apikey: 'INSERT_API_KEY',\n    module: 'contract',\n    action: 'verifysourcecode',\n    contractAddress: 'INSERT_CONTRACT_ADDRESS',\n    sourceCode: 'INSERT_SOURCE_CODE', // flattened if necessary\n    codeformat: 'solidity-single-file', // or you can use \"solidity-standard-json-input\"\n    contractname: 'INSERT_CONTRACT_NAME', // if codeformat = solidity-standard-json-input, then enter contractname as ex: erc20.sol:erc20\n    compilerversion: 'INSERT_COMPILER_VERSION', // see https://etherscan.io/solcversions for list of support versions\n    optimizationUsed: 0, // 0 = no optimization, 1 = optimization was used (applicable when codeformat=solidity-single-file)\n    runs: 200, // set to 200 as default unless otherwise (applicable when codeformat=solidity-single-file)\n    constructorArguments: 'INSERT_CONSTRUCTOR_ARGUMENTS', // if applicable\n    evmversion: 'INSERT_EVM_VERSION', // options: homestead, tangerineWhistle, spuriousDragon, byzantium, constantinople, petersburg, istanbul (applicable when codeformat=solidity-single-file)\n    licenseType: 1, // valid codes 1-14 where 1=No License ... 14=Business Source License 1.1, see https://etherscan.io/contract-license-types\n    libraryname1: 'INSERT_LIBRARY_NAME', // if applicable, enter the name of the first library used, i.e. SafeMath (up to 10 libraries can be used)\n    libraryaddress1: 'INSERT_LIBRARY_ADDRESS', // if applicable, enter the address of the first library used\n    libraryname2: 'INSERT_LIBRARY_NAME', // if applicable, enter the name of the second library used\n    libraryaddress2: 'INSERT_LIBRARY_ADDRESS', // if applicable, enter the address of the second library used\n    // ...\n  },\n  { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }\n);\n\nif (response.data.status == '1') {\n  // 1 = submission success, use the guid returned (response.data.result) to check the status of your submission\n  // average time of processing is 30-60 seconds\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n  // response.data.result is the GUID receipt for the submission, you can use this guid for checking the verification status\n} else {\n  // 0 = error\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n}\n</code></pre> <pre><code>// Submit Source Code for Verification\nconst response = await axios.post(\n  'https://api-moonriver.moonscan.io/api', \n  {\n    apikey: 'INSERT_API_KEY',\n    module: 'contract',\n    action: 'verifysourcecode',\n    contractAddress: 'INSERT_CONTRACT_ADDRESS',\n    sourceCode: 'INSERT_SOURCE_CODE', // flattened if necessary\n    codeformat: 'solidity-single-file', // or you can use \"solidity-standard-json-input\"\n    contractname: 'INSERT_CONTRACT_NAME', // if codeformat = solidity-standard-json-input, then enter contractname as ex: erc20.sol:erc20\n    compilerversion: 'INSERT_COMPILER_VERSION', // see https://etherscan.io/solcversions for list of support versions\n    optimizationUsed: 0, // 0 = no optimization, 1 = optimization was used (applicable when codeformat=solidity-single-file)\n    runs: 200, // set to 200 as default unless otherwise (applicable when codeformat=solidity-single-file)\n    constructorArguments: 'INSERT_CONSTRUCTOR_ARGUMENTS', // if applicable\n    evmversion: 'INSERT_EVM_VERSION', // options: homestead, tangerineWhistle, spuriousDragon, byzantium, constantinople, petersburg, istanbul (applicable when codeformat=solidity-single-file)\n    licenseType: 1, // valid codes 1-14 where 1=No License ... 14=Business Source License 1.1, see https://etherscan.io/contract-license-types\n    libraryname1: 'INSERT_LIBRARY_NAME', // if applicable, enter the name of the first library used, i.e. SafeMath (up to 10 libraries can be used)\n    libraryaddress1: 'INSERT_LIBRARY_ADDRESS', // if applicable, enter the address of the first library used\n    libraryname2: 'INSERT_LIBRARY_NAME', // if applicable, enter the name of the second library used\n    libraryaddress2: 'INSERT_LIBRARY_ADDRESS', // if applicable, enter the address of the second library used\n    // ...\n  },\n  { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }\n);\n\nif (response.data.status == '1') {\n  // 1 = submission success, use the guid returned (response.data.result) to check the status of your submission\n  // average time of processing is 30-60 seconds\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n  // response.data.result is the GUID receipt for the submission, you can use this guid for checking the verification status\n} else {\n  // 0 = error\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n}\n</code></pre> <pre><code>// Submit Source Code for Verification\nconst response = await axios.post(\n  'https://api-moonbase.moonscan.io/api', \n  {\n    apikey: 'INSERT_API_KEY',\n    module: 'contract',\n    action: 'verifysourcecode',\n    contractAddress: 'INSERT_CONTRACT_ADDRESS',\n    sourceCode: 'INSERT_SOURCE_CODE', // flattened if necessary\n    codeformat: 'solidity-single-file', // or you can use \"solidity-standard-json-input\"\n    contractname: 'INSERT_CONTRACT_NAME', // if codeformat = solidity-standard-json-input, then enter contractname as ex: erc20.sol:erc20\n    compilerversion: 'INSERT_COMPILER_VERSION', // see https://etherscan.io/solcversions for list of support versions\n    optimizationUsed: 0, // 0 = no optimization, 1 = optimization was used (applicable when codeformat=solidity-single-file)\n    runs: 200, // set to 200 as default unless otherwise (applicable when codeformat=solidity-single-file)\n    constructorArguments: 'INSERT_CONSTRUCTOR_ARGUMENTS', // if applicable\n    evmversion: 'INSERT_EVM_VERSION', // options: homestead, tangerineWhistle, spuriousDragon, byzantium, constantinople, petersburg, istanbul (applicable when codeformat=solidity-single-file)\n    licenseType: 1, // valid codes 1-14 where 1=No License ... 14=Business Source License 1.1, see https://etherscan.io/contract-license-types\n    libraryname1: 'INSERT_LIBRARY_NAME', // if applicable, enter the name of the first library used, i.e. SafeMath (up to 10 libraries can be used)\n    libraryaddress1: 'INSERT_LIBRARY_ADDRESS', // if applicable, enter the address of the first library used\n    libraryname2: 'INSERT_LIBRARY_NAME', // if applicable, enter the name of the second library used\n    libraryaddress2: 'INSERT_LIBRARY_ADDRESS', // if applicable, enter the address of the second library used\n    // ...\n  },\n  { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }\n);\n\nif (response.data.status == '1') {\n  // 1 = submission success, use the guid returned (response.data.result) to check the status of your submission\n  // average time of processing is 30-60 seconds\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n  // response.data.result is the GUID receipt for the submission, you can use this guid for checking the verification status\n} else {\n  // 0 = error\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n}\n</code></pre> <p>Upon successful submission, a GUID will be returned as a part of the result. This GUID can be used to check for the submission status.</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://api-moonbeam.moonscan.io/api\n  ?module=contract\n  &amp;action=checkverifystatus\n  &amp;guid=INSERT_GUID_FROM_RESPONSE\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonriver.moonscan.io/api\n  ?module=contract\n  &amp;action=checkverifystatus\n  &amp;guid=INSERT_GUID_FROM_RESPONSE\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonbase.moonscan.io/api\n  ?module=contract\n  &amp;action=checkverifystatus\n  &amp;guid=INSERT_GUID_FROM_RESPONSE\n  &amp;apikey=INSERT_API_KEY\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#retrieve-contract-abi-for-verified-contracts","title":"Retrieve Contract ABI for Verified Contracts","text":"<p>Once your contract is verified on Moonscan, you can use the following endpoint to retrieve the contract ABI:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://api-moonbeam.moonscan.io/api\n  ?module=contract\n  &amp;action=getabi\n  &amp;address=INSERT_CONTRACT_ADDRESS\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonriver.moonscan.io/api\n  ?module=contract\n  &amp;action=getabi\n  &amp;address=INSERT_CONTRACT_ADDRESS\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonbase.moonscan.io/api\n  ?module=contract\n  &amp;action=getabi\n  &amp;address=INSERT_CONTRACT_ADDRESS\n  &amp;apikey=INSERT_API_KEY\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#retrieve-contract-source-code-for-verified-contracts","title":"Retrieve Contract Source Code for Verified Contracts","text":"<p>Once your contract is verified on Moonscan, you can use the following endpoint to retrieve the contract source code:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://api-moonbeam.moonscan.io/api\n  ?module=contract\n  &amp;action=getsourcecode\n  &amp;address=INSERT_CONTRACT_ADDRESS\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonriver.moonscan.io/api\n  ?module=contract\n  &amp;action=getsourcecode\n  &amp;address=INSERT_CONTRACT_ADDRESS\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonbase.moonscan.io/api\n  ?module=contract\n  &amp;action=getsourcecode\n  &amp;address=INSERT_CONTRACT_ADDRESS\n  &amp;apikey=INSERT_API_KEY\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#using-sourcify-api","title":"Using Sourcify API","text":"<p>Sourcify is a multi-chain decentralized automated contract verification service, and maintains a public repository of contract metadata. Sourcify also provides a public server API for verification, and checking if a contract is verified, and a repository API for retrieving metadata files.</p>"},{"location":"builders/ethereum/verify-contracts/api-verification/#sourcify-public-server-url","title":"Sourcify Public Server URL","text":"<p>Soucify API endpoints can be accessed through the following public servers:</p> ProductionStaging <pre><code>https://sourcify.dev/server\n</code></pre> <pre><code>https://staging.sourcify.dev/server\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#moonbeam-network-chain-ids","title":"Moonbeam Network Chain ID's","text":"<p>Sourcify uses chain ID's to identify the target network(s) for the request. The chain ID's of Moonbeam networks are as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>1284\n</code></pre> <pre><code>1285\n</code></pre> <pre><code>1287\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#full-vs-partial-match","title":"Perfect vs. Partial Match","text":"<p>Sourcify supports two types of verification match results.</p> <p>Full matches (sometimes referred as perfect matches) refer to the cases when the bytecode of the deployed contract is byte-by-byte the same as compilation output of the given source code files under the compilation settings defined in the metadata file.</p> <p>Partial matches refer to cases when the deployed bytecode of the onchain contract match the bytecode resulting from the recompilation with the metadata and the source files except the metadata hash. For partial matches, the deployed contract and the given source code and metadata are functionally the same, but there are differences in source code comments, variable names, or other metadata fields such as source paths.</p>"},{"location":"builders/ethereum/verify-contracts/api-verification/#verify-contract","title":"Verify Contract","text":"<p>A POST request is used to verify a contract on Sourcify. The following is sample code using JavaScript:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>// Submit Contract Source Code and Metadata for Verification\nconst response = await axios.post('https://sourcify.dev/server/verify', {\n  address: 'INSERT_CONTRACT_ADDRESS',\n  chain: 1284, // chain ID of Moonbeam\n  files: {\n    'metadata-1.json': 'INSERT_JSON_FILE', // metadata file for contract file 1\n    'metadata-2.json': 'INSERT_JSON_FILE', // metadata file for contract file 2\n    'file1-name.sol': 'INSERT_SOL_FILE', // contract source file 1\n    'file2-name.sol': 'INSERT_SOL_FILE', // contract source file 2\n    //...\n  },\n  chosenContract: 1, // (optional) index of the contract, if the provided files contain multiple metadata files\n});\n\nif (result.status == 'perfect') {\n  // perfect match\n  console.log(result.status + ';' + result.address);\n} else if (result.status == 'partial') {\n  // partial match\n  console.log(result.status + ';' + result.address);\n} else {\n  // non-matching\n  console.log(result.status + ';' + result.address);\n}\n</code></pre> <pre><code>// Submit Contract Source Code and Metadata for Verification\nconst response = await axios.post('https://sourcify.dev/server/verify', {\n  address: 'INSERT_CONTRACT_ADDRESS',\n  chain: 1285, // chain ID of Moonriver\n  files: {\n    'metadata-1.json': 'INSERT_JSON_FILE', // metadata file for contract file 1\n    'metadata-2.json': 'INSERT_JSON_FILE', // metadata file for contract file 2\n    'file1-name.sol': 'INSERT_SOL_FILE', // contract source file 1\n    'file2-name.sol': 'INSERT_SOL_FILE', // contract source file 2\n    //...\n  },\n  chosenContract: 1, // (optional) index of the contract, if the provided files contain multiple metadata files\n});\n\nif (result.status == 'perfect') {\n  // perfect match\n  console.log(result.status + ';' + result.address);\n} else if (result.status == 'partial') {\n  // partial match\n  console.log(result.status + ';' + result.address);\n} else {\n  // non-matching\n  console.log(result.status + ';' + result.address);\n}\n</code></pre> <pre><code>// Submit Contract Source Code and Metadata for Verification\nconst response = await axios.post('https://sourcify.dev/server/verify', {\n  address: 'INSERT_CONTRACT_ADDRESS',\n  chain: 1287, // chain ID of Moonbase Alpha\n  files: {\n    'metadata-1.json': 'INSERT_JSON_FILE', // metadata file for contract file 1\n    'metadata-2.json': 'INSERT_JSON_FILE', // metadata file for contract file 2\n    'file1-name.sol': 'INSERT_SOL_FILE', // contract source file 1\n    'file2-name.sol': 'INSERT_SOL_FILE', // contract source file 2\n    //...\n  },\n  chosenContract: 1, // (optional) index of the contract, if the provided files contain multiple metadata files\n});\n\nif (result.status == 'perfect') {\n  // perfect match\n  console.log(result.status + ';' + result.address);\n} else if (result.status == 'partial') {\n  // partial match\n  console.log(result.status + ';' + result.address);\n} else {\n  // non-matching\n  console.log(result.status + ';' + result.address);\n}\n</code></pre> <p>Alternatively, you can also use the Sourcify hosted GUI to submit a contract for verification.  </p>"},{"location":"builders/ethereum/verify-contracts/api-verification/#check-verification-status-by-address-and-chain-id","title":"Check Verification Status by Address and Chain ID","text":"<p>Sourcify provides endpoints for checking the verification status of contracts on multiple EVM chains at once. This can be done through URL parameters, by specifying the contract addresses and the chain ID's of the networks.  </p> <p>There are two variations of this endpoint, one for perfect matching and one for partial matching:</p> Perfect MatchPartial Match <pre><code>curl https://sourcify.dev/server/check-by-addresses\n  ?addresses={INSERT_ADDRESS_1, INSERT_ADDRESS_2, ...}\n  &amp;chainIds={INSERT_CHAIN_ID_1, INSERT_CHAIN_ID_2, ...}\n</code></pre> <pre><code>curl https://sourcify.dev/server/check-all-by-addresses\n  ?addresses={INSERT_ADDRESS_1, INSERT_ADDRESS_2, ...}\n  &amp;chainIds={INSERT_CHAIN_ID_1, INSERT_CHAIN_ID_2, ...}\n</code></pre> <p>An example response will be a JSON object of the following structure:</p> <pre><code>[\n    {\n        \"address\": \"address1\",\n        \"status\": \"perfect\",\n        \"chainIds\": [\n            \"chainId1\",\n            \"chaindId2\"\n        ]\n    },\n    {\n        \"address\": \"address2\",\n        \"status\": \"partial\",\n        \"chainIds\": [\n            \"chaindId2\"\n        ]\n    }\n]\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#retrieve-contract-source-files-for-verified-contracts","title":"Retrieve Contract Source Files for Verified Contracts","text":"<p>You can also retrieve the source files of verified contracts from the Sourcify repository.</p> <p>There are two variations of this endpoint, one for the source files of perfect matches:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://sourcify.dev/server/files/1284/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>curl https://sourcify.dev/server/files/1285/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>curl https://sourcify.dev/server/files/1287/INSERT_CONTRACT_ADDRESS\n</code></pre> <p>And one for the source files of both perfect and partial matches:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://sourcify.dev/server/files/any/1284/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>curl https://sourcify.dev/server/files/any/1285/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>curl https://sourcify.dev/server/files/any/1287/INSERT_CONTRACT_ADDRESS\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#using-sourcify-with-foundry","title":"Using Sourcify with Foundry","text":"<p>Foundry's Forge tool has built-in support for Sourcify verification similar to how it has built-in support for Etherscan. The example in this section of the guide will use the <code>MyToken.sol</code> contract that was created in the Using Foundry to Deploy to Moonbeam guide.</p> <p>A Foundry project that uses Sourcify must have their compiler emit metadata files. This can be configured in the <code>foundry.toml</code> file:</p> <pre><code>[profile.default]\n# Input your custom or default config options here\nextra_output_files = [\"metadata\"]\n</code></pre> <p>If you have already deployed the example contract, you can verify it with the <code>verify-contract</code> command. Before you can verify the contract, you will need to ABI-encode the constructor arguments. To do so for the example contract, you can run the following command:</p> <pre><code>cast abi-encode \"constructor(uint256)\" 100\n</code></pre> <p>The result should be <code>0x0000000000000000000000000000000000000000000000000000000000000064</code>. You can then verify the contract using the following command:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>forge verify-contract --chain-id 1284 \\\n--constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\n--verifier sourcify INSERT_CONTRACT_ADDRESS src/MyToken.sol:MyToken \n</code></pre> <pre><code>forge verify-contract --chain-id 1285 \\\n--constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\n--verifier sourcify INSERT_CONTRACT_ADDRESS src/MyToken.sol:MyToken \n</code></pre> <pre><code>forge verify-contract --chain-id 1287 \\\n--constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\n--verifier sourcify INSERT_CONTRACT_ADDRESS src/MyToken.sol:MyToken \n</code></pre> forge verify-contract --chain-id 1287 \\ --constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\ --verifier sourcify 0x10DBedae73396699Ac2a4EB7A448d79348429d src/MyToken.sol:MyToken Submitting verification for [MyToken] \"0x10DBedae73396699Ac2a4EB7A448d79348429d\" \u2022 Submitting verification for [MyToken] \"0x10DBedae73396699Ac2a4EB7A448d79348429d\" \u2022 Contract source code already verified. Storage Timestamp: 2025-09-04 00:09:50.076Z <p>If you wanted to deploy the example contract and verify at the same time, then you would use the following command:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>forge create --rpc-url INSERT_RPC_API_ENDPOINT \\\n--constructor-args 100 \\\n--verify --verifier sourcify \\\n--private-key INSERT_YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken  \n</code></pre> <pre><code>forge create --rpc-url INSERT_RPC_API_ENDPOINT \\\n--constructor-args 100 \\\n--verify --verifier sourcify \\\n--private-key INSERT_YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken  \n</code></pre> <pre><code>forge create --rpc-url https://rpc.api.moonbase.moonbeam.network \\\n--constructor-args 100 \\\n--verify --verifier sourcify \\\n--private-key INSERT_YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken\n</code></pre>  forge create --rpc-url https://rpc.api.moonbase.moonbeam.network \\ --constructor-args 100 \\ --verify --verifier sourcify --private-key YOUR_PRIVATE_KEY \\ src/MyToken.sol:MyToken [:] Compiling... [:] Compiling 1 files with 0.8.14 [:] Solc 0.8.14 finished in 264.52ms Compiler run successful Deployer: 0x0394c0EdFcCA370B20622721985B577850B0eb75 Deployed to: 0x6A489374557354CE325D4F4a0Dd8F1CB98c1592 Transaction hash: 0x3ab6002497ca35971d2025b0a7d544f703de465513327d4b640886354d11f612 Starting contract verification... Waiting for etherscan to detect contract deployment... Submitting verification for [MyToken] \"0x6A489374557354CE325D4F4a0Dd8F1CB98c1592\" \u2022 Submitting verification for [MyToken] \"0x6A489374557354CE325D4F4a0Dd8F1CB98c1592\" \u2022 Contract source code already verified. Storage Timestamp: 2025-09-04 00:06:03.787Z"},{"location":"builders/ethereum/verify-contracts/block-explorers/","title":"Verify Smart Contracts using Block Explorers","text":""},{"location":"builders/ethereum/verify-contracts/block-explorers/#introduction","title":"Introduction","text":"<p>Verifying smart contracts on a block explorer is a great way to improve the transparency and security of deployed smart contracts on Moonbeam. Users can directly view the source code for verified smart contracts, and for some block explorers, they can also directly interact with the contract's public methods through the block explorer's interface.</p> <p>This page will outline the steps for verifying smart contracts on Moonbeam networks through block explorers.</p>"},{"location":"builders/ethereum/verify-contracts/block-explorers/#deploying-the-contract","title":"Deploying the Contract","text":"<p>In order to verify a smart contract on a block explorer, the contract must first be deployed on the target network. This tutorial will be about deploying the smart contract to Moonbase Alpha, but it can be adapted for Moonbeam or Moonriver.</p> <p>You can check out this page for a tutorial on deploying smart contracts using Ethereum libraries on Moonbeam. You may also use a developer tool such as Remix, Hardhat, or another tool if preferred, to deploy the smart contract to Moonbeam.</p> <p>This tutorial will use the same contract as the above deployment tutorial for the contract verification example.</p> <p>The contract used is a simple incrementer, arbitrarily named <code>Incrementer.sol</code>. The Solidity code is the following:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/block-explorers/#collecting-information-for-contract-verification","title":"Collecting Information for Contract Verification","text":"<p>You will need to collect some information related to the contract's compiler and deployment in order to verify it successfully.</p> <ol> <li>Take note of the Solidity compiler version used to compile and deploy the contract. The Solidity compiler version can usually be selected or specified in the deployment tool used</li> <li> <p>Take note of any SPDX license identifier used at the beginning of the Solidity source file (this example uses an MIT license):</p> <pre><code>// SPDX-License-Identifier: MIT\n</code></pre> </li> <li> <p>(Optional) If optimization is enabled during compilation, take note of the value of the optimization runs parameter</p> </li> <li>(Optional) If the contract constructor method accepts arguments, take note of the ABI-encoded form of the constructor arguments</li> <li>After deployment, take note of the deployed contract address of the smart contract. The deployment address of the contract can be found either in the console output if using a command-line-based tool such as Hardhat, or an Ethereum library, or it can be copied from the GUI in tools such as Remix IDE</li> </ol> <p></p> <p></p>"},{"location":"builders/ethereum/verify-contracts/block-explorers/#verifying-the-contract","title":"Verify the Contract","text":"<p>The next step will be verifying the smart contract in an EVM-compatible explorer for the Moonbeam network that you deployed to.</p>"},{"location":"builders/ethereum/verify-contracts/block-explorers/#moonscan","title":"Moonscan","text":"<p>Take the following steps to verify the contract on Moonscan:</p> <ol> <li>Go to the Verify &amp; Publish Contract Source Code page of Moonscan</li> <li>Fill in the contract's deployed address in the first field, including the <code>0x</code> prefix</li> <li>Select the compiler type. For the current <code>Incrementer.sol</code> example, select Solidity (Single file)</li> <li>After selecting the compiler type, select the compiler version used to compile the contract. If the compiler version used was a nightly commit, uncheck the box under the field to select the nightly version</li> <li>Select the open-source license used. For the current <code>Incrementer.sol</code> example, select the option MIT License (MIT). If there was none used, select No License (None)</li> <li>Click the Continue button at the bottom of the form to continue on to the next page</li> </ol> <p></p> <p>On the second page, the Contract Address, Compiler, and Constructor Arguments fields should be prefilled. Fill in the rest of the information:</p> <ol> <li>Copy and paste the entirety of the contract's content into the text field labeled as such</li> <li>(Optional) Select Yes for Optimization if it was enabled during compilation, and fill in the number of runs under Misc Settings/Runs(Optimizer)</li> <li>(Optional) Add contract libraries and their addresses, if any were used in the contract</li> <li>(Optional) Check any other optional fields that may apply to your contract, and fill them out accordingly</li> <li>Click on the CAPTCHA at the bottom and the Verify and Publish button to confirm and begin verification</li> </ol> <p></p> <p>After a short wait, the result of verification will be displayed in the browser, and a success result page will display the contract's ABI-encoded constructor arguments, the contract name, bytecode, and ABI.</p> <p></p>"},{"location":"builders/ethereum/verify-contracts/block-explorers/#smart-contract-flattening","title":"Smart Contract Flattening","text":"<p>For verifying smart contracts that are made up of multiple files, the process is slightly different and requires some pre-processing to combine all the dependencies of the target smart contract into a single Solidity file.</p> <p>This pre-processing is usually referred to as smart contract flattening. There are a number of tools that can be used to flatten a multi-part smart contract into a single Solidity file, such as Hardhat's Flatten task. Please refer to the respective smart contract flattening tool's documentation for more detailed instructions on its usage.</p> <p>After flattening the multi-part smart contract, it can be verified using the new flattened Solidity file on a block explorer in the same way that a single-file smart contract is verified, as described in this tutorial.</p>"},{"location":"builders/ethereum/verify-contracts/block-explorers/#verify-multi-part-smart-contract-on-moonscan","title":"Verify Multi-Part Smart Contract on Moonscan","text":"<p>For verifying on Moonscan, there is a built-in feature to process multi-part smart contracts.</p> <p>Select Solidity (Multi-part files) under Compiler Type (step 3 of the above example). Then, on the next page, select and upload all the different Solidity files that the contract consists of, including their nested dependency contract files.</p> <p></p> <p>Aside from that, the process is largely the same as verifying single-file contracts on Moonscan.</p>"},{"location":"builders/ethereum/verify-contracts/etherscan-plugins/","title":"Verify Smart Contracts with Etherscan Plugins","text":""},{"location":"builders/ethereum/verify-contracts/etherscan-plugins/#introduction","title":"Introduction","text":"<p>Verifying smart contracts is a great way of improving the transparency and security of contracts deployed on Moonbeam. Hardhat and Foundry integrate with Etherscan's contract verification service to automate the process of verifying contracts by locally detecting which contracts to verify and which Solidity libraries are required, if any.</p> <p>The Hardhat plugin integrates seamlessly into your Hardhat project. Foundry also has Etherscan capabilities, but they are built into its Forge tool instead of being included in a separate plugin.</p> <p>This guide will show you how to use both plugins to verify smart contracts deployed on Moonbase Alpha. This guide can also be adapted for Moonbeam and Moonriver.</p>"},{"location":"builders/ethereum/verify-contracts/etherscan-plugins/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>MetaMask installed and connected to the Moonbase Alpha TestNet</li> <li>An account funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>An Etherscan API key</li> <li>Git installed and configured</li> </ul>"},{"location":"builders/ethereum/verify-contracts/etherscan-plugins/#generating-an-etherscan-api-key","title":"Generating an Etherscan API Key","text":"<p>To verify contracts on Moonscan for any Moonbeam network, you\u2019ll need an Etherscan API key. Because Moonscan is part of Etherscan\u2019s ecosystem, a single key works across all supported networks.</p> <p>To create an Etherscan account and generate your key, follow these steps:</p> <ol> <li>Click Sign In</li> <li>Select Click to sign up and then register your new account</li> </ol> <p></p> <p>Once you have an account and are signed in, you will then be able to create an API key.</p> <ol> <li>Select API Dashboard from the left side menu</li> <li>To add a new key, click the + Add button</li> </ol> <p></p> <p>You will then be prompted to enter in an AppName for your API key and once you enter a name and click Continue it will appear in your list of API keys.</p>"},{"location":"builders/ethereum/verify-contracts/etherscan-plugins/#using-the-hardhat-verify-plugin","title":"Using the Hardhat Etherscan Plugin","text":"<p>The example in this section of the guide will be based off of the <code>Box.sol</code> contract that was created in the Using Hardhat to Deploy To Moonbeam guide.</p> <p>To get started with the Hardhat Etherscan plugin, you will need to first install the plugin library:</p> <pre><code>npm install --save-dev @nomicfoundation/hardhat-verify\n</code></pre> <p>You can add your Etherscan API key to the <code>hardhat.config.js</code> file.</p> <p>From within your Hardhat project, open your <code>hardhat.config.js</code> file. You'll need to import the <code>hardhat-verify</code> plugin, your Etherscan API key, and add the config for Etherscan:</p> <pre><code>require('@nomicfoundation/hardhat-verify');\n\nmodule.exports = {\n  networks: {\n    moonbeam: { ... },\n    moonriver: { ... },\n    moonbaseAlpha: { ... }\n  },\n  etherscan: {\n    apiKey: {\n      moonbeam: 'INSERT_ETHERSCAN_API_KEY',\n      moonriver: 'INSERT_ETHERSCAN_API_KEY',\n      moonbaseAlpha: 'INSERT_ETHERSCAN_API_KEY', \n    },\n  },\n};\n</code></pre> <p>To verify the contract, you will run the <code>verify</code> command and pass in the address of the deployed contract and the network where it's deployed:</p> <pre><code>npx hardhat verify --network moonbase INSERT_CONTRACT_ADDRESS\n</code></pre> <p>In your terminal you should see the source code for your contract was successfully submitted for verification. If the verification was successful, you should see Successfully verified contract and there will be a link to the contract code on Moonscan for Moonbase Alpha.</p> npx hardhat verify --network moonbase 0x5d73ecDB4652173b881893235B64F1a0BdE22dD6 Successfully submitted source code for contract contracts/Box.sol:Box at 0x5d73ecDB4652173b881893235B64F1a0BdE22dD6 for verification on the block explorer. Waiting for verification result... Successfully verified contract Box on Etherscan. https://moonbase.moonscan.io/address/0x5d73ecDB4652173b881893235B64F1a0BdE22dD6#code <p>If you're verifying a contract that has constructor arguments, you'll need to run the above command and add the constructor arguments used to deploy the contract at the end of the command. For example:</p> <pre><code>npx hardhat verify --network moonbase INSERT_CONTRACT_ADDRESS INSERT_CONSTRUCTOR_ARGS\n</code></pre> <p>Please refer to the Hardhat Verify documentation for help with additional use cases such as:</p> <ul> <li>complex arguments</li> <li>libraries with undetectable addresses</li> <li>using multiple API keys</li> <li>using the <code>verify</code> command programmatically</li> <li>determining the correct constructor arguments</li> </ul>"},{"location":"builders/ethereum/verify-contracts/etherscan-plugins/#using-foundry-to-verify","title":"Using Foundry to Verify","text":"<p>The example in this section of the guide will use the <code>MyToken.sol</code> contract that was created in the Using Foundry to Deploy to Moonbeam guide. </p> <p>In addition to the Foundry project, you will need an Etherscan API key to verify your contract. </p> <p>If you have already deployed the example contract, you can verify it with the <code>verify-contract</code> command. Before you can verify the contract, you will need to ABI-encode the constructor arguments. To do so for the example contract, you can run the following command:</p> <pre><code>cast abi-encode \"constructor(uint256)\" 100\n</code></pre> <p>The result should be <code>0x0000000000000000000000000000000000000000000000000000000000000064</code>. You can then verify the contract using the following command:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>forge verify-contract --chain-id 1284 \\\nYOUR_CONTRACT_ADDRESS \\\n--constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\nsrc/MyToken.sol:MyToken \\\n--etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY\n</code></pre> <pre><code>forge verify-contract --chain-id 1285 \\\nYOUR_CONTRACT_ADDRESS \\\n--constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\nsrc/MyToken.sol:MyToken \\\n--etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY\n</code></pre> <pre><code>forge verify-contract --chain-id 1287 \\\nYOUR_CONTRACT_ADDRESS \\\n--constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\nsrc/MyToken.sol:MyToken \\\n--etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY\n</code></pre> forge verify-contract --chain-id 1284 \\ YOUR_CONTRACT_ADDRESS \\ --constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\ src/MyToken.sol:MyToken \\ --etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY Submitting verification for [src/MyToken. sol:MyToken] Ok(\"0\u00d75A05EBOA18ee616bb5dac2C4D0a48991a83533d2\" ) . Submitted contract for verification:         Response:'OK'         GUID:'f7iwagu9vspdrdfirbie1wp16cmuvfk3zvcsix9ey21t3a8ttt'         URL: https: //moonbase.moonscan.io/address/0\u00d75a05eb0a18ee616bb5dac2c4d0a48991a83533d2 Waiting for verification result... Contract successfully verified. <p>If you wanted to deploy the example contract and verify at the same time, then you would use the following command:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>forge create --rpc-url INSERT_RPC_API_ENDPOINT \\\n--constructor-args 100 \\\n--etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY \\\n--verify --private-key YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken\n</code></pre> <pre><code>forge create --rpc-url INSERT_RPC_API_ENDPOINT \\\n--constructor-args 100 \\\n--etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY \\\n--verify --private-key YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken\n</code></pre> <pre><code>forge create --rpc-url https://rpc.api.moonbase.moonbeam.network \\\n--constructor-args 100 \\\n--etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY \\\n--verify --private-key YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken\n</code></pre> forge create --rpc-url INSERT_RPC_API_ENDPOINT \\ --constructor-args 100 \\ --etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY \\ --verify --private-key YOUR_PRIVATE_KEY \\ src/MyToken.sol:MyToken Compiling... No files changed, compilation skipped Deployer: 0x0394c0EdFcCA370B20622721985B577850B0eb 75 Deployed to: 0d21b2653f61b5B5399A677D377D52D07C7668f67 Transaction hash: 0x80fff772b930f425ed3568f0b3d8844e5297691c78807c7b393c85910b7717 Starting contract verification... Waiting for etherscan to detect contract deployment... Submitting verification for [src/MyToken.sol:MyToken]Ok(\"0x21b265361b5B5399A677D377D52D07C7668f67\"). Submitted contract for verification:         Response:'OK'         GUID:'ebbliyrquc5itkavvhvmilanzu5rdqusikImgraanepjm8gpq'         URL: https: //moonbase.moonscan.io/address/0x21b2653f61b55399a677d377d52d07c7668f67 Waiting for verification result... Contract successfully verified."},{"location":"builders/get-started/create-account/","title":"Create an Account","text":""},{"location":"builders/get-started/create-account/#introduction","title":"Introduction","text":"<p>To get started developing on Moonbeam, developers must create an account. The most prevalent approach involves leveraging a wallet application, which facilitates generating and managing cryptographic keys essential for interacting with Moonbeam.</p> <p>Moonbeam uses H160 Ethereum-style accounts and ECDSA keys, represented in 20-byte addresses. If you already have an Ethereum account and its private key or mnemonic, you can use your account on Moonbeam.</p> <p>This guide will walk you through the step-by-step process of creating an account on Moonbeam. Whether you're new to blockchain technology or an experienced Ethereum user, this guide will provide all the information you need to get started.</p> <p>Note</p> <p>This guide does not pertain to a local Moonbeam development node. If you are using a development node, you don't need to worry about creating an account, as the node comes with ten pre-funded accounts for testing purposes. Please refer to the Getting Started with a Local Moonbeam Development Node guide for more information.</p>"},{"location":"builders/get-started/create-account/#choose-a-wallet","title":"Choose a Wallet","text":"<p>A wallet is a software or hardware tool that allows you to securely store, manage, and interact with your digital assets, such as tokens or coins. Wallets store your private keys, which are essential for authorizing transactions on the network.</p> <p>You can review a list of wallets on the Moonbeam DApp Directory.</p> <p></p> <p>The list of wallets on the dApp is not exhaustive and may only cover some of the available options. You should be able to use any Ethereum-compatible wallet to generate an address and its associated private key.</p> <p>You can also check out any of the wallets in the Connect to Moonbeam section of the docs.</p>"},{"location":"builders/get-started/create-account/#use-your-wallet-to-create-an-account","title":"Use Your Wallet to Create an Account","text":"<p>After you've selected a wallet and downloaded it, you'll most likely be prompted to create a new account or import an existing one the first time you open it. You'll want to create a new account.</p> <p>Depending on the wallet, when creating an account, you may be prompted to backup and restore a seed phrase, also referred to as a mnemonic or recovery phrase. This phrase is a sequence of generated words that serve as a backup mechanism for private keys. They typically consist of 12 to 24 words randomly selected from a predefined list. Seed phrases are used to derive private keys deterministically, meaning that the same sequence of words will always generate the same set of private keys. They are crucial for recovering access to a cryptocurrency wallet in case of loss or device failure. Make sure you save the phrase in a safe place; if you lose access to this phrase, you'll lose access to any funds you hold in your account.</p> <p>After saving your seed phrase, you can start developing on Moonbeam. Many wallets offer the option to export the private key linked to your account. By doing so, you can utilize your private key instead of the seed phrase during development. However, taking adequate precautions to securely store your private key or seed phrase while developing is essential.</p> <p>And that's it! Before sending your first transaction on a Moonbeam-based network, ensure you have the necessary network configurations for your chosen network and an RPC endpoint for the network. Once you have these items, you'll be able to follow along with tutorials like the How to use Ethers.js or the How to use Web3.js to send a transaction.</p>"},{"location":"builders/get-started/endpoints/","title":"Network Endpoints","text":""},{"location":"builders/get-started/endpoints/#public-endpoints","title":"Public Endpoints","text":"<p>Moonbeam-based networks have two endpoints available for users to connect to: one for HTTPS and one for WSS.</p> <p>The endpoints in this section are for development purposes only and are not meant to be used in production applications.</p> <p>If you are looking for an API provider suitable for production use, you can check out the Endpoint Providers section of this guide.</p>"},{"location":"builders/get-started/endpoints/#moonbeam","title":"Moonbeam","text":"HTTPSWSS Provider RPC URL Limits Dwellir <pre><code>https://moonbeam-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>https://moonbeam.api.onfinality.io/public</code></pre> 40 req/sec UnitedBloc <pre><code>https://moonbeam.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonbeam.public.curie.radiumblock.co/http</code></pre> 200 req/sec 1RPC <pre><code>https://1rpc.io/glmr</code></pre> 10k req/day Grove <pre><code>https://moonbeam.rpc.grove.city/v1/01fdb492</code></pre> 5k req/day Provider RPC URL Limits Dwellir <pre><code>wss://moonbeam-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>wss://moonbeam.api.onfinality.io/public-ws</code></pre> 40 req/sec UnitedBloc <pre><code>wss://moonbeam.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonbeam.public.curie.radiumblock.co/ws</code></pre> 200 req/sec 1RPC <pre><code>wss://1rpc.io/glmr</code></pre> 10k req/day"},{"location":"builders/get-started/endpoints/#moonriver","title":"Moonriver","text":"HTTPSWSS Provider RPC URL Limits Dwellir <pre><code>https://moonriver-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>https://moonriver.api.onfinality.io/public</code></pre> 40 req/sec UnitedBloc <pre><code>https://moonriver.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonriver.public.curie.radiumblock.co/http</code></pre> 200 req/sec Grove <pre><code>https://moonriver.rpc.grove.city/v1/01fdb492</code></pre> 5k req/day Provider RPC URL Limits Dwellir <pre><code>wss://moonriver-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>wss://moonriver.api.onfinality.io/public-ws</code></pre> 40 req/sec UnitedBloc <pre><code>wss://moonriver.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonriver.public.curie.radiumblock.co/ws</code></pre> 200 req/sec"},{"location":"builders/get-started/endpoints/#moonbase-alpha","title":"Moonbase Alpha","text":"HTTPSWSS Provider RPC URL Limits Dwellir <pre><code>https://moonbase-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>https://moonbeam-alpha.api.onfinality.io/public</code></pre> 40 req/sec Moonbeam Foundation <pre><code>https://rpc.api.moonbase.moonbeam.network</code></pre> 25 req/sec UnitedBloc <pre><code>https://moonbase.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonbase.public.curie.radiumblock.co/http</code></pre> 200 req/sec Provider RPC URL Limits Dwellir <pre><code>wss://moonbase-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>wss://moonbeam-alpha.api.onfinality.io/public-ws</code></pre> 40 req/sec Moonbeam Foundation <pre><code>wss://wss.api.moonbase.moonbeam.network</code></pre> 25 req/sec UnitedBloc <pre><code>wss://moonbase.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonbase.public.curie.radiumblock.co/ws</code></pre> 200 req/sec"},{"location":"builders/get-started/endpoints/#relay-chain","title":"Relay Chain","text":"<p>To connect to the Moonbase Alpha relay chain, you can use the following WS Endpoint:</p> Provider RPC URL OpsLayer <pre><code>wss://relay.api.moonbase.moonbeam.network</code></pre>"},{"location":"builders/get-started/endpoints/#endpoint-providers","title":"RPC Endpoint Providers","text":"<p>You can create your own endpoint suitable for development or production use using any of the following API providers:</p> <ul> <li>1RPC</li> <li>Blast</li> <li>Chainstack</li> <li>dRPC</li> <li>Dwellir</li> <li>GetBlock</li> <li>Grove</li> <li>OnFinality</li> <li>UnitedBloc</li> </ul>"},{"location":"builders/get-started/endpoints/#1rpc","title":"1RPC","text":"<p>1RPC is a free and private RPC relay that protects user privacy by preventing data collection, user tracking, phishing attempts from other parties. It tunnels user requests via distributed relays to other RPC providers whilst preventing the tracking of user metadata such as IP address, device information and wallet linkability with secure enclave technology.</p> <p>1RPC is created to be an open initiative from the blockchain infrastructure community. They are motivated by a common good mission to help build a better Web3 and encourage anyone who values user privacy to join this open collaboration.</p> <p>Head over to 1RPC official site to set it up!</p> <p></p>"},{"location":"builders/get-started/endpoints/#blast","title":"Blast","text":"<p>As a user of Blast powered by Bware Labs, you will be able to obtain your own free endpoint allowing you to interact with Moonbeam, just by performing a few simple clicks within a user-friendly interface.</p> <p>To get started, you'll need to head to Blast, and launch the app, and connect your wallet. Once your wallet is connected you will be able to create a project and then generate your own custom endpoint. To generate an endpoint:</p> <ol> <li>Create a new project</li> <li>Click on Available Endpoints</li> <li>Select Moonbeam network for your endpoint</li> <li>Confirm the selected network and Press Activate</li> <li>You'll now see Moonbeam under Active Endpoints. Click on the network and you'll see your custom RPC and WSS endpoints on the next page</li> </ol> <p></p>"},{"location":"builders/get-started/endpoints/#chainstack","title":"Chainstack","text":"<p>Chainstack, the Web3 infrastructure provider, offers free and paid endpoints for Moonbeam. The free Developer plan starts with 3 million monthly requests and 25 requests per second (RPS). You can easily scale with the paid plans.</p> <p>To start with a free Developer plan endpoint, sign up using an email or any social account, like GitHub or X (Twitter).</p> <ol> <li>Visit Chainstack</li> <li>Sign up</li> <li>Deploy a Moonbeam node</li> </ol> <p></p>"},{"location":"builders/get-started/endpoints/#drpc","title":"dRPC.org","text":"<p>dRPC.org offers public and paid Moonbeam RPC endpoints, providing an efficient, low-latency connection to blockchain nodes. The paid tiers include higher request limits, lower latency, and advanced analytics for optimized performance.</p> <p>How to use dRPC:</p> <ol> <li>Sign up or log in at dRPC.org</li> <li>In the dashboard, create an API key</li> <li>Click the key and select the desired endpoint</li> </ol> <p>For 24/7 support, join dRPC's Discord.</p>"},{"location":"builders/get-started/endpoints/#dwellir","title":"Dwellir","text":"<p>Dwellir is a blockchain operation service that ensures global scalability, low latency, and a 99.99% uptime guarantee, providing fast and reliable node operations wherever your business stands. The public endpoint service is geographically distributed bare metal servers globally. As the service is public, there are no sign-up or API keys to manage.</p> <p>To get started with a developer endpoint or dedicated node, you'll need to contact us:</p> <ol> <li>Visit Dwellir</li> <li>Submit your email and your node request</li> </ol> <p></p>"},{"location":"builders/get-started/endpoints/#getblock","title":"GetBlock","text":"<p>GetBlock is a service that provides instant API access to Moonbeam and Moonriver and is available through shared and dedicated nodes. Dedicated nodes provide access to a private server with fast speeds and without rate limits. Shared nodes provide a free API/add-on based endpoint for you to get started quickly.</p> <p>To get started with GetBlock, you can go to the GetBlock registration page and sign up for a new account. Then, from your account Dashboard, you can view and manage your existing endpoints for multiple protocols, and also create new ones.</p> <p>Creating a new API/add-on based endpoint is simple, all you have to do is:</p> <ol> <li>Fill the information for the desired protocol from the list of available blockchains</li> <li>Choose the network you want your endpoint to point to (Mainnet, Testnet, etc)</li> <li>Select JSON-RPC from the API/Add-on dropdown</li> <li>Click the Get button at the far right and you're all set to go! </li> </ol> <p></p>"},{"location":"builders/get-started/endpoints/#grove","title":"Grove","text":"<p>Grove is a decentralized RPC network that provides reliable Web3 infrastructure with enterprise-grade performance and security. Grove offers both free and paid tiers, with the free tier providing generous limits for development use, while paid plans offer higher throughput, dedicated support, and advanced features for production applications. Grove's decentralized approach ensures high availability and censorship resistance by distributing requests across multiple node operators. The network supports both JSON-RPC and WebSocket connections for real-time applications. To get started with Grove:</p> <ol> <li>Visit the Grove Portal and sign up for an account</li> <li>From your dashboard, create a new application</li> <li>Copy your Moonbeam or Moonriver endpoints</li> <li>Start making requests to your custom Grove endpoint</li> </ol> <p>Grove provides detailed analytics, request monitoring, and flexible rate limiting to help you optimize your application's performance.</p> <p></p>"},{"location":"builders/get-started/endpoints/#onfinality","title":"OnFinality","text":"<p>OnFinality provides a free API key based endpoint for customers in place of a public endpoint. Additionally, OnFinality offers paid tiers of service that offer increased rate limits and higher performance than those offered by the free tier. You also receive more in depth analytics of the usage of your application.</p> <p>To create a custom OnFinality endpoint, go to OnFinality and sign up, or if you already have signed up you can go ahead and log in. From the OnFinality Dashboard, you can:</p> <ol> <li>Click on API Service</li> <li>Select the network from the dropdown</li> <li>Your custom API endpoint will be generated automatically</li> </ol> <p></p>"},{"location":"builders/get-started/endpoints/#unitedbloc","title":"UnitedBloc","text":"<p>UnitedBloc is a collective of community collators from both Moonbeam and Moonriver. To provide value for the community, they offer public RPC services for the Moonbeam, Moonriver, and Moonbase Alpha networks.</p> <p>The public endpoint service is served by eight geographically distributed bare metal servers globally balanced via GeoDNS and regionally load balanced with NGINX. As the service is public, there are no sign-up or API keys to manage.</p> <p>The collators involved in this initiative are:</p> <ul> <li>Blockshard (CH)</li> <li>BloClick (ES)</li> <li>BrightlyStake (IN)</li> <li>CertHum (US)</li> <li>GPValidator (PT)</li> <li>Hetavalidation (AU)</li> <li>Legend (AE)</li> <li>PathrockNetwork (DE)</li> <li>Polkadotters (CZ)</li> <li>SIK | crifferent.de (DE)</li> <li>StakeBaby (GR)</li> <li>StakeSquid (GE)</li> <li>TrueStaking (US)</li> </ul> <p>They also provide a public Grafana dashboard with some cool metrics.</p> <p>Check the public endpoints section to get the relevant URL. You can contact them via their Telegram channel, or read more about their initiative on their blogpost page.</p>"},{"location":"builders/get-started/endpoints/#lazy-loading-with-RPC-Endpoint-Providers","title":"Lazy Loading with RPC Endpoint Providers","text":"<p>Lazy loading lets a Moonbeam node operate while downloading network state in the background, eliminating the need to wait for full synchronization before use. To spin up a Moonbeam node with lazy loading, you'll need to either download the Moonbeam release binary or compile the binary. You can activate lazy loading with the following flag:</p> <p><code>--lazy-loading-remote-rpc 'INSERT-RPC-URL'</code></p> <p>Lazy loading is highly resource-intensive, requiring many RPC requests to function. To avoid being throttled, it's recommended that you use a dedicated endpoint (i.e., an endpoint with an API key) rather than a public endpoint. You will likely be rate-limited if you use lazy loading with a public endpoint. Upon spooling up a node with this feature, you'll see output like the following:</p> [Lazy loading \ud83c\udf17]     You are now running the Moonbeam client in lazy loading mode, where data is retrieved     from a live RPC node on demand.     Using remote state from: https://moonbeam.unitedbloc.com     Forking from block: 8482853     To ensure the client works properly, please note the following:         1. *Avoid Throttling*: Ensure that the backing RPC node is not limiting the number of         requests, as this can prevent the lazy loading client from functioning correctly;         2. *Be Patient*: As the client may take approximately 20 times longer than normal to         retrieve and process the necessary data for the requested operation.     The service will start in 10 seconds..."},{"location":"builders/get-started/endpoints/#overriding-state-with-lazy-loading","title":"Overriding State with Lazy Loading","text":"<p>By default, you won't see detailed logging in the terminal. To override this setting and show lazy loading logs, you can add the following flag to your command to start the Moonbeam node: <code>-l debug</code>. You can further customize your use of the lazy loading functionality with the following optional parameters:</p> <ul> <li><code>--lazy-loading-block</code> - specifies a block hash from which to start loading data. If not provided, the latest block will be used</li> <li><code>--lazy-loading-delay-between-requests</code> - the delay (in milliseconds) between RPC requests when using lazy loading. This parameter controls the amount of time to wait between consecutive RPC requests. This can help manage request rate and avoid overwhelming the server. Default value is <code>100</code> milliseconds</li> <li><code>--lazy-loading-max-retries-per-request</code> - the maximum number of retries for an RPC request when using lazy loading. Default value is <code>10</code> retries</li> <li><code>--lazy-loading-runtime-override</code> - path to a WASM file to override the runtime when forking. If not provided, it will fetch the runtime from the block being forked</li> <li><code>--lazy-loading-state-overrides</code> - path to a JSON file containing state overrides to be applied when forking</li> </ul>"},{"location":"builders/get-started/endpoints/#simple-storage-item-override","title":"Simple Storage Item Override","text":"<p>The state overrides file should define the respective pallet, storage item, and value that you seek to override as follows:</p> <pre><code>[\n {\n     \"pallet\": \"System\",\n     \"storage\": \"SelectedCandidates\",\n     \"value\": \"0x04f24ff3a9cf04c71dbc94d0b566f7a27b94566cac\"\n }\n]\n</code></pre>"},{"location":"builders/get-started/endpoints/#override-an-accounts-free-balance","title":"Override an Account's Free Balance","text":"<p>To override the balance of a particular account, you can override the account storage item of the system pallet for the respective account as follows:</p> <pre><code>[\n  {\n    \"pallet\": \"System\",\n    \"storage\": \"Account\",\n    \"key\": \"TARGET_ADDRESS\",\n    \"value\": \"0x460c000002000000010000000600000069e10de76676d0800000000000000000040a556b0e032de12000000000000000004083a09e15c74c1b0100000000000000000000000000000000000000000000080\"\n  }\n]\n</code></pre> Details about overriding account balances <p>Overriding an account balance, as shown above, can be a complex process. However, this guide will break it down into steps that are easy to follow. Before making any changes, you should obtain the existing value corresponding to the key (i.e., the account in this case). You can go to Chain State on Polkadot.js Apps and query the System pallet by providing the account you'd like to query. Upon submitting the query, you'll get back a readable account structure like so:</p> <pre><code>{\n  nonce: 3,142\n  consumers: 2\n  providers: 1\n  sufficients: 6\n  data: {\n    free: 1,278,606,392,142,175,328,676\n    reserved: 348,052,500,000,000,000,000\n    frozen: 20,413,910,106,633,175,872\n    flags: 170,141,183,460,469,231,731,687,303,715,884,105,728\n  }\n}\n</code></pre> <p>While this is useful as a reference, the information you're looking for is the encoded storage key, which is accessible even without submitting the chain state query. In this instance, the encoded storage key corresponding to the system pallet and the selected account <code>0x3B939FeaD1557C741Ff06492FD0127bd287A421e</code> is:</p> <pre><code>0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9b882fedb4f75b055c709ec5b66b5d9933b939fead1557c741ff06492fd0127bd287a421e\n</code></pre> <p>Note that this encoded storage key will change alongside any input changes, such as a different account being queried. Then, head over the Raw Storage tab on Polkadot.js Apps. Input the above storage key and submit the query. The response is the SCALE encoded account struct, a part of which contains the free balance information to be modified as part of this example: </p> <pre><code>0x460c0000020000000100000006000000a4d92a6a4e6b3a5045000000000000000040a556b0e032de12000000000000004083a09e15c74c1b010000000000000000000000000000000000000000000080\n</code></pre> <p>There is quite a bit of data encoded in the value field because it is a complex struct comprised of multiple values. The struct is comprised of:</p> <pre><code>struct AccountInfo {\n    nonce: u32,             // Transaction count\n    consumers: u32,         // Number of consumers \n    providers: u32,         // Number of providers\n    sufficients: u32,       // Number of sufficients\n    data: AccountData {     // The balance info\n        free: u128,         // Free balance\n        reserved: u128,     // Reserved balance\n        frozen: u128,       // Frozen balance\n        flags: u128         // Account flags\n    }\n}\n</code></pre> <p>You can associate each part of the SCALE encoded struct with the corresponding piece of Alice's account information that it represents:</p> <pre><code>0x460c0000        // nonce (u32): 3,142 \n02000000          // consumers (u32): 2\n01000000          // providers (u32): 1  \n06000000          // sufficients (u32): 6\n\na4d92a6a4e6b3a5045000000000000000  \n// free (u128): 1,278,606,392,142,175,328,676\n\n40a556b0e032de1200000000000000000  \n// reserved (u128): 348,052,500,000,000,000,000  \n\n4083a09e15c74c1b01000000000000000  \n// frozen (u128): 20,413,910,106,633,175,872\n\n00000000000000000000000000000080   \n// flags (u128): 170,141,183,460,469,231,731,687,303,715,884,105,728\n</code></pre> <p>Remember that the values are little endian encoded. To convert the hexadecimal little endian encoded values to decimal, you can use Substrate Utilities converter, using the Balance to Hex (Little Endian) converter.</p> <p>In this example, the existing free balance of <code>1,278,606,392,142,175,328,676</code> Wei or approximately <code>1278.60</code> DEV is <code>a4d92a6a4e6b3a5045</code>. The following example will change the value to <code>500,000</code> DEV, which is <code>500,000,000,000,000,000,000,000</code> Wei or <code>0x000080d07666e70de169</code> encoded as a hexadecimal little endian value. When properly padded to fit into the SCALE encoded storage value, it becomes <code>69e10de76676d08000000000000000000</code>, such that the table now looks like:</p> <pre><code>0x460c0000        // nonce (u32): 3,142 \n02000000          // consumers (u32): 2\n01000000          // providers (u32): 1  \n06000000          // sufficients (u32): 6\n\n69e10de76676d08000000000000000000\n// free (u128): 500,000,000,000,000,000,000,000\n\n40a556b0e032de1200000000000000000  \n// reserved (u128): 348,052,500,000,000,000,000  \n\n4083a09e15c74c1b01000000000000000  \n// frozen (u128): 20,413,910,106,633,175,872\n\n00000000000000000000000000000080   \n// flags (u128): 170,141,183,460,469,231,731,687,303,715,884,105,728\n</code></pre> <p>Therefore, the SCALE encoded override value is as follows:</p> <pre><code>0x460c000002000000010000000600000069e10de76676d0800000000000000000040a556b0e032de12000000000000000004083a09e15c74c1b0100000000000000000000000000000000000000000000080\n</code></pre> <p>You can now specify the SCALE encoded override value in your <code>state-overrides.json</code> file as follows:</p> <pre><code>[\n  {\n    \"pallet\": \"System\",\n    \"storage\": \"Account\",\n    \"key\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"value\": \"0x460c000002000000010000000600000069e10de76676d0800000000000000000040a556b0e032de12000000000000000004083a09e15c74c1b0100000000000000000000000000000000000000000000080\"\n  }\n]\n</code></pre> <p>To run lazy loading with the balance state override, you can use the following command: </p> <pre><code>--lazy-loading-remote-rpc 'INSERT_RPC_URL' --lazy-loading-state-overrides ./state-overrides.json\n</code></pre>"},{"location":"builders/get-started/endpoints/#override-an-erc-20-token-balance","title":"Override an ERC-20 Token Balance","text":"<p>To override an ERC-20 token balance, identify the storage slot in the EVM\u2019s AccountStorages where the <code>balanceOf</code> data for the given token contract and account is stored. This storage slot is determined by the token contract\u2019s H160 address and the corresponding H256 storage key. Once you have this slot, specify the new balance value in the <code>state-overrides.json</code> file to implement the override.</p> <p>In the example below, we override the token balance of the Wormhole USDC Contract (<code>0x931715FEE2d06333043d11F658C8CE934aC61D0c</code>) for the account <code>0x3b939fead1557c741ff06492fd0127bd287a421e</code> to $5,000 USDC. Since Wormhole USDC uses 6 decimal places, $5,000 corresponds to <code>5000000000</code> in integer form, which is <code>0x12a05f200</code> in hexadecimal.</p> <pre><code>[\n    {\n        \"pallet\": \"EVM\",\n        \"storage\": \"AccountStorages\",\n        \"key\": [\n            \"0x931715FEE2d06333043d11F658C8CE934aC61D0c\",\n            \"0x8c9902c0f94ae586c91ba539eb52087d3dd1578da91158308d79ff24a8d4f342\"\n        ],\n        \"value\": \"0x000000000000000000000000000000000000000000000000000000012a05f200\"\n    }\n]\n</code></pre> <p>You can calculate the exact storage slot to override for your own account with the following script:</p> <pre><code>import { ethers } from 'ethers';\n\nfunction getBalanceSlot(accountAddress) {\n  // Convert address to bytes32 and normalize\n  const addr = ethers.zeroPadValue(accountAddress, 32);\n\n  // CAUTION! The storage slot used here is 5, which\n  // is specific to Wormhole contracts\n  // The storage slot index for other tokens may vary\n  const packedData = ethers.concat([\n    addr,\n    ethers.zeroPadValue(ethers.toBeHex(5), 32),\n  ]);\n\n  // Calculate keccak256\n  return ethers.keccak256(packedData);\n}\n\n// Example usage\nconst address = 'INSERT_ADDRESS';\nconsole.log(getBalanceSlot(address));\n</code></pre> <p>You can apply the same process for other ERC-20 token contracts. The following sections demonstrate overrides for the <code>0x3B939FeaD1557C741Ff06492FD0127bd287A421e</code> account with various ERC-20 tokens. Remember to update the H160 token contract address whenever you switch to a different token. Also, you will need to recalculate the H256 storage slot for each distinct account whose balance you want to override.</p> Example: Override Wormhole BTC Token Balance <pre><code>[\n    {\n        \"pallet\": \"EVM\",\n        \"storage\": \"AccountStorages\",\n        \"key\": [\n            \"0xE57eBd2d67B462E9926e04a8e33f01cD0D64346D\",\n            \"0x8c9902c0f94ae586c91ba539eb52087d3dd1578da91158308d79ff24a8d4f342\"\n        ],\n        \"value\": \"0x000000000000000000000000000000000000000000000000000000012a05f200\"\n    }\n]\n</code></pre> Example: Override Wormhole ETH Token Balance <pre><code>[\n    {\n        \"pallet\": \"EVM\",\n        \"storage\": \"AccountStorages\",\n        \"key\": [\n            \"0xab3f0245B83feB11d15AAffeFD7AD465a59817eD\",\n            \"0x8c9902c0f94ae586c91ba539eb52087d3dd1578da91158308d79ff24a8d4f342\"\n        ],\n        \"value\": \"0x000000000000000000000000000000000000000000000000000000012a05f200\"\n    }\n]\n</code></pre> Example: Override WELL Token Balance <p>Because the WELL token does not use a proxy implementation contract, the storage slot calculation differs. Instead of slot <code>5</code>, the balance mapping resides at slot <code>1</code>. You can determine the exact storage slot to override the WELL token balance for your own account using the following script:</p> <pre><code>import { ethers } from 'ethers';\n\nfunction getBalanceSlot(accountAddress) {\n  // Convert address to bytes32 and normalize\n  const addr = ethers.zeroPadValue(accountAddress, 32);\n\n  // Caution! The storage slot index used here is 1\n  // The storage slot index for other tokens may vary\n  const packedData = ethers.concat([\n    addr,\n    ethers.zeroPadValue(ethers.toBeHex(1), 32),\n  ]);\n\n  // Calculate keccak256\n  return ethers.keccak256(packedData);\n}\n\n// Example usage\nconst address = 'INSERT_ADDRESS';\nconsole.log(getBalanceSlot(address));\n</code></pre> <p>Thus, the storage override would be:</p> <pre><code>[\n    {\n        \"pallet\": \"EVM\",\n        \"storage\": \"AccountStorages\",\n        \"key\": [\n            \"0x511aB53F793683763E5a8829738301368a2411E3\",\n            \"0x728d3daf4878939a6bb58cbc263f39655bb57ea15db7daa0b306f3bf2c3f1227\"\n        ],\n        \"value\": \"0x000000000000000000000000000000000000000000000000000000012a05f200\"\n    }\n]\n</code></pre>"},{"location":"builders/get-started/endpoints/#tracing-providers","title":"Tracing RPC Endpoint Providers","text":"<p>Tracing RPC endpoints allow you to access non-standard RPC methods, such as those that belong to Geth's <code>debug</code> and <code>txpool</code> APIs and OpenEthereum's <code>trace</code> module. To see a list of the supported non-standard RPC methods on Moonbeam for debugging and tracing, please refer to the Debug API &amp; Trace Module guide.</p> <p>The following providers provide tracing RPC endpoints:</p> <ul> <li>OnFinality</li> </ul>"},{"location":"builders/get-started/endpoints/#onfinality-tracing","title":"OnFinality","text":"<p>OnFinality's Trace API can be used to quickly get started tracing and debugging transactions on Moonbeam and Moonriver. It is only available to users on their Growth and Ultimate plans.</p> <p>To use the Trace API, you simply call the trace method of your choice from your private RPC endpoint. For a list of the supported networks and trace methods, please check out OnFinality's Trace API documentation.</p> <p>Please note that if you are tracing historic blocks, it is recommended to use your own dedicated trace node to backfill any data, and then once you're caught up, you can switch to using the Trace API. You can check out the How to Deploy a Trace Node for Moonbeam on OnFinality post for more information on how to spin up your own dedicated trace node.</p>"},{"location":"builders/get-started/explorers/","title":"Block Explorers","text":""},{"location":"builders/get-started/explorers/#introduction","title":"Introduction","text":"<p>Block explorers can be thought of as search engines for the blockchain. They allow users to search for information such as balances, contracts, and transactions. More advanced block explorers even offer indexing capabilities, which enable them to provide a complete set of information, such as ERC-20 tokens in the network. They might even offer API services to access it via external services.</p> <p>Moonbeam provides two different kinds of explorers: ones to query the Ethereum API and others  dedicated to the Substrate API. All EVM-based transactions are accessible via the Ethereum API, while the Substrate API can be relied upon for Substrate-native functions such as governance and staking. The Substrate API also includes information about the EVM-based transactions, but only limited information is shown.</p>"},{"location":"builders/get-started/explorers/#quick-links","title":"Quick Links","text":"MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node Block Explorer Type URL Moonscan EVM https://moonbeam.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=Moonbeam Subscan Substrate https://moonbeam.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Moonscan EVM https://moonriver.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=Moonriver Subscan Substrate https://moonriver.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Moonscan EVM https://moonbase.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=MoonbaseAlpha Subscan Substrate https://moonbase.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Expedition EVM https://moonbeam-explorer.netlify.app/?network=MoonbeamDevNode Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer"},{"location":"builders/get-started/explorers/#ethereum-api","title":"Ethereum API","text":""},{"location":"builders/get-started/explorers/#Moonscan","title":"Moonscan","text":"<p>Moonscan is the primary Ethereum API block explorer for Moonbeam-based networks. Built by the Etherscan team, Moonscan provides a powerful, intuitive, and feature-rich experience. In addition to its comprehensive transaction and block data, Moonscan provides a number of statistics and charts, such as average gas price, daily transactions, and block size charts.</p> <p>Other Moonscan features include:</p> <ul> <li>Collator leaderboard ranking collators by performance</li> <li>Contract source code verification, accessible both via a web interface and an API</li> <li>Ability to read and write state data of verified smart contracts</li> <li>Token approvals where you can view and revoke any of your prior token approvals</li> <li>Adding token information and creating a profile for ERC-20s, ERC-721s, and ERC-1155s deployed to Moonbeam-based networks. The profile can include links to your project, social media, price data, and other information pertaining to your token</li> </ul> <p></p>"},{"location":"builders/get-started/explorers/#expedition","title":"Expedition","text":"<p>A Moonbeam-themed version of the Expedition explorer can be found in this link. It is a basic JSON-RPC based explorer.</p> <p>By default, the explorer is connected to Moonbeam. However, you can switch to Moonriver or Moonbase Alpha, or connect it to a local dev node by following the next steps:</p> <ol> <li>Click on the network text, where you'll be able to select between all different networks, including a Moonbeam Development Node running on <code>http://127.0.0.1:9944</code></li> <li>In the case you want to connect to a specific RPC URL, select Add Custom Chain and enter the URL. For example, <code>http://localhost:9937</code></li> </ol> <p></p>"},{"location":"builders/get-started/explorers/#substrate-api","title":"Substrate API","text":""},{"location":"builders/get-started/explorers/#subscan","title":"Subscan","text":"<p>Subscan is the primary Substrate API block explorer for Moonbeam-based networks. Subscan is capable of parsing standard or custom modules. For example, this is useful to display information regarding the Staking, Governance, and EVM pallets (or modules). The code is all open-source and can be found in the Subscan Essentials GitHub repo.</p> <p></p>"},{"location":"builders/get-started/explorers/#polkadotjs","title":"Polkadot.js","text":"<p>While not a full-featured block explorer, Polkadot.js Apps is a convenient option especially for users running local development nodes to view events and query transaction hashes. Polkadot.js Apps uses the WebSocket endpoint to interact with the Network. You can easily connect to Moonbeam, Moonriver, or Moonbase Alpha.</p> <p></p> <p>To connect it to a Moonbeam development node, you can follow the steps in the Connecting Polkadot.js Apps to a Local Moonbeam Node section of the Getting Started with a Moonbeam Development Node guide. The default port for this is <code>9944</code>.</p> <p></p>"},{"location":"builders/get-started/quick-start/","title":"Quick Start Guide for Developing on Moonbeam","text":""},{"location":"builders/get-started/quick-start/#overview","title":"Quick Overview","text":"<p>Moonbeam is a fully Ethereum-compatible smart contract platform on Polkadot. As such, you can interact with Moonbeam via the Ethereum API and Substrate API.</p> <p>Although Moonbeam is a Substrate-based platform, Moonbeam uses a unified accounts system, which replaces Substrate-style accounts and keys with Ethereum-style accounts and keys. As a result, you can interact with your Moonbeam account with MetaMask, Ledger, and other Ethereum-compatible wallets by simply adding Moonbeam's network configurations. Similarly, you can develop on Moonbeam using Ethereum libraries and development environments.</p>"},{"location":"builders/get-started/quick-start/#moonbeam-networks","title":"Moonbeam Networks","text":"<p>To get started developing on Moonbeam, it's important to be aware of the various networks within the Moonbeam ecosystem.</p> Network Network Type Relay Chain Native Asset Symbol Native Asset Decimals Moonbeam MainNet Polkadot GLMR 18 Moonriver MainNet Kusama MOVR 18 Moonbase Alpha TestNet Alphanet relay DEV 18 Moonbeam Development Node Local TestNet None DEV 18 <p>Note</p> <p>A Moonbeam development node doesn't have a relay chain as its purpose is to be your own personal development environment where you can get started developing quickly without the overhead of a relay chain.</p>"},{"location":"builders/get-started/quick-start/#network-configurations","title":"Network Configurations","text":"<p>When working with developer tools, depending on the tool, you might need to configure Moonbeam to interact with the network. To do so, you can use the following information:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node Variable Value Chain ID <pre><code>1284</code></pre> Public RPC URLs <pre><code>https://rpc.api.moonbeam.network</code></pre> <pre><code>https://moonbeam.unitedbloc.com</code></pre> Public WSS URLs <pre><code>wss://wss.api.moonbeam.network</code></pre> Variable Value Chain ID <pre><code>1285</code></pre> Public RPC URLs <pre><code>https://rpc.api.moonriver.moonbeam.network</code></pre> <pre><code>https://moonriver.unitedbloc.com</code></pre> Public WSS URLs <pre><code>wss://wss.api.moonriver.moonbeam.network</code></pre> Variable Value Chain ID <pre><code>1287</code></pre> Public RPC URLs <pre><code>https://rpc.api.moonbase.moonbeam.network</code></pre> Public WSS URLs <pre><code>wss://wss.api.moonbase.moonbeam.network</code></pre> Variable Value Chain ID <pre><code>1281</code></pre> Local RPC URL <pre><code>http://127.0.0.1:9944</code></pre> Local WSS URL <pre><code>ws://127.0.0.1:9944</code></pre> <p>Note</p> <p>You can create your own endpoint suitable for development or production from one of the supported RPC providers.</p>"},{"location":"builders/get-started/quick-start/#explorers","title":"Block Explorers","text":"<p>Moonbeam provides two different kinds of explorers: ones to query the Ethereum API, and others dedicated to the Substrate API. All EVM-based transactions are accessible via the Ethereum API whereas the Substrate API can be relied upon for Substrate-native functions such as governance, staking, and some information about EVM-based transactions. For more information on each explorer, please check out the Block Explorers page.</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node Block Explorer Type URL Moonscan EVM https://moonbeam.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=Moonbeam Subscan Substrate https://moonbeam.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Moonscan EVM https://moonriver.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=Moonriver Subscan Substrate https://moonriver.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Moonscan EVM https://moonbase.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=MoonbaseAlpha Subscan Substrate https://moonbase.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Expedition EVM https://moonbeam-explorer.netlify.app/?network=MoonbeamDevNode Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer"},{"location":"builders/get-started/quick-start/#testnet-tokens","title":"Funding TestNet Accounts","text":"<p>To get started developing on one of the TestNets, you'll need to fund your account with DEV tokens to send transactions. Please note that DEV tokens have no real value and are for testing purposes only.</p> TestNet Where To Get Tokens From Moonbase Alpha The Moonbase Alpha Faucet website.  The faucet dispenses 1.1 DEV tokens every 24 hours Moonbeam Development Node Any of the ten pre-funded accounts that come with your  development node"},{"location":"builders/get-started/quick-start/#development-tools","title":"Development Tools","text":"<p>As Moonbeam is a Substrate-based chain that is fully Ethereum-compatible, you can use Substrate-based tools and Ethereum-based tools.</p>"},{"location":"builders/get-started/quick-start/#javascript","title":"JavaScript Tools","text":"EthereumSubstrate Tool Type Ethers.js Library Web3.js Library Hardhat Dev Environment OpenZeppelin Dev Environment Remix Dev Environment Scaffold-Eth Dev Environment thirdweb Dev Environment Waffle &amp; Mars Dev Environment Tool Type Polkadot.js API Library"},{"location":"builders/get-started/quick-start/#python","title":"Python Tools","text":"EthereumSubstrate Tool Type Web3.py Library Ape Dev Environment Tool Type Py Substrate Interface Library"},{"location":"builders/get-started/token-profile/","title":"Add Token Information on Moonscan","text":""},{"location":"builders/get-started/token-profile/#introduction","title":"Introduction","text":"<p>This tutorial will guide you through the process of adding a profile for your ERC-20, ERC-721, or ERC-1155 tokens to Moonscan.</p> <p>\u200b\u200bMoonscan is a block explorer and analytics platform for EVM-compatible chains. It is an integration of Moonbeam and Etherscan, and it allows users and developers to have access to developer tools and network statistics that provide granular insights into the EVM of Moonriver and Moonbeam.</p> <p>Developers can create a profile for their tokens on Moonriver and Moonbeam. The profile captures basic information about the project behind the token, social media links, links to price data, and other information pertaining to the project\u2019s token sales.</p> <p></p> <p>This tutorial will show you how to create a profile on Moonscan of a sample ERC-20 token, called DemoToken (DEMO), deployed to Moonriver. These instructions can be adapted for any of the Moonbeam-based networks, as well as for an ERC-721 or ERC-1155 token.</p>"},{"location":"builders/get-started/token-profile/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have the following:</p> <ul> <li>A Moonscan Account</li> </ul> <p>You will need to verify ownership of the token contract address later on in this guide. You can either do this manually or automatically, but if you choose to do it automatically you'll also need the following:</p> <ul> <li>Access to the account that deployed the token contract, so you can sign messages as the owner</li> <li>MetaMask installed and connected to the network where the token is deployed to</li> </ul>"},{"location":"builders/get-started/token-profile/#getting-started","title":"Getting Started","text":"<p>To get started, you'll need to make sure that you are logged into your Moonscan account. Once you\u2019re signed into your account, you can go to the token page of the token you want to add a profile for. For ERC-20s, you can search the name of the token in the search bar. Or for any token, you can manually enter in the URL.</p> MoonbeamMoonriverMoonbase Alpha <pre><code>https://moonscan.io/token/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>https://moonriver.moonscan.io/token/INSERT_CONTRACT_ADDRESS \n</code></pre> <pre><code>https://moonbase.moonscan.io/token/INSERT_CONTRACT_ADDRESS\n</code></pre> <p>Next to Social Profiles, you can click on Update.</p> <p></p> <p>You\u2019ll be taken to the Token Update Application Form.</p> <p>If you haven\u2019t verified your contract source code yet, you will need to do so before you can proceed to the next step. If you have already verified your contract, you can skip ahead to the Verifying Address Ownership section.</p>"},{"location":"builders/get-started/token-profile/#verifying-contract-source-code","title":"Verifying Contract Source Code","text":"<p>You can verify your contract source code a couple of ways. You can directly verify it from Moonscan, or if you developed the contract with Hardhat or Foundry, you can also use their corresponding Etherscan integrations.</p> <p>To verify your contract source code directly from Moonscan, you can click on the tool link.</p> <p></p> <p>You\u2019ll be taken to the Verify &amp; Publish Contract Source Code page where you can enter in details about the contract and how it was compiled.</p> <ol> <li>Enter the token contract address</li> <li>Select the Compiler Type from the dropdown</li> <li>Choose the Compile Version you used</li> <li>Then select an Open Source License Type</li> <li>Review and click the I agree to the terms of service checkbox</li> <li>Click Continue</li> </ol> <p></p> <p>You\u2019ll be taken to the next page where you can enter in the contract source code and specify additional settings and arguments used.</p> <ol> <li>Contract Address and Compiler should already be filled in. If you enabled optimization, you can update the Optimization dropdown</li> <li>Enter in a flattened version of the contract source code. To flatten the contract, you can use the Flattener Remix plugin</li> <li>Update the Constructor Arguments, Contract Library Address, and Misc Settings sections if needed</li> <li>Click I\u2019m not a robot</li> <li>Finally, click Verify and Publish</li> </ol> <p></p> <p>Now that your contract source code has been verified, you can move on to the next step, verifying that you\u2019re the contract address owner.</p>"},{"location":"builders/get-started/token-profile/#verifying-address-ownership","title":"Verifying Address Ownership","text":"<p>From the Token Update Application Form page, you should see a message at the top of the screen that states you need to verify the contract address owner. To get started with this process, you can click on the tool link.</p> <p></p> <p>You\u2019ll be taken to the Verify Address Ownership page, where you can choose to sign the message verifying your ownership either manually or by connecting to Web3. If you wish to verify ownership manually, you\u2019ll need the message signature hash. Otherwise, if you connect to Web3, the hash will be calculated for you.</p> <p></p>"},{"location":"builders/get-started/token-profile/#sign-message-manually","title":"Sign Message Manually","text":"<p>If you wish to verify ownership manually, you\u2019ll need the message signature hash. If you have calculated the hash yourself, you can click Sign Message Manually, enter the Message Signature Hash, and click Verify Ownership.</p> <p></p>"},{"location":"builders/get-started/token-profile/#connect-to-web3","title":"Connect to Web3","text":"<p>You can easily calculate the message signature hash using MetaMask. You will need to have the account you deployed the contract with loaded into MetaMask. Then you can click on Connect to Web3 and MetaMask will pop-up.</p> <ol> <li>Select the account to connect with, which should be the account you used to deploy the contract</li> <li>Connect to the account</li> </ol> <p></p> <p>Back on the Verify Address Ownership page, you can take the following steps</p> <ol> <li>Click Sign with Web3</li> <li>MetaMask will pop-up and you can Sign the message</li> </ol> <p></p> <p>Once you\u2019ve signed the message, you can then click Click to Proceed. You should now see that the Message Signature Hash has been automatically populated for you. All you have left to do is click Verify Ownership.</p> <p></p>"},{"location":"builders/get-started/token-profile/#creating-the-profile","title":"Creating the Profile","text":"<p>Now you can start filling in the necessary information to build the token profile, including project information, social media links, price data links, and more. You should make sure that all the links provided are working and are safe to visit before submitting.</p> <p>At a minimum you will need to fill in the following information:</p> <ul> <li>Request Type</li> <li>Token Contract Address</li> <li>Requester Name</li> <li>Requester Email Address</li> <li>Official Project Website</li> <li>Official Project Email Address</li> <li>Link to download a 32x32 png icon logo</li> <li>Project Description</li> </ul> <p>All of the other fields are optional. Once you\u2019ve filled in the information, you can click Submit at the bottom of the page.</p> <p></p> <p>And that\u2019s it! You\u2019ve successfully created and submitted a profile for your token on Moonscan! The Moonscan team will review your submission as soon as possible and provide you with further instructions as needed.</p>"},{"location":"builders/get-started/networks/moonbase/","title":"Get Started with Moonbase Alpha","text":""},{"location":"builders/get-started/networks/moonbase/#network-endpoints","title":"Network Endpoints","text":"<p>Moonbase Alpha has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.</p> <p>If you're looking for your own endpoints suitable for production use, you can check out the Endpoint Providers section of our documentation. Otherwise, to get started quickly you can use one of the following public HTTPS or WSS endpoints.</p> HTTPSWSS Provider RPC URL Limits Dwellir <pre><code>https://moonbase-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>https://moonbeam-alpha.api.onfinality.io/public</code></pre> 40 req/sec Moonbeam Foundation <pre><code>https://rpc.api.moonbase.moonbeam.network</code></pre> 25 req/sec UnitedBloc <pre><code>https://moonbase.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonbase.public.curie.radiumblock.co/http</code></pre> 200 req/sec Provider RPC URL Limits Dwellir <pre><code>wss://moonbase-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>wss://moonbeam-alpha.api.onfinality.io/public-ws</code></pre> 40 req/sec Moonbeam Foundation <pre><code>wss://wss.api.moonbase.moonbeam.network</code></pre> 25 req/sec UnitedBloc <pre><code>wss://moonbase.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonbase.public.curie.radiumblock.co/ws</code></pre> 200 req/sec"},{"location":"builders/get-started/networks/moonbase/#relay-chain","title":"Relay Chain","text":"<p>To connect to the Moonbase Alpha relay chain, you can use the following WS Endpoint:</p> Provider RPC URL OpsLayer <pre><code>wss://relay.api.moonbase.moonbeam.network</code></pre>"},{"location":"builders/get-started/networks/moonbase/#quick-start","title":"Quick Start","text":"<p>For the Web3.js library, you can create a local Web3 instance and set the provider to connect to Moonbase Alpha (both HTTP and WS are supported):</p> <pre><code>const { Web3 } = require('web3'); // Load Web3 library\n.\n.\n.\n// Create local Web3 instance - set Moonbase Alpha as provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); \n</code></pre> <p>For the Ethers.js library, define the provider by using <code>ethers.JsonRpcProvider(providerURL, {object})</code> and setting the provider URL to Moonbase Alpha:</p> <pre><code>const ethers = require('ethers'); // Load Ethers library\n\nconst providerURL = 'https://rpc.api.moonbase.moonbeam.network';\n// Define provider\nconst provider = new ethers.JsonRpcProvider(providerURL, {\n    chainId: 1287,\n    name: 'moonbase-alphanet'\n});\n</code></pre> <p>Any Ethereum wallet should be able to generate a valid address for Moonbeam (for example, MetaMask).</p>"},{"location":"builders/get-started/networks/moonbase/#chain-id","title":"Chain ID","text":"<p>Moonbase Alpha TestNet chain ID is: <code>1287</code>, which is <code>0x507</code> in hex.</p>"},{"location":"builders/get-started/networks/moonbase/#block-explorers","title":"Block Explorers","text":"<p>For Moonbase Alpha, you can use any of the following block explorers:</p> <ul> <li>Ethereum API (Etherscan Equivalent) \u2014 Moonscan</li> <li>Ethereum API JSON-RPC based \u2014 Moonbeam Basic Explorer</li> <li>Substrate API \u2014 Subscan or Polkadot.js Apps</li> </ul> <p>For more information on each of the available block explorers, please head to the Block Explorers section of the documentation.</p>"},{"location":"builders/get-started/networks/moonbase/#connect-metamask","title":"Connect MetaMask","text":"<p>If you already have MetaMask installed, you can easily connect MetaMask to the Moonbase Alpha TestNet:</p> Connect MetaMask <p>Note</p> <p>MetaMask will popup asking for permission to add Moonbase Alpha as a custom network. Once you approve permissions, MetaMask will switch your current network to Moonbase Alpha.</p> <p>If you do not have MetaMask installed, or would like to follow a tutorial to get started, please check out the Interacting with Moonbeam using MetaMask guide.</p>"},{"location":"builders/get-started/networks/moonbase/#configuration","title":"Configuration","text":"<p>Please note the following gas configuration parameters. These values are subject to change in future runtime upgrades.</p> Variable Value Minimum gas price 0.03125 Gwei Target block time 6 seconds Block gas limit 60,000,000 Transaction gas limit 52,000,000"},{"location":"builders/get-started/networks/moonbase/#get-tokens","title":"Get Tokens","text":"<p>To start building on Moonbase Alpha, you can get DEV tokens from the Moonbase Alpha Faucet. For specific amounts, you can always reach out directly to us via our community channels.</p> <p>To request DEV tokens from the faucet, you can enter your address on the Moonbase Alpha Faucet website. The faucet dispenses 1.1 DEV tokens every 24 hours.</p> <p></p> <p>Note</p> <p>Moonbase Alpha DEV tokens have no value. Please don't spam the faucet with unnecessary requests.</p>"},{"location":"builders/get-started/networks/moonbase/#Demo-DApps","title":"Demo DApps","text":"<p>There are a variety of DApps deployed to Moonbase Alpha enabling you to experiment with various apps and integrations. You can also acquire a variety of test tokens through the Moonbase ERC20 Minter or Moonbeam Uniswap DApps. For example, Moonbeam Uniswap can help you acquire cross-chain assets such as xcUNIT or xcKarura for testing XCM related functions. In the below table, you'll find each sample DApp, its associated URL, and GitHub repository.</p>"},{"location":"builders/get-started/networks/moonbase/#quick-links","title":"Quick Links","text":"DApp Description Repository Moonbase ERC-20 Minter ERC-20 Faucet https://github.com/papermoonio/moonbase-mintableERC20 Moonbeam Uniswap Uniswap V2 Fork https://github.com/papermoonio/moonbeam-uniswap <p>|        MoonLotto Lottery        |   TheGraph Demo    | Interface, Subgraph | | Moonbeam WalletConnect | WalletConnect Demo |            https://github.com/papermoonio/moonbeam-walletconnect-demo             | |              MoonGas              | Gas Price Tracker  |                    https://github.com/albertov19/moonbeam-gas-station                     |</p> <p>Note</p> <p>These DApps are intended for demonstration purposes only and may be incomplete or unsuitable for production deployments.</p>"},{"location":"builders/get-started/networks/moonbase/#moonbase-erc20-minter","title":"Moonbase ERC20 Minter","text":"<p>The Moonbase ERC-20 Minter enables you to mint a variety of ERC-20 test tokens corresponding to the 8 planets of the solar system, and Pluto. To mint tokens, first press Connect MetaMask in the upper right hand corner. Then scroll to the Mint Tokens section and the choose desired ERC-20 contract. Press Submit Tx and confirm the transaction in MetaMask. Each mint will grant you 100 tokens, and you can mint tokens for each contract once per hour.</p> <p></p>"},{"location":"builders/get-started/networks/moonbase/#moonbeam-uniswap","title":"Moonbeam Uniswap","text":"<p>Moonbeam Uniswap is a fork of Uniswap-V2 deployed to Moonbase Alpha. Notably, Moonbeam Uniswap allows developers to easily make a swap to acquire cross-chain assets such as xcKarura or xcUNIT for XCM testing purposes. To perform your first swap, take the following steps:</p> <ol> <li>Press Select a token</li> <li>Connect your MetaMask wallet and ensure you're on the Moonbase Alpha network</li> <li>Press Choose a List on the prompt</li> <li>Select Moon Menu</li> <li>Search for or select your desired asset from the list then continue with the swap</li> </ol> <p></p> <p>Note</p> <p>If you see only a partial list of assets under Moon Menu, your browser may have cached an older version of Moon Menu. Clearing the cache and re-adding Moon Menu will resolve this.</p>"},{"location":"builders/get-started/networks/moonbase/#moonlotto-lottery","title":"MoonLotto Lottery","text":"<p>MoonLotto is a simple lottery game on Moonbase Alpha derived from The Graph's Example Subgraph.  Purchasing a ticket costs 1 DEV and a winner is chosen each half hour if there are at least 10 participants. MoonLotto.sol holds the contract logic for the lottery. To participate, take the following steps:</p> <ol> <li>Connect your MetaMask wallet and ensure you're on the Moonbase Alpha network</li> <li>Enter the address of the recipient of lotto ticket or check I want to buy a ticket for my address</li> <li>Press Submit on MetaMask and confirm the transaction in MetaMask</li> </ol> <p></p>"},{"location":"builders/get-started/networks/moonbase/#moonbeam-walletconnect","title":"Moonbeam WalletConnect","text":"<p>Moonbeam WalletConnect shows how easy it is to integrate WalletConnect into your DApps and unlock support for a great variety of crypto wallets. Be sure to check out the demo app repository to see exactly how the WalletConnect integration works. To get started, you can take the following steps:</p> <ol> <li>Press Connect Wallet</li> <li>Scan the QR code using a wallet compatible with WalletConnect</li> </ol> <p></p>"},{"location":"builders/get-started/networks/moonbase/#moongas","title":"MoonGas","text":"<p>MoonGas is a convenient dashboard for viewing the minimum, maximum, and average gas price of transactions in the prior block across all Moonbeam networks. Note, these statistics can fluctuate widely by block and occasionally include outlier values. You can check out the repository for MoonGas.</p> <p>You'll notice that the minimum gas price for Moonbeam is 31.25 Gwei, while the minimum for Moonriver is 0.3125 Gwei and Moonbase Alpha is 0.03125 Gwei. This difference stems from the 100 to 1 re-denomination of GLMR and thus the 31.25 Gwei minimum on Moonbeam corresponds to a 0.3125 Gwei minimum on Moonriver and a 0.03125 Gwei on Moonbase.</p> <p></p>"},{"location":"builders/get-started/networks/moonbeam-dev/","title":"Getting Started with a Local Moonbeam Development Node","text":""},{"location":"builders/get-started/networks/moonbeam-dev/#introduction","title":"Introduction","text":"<p>A Moonbeam development node is your own personal development environment for building and testing applications on Moonbeam. For Ethereum developers, it is comparable to the Hardhat Network. It enables you to get started quickly and easily without the overhead of a relay chain. You can spin up your node with the <code>--sealing</code> option to author blocks instantly, manually, or at a custom interval after transactions are received. By default, a block will be created when a transaction is received, which is similar to the default behavior of Hardhat Network's instamine feature.</p> <p>If you follow this guide to the end, you will have a Moonbeam development node running in your local environment with 10 prefunded accounts.</p> <p>Note</p> <p>This tutorial was created using the v0.47.0 tag of Moonbase Alpha. The Moonbeam platform and the Frontier components it relies on for Substrate-based Ethereum compatibility are still under very active development. The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#spin-up-a-node","title":"Spin Up a Moonbeam Development Node","text":"<p>There are two ways to get started running a Moonbeam node. You can use Docker to run a pre-built binary or you can compile the binary locally and set up a development node yourself. Using Docker is a quick and convenient way to get started, as you won't have to install Substrate and all the dependencies, and you can skip the node-building process as well. It does require you to install Docker. On the other hand, if you decide you want to go through the process of building your development node, it could take roughly 30 minutes or longer to complete, depending on your hardware.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#getting-started-with-docker","title":"Spin Up a Node with Docker","text":"<p>Using Docker enables you to spin up a node in a matter of seconds. Once you have Docker installed, you can take the following steps to spin up your node:</p> <ol> <li> <p>Execute the following command to download the latest Moonbeam image:</p> <pre><code>docker pull moonbeamfoundation/moonbeam:v0.47.0\n</code></pre> <p>The tail end of the console log should look like this:</p> <p> docker pull moonbeamfoundation/moonbeam:v0.47.0 v0.47.0: Pulling from moonbeamfoundation/moonbeam      b0a0cf830b12: Pull complete      fbff687640dd: Pull complete      58ea427410e2: Pull complete      811ba55e6e61: Pull complete      4316d5f1b914: Pull complete      128693ce218e: Pull complete      a3ac90b88463: Pull complete      Digest: sha256:86421aca2381265cd2e5283cb98705e24be0bc92a73937363f79d9d6e0d62088      Status: Downloaded newer image for moonbeamfoundation/moonbeam:v0.47.0      docker.io/moonbeamfoundation/moonbeam:v0.47.0      Status: Downloaded newer image for moonbeamfoundation/moonbeam:v0.46.0      docker.io/moonbeamfoundation/moonbeam:v0.46.0    </p> </li> <li> <p>Spin up a Moonbeam development node by running the following Docker command, which will launch the node in instant seal mode for local testing so that blocks are authored instantly as transactions are received:</p> UbuntuMacOSWindows <pre><code>docker run --rm --name moonbeam_development --network host \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--dev --rpc-external\n</code></pre> <pre><code>docker run --rm --name moonbeam_development -p 9944:9944 \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--dev --rpc-external\n</code></pre> <pre><code>docker run --rm --name moonbeam_development -p 9944:9944 ^\nmoonbeamfoundation/moonbeam:v0.47.0 ^\n--dev --rpc-external\n</code></pre> <p>For Apple Silicon users</p> <p>If the Docker commands fail or behave unexpectedly on Apple Silicon, enable Use Rosetta for x86_64/amd64 emulation on Apple Silicon in Docker Desktop settings and use the <code>amd64</code> platform for both pull and run commands:</p> <pre><code>docker pull --platform=linux/amd64 moonbeamfoundation/moonbeam:v0.47.0\n</code></pre> <pre><code>docker run --rm --platform=linux/amd64 --name moonbeam_development -p 9944:9944 \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--dev --rpc-external\n</code></pre> <p>If performance is still insufficient, consider spinning up a node with a binary file.</p> </li> </ol> <p>If successful, you should see an output showing an idle state waiting for blocks to be authored:</p> docker run --rm --name moonbeam_development --network host \\      moonbeamfoundation/moonbeam:v0.47.0 \\      --dev --rpc-external    CLI parameter `--execution` has no effect anymore and will be removed in the future!      2025-07-10 09:04:26 Moonbeam Parachain Collator      2025-07-10 09:04:26 \u270c\ufe0f  version 0.47.0-d7df89e7161      2025-07-10 09:04:26 \u2764\ufe0f  by PureStake, 2019-2025      2025-07-10 09:04:26 \ud83d\udccb Chain specification: Moonbase Development Testnet      2025-07-10 09:04:26 \ud83c\udff7  Node name: black-and-white-sticks-9174      2025-07-10 09:04:26 \ud83d\udc64 Role: AUTHORITY      2025-07-10 09:04:26 \ud83d\udcbe Database: RocksDb at /tmp/substrateO3YeRz/chains/moonbase_dev/db/full      2025-07-10 09:04:26 \ud83d\udd28 Initializing Genesis block/state (state: 0xf7c4\u20265c0f, header-hash: 0x42bd\u20263b5b)      2025-07-10 09:04:26 Using default protocol ID \"sup\" because none is configured in the chain specs      2025-07-10 09:04:26 \ud83c\udff7  Local node identity is: 12D3KooWLcpczme2JeBEfLqmjqkzYVKTGKhhGmwSzHjRXGBVhDX7      2025-07-10 09:04:26 \ud83d\udcbb Operating system: linux      2025-07-10 09:04:26 \ud83d\udcbb CPU architecture: x86_64      2025-07-10 09:04:26 \ud83d\udcbb Target environment: gnu      2025-07-10 09:04:26 \ud83d\udcbb CPU: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz      2025-07-10 09:04:26 \ud83d\udcbb CPU cores: 12      2025-07-10 09:04:26 \ud83d\udcbb Memory: 7946MB      2025-07-10 09:04:26 \ud83d\udcbb Kernel: 6.4.16-linuxkit      2025-07-10 09:04:26 \ud83d\udcbb Linux distribution: Debian GNU/Linux 12 (bookworm)      2025-07-10 09:04:26 \ud83d\udcbb Virtual machine: yes      2025-07-10 09:04:26 \ud83d\udce6 Highest known block at #0      2025-07-10 09:04:26 Running JSON-RPC server: addr=0.0.0.0:9944, allowed origins=[\"*\"]      2025-07-10 09:04:26 \ud83c\udfc1 CPU score: 1.14 GiBs      2025-07-10 09:04:26 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615      2025-07-10 09:04:26 \ud83c\udfc1 Memory score: 10.41 GiBs      2025-07-10 09:04:26 \ud83c\udfc1 Disk score (seq. writes): 987.96 MiBs      2025-07-10 09:04:26 \ud83c\udfc1 Disk score (rand. writes): 363.65 MiBs      2025-07-10 09:04:26 Development Service Ready      2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0xa083\u2026f354), finalized #0 (0xa083\u2026f354), \u2b07 0 \u2b06 0      2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0xa083\u2026f354), finalized #0 (0xa083\u2026f354), \u2b07 0 \u2b06 0    <p>For more information on some of the flags and options used in the example, check out Flags and Options. If you want to see a complete list of all of the flags, options, and subcommands, open the help menu by running:</p> <pre><code>docker run --rm --name moonbeam_development \\\nmoonbeamfoundation/moonbeam \\\n--help\n</code></pre> <p>To continue with the tutorial, the next section is not necessary, as you've already spun up a node with Docker. You can skip ahead to the Configure your Moonbeam Development Node section.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#getting-started-with-the-binary-file","title":"Spin Up a Node with a Binary File","text":"<p>As an alternative to using Docker, you can spin up a node using the Moonbeam binary. This method is more time-consuming. Depending on your hardware, the process could take around 30 minutes to complete.</p> <p>Note</p> <p>If you know what you are doing, you can directly download the precompiled binaries attached to each release on the Moonbeam release page. These will not work in all systems. For example, the binaries only work with x86-64 Linux with specific versions of dependencies. The safest way to ensure compatibility is to compile the binary on the system where it will be run.</p> <p>To build the binary file, you can take the following steps:</p> <ol> <li> <p>Clone a specific tag of the Moonbeam repo, which you can find on the Moonbeam GitHub repository:</p> <pre><code>git clone -b v0.47.0 https://github.com/moonbeam-foundation/moonbeam\ncd moonbeam\n</code></pre> <p>Note</p> <p>Spaces in the installation file path will cause a compilation error.</p> </li> <li> <p>If you already have Rust installed, you can skip the next two steps. Otherwise, install Rust and its prerequisites via Rust's recommended method by executing:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> </li> <li> <p>Update your PATH environment variable by running:</p> <pre><code>source $HOME/.cargo/env\n</code></pre> </li> <li> <p>Build the development node by running:</p> <p>Note</p> <p>If you are using Ubuntu 20.04 or 22.04, then you will need to make sure these additional dependencies have been installed before building the binary:</p> <pre><code>apt install clang protobuf-compiler libprotobuf-dev pkg-config libssl-dev -y \n</code></pre> <p>For MacOS users, these dependencies can be installed via Homebrew:</p> <pre><code>brew install llvm\nbrew install protobuf\n</code></pre> <pre><code>cargo build --release\n</code></pre> <p>Here is what the tail end of the build output should look like:</p> <p> Compiling try-runtime-cli v0.9.0 (https://github.com/paritytech/substrate?branch=rococo-v1#401c24e8)      Compiling frame-benchmarking-cli v3.0.0 (https://github.com/paritytech/substrate?branch=rococo-v1#401c24e8)      Compiling cumulus-client-cli v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Compiling moonbeam-rpc-txpool v0.6.0 (/home/purestake/moonbeam/client/rpc/txpool)      Compiling moonbeam-rpc-debug v0.1.0 (/home/purestake/moonbeam/client/rpc/debug)      Compiling moonbeam-rpc-trace v0.6.0 (/home/purestake/moonbeam/client/rpc/trace)      Compiling cumulus-client-network v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Compiling cumulus-client-consensus-relay-chain v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Compiling polkadot-test-service v0.8.29 (https://github.com/paritytech/polkadot?branch=rococo-v1#b64741e6)      Compiling cumulus-client-collator v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Compiling cumulus-client-service v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Finished release [optimized] target(s) in 31m 17s    </p> </li> </ol> <p>Note</p> <p>The initial build will take a while. Depending on your hardware, you should expect approximately 30 minutes for the build process to finish.</p> <p>Then, you will want to run the node in development mode using the following command:</p> <pre><code>./target/release/moonbeam --dev\n</code></pre> <p>Note</p> <p>For people not familiar with Substrate, the <code>--dev</code> flag is a way to run a Substrate-based node in a single-node developer configuration for testing purposes. When you run your node with the <code>--dev</code> flag, your node is started in a fresh state, and its state does not persist.</p> <p>You should see an output that looks like the following, showing an idle state waiting for blocks to be produced:</p> ./target/release/moonbeam --dev  2025-07-10 09:04:26 Moonbeam Parachain Collator      2025-07-10 09:04:26 \u270c\ufe0f  version 0.47.0-d7df89e7161      2025-07-10 09:04:26 \u2764\ufe0f  by PureStake, 2019-2025      2025-07-10 09:04:26 \ud83d\udccb Chain specification: Moonbase Development Testnet      2025-07-10 09:04:26 \ud83c\udff7  Node name: black-and-white-sticks-9174      2025-07-10 09:04:26 \ud83d\udc64 Role: AUTHORITY      2025-07-10 09:04:26 \ud83d\udcbe Database: RocksDb at /tmp/substrateO3YeRz/chains/moonbase_dev/db/full      2025-07-10 09:04:26 \ud83d\udd28 Initializing Genesis block/state (state: 0x7c34\u202699c5, header-hash: 0xa083\u2026f354)      2025-07-10 09:04:26 Using default protocol ID \"sup\" because none is configured in the chain specs      2025-07-10 09:04:26 \ud83c\udff7  Local node identity is: 12D3KooWLcpczme2JeBEfLqmjqkzYVKTGKhhGmwSzHjRXGBVhDX7      2025-07-10 09:04:26 \ud83d\udcbb Operating system: linux      2025-07-10 09:04:26 \ud83d\udcbb CPU architecture: x86_64      2025-07-10 09:04:26 \ud83d\udcbb Target environment: gnu      2025-07-10 09:04:26 \ud83d\udcbb CPU: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz      2025-07-10 09:04:26 \ud83d\udcbb CPU cores: 12      2025-07-10 09:04:26 \ud83d\udcbb Memory: 7946MB      2025-07-10 09:04:26 \ud83d\udcbb Kernel: 6.4.16-linuxkit      2025-07-10 09:04:26 \ud83d\udcbb Linux distribution: Debian GNU/Linux 12 (bookworm)      2025-07-10 09:04:26 \ud83d\udcbb Virtual machine: yes      2025-07-10 09:04:26 \ud83d\udce6 Highest known block at #0      2025-07-10 09:04:26 Running JSON-RPC server: addr=0.0.0.0:9944, allowed origins=[\"*\"]      2025-07-10 09:04:26 \ud83c\udfc1 CPU score: 1.14 GiBs      2025-07-10 09:04:26 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615      2025-07-10 09:04:26 \ud83c\udfc1 Memory score: 10.41 GiBs      2025-07-10 09:04:26 \ud83c\udfc1 Disk score (seq. writes): 987.96 MiBs      2025-07-10 09:04:26 \ud83c\udfc1 Disk score (rand. writes): 363.65 MiBs      2025-07-10 09:04:26 Development Service Ready      2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0xa083\u2026f354), finalized #0 (0xa083\u2026f354), \u2b07 0 \u2b06 0      2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0xa083\u2026f354), finalized #0 (0xa083\u2026f354), \u2b07 0 \u2b06 0    <p>For more information on some of the flags and options used in the example, check out the Flags and Options. If you want to see a complete list of all of the flags, options, and subcommands, open the help menu by running:</p> <pre><code>./target/release/moonbeam --help\n</code></pre>"},{"location":"builders/get-started/networks/moonbeam-dev/#configure-moonbeam-dev-node","title":"Configure Your Moonbeam Development Node","text":"<p>Now that you know how to get a standard Moonbeam development node up and running, you may be wondering how you can configure it. The following sections will cover some common configurations you can use when you spin up your node.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#node-flags","title":"Common Flags to Configure Your Node","text":"<p>Flags do not take an argument. To use a flag, add it to the end of a command. For example:</p> <pre><code>./target/release/moonbeam --dev\n</code></pre> <ul> <li><code>--dev</code> - specifies the development chain</li> <li><code>--tmp</code> - runs a temporary node in which all of the configuration will be deleted at the end of the process</li> <li><code>--rpc-external</code> - listen to all RPC and WebSocket interfaces</li> </ul>"},{"location":"builders/get-started/networks/moonbeam-dev/#node-options","title":"Common Options to Configure Your Node","text":"<p>Options accept an argument to the right of the option. For example:</p> <pre><code>./target/release/moonbeam --dev --sealing 6000\n</code></pre> <ul> <li><code>-l &lt;log pattern&gt;</code> or <code>--log &lt;log pattern&gt;</code> - sets a custom logging filter. The syntax for the log pattern is <code>&lt;target&gt;=&lt;level&gt;</code>. For example, to print all of the JSON-RPC logs, the command would look like this: <code>-l json=trace</code></li> <li><code>--sealing &lt;interval&gt;</code> - when blocks should be sealed in the dev service. Accepted arguments for interval: <code>instant</code>, <code>manual</code>, or a number representing the timer interval in milliseconds (for example, <code>6000</code> will have the node produce blocks every 6 seconds). The default is `instant``. Please refer to the Configure Block Production section below for more information</li> <li><code>--rpc-port &lt;port&gt;</code> - sets the unified port for HTTP and WS connections. Accepts a port as the argument. Default is 9944</li> <li><code>--ws-port &lt;port&gt;</code> - deprecated as of client v0.33.0, use <code>--rpc-port</code> for HTTP and WS connections instead - sets the WebSockets RPC server TCP port. As of client v0.30.0, it sets the unified port for both HTTP and WS connections. Accepts a port as the argument</li> <li><code>--rpc-max-connections &lt;connections&gt;</code> - specifies the combined HTTP and WS connection limit. The default is 100 connections</li> <li><code>--ws-max-connections &lt;connections&gt;</code> - deprecated as of client v0.33.0, use <code>--rpc-max-connections</code> to limit the HTTP and WS connections instead - this flag adjusts the combined HTTP and WS connection limit. The default is 100 connections</li> <li><code>--rpc-cors &lt;origins&gt;</code> - specifies the browser origins allowed to access the HTTP and WS RPC servers. The origins can be a comma-separated list of the origins to allow access, or you can also specify <code>null</code>. When running a development node, the default is to allow all origins</li> </ul> <p>For a complete list of flags and options, spin up your Moonbeam development node with <code>--help</code> added to the end of the command.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#configure-block-production","title":"Configure Block Production","text":"<p>By default, your Moonbeam development node is spun up in instant seal mode, which instantly authors blocks as transactions are received. However, you can specify when blocks should be authored or sealed by using the <code>--sealing</code> option.</p> <p>The <code>--sealing</code> flag accepts any of the following arguments:</p> <ul> <li><code>instant</code> - as we already covered, this is the default option in which blocks are authored as soon as a transaction is received</li> <li><code>manual</code> - allows you to produce blocks manually. If a transaction is received, a block will not be produced until you manually create one</li> <li>an interval in milliseconds - authors a block on a specific time interval. For example, if you set it to <code>6000</code>, you will have the node produce blocks every 6 seconds</li> </ul> <p>The flag should be appended to the start-up command in the following format:</p> <pre><code>--sealing &lt;interval&gt;\n</code></pre> <p>If you choose <code>manual</code>, you'll need to manually create the blocks yourself, which can be done with the <code>engine_createBlock</code> JSON-RPC method:</p> <pre><code>engine_createBlock(createEmpty: *bool*, finalize: *bool*, parentHash?: *BlockHash*)\n</code></pre> <p>For example, you can use the following snippet to manually create a block using Ethers.js, an Ethereum library that makes it easy to interact with JSON-RPC methods:</p> <pre><code>import { ethers } from 'ethers';\n\nconst produceBlock = async () =&gt; {\n  // Connect to the Ethereum node (if applicable, replace the URL with your node's address)\n  const provider = new ethers.JsonRpcProvider(\n    'http://127.0.0.1:9944'\n  );\n\n  // Set the custom JSON-RPC method and parameters\n  const method = 'engine_createBlock';\n  const params = [true, true, null];\n\n  try {\n    // Send the custom JSON-RPC call\n    const result = await provider.send(method, params);\n  } catch (error) {\n    // Handle any errors that may occur\n    console.error('Error:', error.message);\n  }\n};\n\nproduceBlock();\n</code></pre> <p>Note</p> <p>If you're unfamiliar with Ethers, please refer to the Ethers.js documentation page to learn more.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#pre-funded-development-accounts","title":"Prefunded Development Accounts","text":"<p>Moonbeam has a unified accounts system, which enables users to have an Ethereum-styled H160 account that can interact with the Substrate API and the Ethereum API. As a result, you can interact with your account through Polkadot.js Apps or MetaMask (or any other EVM wallet). In addition, you can also use other development tools, such as Remix and Hardhat.</p> <p>Your Moonbeam development node comes with ten prefunded Ethereum-styled accounts for development. The addresses are derived from Substrate's canonical development mnemonic:</p> <pre><code>bottom drive obey lake curtain smoke basket hold race lonely fit walk\n</code></pre> Development account addresses and private keys <ul> <li> <p>Alith:</p> <ul> <li>Public Address: <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>Private Key: <code>0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133</code></li> </ul> </li> <li> <p>Baltathar:</p> <ul> <li>Public Address: <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>Private Key: <code>0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b</code></li> </ul> </li> <li> <p>Charleth:</p> <ul> <li>Public Address: <code>0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</code></li> <li>Private Key: <code>0x0b6e18cafb6ed99687ec547bd28139cafdd2bffe70e6b688025de6b445aa5c5b</code></li> </ul> </li> <li> <p>Dorothy:</p> <ul> <li>Public Address: <code>0x773539d4Ac0e786233D90A233654ccEE26a613D9</code></li> <li>Private Key: <code>0x39539ab1876910bbf3a223d84a29e28f1cb4e2e456503e7e91ed39b2e7223d68</code></li> </ul> </li> <li> <p>Ethan:</p> <ul> <li>Public Address: <code>0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB</code></li> <li>Private Key: <code>0x7dce9bc8babb68fec1409be38c8e1a52650206a7ed90ff956ae8a6d15eeaaef4</code></li> </ul> </li> <li> <p>Faith:</p> <ul> <li>Public Address: <code>0xC0F0f4ab324C46e55D02D0033343B4Be8A55532d</code></li> <li>Private Key: <code>0xb9d2ea9a615f3165812e8d44de0d24da9bbd164b65c4f0573e1ce2c8dbd9c8df</code></li> </ul> </li> <li> <p>Goliath:</p> <ul> <li>Public Address: <code>0x7BF369283338E12C90514468aa3868A551AB2929</code></li> <li>Private Key: <code>0x96b8a38e12e1a31dee1eab2fffdf9d9990045f5b37e44d8cc27766ef294acf18</code></li> </ul> </li> <li> <p>Heath: </p> <ul> <li>Public Address: <code>0x931f3600a299fd9B24cEfB3BfF79388D19804BeA</code></li> <li>Private Key: <code>0x0d6dcaaef49272a5411896be8ad16c01c35d6f8c18873387b71fbc734759b0ab</code></li> </ul> </li> <li> <p>Ida: </p> <ul> <li>Public Address: <code>0xC41C5F1123ECCd5ce233578B2e7ebd5693869d73</code></li> <li>Private Key: <code>0x4c42532034540267bf568198ccec4cb822a025da542861fcb146a5fab6433ff8</code></li> </ul> </li> <li> <p>Judith: </p> <ul> <li>Public Address: <code>0x2898FE7a42Be376C8BC7AF536A940F7Fd5aDd423</code></li> <li>Private Key: <code>0x94c49300a58d576011096bcb006aa06f5a91b34b4383891e8029c21dc39fbb8b</code></li> </ul> </li> </ul> <p>Also included with the development node is an additional prefunded account used for testing purposes:</p> <ul> <li>Gerald:<ul> <li>Public Address: <code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code></li> <li>Private Key: <code>0x99b3c12287537e38c90a9219d4cb074a89a16e9cdb20bf85728ebd97c343e342</code></li> </ul> </li> </ul> <p>You can connect any of these accounts to MetaMask, Talisman, Polkadot.js Apps, etc., using their private keys.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#access-your-development-node","title":"Development Node Endpoints","text":"<p>You can access your Moonbeam development node using the following RPC and WSS endpoints:</p> HTTPWSS <pre><code>http://127.0.0.1:9944\n</code></pre> <pre><code>ws://127.0.0.1:9944\n</code></pre>"},{"location":"builders/get-started/networks/moonbeam-dev/#block-explorers","title":"Block Explorers","text":"<p>For a Moonbeam development node, you can use any of the following block explorers:</p> <ul> <li>Substrate API \u2014 Polkadot.js Apps on WS port <code>9944</code></li> <li>Ethereum API JSON-RPC-based \u2014 Moonbeam Basic Explorer on HTTP port <code>9944</code></li> </ul>"},{"location":"builders/get-started/networks/moonbeam-dev/#debug-trace-txpool-apis","title":"Debug, Trace, and TxPool APIs","text":"<p>You can also gain access to some non-standard RPC methods by running a tracing node, which allows developers to inspect and debug transactions during runtime. Tracing nodes use a different Docker image than a standard Moonbeam development node.</p> <p>To learn how to run a Moonbeam development tracing node, check out the Run a Tracing Node guide, and be sure to switch to the Moonbeam Development Node tab throughout the instructions. Then, to access the non-standard RPC methods with your tracing node, check out the Debug &amp; Trace guide.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#purging-your-node","title":"Purge a Development Node","text":"<p>If you want to remove data associated with your node, you can purge it. The instructions for purging a node are different depending on how you initially spun up your node.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#purge-docker-node","title":"Purge a Node Spun Up with Docker","text":"<p>If you spun up your node using Docker along with the <code>-v</code> flag to specify a mounted directory for your container, you will need to purge that directory. To do so, you can run the following command:</p> <pre><code>sudo rm -rf /var/lib/alphanet-data/*\n</code></pre> <p>If you followed the instructions in this guide and did not use the <code>-v</code> flag, you can stop and remove the Docker container. The associated data will be removed along with it. To do so, you can run the following command:</p> <pre><code>sudo docker stop `CONTAINER_ID` &amp;&amp; docker rm `CONTAINER_ID`\n</code></pre>"},{"location":"builders/get-started/networks/moonbeam-dev/#purge-binary-node","title":"Purge a Node Spun up with a Binary File","text":"<p>When running a node via the binary file, data is stored in a local directory, typically located in <code>~/.local/shared/moonbeam/chains/development/db</code>. If you want to start a fresh instance of the node, you can either delete the content of the folder or run the following command inside the <code>moonbeam</code> folder:</p> <pre><code>./target/release/moonbeam purge-chain --dev -y\n</code></pre> <p>This will remove the data folder. Note that all chain data is now lost. To learn more about all of the available <code>purge-chain</code> commands, you can check out the Purging Binary Data section of our documentation.</p>"},{"location":"builders/get-started/networks/moonbeam/","title":"Get Started with Moonbeam","text":""},{"location":"builders/get-started/networks/moonbeam/#network-endpoints","title":"Network Endpoints","text":"<p>Moonbeam has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.</p> <p>If you're looking for your own endpoints suitable for production use, you can check out the Endpoint Providers section of our documentation. Otherwise, to get started quickly you can use one of the following public HTTPS or WSS endpoints:</p> HTTPSWSS Provider RPC URL Limits Dwellir <pre><code>https://moonbeam-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>https://moonbeam.api.onfinality.io/public</code></pre> 40 req/sec UnitedBloc <pre><code>https://moonbeam.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonbeam.public.curie.radiumblock.co/http</code></pre> 200 req/sec 1RPC <pre><code>https://1rpc.io/glmr</code></pre> 10k req/day Grove <pre><code>https://moonbeam.rpc.grove.city/v1/01fdb492</code></pre> 5k req/day Provider RPC URL Limits Dwellir <pre><code>wss://moonbeam-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>wss://moonbeam.api.onfinality.io/public-ws</code></pre> 40 req/sec UnitedBloc <pre><code>wss://moonbeam.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonbeam.public.curie.radiumblock.co/ws</code></pre> 200 req/sec 1RPC <pre><code>wss://1rpc.io/glmr</code></pre> 10k req/day"},{"location":"builders/get-started/networks/moonbeam/#quick-start","title":"Quick Start","text":"<p>Before getting started, make sure you've retrieved your own endpoint and API key from one of the custom Endpoint Providers. Then for the Web3.js library, you can create a local Web3 instance and set the provider to connect to Moonbeam (both HTTP and WS are supported):</p> <pre><code>const { Web3 } = require('web3'); // Load Web3 library\n.\n.\n.\n// Create local Web3 instance - set Moonbeam as provider\nconst web3 = new Web3('INSERT_RPC_API_ENDPOINT'); // Insert your RPC URL here\n</code></pre> <p>For the Ethers.js library, define the provider by using <code>ethers.JsonRpcProvider(providerURL, {object})</code> and setting the provider URL to Moonbeam:</p> <pre><code>const ethers = require('ethers'); // Load Ethers library\n\nconst providerURL = 'INSERT_RPC_API_ENDPOINT'; // Insert your RPC URL here\n\n// Define provider\nconst provider = new ethers.JsonRpcProvider(providerURL, {\n    chainId: 1284,\n    name: 'moonbeam'\n});\n</code></pre> <p>Any Ethereum wallet should be able to generate a valid address for Moonbeam (for example, MetaMask).</p>"},{"location":"builders/get-started/networks/moonbeam/#chain-id","title":"Chain ID","text":"<p>Moonbeam chain ID is: <code>1284</code>, or <code>0x504</code> in hex.</p>"},{"location":"builders/get-started/networks/moonbeam/#block-explorers","title":"Block Explorers","text":"<p>For Moonbeam, you can use any of the following block explorers:</p> <ul> <li>Ethereum API (Etherscan Equivalent) \u2014 Moonscan</li> <li>Ethereum API JSON-RPC based \u2014 Moonbeam Basic Explorer</li> <li>Substrate API \u2014 Subscan or Polkadot.js Apps</li> </ul> <p>For more information on each of the available block explorers, please head to the Block Explorers section of the documentation.</p>"},{"location":"builders/get-started/networks/moonbeam/#connect-metamask","title":"Connect MetaMask","text":"<p>If you already have MetaMask installed, you can easily connect MetaMask to Moonbeam:</p> Connect MetaMask <p>Note</p> <p>MetaMask will popup asking for permission to add Moonbeam as a custom network. Once you approve permissions, MetaMask will switch your current network to Moonbeam.</p> <p>If you do not have MetaMask installed, or would like to follow a tutorial to get started, please check out the Interacting with Moonbeam using MetaMask guide.</p>"},{"location":"builders/get-started/networks/moonbeam/#configuration","title":"Configuration","text":"<p>Please note the following gas configuration parameters. These values are subject to change in future runtime upgrades.</p> Variable Value Minimum gas price 31.25 Gwei Target block time 6 seconds Block gas limit 60,000,000 Transaction gas limit 52,000,000"},{"location":"builders/get-started/networks/moonriver/","title":"Get Started with Moonriver","text":""},{"location":"builders/get-started/networks/moonriver/#network-endpoints","title":"Network Endpoints","text":"<p>Moonriver has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.</p> <p>If you're looking for your own endpoints suitable for production use, you can check out the Endpoint Providers section of our documentation. Otherwise, to get started quickly you can use one of the following public HTTPS or WSS endpoints:</p> HTTPSWSS Provider RPC URL Limits Dwellir <pre><code>https://moonriver-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>https://moonriver.api.onfinality.io/public</code></pre> 40 req/sec UnitedBloc <pre><code>https://moonriver.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonriver.public.curie.radiumblock.co/http</code></pre> 200 req/sec Grove <pre><code>https://moonriver.rpc.grove.city/v1/01fdb492</code></pre> 5k req/day Provider RPC URL Limits Dwellir <pre><code>wss://moonriver-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>wss://moonriver.api.onfinality.io/public-ws</code></pre> 40 req/sec UnitedBloc <pre><code>wss://moonriver.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonriver.public.curie.radiumblock.co/ws</code></pre> 200 req/sec"},{"location":"builders/get-started/networks/moonriver/#quick-start","title":"Quick Start","text":"<p>Before getting started, make sure you've retrieved your own endpoint and API key from one of the custom Endpoint Providers. Then for the Web3.js library, you can create a local Web3 instance and set the provider to connect to Moonriver (both HTTP and WS are supported):</p> <pre><code>const { Web3 } = require('web3'); // Load Web3 library\n.\n.\n.\n// Create local Web3 instance - set Moonriver as provider\nconst web3 = new Web3('INSERT_RPC_API_ENDPOINT'); // Insert your RPC URL here\n</code></pre> <p>For the Ethers.js library, define the provider by using <code>ethers.JsonRpcProvider(providerURL, {object})</code> and setting the provider URL to Moonriver:</p> <pre><code>const ethers = require('ethers'); // Load Ethers library\n\nconst providerURL = 'INSERT_RPC_API_ENDPOINT'; // Insert your RPC URL here\n\n// Define provider\nconst provider = new ethers.JsonRpcProvider(providerURL, {\n    chainId: 1285,\n    name: 'moonriver'\n});\n</code></pre> <p>Any Ethereum wallet should be able to generate a valid address for Moonbeam (for example, MetaMask).</p>"},{"location":"builders/get-started/networks/moonriver/#chain-id","title":"Chain ID","text":"<p>Moonriver chain ID is: <code>1285</code>, or <code>0x505</code> in hex.</p>"},{"location":"builders/get-started/networks/moonriver/#block-explorers","title":"Block Explorers","text":"<p>For Moonriver, you can use any of the following block explorers:</p> <ul> <li>Ethereum API (Etherscan Equivalent) \u2014 Moonscan</li> <li>Ethereum API JSON-RPC based \u2014 Moonbeam Basic Explorer</li> <li>Substrate API \u2014 Subscan or Polkadot.js Apps</li> </ul> <p>For more information on each of the available block explorers, please head to the Block Explorers section of the documentation.</p>"},{"location":"builders/get-started/networks/moonriver/#connect-metamask","title":"Connect MetaMask","text":"<p>If you already have MetaMask installed, you can easily connect MetaMask to Moonriver:</p> Connect MetaMask <p>Note</p> <p>MetaMask will popup asking for permission to add Moonriver as a custom network. Once you approve permissions, MetaMask will switch your current network to Moonriver.</p> <p>If you do not have MetaMask installed, or would like to follow a tutorial to get started, please check out the Interacting with Moonbeam using MetaMask guide.</p>"},{"location":"builders/get-started/networks/moonriver/#configuration","title":"Configuration","text":"<p>Please note the following gas configuration parameters. These values are subject to change in future runtime upgrades.</p> Variable Value Minimum gas price 0.3125 Gwei Target block time 6 seconds Block gas limit 60,000,000 Transaction gas limit 52,000,000"},{"location":"builders/integrations/analytics/dapplooker/","title":"Getting Started with Dapplooker","text":""},{"location":"builders/integrations/analytics/dapplooker/#introduction","title":"Introduction","text":"<p>Developers on Moonriver and Moonbeam can use the Dapplooker platform to analyze their on-chain data and run SQL queries. The integration gives projects the ability to create charts and dashboards to\u00a0track their smart contracts\u00a0and provide feedback on performance and adoption.</p> <p>Dapplooker analytics platform complements Moonbeam-based networks by helping users make sense of smart contracts without having to rely on an engineer or analyst. Dapplooker\u2019s intuitive Visual SQL helps browse smart contract data in tabular form and write SQL queries using easy to use editor. Users can create, fork, and share dashboards with everyone.</p> <p>This guide will cover all of the details needed to register your project with the Dapplooker platform and how to build analytics using SQL editor. This guide can be adapted for use on Moonbeam, Moonriver, or Moonbase Alpha.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/analytics/dapplooker/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started with this guide, you'll need to create or have a Dapplooker account. You can signup and create an account. If you've already signed up, you can login to your account.</p> <p></p>"},{"location":"builders/integrations/analytics/dapplooker/#connect-smart-contracts","title":"Connect Smart Contracts","text":"<p>To connect a smart contract to Dapplooker, you can click on the My Projects button at the top of the page.</p> <p>From the Register Your Project page, click Connect Dapp then select the Connect Smart Contract option. You can also browse and run analytics on already indexed DApps from the menu.</p> <p></p> <p>You'll be prompted to enter in details about your project and contract:</p> <ol> <li>Enter your project name</li> <li>Enter the network your project lives on. The network can be either Moonbeam, Moonriver, or Moonbase Alpha</li> <li>Toggle the slider if you have several instances of the same contract</li> <li>Enter your contract address. If the contract address is verified on Moonscan, it will start appearing in autocomplete. You can select the contract address from autocomplete. If no contract address appears in autocomplete, you can input your contract address and click on the + button and then the upload button to upload the ABI</li> <li>Enter your project's website</li> <li>Upload your project's logo</li> <li>Click Register and smart contract transactions events data syncing will start. It can take some time for complete data to be synced</li> </ol> <p></p> <p>Once syncing is complete, you will get an email notification. Clicking on the link in the email will take you directly to your indexed data.</p>"},{"location":"builders/integrations/analytics/dapplooker/#connect-subgraphs","title":"Connect Subgraphs","text":"<p>To connect a subgraph to Dapplooker, you can click on the My Projects button at the top of the page.</p> <p>From the Register Your Project page, click Connect Dapp then select the Connect Subgraph option. You can also browse and run analytics on already indexed Dapps from the menu.</p> <p></p> <p>You'll be prompted to enter in details about your project and subgraph:</p> <ol> <li>Enter your project name</li> <li>Enter the network your project lives on. The network can be either Moonbeam, Moonriver, or Moonbase Alpha</li> <li>Input your DApp subgraph endpoint</li> <li>Enter your project's website</li> <li>Upload your project's logo</li> <li>Click Register and subgraph entities data syncing will start. It can take some time for complete data to be synced</li> </ol> <p></p> <p>Once syncing is complete, you will get an email notification. Clicking on the link in the email will take you directly to your indexed data.</p>"},{"location":"builders/integrations/analytics/dapplooker/#create-charts-dashboards","title":"Create Charts &amp; Dashboards","text":"<p>To get started creating charts to visualize your data, you can click Create a Chart at the top of the page. From there you can choose to create a Simple chart, Custom chart, or Native query chart. For more information on creating each type of chart, you can take a look at the Dapplooker documentation on creating charts.</p> <p>If you are interested in creating a dashboard, you can get started by clicking Browse Data at the top of the page. Then, click the + button and choose New dashboard from the dropdown menu. For more information on creating a dashboard, please refer to the Dapplooker documentation on creating a dashboard.</p> <p>You can publish charts and dashboards in private or public folders. Public charts and dashboards are accessible to everyone. You can also fork, edit, and create new charts and dashboards from public charts.</p>"},{"location":"builders/integrations/analytics/dapplooker/#example-dashboards","title":"Example Charts &amp; Dashboards","text":"<p>There are a collection of charts and dashboards available for you to view and build off of for both Moonbeam and Moonriver. To get started, you can take a look at the Moonbeam Network Collection or the Moonriver Network Collection. There, you\u2019ll find editable public charts and dashboards.</p> <p>To start editing any of the charts or dashboards, you can click on the list icon in the right hand corner between the Summarize button and the refresh icon. This opens the editor, where you can fully customize the existing chart or dashboard. Any changes you make will not automatically be saved. To create the chart or dashboard with your changes, you'll need to click Save. For more information on editing and creating the charts or dashboards, please refer to the Dapplooker documentation site.</p> <p>Another place you can start to view and build off of data is from the list of Moonbeam Staking dashboards and the Moonriver Staking dashboards.</p>"},{"location":"builders/integrations/analytics/dapplooker/#popular-dashboards","title":"Popular Dashboards","text":"<ul> <li>Moonbeam Staking Dashboard - staking dashboards for collators and delegators on Moonbeam that includes APY data</li> <li>Moonriver Staking Dashboard - staking dashboards for collators and delegators on Moonriver that includes APY data</li> <li>Dapplooker Explorer for Moonbeam - find popular dashboards on Moonbeam</li> <li>Dapplooker Explorer for Moonriver - find popular dashboards on Moonriver</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/analytics/zapper/","title":"Portfolio Tracking with Zapper","text":""},{"location":"builders/integrations/analytics/zapper/#introduction","title":"Introduction","text":"<p>Zapper is a Web3 application that enables users to explore on-chain data, manage their portfolios, and interact with decentralized finance (DeFi) protocols across multiple networks, including Moonbeam. Through their integration with Zapper, users can monitor and manage assets across Moonbeam\u2019s DeFi ecosystem, including platforms such as Moonwell, StellaSwap, OmniLST, and Prime Protocol.</p> <p>This tutorial provides a detailed step-by-step guide for users and developers to integrate with Zapper and maximize their experience within the Moonbeam ecosystem.</p>"},{"location":"builders/integrations/analytics/zapper/#get-started-on-zapper","title":"Get Started on Zapper","text":"<p>You can navigate to Zapper's official website and take the following steps to start interacting with the application:</p> <ol> <li>Click on the Connect Wallet button at the top right corner </li> <li>Select your preferred wallet from the supported options (e.g., MetaMask, Talisman, Coinbase Wallet) </li> <li>Follow the on-screen prompts to connect securely to Zapper</li> </ol>"},{"location":"builders/integrations/analytics/zapper/#explore-your-portfolio","title":"Explore Your Portfolio","text":"<p>Once your wallet is connected, Zapper will automatically detect and display your assets across supported networks, including Moonbeam. You can navigate to your main dashboard by clicking on My profile on the left sidebar or selecting it from the wallet icon on the top-right corner. The dashboard provides an overview of your holdings and activity split in the following categories:</p> <ul> <li>Summary - displays your total assets, liabilities, and net worth across all networks</li> <li>Tokens - lists all tokens held in your connected wallet, including GLMR (Moonbeam's native token) and any ERC-20 tokens</li> <li>DeFi - shows active positions in Moonbeam-based DeFi platforms such as lending, liquidity pools, and staking</li> <li>NFTs - displays any NFTs you own on Moonbeam or other supported chains</li> <li>Activity - Zapper's dashboard provides real-time data, enabling efficient management of your on-chain activities</li> </ul> <p></p>"},{"location":"builders/integrations/analytics/zapper/#engage-with-moonbeams-defi-ecosystem","title":"Engage with Moonbeam's DeFi Ecosystem","text":"<p>Zapper provides access to view the activity on Moonbeam's DeFi protocols, such as:</p> <ul> <li>Moonwell - for accessing lending and borrowing services</li> <li>StellaSwap - for participating in token swaps and liquidity provision by depositing token pairs into StellaSwap's liquidity pools</li> <li>OmniLST - for engaging in liquid staking opportunities (stake GLMR tokens to receive liquid staking tokens and use them in other DeFi applications)</li> <li>Prime Protocol - for managing cross-chain assets and accessing borrowing services (deposit assets as collateral to borrow across multiple chains)</li> </ul> <p>You can follow these steps to review any of the aforementioned protocols:</p> <ol> <li>Select Moonbeam from the chain filter in the left sidebar. This will display the most trending dApps in the ecosystem. Click on the protocol you wish to explore </li> <li>In the Activity tab, view the latest transactions for the selected protocol, including token swaps, LP or staking on StellaSwap, lending and borrowing on Moonwell, staked GLMR on OmniLST, and activity on other supported dApps </li> <li>View additional details for the selected protocol, including daily active users and daily transactions in the left sidebar, deployed smart contracts in the Contracts tab, and your holdings in the protocol via the Properties tab</li> </ol>"},{"location":"builders/integrations/analytics/zapper/#access-and-manage-moonbeam-assets","title":"Access and Manage Moonbeam Assets","text":"<p>Zapper also has an integrated modal for seamlessly swapping assets on Moonbeam. You can access this feature by selecting Moonbeam in the chain filter on the left sidebar and choosing the desired token on the right sidebar.</p> <p></p> <p>Inside the token page, you'll be able to see the asset's performance and details such as price action, volumes, holders and transactions. </p> <p></p> <p>To perform a swap you'll need to access the swap modal by clicking on the Buy/Sell buttons in the left sidebar. Once inside the modal you can select the assets for swapping, input the desired quantity for the token you want to sell, and click on Review order to sign and submit the transaction.</p> <p></p>"},{"location":"builders/integrations/analytics/zapper/#integrate-with-zappers-api","title":"Integrate with Zapper's API","text":"<p>Developers can leverage Zapper's API to enrich their applications with comprehensive DeFi data from the Moonbeam network.</p> <p>You can register for an API key by visiting the Zapper API portal. An API key is necessary to authenticate your application and access Zapper's endpoints. </p> <p>Zapper offers several endpoints to fetch relevant data, such as:</p> <ul> <li>Balances - retrieve asset balances for addresses on Moonbeam</li> <li>Transactions - access transaction histories</li> <li>Prices - obtain real-time token prices</li> </ul> <p>Furthermore, you can familiarize yourself with the Zapper API documentation, which provides detailed information on the available endpoints, request structures, and response formats.</p> <p>Depending on your preferred programming language, you can set up your environment to make HTTP requests to Zapper's API. Below is an example of retrieving token balances for a specified wallet address on Moonbeam using Node.js and Axios:</p> <pre><code>const axios = require('axios');\n\nconst API_KEY = 'INSERT_API_KEY';\nconst address = 'INSERT_WALLET_ADDRESS';\nconst chain = 'moonbeam';\n\naxios.get(`https://api.zapper.xyz/v1/protocols/tokens/balances`, {\n  params: { addresses: address, network: chain },\n  headers: { Authorization: `Bearer ${API_KEY}` }\n})\n.then(response =&gt; {\n  console.log(response.data);\n})\n.catch(error =&gt; {\n  console.error(error);\n});\n</code></pre> <p>Note</p> <p>Ensure that your application handles API responses appropriately and includes error-handling mechanisms.</p> <p>By following this tutorial, users and developers will have effectively learned how to integrate with Zapper and use it for exploring multiple DApps in the Moonbeam network. </p>"},{"location":"builders/integrations/analytics/zapper/#additional-resources","title":"Additional Resources","text":"<p>You can also explore the Zapper API GitHub repository for code examples and community contributions, or refer to Zapper's integration guides for detailed instructions and best practices.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/indexers/covalent/","title":"Getting Started with the GoldRush API","text":""},{"location":"builders/integrations/indexers/covalent/#introduction","title":"Introduction","text":"<p>GoldRush, formerly known as Covalent, is a hosted blockchain data solution providing access to historical and current on-chain data for 100+ supported blockchains, including Moonbeam, Moonriver, and Moonbase Alpha. GoldRush maintains a full archival copy of every supported blockchain, meaning every balance, transaction, log event, and NFT asset data is available from the genesis block. This data is available via:</p> <ul> <li>Unified API - incorporate blockchain data into your app with a familiar REST API</li> </ul> <p>This guide will cover all of the details needed to get started with the Foundational API and how to access the API endpoints for Moonbeam using curl commands and JavaScript and Python snippets.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/indexers/covalent/#unified-api-overview","title":"Unified API Overview","text":"<p>GoldRush's Unified API is a powerful but easy-to-use REST API that offers visibility to assets across all blockchain networks. It features a consistent request and response object format across networks. For example, a user can fetch all the token balances for a wallet address across any supported blockchain by changing the unique blockchain name or ID path parameter in the request URL. GoldRush's Unified API can offer more data flexibility than JSON-RPC interfaces, which are typically limited to queries on a specific block. It also allows queries on multiple objects and batch exports of data.</p>"},{"location":"builders/integrations/indexers/covalent/#querying-the-unified-api","title":"Querying the Unified API","text":"<p>It's easy to get started querying the Unified API after you've secured a GoldRush API Key. Make sure you have your API Key which begins with <code>cqt_</code> or <code>ckey_</code>. </p> <p>You can interact with any of the API methods in the web interface of the GoldRush docs. To try out the token balances API, head to the token balances docs and take the following steps:</p> <ol> <li>Paste in your API key</li> <li>Enter the desired <code>chainName</code>, such as <code>moonbeam-moonbase-alpha</code> for Moonbase Alpha. Reference the Quick Start section if you're unsure what the chainName should be for your desired network</li> <li>Enter the address you wish to check the token balances of</li> <li>Press Send</li> </ol> <p></p>"},{"location":"builders/integrations/indexers/covalent/#quick-start","title":"Quick Start","text":"<p>If you're familiar with GoldRush and ready to dive in, you need the chainID and network name to get started.</p> MoonbeamMoonriverMoonbase Alpha Parameter Value <code>chainName</code> <code>moonbeam-mainnet</code> <code>chainID</code> <code>1284</code> Parameter Value <code>chainName</code> <code>moonbeam-moonriver</code> <code>chainID</code> <code>1285</code> Parameter Value <code>chainName</code> <code>moonbeam-moonbase-alpha</code> <code>chainID</code> <code>1287</code>"},{"location":"builders/integrations/indexers/covalent/#fundamentals-of-the-unified-api","title":"Fundamentals of the Unified API","text":"<ul> <li>The GoldRush API is RESTful and it is designed around the main resources that are available through the web interface</li> <li>The current version of the API is version 1</li> <li>The default return format for all endpoints is JSON</li> <li>All requests require authentication; you will need an API Key to use the GoldRush API</li> <li>The cost of an API call is denominated in credits and varies depending on the particular call. Upon creating an API key, you're given a substantial amount of free credits to get started (25,000 at the time of writing). You can track your usage of these free credits on the GoldRush Dashboard</li> <li>Note that free development API keys are rate limited to <code>4</code> requests per second. Subscribers to a professional plan can make up to <code>50</code> requests per second.</li> <li>The root URL of the API is: <code>https://api.covalenthq.com/v1/</code></li> <li>All requests are done over HTTPS (calls over plain HTTP will fail)</li> <li>The refresh rate of the APIs is real-time: 30s or two blocks, and batch 30m or 40 blocks</li> </ul>"},{"location":"builders/integrations/indexers/covalent/#types-of-endpoints","title":"Types of Endpoints","text":"<p>The GoldRush API has three classes of endpoints:</p> <ul> <li>Class A \u2014 endpoints that return enriched blockchain data applicable to all blockchain networks, eg: balances, transactions, log events, etc</li> <li>Class B \u2014 endpoints that are for a specific protocol on a blockchain, e.g. Uniswap is Ethereum-only and is not applicable to other blockchain networks</li> <li>Class C \u2014 endpoints that are community-built and maintained but powered by GoldRush infrastructure</li> </ul>"},{"location":"builders/integrations/indexers/covalent/#sample-supported-endpoints","title":"Sample Supported Endpoints","text":"<p>For a full list of supported endpoints, refer to the GoldRush API reference. A subset of the supported endpoints include:</p> <ul> <li>Token balances- get all token balances (native, ERC-20, ERC-721, ERC-1155) with current market prices for an address</li> <li>Native token balances- retrieve native token balance for an address</li> <li>Get a transaction- fetch and render a single transaction with decoded log events</li> <li>Transaction summary- retrieve key wallet activity data for an address</li> <li>Earliest transactions- get the earliest transactions for an address</li> <li>Recent transactions- fetch the most recent transactions for an address</li> <li>Paginated transactions- get paginated transactions for an address</li> <li>Bulk time bucket transactions- fetch all transactions in 15-minute time buckets</li> <li>Block transactions- get all transactions in a specific block</li> <li>ERC-20 token transfers- fetch transfer history of a specific ERC-20 token for an address</li> <li>Cross-chain activity- locate chains on which an address is active</li> <li>Token approvals- get a list of token approvals for an address</li> <li>NFT approvals- retrieve NFT approvals for an address</li> </ul>"},{"location":"builders/integrations/indexers/covalent/#unified-api-methods","title":"Unified API Methods","text":"<p>For more information on each of the methods of the Unified API and for an interactive interface to try out each of the methods, be sure to check out the GoldRush docs.  </p>"},{"location":"builders/integrations/indexers/covalent/#balances","title":"Balances","text":"Token Balances <p>The token balances endpoint retrieves native tokens, fungible (ERC-20) tokens, and non-fungible (ERC-721 &amp; ERC-1155) tokens associated with a given address. The returned data includes current market prices and additional token metadata.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to check the token balances of</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x569BE8d8b04538318e1722f6e375FD381D2da865/balances_v2/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x569be8d8b04538318e1722f6e375fd381d2da865\",\n    \"updated_at\": \"2024-10-08T23:34:58.401269473Z\",\n    \"next_update_at\": \"2024-10-08T23:39:58.401269913Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"contract_decimals\": 18,\n        \"contract_name\": \"Mainnet2021\",\n        \"contract_ticker_symbol\": \"MN21\",\n        \"contract_address\": \"0xb59c01231fd65fb2da1e23a52abb946e2e13b333\",\n        \"supports_erc\": [\n          \"erc20\"\n        ],\n        \"logo_url\": \"https://logos.covalenthq.com/tokens/1287/0xb59c01231fd65fb2da1e23a52abb946e2e13b333.png\",\n        \"balance\": \"999999\",\n        \"quote_rate\": null,\n        \"quote\": 0,\n        \"pretty_quote\": \"$0.00\"\n      },\n      {\n        \"contract_decimals\": 18,\n        \"contract_name\": \"Dev\",\n        \"contract_ticker_symbol\": \"DEV\",\n        \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n        \"supports_erc\": [\n          \"erc20\"\n        ],\n        \"logo_url\": \"https://www.datocms-assets.com/86369/1669924256-moonbeam-1.png\",\n        \"balance\": \"88335963638628211482\",\n        \"quote_rate\": 0,\n        \"quote\": 0,\n        \"pretty_quote\": \"$0.00\"\n      }\n    ],\n    \"pagination\": null\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Native Token Balances <p>The native token balances endpoint retrieves the native token balance for a given address in a streamlined manner. </p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to check the token balances of</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x569BE8d8b04538318e1722f6e375FD381D2da865/balances_native/ \\\n  --header 'Authorization: Bearer INSERT-API-KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x569be8d8b04538318e1722f6e375fd381d2da865\",\n    \"updated_at\": \"2024-10-09T00:15:57.758041451Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"contract_decimals\": 18,\n        \"contract_name\": \"Dev\",\n        \"contract_ticker_symbol\": \"DEV\",\n        \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n        \"supports_erc\": [\n          \"erc20\"\n        ],\n        \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\",\n        \"block_height\": 8959160,\n        \"balance\": \"88335963638628211482\",\n        \"quote_rate\": null,\n        \"quote\": null,\n        \"pretty_quote\": null\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get ERC-20 Token Transfers for Address <p>Get ERC-20 Token Transfers for Address is used to fetch the transfer-in and transfer-out of a token along with historical prices from an address, when provided both a wallet address and an ERC-20 token contract address</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> <li><code>contractAddress</code> string - the ERC-20 token contract to query</li> </ul> <pre><code>curl --request GET \\\n  --url 'https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/transfers_v2/?contract-address=0x37822de108AFFdd5cDCFDaAa2E32756Da284DB85' \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T02:02:58.842706507Z\",\n    \"next_update_at\": \"2024-10-09T02:07:58.842707047Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2022-04-29T17:41:36Z\",\n        \"block_height\": 2075113,\n        \"tx_hash\": \"0x7271982923345160707c397e412db1a75ceaa458fc1a5dc2c638dd60e58e60d2\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": \"0x37822de108affdd5cdcfdaaa2e32756da284db85\",\n        \"value\": \"0\",\n        \"gas_offered\": 35009,\n        \"gas_spent\": 32693,\n        \"gas_price\": 2500000000,\n        \"fees_paid\": \"81732500000000\",\n        \"transfers\": [\n          {\n            \"tx_hash\": \"0x7271982923345160707c397e412db1a75ceaa458fc1a5dc2c638dd60e58e60d2\",\n            \"from_address\": \"0x0000000000000000000000000000000000000000\",\n            \"to_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n            \"contract_name\": \"Mercury\",\n            \"contract_ticker_symbol\": \"MERC\",\n            \"contract_address\": \"0x37822de108affdd5cdcfdaaa2e32756da284db85\",\n            \"transfer_type\": \"IN\",\n            \"delta\": \"100000000000000000000\"\n          }\n        ]\n      },\n      {\n        \"block_signed_at\": \"2021-10-13T19:06:30Z\",\n        \"block_height\": 954752,\n        \"tx_hash\": \"0x7fb19c6b0ccf1dd87610c59a9cdc2f298ce6b39b32b396f900f1bf3c8f034b6b\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": \"0x8a1932d6e26433f3037bd6c3a40c816222a6ccd4\",\n        \"value\": \"0\",\n        \"gas_offered\": 369444,\n        \"gas_spent\": 99165,\n        \"gas_price\": 1000000000,\n        \"fees_paid\": \"99165000000000\",\n        \"transfers\": [\n          {\n            \"tx_hash\": \"0x7fb19c6b0ccf1dd87610c59a9cdc2f298ce6b39b32b396f900f1bf3c8f034b6b\",\n            \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n            \"to_address\": \"0x573db48e758cbc07a99afe67b8b7b23f671902c0\",\n            \"contract_name\": \"Mercury\",\n            \"contract_ticker_symbol\": \"MERC\",\n            \"contract_address\": \"0x37822de108affdd5cdcfdaaa2e32756da284db85\",\n            \"transfer_type\": \"OUT\",\n            \"delta\": \"10000000000000000000000\"\n          }\n        ]\n      }\n    ],\n    \"pagination\": {\n      \"has_more\": false,\n      \"page_number\": 0,\n      \"page_size\": 100,\n      \"total_count\": null\n    }\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre>"},{"location":"builders/integrations/indexers/covalent/#transactions","title":"Transactions","text":"Get a transaction <p>Get a transaction is used fetch and render a single transaction including its decoded log events. </p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>txHash</code> string - the transaction hash</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/transaction_v2/0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T00:33:57.799418189Z\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-09-27T22:23:54Z\",\n        \"block_height\": 8816296,\n        \"block_hash\": \"0x2f89cd5009b3c69de1eb4edf678a5dfb6c2366cb7da6945783a443133b3df44e\",\n        \"tx_hash\": \"0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60\",\n        \"tx_offset\": 1,\n        \"successful\": true,\n        \"miner_address\": \"0xd34fedcefbaacbd74bd3d0bb80b3a67e6b2defb7\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"from_address_label\": null,\n        \"to_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n        \"to_address_label\": null,\n        \"value\": \"0\",\n        \"value_quote\": null,\n        \"pretty_value_quote\": null,\n        \"gas_metadata\": {\n          \"contract_decimals\": 18,\n          \"contract_name\": \"Dev\",\n          \"contract_ticker_symbol\": \"DEV\",\n          \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n          \"supports_erc\": [\n            \"erc20\"\n          ],\n          \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\"\n        },\n        \"gas_offered\": 169164,\n        \"gas_spent\": 110096,\n        \"gas_price\": 31250000,\n        \"fees_paid\": \"13762000000000\",\n        \"gas_quote\": null,\n        \"pretty_gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"explorers\": [\n          {\n            \"label\": null,\n            \"url\": \"https://moonbase-blockscout.testnet.moonbeam.network/tx/0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60\"\n          }\n        ],\n        \"log_events\": [\n          {\n            \"block_signed_at\": \"2024-09-27T22:23:54Z\",\n            \"block_height\": 8816296,\n            \"tx_offset\": 1,\n            \"log_offset\": 1,\n            \"tx_hash\": \"0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60\",\n            \"raw_log_topics\": [\n              \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n              \"0x0000000000000000000000003b939fead1557c741ff06492fd0127bd287a421e\",\n              \"0x0000000000000000000000004b8c667590e6a28497ea4be5facb7e9869a64eae\"\n            ],\n            \"sender_contract_decimals\": 12,\n            \"sender_name\": \"xcUNIT\",\n            \"sender_contract_ticker_symbol\": \"xcUNIT\",\n            \"sender_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n            \"sender_address_label\": null,\n            \"sender_logo_url\": \"https://logos.covalenthq.com/tokens/1287/0xffffffff1fcacbd218edc0eba20fc2308c778080.png\",\n            \"supports_erc\": [\n              \"erc20\"\n            ],\n            \"sender_factory_address\": null,\n            \"raw_log_data\": \"0x000000000000000000000000000000000000000000000000000000e8d4a51000\",\n            \"decoded\": {\n              \"name\": \"Transfer\",\n              \"signature\": \"Transfer(indexed address from, indexed address to, uint256 value)\",\n              \"params\": [\n                {\n                  \"name\": \"from\",\n                  \"type\": \"address\",\n                  \"indexed\": true,\n                  \"decoded\": true,\n                  \"value\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\"\n                },\n                {\n                  \"name\": \"to\",\n                  \"type\": \"address\",\n                  \"indexed\": true,\n                  \"decoded\": true,\n                  \"value\": \"0x4b8c667590e6a28497ea4be5facb7e9869a64eae\"\n                },\n                {\n                  \"name\": \"value\",\n                  \"type\": \"uint256\",\n                  \"indexed\": false,\n                  \"decoded\": true,\n                  \"value\": \"1000000000000\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ],\n    \"pagination\": null\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get transaction summary for address <p>Get transaction summary for address retrieves key wallet activity data, including the first and most recent transactions, and total transaction count. It enables quick analysis of wallet age, inactive periods, and overall Web3 engagement levels.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/transactions_summary/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T00:48:11.969915467Z\",\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"total_count\": 3066,\n        \"latest_transaction\": {\n          \"block_signed_at\": \"2024-10-04T19:41:48Z\",\n          \"tx_hash\": \"0x0923932a55c4366288cfc7a970e1d04895551d11f64d8f183877e8f6c19360bc\",\n          \"tx_detail_link\": \"https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/transaction_v2/0x0923932a55c4366288cfc7a970e1d04895551d11f64d8f183877e8f6c19360bc/\"\n        },\n        \"earliest_transaction\": {\n          \"block_signed_at\": \"2021-05-27T18:13:12Z\",\n          \"tx_hash\": \"0xc94e0072477e2543d17662317d40e4785ac6bb327c2a7483021167684b8584f3\",\n          \"tx_detail_link\": \"https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/transaction_v2/0xc94e0072477e2543d17662317d40e4785ac6bb327c2a7483021167684b8584f3/\"\n        }\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get earliest transactions for address (v3) <p>Get earliest transactions for address retrieves the earliest transactions involving an address.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/bulk/transactions/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T01:12:17.851277100Z\",\n    \"next_update_at\": \"2024-10-09T01:17:17.851280680Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2021-05-27T18:13:12Z\",\n        \"block_height\": 6971,\n        \"tx_hash\": \"0xc94e0072477e2543d17662317d40e4785ac6bb327c2a7483021167684b8584f3\",\n        \"from_address\": \"0xc10dc91c62c4854ffc0997776d495da3d8c79730\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"1044522000000000\",\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"log_events\": [\n          {\n            \"sender_name\": \"Mercury\",\n            \"sender_contract_ticker_symbol\": \"MERC\",\n            \"sender_address\": \"0x37822de108affdd5cdcfdaaa2e32756da284db85\",\n            \"decoded\": {\n              \"name\": \"Transfer\",\n              \"params\": [\n                {\n                  \"name\": \"from\",\n                  \"value\": \"0x0000000000000000000000000000000000000000\"\n                },\n                {\n                  \"name\": \"to\",\n                  \"value\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\"\n                },\n                {\n                  \"name\": \"value\",\n                  \"value\": \"100000000000000000000000\"\n                }\n              ]\n            }\n          }\n        ]\n      },\n      {\n        \"block_signed_at\": \"2021-05-27T18:13:24Z\",\n        \"block_height\": 6972,\n        \"tx_hash\": \"0xc37137133cbb8b0810943a6625a7193b5b18d72b5e21a78103243f482c269e71\",\n        \"from_address\": \"0xc10dc91c62c4854ffc0997776d495da3d8c79730\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"1044486000000000\",\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"log_events\": [\n          {\n            \"sender_name\": \"Venus\",\n            \"sender_contract_ticker_symbol\": \"VEN\",\n            \"sender_address\": \"0xcdf746c5c86df2c2772d2d36e227b4c0203cba25\",\n            \"decoded\": {\n              \"name\": \"Transfer\",\n              \"params\": [\n                {\n                  \"name\": \"from\",\n                  \"value\": \"0x0000000000000000000000000000000000000000\"\n                },\n                {\n                  \"name\": \"to\",\n                  \"value\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\"\n                },\n                {\n                  \"name\": \"value\",\n                  \"value\": \"100000000000000000000000\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get recent transactions for address (v3) <p>Get recent transactions for address retrieves the most recent transactions involving an address.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/transactions_v3/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T01:16:10.410076422Z\",\n    \"next_update_at\": \"2024-10-09T01:21:10.410077022Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-10-04T19:41:48Z\",\n        \"block_height\": 8901780,\n        \"tx_hash\": \"0x0923932a55c4366288cfc7a970e1d04895551d11f64d8f183877e8f6c19360bc\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"120825750000000\",\n        \"gas_offered\": 1010593,\n        \"gas_spent\": 966606,\n        \"gas_price\": 31250000,\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null\n      },\n      {\n        \"block_signed_at\": \"2024-09-27T22:23:54Z\",\n        \"block_height\": 8816296,\n        \"tx_hash\": \"0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n        \"value\": \"0\",\n        \"fees_paid\": \"13762000000000\",\n        \"gas_offered\": 169164,\n        \"gas_spent\": 110096,\n        \"gas_price\": 31250000,\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"log_events\": [\n          {\n            \"sender_name\": \"xcUNIT\",\n            \"sender_contract_ticker_symbol\": \"xcUNIT\",\n            \"sender_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n            \"decoded\": {\n              \"name\": \"Transfer\",\n              \"params\": [\n                {\n                  \"name\": \"from\",\n                  \"value\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\"\n                },\n                {\n                  \"name\": \"to\",\n                  \"value\": \"0x4b8c667590e6a28497ea4be5facb7e9869a64eae\"\n                },\n                {\n                  \"name\": \"value\",\n                  \"value\": \"1000000000000\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get paginated transactions for address (v3) <p>Get paginated transactions for address (v3) fetches the transactions involving an address and the specified page, starting from a 0 index.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> <li><code>page</code> integer - the requested page, 0-indexed. </li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/transactions_v3/page/2/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T01:37:36.277434751Z\",\n    \"next_update_at\": \"2024-10-09T01:42:36.277435481Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2021-06-08T18:22:00Z\",\n        \"block_height\": 93135,\n        \"tx_hash\": \"0x802eab122522f1ae23b911e8045d9de128acaa5c790d5df0c389240f23b7e17d\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"1416680000000000\",\n        \"gas_offered\": 1455080,\n        \"gas_spent\": 1416680,\n        \"gas_price\": 1000000000,\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null\n      },\n      {\n        \"block_signed_at\": \"2021-06-08T18:21:48Z\",\n        \"block_height\": 93134,\n        \"tx_hash\": \"0xe82d29e37e8d324a22ed9ce70d0c85258c420cf98cc4161c35f4edb7c9ba09c0\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"1712047000000000\",\n        \"gas_offered\": 1750447,\n        \"gas_spent\": 1712047,\n        \"gas_price\": 1000000000,\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get bulk time bucket transactions for address (v3) <p>Get bulk time bucket transactions for address (v3) is used to fetch all transactions including their decoded log events in a 15-minute time bucket interval.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> <li><code>timeBucket</code> integer - The 0-indexed 15-minute time bucket. E.g. 8 9 Oct 2024 01:49 GMT = 1728420540 (Unix time). 1728420540/900 = 1920467 timeBucket.</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/bulk/transactions/0x28a2B98793Fd1E20Fd79824cd29D36D3eB9A8F0E/1920467/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x28a2b98793fd1e20fd79824cd29d36d3eb9a8f0e\",\n    \"updated_at\": \"2024-10-09T01:47:40.617173773Z\",\n    \"next_update_at\": \"2024-10-09T01:52:40.617176953Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"complete\": true,\n    \"current_bucket\": 1920467,\n    \"links\": {\n      \"prev\": \"https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/bulk/transactions/0x28a2b98793fd1e20fd79824cd29d36d3eb9a8f0e/1920466/\",\n      \"next\": \"https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/bulk/transactions/0x28a2b98793fd1e20fd79824cd29d36d3eb9a8f0e/1920468/\"\n    },\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-10-08T20:48:42Z\",\n        \"block_height\": 8957260,\n        \"tx_hash\": \"0x587f0121ea9c51b93e1915a20370f0a2f004adee99d00ef8d1c0f9cc681a9772\",\n        \"from_address\": \"0x28a2b98793fd1e20fd79824cd29d36d3eb9a8f0e\",\n        \"to_address\": \"0x916b54696a70588a716f899be1e8f2a5ffd5f135\",\n        \"value\": \"0\",\n        \"gas_offered\": 582957,\n        \"gas_spent\": 551928,\n        \"gas_price\": 31250000,\n        \"fees_paid\": \"68991000000000\",\n        \"log_events\": [\n          {\n            \"sender_address\": \"0x916b54696a70588a716f899be1e8f2a5ffd5f135\",\n            \"decoded\": {\n              \"name\": \"SessionStarted\",\n              \"signature\": \"SessionStarted(indexed uint64 chainId, indexed uint64 blockHeight, uint64 deadline)\",\n              \"params\": [\n                {\n                  \"name\": \"chainId\",\n                  \"type\": \"uint64\",\n                  \"value\": \"1\"\n                },\n                {\n                  \"name\": \"blockHeight\",\n                  \"type\": \"uint64\",\n                  \"value\": \"20923350\"\n                },\n                {\n                  \"name\": \"deadline\",\n                  \"type\": \"uint64\",\n                  \"value\": \"8957360\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get all transactions in a block by page (v3) <p>Get all transactions in a block by page (v3) is used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>blockHeight</code> integer - the request block height. Also accepts the <code>latest</code> keyword</li> <li><code>page</code> integer - the requested page, 0-indexed.</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/block/8960094/transactions_v3/page/0/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T01:54:34.371150099Z\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"links\": {\n      \"prev\": null,\n      \"next\": null\n    },\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-10-09T01:51:42Z\",\n        \"block_height\": 8960094,\n        \"block_hash\": \"0x2a9cda3cfd23dffbe064932991568cae601d178717743eabc326222123d7ad44\",\n        \"tx_hash\": \"0x4abfef674580260d3c837e1dc5b17b8bf809e620518e40d3731c6c1cfa5346d9\",\n        \"tx_offset\": 0,\n        \"successful\": true,\n        \"miner_address\": \"0xeda33e2b5ffb97bb8b901b71b87e5791556fd46b\",\n        \"from_address\": \"0xf5e8a439c599205c1ab06b535de46681aed1007a\",\n        \"from_address_label\": null,\n        \"to_address\": \"0x21e612506ab4792a5d22466c0b529bb9afe4e42b\",\n        \"to_address_label\": null,\n        \"value\": \"0\",\n        \"value_quote\": null,\n        \"pretty_value_quote\": null,\n        \"gas_metadata\": {\n          \"contract_decimals\": 18,\n          \"contract_name\": \"Dev\",\n          \"contract_ticker_symbol\": \"DEV\",\n          \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n          \"supports_erc\": [\n            \"erc20\"\n          ],\n          \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\"\n        },\n        \"gas_offered\": 505088,\n        \"gas_spent\": 184528,\n        \"gas_price\": 1200000000,\n        \"fees_paid\": \"221433600000000\",\n        \"gas_quote\": null,\n        \"pretty_gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"explorers\": [\n          {\n            \"label\": null,\n            \"url\": \"https://moonbase-blockscout.testnet.moonbeam.network/tx/0x4abfef674580260d3c837e1dc5b17b8bf809e620518e40d3731c6c1cfa5346d9\"\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get all transactions in a block (v3) <p>Get all transactions in a block (v3) is used to used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions. It takes a blockhash as a parameter and it does not accept a page parameter.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>blockHash</code> integer - the request block hash</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/block_hash/0x2a9cda3cfd23dffbe064932991568cae601d178717743eabc326222123d7ad44/transactions_v3/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T01:58:08.816101489Z\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-10-09T01:51:42Z\",\n        \"block_height\": 8960094,\n        \"block_hash\": \"0x2a9cda3cfd23dffbe064932991568cae601d178717743eabc326222123d7ad44\",\n        \"tx_hash\": \"0x4abfef674580260d3c837e1dc5b17b8bf809e620518e40d3731c6c1cfa5346d9\",\n        \"tx_offset\": 0,\n        \"successful\": true,\n        \"miner_address\": \"0xeda33e2b5ffb97bb8b901b71b87e5791556fd46b\",\n        \"from_address\": \"0xf5e8a439c599205c1ab06b535de46681aed1007a\",\n        \"from_address_label\": null,\n        \"to_address\": \"0x21e612506ab4792a5d22466c0b529bb9afe4e42b\",\n        \"to_address_label\": null,\n        \"value\": \"0\",\n        \"value_quote\": null,\n        \"pretty_value_quote\": null,\n        \"gas_metadata\": {\n          \"contract_decimals\": 18,\n          \"contract_name\": \"Dev\",\n          \"contract_ticker_symbol\": \"DEV\",\n          \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n          \"supports_erc\": [\n            \"erc20\"\n          ],\n          \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\"\n        },\n        \"gas_offered\": 505088,\n        \"gas_spent\": 184528,\n        \"gas_price\": 1200000000,\n        \"fees_paid\": \"221433600000000\",\n        \"gas_quote\": null,\n        \"pretty_gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"explorers\": [\n          {\n            \"label\": null,\n            \"url\": \"https://moonbase-blockscout.testnet.moonbeam.network/tx/0x4abfef674580260d3c837e1dc5b17b8bf809e620518e40d3731c6c1cfa5346d9\"\n          }\n        ]\n      }\n    ],\n    \"pagination\": null\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre>"},{"location":"builders/integrations/indexers/covalent/#cross-chain","title":"Cross Chain","text":"Get cross-chain activity for address <p>Get cross-chain activity for address is used to locate chains which an address is active on with a single API call</p> ParametersExample RequestExample Response <ul> <li><code>walletAddress</code> string - the address you wish to query</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/activity/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T02:08:22.594362014Z\",\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"items\": [\n      {\n        \"name\": \"matic-mainnet\",\n        \"chain_id\": \"137\",\n        \"is_testnet\": false,\n        \"label\": \"Polygon Mainnet\",\n        \"category_label\": \"Polygon\",\n        \"logo_url\": \"https://www.datocms-assets.com/86369/1677870347-property-1-polygon-zkevm-icon-white.svg\",\n        \"color_theme\": {\n          \"hex\": \"#8247E5\",\n          \"css_rgb\": \"rgb(130 71 229)\"\n        },\n        \"last_seen_at\": \"2024-06-26T09:50:16Z\"\n      },\n      {\n        \"name\": \"moonbeam-mainnet\",\n        \"chain_id\": \"1284\",\n        \"is_testnet\": false,\n        \"label\": \"Moonbeam Mainnet\",\n        \"category_label\": \"Moonbeam\",\n        \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\",\n        \"color_theme\": {\n          \"hex\": \"#54CBC8\",\n          \"css_rgb\": \"rgb(84 203 200)\"\n        },\n        \"last_seen_at\": \"2024-10-04T01:11:42Z\"\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre>"},{"location":"builders/integrations/indexers/covalent/#security","title":"Security","text":"Get token approvals for address <p>Get token approvals for address is used to get a list of approvals across all token contracts categorized by spenders for a wallet\u2019s assets</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-mainnet/approvals/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T02:11:10.587740726Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1284,\n    \"chain_name\": \"moonbeam-mainnet\",\n    \"items\": [\n      {\n        \"token_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n        \"token_address_label\": \"xcDOT\",\n        \"ticker_symbol\": \"xcDOT\",\n        \"contract_decimals\": 10,\n        \"logo_url\": \"https://logos.covalenthq.com/tokens/1284/0xffffffff1fcacbd218edc0eba20fc2308c778080.png\",\n        \"quote_rate\": 4.169,\n        \"balance\": \"1655341603\",\n        \"balance_quote\": 0.6901119142907,\n        \"pretty_balance_quote\": \"$0.69\",\n        \"spenders\": [\n          {\n            \"spender_address\": \"0xbc7e02c4178a7df7d3e564323a5c359dc96c4db4\",\n            \"spender_address_label\": \"Stella stDOT\",\n            \"allowance\": \"UNLIMITED\",\n            \"value_at_risk_quote\": 0.6901119142907,\n            \"pretty_value_at_risk_quote\": \"$0.69\",\n            \"risk_factor\": \"LOW RISK\"\n          }\n        ]\n      },\n      {\n        \"token_address\": \"0x818ec0a7fe18ff94269904fced6ae3dae6d6dc0b\",\n        \"token_address_label\": \"USD Coin\",\n        \"ticker_symbol\": \"USDC\",\n        \"contract_decimals\": 6,\n        \"logo_url\": \"https://logos.covalenthq.com/tokens/1284/0x818ec0a7fe18ff94269904fced6ae3dae6d6dc0b.png\",\n        \"quote_rate\": 0.09,\n        \"balance\": \"1\",\n        \"balance_quote\": 0,\n        \"pretty_balance_quote\": \"$0.00\",\n        \"spenders\": [\n          {\n            \"spender_address\": \"0x70085a09d30d6f8c4ecf6ee10120d1847383bb57\",\n            \"spender_address_label\": null,\n            \"allowance\": \"UNLIMITED\",\n            \"value_at_risk_quote\": 0,\n            \"pretty_value_at_risk_quote\": \"$0.00\",\n            \"risk_factor\": \"LOW RISK\"\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> <p>The GoldRush API offers many additional methods, including NFT, price, Bitcoin, and utility methods. Be sure to check out the GoldRush API for more information on each of these methods.  </p>"},{"location":"builders/integrations/indexers/covalent/#api-parameters-and-resources","title":"API Parameters and Resources","text":""},{"location":"builders/integrations/indexers/covalent/#api-parameters","title":"API Parameters","text":"MoonbeamMoonriverMoonbase Alpha Parameter Value Response Formats JSON, CSV Real-Time Data Latency 2 blocks Batch Data Latency 30 minutes API Free Tier Limit of 4 RPS API Premium Tier Limit of 50 RPS Parameter Value Response Formats JSON, CSV Real-Time Data Latency 2 blocks Batch Data Latency 30 minutes API Free Tier Limit of 4 RPS API Premium Tier Limit of 50 RPS Parameter Value Response Formats JSON, CSV Real-Time Data Latency 2 blocks Batch Data Latency 30 minutes API Free Tier Limit of 4 RPS API Premium Tier Limit of 50 RPS"},{"location":"builders/integrations/indexers/covalent/#api-resources","title":"API Resources","text":"<ul> <li>API Reference and In-Browser Endpoint Demo</li> <li>GoldRush Quickstart</li> <li>Written Guides</li> </ul>"},{"location":"builders/integrations/indexers/covalent/#how-to-use-the-unified-api","title":"How to Use the Unified API","text":"<p>First, make sure you have your API Key which begins with <code>cqt_</code> or <code>ckey_</code>. Once you have your API key, you can access any of the supported endpoints. To get information for a specific network, you must provide the chain ID.</p>"},{"location":"builders/integrations/indexers/covalent/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started with the GoldRush API, you will need to have the following:</p> <ul> <li>A free GoldRush API Key</li> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/integrations/indexers/covalent/#using-curl","title":"Using Curl","text":"<p>One of the supported endpoints is the token holders endpoint, which returns a list of all the token holders of a particular token. For this example, you can check the token holders for the ERTH token. The contract address for the ERTH token on Moonbase Alpha is <code>0x08B40414525687731C23F430CEBb424b332b3d35</code>.</p> <p>Try running the command below in a terminal window after replacing the placeholder with your API key.</p> <pre><code>curl https://api.covalenthq.com/v1/1287/tokens/\\\n0x08B40414525687731C23F430CEBb424b332b3d35/token_holders/ \\\n-u INSERT_YOUR_API_KEY:\n</code></pre> <p>Note</p> <p>The colon <code>:</code> after the API key is required to skip the password prompt.</p> <p>Unless you already owned some ERTH tokens, your address will be missing from that list. Head over to the Moonbase Alpha ERC-20 Faucet to generate some ERTH tokens for yourself. Now repeat the same GoldRush API request as above. The GoldRush API updates in real-time, so you should now see your address in the list of token holders for the ERTH token.</p>"},{"location":"builders/integrations/indexers/covalent/#using-javascript","title":"Using Javascript","text":"<p>Copy and paste the below code block into your preferred environment or JSFiddle. After setting the API key, set the address constant. Remember for Moonbase Alpha the chain ID is <code>1287</code>.</p> Using FetchUsing Async <pre><code>// Set your API key\nconst apiKey = 'INSERT_YOUR_API_KEY';\n\nfunction getData() {\n  const address = '0xFEC4f9D5B322Aa834056E85946A32c35A3f5aDD8'; // example\n  const chainId = '1287'; // Moonbase Alpha TestNet chain ID\n  const url = new URL(\n    `https://api.covalenthq.com/v1/${chainId}/address/${address}/balances_v2/`\n  );\n\n  url.search = new URLSearchParams({\n    key: apiKey,\n  });\n\n  // Use fetch API to get Covalent data\n  fetch(url)\n    .then((resp) =&gt; resp.json())\n    .then(function (data) {\n      const result = data.data;\n\n      console.log(result);\n      return result;\n    });\n}\n\ngetData();\n</code></pre> <pre><code>// Set your API key\nconst apiKey = 'INSERT_YOUR_API_KEY';\nconst address = '0xFEC4f9D5B322Aa834056E85946A32c35A3f5aDD8'; // Example\nconst chainId = '1287'; // Moonbase Alpha TestNet chain ID\nconst url = new URL(\n  `https://api.covalenthq.com/v1/${chainId}/address/${address}/balances_v2/`\n);\n\nurl.search = new URLSearchParams({\n  key: apiKey,\n});\n\nasync function getData() {\n  const response = await fetch(url);\n  const result = await response.json();\n  console.log(result);\n  return result;\n}\n\ngetData();\n</code></pre> <p>The balances endpoint returns a list of all ERC-20 and NFT token balances, including ERC-721 and ERC-1155 balances, along with their current spot prices (if available).</p> <p></p>"},{"location":"builders/integrations/indexers/covalent/#using-python","title":"Using Python","text":"<p>GoldRush doesn\u2019t have an official API wrapper. To query the API directly, you will have to use the Python requests library. Install requests into your environment from the command line with <code>pip install requests</code>. Then import it and use it in your code. Use the HTTP verbs get methods to return the information from the API. Copy and paste the below code block into your preferred environment and run it. The output should look similar to the screenshot above, however the formatting may vary depending on your environment.</p> <pre><code>import requests\n\ndef fetch_wallet_balance(address):\n    api_url = \"https://api.covalenthq.com\"\n    endpoint = f\"/v1/1287/address/{address}/balances_v2/\"\n    url = api_url + endpoint\n    response = requests.get(url, auth=(\"INSERT_YOUR_API_KEY\", \"\"))\n    print(response.json())\n    return response.json()\n\n# Example address request\nfetch_wallet_balance(\"0xFEC4f9D5B322Aa834056E85946A32c35A3f5aDD8\")\n</code></pre> <p>Note</p> <p>The second parameter of <code>auth</code> is empty because no password is required\u2014your API key is all that's needed.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/indexers/moralis/","title":"Access Moonbeam Data via Moralis APIs","text":""},{"location":"builders/integrations/indexers/moralis/#introduction","title":"Introduction","text":"<p>As a one-stop solution for blockchain development, Moralis offers a comprehensive platform that empowers developers to create, launch, and scale decentralized applications (dApps) with ease.</p> <p>It provides a suite of tools and services designed to streamline the process of accessing Web3 data and interacting with blockchain networks. Its offerings are structured into these primary categories:</p> <ul> <li> <p>EVM API - The EVM API allows developers to query essential data for Ethereum Virtual Machine (EVM)-compatible blockchains. Moralis provides dedicated APIs for four key areas: NFTs, tokens, wallets, and general blockchain information</p> </li> <li> <p>Streams API - the Streams API enables developers to listen for on-chain events, such as smart contract event emissions, in real-time. Popular use cases include real-time wallet notifications, asset monitoring, and gaming event notifications</p> </li> <li> <p>RPC API - the RPC API offers a secure and reliable connection to various blockchain networks. It provides a high-performance gateway for developers to interact with blockchain nodes, ensuring stable and efficient communication between dApps and the blockchain</p> </li> </ul> <p>This guide will show you how to access the API endpoints for Moonbeam using curl commands and the Moralis SDK using JavaScript and Python snippets.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/indexers/moralis/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To interact with Moralis' API endpoints, an account and API key are required.</p> <p>Head to the sign up page to create an account. Once you're in, navigate to the API keys section. There, you can generate your own unique API key. Be sure to copy it for future use.</p> <p></p>"},{"location":"builders/integrations/indexers/moralis/#querying-the-evm-api","title":"Querying the EVM API","text":"<p>With the API key, you can try Moralis' REST APIs. The following examples show how the EVM API works:</p> <p>Get the token balance of a wallet:  </p> <pre><code>curl --request GET \\\n--url 'https://deep-index.moralis.io/api/v2.2/0xd4d7fb1f98dD66f6D1f393E8e237AdF74c31F3ea/erc20?chain=moonbeam' \\\n--header 'accept: application/json' \\\n--header 'X-API-Key: INSERT_YOUR_API_KEY' \n</code></pre> <p>Get the list of owners of an NFT:  </p> <pre><code>curl --request GET \\\n--url 'https://deep-index.moralis.io/api/v2.2/nft/0xfffffffffffffffffffffffffffffffffffffffff/owners?chain=moonbeam&amp;format=decimal' \\\n--header 'accept: application/json' \\\n--header 'X-API-Key: INSERT_YOUR_API_KEY' \n</code></pre> <p>For a comprehensive overview of EVM APIs and their capabilities, please refer to Moralis' official documentation.</p>"},{"location":"builders/integrations/indexers/moralis/#using-the-moralis-SDK","title":"Using the Moralis SDK","text":"<p>Moralis has an SDK that allows developers to seamlessly integrate Moralis' API into their backend infrastructure. This SDK offers a wide array of features, including:</p> <ul> <li>Data querying from EVM APIs  </li> <li>Integration of Web3 authentication  </li> <li>A collection of utility functions for efficient data transformation and formatting  </li> </ul> <p>Moralis currently provides official SDK support for two primary programming languages:</p> <ul> <li>Node.js</li> <li>Python</li> </ul> <p>You can install Moralis SDK with the following commands: </p> npmyarnpnpmpip <pre><code>npm install moralis\n</code></pre> <pre><code>yarn add moralis\n</code></pre> <pre><code>pnpm add moralis\n</code></pre> <pre><code>pip install moralis\n</code></pre> <p>Once the SDK is ready, you can leverage it to query Moralis APIs. Here's an example of how to interact with the EVM API using a JSON-RPC interface:</p> JavaScriptPython <pre><code>import Moralis from 'moralis';\n\ntry {\n  await Moralis.start({\n    apiKey: 'INSERT_YOUR_API_KEY',\n  });\n\n  const response = await Moralis.EvmApi.block.getBlock({\n    chain: '0x504',\n    blockNumberOrHash: '1',\n  });\n\n  console.log(response.raw);\n} catch (e) {\n  console.error(e);\n}\n</code></pre> <pre><code>from moralis import evm_api\n\napi_key = \"INSERT_YOUR_API_KEY\"\n\nparams = {\"chain\": \"moonbeam\", \"block_number_or_hash\": \"1\"}\n\nresult = evm_api.block.get_block(\n    api_key=api_key,\n    params=params,\n)\n\nprint(result)\n</code></pre> <p>For more information on advanced features and configurations within the Moralis SDK, please refer to the official JavaScript and Python documentation.</p>"},{"location":"builders/integrations/indexers/moralis/#accessing-stream-api","title":"Accessing the Stream API","text":"<p>The Moralis Streams API is a tool for developers to listen to and react to events happening on blockchains in real time. This API lets you listen for specific events, such as a new transaction being added to a block, a particular smart contract function being called, or an NFT being transferred and delivering the event via Webhook. </p> <p>Head over to the Streams page from your Moralis dashboard and click Create a new stream to get started.</p> <p></p> <p>To get started quickly, choose a predefined template. This example focuses on transactions related to xcDOT. Select the Contract Activity template to listen for events related specifically to xcDOT.</p> <p></p> <p>On the next page, enter the following details:</p> <ol> <li>Enter the smart contract address for xcDOT: <pre><code>0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080\n</code></pre></li> <li>Select Moonbeam from the available network options. Moralis supports listening to events on Moonbeam, Moonriver, and Moonbase Alpha </li> <li>Customize the events you want to receive. For this example, choose All contract events. You may also test the stream to confirm it captures the needed data</li> <li>Connect the stream to an endpoint to receive updates from Moralis</li> <li>Click Save to activate your stream</li> </ol> <p></p> <p>Now you're all set. Once you activate your stream, it will be added to your list of streams on your dashboard.</p> <p></p>"},{"location":"builders/integrations/indexers/moralis/#accessing-rpc-api","title":"Accessing the RPC API","text":"<p>To use the Moralis Moonbeam RPC endpoint, visit the Nodes page, click Create Node, and take the following steps:</p> <ol> <li>Select Moonbeam as the protocol</li> <li>Choose Mainnet as the chain</li> <li>Click Create Node</li> </ol> <p></p> <p>Your RPC endpoint will be generated for you to easily copy, and your Moonbeam node will be up and running in seconds, ready to handle your RPC requests. You can view your nodes at any time from your dashboard.</p> <p></p> <p>And that's it! Hope this guide has been helpful. For advanced features and more complex use cases, refer to the official Moralis documentation for further details.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/indexers/subquery/","title":"Indexing Moonbeam with SubQuery","text":""},{"location":"builders/integrations/indexers/subquery/#introduction","title":"Introduction","text":"<p>SubQuery is a data aggregation layer that operates between the layer-1 blockchains (such as Moonbeam and Polkadot) and DApps. This service unlocks blockchain data and transforms it into a queryable state so that it can be used in intuitive applications. It allows DApp developers to focus on their core use case and front end without needing to waste time on building a custom back end for data processing.</p> <p>SubQuery supports indexing the Ethereum Virtual Machine (EVM) and Substrate data for any of the Moonbeam networks. A key advantage of using SubQuery is that you can flexibly collect query data across both Moonbeam's EVM and Substrate code with a single project and tool, and then query this data using GraphQL.</p> <p>For example, SubQuery can filter and query EVM logs and transactions in addition to Substrate data sources. SubQuery introduces more advanced filters than other indexers, allowing filtering of non-contract transactions, transaction senders, contracts, and indexed log arguments, so developers can build a wide variety of projects that cater to their specific data needs.</p> <p>This quick-start guide will show you how to create a SubQuery project and configure it to index Substrate and EVM data on Moonbeam.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/indexers/subquery/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Later on in this guide, you have the option of deploying your project to a locally running SubQuery node. To do so, you need to have the following installed on your system:</p> <ul> <li>Docker</li> <li>Docker Compose</li> </ul> <p>Note</p> <p>If Docker Compose was installed for Linux via the <code>sudo apt install docker-compose</code> command, you might run into some errors later on in the guide. Please be sure to follow the instructions for Linux from the official Install Docker Compose guide.</p>"},{"location":"builders/integrations/indexers/subquery/#create-a-project","title":"Create a Project","text":"<p>To get started, you'll need to create a SubQuery project:</p> <ol> <li> <p>Globally install the SubQuery CLI:</p> npmyarn <pre><code>npm install -g @subql/cli\n</code></pre> <pre><code>yarn global add @subql/cli\n</code></pre> </li> </ol> <p>Note</p> <p>Using yarn to install <code>@subql/cli</code> is discouraged due to its poor dependency management, which can result in various errors.</p> <ol> <li> <p>Initialize your SubQuery project using the following command:</p> <pre><code>subql init PROJECT_NAME\n</code></pre> </li> <li> <p>You'll be prompted to answer a series of questions:</p> <ol> <li> <p>For the Select a network family question, although Moonbeam is EVM compatible, the Moonbeam templates are under the Polkadot family, so you can choose Polkadot</p> <p>  subql init moonbeam-demo ? Select a network family    EVM Networks   Algorand   Cosmos   Concordium   NEAR &gt; Polkadot   Stellar </p> </li> <li> <p>The next screen will prompt you to Select a network. You can choose between Moonbeam and Moonriver</p> <p>Note</p> <p>To build a project on Moonbase Alpha, you can select either network and adapt it later on</p> <p>  subql init moonbeam-demo ? Select a network family Polkadot ? Select a network    Humanode   HydraDX   Integritee Shell   Interlay   Karura   Khala   KILT Spiritnet   Kusama   Kylin &gt; Moonbeam   Moonriver   Nodle   OriginTrail   Parallel   Parallel Heiko   Polkadex   Polkadot   Quartz   Shiden   Kusama Asset Hub (Statemine) (Move up and down to reveal more choices) </p> </li> <li> <p>You'll be prompted to Select a template project. Depending on the network you chose in the prior step, the template options may vary</p> MoonbeamMoonriver Template Description <code>moonbeam-evm-starter</code> A starter EVM project that indexes ERC-20 <code>Transfer</code> events and <code>approve</code> calls <code>moonbeam-substrate-evm-starter</code> A starter Substrate and EVM project that indexes ERC-20 <code>Transfer</code> events and calls to the Staking Pallet's <code>joinCandidates</code> and <code>executeLeaveCandidates</code> extrinsics <code>Moonbeam-starter</code> A starter Substrate project that indexes balance transfers through the Balances Pallet Template Description <code>moonriver-evm-starter</code> A starter EVM project that indexes ERC-20 <code>Transfer</code> events and <code>approve</code> calls <code>Moonriver-starter</code> A starter Substrate project that indexes balance transfers through the Balances Pallet <p>  subql init moonbeam-demo ? Select a network family Polkadot ? Select a network Moonbeam ? Select a template project  &gt; moonbeam-evm-starter   moonbeam-substrate-evm-starter   Moonbeam-starter   Other                         Enter a custom git endpoint </p> </li> <li> <p>You'll be prompted to add additional information, such as the RPC endpoint, the project's author, and the description of the project. For these, you can just hit enter and accept the default or customize them as you see fit</p> <p>Note</p> <p>To avoid hitting the rate limits of public RPC endpoints, it is recommended to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</p> <p>  subql init moonbeam-demo ? Select a network family Polkadot ? Select a network Moonbeam ? Select a template project Moonbeam-starter RPC endpoint: [wss://moonbeam.api.onfinality.io/public-ws]: Author [SubQuery Team]: Description [This project can be used as a starting p...]: Preparing project... done moonbeam-demo is ready </p> </li> </ol> </li> <li> <p>After you've gone through all of the prompts, the starter project will be cloned. You'll just need to install dependencies from within the project directory:</p> npmyarn <pre><code>cd PROJECT_NAME &amp;&amp; npm install\n</code></pre> <pre><code>cd PROJECT_NAME &amp;&amp; yarn install\n</code></pre> </li> </ol>"},{"location":"builders/integrations/indexers/subquery/#configure-the-network","title":"Configure the Network","text":"<p>The template projects already come pre-configured for the network selected while initializing your project. However, if you're working off of an existing project or want to configure your project for Moonbase Alpha instead of Moonbeam or Moonriver, you can update the network configurations in the <code>project.ts</code> file.</p> <p>The <code>network</code> configuration is as follows for each network:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>network: {\n  chainId: \n    '0xfe58ea77779b7abda7da4ec526d14db9b1e9cd40a217c34892af80a9b332b76d',\n  endpoint: ['INSERT_RPC_API_ENDPOINT'],\n  chaintypes: {\n    file: ./dist/chaintypes.js,\n  },\n},\n</code></pre> <pre><code>network: {\n  chainId: '0x401a1f9dca3da46f5c4091016c8a2f26dcea05865116b286f60f668207d1474b',\n  endpoint: ['INSERT_RPC_API_ENDPOINT'],\n  chaintypes: {\n    file: ./dist/chaintypes.js,\n  },\n},\n</code></pre> <pre><code>network: {\n  chainId: '0x91bc6e169807aaa54802737e1c504b2577d4fafedd5a02c10293b1cd60e39527',\n  endpoint: ['https://rpc.api.moonbase.moonbeam.network'],\n  chaintypes: {\n    file: ./dist/chaintypes.js,\n  },\n},\n</code></pre> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/integrations/indexers/subquery/#modify-the-graphql-schema","title":"Modify the GraphQL Schema","text":"<p>In the <code>schema.graphql</code> file, you can use GraphQL entities to define the shape of your data. Once you've edited the GraphQL schema for your needs, you'll need to generate the required GraphQL models. To do so, you can run the following command:</p> npmyarn <pre><code>npm run codegen\n</code></pre> <pre><code>yarn codegen\n</code></pre>  npm run codegen &gt; moonbeam-demo@0.0.4 codegen &gt; subql codegen ============================== ---------Subql Codegen--------- ============================== Project manifest generated to /home/papermoon/moonbeam-demo/project.yaml * Schema Transfer generated ! * Schema Account generated ! * Models index generated ! * Types index generated ! <p>The generated models will be created in the <code>src/types/models</code> directory. These models will be used in the mapping handlers that process the indexed data.</p> <p>Note</p> <p>If you make changes to the <code>schema.graphql</code> file, you'll need to regenerate your types.</p>"},{"location":"builders/integrations/indexers/subquery/#index-substrate-data","title":"Index Substrate Data","text":"<p>The <code>project.ts</code> file is the entry point into your indexer; it defines what type of data to index and the mapping functions that are responsible for handling and processing the indexed data.</p> <p>To index Substrate data, you'll need to ensure that the type of the <code>project</code> is <code>SubstrateProject</code>.</p> <pre><code>const project: SubstrateProject = { ... }\n</code></pre>"},{"location":"builders/integrations/indexers/subquery/#the-substrate-data-source","title":"The Substrate Data Source","text":"<p>In the <code>project.dataSources</code> array, you'll define the Substrate data source and the data to be indexed. The format of the data source is as follows:</p> <pre><code>datasources: [\n  {\n    kind: 'substrate/Runtime',\n    startBlock: INSERT_START_BLOCK,\n    endBlock: INSERT_END_BLOCK,\n    mapping: {\n      file: './dist/index.js',\n      handlers: [\n        {\n          kind: 'INSERT_HANDLER_KIND',\n          handler: 'INSERT_HANDLER_FUNCTION_NAME',\n          filter: {\n            'INSERT_FILTER_TYPE': 'INSERT_FILTER',\n          },\n        },\n      ],\n    },\n  },\n],\n</code></pre> <p>Each property can be defined as follows:</p> <ul> <li><code>kind</code> - the kind of data source that you'll use, which for Substrate data is the <code>substrate/Runtime</code> source</li> <li><code>startBlock</code> - (optional) the block from which the indexer will start processing blocks</li> <li><code>endBlock</code> - (optional) after this block, the indexer will stop processing blocks</li> <li><code>mapping</code> - the data to be indexed and the handlers for the data<ul> <li><code>file</code> - the entry path for the mapping</li> <li><code>handlers</code> - the handlers for specific kinds of data<ul> <li><code>kind</code> - the kind of handler. For Substrate data, there are three kinds: <code>substrateBlockHandler</code>, <code>substrate/EventHandler</code>, and <code>substrate/CallHandler</code></li> <li><code>handler</code> - the name of the handler function that will process this data</li> <li><code>filter</code> - (optional) the filter type and data that will trigger a mapping handler. For example, what block, event, or extrinsic to index</li> </ul> </li> </ul> </li> </ul>"},{"location":"builders/integrations/indexers/subquery/#substrate-mapping-handlers","title":"Substrate Mapping Handlers","text":"<p>Using only certain handlers and filters will improve your indexer's efficiency. The handlers available for Substrate data are as follows:</p> <ul> <li> <p>The block handler is used to index block data and is called once for every block. As such, this type of handler will slow your project down significantly and should only be used if absolutely necessary. The supported filters for the block handler are: <code>specVersion</code>, <code>modulo</code>, and <code>timestamp</code></p> Filter Description Example <code>specVersion</code> Filters the blocks that fall into a spec version range <code>specVersion: [null, 2000]</code> <code># Indexes blocks with a spec</code> <code>version between 0 - 2000</code> <code>modulo</code> Filters the blocks at an interval <code>modulo: 50 # Indexes every 50 blocks</code> <code>timestamp</code> Filters the blocks at a time interval (in UTC).  Accepts a valid cron expression <code>timestamp: '*5/ * * * *'</code> <code># Indexes blocks every 5 minutes</code> </li> <li> <p>The event handler is used to index certain Substrate events that are part of the runtime. The supported filters for the event handler are: <code>module</code> and <code>method</code></p> Filter Description Example <code>module</code> Filters the pallet (module) that the event belongs to <code>module: 'balances'</code> <code>method</code> Filters the event <code>method: 'Transfer'</code> </li> <li> <p>The call handler is used to index certain Substrate extrinsics. The supported filters for the call handler are: <code>module</code>, <code>method</code>, <code>success</code>, and <code>isSigned</code></p> Filter Description Example <code>module</code> Filters the pallet (module) that extrinsic belongs to <code>module: 'balances'</code> <code>method</code> Filters the extrinsic <code>method: 'Transfer'</code> <code>success</code> Filters extrinsics based on outcome <code>success: true</code> <code>isSigned</code> Filters extrinsics based on whether they're signed <code>isSigned: true</code> </li> </ul>"},{"location":"builders/integrations/indexers/subquery/#index-ethereum-data","title":"Index Ethereum Data","text":"<p>The <code>project.ts</code> file is the entry point into your indexer; it defines what type of data to index and the mapping functions that are responsible for handling and processing the indexed data.</p> <p>To index Substrate data, you'll need to ensure that the type of the <code>project</code> is <code>SubstrateProject&lt;FrontierEvmDatasource&gt;</code>.</p> <pre><code>const project: SubstrateProject&lt;FrontierEvmDatasource&gt; = { ... }\n</code></pre>"},{"location":"builders/integrations/indexers/subquery/#the-evm-data-source","title":"The EVM Data Source","text":"<p>In the <code>project.dataSources</code> array, you'll define the EVM data source and the data to be indexed. The EVM data source is powered by a data processor specifically made to work with Moonbeam\u2019s implementation of Frontier. It allows you to reference specific ABI resources used by the processor to parse arguments and the smart contract address that the events are from or the call is made to. In general, it acts as middleware that can provide extra filtering and data transformation.</p> <p>The format of the data source is as follows:</p> <pre><code>datasources: [\n  {\n    kind: 'substrate/FrontierEvm',\n    startBlock: INSERT_START_BLOCK,\n    endBlock: INSERT_END_BLOCK,\n    processor: {\n      file: './node_modules/@subql/frontier-evm-processor/dist/bundle.js',\n      options: {\n        abi: '',\n        address: '',\n      },\n    },\n    assets: ''\n    mapping: {\n      file: './dist/index.js',\n      handlers: [\n        {\n          kind: 'INSERT_HANDLER_KIND',\n          handler: 'INSERT_HANDLER_FUNCTION_NAME',\n          filter: {\n            'INSERT_FILTER_TYPE': 'INSERT_FILTER',\n          },\n        },\n      ],\n    },\n  },\n],\n</code></pre> <p>Each property can be defined as follows:</p> <ul> <li><code>kind</code> - the kind of data source that you'll use, which for EVM data is the <code>substrate/FrontierEVM</code> source</li> <li><code>startBlock</code> - (optional) the block from which the indexer will start processing blocks</li> <li><code>endBlock</code> - (optional) after this block, the indexer will stop processing blocks</li> <li><code>processor</code> - the Frontier EVM data processor configuration<ul> <li><code>file</code> - the file where the data processor code lives</li> <li><code>options</code> - (optional) the processor options specific to the Frontier EVM processor<ul> <li><code>abi</code> - (optional) the ABI that is used to parse arguments. The <code>abi</code> value must be a key in the <code>assets</code> configuration</li> <li><code>address</code> - (optional) the contract address where the event is emitted from or the call is made to. Using <code>null</code> will capture contract creation calls</li> </ul> </li> <li><code>assets</code> - (optional) an object of external asset ABI files</li> </ul> </li> <li><code>mapping</code> - the data to be indexed and the handlers for the data<ul> <li><code>file</code> - the entry path for the mapping</li> <li><code>handlers</code> - the handlers for specific kinds of data<ul> <li><code>kind</code> - the kind of handler. For EVM data, there are two kinds: <code>substrate/FrontierEvmCall</code> and <code>substrate/FrontierEvmEvent</code></li> <li><code>handler</code> - the name of the handler function that will process this data</li> <li><code>filter</code> - (optional) the filter type and data that will trigger a mapping handler. For example, what block, event, or extrinsic to index</li> </ul> </li> </ul> </li> </ul>"},{"location":"builders/integrations/indexers/subquery/#evm-mapping-handlers","title":"Frontier EVM Mapping Handlers","text":"<p>Using only certain handlers and filters will improve your indexer's efficiency. The handlers available for EVM data are as follows:</p> <ul> <li> <p>The Frontier EVM call handler is used to index transactions that are formatted based on Ethers <code>TransactionResponse</code> type, but varies slightly. For information on the exact changes, please refer to SubQuery's documentation. The supported filters for the call handler are: <code>function</code> and <code>from</code></p> Filter Description Example <code>function</code> Filters the call by function signature or selector <code>function: '0x095ea7b3'</code> <code>function: 'approve(address to,uint256 value)'</code> <code>from</code> Filters the call by the address that sent the transaction <code>from: '0x6bd193ee6d2104f14f94e2ca6efefae561a4334b'</code> </li> <li> <p>The Frontier EVM event handler is used to index certain EVM events. The supported filter for the event handler is: <code>topics</code></p> Filter Description Example <code>topics</code> Filters the event log by topics, which follows the Ethereum JSON-RPC log filters <code>topics: 'Transfer(address indexed from,address indexed to,uint256 value)'</code> </li> </ul>"},{"location":"builders/integrations/indexers/subquery/#run-your-indexer","title":"Run Your Indexer","text":"<p>To run your indexer locally using Docker, you can take the following steps:</p> <ol> <li> <p>Build your project:</p> npmyarn <pre><code>npm run build\n</code></pre> <pre><code>yarn build\n</code></pre> <p>  npm run build &gt; moonbeam-demo@0.0.4 build &gt; subql build Project manifest generated to /home/papermoon/moonbeam-demo/project.yaml Building and packing code ... Done! </p> <p>Note</p> <p>If you make changes to the <code>project.ts</code> file, you'll need to rebuild your project.</p> </li> <li> <p>Start up the Docker container for your indexer:</p> npmyarn <pre><code>npm run start:docker\n</code></pre> <pre><code>yarn start:docker\n</code></pre> <p> t found at block 171198 subquery-node_1  | 2025-04-07T04:29:52.601Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171203 subquery-node_1  | 2025-04-07T04:29:52.663Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.701Z &lt;benchmark&gt; INFO INDEXING: 3148.19 blocks/s. Target height: 5,105,255. Current height: 171,205. Estimated time remaining: 0 days 00 hours 26 mins subquery-node_1  | 2025-04-07T04:29:52.710Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.717Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.739Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.750Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.765Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.780Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.807Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.826Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.864Z &lt;sandbox-#3&gt; INFO New transfer event </p> </li> <li> <p>Head to <code>http://localhost:3000</code> to open the GraphQL playground and submit queries. You can open up the DOCS or SCHEMA tab on the playground as a reference when creating your queries</p> <p>Note</p> <p>It may take a few minutes before the GraphQL server is ready. You'll be able to access the playground after you see the following log:</p> <pre><code>substrate-demo-graphql-engine-1  | &lt;subql-query&gt; INFO Started playground at `http://localhost:3000`\n</code></pre> <p></p> </li> </ol> <p>And that's it! For a step-by-step tutorial on how to use the <code>moonbeam-substrate-evm-starter</code> template project, you can refer to SubQuery's Moonbeam (EVM) Quick Start documentation.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/indexers/subsquid/","title":"Indexing Moonbeam with SQD (formerly Subsquid)","text":""},{"location":"builders/integrations/indexers/subsquid/#introduction","title":"Introduction","text":"<p>SQD (formerly Subsquid) is a data network that allows rapid and cost-efficient retrieval of blockchain data from 100+ chains using SQD\u2019s decentralized data lake and open-source SDK. In very simple terms, SQD can be thought of as an ETL (extract, transform, and load) tool with a GraphQL server included. It enables comprehensive filtering, pagination, and even full-text search capabilities.</p> <p>SQD has native and full support for both Ethereum Virtual Machine (EVM) and Substrate data. Since Moonbeam is a Substrate-based smart contact platform that is EVM-compatible, SQD can be used to index both EVM and Substrate-based data. SQD offers a Substrate Archive and Processor and an EVM Archive and Processor. The Substrate Archive and Processor can be used to index both Substrate and EVM data. This allows developers to extract on-chain data from any of the Moonbeam networks and process EVM logs as well as Substrate entities (events, extrinsics, and storage items) in one single project and serve the resulting data with one single GraphQL endpoint. If you exclusively want to index EVM data, it is recommended to use the EVM Archive and Processor.</p> <p>This quick-start guide will show you how to create Substrate and EVM projects with SQD and configure it to index data on Moonbeam. For a more comprehensive end-to-end tutorial, be sure to check out Index a Local Moonbeam Development Node with SQD.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/indexers/subsquid/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started with SQD, you'll need to have the following:</p> <ul> <li>Node.js version 16 or newer</li> <li>Docker</li> <li>Squid CLI</li> </ul> <p>Note</p> <p>The Squid template is not compatible with <code>yarn</code>, so you'll need to use <code>npm</code> instead.</p>"},{"location":"builders/integrations/indexers/subsquid/#index-substrate-calls-events","title":"Index Substrate Data on Moonbeam","text":"<p>To get started indexing Substrate data on Moonbeam, you'll need to create a SQD project and configure it for Moonbeam by taking the following steps:</p> <ol> <li> <p>Create a SQD project based on the Substrate template by running:</p> <pre><code>sqd init INSERT_SQUID_NAME --template substrate\n</code></pre> <p>For more information on getting started with this template, please check out the Quickstart: Substrate chains guide on SQD's documentation site.</p> </li> <li> <p>Navigate into the root directory of your Squid project and install dependencies by running:  </p> <pre><code>npm ci\n</code></pre> </li> <li> <p>To configure your SQD project to run on Moonbeam, you'll need to update the <code>typegen.json</code> file. The <code>typegen.json</code> file is responsible for generating TypeScript interface classes for your data. Depending on the network you're indexing data on, the <code>specVersions</code> value in the <code>typegen.json</code> file should be configured as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>\"specVersions\": \"https://v2.archive.subsquid.io/metadata/moonbeam\",\n</code></pre> <pre><code>\"specVersions\": \"https://v2.archive.subsquid.io/metadata/moonriver\",\n</code></pre> <pre><code>\"specVersions\": \"https://v2.archive.subsquid.io/metadata/moonbase\",\n</code></pre> </li> <li> <p>Modify the <code>src/processor.ts</code> file, which is where Squids instantiate the processor, configure it, and attach handler functions. The processor fetches historical on-chain data from an Archive, which is a specialized data lake. You'll need to configure your processor to pull data from the Archive that corresponds to the network you are indexing data on:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>const processor = new SubstrateBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_API_ENDPOINT',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonbeam-mainnet'\n  archive: lookupArchive('moonbeam', {type: 'Substrate', release: 'ArrowSquid'}),\n})\n</code></pre> <pre><code>const processor = new SubstrateBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_API_ENDPOINT',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonriver-mainnet'\n  archive: lookupArchive('moonriver', {type: 'Substrate', release: 'ArrowSquid'}),\n})\n</code></pre> <pre><code>const processor = new SubstrateBatchProcessor();\nprocessor.setDataSource({\n  chain: 'https://rpc.api.moonbase.moonbeam.network',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonbase-testnet'\n  archive: lookupArchive('moonbase', {type: 'Substrate', release: 'ArrowSquid'}),\n})\n</code></pre> <p>Note</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> </li> <li> <p>There's one more quick change to make to the template. The SQD Substrate template is configured to process Substrate account types, but Moonbeam uses Ethereum-style accounts. The <code>getTransferEvents</code> function in the <code>src/main.ts</code> file will iterate through the events ingested by <code>processor.ts</code> and store the relevant <code>transfer</code> events in the database. In the <code>getTransferEvents</code> function, remove the ss58 encoding of the <code>from</code> and <code>to</code> fields. In an unmodified Substrate template, the <code>from</code> and <code>to</code> fields are ss58 encoded as shown:</p> <pre><code>from: ss58.codec('kusama').encode(rec.from),\nto: ss58.codec('kusama').encode(rec.to),\n</code></pre> <p>After removing the ss58 encoding, the respective lines are:</p> <pre><code>from: rec.from, \nto: rec.to, \n</code></pre> </li> </ol> <p>And that's all you have to do to configure your SQD project to index Substrate data on Moonbeam! Now you can update the <code>schema.graphql</code>, <code>typegen.json</code>, <code>src/main.ts</code>, and <code>src/processor.ts</code> files to index the data you need for your project! Next, take the steps in the Run your Indexer section to run your indexer and query your Squid.</p>"},{"location":"builders/integrations/indexers/subsquid/#index-ethereum-contracts","title":"Index Ethereum Data on Moonbeam","text":"<p>To get started indexing EVM data on Moonbeam, you'll need to create a SQD project and configure it for Moonbeam by taking the following steps:</p> <ol> <li> <p>You can create a SQD project for EVM data by using the generic EVM template or you can use the ABI template for indexing data related to a specific contract:</p> EVMABI <pre><code>sqd init INSERT_SQUID_NAME --template evm\n</code></pre> <pre><code>sqd init INSERT_SQUID_NAME --template abi\n</code></pre> <p>For more information on getting started with both of these templates, please check out the following SQD docs:</p> <ul> <li>Quickstart: EVM chains</li> <li>Quickstart: generate from ABI</li> </ul> </li> <li> <p>Navigate into the root directory of your Squid project and install dependencies by running:</p> <pre><code>npm ci\n</code></pre> </li> <li> <p>Modify the <code>src/processor.ts</code> file, which is where Squids instantiate the processor, configure it, and attach handler functions. The processor fetches historical on-chain data from an Archive, which is a specialized data lake. You'll need to configure your processor to pull data from the Archive that corresponds to the network you are indexing data on:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>const processor = new EvmBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_API_ENDPOINT',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonbeam-mainnet'\n  archive: lookupArchive('moonbeam', { type: 'EVM' })\n})\n</code></pre> <pre><code>const processor = new EvmBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_API_ENDPOINT',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonriver-mainnet'\n  archive: lookupArchive('moonriver', { type: 'EVM' }),\n})\n</code></pre> <pre><code>const processor = new EvmBatchProcessor();\nprocessor.setDataSource({\n  chain: 'https://rpc.api.moonbase.moonbeam.network',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonbase-testnet'\n  archive: lookupArchive('moonbase', { type: 'EVM' }),\n})\n</code></pre> <p>Note</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> </li> </ol> <p>And that's all you have to do to configure your SQD project to index EVM data on Moonbeam! Now you can update the <code>schema.graphql</code>, <code>src/main.ts</code>, and <code>src/processor.ts</code> files to index the data you need for your project! Continue with the steps in the following section to run your indexer and query your Squid.</p>"},{"location":"builders/integrations/indexers/subsquid/#run-your-indexer","title":"Run Your Indexer","text":"<p>These steps apply to both Substrate and EVM indexers. Running your SQD indexer after you've properly configured it takes only a few steps:  </p> <ol> <li> <p>Launch Postgres by running:</p> <pre><code>sqd up\n</code></pre> </li> <li> <p>Inspect and run the processor:</p> <pre><code>sqd process\n</code></pre> </li> <li> <p>Open a separate terminal window in the same directory, then start the GraphQL server:</p> <pre><code>sqd serve\n</code></pre> </li> <li> <p>You can query your template Substrate or EVM Squid with the below sample queries. If you've modified the template Squid to index different data, you'll need to modify this query accordingly</p> Substrate IndexerEVM Indexer <pre><code>query MyQuery {\n  accountsConnection(orderBy: id_ASC) {\n    totalCount\n  }\n}\n</code></pre> <pre><code>query MyQuery {\n  burns(orderBy: value_DESC) {\n    address\n    block\n    id\n    txHash\n    value\n  }\n}\n</code></pre> </li> </ol> <p>If you're interested in a step-by-step tutorial to get started indexing data on Moonbeam, you can check out the Index NFT Token Transfers on Moonbeam with SQD tutorial!</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/indexers/thegraph/","title":"Using The Graph on Moonbeam","text":""},{"location":"builders/integrations/indexers/thegraph/#introduction","title":"Introduction","text":"<p>Indexing protocols organize information so that applications can access it more efficiently. For example, Google indexes the entire Internet to provide information rapidly when you search for something.</p> <p>The Graph is a decentralized and open-source indexing protocol for querying networks like Ethereum. In short, it provides a way to efficiently store data emitted by events from smart contracts so that other projects or dApps can access it easily.</p> <p>Furthermore, developers can build APIs called subgraphs. Users or other developers can use subgraphs to query data specific to a set of smart contracts. Data is fetched with a standard GraphQL API. You can visit The Graph's documentation site to learn about The Graph protocol.</p> <p>Due to the support of Ethereum tracing modules on Moonbeam, The Graph can index blockchain data on Moonbeam. This guide takes you through the creation of a subgraph based on the Exiled Racers Game Asset contract on Moonbeam.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/indexers/thegraph/#create-a-subgraph","title":"Create a Subgraph","text":"<p>You can quickly create a subgraph from an existing contract. To get started, you'll follow these steps:</p> <ol> <li>Initialize your subgraph project</li> <li>Deploy your subgraph to the Subgraph Studio</li> <li>Publish your subgraph to The Graph's decentralized network</li> <li>Query your subgraph from your dApp</li> </ol> <p>Note</p> <p>You can query your subgraph via the free, rate-limited development query URL, which can be used for development and staging. The free plan includes 100,000 queries per month. If you need to make more queries or want a production-ready plan, please check out The Graph's documentation.</p>"},{"location":"builders/integrations/indexers/thegraph/#create-a-subgraph","title":"Create a Subgraph on Subgraph Studio","text":"<p>To initialize your subgraph, you must head to the Subgraph Studio and connect your wallet. After you've connected your wallet, you'll be prompted to add an email address, which will be used to send notifications about your account. You can only associate one account with your email address, so make sure you've connected the account you intend to continue to use.</p> <p>After you get your email address set up and verified, you can create a subgraph from your dashboard by clicking Create a Subgraph.</p> <p></p> <p>Then, you can:</p> <ol> <li>Enter a name. Note that it is recommended to use title case for the name (i.e., Subgraph Name Chain Name); the name cannot be changed once it has been created</li> <li>Click Create Subgraph</li> </ol> <p></p> <p>You will then land on your subgraph's page. Here, you can add additional information about your subgraph, such as the description, source code URL, website URL, and categories your subgraph belongs to. You'll also find all the CLI commands you need to initialize and deploy your subgraph.</p> <p></p>"},{"location":"builders/integrations/indexers/thegraph/#install-graph-cli","title":"Install Graph CLI\u2060","text":"<p>To install Graph CLI on your local machine, run the following:</p> npmyarn <pre><code>npm install -g @graphprotocol/graph-cli\n</code></pre> <pre><code>yarn global add @graphprotocol/graph-cli\n</code></pre>"},{"location":"builders/integrations/indexers/thegraph/#initialize-your-subgraph","title":"Initialize Your Subgraph\u2060","text":"<p>Before you initialize your subgraph, you should verify the contract address from which you want to query data on Moonscan. This is so the Graph CLI can pull in the ABI directly from Moonscan for you. To learn how to verify your contracts, please refer to the Verify Contracts section of the docs.</p> <p>You'll need to grab the initialization command from your subgraph's page on Subgraph Studio to initialize your subgraph. Or, if you know the name of your subgraph, you can use the following command:</p> <pre><code>graph init INSERT_SUBGRAPH_NAME\n</code></pre> <p>To initialize your subgraph, you'll need to provide some additional information, which you will be prompted to provide in your terminal:</p> <ol> <li>For Protocol, select ethereum, as Moonbeam is an Ethereum-compatible chain</li> <li>Hit enter for Subgraph slug to use the default one provided, or change as needed</li> <li>Again, hit enter for Directory to create the subgraph in to use the default one provided, or change as needed</li> <li>For Ethereum network, scroll down and select the Moonbeam network you are working with. Note that the Moonbase Alpha TestNet is labeled as mbase</li> <li>Enter the contract address to index and query data from. The CLI will attempt to fetch the ABI from Moonscan. If it doesn't work, make sure that your contract has been verified and retry if needed. Otherwise, you will need to input it manually as a JSON file after your project has been successfully created. If you don't have a smart contract in mind and want to follow along with the tutorial, you can use the EXR contract address:  <pre><code>0x515e20e6275CEeFe19221FC53e77E38cc32b80Fb\n</code></pre></li> <li>Enter a start block. The start block allows you to save time by only indexing the necessary blocks. To get all of the data for this contract, you can use the block the contract was deployed</li> <li>Contract Name should be automatically populated for you, but if not, manually enter the name of the contract</li> <li>For Index contract events as entities, it is recommended to set this to true, as it will automatically add mappings to your subgraph for every event emitted. In other words, you'll be able to capture and store the data emitted by these events</li> </ol> <p>The CLI will generate your project for you, and you can continue to add additional contracts as needed.</p> graph init moonbeam-demo  \u00b7 ethereum  \u00b7 moonbeam-demo  \u00b7 moonbeam-demo  \u00b7 moonbeam  \u00b7 0x515e20e6275CEeFe19221FC53e77E38cc32b80Fb \u2716 Failed to fetch Start Block: Failed to fetch contract creation transaction hash  \u00b7 false  \u00b7 1137478  \u00b7 EXRGameAsset  \u00b7 true   Generate subgraph   Write subgraph to directory  Create subgraph scaffold  Initialize networks config  Initialize subgraph repository  Install dependencies with yarn  Generate ABI and schema types with yarn codegen Subgraph moonbeam-demo created in moonbeam-demo <p>Your project will be created using the slug name you provided in step two. At this time, you can feel free to check out the project and modify the logic as needed for your project. For more information on how to write a subgraph, check out The Graph's documentation. Note that for this quick start example, if you selected to index contract events as entities, you don't need to modify anything; you can deploy the project as is.</p>"},{"location":"builders/integrations/indexers/thegraph/#deploy","title":"Deploy a Subgraph","text":"<p>To deploy your subgraph to Subgraph Studio, change to the subgraph directory in your terminal and run the following commands:</p> <ol> <li> <p>Generate types for your smart contract ABIs and the subgraph schema</p> <pre><code>graph codegen\n</code></pre> <p> graph codegen  Skip migration: Bump mapping apiVersion from 0.0.1 to 0.0.2  Skip migration: Bump mapping apiVersion from 0.0.2 to 0.0.3  Skip migration: Bump mapping apiVersion from 0.0.3 to 0.0.4  Skip migration: Bump mapping specVersion from 0.0.1 to 0.0.2  Skip migration: Bump mapping specVersion from 0.0.2 to 0.0.4 \u2714 Apply migrations \u2714 Load subgraph from subgraph.yaml   Load contract ABI from abis/EXRGameAsset.json \u2714 Load contract ABIs   Generate types for contract ABI: EXRGameAsset (abis/EXRGameAsset.json)   Write types to generated/EXRGameAsset/EXRGameAsset.ts \u2714 Generate types for contract ABIs \u2714 Generate types for data source templates \u2714 Load data source template ABIs \u2714 Generate types for data source template ABIs \u2714 Load GraphQL schema from schema.graphql   Write types to generated/schema.ts \u2714 Generate types for GraphQL schema </p> </li> <li> <p>Compile your subgraph to Wasm</p> <pre><code>graph build\n</code></pre> <p> graph build  Skip migration: Bump mapping apiVersion from 0.0.1 to 0.0.2  Skip migration: Bump mapping apiVersion from 0.0.2 to 0.0.3  Skip migration: Bump mapping apiVersion from 0.0.3 to 0.0.4  Skip migration: Bump mapping specVersion from 0.0.1 to 0.0.2  Skip migration: Bump mapping specVersion from 0.0.2 to 0.0.4 \u2714 Apply migrations \u2714 Load subgraph from subgraph.yaml   Compile data source: EXRGameAsset =&gt; build/EXRGameAsset/EXRGameAsset.wasm \u2714 Compile subgraph   Copy schema file build/schema.graphql   Write subgraph file build/EXRGameAsset/abis/EXRGameAsset.json   Write subgraph manifest build/subgraph.yaml \u2714 Write compiled subgraph to build/ </p> </li> <li> <p>Authenticate your subgraph with your deploy key. The exact command containing the deploy key can be found on your subgraph's page in Subgraph Studio</p> <pre><code>graph auth INSERT_DEPLOY_KEY\n</code></pre> <p> graph auth eb6...  Deploy key set for https://api.studio.thegraph.com/deploy/ </p> </li> <li> <p>Deploy your subgraph and specify the slug for it. Again, you can get the exact command from your subgraph's page in Subgraph Studio</p> <pre><code>graph deploy INSERT_SUBGRAPH_SLUG\n</code></pre> <p>You will be asked for a version label. You can enter something like v0.0.1, but you're free to choose the format</p> <p> graph deploy moonbeam-demo  v0.1  Skip migration: Bump mapping apiVersion from 0.0.1 to 0.0.2  Skip migration: Bump mapping apiVersion from 0.0.2 to 0.0.3  Skip migration: Bump mapping apiVersion from 0.0.3 to 0.0.4  Skip migration: Bump mapping specVersion from 0.0.1 to 0.0.2  Skip migration: Bump mapping specVersion from 0.0.2 to 0.0.4 \u2714 Apply migrations \u2714 Load subgraph from subgraph.yaml   Compile data source: EXRGameAsset =&gt; build/EXRGameAsset/EXRGameAsset.wasm \u2714 Compile subgraph   Copy schema file build/schema.graphql   Write subgraph file build/EXRGameAsset/abis/EXRGameAsset.json   Write subgraph manifest build/subgraph.yaml \u2714 Write compiled subgraph to build/ \u2714 Compile subgraph \u2714 Compile subgraph   Add file to IPFS build/schema.graphql             .. QmQfQiQLmtgpibjDDgP83YfczUzLbuXhKa8FevB58LLuP2   Add file to IPFS build/EXRGameAsset/abis/EXRGameAsset.json             .. QmdXKywXz8MkUvbW5YrPiBzbGKgcMjZbbLjRjWtgGcruXT   Add file to IPFS build/EXRGameAsset/EXRGameAsset.wasm             .. QmSLqNWtL6Uvku5adann325ruz8AgjfqLmn1NFLpZ8JcKK \u2714 Upload subgraph to IPFS Build completed: QmUHKw4sthmV6ve1YqFJMNvkviYf3sWzVA3qk4xjx5587q Deployed to https://thegraph.com/studio/subgraph/moonbeam-demo Subgraph endpoints: Queries (HTTP):     https://api.studio.thegraph.com/query/80185/moonbeam-demo/v0.1 </p> </li> </ol> <p>Once you've successfully deployed your subgraph, you can query it using the subgraph endpoint that was printed to your terminal.</p>"},{"location":"builders/integrations/indexers/thegraph/#test-your-subgraph","title":"Test Your Subgraph\u2060","text":"<p>You can test your subgraph by making a query in the Playground section of your subgraph's page on Subgraph Studio.</p> <p></p> <p>To test from your dApp, you can use the API endpoint that was printed to your terminal. You can also find the endpoint on your subgraph's page in Subgraph Studio under the Details tab.</p> <p></p> <p>You can use the following example code to query your subgraph. First, you'll need to install Axios:</p> npmyarn <pre><code>npm install axios\n</code></pre> <pre><code>yarn add axios\n</code></pre> <p>Then, use the code snippet below. Be sure to insert your own query and endpoint:</p> <pre><code>import axios from 'axios';\n\nconst graphqlQuery = `query MyQuery {\n  gameAssetMinteds {\n    blockNumber\n    transactionHash\n    id\n    tokenId\n  }\n}`;\n\nconst queryUrl =\n  'INSERT_QUERY_URL'; // Will look something like this: \n  // https://api.studio.thegraph.com/query/80185/moonbeam-demo/version/latest\n\nconst graphQLRequest = {\n  method: 'post',\n  url: queryUrl,\n  data: {\n    query: graphqlQuery,\n  },\n};\n\n// Send the GraphQL query\naxios(graphQLRequest)\n  .then((response) =&gt; {\n    // Handle the response here\n    const data = response.data.data;\n    console.log(data);\n  })\n  .catch((error) =&gt; {\n    // Handle any errors\n    console.error(error);\n  });\n</code></pre>"},{"location":"builders/integrations/indexers/thegraph/#publish-your-subgraph","title":"Publish Your Subgraph to The Graph's Decentralized Network","text":"<p>Once your subgraph is ready for production, you can publish it to the decentralized network.</p> <p>Note</p> <p>Publishing requires Arbitrum ETH. When upgrading your subgraph, a small amount is airdropped to facilitate your initial protocol interactions.</p> <p>For publishing instructions, please refer to The Graph's documentation.</p>"},{"location":"builders/integrations/indexers/thegraph/#additional-resources","title":"Additional Resources","text":"<ul> <li>To explore all the ways you can optimize and customize your subgraph for better performance, read more about creating a subgraph</li> <li>For more information on querying data from your subgraph, check out the Querying the Graph guide</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/oracles/api3/","title":"Use API3 To Request Off-Chain Data on Moonbeam","text":""},{"location":"builders/integrations/oracles/api3/#introduction","title":"Introduction","text":"<p>API3 is a decentralized solution for delivering traditional API services to smart contract platforms in an easily accessible and scalable way. It is governed by a Decentralized Autonomous Organization (DAO), the API3 DAO. API3 enables developers to access off-chain resources from within their smart contracts without worrying about security implications. API3 makes this possible through Airnodes, which are first-party oracles, and on-chain data feeds sourced from these oracles.</p> <p>Developers can use Airnode to request off-chain data inside their smart contracts on Moonbeam networks. An Airnode is a first-party oracle that pushes off-chain API data to your on-chain contract. Airnode lets API providers easily run their own first-party oracle nodes. That way, they can provide data to any on-chain dApp interested in their services, all without an intermediary.</p> <p>An on-chain smart contract requests the RRP (Request Response Protocol) contract (<code>AirnodeRrpV0.sol</code>) that adds the request to the event logs. The Airnode then accesses the event logs, fetches the API data, and performs a callback to the requester with the requested data.</p> <p></p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/oracles/api3/#calling-an-airnode","title":"Request Off-Chain Data From an Airnode","text":"<p>Requesting off-chain data essentially involves triggering an Airnode and getting its response through your smart contract. The smart contract in this case would be the requester contract, which will make a request to the desired off-chain Airnode and then capture its response.</p> <p>The requester calling an Airnode primarily focuses on two tasks:</p> <ul> <li>Making the request</li> <li>Accepting and decoding the response</li> </ul> <p></p> <p>Here is an example of a basic requester contract to request data from an Airnode:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@api3/airnode-protocol/contracts/rrp/requesters/RrpRequesterV0.sol\";\nimport \"@openzeppelin/contracts@4.9.5/access/Ownable.sol\";\n\n// A Requester that will return the requested data by calling the specified Airnode.\ncontract Requester is RrpRequesterV0, Ownable {\n    mapping(bytes32 =&gt; bool) public incomingFulfillments;\n    mapping(bytes32 =&gt; int256) public fulfilledData;\n\n    // Make sure you specify the right _rrpAddress for your chain while deploying the contract.\n    constructor(address _rrpAddress) RrpRequesterV0(_rrpAddress) {}\n\n    // To receive funds from the sponsor wallet and send them to the owner.\n    receive() external payable {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    // The main makeRequest function that will trigger the Airnode request.\n    function makeRequest(\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        bytes calldata parameters\n\n    ) external {\n        bytes32 requestId = airnodeRrp.makeFullRequest(\n            airnode,                        // airnode address\n            endpointId,                     // endpointId\n            sponsor,                        // sponsor's address\n            sponsorWallet,                  // sponsorWallet\n            address(this),                  // fulfillAddress\n            this.fulfill.selector,          // fulfillFunctionId\n            parameters                      // encoded API parameters\n        );\n        incomingFulfillments[requestId] = true;\n    }\n\n    function fulfill(bytes32 requestId, bytes calldata data)\n        external\n        onlyAirnodeRrp\n    {\n        require(incomingFulfillments[requestId], \"No such request made\");\n        delete incomingFulfillments[requestId];\n        int256 decodedData = abi.decode(data, (int256));\n        fulfilledData[requestId] = decodedData;\n    }\n\n    // To withdraw funds from the sponsor wallet to the contract.\n    function withdraw(address airnode, address sponsorWallet) external onlyOwner {\n        airnodeRrp.requestWithdrawal(\n        airnode,\n        sponsorWallet\n        );\n    }\n}\n</code></pre> <p>You can also try deploying the example contract on Remix.</p>"},{"location":"builders/integrations/oracles/api3/#contract-addresses","title":"Contract Addresses","text":"<p>The <code>_rrpAddress</code> is the main <code>airnodeRrpAddress</code>. The RRP contracts have already been deployed on-chain. The addresses for the <code>_rrpAddress</code> on Moonbeam networks are as follows:</p> MoonbeamMoonriverMoonbase Alpha Contract Addresses AirnodeRrpV0 <code>0xa0AD79D995DdeeB18a14eAef56A549A04e3Aa1Bd</code> Contract Addresses AirnodeRrpV0 <code>0xa0AD79D995DdeeB18a14eAef56A549A04e3Aa1Bd</code> Contract Addresses AirnodeRrpV0 <code>0xa0AD79D995DdeeB18a14eAef56A549A04e3Aa1Bd</code>"},{"location":"builders/integrations/oracles/api3/#request-params","title":"Request Parameters","text":"<p>The <code>makeRequest()</code> function expects the following parameters to make a valid request:</p> <ul> <li><code>airnode</code> - specifies the Airnode address</li> <li><code>endpointId</code> - specifies which endpoint to be used</li> <li><code>sponsor</code> and <code>sponsorWallet</code> - specifies which wallet will be used to fulfill the request</li> <li><code>parameters</code> - specifies the API and Reserved Parameters (see Airnode ABI specifications for how these are encoded). Parameters can be encoded off-chain using the <code>@airnode-abi</code> library</li> </ul>"},{"location":"builders/integrations/oracles/api3/#response-params","title":"Response Parameters","text":"<p>The callback to the requester contract contains two parameters:</p> <ul> <li><code>requestId</code> - first acquired when making the request and passed here as a reference to identify the request for which the response is intended</li> <li><code>data</code> - in case of a successful response, this is the requested data encoded and contains a timestamp in addition to other response data. Decode it using the <code>decode()</code> function from the <code>abi</code> object</li> </ul> <p>Note</p> <p>Sponsors should not fund a <code>sponsorWallet</code> with more than they can trust the Airnode with, as the Airnode controls the private key to the <code>sponsorWallet</code>. The deployer of such Airnode undertakes no custody obligations, and the risk of loss or misuse of any excess funds sent to the <code>sponsorWallet</code> remains with the sponsor.</p>"},{"location":"builders/integrations/oracles/api3/#dapis","title":"dAPIs: API3 Data Feeds","text":"<p>dAPIs are continuously updated streams of off-chain data, such as the latest cryptocurrency, stock, and commodity prices. They can power decentralized applications such as DeFi lending, synthetic assets, stablecoins, derivatives, NFTs, and more.</p> <p>The data feeds are continuously updated by first-party oracles using signed data. DApp owners can read the on-chain value of any dAPI in real-time.</p> <p>Because they are composed of first-party data feeds, dAPIs offer security, transparency, cost-efficiency, and scalability in a turnkey package.</p> <p></p> <p>To learn more about how dAPIs work, please refer to API3's documentation.</p>"},{"location":"builders/integrations/oracles/api3/#subscribing-to-dapis","title":"Subscribe to dAPIs","text":"<p>The API3 Market lets users access dAPIs on Moonbeam, Moonriver, and the Moonbase Alpha TestNet (currently labeled as the Moonbeam TestNet).</p> <p>From the API3 Market home page, you can search for a given chain. After selecting the chain, you can view the list of available dAPIs and click on one for more information. For example, you can click on the <code>USDT/USD</code> pair available for Moonbeam to view the parameters of the dAPI, including the deviation and the heartbeat.</p> <p>The supported parameters for dAPIs are:</p> Deviation Heartbeat 0.25% 24 hours 0.5% 24 hours 1% 24 hours 5% 24 hours <p></p>"},{"location":"builders/integrations/oracles/api3/#select-a-dapi","title":"Configure and Activate a dAPI","text":"<p>Once you've selected a dAPI to interact with, check the expiration date and update the parameters as needed. You can update the parameters and extend the subscription by purchasing a new configuration. If the dAPI has been activated and the configurations listed will work for you, you can skip ahead to the next section to learn how to interact with the dAPI.</p> <p>To purchase a plan with new configurations, click on Purchase new plan and take the following steps:</p> <ol> <li>Select your parameters</li> <li>Click on Connect Wallet</li> </ol> <p></p> <p>Once connected, you'll be able to purchase your new plan. Click on Purchase and sign the transaction. After the transaction has been confirmed, you will be able to see the updated configuration for the dAPI.</p>"},{"location":"builders/integrations/oracles/api3/#get-data","title":"Get Data from a dAPI","text":"<p>To interact with a dAPI, you'll need to get the proxy address for it. Click on the Integrate button from the dAPI details page. Then, on the integration page, copy the proxy address.</p> <p></p> <p>With the proxy address in hand, you'll be able to integrate the dAPI into a smart contract. Here's an example of a basic contract that reads from a dAPI:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts@4.9.5/access/Ownable.sol\";\nimport \"@api3/contracts/api3-server-v1/proxies/interfaces/IProxy.sol\";\n\ncontract DataFeedReaderExample is Ownable {\n    // The proxy contract address obtained from the API3 Market UI\n    address public proxyAddress;\n\n    // Updating the proxy contract address is a security-critical\n    // action. In this example, only the owner is allowed to do so\n    function setProxyAddress(address _proxyAddress) public onlyOwner {\n        proxyAddress = _proxyAddress;\n    }\n\n    function readDataFeed()\n        external\n        view\n        returns (int224 value, uint256 timestamp)\n    {\n        // Use the IProxy interface to read a dAPI via its\n        // proxy contract\n        (value, timestamp) = IProxy(proxyAddress).read();\n        // If you have any assumptions about `value` and `timestamp`,\n        // make sure to validate them after reading from the proxy\n    }\n}\n</code></pre> <p>The example contract contains two functions:</p> <ul> <li><code>setProxyAddress()</code> - used to set the address of the dAPI proxy contract</li> <li><code>readDataFeed()</code> - a <code>view</code> function that returns the latest price of the set dAPI</li> </ul> <p>Try deploying it on Remix!</p>"},{"location":"builders/integrations/oracles/api3/#additional-resources","title":"Additional Resources","text":"<p>Here are some additional developer resources:</p> <ul> <li>API3 Market</li> <li>API3 Docs</li> <li>API3 DAO GitHub</li> <li>API3 Medium</li> <li>API3 YouTube</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/oracles/band-protocol/","title":"Band Protocol Oracle","text":""},{"location":"builders/integrations/oracles/band-protocol/#introduction","title":"Introduction","text":"<p>Developers have two ways to fetch prices from Band\u2019s oracle infrastructure. On one hand, they can use Band\u2019s smart contracts on Moonbeam. Doing so, they access data that is on-chain and is updated either at regular intervals or when price slippage is more than a target amount (different for each token). On the other hand, devs can use the JavaScript helper library, which uses an API endpoint to fetch the data using similar functions as those from the smart contracts, but this implementation bypasses the blockchain entirely.  This can be useful if your DApp front-end needs direct access to the data.</p> <p>The Aggregator Contract address can be found in the following table:</p> Network Aggregator Contract Address Moonbase Alpha 0xDA7a001b254CD22e46d3eAB04d937489c93174C3    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/oracles/band-protocol/#supported-token","title":"Supported Token","text":"<p>Price queries with any denomination are available as long as the base and quote symbols are supported (base/quote). For example:</p> <ul> <li><code>BTC/USD</code></li> <li><code>BTC/ETH</code></li> <li><code>ETH/EUR</code></li> </ul> <p>At the time of writing, the list of supported symbols can be found on the Band Standard Dataset page of the Band website. There are more than 146 price pairs available to query.</p>"},{"location":"builders/integrations/oracles/band-protocol/#querying-prices","title":"Querying Prices","text":"<p>As stated before, developers can leverage two methods to query prices from Band's oracle: </p> <ul> <li>Band's smart contract on Moonbeam (deployed to Moonbase Alpha TestNet for now)</li> <li>JavaScript helper library</li> </ul>"},{"location":"builders/integrations/oracles/band-protocol/#get-data-using-smart-contracts","title":"Get Data Using Smart Contracts","text":"<p>Contracts can query on-chain data, such as token prices, from Band's oracle by implementing the interface of the <code>StdReference</code> contract, which exposes the <code>getReferenceData</code> and <code>getReferenceDataBulk</code> functions.</p> <p>The first function, <code>getReferenceData</code>, takes two strings (the base and the quote symbol) as the inputs. The function queries the <code>StdReference</code> contract for the latest rates available for those two tokens. It returns a <code>ReferenceData</code> struct.</p> <p>The <code>ReferenceData</code> struct has the following elements:</p> <ul> <li>Rate: the exchange rate in terms of base/quote. The value returned is multiplied by 10<sup>18</sup></li> <li>Last updated base: the last time when the base price was updated (since UNIX epoch)</li> <li>Last updated quote: the last time when the quoted price was updated (since UNIX epoch)</li> </ul> <pre><code>struct ReferenceData {\n  uint256 rate; \n  uint256 lastUpdatedBase; \n  uint256 lastUpdatedQuote;\n}\n</code></pre> <p>The second function, <code>getReferenceDataBulk</code>, takes information as data arrays. For example, if you pass in <code>['BTC','BTC','ETH']</code> as base and <code>['USD','ETH','EUR']</code> as quote, the <code>ReferenceData</code>returned array contains the information regarding the following pairs:</p> <ul> <li><code>BTC/USD</code></li> <li><code>BTC/ETH</code></li> <li><code>ETH/EUR</code></li> </ul>"},{"location":"builders/integrations/oracles/band-protocol/#example-contract","title":"Example Contract","text":"<p>The following smart contract code provides some simple examples of the <code>StdReference</code> contract and the <code>getReferenceData</code> function - these are not meant for production. The <code>IStdReference.sol</code> interface defines ReferenceData structure and the functions available to make the queries.</p> <pre><code>pragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\ninterface IStdReference {\n    /// A structure returned whenever someone requests for standard reference data.\n    struct ReferenceData {\n        uint256 rate; // base/quote exchange rate, multiplied by 1e18.\n        uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.\n        uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.\n    }\n\n    /// Returns the price data for the given base/quote pair. Revert if not available.\n    function getReferenceData(string memory _base, string memory _quote)\n        external\n        view\n        returns (ReferenceData memory);\n\n    /// Similar to getReferenceData, but with multiple base/quote pairs at once.\n    function getReferenceDataBulk(string[] memory _bases, string[] memory _quotes)\n        external\n        view\n        returns (ReferenceData[] memory);\n}\n</code></pre> <p>Next, you can use the following <code>DemoOracle</code> script. It provides four functions:</p> <ul> <li>getPrice(string[] base, string[] quotes) - a view function that queries a single base. In this example, the price of <code>BTC</code> quoted in <code>USD</code></li> <li>getMultiPrices(string[] bases, string[] quotes) - a view function that queries multiple bases. In this example, the price of <code>BTC</code> and <code>ETH</code>, both quoted in <code>USD</code></li> <li>savePrice(string base, string quote) - a public function that queries the base/quote pair. Each element is provided as separate strings, for example <code>_base = \"BTC\", _quotes = \"USD\"</code>. This sends a transaction and modifies the <code>price</code> variable stored in the contract</li> <li>saveMultiPrices(string[] bases, string[] quotes) - a public  function that queries each base/quote pair. Each element is provided as a string array. For example, <code>_bases = [\"BTC\",\"ETH\"], _quotes = [\"USD\",\"USD\"]</code>. This sends a transaction and modifies the <code>prices</code> array stored in the contract, which will hold the price of each pair in the same order as specified in the input</li> </ul> <p>When deployed, the constructor function needs the Aggregator Contract address for the target network.</p> <pre><code>pragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./IStdReference.sol\";\n\ncontract DemoOracle {\n    IStdReference ref;\n\n    uint256 public price;\n    uint256[] public pricesArr;\n\n    constructor(IStdReference _ref) public {\n        ref = _ref; // Aggregator Contract Address\n                    // Moonbase Alpha 0xDA7a001b254CD22e46d3eAB04d937489c93174C3\n\n    }\n\n    function getPrice(string memory _base, string memory _quote) external view returns (uint256){\n        IStdReference.ReferenceData memory data = ref.getReferenceData(_base,_quote);\n        return data.rate;\n    }\n\n    function getMultiPrices(string[] memory _bases, string[] memory _quotes) external view returns (uint256[] memory){\n        IStdReference.ReferenceData[] memory data = ref.getReferenceDataBulk(_bases,_quotes);\n\n        uint256 len = _bases.length;\n        uint256[] memory prices = new uint256[](len);\n        for (uint256 i = 0; i &lt; len; i++) {\n            prices[i] = data[i].rate;\n        }\n\n        return prices;\n    }\n\n    function savePrice(string memory _base, string memory _quote) external {\n        IStdReference.ReferenceData memory data = ref.getReferenceData(_base,_quote);\n        price = data.rate;\n    }\n\n    function saveMultiPrices(\n        string[] memory _bases,\n        string[] memory _quotes\n    ) public {\n        require(_bases.length == _quotes.length, \"BAD_INPUT_LENGTH\");\n        uint256 len = _bases.length;\n        IStdReference.ReferenceData[] memory data = ref.getReferenceDataBulk(_bases,_quotes);\n        delete pricesArr;\n        for (uint256 i = 0; i &lt; len; i++) {\n            pricesArr.push(data[i].rate);\n        }\n\n    }\n}\n</code></pre>"},{"location":"builders/integrations/oracles/band-protocol/#try-it-in-moonbase\u00a0alpha","title":"Try it in Moonbase\u00a0Alpha","text":"<p>There is predeployed contract available in the Moonbase Alpha TestNet (at address <code>0xf15c870344c1c02f5939a5C4926b7cDb90dEc655</code>) so you can easily check the information fed from Band Protocol's oracle. To do so, you need the following interface contract:</p> <pre><code>pragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\ninterface TestInterface {\n    function getPrice(string memory _base, string memory _quote) external view returns (uint256);\n\n    function getMultiPrices(string[] memory _bases, string[] memory _quotes) external view returns (uint256[] memory);\n}\n</code></pre> <p>With it, you will have two view functions available - very similar to the previous examples:</p> <ul> <li>getPrice(string base, string quote) - provides the price feed for a single base/quote pair that is given as input to the function, that is, \"BTC\", \"USD\"</li> <li>getMultiPrices(string[] bases, string[] quotes) - provides the price feed for a multiple base/quote pairs that are given as input to the function, that is, [\"BTC\", \"ETH\", \"ETH\"], [\"USD\", \"USD\", \"EUR\"]</li> </ul> <p>For example, using Remix, you can easily query the <code>BTC/USD</code> price pair using this interface.</p> <p>After creating the file and compiling the contract, head to the Deploy and Run Transactions tab, enter the contract address (<code>0xf15c870344c1c02f5939a5C4926b7cDb90dEc655</code>) and click on At Address. Make sure you have set the ENVIRONMENT to Injected Web3 so you are connected to Moonbase Alpha. </p> <p></p> <p>This will create an instance of the demo contract that you can interact with. Use the functions <code>getPrice()</code> and <code>getMultiPrices()</code> to query the data of the corresponding pair.</p> <p></p>"},{"location":"builders/integrations/oracles/band-protocol/#bandchainjs-javascript-helper-library","title":"BandChain.js JavaScript Helper Library","text":"<p>The helper library also supports a similar <code>getReferenceData</code> function. To get started, the library needs to be installed:</p> <pre><code>npm install @bandprotocol/bandchain.js\n</code></pre> <p>The library provides a constructor function that requires an endpoint to point to. This returns an instance that then enables all the necessary methods, such as the <code>getReferenceData</code> function.  When querying for information, the function accepts an array where each element is the base/quote pair needed. For example:</p> <pre><code>getReferenceData(['BTC/USD', 'BTC/ETH', 'ETH/EUR'])\n</code></pre> <p>Then, it returns an array object with the following structure:</p> <pre><code>[\n  {\n    pair: 'BTC/USD',\n    rate: rate,\n    updated: { base: lastUpdatedBase, quote: lastUpdatedQuote}\n  },\n  {\n    pair: 'BTC/ETH',\n    rate: rate,\n    updated: { base: lastUpdatedBase, quote: lastUpdatedQuote}\n  },\n  {\n    pair: 'ETH/EUR',\n    rate: rate,\n    updated: { base: lastUpdatedBase, quote: lastUpdatedQuote}\n  },\n]\n</code></pre> <p>Where <code>lastUpdatedBase</code> and <code>lastUpdatedQuote</code> are the last time when the base and quote prices were updated respectively (since UNIX epoch).</p>"},{"location":"builders/integrations/oracles/band-protocol/#example-usage","title":"Example Usage","text":"<p>The following JavaScript script provides a simple example of the <code>getReferenceData</code> function.</p> <pre><code>const BandChain = require('@bandprotocol/bandchain.js');\n\nconst queryData = async () =&gt; {\n  const endpoint = 'https://poa-api.bandchain.org';\n\n  const bandchain = new BandChain(endpoint);\n  const dataQuery = await bandchain.getReferenceData([\n    'BTC/USD',\n    'BTC/ETH',\n    'ETH/EUR',\n  ]);\n  console.log(dataQuery);\n};\n\nqueryData();\n</code></pre> <p>You can execute this code with a node, and the following <code>dataQuery</code> output should look like this:</p>  node getData.js [   {     pair: 'BTC/USD',     rate: 15787.679999999998,     updated: { base: 1605181892, quote: 1605181910 }   },   {     pair: 'BTC/ETH',     rate: 34.31432980503814,     updated: { base: 1605181892, quote: 1605181892 }   },   {     pair: 'ETH/EUR',     rate: 389.47110012528356,     updated: { base: 1605181892, quote: 1605180505 }   } ] <p>Note that compared to the request done via smart contracts, the result is given directly in the correct units.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/oracles/dia/","title":"Introduction to DIA Oracles","text":""},{"location":"builders/integrations/oracles/dia/#introduction","title":"Introduction","text":"<p>DIA offers customizable oracles that are tailored to each dApp\u2019s needs. Each oracle can be customized in several ways, including data sources, data cleansing filters, pricing and computational methodologies, update mechanisms, and more. This ensures that the data and oracle remain robust and resilient to market conditions and provide a global market price as well as specific individual or cross-chain market prices.</p> <p>By collecting billions of raw trades directly from over 90 sources, including CEXs, DEXs, and NFT marketplaces, DIA enables full transparency, customization, and control throughout the entire value stack. DIA's data and oracle suite comprise price feeds for 20,000+ assets, including cryptocurrencies, NFT collections, and liquid-staked tokens, as well as random number generation and other data feed types.</p> <p>You can visit DIA's documentation to learn how to Request a Custom Oracle.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/oracles/dia/#token-price-feeds","title":"Token Price Feeds","text":"<p>DIA token price feeds provide smart contracts with real-time price information for 3,000+ cryptocurrencies, sourced transparently from 90+ trusted, high-volume DEXs and CEXs.</p>"},{"location":"builders/integrations/oracles/dia/#moonbeam-demo-price-oracles","title":"Moonbeam Demo Price Oracles","text":"<p>DIA has deployed the following demo oracles for the Moonbeam community, which provide a limited selection of cryptocurrency price feeds with predefined configuration settings:</p> Network Contract Address Moonbeam <code>0x1f1BAe8D7a2957CeF5ffA0d957cfEDd6828D728f</code> Moonriver <code>0x11f74b94afb5968119c98ea277a2b73208bb39ab</code> Moonbase Alpha <code>0xe23d8713aa3a0a2c102af772d2467064821b8d46</code> <p>The demo oracle contracts deployed to Moonbeam are the DIA Key-Value Oracle Contract V2. The contract is structured as follows:</p> <pre><code>pragma solidity 0.7.4;\n\ncontract DIAOracleV2 {\n    mapping (string =&gt; uint256) public values;\n    address oracleUpdater;\n\n    event OracleUpdate(string key, uint128 value, uint128 timestamp);\n    event UpdaterAddressChange(address newUpdater);\n\n    constructor() {\n        oracleUpdater = msg.sender;\n    }\n\n    function setValue(string memory key, uint128 value, uint128 timestamp) public {\n        require(msg.sender == oracleUpdater);\n        uint256 cValue = (((uint256)(value)) &lt;&lt; 128) + timestamp;\n        values[key] = cValue;\n        emit OracleUpdate(key, value, timestamp);\n    }\n\n    function getValue(string memory key) external view returns (uint128, uint128) {\n        uint256 cValue = values[key];\n        uint128 timestamp = (uint128)(cValue % 2**128);\n        uint128 value = (uint128)(cValue &gt;&gt; 128);\n        return (value, timestamp);\n    }\n\n    function updateOracleUpdaterAddress(address newOracleUpdaterAddress) public {\n      require(msg.sender == oracleUpdater);\n        oracleUpdater = newOracleUpdaterAddress;\n        emit UpdaterAddressChange(newOracleUpdaterAddress);\n    }\n}\n</code></pre> <p>Note</p> <p>DIA demo oracles are not intended for use in production environments. Developers can request a dedicated, production-ready oracle with custom price feeds and configuration settings. To start the request process, you can check out the Request a Custom Oracle documentation.</p>"},{"location":"builders/integrations/oracles/dia/#price-feeds","title":"Included Price Feeds","text":"<p>The price feeds included with the demo oracles are:</p> <ul> <li>DIA/USD</li> <li>BTC/USD</li> <li>USDC/USD</li> </ul>"},{"location":"builders/integrations/oracles/dia/#how-to-access-dia-oracles","title":"How to Access DIA Oracles","text":"<p>The steps for accessing a price value on DIA oracles are as follows:</p> <ol> <li>Access your oracle smart contract on Moonbeam</li> <li>Call <code>getValue(pair_name)</code> with <code>pair_name</code> being the full pair name, such as <code>BTC/USD</code>. You can use the Read Contract functionality under the Contract tab of the contract on Moonscan to execute this call</li> </ol> <p>The response contains two values:</p> <ul> <li>The current asset price in USD with a fix-comma notation of 8 decimals</li> <li>The UNIX timestamp of the last oracle update</li> </ul> <p>You can find DIA's oracle integration samples in Solidity and Vyper languages by visiting the Fetch Price Data guide on DIA's documentation site.</p>"},{"location":"builders/integrations/oracles/dia/#supported-token-api-endpoints","title":"Supported Token API Endpoints","text":"<p>DIA also supports Rest and GraphQL endpoints to return cryptocurrency price data. You can visit the DIA documentation to see all API endpoints.</p> <p>For example, you can use the following JavaScript scripts to access the BTC/USD price feed:</p> RestGraphQL <pre><code>const axios = require('axios');\n\nconst options = {\n  method: 'GET',\n  url: 'https://api.diadata.org/v1/assetQuotation/Bitcoin/0x0000000000000000000000000000000000000000',\n  headers: { 'Content-Type': 'application/json' },\n};\n\naxios\n  .request(options)\n  .then(function (response) {\n    console.log(response.data);\n  })\n  .catch(function (error) {\n    console.error(error);\n  });\n</code></pre> <pre><code>const axios = require('axios');\n\nconst url = 'https://api.diadata.org/graphql/query';\n\nconst query = `\n  {\n    GetFeed(\n      Filter: \"mair\",\n      BlockSizeSeconds: 480,\n      BlockShiftSeconds: 480,\n      StartTime: 1690449575,\n      EndTime: 1690535975,\n      FeedSelection: [\n        {\n          Address: \"0x0000000000000000000000000000000000000000\",\n          Blockchain:\"Bitcoin\",\n          Exchangepairs:[],\n        },\n      ],\n    )\n    {\n      Name\n      Time\n      Value\n      Pools\n      Pairs\n    }\n  }`;\n\nconst data = {\n  query: query,\n};\n\naxios\n  .post(url, data)\n  .then((response) =&gt; {\n    console.log(response.data);\n  })\n  .catch((error) =&gt; {\n    console.error('Request failed:', error.message);\n  });\n</code></pre> <p>You can refer to DIA's documentation on Rest API endpoints and the GraphQL Endpoint for information on the parameters and return data.</p>"},{"location":"builders/integrations/oracles/dia/#nft-floor-price-feeds","title":"NFT Floor Price Feeds","text":"<p>DIA NFT floor price feeds provide smart contracts with real-time price information for 18,000+ NFT collections, sourced on-chain with 100% transparency from multiple cross-chain NFT marketplaces.</p> <p>Please refer to DIA's documentation to find out how you can request a custom NFT oracle for NFTs on Moonbeam.</p>"},{"location":"builders/integrations/oracles/dia/#random-number-generation","title":"Random Number Generation","text":"<p>DIA xRandom provides smart contracts with unpredictable and unbiased random numbers, facilitating the development of on-chain use cases such as lotteries, prediction markets, NFT launches, and more.</p> <p>DIA leverages the Drand public randomness beacon, and updates its oracle with round numbers, randomness and a signature. Drand runs distributed nodes to produce their randomness beacon. Drand uses Pedersen's DKG (Distributed Key Generation) protocol to create collective private and public keys. Participants in their League of Entropy then generate randomness in rounds and broadcast it together with its signature.</p> <p>To learn more about Drand\u2019s randomness beacon, watch the On-Chain Randomness Oracle | DIA Developer Tutorial and read Drand\u2019s documentation.</p>"},{"location":"builders/integrations/oracles/dia/#moonbeam-demo-randomness-oracle","title":"Moonbeam Demo Randomness Oracle","text":"<p>DIA has deployed a demo oracle on Moonbase Alpha, which can be accessed at the following address:</p> <pre><code>0x48d351ab7f8646239bbade95c3cc6de3ef4a6cec\n</code></pre> <p>The DIA randomness smart contract is structured as follows:</p> <pre><code>pragma solidity ^0.8.0;\n\ncontract DIARandomOracle {\n  struct Random {\n    string randomness;\n    string signature;\n    string previousSignature;\n  }\n\n  mapping(uint256 =&gt; Random) public values;\n  uint256 public lastRound = 0;\n  address public oracleUpdater;\n  event OracleUpdate(string key, uint128 value, uint128 timestamp);\n  event UpdaterAddressChange(address newUpdater);\n\n  constructor() {\n      oracleUpdater = msg.sender;\n  }\n\n  function setRandomValue(\n    uint256 _round,\n    string memory _randomness,\n    string memory _signature,\n    string memory _previousSignature\n  ) public {\n    require(msg.sender == oracleUpdater, \"not a updater\");\n    require(lastRound &lt; _round, \"old round\");\n    lastRound = _round;\n    values[_round] = Random(_randomness, _signature, _previousSignature);\n  }\n\n  function getValue(uint256 _round) external view returns (Random memory) {\n    return values[_round];\n  }\n\n  function updateOracleUpdaterAddress(address newOracleUpdaterAddress)\n    public\n  {\n    require(msg.sender == oracleUpdater, \"not a updater\");\n    oracleUpdater = newOracleUpdaterAddress;\n    emit UpdaterAddressChange(newOracleUpdaterAddress);\n  }\n\n  function getRandomValueFromRound(uint256 _round)\n    external\n    view\n    returns (string memory)\n  {\n    return values[_round].randomness;\n  }\n\n  function getRandomValueFromRoundWithSignature(uint256 _round)\n    external\n    view\n    returns (Random memory)\n  {\n    return values[_round];\n  }\n\n    function getLastRound() public view returns (uint256) {\n    return lastRound;\n  }\n}\n</code></pre> <p>Note</p> <p>DIA demo oracles are not intended for use in production environments. Developers can request a dedicated, production-ready randomness oracle. To start the request process, you can contact the integrations team on Telegram.</p>"},{"location":"builders/integrations/oracles/dia/#how-to-use-the-dia-randomness-oracle","title":"How to Use the DIA Randomness Oracle","text":"<p>The steps for accessing a published random value are as follows:</p> <ol> <li>Access your randomness oracle smart contract on Moonbeam</li> <li>Call <code>getLastRound()</code>to obtain the ID of the latest published round. You can use the Read Contract functionality under the Contract tab of the contract on Moonscan to execute this call</li> <li>Call <code>getRandomValueFromRound(uint256 _round)</code> using the obtained round ID. Again, you can use Moonscan to quickly execute this call</li> </ol> <p>The response contains the randomness value.</p> <p>The signature can also be requested by calling <code>getRandomValueFromRoundWithSignature(uint256 _round)</code>, which returns a tuple containing the randomness value, the signature, and the previous signature.</p> <p>To learn how to deploy a randomness-consuming contract on Moonbeam, please refer to the Deploying a Randomness Consuming Smart Contract on EVM chains with DIA xRandom Oracle video tutorial.</p>"},{"location":"builders/integrations/oracles/dia/#resources","title":"Resources","text":"<ul> <li>Twitter</li> <li>Discord</li> <li>Website</li> <li>Docs</li> <li>Explore data</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/oracles/razor-network/","title":"Razor Network Oracle","text":""},{"location":"builders/integrations/oracles/razor-network/#introduction","title":"Introduction","text":"<p>Developers can now fetch prices from Razor Network\u2019s oracle using a Bridge contract deployed on the Moonbase Alpha TestNet. This Bridge acts as middleware, and events emitted by it are fetched by the Razor Network's oracle infrastructure, sending prices to the Bridge contract.</p> <p>To access these price feeds, you need to interact with the Bridge contract address, which can be found in the following table:</p> Network Contract Address Moonbase Alpha 0x53f7660Ea48289B5DA42f1d79Eb9d4F5eB83D3BE    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/oracles/razor-network/#jobs","title":"Jobs","text":"<p>Each data-feed has a Job ID attached to it. For example:</p> Job ID Underlying Price [USD] 1 ETH 2 BTC 3 Microsoft Stocks <p>You can check Job IDs for each data-feed on the Razor Network Explorer. Price feeds are updated every 5 minutes. More information can be found in Razor's documentation website.</p>"},{"location":"builders/integrations/oracles/razor-network/#get-data-from-bridge-contract","title":"Get Data From Bridge Contract","text":"<p>Contracts can query on-chain data such as token prices, from Razor Network's oracle by implementing the interface of the Bridge contract, which exposes the <code>getResult</code> and <code>getJob</code> functions.</p> <pre><code>pragma solidity 0.6.11;\n\ninterface Razor {\n\n    function getResult(uint256 id) external view returns (uint256);\n\n    function getJob(uint256 id) external view returns(string memory url, string memory selector, string memory name, bool repeat, uint256 result);\n}\n</code></pre> <p>The first function, <code>getResult</code>, takes the Job ID associated with the data-feed and fetches the price. For example, if you pass in <code>1</code>, you will receive the price of the data-feed related to the Job ID.</p> <p>The second function, <code>getJob</code>, takes the Job ID associated with the data-feed and fetches the general information regarding the data-feed, such as the name of the data-feed, the price, and the URL being used to fetch the prices.</p>"},{"location":"builders/integrations/oracles/razor-network/#example-contract","title":"Example Contract","text":"<p>There is a predeployed bridge contract in the Moonbase Alpha TestNet (at address <code>0xC6F33c0F15FE5e3A51A019524ac43574cFF29EFB</code>) so you can quickly check the information fed from Razor Network's oracle.</p> <p>The only requirement is the Bridge interface, which defines <code>getResult</code> structure and makes the functions available to the contract for queries.</p> <p>You can use the following <code>Demo</code> contract. It provides various functions:</p> <ul> <li>fetchPrice - a view function that queries a single Job ID. For example, to fetch the price of <code>ETH</code> in <code>USD</code>, you will need to send the Job ID <code>1</code></li> <li>fetchMultiPrices - a view function that queries multiple Job IDs. For example, to fetch the price of <code>ETH</code> and <code>BTC</code> in <code>USD</code>, you will need to send the Job IDs <code>[1,2]</code></li> <li>savePrice - a public function that queries a single Job ID. This sends a transaction and modifies the <code>price</code> variable stored in the contract.</li> <li>saveMultiPrices - a public function that queries multiple Job IDs. For example, to fetch the price of <code>ETH</code> and <code>BTC</code> in <code>USD</code>, you will need to send the Job IDs <code>[1,2]</code>. This sends a transaction and modifies the <code>pricesArr</code> array stored in the contract, which will hold the price of each pair in the same order as specified in the input</li> </ul> <pre><code>pragma solidity 0.6.11;\n\ninterface Razor {\n    function getResult(uint256 id) external view returns (uint256);\n    function getJob(uint256 id) external view returns(string memory url, string memory selector, string memory name, bool repeat, uint256 result);\n}\n\ncontract Demo {\n    // Interface\n    Razor internal razor;\n\n    // Variables\n    uint256 public price;\n    uint256[] public pricesArr;\n\n    constructor(address _bridgeAddress) public {\n        razor = Razor(_bridgeAddress); // Bridge Contract Address\n                                       // Moonbase Alpha 0xC6F33c0F15FE5e3A51A019524ac43574cFF29EFB\n    }\n\n    function fetchPrice(uint256 _jobID) public view returns (uint256){\n        return razor.getResult(_jobID);\n    }\n\n    function fetchMultiPrices(uint256[] memory jobs) external view returns(uint256[] memory){\n        uint256[] memory prices = new uint256[](jobs.length);\n        for(uint256 i=0;i&lt;jobs.length;i++){\n            prices[i] = razor.getResult(jobs[i]);\n        }\n        return prices;\n    }\n\n    function savePrice(uint _jobID) public {\n        price = razor.getResult(_jobID);\n    }\n\n    function saveMultiPrices(uint[] calldata _jobIDs) public {\n        delete pricesArr;\n\n        for (uint256 i = 0; i &lt; _jobIDs.length; i++) {\n            pricesArr.push(razor.getResult(_jobIDs[i]));\n        }\n\n    }\n}\n</code></pre>"},{"location":"builders/integrations/oracles/razor-network/#try-it-on-moonbase-alpha","title":"Try it on Moonbase Alpha","text":"<p>The easiest way to try their Oracle implementation is by pointing the interface to the Bridge contract deployed at address <code>0xC6F33c0F15FE5e3A51A019524ac43574cFF29EFB</code>:</p> <pre><code>pragma solidity 0.6.11;\n\ninterface Razor {\n    function getResult(uint256 id) external view returns (uint256);\n    function getJob(uint256 id) external view returns(string memory url, string memory selector, string memory name, bool repeat, uint256 result);\n}\n</code></pre> <p>With it, you will have two view functions available, very similar to the previous examples:</p> <ul> <li>getPrice - provides the price feed for a single job ID given as input to the function. For example, to fetch the price of <code>ETH</code> in <code>USD</code>, you will need to send the Job ID <code>1</code></li> <li>getMultiPrices - provides the price feed for multiple Job IDs given as an array input to the function. For example, to fetch the price of <code>ETH</code> and <code>BTC</code> in <code>USD</code>, you will need to send the job IDs <code>[1,2]</code></li> </ul> <p>You can use Remix to fetch the <code>BTC</code> price in <code>USD</code>.</p> <p>After creating the file and compiling the contract, head to the Deploy and Run Transactions tab, enter the contract address (<code>0xC6F33c0F15FE5e3A51A019524ac43574cFF29EFB</code>), and click on At Address. Make sure you have set the ENVIRONMENT to Injected Web3 so that you are connected to Moonbase Alpha (through the Web3 provider of the wallet).</p> <p></p> <p>This will create an instance of the demo contract that you can interact with. Use the functions <code>getPrice()</code> and <code>getMultiPrices()</code> to query the data of the corresponding pair.</p> <p></p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/oracles/supra/","title":"Supra Oracles","text":""},{"location":"builders/integrations/oracles/supra/#introduction","title":"Introduction","text":"<p>Supra is a novel, high-throughput oracle and intralayer: a vertically integrated toolkit of cross-chain solutions (data oracles, asset bridge, automation network, and more) that interlink all blockchains, public (L1s and L2s) or private (enterprises), including Moonbeam.</p> <p>Supra provides decentralized oracle price feeds that can be used for on-chain and off-chain use cases such as spot and perpetual DEXes, lending protocols, and payment protocols.</p> <p>This page provides everything you need to know to get started with Supra on Moonbeam.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/oracles/supra/#price-feeds","title":"How to use Supra's Price Feeds","text":"<p>Supra uses a pull model as a customized approach that publishes price data upon request. It combines Web2 and Web3 methods to achieve low latency when sending data from Supra to destination chains. The process involves the following steps:</p> <ol> <li>Web2 methods are used to retrieve price data from Supra</li> <li>Smart contracts are utilized for cryptographically verifying and writing the latest price data on-chain, where it lives on immutable ledgers, using Supra's Pull Oracle V1</li> <li>Once the data has been written on-chain, the most recently published price feed data will be available in Supra's Storage contract</li> </ol> <p>The addresses for Supra's contracts on Moonbeam are as follows:</p> MoonbeamMoonbase Alpha Contract Address Pull Oracle 0x2FA6DbFe4291136Cf272E1A3294362b6651e8517 Storage 0xD02cc7a670047b6b012556A88e275c685d25e0c9 Contract Address Pull Oracle 0xaa2f56843Cec7840F0C106F0202313d8d8CB13d6 Storage 0x4591d1B110ad451d8220d82252F829E8b2a91B17 <p>Note</p> <p>Moonriver is not supported at this time.</p>"},{"location":"builders/integrations/oracles/supra/#list-of-available-price-feeds","title":"List of Available Price Feeds","text":"<p>To view a complete list of the available data pairs provided by Supra, please check out their data feeds catalog on their documentation site.</p> <p>To interact with any of these data pairs, you'll need to take note of the pair's Pair ID.</p>"},{"location":"builders/integrations/oracles/supra/#try-it-out","title":"Try It Out","text":"<p>Try out a basic example of how to fetch price data using Supra's pull model with step-by-step instructions in the Fetching Price Data with Supra Oracles tutorial. You'll learn how to tackle each of the three steps mentioned in the previous section.</p>"},{"location":"builders/integrations/oracles/supra/#connect-with-supra","title":"Connect with Supra","text":"<p>Still looking for answers? Supra's got them! Check out all the ways you can reach the Supra team:</p> <ul> <li>Visit Supra's websites at supraoracles.com</li> <li>Read their docs</li> <li>Chat with them on Telegram</li> <li>Follow them on Twitter</li> <li>Join their Discord</li> <li>Check out their Youtube</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/wallets/metamask/","title":"Integrate MetaMask into a DApp","text":""},{"location":"builders/integrations/wallets/metamask/#introduction","title":"Introduction","text":"<p>With the release of MetaMask's Custom Networks API, users can be prompted to add Moonbeam's Testnet, Moonbase Alpha.</p> <p>This section will take you through the process of adding a \"Connect to Moonbase Alpha\" button that will prompt users to connect their MetaMask account(s) to Moonbase Alpha. Your users will no longer need to know or worry about Moonbase Alpha's network configurations and adding a custom network to MetaMask. To interact with Moonbeam from your dApp, all users will need to do is click a few buttons to connect to Moonbase Alpha and get started.</p> <p>MetaMask injects a global Ethereum API into websites users visit at <code>window.ethereum</code>, which allows the websites to read and request the users' blockchain data. You'll be using the Ethereum provider to walk your users through the process of adding Moonbase Alpha as a custom network. In general, you will have to:</p> <ul> <li>Check if the Ethereum provider exists and if it's MetaMask</li> <li>Request the user's account address</li> <li>Add Moonbase Alpha as a new chain</li> </ul> <p>This guide is divided into two sections. First, it'll cover adding a button that will be used to trigger MetaMask to pop up and connect to Moonbase Alpha. The second part of the guide will create the logic for connecting the user to MetaMask. This way when you click the button you can actually test the functionality as you go through the guide.</p>"},{"location":"builders/integrations/wallets/metamask/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To add the Connect MetaMask button you'll need a JavaScript project and the MetaMask browser extension installed for local testing.</p> <p>It's recommended to use MetaMask's <code>detect-provider</code> utility package to detect the provider injected at <code>window.ethereum</code>. The package handles detecting the provider for the MetaMask extension and MetaMask Mobile. To install the package in your JavaScript project, run:</p> <pre><code>npm install @metamask/detect-provider\n</code></pre>"},{"location":"builders/integrations/wallets/metamask/#add-a-button","title":"Add a Button","text":"<p>You'll start off by adding a button that will be used to connect MetaMask to Moonbase Alpha. You want to start with the button so when you create the logic in the next step you can test the code as you make your way through the guide.</p> <p>The function you will create in the next section of the guide will be called <code>configureMoonbaseAlpha</code>. So the button on click should call <code>configureMoonbaseAlpha</code>.</p> <pre><code>&lt;button onClick={configureMoonbaseAlpha()}&gt;Connect to Moonbase Alpha&lt;/button&gt;\n</code></pre>"},{"location":"builders/integrations/wallets/metamask/#add-logic","title":"Add Logic","text":"<p>Now that you have created the button, you need to add the <code>configureMoonbaseAlpha</code> function that will be used on click.</p> <ol> <li> <p>Detect the provider at <code>window.ethereum</code> and check if it's MetaMask. If you want a simple solution you can directly access <code>window.ethereum</code>. Or you can use MetaMask's <code>detect-provider</code> package and it will detect the provider for MetaMask extension and MetaMask Mobile for you</p> <pre><code>import detectEthereumProvider from '@metamask/detect-provider';\nconst configureMoonbaseAlpha = async () =&gt; {\n  const provider = await detectEthereumProvider({ mustBeMetaMask: true });\n  if (provider) {\n    // Logic will go here\n  } else {\n    console.error('Please install MetaMask');\n  }\n};\n</code></pre> </li> <li> <p>Request the user's accounts by calling the <code>eth_requestAccounts</code> method. This will prompt MetaMask to pop up and ask the user to select which accounts they would like to connect to. Behind the scenes, permissions are being checked by calling <code>wallet_requestPermissions</code>. Currently the only permissions are for <code>eth_accounts</code>. So you're ultimately verifying that you have access to the user's addresses returned from <code>eth_accounts</code>. If you're interested in learning more about the permissions system, check out EIP-2255</p> <pre><code>import detectEthereumProvider from '@metamask/detect-provider';\nconst configureMoonbaseAlpha = async () =&gt; {\n  const provider = await detectEthereumProvider({ mustBeMetaMask: true });\n  if (provider) {\n    try {\n      await provider.request({ method: 'eth_requestAccounts' });\n    } catch (e) {\n      console.error(e);\n    }\n  } else {\n    console.error('Please install MetaMask');\n  }\n};\n</code></pre> <p></p> </li> <li> <p>Add Moonbase Alpha as a new chain by calling <code>wallet_addEthereumChain</code>. This will prompt the user to provide permission to add Moonbase Alpha as a custom network. Once the network has been successfully added, it will also prompt the user to then switch to Moonbase Alpha</p> <pre><code>import detectEthereumProvider from '@metamask/detect-provider';\nconst configureMoonbaseAlpha = async () =&gt; {\n  const provider = await detectEthereumProvider({ mustBeMetaMask: true });\n  if (provider) {\n    try {\n      await provider.request({ method: 'eth_requestAccounts' });\n      await provider.request({\n        method: 'wallet_addEthereumChain',\n        params: [\n          {\n             // Moonbase Alpha's chainId is 1287, which is 0x507 in hex\n            chainId: '0x507',\n            chainName: 'Moonbase Alpha',\n            nativeCurrency: {\n              name: 'DEV',\n              symbol: 'DEV',\n              decimals: 18,\n            },\n            rpcUrls: ['https://rpc.api.moonbase.moonbeam.network'],\n            blockExplorerUrls: ['https://moonbase.moonscan.io/'],\n          },\n        ],\n      });\n    } catch (e) {\n      console.error(e);\n    }\n  } else {\n    console.error('Please install MetaMask');\n  }\n};\n</code></pre> <p></p> </li> </ol> <p>So, now you should have a button that, on click, walks users through the entire process of connecting their MetaMask accounts to Moonbase Alpha.</p>"},{"location":"builders/integrations/wallets/metamask/#confirm-connection","title":"Confirm Connection","text":"<p>It's possible that you'll have logic that relies on knowing whether a user is connected to Moonbase Alpha or not. Perhaps you want to disable the button if the user is already connected. To confirm a user is connected to Moonbase Alpha, you can call <code>eth_chainId</code>, which will return the users current chain ID:</p> <pre><code>const chainId = await provider.request({\n  method: 'eth_chainId',\n});\n// Moonbase Alpha's chainId is 1287, which is 0x507 in hex\nif (chainId === '0x507') {\n  // At this point, you might want to disable the \"Connect\" button\n  // or inform the user that they are already connected to the\n  // Moonbase Alpha testnet\n}\n</code></pre>"},{"location":"builders/integrations/wallets/metamask/#listen-to-account-changes","title":"Listen to Account Changes","text":"<p>To ensure that your project or dApp is staying up to date with the latest account information, you can add the <code>accountsChanged</code> event listener that MetaMask provides. MetaMask emits this event when the return value of <code>eth_accounts</code> changes. If an address is returned, it is your user's most recent account that provided access permissions. If no address is returned, that means the user has not provided any accounts with access permissions.</p> <pre><code>provider.on('accountsChanged', (accounts) =&gt; {\n  if (accounts.length === 0) {\n    // MetaMask is locked or the user doesn't have any connected accounts\n    console.log('Please connect to MetaMask.');\n  }\n});\n</code></pre>"},{"location":"builders/integrations/wallets/metamask/#listen-to-chain-changes","title":"Listen to Chain Changes","text":"<p>To keep your project or dApp up to date with any changes to the connected chain, you'll want to subscribe to the <code>chainChanged</code> event. MetaMask emits this event every time the connected chain changes.</p> <pre><code>provider.on('chainChanged', () =&gt; {\n  // MetaMask recommends reloading the page unless you have good reason not to\n  window.location.reload();\n});\n</code></pre> <p>MetaMask recommends reloading the page whenever the chain changes, unless there is a good reason not to, as it's important to always be in sync with chain changes.</p>"},{"location":"builders/integrations/wallets/particle-network/","title":"Particle Network Wallet Abstraction","text":""},{"location":"builders/integrations/wallets/particle-network/#introduction","title":"Introduction","text":"<p>Particle Network offers Wallet Abstraction services with an Account Abstraction stack, providing a suite of SDKs focused on reducing user onboarding friction. </p> <p>By embedding customizable Externally Owned Account (EOA) and Account Abstraction (AA) components, Particle allows quick 2-click onboarding via social logins like Google, email, and phone, as well as traditional Web3 methods. This approach removes the need for users to manage a conventional wallet, delivering a streamlined, application-specific experience for Web3 interactions.</p> <p>Particle Network supports Moonbeam, Moonriver, and the Moonbase Alpha TestNet with both standard EOA interactions and native ERC-4337 <code>SimpleAccount</code> implementations, providing full-stack account abstraction.</p> <p>Key components of Particle Network's Moonbeam integration include:</p> <ul> <li>Particle Connect: Particle's flagship Wallet-as-a-Service solution, offering embedded wallets powered by MPC-TSS for smooth, Web2-like onboarding and interactions, with Account Abstraction support integrated within a single SDK</li> <li>Particle Network Modular AA Stack: Beyond the default EOA-based interactions, Particle also offers a modular AA stack for ERC-4337 account abstraction on Moonbeam, allowing flexibility in the smart account, bundler, and paymaster configurations to suit AA-enabled applications</li> </ul> <p></p> <p>In this guide, you'll go through a step-by-step example of using Particle Connect on Moonbeam.</p>"},{"location":"builders/integrations/wallets/particle-network/#create-an-application","title":"Create an Application","text":"<p>To use Particle Connect on Moonbeam, you'll need to create an account on the Particle Network dashboard and spin up an application</p> <ol> <li> <p>Navigate to the Particle Network dashboard, then sign up or log in</p> <p></p> </li> <li> <p>Once logged in, click Add New Project to create a new project</p> <p></p> </li> <li> <p>Enter the project name and click Save</p> <p></p> </li> <li> <p>From the project's dashboard, scroll down to the Your Apps section and create a new app by selecting iOS, Android, or Web and providing the requested information</p> <p></p> </li> <li> <p>Finally, copy the Project ID, Client Key, and App ID</p> <p></p> </li> </ol>"},{"location":"builders/integrations/wallets/particle-network/#install-dependencies","title":"Install Dependencies","text":"<p>To integrate Particle Connect into your Moonbeam application, you'll need only a few dependencies. Particle Connect offers built-in Account Abstraction (AA) support; however, in this example, we'll install the Particle AA SDK to utilize EIP-1193 providers, such as ethers.</p> <pre><code>yarn add @particle-network/connectkit viem@^2 @particle-network/aa ethers\n</code></pre> <p>Note that this tutorial is based on a Next.js app with TypeScript and Tailwind CSS.</p>"},{"location":"builders/integrations/wallets/particle-network/#configure-particle-network","title":"Configure Particle Connect","text":"<p>We\u2019ll configure and initialize Particle Connect (Particle's flagship authentication SDK). Begin by creating a new file called <code>ConnectKit.tsx</code> in your project\u2019s root directory, where we\u2019ll set up the <code>ParticleConnectKit</code> component as the primary interface for configuration.</p> <p>Before proceeding, head back to the Particle dashboard and retrieve the following API keys:</p> <ul> <li><code>projectId</code> \u2013 your project\u2019s unique ID</li> <li><code>clientKey</code> \u2013 your client-specific key</li> <li><code>appId</code> \u2013 your application ID</li> </ul> <p>These keys are essential as they connect your Particle Connect instance with the Particle dashboard, enabling features like no-code customization, user activity tracking, and API request authentication.</p> <p>Place the API keys in a <code>.env</code> file in the following format:</p> <pre><code>NEXT_PUBLIC_PROJECT_ID='INSERT_PROJECT_ID'\nNEXT_PUBLIC_CLIENT_KEY='INSERT_CLIENT_KEY'\nNEXT_PUBLIC_APP_ID='INSERT_APP_ID'\n</code></pre> <p>This setup ensures that your API keys are securely accessible to the Next.js application while protecting them from unauthorized access.</p> <p>Here\u2019s the code to add to your <code>ConnectKit.tsx</code> file:</p> <pre><code>\"use client\";\n\nimport React from \"react\";\nimport { ConnectKitProvider, createConfig } from \"@particle-network/connectkit\";\nimport { authWalletConnectors } from \"@particle-network/connectkit/auth\";\nimport { moonbeam } from \"@particle-network/connectkit/chains\";\nimport { wallet, EntryPosition } from \"@particle-network/connectkit/wallet\";\nimport { aa } from \"@particle-network/connectkit/aa\";\n\nconst config = createConfig({\n  projectId: process.env.NEXT_PUBLIC_PROJECT_ID!,\n  clientKey: process.env.NEXT_PUBLIC_CLIENT_KEY!,\n  appId: process.env.NEXT_PUBLIC_APP_ID!,\n\n  walletConnectors: [authWalletConnectors({})],\n\n  plugins: [\n    wallet({\n      entryPosition: EntryPosition.BR, // Positions the modal button at the bottom right on login\n      visible: true, // Determines if the wallet modal is displayed\n    }),\n    aa({\n      name: \"SIMPLE\",\n      version: \"2.0.0\",\n    }),\n  ],\n  chains: [moonbeam],\n});\n\nexport const ParticleConnectkit = ({ children }: React.PropsWithChildren) =&gt; {\n  return &lt;ConnectKitProvider config={config}&gt;{children}&lt;/ConnectKitProvider&gt;;\n};\n</code></pre> <p>This setup initializes <code>ParticleConnectKit</code>, a wrapper for the configured <code>ConnectKitProvider</code> instance, using your project keys. It also defines essential SDK settings, such as supported chains (e.g., Moonbeam), wallet positioning and visibility options, and a <code>SIMPLE</code> smart account instance.</p> <p>For further customization options, refer to the Particle Connect documentation.</p> <p>At this point, you've signed up and created an application, installed all required dependencies, and configured <code>ParticleConnectKit</code> and <code>SmartAccount,</code> if applicable.</p>"},{"location":"builders/integrations/wallets/particle-network/#integrate-particleconnectkit","title":"Integrate the <code>ParticleConnectKit</code> Component in Your App","text":"<p>After completing the configuration, wrap your application with the <code>ParticleConnectKit</code> component to enable global access to the Particle Connect SDK. Update your <code>layout.tsx</code> file in <code>src</code> as shown below:</p> <pre><code>import { ParticleConnectkit } from \"@/ConnectKit\";\nimport type { Metadata } from \"next\";\nimport { Inter } from \"next/font/google\";\nimport \"./globals.css\";\n\nconst inter = Inter({ subsets: [\"latin\"] });\n\nexport const metadata: Metadata = {\n  title: \"Particle Connectkit App\",\n  description: \"Generated by create next app\",\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    &lt;html lang=\"en\"&gt;\n      &lt;body className={inter.className}&gt;\n        &lt;ParticleConnectkit&gt;{children}&lt;/ParticleConnectkit&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n</code></pre> <p>Wrapping your application in <code>ParticleConnectKit</code> provides global access to the SDK, making features like social logins and wallet generation available throughout your app. This setup in <code>layout.tsx</code> ensures all components can access Particle Connect\u2019s capabilities.</p>"},{"location":"builders/integrations/wallets/particle-network/#connecting-wallet","title":"Connecting Wallet","text":"<p>With the configured <code>layout.tsx</code> file, the next step is to add a central Connect Wallet button for user connectivity. You can achieve this by importing <code>ConnectButton</code> from <code>@particle-network/connectkit</code>. Once the user logs in, the <code>ConnectButton</code> transforms into an embedded widget.</p> <pre><code>\"use client\";\nimport { ConnectButton, useAccount } from \"@particle-network/connectkit\";\n\nconst HomePage = () =&gt; {\n  const { address, isConnected, chainId } = useAccount();\n\n  return (\n    &lt;div className=\"flex justify-center items-center h-screen\"&gt;\n      &lt;div className=\"text-center\"&gt;\n        &lt;ConnectButton /&gt;\n        {isConnected &amp;&amp; (\n          &lt;&gt;\n            &lt;h2&gt;Address: {address}&lt;/h2&gt;\n            &lt;h2&gt;Chain ID: {chainId}&lt;/h2&gt;\n          &lt;/&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default HomePage;\n</code></pre>"},{"location":"builders/integrations/wallets/particle-network/#sending-transactions-with-an-eip-1193-provider","title":"Sending transactions with an EIP-1193 provider","text":"<p>Using Particle Connect alongside the Particle AA SDK enables you to work with an EIP-1193 provider like ethers. This approach is beneficial because you're likely already familiar with these providers or if you integrate Particle Connect into an existing application.</p> <p>To set this up, wrap the smart account provided by Particle Connect with an instance of ethers to create a <code>customProvider.</code> You can use ethers as usual from there, with the smart account as the underlying transaction signer.</p> <pre><code>import {useSmartAccount } from \"@particle-network/connectkit\";\nimport { AAWrapProvider, SendTransactionMode } from \"@particle-network/aa\";\n\nconst smartAccount = useSmartAccount();\n\n// Init custom provider with gasless transaction mode\nconst customProvider = smartAccount\n? new ethers.BrowserProvider(\n    new AAWrapProvider(\n        smartAccount,\n        SendTransactionMode.Gasless\n    ) as Eip1193Provider,\n    \"any\"\n    )\n: null;\n\n/**\n * Sends a transaction using the ethers.js library.\n * This transaction is gasless since the customProvider is initialized as gasless\n*/\nconst executeTxEthers = async () =&gt; {\n    if (!customProvider) return;\n\n    const signer = await customProvider.getSigner();\n    const tx = {\n      to: recipientAddress,\n      value: parseEther(\"0.01\").toString(),\n    };\n\n    const txResponse = await signer.sendTransaction(tx);\n    const txReceipt = await txResponse.wait();\n    console.log(txReceipt?.hash)\n  };\n</code></pre>"},{"location":"builders/integrations/wallets/particle-network/#example-of-utilization","title":"Example of Utilization","text":"<p>With those above established, Particle Connect can be used similarly, as shown in the example application below.</p> <p>Specifically, this application creates a smart account on Moonbeam MainNet through social login, then uses it to send a gasless transaction of 0.001 GLMR with the ethers provider.</p> <pre><code>\"use client\";\nimport React, { useEffect, useState } from \"react\";\n\n// Particle imports\nimport {\n  ConnectButton,\n  useAccount,\n  usePublicClient,\n  useSmartAccount,\n} from \"@particle-network/connectkit\";\n\n// Eip1193 and AA Provider\nimport { AAWrapProvider, SendTransactionMode } from \"@particle-network/aa\"; // Only needed with Eip1193 provider\nimport { ethers, type Eip1193Provider } from \"ethers\";\nimport { formatEther, parseEther } from \"viem\";\n\nexport default function Home() {\n  const { isConnected, chain } = useAccount();\n  const publicClient = usePublicClient();\n  const smartAccount = useSmartAccount();\n\n  const [userAddress, setUserAddress] = useState&lt;string&gt;(\"\");\n  const [balance, setBalance] = useState&lt;string | null&gt;(null);\n  const [recipientAddress, setRecipientAddress] = useState&lt;string&gt;(\"\");\n  const [transactionHash, setTransactionHash] = useState&lt;string | null&gt;(null);\n\n  // Init custom provider with gasless transaction mode\n  const customProvider = smartAccount\n    ? new ethers.BrowserProvider(\n        new AAWrapProvider(\n          smartAccount,\n          SendTransactionMode.Gasless\n        ) as Eip1193Provider,\n        \"any\"\n      )\n    : null;\n\n  /**\n   * Fetches the balance of a given address.\n   * @param {string} address - The address to fetch the balance for.\n   */\n  const fetchBalance = async (address: string) =&gt; {\n    try {\n      const balanceResponse = await publicClient?.getBalance({\n        address: address as `0x${string}`,\n      });\n      if (balanceResponse) {\n        const balanceInEther = formatEther(balanceResponse).toString();\n        setBalance(balanceInEther);\n      } else {\n        setBalance(\"0.0\");\n      }\n    } catch (error) {\n      console.error(\"Error fetching balance:\", error);\n      setBalance(\"0.0\");\n    }\n  };\n\n  /**\n   * Loads the user's account data, including address and balance.\n   */\n  useEffect(() =&gt; {\n    const loadAccountData = async () =&gt; {\n      if (isConnected &amp;&amp; smartAccount) {\n        try {\n          const address = await smartAccount.getAddress();\n          setUserAddress(address);\n          await fetchBalance(address);\n        } catch (error) {\n          console.error(\"Error loading account data:\", error);\n        }\n      }\n    };\n    loadAccountData();\n  }, [isConnected, smartAccount]);\n\n  /**\n   * Sends a transaction using the ethers.js library.\n   * This transaction is gasless since the customProvider is initialized as gasless\n   */\n  const executeTxEthers = async () =&gt; {\n    if (!customProvider) return;\n\n    const signer = await customProvider.getSigner();\n    try {\n      const tx = {\n        to: recipientAddress,\n        value: parseEther(\"0.01\").toString(),\n      };\n\n      const txResponse = await signer.sendTransaction(tx);\n      const txReceipt = await txResponse.wait();\n\n      setTransactionHash(txReceipt?.hash || null);\n    } catch (error) {\n      console.error(\"Failed to send transaction using ethers.js:\", error);\n    }\n  };\n\n  return (\n    &lt;div className=\"container min-h-screen flex flex-col justify-center items-center mx-auto gap-4 px-4 md:px-8\"&gt;\n      &lt;div className=\"w-full flex justify-center mt-4\"&gt;\n        &lt;ConnectButton label=\"Click to login\" /&gt;\n      &lt;/div&gt;\n      {isConnected &amp;&amp; (\n        &lt;&gt;\n          &lt;div className=\"border border-purple-500 p-6 rounded-lg w-full\"&gt;\n            &lt;h2 className=\"text-lg font-semibold mb-2 text-white\"&gt;\n              Address: &lt;code&gt;{userAddress || \"Loading...\"}&lt;/code&gt;\n            &lt;/h2&gt;\n            &lt;h2 className=\"text-lg font-semibold mb-2 text-white\"&gt;\n              Balance: {balance || \"Loading...\"} {chain?.nativeCurrency.symbol}\n            &lt;/h2&gt;\n            &lt;input\n              type=\"text\"\n              placeholder=\"Recipient Address\"\n              value={recipientAddress}\n              onChange={(e) =&gt; setRecipientAddress(e.target.value)}\n              className=\"mt-4 p-3 w-full rounded border border-gray-700 bg-gray-900 text-white focus:outline-none\"\n            /&gt;\n            &lt;button\n              className=\"bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded mt-4\"\n              onClick={executeTxEthers}\n              disabled={!recipientAddress}\n            &gt;\n              Send 0.001 {chain?.nativeCurrency.name}\n            &lt;/button&gt;\n            {transactionHash &amp;&amp; (\n              &lt;p className=\"text-green-500 mt-4\"&gt;\n                Transaction Hash: {transactionHash}\n              &lt;/p&gt;\n            )}\n          &lt;/div&gt;\n        &lt;/&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>That concludes the brief introduction to Particle's Smart Wallet-as-a-Service stack and how to get started with Particle on Moonbeam. For more information, you can check out Particle Network's documentation.</p> <p>Find the repository with the complete code implementation on the Particle Network GitHub.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/wallets/rainbowkit/","title":"Integrate RainbowKit into a DApp","text":""},{"location":"builders/integrations/wallets/rainbowkit/#introduction","title":"Introduction","text":"<p>RainbowKit is a React library that adds wallet connection capabilities to a dApp. It supports numerous wallets and enables features such as switching connection chains, ENS address resolution, and balance display out-of-the-box. RainbowKit offers customization options for all EVM-compatible chains, making it possible to easily connect mobile wallets to your Moonbeam dApps.</p> <p>RainbowKit bundles together multiple tools to simplify adding wallet connection to your dApp: </p> <ul> <li>Wagmi - a React Hooks library for interacting with Ethereum accounts, wallets, contracts, transactions, signing, ENS, and more</li> <li>viem - TypeScript interface which provides low-level stateless primitives for interacting with Ethereum</li> <li>WalletConnect - adds encrypted connections and enhanced UX experiences like connecting a mobile wallet by scanning a QR code</li> <li>TanStack Query - helps manage and update server state within the application</li> </ul> <p>This guide takes you through adding RainbowKit to a dApp using the CLI, adding support for Moonbeam networks, and some options for further customizing your integration.</p>"},{"location":"builders/integrations/wallets/rainbowkit/#quick-start","title":"Quick Start","text":"<p>If you are starting a new project, RainbowKit can scaffold a project from the CLI, combining RainbowKit and Wagmi in a Next.js application. Use your package manager of choice to run the CLI command and start your project:</p> npmpnpmyarn <pre><code>npm init @rainbow-me/rainbowkit@latest \n</code></pre> <pre><code>pnpm create @rainbow-me/rainbowkit@latest\n</code></pre> <pre><code>yarn create @rainbow-me/rainbowkit\n</code></pre> <p>The script will prompt you for a project name, generate a new directory with the boilerplate starter code, and install all required dependencies. </p> npm init @rainbow-me/rainbowkit@latest   \ud83c\udf08 Welcome to RainbowKit!  rainbow-demo  \ud83d\ude80 Creating a new RainbowKit app in /Users/dawnkelly/Documents/papermoon_builds/RainbowKit/add-rainbow-kit/rainbow-demo  \ud83d\udce6 Installing dependencies with npm. This could take a while. \ud83d\udcda Initializing git repository  \ud83c\udf08 Done! Thanks for using RainbowKit \ud83d\ude4f  \ud83d\udc49 To get started, run cd rainbow-demo and then npm run dev <p>You can now navigate to the project directory, start the development server, and navigate to <code>http://localhost:3000</code> to view your project locally:</p> npmpnpmyarn <pre><code>cd INSERT_PROJECT_NAME\nnpm run dev \n</code></pre> <pre><code>cd INSERT_PROJECT_NAME\npnpm run dev\n</code></pre> <pre><code>cd INSERT_PROJECT_NAME\nyarn dev\n</code></pre> <p>Your starting screen should look like this:</p> <p></p> <p>Open the project in your code editor and take a look at the directory and file structure, making note of the <code>wagmi.ts</code> file. This file is where you can customize which chains to include in the list of networks users can connect to through your dApp. </p> <p>Moonbeam, Moonriver, and Moonbase Alpha are not on the list of default supported networks. You can customize your dApp's supported networks in the <code>wagmi.ts</code> file by updating the chain entrypoints imported from <code>wagmi/chains</code> and passed to the <code>chains</code> property when <code>config</code> is defined. Wagmi uses chain definitions established by viem, primarily the chain name. The <code>wagmi/chains</code> names for Moonbeam networks are as follows: </p> MoonbeamMoonriverMoonbase Alpha <pre><code>moonbeam\n</code></pre> <pre><code>moonriver\n</code></pre> <pre><code>moonbaseAlpha\n</code></pre> <p>To add support for Moonbeam networks, update <code>wagmi.ts</code> as follows. You will learn how to generate the <code>projectId</code> value in the next section. </p> src/wagmi.ts<pre><code>import '@rainbow-me/rainbowkit/styles.css';\nimport { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';\nimport { WagmiProvider } from 'wagmi';\nimport { moonbeam, moonriver, moonbaseAlpha } from 'wagmi/chains';\nimport { QueryClientProvider, QueryClient } from '@tanstack/react-query';\n\nexport const config = getDefaultConfig({\n  appName: 'My Moonbeam App',\n  projectId: 'process.env.NEXT_PUBLIC_PROJECT_ID',\n  chains: [moonbeam, moonriver, moonbaseAlpha],\n  ssr: true,\n});\n</code></pre>"},{"location":"builders/integrations/wallets/rainbowkit/#manual-setup","title":"Manual Setup","text":"<p>If you want to add RainbowKit to an existing React application, you can complete a manual setup. The following sections will guide you through using the manual setup to install and import needed dependencies, configure chain connections to support Moonbeam networks, and make RainbowKit functionality available to users of your dApp. You will also learn how to specify which chain the Connect Wallet button should connect to by default and how to customize the RainbowKit theme to fit your project.</p>"},{"location":"builders/integrations/wallets/rainbowkit/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The following guide assumes you have:</p> <ul> <li> <p>An existing dApp built with React and you want to use the manual setup to connect to a mobile wallet via RainbowKit</p> <ul> <li> <p>The RainbowKit examples repository includes templates for multiple React frameworks</p> </li> <li> <p>To follow this guide, visit Next.js and follow the Automatic Installation instructions, selecting Typescript and the App Router options during setup </p> </li> </ul> </li> <li> <p>A mobile wallet which supports Moonbeam out of the box or allows for adding custom networks</p> </li> <li> <p>A WalletConnect <code>projectId</code> - every dApp relying on WalletConnect is required to have an associated <code>projectId</code>. It is free to create an account, and you can instantly generate an ID</p> </li> </ul> <p>To obtain a WalletConnect <code>projectId</code>:</p> <ol> <li>Visit WalletConnect Cloud</li> <li>On the Projects page, select Create </li> <li>Add your project information (you can leave Homepage URL blank if you have not deployed your dApp)</li> <li>Select the AppKit SDK</li> <li>Select your coding environment or platform (select React for this guide)</li> <li>Locate your <code>projectId</code> in the left menu. You can also find it in the Get started code snippet of the WalletConnect Quickstart</li> </ol>"},{"location":"builders/integrations/wallets/rainbowkit/#getting-started","title":"Getting Started","text":"<p>Ensure you are in the root directory for your project, then install RainbowKit and its peer dependencies:</p> npmpnpmyarn <pre><code>npm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query\n</code></pre> <pre><code>pnpm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query\n</code></pre> <pre><code>yarn add @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query\n</code></pre> <p>Next, start the development server to create a local dApp instance:</p> npmpnpmyarn <pre><code>npm run dev\n</code></pre> <pre><code>pnpm run dev\n</code></pre> <pre><code>yarn dev\n</code></pre> <p>If you navigate to <code>http://localhost:3000</code>,  you should see the starter Next.js application in your browser.</p> <p>To test the RainbowKit connection, you will use the MetaMask mobile app. To follow this guide, you must have established a connection to the Moonbase Alpha TestNet on the MetaMask mobile app.</p> <p>You can connect your MetaMask mobile wallet to the Moonbase Alpha TestNet in a couple of ways. You can manually add the Moonbase Alpha TestNet configurations from the Networks section of the Settings menu. Or you can also open up the Browser from MetaMask mobile and navigate to the Moonbeam documentation site (docs.moonbeam.network), click on Connect MetaMask at the top of the page, and select Moonbase Alpha from the menu. Follow the prompts to automatically add Moonbase Alpha as a custom network.</p> <p>Next, safely add your <code>projectId</code> to your application: </p> <ol> <li> <p>Create a <code>.env.local</code> file in the root directory of your project</p> <pre><code>touch .env.local\n</code></pre> </li> <li> <p>Add your <code>projectId</code> to this file</p> .env.local<pre><code>NEXT_PUBLIC_PROJECT_ID='INSERT_PROJECT_ID'\n</code></pre> </li> <li> <p>Locate your <code>.gitignore</code> file in this same directory and ensure <code>.env*.local</code> is included in the list of files to ignore. This will prevent committing your <code>projectId</code> to GitHub</p> </li> </ol> <p>In the next section, you will use this stored <code>projectId</code> when setting up the <code>wagmi</code> config.</p>"},{"location":"builders/integrations/wallets/rainbowkit/#connect-dapp-to-metamask-mobile","title":"Connect DApp to MetaMask Mobile","text":"<p>In the next sections, you will complete the steps needed to use RainbowKit to connect your dApp to MetaMask's mobile wallet:</p> <ol> <li>Import RainbowKit, Wagmi, and TanStack Query</li> <li>Setup configuration for Wagmi</li> <li>Wrap your application with providers</li> <li>Add the connect button</li> </ol>"},{"location":"builders/integrations/wallets/rainbowkit/#import-rainbowkit-wagmi-and-tanstack-query","title":"Import RainbowKit, Wagmi, and TanStack Query","text":"<p>Ensure you are still in your project's root directory, then create a new file called <code>wagmi.ts</code>. This file will contain the imports and configuration needed to connect your dApp to mobile wallets and interact with blockchains. </p> <pre><code>touch wagmi.ts\n</code></pre> MoonbeamMoonriverMoonbase Alpha <pre><code>moonbeam\n</code></pre> <pre><code>moonriver\n</code></pre> <pre><code>moonbaseAlpha\n</code></pre> <p>Add the <code>wagmi/chains</code> import with <code>moonbeam</code>, <code>moonriver</code>, and <code>moonbaseAlpha</code> as the supported chains. </p> wagmi.ts<pre><code>import '@rainbow-me/rainbowkit/styles.css';\nimport { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';\nimport { WagmiProvider } from 'wagmi';\nimport { moonbeam, moonriver, moonbaseAlpha } from 'wagmi/chains';\nimport { QueryClientProvider, QueryClient } from '@tanstack/react-query';\n</code></pre> <p>Now, setup the <code>config</code> to include Moonbeam networks by ensuring the <code>chains</code> array matches the list of chains in the <code>import</code> statement. Finally, update the <code>projectId</code> value to use the one stored in your <code>.env.local</code> file.</p> wagmi.ts<pre><code>export const config = getDefaultConfig({\n  appName: 'My Moonbeam App',\n  projectId: 'process.env.NEXT_PUBLIC_PROJECT_ID',\n  chains: [moonbeam, moonriver, moonbaseAlpha],\n  ssr: true,\n});\n</code></pre>"},{"location":"builders/integrations/wallets/rainbowkit/#wrap-your-application-with-providers","title":"Wrap Your Application with Providers","text":"<p>With the configuration in place, the next step is to wrap your application with the <code>RainbowKitProvider</code>, <code>WagmiProvider</code>, and <code>QueryClientProvider</code> to make them available throughout your dApp. In your terminal, navigate to the <code>app</code> directory in your project and create a file named <code>providers.tsx</code>:</p> <pre><code>cd app &amp;&amp;\ntouch providers.tsx\n</code></pre> <p>Open <code>providers.tsx</code> and add the following code to define <code>Providers</code>:</p> providers.tsx<pre><code>'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WagmiProvider } from 'wagmi';\nimport { RainbowKitProvider } from '@rainbow-me/rainbowkit';\nimport { config } from '../wagmi';\n\nconst queryClient = new QueryClient();\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &lt;WagmiProvider config={config}&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;RainbowKitProvider&gt;{children}&lt;/RainbowKitProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/WagmiProvider&gt;\n  );\n}\n</code></pre> <p>Now locate the <code>layout.tsx</code> file inside the <code>app</code> directory and modify the code to import <code>Providers</code> and wrap the application:</p> layout.tsx<pre><code>import type { Metadata } from 'next';\nimport { Inter } from 'next/font/google';\nimport './globals.css';\nimport '@rainbow-me/rainbowkit/styles.css';\nimport { Providers } from './providers';\n\nconst inter = Inter({ subsets: ['latin'] });\n\nexport const metadata: Metadata = {\n  title: 'My Moonbeam dApp',\n  description: 'Generated by create next app',\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    &lt;html lang='en'&gt;\n      &lt;body&gt;\n        &lt;Providers&gt;{children}&lt;/Providers&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n</code></pre> <p>Wrapping the application in the providers makes the functionalities of RainbowKit, Wagmi, and TanStack Query available throughout your dApp. This setup gives you the flexibility to add a wallet connection button anywhere in your project. </p>"},{"location":"builders/integrations/wallets/rainbowkit/#add-the-connect-button","title":"Add the Connect Button","text":"<p>RainbowKit offers a <code>ConnectButton</code> component, which renders the Connect and Disconnect buttons and UI elements for switching chains. This example imports the <code>ConnectButton</code> into the existing <code>page.tsx</code> file for simplicity, but you may want to add it to an element like a Header or Navbar so it appears at the top of each page. Update the code in <code>page.tsx</code> as follows:</p> page.tsx<pre><code>import Image from 'next/image';\nimport styles from './page.module.css';\nimport { ConnectButton } from '@rainbow-me/rainbowkit';\n\nexport default function Home() {\n  return (\n    &lt;div className={styles.main}&gt;\n      &lt;ConnectButton /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>If you haven't already, start the development server and spin up a local version of your dApp. Your home page should now include a visible Connect Wallet button. Click the button to test the connection. You should now see the RainbowKit modal with options to get or connect a wallet. Select MetaMask and follow the prompts to connect your wallet.</p> <p>The current configuration defaults to connecting to Moonbeam and displaying the current network, native token balance, an ENS or fallback avatar, and the connected wallet address. Select the arrow next to Moonbeam to open the Switch Networks modal. Select Moonbase Alpha and sign the MetaMask transaction to authorize switching networks. You should now see Moonbase Alpha listed as the connected network with your DEV token balance, avatar, and account number displayed. </p>"},{"location":"builders/integrations/wallets/rainbowkit/#customize-rainbow-kit","title":"Customize Rainbow Kit","text":"<p>Not only does RainbowKit abstract away the complexities of managing wallet connections, but the library offers several options for customizing UI and functionality to meet the needs of your dApp. You can find a complete list of customization options in the RainbowKit documentation. This section covers customizing the Connect Wallet button to connect initially to Moonbase Alpha and render it in a custom color. </p>"},{"location":"builders/integrations/wallets/rainbowkit/#set-custom-initial-chain","title":"Set Custom Initial Chain","text":"<p>RainbowKit will connect by default to the first chain supplied to Wagmi in the config. If you compare the order of chains listed in <code>wagmi.ts</code> to those on the Switch Networks modal, you will see they are the same. If you wanted to always connect to the TestNet first, a simple fix would be to move <code>moonbaseAlpha</code> to the top of the chain list. However, assuming this default behavior will never change is not the most reliable option. </p> <p>Instead, you can use the <code>initialChain</code> prop that is part of the <code>RainbowKitProvider</code> element to define which chain the wallet should initially connect to when the user selects Connect Wallet. Open your <code>providers.tsx</code> file and update the code to configure the <code>initialChain</code> prop. You can pass either a chain ID or chain name from the Wagmi Chains list.</p>"},{"location":"builders/integrations/wallets/rainbowkit/#define-custom-theme-colors","title":"Define Custom Theme Colors","text":"<p>RainbowKit offers three built-in theme functions: <code>lightTheme</code>, <code>darkTheme</code>, and <code>midnightTheme</code>. These theme functions return a theme object, which you can pass into the <code>RainbowKitProvider</code> prop <code>theme</code> to set custom colors, border radius, font stack, and overlay blur. Update <code>providers.tsx</code> with the following code. Be sure to add <code>darkTheme</code> to the <code>@rainbow-me/rainbowkit</code>import statement to allow your changes to render correctly. After customizing the initial chain and theme, your <code>providers.tsx</code> file should look like the following:</p> providers.tsx<pre><code>'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WagmiProvider } from 'wagmi';\nimport { RainbowKitProvider, darkTheme } from '@rainbow-me/rainbowkit';\nimport { config } from '../wagmi';\nimport { moonbaseAlpha } from 'viem/chains';\n\nconst queryClient = new QueryClient();\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &lt;WagmiProvider config={config}&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;RainbowKitProvider\n          initialChain={moonbaseAlpha}\n          theme={darkTheme({\n            accentColor: '#958fdc',\n            accentColorForeground: 'white',\n          })}\n        &gt;\n          {children}\n        &lt;/RainbowKitProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/WagmiProvider&gt;\n  );\n}\n</code></pre>"},{"location":"builders/integrations/wallets/rainbowkit/#handle-disconnections","title":"Handle Disconnections","text":"<p>You can now disconnect MetaMask from your dApp and then reconnect to test your customizations. There are two options for completing this step.  </p>"},{"location":"builders/integrations/wallets/rainbowkit/#disconnect-from-dapp","title":"Disconnect from DApp","text":"<p>RainbowKit includes a Disconnect button out of the box. To open the modal, select the arrow next to your account number. Click the Disconnect button. You should now see Connect Wallet; your account information should no longer be visible. </p> <p></p>"},{"location":"builders/integrations/wallets/rainbowkit/#disconnect-from-metamask-mobile","title":"Disconnect from MetaMask Mobile","text":"<p>Some users prefer to disconnect from their mobile wallet rather than use a button within a dApp. To use this method: </p> <ol> <li>Select the MetaMask extension in your browser to open the modal</li> <li>Select the three dots in the upper right corner of the MetaMask modal</li> <li>Select Connected sites</li> <li>Review the list of sites connected to your wallet</li> <li>Select Disconnect for each site you want to disconnect</li> </ol>"},{"location":"builders/integrations/wallets/rainbowkit/#final-result","title":"Final Result","text":"<p>The Connect Wallet button on your home page should now render in the color you entered for <code>accentColor</code> when customizing the theme. When you click Connect Wallet, you will see the same accent color in use. Select MetaMask and sign the transaction to authorize the connection. You should now see Moonbase Alpha as the connected network and your DEV token balance for the account balance without manually switching networks. </p> <p></p> <p>This guide includes only a few of the customization options available through RainbowKit. You can learn more about the capabilities and options of this library by visiting RainbowKit Docs.</p> <p>You can view the complete example code in the rainbow-manual-build-demo repository</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/wallets/walletconnect/","title":"Integrate WalletConnect into a DApp","text":""},{"location":"builders/integrations/wallets/walletconnect/#introduction","title":"Introduction","text":"<p>WalletConnect is an open protocol to communicate securely between wallets and DApps.</p> <p>WalletConnect establishes a remote connection between a DApp and mobile wallet by using a bridge server to relay payloads. The connection is initiated via a QR code displayed in a DApp, which will need to be scanned and approved by a mobile wallet. When a connection is established, the payloads between the DApp and wallet are encrypted through a shared key.</p> <p></p> <p>WalletConnect can also be used to establish a connection between a DApp and a desktop wallet. However, this guide will only cover a mobile wallet connection.</p> <p>In this guide, you'll learn how to integrate WalletConnect into a simple DApp built on the Moonbase Alpha TestNet. The guide will be divided into a few different sections. The first section will cover connecting your DApp to MetaMask mobile. After the connection has been established, the guide will cover disconnections. This way, when you are testing your DApp you will be able to connect and then disconnect so you don't end up with a bunch of unnecessary WalletConnect sessions lingering in MetaMask mobile. Afterwards you will learn how to display network and account details when connected, and send transactions from your DApp to MetaMask mobile for confirmation.</p> <p>This guide is an adaptation of the WalletConnect Example Dapp (source code). To view the end result, you can check out the Moonbeam WalletConnect Demo app (source code).</p>"},{"location":"builders/integrations/wallets/walletconnect/#quick-start","title":"Quick Start","text":"<p>If you already have a DApp with WalletConnect support, and just want to add Moonbeam support, you can use the following network configurations:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  name: \"Moonbeam\",\n  short_name: \"moonbeam\",\n  chain: \"Moonbeam\",\n  network: \"mainnet\",\n  chain_id: 1284,\n  network_id: 1284,\n  rpc_url: \"https://rpc.api.moonbeam.network\",\n  native_currency: {\n    symbol: \"GLMR\",\n    name: \"Glimmer\",\n    decimals: \"18\",\n    contractAddress: \"\",\n    balance: \"\",\n  },\n},\n</code></pre> <pre><code>{\n  name: \"Moonriver\",\n  short_name: \"moonriver\",\n  chain: \"Moonriver\",\n  network: \"mainnet\",\n  chain_id: 1285,\n  network_id: 1285,\n  rpc_url: \"https://rpc.api.moonriver.moonbeam.network\",\n  native_currency: {\n    symbol: \"MOVR\",\n    name: \"Moonriver\",\n    decimals: \"18\",\n    contractAddress: \"\",\n    balance: \"\",\n  },\n},\n</code></pre> <pre><code>{\n  name: \"Moonbase Alpha\",\n  short_name: \"moonbase\",\n  chain: \"Moonbase\",\n  network: \"testnet\",\n  chain_id: 1287,\n  network_id: 1287,\n  rpc_url: \"https://rpc.api.moonbase.moonbeam.network\",\n  native_currency: {\n    symbol: \"DEV\",\n    name: \"DEV\",\n    decimals: \"18\",\n    contractAddress: \"\",\n    balance: \"\",\n  },\n},\n</code></pre>"},{"location":"builders/integrations/wallets/walletconnect/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Throughout this guide, you'll use a simple front-end dApp built with React to connect to a mobile wallet via WalletConnect. So, you will need a React project and the MetaMask mobile app installed for testing purposes. A template has been created that includes the required packages, some basic styling, and placeholders where logic and UI elements must be added. However, if you would like to use your own dApp, you'll need to install the following required dependencies:</p> <pre><code>npm install ethers @walletconnect/client @walletconnect/qrcode-modal\n</code></pre> <p>This guide will use MetaMask mobile for testing purposes. To install MetaMask mobile, you can go to metamask.io/download/ and switch to either the iOS or Android tab.</p> <p>Lastly, you will need to have an account funded with DEV tokens, so that you can test out sending a transaction.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet.</p>"},{"location":"builders/integrations/wallets/walletconnect/#getting-started","title":"Getting Started","text":"<p>To get started quickly with the Moonbeam WalletConnect template, which provides everything you need to dive right in, you'll need to take the following steps:</p> <ol> <li>Clone the walletconnect-template GitHub repository</li> <li>Run <code>npm install</code> to install the required dependencies</li> <li>Run <code>npm start</code> to spin up a local instance of the DApp</li> </ol> <p>To test the WalletConnect connection, you can use the MetaMask mobile app. For the purposes of this guide, you will need to already be connected to the Moonbase Alpha TestNet on the MetaMask mobile app. Later on in the guide, you will learn how to check if the connected network is a supported network, and if not display an error that will suggest users to switch to a network that is supported.</p> <p>There are a couple of ways you can connect your MetaMask mobile wallet to the Moonbase Alpha TestNet. You can manually add the Moonbase Alpha TestNet configurations from the Networks section of the Settings menu. Or you can also open up the Browser from MetaMask mobile and navigate to docs.moonbeam.network, click on Connect MetaMask at the top of the page, and select Moonbase Alpha from the menu. This will prompt you to automatically add Moonbase Alpha as a custom network and saves you from inputting the network configurations manually.</p>"},{"location":"builders/integrations/wallets/walletconnect/#connect-dapp-to-metamask-mobile","title":"Connect DApp to MetaMask Mobile","text":"<p>In this section, you will learn how to make a connection between your DApp and MetaMask mobile. WalletConnect establishes a remote connection between a DApp and mobile wallet by using a bridge server to relay payloads. The connection is initiated via a QR code displayed in the DApp, which will need to be scanned and approved by the mobile wallet.</p> <p>To get started, you can open up the <code>App.js</code> file of the template and the first changes will be made within the <code>connect</code> function. This function will handle the connection logic by creating a new instance of the WalletConnect connector. You'll notice that the <code>setFetching</code> state hook is already in place. This will be used to set the <code>fetching</code> state variable to <code>true</code> while the connection is being established. In general the <code>connect</code> function will:</p> <ol> <li>Create the WalletConnect Connector and pass in the URL for the bridge server and the WalletConnect QR code modal</li> <li>Use the <code>setConnector</code> state hook to update the <code>connector</code> state variable</li> <li>Check if the connection has been established, and if not create a new session request</li> </ol> <pre><code>const connect = async () =&gt; {\n  setFetching(true);\n\n  // 1. Create connector\n  const connector = new WalletConnect({\n    bridge: 'https://bridge.walletconnect.org',\n    qrcodeModal: QRCodeModal,\n  });\n\n  // 2. Update the connector state\n  setConnector(connector);\n\n  // 3. If not connected, create a new session\n  if (!connector.connected) {\n    await connector.createSession();\n  }\n};\n</code></pre> <p>Now that you have the <code>connect</code> function setup, you can create a Connect Wallet button that will call it <code>onClick</code>. You can replace the <code>{/* buttons and network details will go here */}</code> comment in the template with the following button:</p> <pre><code>&lt;Button onClick={connect}&gt;Connect Wallet&lt;/Button&gt;\n</code></pre> <p>To test out the code so far, if you haven't already you can run <code>npm start</code> to spin up a local instance of your DApp. Then click on Connect Wallet. The WalletConnect QR code modal will pop-up.</p> <p></p> <p>To establish the connection from MetaMask mobile, you can:</p> <ol> <li>Click on the scan icon in the top right corner and scan the QR code</li> <li>A window will pop-up at the bottom of the screen and prompt you to connect to the DApp. Click Connect</li> <li>If you were able to successfully connect, you will see a pop-up in MetaMask that says Connected to Moonbeam WalletConnect Demo App</li> </ol> <p></p> <p>Currently, your DApp will still show the Connect Wallet button, so the next step will be to display a Disconnect button when connected instead. </p>"},{"location":"builders/integrations/wallets/walletconnect/#handle-disconnections","title":"Handle Disconnections","text":"<p>When you're developing your DApp and the WalletConnect integration, it is important to handle disconnections so that you can properly test the flow of the integration. You also don't want to end up with a bunch of lingering WalletConnect sessions within MetaMask mobile.</p> <p>If at any time, you need to manually end a session, you can do so from MetaMask mobile by naivgating to Settings and take the following steps:</p> <ol> <li>Select Experimental</li> <li>Under WalletConnect Sessions, tap on View Sessions</li> <li>To remove a specific session, you can hold down on the session</li> <li>A pop-up will appear at the bottom of the screen where you can then tap End.</li> </ol> <p></p> <p>Although this is important for development, this way of disconnecting a session can also be done by a user. The next couple of sections will cover the logic for how to handle disconnections from your DApp and from MetaMask mobile.</p>"},{"location":"builders/integrations/wallets/walletconnect/#disconnect-from-dapp","title":"Disconnect from DApp","text":"<p>To make it easy for users, your DApp should have a Disconnect button that will end the active session on their mobile wallet. First you can create the logic and then you can create the button.</p> <p>Upon disconnecting, you will need to reset the state of your DApp back to the initial state. To reset the state, you can create a <code>resetApp</code> function that uses the state hooks.</p> <pre><code>const resetApp = () =&gt; {\n  setConnector(null);\n  setFetching(false);\n};\n</code></pre> <p>In addition to resetting the state of the DApp, you will also need to kill the session using the <code>connector</code> and the WalletConnect <code>killSession</code> function. Since all of this functionality should happen when the user clicks on the Disconnect button, you can create a single <code>killSession</code> function to handle the reset and the disconnection.</p> <pre><code>const killSession = () =&gt; {\n  // Make sure the connector exists before trying to kill the session\n  if (connector) {\n    connector.killSession();\n  }\n  resetApp();\n};\n</code></pre> <p>Now that you have all of the logic required to handle the disconnection, you will need the Disconnect button that <code>onClick</code> will call the <code>killSession</code> function. Since you only want to display the Disconnect button once a user is connected, you can use conditional rendering. Conditional rendering allows you to check against certain variables and if a condition applies you can render one element or another. In this case, if you are not fetching the initial connection and the connector exists, you can render the Disconnect button, otherwise render the Connect Wallet button. You can replace the existing <code>&lt;Button&gt;</code> with the following:</p> <pre><code>{\n  connector &amp;&amp; !fetching ? (\n    &lt;OutlinedButton onClick={killSession}&gt;Disconnect&lt;/OutlinedButton&gt;\n  ) : (\n    &lt;Button onClick={connect}&gt;Connect Wallet&lt;/Button&gt;\n  );\n}\n</code></pre> <p>If you go to test the disconnection logic and nothing happens when you click Connect Wallet, make sure you have manually ended any preexisting sessions from MetaMask mobile. If you're still running into problems, do a hard refresh on your browser.</p> <p>Now when a user clicks on Disconnect the DApp will be reset, the connection will be disconnected on the user's mobile wallet, and the Connect Wallet button will be displayed again.</p>"},{"location":"builders/integrations/wallets/walletconnect/#disconnect-from-metamask-mobile","title":"Disconnect from MetaMask Mobile","text":"<p>As previously mentioned, a user can also disconnect and end the session from within their mobile wallet. If this happens, WalletConnect emits a <code>disconnect</code> event that the DApp will need to listen for. Upon receiving the <code>disconnect</code> event, the state will need to be reset back to the initial state. In this scenario, there is no reason to use <code>killSession</code> to end the session on the mobile wallet as the user has already ended the session on their mobile wallet.</p> <p>You'll notice that in the template, the <code>disconnect</code> event is listened for within the React Effect Hook. The effect hook lets you perform side effects in function components such as fetching data and setting up a subscription.</p> <p>In the <code>disconnect</code> event callback, you can add the <code>resetApp</code> function so that whenever a <code>disconnect</code> event is emitted, you reset the state of your DApp. </p> <pre><code>connector.on('disconnect', async (error) =&gt; {\n  if (error) {\n    // Handle errors as you see fit\n    console.error(error);\n  }\n  resetApp();\n});\n</code></pre> <p>So far you've setup the minimum logic required for connecting and disconnecting your DApp and the MetaMask mobile app. When the connection has been established, a Disconnect button is now displayed. In the next section, you'll expand on what is displayed when connected to include account and network details.</p>"},{"location":"builders/integrations/wallets/walletconnect/#check-network-support-display-result","title":"Check Network Support &amp; Display Results","text":"<p>With the basics of connecting and disconnecting out of the way, you can expand on what is displayed in the DApp when a user is connected. The first thing you'll want to do is check if the network they are on is supported and if not display a message that requests them to switch the network.</p> <p>The template comes with a list of supported networks, you can find it under <code>src/helpers/networks.js</code>. For the purposes of this guide, Moonbase Alpha is the only one that you'll be testing but you can feel free to uncomment the Moonbeam and Moonriver network configurations and add additional networks as needed.</p> <p>You can add the logic to check if the connected network is supported to the <code>onConnect</code> function. The <code>onConnect</code> function is called anytime a <code>connect</code> event is emitted. If the user is connected to a supported network, you can display network details such as the chain ID, network name, and more. You can add the following state variables and hooks:</p> <pre><code>const [account, setAccount] = useState(null);\nconst [chainId, setChainId] = useState(null);\nconst [supported, setSupported] = useState(false);\nconst [network, setNetwork] = useState(null);\nconst [symbol, setSymbol] = useState(null);\n</code></pre> <p>Make sure that you also add these state hooks in the <code>resetApp</code> function, so that all of the state variables can be reset to their initial state. </p> <p>You'll notice that the <code>onConnect</code> function already accepts two parameters: the connected chain ID and account. You can set the state variables for the <code>chainId</code> and <code>account</code> then check to see if the network is supported. You'll use the chain ID to see if the network exists in the list of supported networks. If it does, you can use the <code>setSupported</code> state hook to set the state to <code>true</code>, and if not set it to <code>false</code>.</p> <pre><code>const onConnect = async (chainId, connectedAccount) =&gt; {\n  setAccount(connectedAccount);\n  setChainId(chainId);\n\n  // get chain data\n  const networkData = SUPPORTED_NETWORKS.filter(\n    (chain) =&gt; chain.chain_id === chainId\n  )[0];\n\n  if (!networkData) {\n    setSupported(false);\n  } else {\n    setSupported(true);\n    // set additional network data here\n  }\n};\n</code></pre> <p>If the network does exist in the list of supported networks, you can then save additional network name and symbol. The symbol will be used later on to display the connected account's balance.</p> <p>You can replace the <code>// set additional network data here</code> comment with the following:</p> <pre><code>setNetwork(networkData.name);\nsetSymbol(networkData.native_currency.symbol);\n</code></pre> <p>You will also need to update the <code>useEffect</code> dependency array to include the <code>chainId</code> and <code>account</code> state variables so that it re-renders with any changes to either variable.</p> <pre><code>useEffect(() =&gt; {\n  ...\n}, [connector, chainId, account]);\n</code></pre> <p>Then to render these state variables on the page, you can include additional UI elements alongside the Disconnect button. Again, you can use conditional rendering to display specific details or an error message if the network is supported or not.</p> <pre><code>{\n  connector &amp;&amp; !fetching ? (\n    &lt;LoadedData&gt;\n      &lt;Data&gt;\n        &lt;strong&gt;Connected Account: &lt;/strong&gt;\n        {account}\n      &lt;/Data&gt;\n      &lt;Data&gt;\n        &lt;strong&gt;Chain ID: &lt;/strong&gt;\n        {chainId}\n      &lt;/Data&gt;\n      {supported ? (\n        &lt;&gt;\n          &lt;Data&gt;\n            &lt;strong&gt;Network: &lt;/strong&gt;\n            {network}\n          &lt;/Data&gt;\n        &lt;/&gt;\n      ) : (\n        &lt;strong&gt;\n          Network not supported. Please disconnect, switch networks, and connect\n          again.\n        &lt;/strong&gt;\n      )}\n      &lt;OutlinedButton onClick={killSession}&gt;Disconnect&lt;/OutlinedButton&gt;\n    &lt;/LoadedData&gt;\n  ) : (\n    &lt;Button onClick={connect}&gt;Connect Wallet&lt;/Button&gt;\n  );\n}\n</code></pre> <p>You can adapt the above code snippet as needed to provide better error handling.</p>"},{"location":"builders/integrations/wallets/walletconnect/#refresh-data","title":"Refresh Data","text":"<p>While you're developing the DApp, you'll want to handle page refreshes and update the data as needed based on the WalletConnect connection. Otherwise, you might find yourself manually disconnecting from MetaMask mobile more often then not.</p> <p>The template already has a <code>refreshData</code> function, it just needs to be called under certain circumstances. If the <code>connector</code> exists and is connected, but the <code>chainId</code> or <code>account</code> doesn't you should call the <code>refreshData</code> function and use the <code>connector</code> configurations to update state and re-render the variables on the page.</p> <p>You can replace the <code>// check state variables here &amp; if needed refresh the app</code> comment with the following:</p> <pre><code>// If any of these variables do not exist and the connector is connected, refresh the data\nif ((!chainId || !account) &amp;&amp; connector.connected) {\n  refreshData();\n}\n</code></pre> <p>You can test this logic out by refreshing the page after establishing a connection. Instead of defaulting to the Connect Wallet button, you'll see that the account and network details, and the Disconnect button are displayed.</p>"},{"location":"builders/integrations/wallets/walletconnect/#add-account-balance","title":"Add Account Balance","text":"<p>Depending on your needs, you might want to show the connected account's balance for the connected network. To do so, you can use Ethers to create a provider which can then be used to fetch the balance of the connected account.</p> <p>You can start by adding another state variable for <code>balance</code>.</p> <pre><code>const [balance, setBalance] = useState(null);\n</code></pre> <p>Make sure that you add this state hook in the <code>resetApp</code> function, and use it to reset the balance variable to its initial state.</p> <p>For simplicity, you can add the logic for fetching the account balance and saving it to state directly in the <code>onConnect</code> function. You will need to:</p> <ol> <li>Create an Ethers provider by passing in the network's RPC url, chain ID, and name</li> <li>Use the provider to call <code>getBalance</code>, which will return the balance as a <code>BigNumber</code></li> <li>Convert the <code>BigNumber</code> representation of the balance to a string representation of the balance in Ether</li> <li>Use the <code>setBalance</code> state hook to save the balance to state</li> </ol> <pre><code>const onConnect = async (chainId, address) =&gt; {\n  setAccount(address);\n\n  const networkData = SUPPORTED_NETWORKS.filter(\n    (network) =&gt; network.chain_id === chainId\n  )[0];\n\n  if (!networkData) {\n    setSupported(false);\n  } else {\n    setSupported(true);\n    setNetwork(networkData.name);\n    setSymbol(networkData.native_currency.symbol);\n    setChainId(chainId);\n\n    // 1. Create an Ethers provider\n    const provider = new ethers.JsonRpcProvider(networkData.rpc_url, {\n      chainId,\n      name: networkData.name,\n    });\n\n    // 2. Get the account balance\n    const balance = await provider.getBalance(address);\n    // 3. Format the balance\n    const formattedBalance = ethers.formatEther(balance);\n    // 4. Save the balance to state\n    setBalance(formattedBalance);\n  }\n};\n</code></pre> <p>You will need to add the <code>balance</code> state variable to the <code>useEffect</code> dependency array alongside the <code>connector</code>, <code>chainId</code>, and <code>account</code> variables.</p> <p>You can also use the <code>balance</code> state variable to refresh the data on the page.</p> <pre><code>// If any of these variables do not exist and the connector is connected, refresh the data\nif ((!chainId || !account || !balance) &amp;&amp; connector.connected) {\n  refreshData();\n}\n</code></pre> <p>Finally, you can display the account balance if the user is connected to a supported network. You can use the <code>symbol</code> state variable that was created earlier on in the guide to show the balance in DEV for Moonbase Alpha.</p> <pre><code>{\n  supported ? (\n    &lt;&gt;\n      &lt;Data&gt;\n        &lt;strong&gt;Network: &lt;/strong&gt;\n        {network}\n      &lt;/Data&gt;\n      &lt;Data&gt;\n        &lt;strong&gt;Balance: &lt;/strong&gt;\n        {balance} {symbol}\n      &lt;/Data&gt;\n    &lt;/&gt;\n  ) : (\n    &lt;strong&gt;\n      Network not supported. Please disconnect, switch networks, and connect\n      again.\n    &lt;/strong&gt;\n  );\n}\n</code></pre> <p>This example can be adapted to retrieve other data from Ethers as needed.</p>"},{"location":"builders/integrations/wallets/walletconnect/#send-a-transaction","title":"Send a Transaction","text":"<p>To truly take advantage of the value that WalletConnect provides, you can send a transaction which will be initiated from within your DApp and then confirmed and signed from MetaMask mobile.</p> <p>To get started, you will need to update the <code>sendTransaction</code> function that has already been created in the template. The function will use the WalletConnect <code>connector</code> to send a transaction. For example purposes, you can send 2 DEV tokens on Moonbase Alpha to your own account.</p> <pre><code>const sendTransaction = async () =&gt; {\n  try {\n    await connector.sendTransaction({\n      from: account,\n      to: account,\n      value: '0x1BC16D674EC80000',\n    });\n  } catch (e) {\n    // Handle the error as you see fit\n    console.error(e);\n  }\n};\n</code></pre> <p>To initiate the transaction from the DApp, you will need to create a button, that <code>onClick</code> calls the <code>sendTransaction</code> function. This should only be done if the connected network is a supported network.</p> <pre><code>{\n  supported ? (\n    &lt;&gt;\n      &lt;Data&gt;\n        &lt;strong&gt;Network: &lt;/strong&gt;\n        {network}\n      &lt;/Data&gt;\n      &lt;Data&gt;\n        &lt;strong&gt;Balance: &lt;/strong&gt;\n        {balance} {symbol}\n      &lt;/Data&gt;\n      &lt;OutlinedButton onClick={sendTransaction}&gt;\n        Send Transaction\n      &lt;/OutlinedButton&gt;\n    &lt;/&gt;\n  ) : (\n    &lt;strong&gt;\n      Network not supported. Please disconnect, switch networks, and connect\n      again.\n    &lt;/strong&gt;\n  );\n}\n</code></pre> <p>When you click on Send Transaction, a pop-up will appear in MetaMask mobile with the transaction details:</p> <ol> <li>To sign and send the transaction, you can click on Confirm</li> <li>If successful you should see a notification in the MetaMask mobile app</li> </ol> <p></p> <p>You can also confirm the transaction went through by searching for your account in a block explorer such as Moonscan.</p>"},{"location":"builders/integrations/wallets/walletconnect/#final-result","title":"Final Result","text":"<p>To review the code for this tutorial in one place, you can check out the moonbeam-walletconnect-demo GitHub repository.</p> <p>To see all of the code in action, you can check out the deployed Moonbeam WalletConnect Demo App.</p>"},{"location":"builders/integrations/wallets/walletconnect/#additional-considerations","title":"Additional Considerations","text":"<p>This guide covers the basics for setting up a WalletConnect connection, but there are many ways in which you can improve the experience for your users or yourself as you develop the integration. You might want to consider adding in support for the following items:</p> <ul> <li>Adding a loader for when your transaction is waiting to be confirmed or a message that informs your users to check their mobile wallet and confirm the transaction from there</li> <li>Adding notifications on your DApp for the status of sent transactions</li> <li>Adding appropriate error handling</li> <li>Adding in logic to automatically update your users balances</li> </ul>"},{"location":"builders/interoperability/mrl/","title":"Moonbeam Routed Liquidity","text":""},{"location":"builders/interoperability/mrl/#introduction","title":"Introduction","text":"<p>Moonbeam Routed Liquidity (MRL) refers to a use case in which liquidity in any blockchain ecosystem that Moonbeam is connected to can be routed to Polkadot parachains. This is possible because of multiple components that work together:</p> <ul> <li>General Message Passing (GMP) - technology connecting multiple blockchains, including Moonbeam. With it, developers can pass messages with arbitrary data, and tokens can be sent across non-parachain blockchains through chain-agnostic GMP protocols</li> <li>Cross-Consensus Message Passing (XCM) - Polkadot's flavor of GMP. Main technology driving cross-chain interactions between Polkadot and its parachains, including Moonbeam</li> <li>XCM-Enabled ERC-20s - also referred to as local XC-20s, are all of the ERC-20 tokens that exist on Moonbeam's EVM that are XCM-enabled out of the box</li> <li>GMP Precompile - a precompiled contract that acts as an interface between a message passed from Wormhole GMP protocol and XCM</li> </ul> <p>These components are combined to offer seamless liquidity routing into parachains through Moonbeam. Liquidity can be routed to parachains using either the GMP Precompile or traditional smart contracts that interact with XCM-related precompiles, like the X-Tokens Precompile.</p> <p>GMP protocols typically move assets in a lock/mint or burn/mint fashion. This liquidity exists on Moonbeam normally as ERC-20 tokens. All ERC-20s on Moonbeam are now XCM-enabled, meaning they can now exist as XC-20s in any other parachain, as long as they are registered on the other parachain. XCM-enabled ERC-20s are referred to as local XC-20s on Moonbeam.</p> <p>MRL is currently available through Wormhole-connected chains, but nothing stops a parachain team from implementing a similar pathway through a different GMP provider.</p> <p>This guide will primarily cover the process of integrating with Wormhole's SDKs and interfaces so that your parachain can access liquidity from non-parachain blockchains through Moonbeam. It will also cover the requirements to get started and the tokens available through Wormhole.</p>"},{"location":"builders/interoperability/mrl/#prerequisites","title":"Prerequisites","text":"<p>To begin an MRL integration with your parachain, you will first need to:</p> <ul> <li>Establish a cross-chain integration with Moonbeam via HRMP channels so assets can be sent from Moonbeam to your parachain</li> <li>Register Moonbeam\u2019s asset on your parachain. This is required due to a temporary drawback of pallets that send XCM messages for asset transfer, making Moonbeam\u2019s native gas asset the only asset that can be used as a cross-chain fee on the way back</li> <li>Register the local XC-20 token(s) you want routed to your parachain<ul> <li>Allow these local XC-20 token(s) to be used for XCM fees</li> </ul> </li> <li>Allow users to send the <code>Transact</code> XCM instruction (via <code>polkadotXcm.Send</code> or with the XCM Transactor Pallet), which enables remote EVM calls, allowing accounts on a remote parachain to interact with the bridging smart contracts on Moonbeam</li> </ul>"},{"location":"builders/interoperability/mrl/#mrl-through-wormhole","title":"MRL Through Wormhole","text":"<p>While MRL intends to encompass many different GMP providers, Wormhole is the first built for the public.After you have completed all of the prerequisites, to receive liquidity through Wormhole, you'll need to:</p> <ul> <li>Notify the Moonbeam team of your desire to integrate into the MRL program so that we can help you with the technical implementation</li> <li>Connect with the Wormhole team and other MRL-dependent frontends to finalize technical details and sync announcements. They will likely need the following information:<ul> <li>Parachain ID</li> <li>The account type that your parachain uses (i.e., AccountId32 or AccountKey20)</li> <li>The addresses and names of the tokens that you have registered</li> <li>An endpoint that a Wormhole Connect frontend can use</li> <li>Why do you want your parachain to be connected through Wormhole Connect?</li> </ul> </li> </ul>"},{"location":"builders/interoperability/mrl/#sending-tokens-through-wormhole","title":"Send Tokens Through Wormhole to a Parachain","text":"<p>MRL provides a one-click solution that allows you to define a multilocation as the final destination for your assets arriving from any Wormhole chain with a Wormhole Connect integration.</p> <p>To send tokens through Wormhole and MRL, user interfaces will use a mixture of the Wormhole TokenBridge and Moonbeam\u2019s GMP Precompile.</p> <p>Users transferring liquidity will invoke the <code>transferTokensWithPayload</code> method on the origin chain's deployment of the Wormhole TokenBridge smart contract, which implements the <code>ITokenBridge.sol</code> interface to send tokens to the GMP Precompile. This function requires a bytes payload, formatted as a SCALE-encoded multilocation object wrapped within another precompile-specific versioned type. To learn how to build this payload, please refer to the Building the Payload for Wormhole section of the GMP Precompile documentation.</p> <p>Wormhole relies on a set of distributed nodes that monitor the state on several blockchains. In Wormhole, these nodes are referred to as Guardians. The Guardian's role is to observe messages and sign the corresponding payloads. If 2/3rds of Wormhole's signing Guardians validate a particular message, the message becomes approved and can be received on other chains.</p> <p>The Guardian signatures and the message form a proof called a Verified Action Approval (VAA). These VAAs are delivered to their destinations by relayers within the Wormhole network. On the destination chain, the VAA is used to perform an action. In this case, the VAA is passed into the <code>wormholeTransferERC20</code> function of the GMP Precompile, which processes the VAA through the Wormhole bridge contract (which mints the tokens) and relays the tokens to a parachain using XCM messages. Please note that as a parachain integrating MRL, you will likely not need to implement or use the GMP Precompile.</p> <p>A relayer's only job is to pass the transactions approved by Wormhole Guardians to the destination chain. MRL is supported by some relayers already, but anyone can run one. Furthermore, users can manually execute their transaction in the destination chain when bridging through Wormhole and avoid relayers altogether.</p> <p></p>"},{"location":"builders/interoperability/mrl/#sending-tokens-back-through-wormhole","title":"Send Tokens From a Parachain Back Through Wormhole","text":"<p>To send tokens from a parachain back through Wormhole to a destination chain, a user must send a transaction, preferably using the <code>utility.batchAll</code> extrinsic, which will batch a token transfer and a remote execution action into a single transaction. For example, a batch with a <code>xTokens.transferMultiassets</code> call and a <code>polkadotXcm.send</code> call with the <code>Transact</code> instruction.</p> <p>The reason for batching is to offer a one-click solution. Nevertheless, for now, the user must also own xcGLMR (representation of GLMR) on the parachain. There are two main reasons as to why:</p> <ul> <li>Local XC-20s (XCM-enabled ERC-20s) can't be used to pay for XCM execution on Moonbeam. This was a design decision, as it was preferred to treat them as ERC-20s and utilize the native <code>transfer</code> function of the ERC-20 interface. Consequently, XCM instructions handling the XC-20s are only limited to moving funds from one account to another and don't understand the Holding Register that is inherent to the XCM flow</li> <li>Currently, XCM-related pallets limit XCM messages' ability to send tokens with different reserve chains. Consequently, you can't send an XC-20 and set the fee token to be the native parachain token</li> </ul> <p>Note that as of late 2024, the X-Tokens precompile now uses the Polkadot XCM pallet under the hood, replacing the X-Tokens pallet. Parachains using a different pallet must implement their own solution to transfer reserve and non-reserve assets in a single message.</p> <p>As an example, a brief overview of the entire process of sending MRL tokens from a parachain back through Wormhole to a destination chain is as follows:</p> <ol> <li>Send a batch transaction using the <code>batchAll</code> extrinsic of the Utility Pallet that contains the following two calls:<ul> <li><code>xTokens.transferMultiassets</code> - sends xcGLMR and the local XC-20 to the user\u2019s Computed Origin account. The Computed Origin account is a keyless account on Moonbeam that an account on another parachain has control of via XCM</li> <li><code>polkadotXcm.send</code> - with the <code>Transact</code> instruction. Sends a remote EVM call via XCM to the Batch Precompile on Moonbeam, which batches the following two calls into a single remote EVM transaction using the <code>ethereumXcm.transact</code> extrinsic:<ul> <li><code>approve</code> (of the local XC-20 contract) - approves the Wormhole relayer to transfer the local XC-20</li> <li><code>transferTokensWithRelay</code> (of the relayer contract) - calls the <code>transferTokensWithPayload</code> function of the Wormhole TokenBridge smart contract on Moonbeam to transfer the tokens cross-chain, which broadcasts the message for the Wormhole Guardians to pick up</li> </ul> </li> </ul> </li> <li>The Guardian Network will pick up on the Wormhole transaction and sign it</li> <li>A Wormhole relayer will relay the tokens to the destination chain and destination account</li> </ol> <p></p> <p>Now that you have a general idea of the game plan, you can begin implementing it. The example in this guide will show you how to transfer assets from a parachain to Moonbase Alpha and back through Wormhole to the destination chain, but this guide can be adapted for Moonbeam.</p>"},{"location":"builders/interoperability/mrl/#calculate-computed-origin-account","title":"Calculate the Computed Origin Account","text":"<p>To send tokens back through Wormhole, you'll need to calculate the user's Computed Origin account (previously referred to as a multilocation-derivative account) on Moonbeam. This can be done off-chain using the <code>calculate-multilocation-derivative-account.ts</code> script from the xcm-tools repository. For more details, you can refer to the Computed Origins guide.</p> <p>Alternatively, the <code>multilocationToAddress</code> function of the XCM Utilities Precompile can also be used.</p>"},{"location":"builders/interoperability/mrl/#create-a-project","title":"Create a Project","text":"<p>You'll need to create a new project directory for the files you'll be building in this guide. Take the following steps to set up your project:</p> <ol> <li> <p>Create a new directory and change into the directory</p> <pre><code>mkdir wormhole-mrl-demo &amp;&amp; cd wormhole-mrl-demo\n</code></pre> </li> <li> <p>Create a <code>package.json</code> file:</p> <pre><code>npm init -y\n</code></pre> </li> <li> <p>Install packages that you'll need to build the remote EVM calls and the XCM extrinsics</p> <pre><code>npm i @polkadot/api ethers\n</code></pre> </li> <li> <p>Create the files that you'll need for this guide:</p> <ul> <li><code>build-transfer-multiassets-call.js</code> - for creating the <code>xTokens.transferMultiassets</code> extrinsic that transfers assets cross-chain. This contains the logic for the first call of the batch transaction</li> <li><code>build-remote-calldata.js</code> - for creating the encoded calldata that approves the Wormhole relayer to transfer the local XC-20 and initiates the transfer via the Wormhole TokenBridge contract. This is required for the second call of the batch transaction</li> <li><code>build-remote-evm-call.js</code> - to create the <code>polkadotXcm.send</code> extrinsic that executes the remote EVM call. This contains the logic for the second call of the batch transaction</li> <li><code>send-batch-transaction.js</code> - for assembling and sending the batch transaction for the asset transfer and the remote EVM call</li> </ul> <pre><code>touch build-transfer-multiassets.js build-remote-calldata.js \\\nbuild-remote-evm-call.js send-batch-transaction.js\n</code></pre> </li> <li> <p>Create a directory and files for the ABIs of each of the contracts you'll be working within this guide:</p> <pre><code>mkdir abi &amp;&amp; touch abi/ERC20.js abi/TokenRelayer.js abi/Batch.js\n</code></pre> ERC-20 Interface ABI ERC20.js<pre><code>export default [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'owner',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'spender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'value',\n        type: 'uint256',\n      },\n    ],\n    name: 'Approval',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'from',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'to',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'value',\n        type: 'uint256',\n      },\n    ],\n    name: 'Transfer',\n    type: 'event',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'owner',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: 'spender',\n        type: 'address',\n      },\n    ],\n    name: 'allowance',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'spender',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'to',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'from',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: 'to',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> TokenBridge Relayer ABI TokenRelayer.js<pre><code>export default [\n  {\n    inputs: [\n      {\n        internalType: 'uint16',\n        name: 'targetChainId',\n        type: 'uint16',\n      },\n      {\n        internalType: 'address',\n        name: 'token',\n        type: 'address',\n      },\n      {\n        internalType: 'uint8',\n        name: 'decimals',\n        type: 'uint8',\n      },\n    ],\n    name: 'calculateRelayerFee',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: 'feeInTokenDenomination',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'token',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: 'toNativeTokenAmount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint16',\n        name: 'targetChain',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes32',\n        name: 'targetRecipient',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'uint32',\n        name: 'batchId',\n        type: 'uint32',\n      },\n    ],\n    name: 'transferTokensWithRelay',\n    outputs: [\n      {\n        internalType: 'uint64',\n        name: 'messageSequence',\n        type: 'uint64',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: 'toNativeTokenAmount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint16',\n        name: 'targetChain',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes32',\n        name: 'targetRecipient',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'uint32',\n        name: 'batchId',\n        type: 'uint32',\n      },\n    ],\n    name: 'wrapAndTransferEthWithRelay',\n    outputs: [\n      {\n        internalType: 'uint64',\n        name: 'messageSequence',\n        type: 'uint64',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n];\n</code></pre> Batch Precompile ABI Batch.js<pre><code>export default [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'index',\n        type: 'uint256',\n      },\n    ],\n    name: 'SubcallFailed',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'index',\n        type: 'uint256',\n      },\n    ],\n    name: 'SubcallSucceeded',\n    type: 'event',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address[]',\n        name: 'to',\n        type: 'address[]',\n      },\n      {\n        internalType: 'uint256[]',\n        name: 'value',\n        type: 'uint256[]',\n      },\n      {\n        internalType: 'bytes[]',\n        name: 'callData',\n        type: 'bytes[]',\n      },\n      {\n        internalType: 'uint64[]',\n        name: 'gasLimit',\n        type: 'uint64[]',\n      },\n    ],\n    name: 'batchAll',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address[]',\n        name: 'to',\n        type: 'address[]',\n      },\n      {\n        internalType: 'uint256[]',\n        name: 'value',\n        type: 'uint256[]',\n      },\n      {\n        internalType: 'bytes[]',\n        name: 'callData',\n        type: 'bytes[]',\n      },\n      {\n        internalType: 'uint64[]',\n        name: 'gasLimit',\n        type: 'uint64[]',\n      },\n    ],\n    name: 'batchSome',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address[]',\n        name: 'to',\n        type: 'address[]',\n      },\n      {\n        internalType: 'uint256[]',\n        name: 'value',\n        type: 'uint256[]',\n      },\n      {\n        internalType: 'bytes[]',\n        name: 'callData',\n        type: 'bytes[]',\n      },\n      {\n        internalType: 'uint64[]',\n        name: 'gasLimit',\n        type: 'uint64[]',\n      },\n    ],\n    name: 'batchSomeUntilFailure',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> </li> </ol>"},{"location":"builders/interoperability/mrl/#build-transfer-multiassets","title":"Build the Transfer Multiassets Extrinsic","text":"<p>You can begin to tackle the <code>xTokens.transferMultiassets</code> extrinsic, which accepts four parameters:</p> <ul> <li><code>assets</code> - defines the multilocation and amount of xcDEV (xcGLMR for Moonbeam) and the local XC-20 to send to Moonbase Alpha, with the xcDEV positioned as the first asset and the local XC-20 as the second</li> <li><code>feeItem</code> - set to the index of the xcDEV asset, which in this case is <code>0</code>, so that DEV is used to pay for the execution fees in Moonbase Alpha</li> <li><code>dest</code> - a multilocation that defines the Computed Origin account that you calculated in the previous section on Moonbase Alpha</li> <li><code>destWeightLimit</code> - the weight to be purchased to pay for XCM execution on the destination chain</li> </ul> <p>You can find more information on each parameter in the X-Tokens Precompile page documentation.</p> <p>In the <code>build-transfer-multiassets-call.js</code> file, you'll build the <code>xTokens.transferMultiassets</code> extrinsic and export it.</p> build-transfer-multiassets-call.js<pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\n// Input data\nconst originChainProviderWsURL = 'INSERT_ORIGIN_CHAIN_WSS_URL';\nconst computedOriginAccount = 'INSERT_COMPUTED_ORIGIN_ADDRESS';\nconst localXC20Address = 'INSERT_LOCAL_XC20_ADDRESS';\nconst transferAmount = 'INSERT_AMOUNT_TO_TRANSFER';\n\n// Transfer multiassets parameters\nconst assets = {\n  V4: [\n    {\n      // xcDEV\n      id: {\n        parents: 1,\n        interior: {\n          X2: [\n            { Parachain: 1000 }, // Parachain ID\n            { PalletInstance: 3 }, // Index of the Balances Pallet\n          ],\n        },\n      },\n      fun: {\n        Fungible: '100000000000000000', // 0.1 DEV as an estimation for XCM and EVM transaction fee\n      },\n    },\n    {\n      // Local XC-20 token\n      id: {\n        parents: 1,\n        interior: {\n          X3: [\n            { Parachain: 1000 }, // Parachain ID\n            { PalletInstance: 48 }, // Index of the ERC-20 XCM Bridge Pallet\n            {\n              AccountKey20: {\n                key: localXC20Address,\n              },\n            },\n          ],\n        },\n      },\n      fun: {\n        Fungible: transferAmount,\n      },\n    },\n  ],\n};\nconst feeItem = 0;\nconst destination = {\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { Parachain: 1000 },\n        { AccountKey20: { key: computedOriginAccount } },\n      ],\n    },\n  },\n};\nconst weightLimit = 'Unlimited';\n\nexport const getTransferMultiassetsCall = async () =&gt; {\n  // Create origin chain API provider\n  const originChainProvider = new WsProvider(originChainProviderWsURL);\n  const originChainAPI = await ApiPromise.create({\n    provider: originChainProvider,\n  });\n\n  // Create the transferMultiasset extrinsic\n  const transferMultiassets = originChainAPI.tx.xTokens.transferMultiassets(\n    assets,\n    feeItem,\n    destination,\n    weightLimit\n  );\n\n  originChainAPI.disconnect();\n\n  return transferMultiassets;\n};\n</code></pre> <p>To modify the code for Moonbeam, you'll use the following configurations:</p> Parameter Value Parachain ID 2004 Balances Pallet Index 10 ERC-20 XCM Bridge Pallet Index 110"},{"location":"builders/interoperability/mrl/#build-the-remote-evm-call","title":"Build the Remote EVM Call","text":"<p>To generate the second call of the batch transaction, the <code>polkadotXcm.send</code> extrinsic, you'll need to create the EVM transaction and then assemble the XCM instructions that execute said EVM transaction.</p> <p>For now, you'll focus on generating the calldata for the EVM transaction. For this, you'll construct a transaction that interacts with the Batch Precompile so that two transactions can happen in one. This is helpful because this EVM transaction has to approve both a Wormhole relayer to relay the local XC-20 token and the relay action itself.</p> <p>To create the batch transaction and wrap it in a remote EVM call to be executed on Moonbeam, you'll need to take the following steps:</p> <ol> <li> <p>Create contract instances of the local XC-20, the Wormhole relayer, and the Batch Precompile. For this, you'll need the ABI for each contract and the address of a Wormhole relayer. You can use the xLabs relayer:</p> MoonbeamMoonbase Alpha <pre><code>0xcafd2f0a35a4459fa40c0517e17e6fa2939441ca\n</code></pre> <pre><code>0x9563a59c15842a6f322b10f69d1dd88b41f2e97b\n</code></pre> </li> <li> <p>Use Ether's <code>encodeFunctionData</code> function to get the encoded call data for the two calls in the batch transaction: the <code>approve</code> transaction and the <code>transferTokensWithRelay</code> transaction</p> </li> <li>Combine the two transactions into a batch transaction and use Ether's <code>encodeFunctionData</code> to get the encoded call data for the batch transaction</li> <li>Use the encoded call data for the batch transaction to create the remote EVM call via the <code>ethereumXcm.transact</code> extrinsic, which accepts the <code>xcmTransaction</code> as the parameter. For more information, please refer to the Remote EVM Calls documentation</li> </ol> <p>In the <code>build-remote-calldata.js</code> file, add the following code:</p> build-remote-calldata.js<pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { ethers } from 'ethers';\nimport batchABI from './abi/Batch.js';\nimport erc20ABI from './abi/ERC20.js';\nimport tokenRelayerABI from './abi/TokenRelayer.js';\n\nconst localXC20Address = 'INSERT_LOCAL_XC20_ADDRESS';\nconst transferAmount = 'INSERT_AMOUNT_TO_TRANSFER';\nconst xLabsRelayer = '0x9563a59c15842a6f322b10f69d1dd88b41f2e97b';\nconst destinationChainId = 'INSERT_DESTINATION_CHAIN_ID';\nconst computedOriginAccount = 'INSERT_COMPUTED_ORIGIN_ADDRESS';\n// The recipient address on the destination chain needs to be formatted in 32 bytes\n// You'll pad the address to the left with zeroes. Add the destination address below\n// without the 0x\nconst destinationAddress =\n  '0x000000000000000000000000' + 'INSERT_DESTINATION_ADDRESS';\n\n// Create contract instances\nconst batchInterface = new ethers.Interface(batchABI);\nconst localXC20Interface = new ethers.Interface(erc20ABI);\nconst tokenRelayer = new ethers.Contract(\n  xLabsRelayer,\n  tokenRelayerABI,\n  new ethers.JsonRpcProvider('https://rpc.api.moonbase.moonbeam.network')\n);\n\n// Get the encoded calldata for the approve transaction\nconst approve = localXC20Interface.encodeFunctionData('approve', [\n  xLabsRelayer, // Spender\n  transferAmount, // Amount\n]);\n\n// Get the encoded calldata for the transferTokensWithRelay transaction.\n// Use wrapAndTransferEthWithRelay if the token is GLMR\nconst transferTokensWithRelay = tokenRelayer.interface.encodeFunctionData(\n  'transferTokensWithRelay',\n  [\n    localXC20Address, // Token\n    transferAmount, // Amount to be transferred\n    0, // Amount to swap into native assets on the target chain\n    destinationChainId, // Target chain ID, like Ethereum MainNet or Fantom\n    destinationAddress, // Target recipient address\n    0, // Batch ID for Wormhole message batching\n  ]\n);\n\nconst encodedBatchAllCall = batchInterface.encodeFunctionData('batchAll', [\n  [localXC20Address, xLabsRelayer], // Addresses to call\n  [0, 0], // Value to send for each call\n  [approve, transferTokensWithRelay], // Call data for each call\n  [], // Gas limit for each call\n]);\n\nexport const getTransactCall = async () =&gt; {\n  // Create Moonbeam API provider\n  const moonbeamProvider = new WsProvider(\n    'wss://wss.api.moonbase.moonbeam.network'\n  );\n  const moonbeamAPI = await ApiPromise.create({ provider: moonbeamProvider });\n\n  // Create the extrinsic for the remote EVM call\n  const transact = moonbeamAPI.tx.ethereumXcm.transact({\n    V2: {\n      gasLimit: 350000n,\n      action: {\n        Call: '0x0000000000000000000000000000000000000808',\n      },\n      value: 0n,\n      input: encodedBatchAllCall,\n    },\n  });\n\n  const txWeight = (await transact.paymentInfo(computedOriginAccount)).weight;\n\n  moonbeamAPI.disconnect();\n\n  return { transact, txWeight };\n};\n</code></pre>"},{"location":"builders/interoperability/mrl/#build-xcm-message-for-remote-evm-call","title":"Build the XCM Message for the Remote EVM Call","text":"<p>Next, you'll need to create the extrinsic to send the remote EVM call to Moonbeam. To do so, you'll want to send an XCM message such that the <code>Transact</code> XCM instruction gets successfully executed. The most common method to do this is through <code>polkadotXcm.send</code> with the <code>WithdrawAsset</code>, <code>BuyExecution</code>, and <code>Transact</code> instructions. <code>RefundSurplus</code> and <code>DepositAsset</code> can also be used to ensure no assets get trapped, but they are technically optional.</p> <p>In the <code>build-remote-evm-call.js</code> file, add the following code:</p> build-remote-evm-call.js<pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { getTransactCall } from './build-batch-evm-call.js';\n\nconst originChainProviderWsURL = 'INSERT_ORIGIN_CHAIN_WSS_URL';\nconst computedOriginAccount = 'INSERT_COMPUTED_ORIGIN_ADDRESS';\n\nexport const getPolkadotXcmCall = async () =&gt; {\n  // Create origin chain API provider\n  const originChainProvider = new WsProvider(originChainProviderWsURL);\n  const originChainAPI = await ApiPromise.create({\n    provider: originChainProvider,\n  });\n\n  // Get the weight required to execute the Transact calldata\n  const { transact, txWeight } = await getTransactCall();\n\n  // Create the extrinsic for the remote EVM call\n  const sendXcm = originChainAPI.tx.polkadotXcm.send(\n    { V4: { parents: 1, interior: { X1: [{ Parachain: 1000 }] } } },\n    {\n      V4: [\n        {\n          // Withdraw DEV asset (0.06) from the target account\n          WithdrawAsset: [\n            {\n              id: {\n                parents: 0,\n                interior: { X1: [{ PalletInstance: 3 }] },\n              },\n              fun: { Fungible: 60000000000000000n },\n            },\n          ],\n        },\n        {\n          // Buy execution with the DEV asset\n          BuyExecution: {\n            fees: {\n              id: {\n                parents: 0,\n                interior: { X1: [{ PalletInstance: 3 }] },\n              },\n              fun: { Fungible: 60000000000000000n },\n            },\n            weightLimit: 'Unlimited',\n          },\n        },\n        {\n          Transact: {\n            originKind: 'SovereignAccount',\n            requireWeightAtMost: {\n              refTime: txWeight.refTime,\n              proofSize: txWeight.proofSize,\n            },\n            call: {\n              encoded: transact.method.toHex(),\n            },\n          },\n        },\n        {\n          RefundSurplus: {},\n        },\n        {\n          DepositAsset: {\n            // Note that this must be AllCounted and not All, since All has too high of a gas requirement\n            assets: { Wild: { AllCounted: 1 } },\n            beneficiary: {\n              parents: 0,\n              interior: {\n                X1: [{ AccountKey20: { key: computedOriginAccount } }],\n              },\n            },\n          },\n        },\n      ],\n    }\n  );\n\n  return sendXcm;\n};\n</code></pre>"},{"location":"builders/interoperability/mrl/#build-batch-extrinsic","title":"Build the Batch Extrinsic","text":"<p>To ensure that both the <code>xTokens.transferMultiassets</code> and the <code>polkadotXcm.send</code> transactions are sent together, you can batch them together using <code>utility.batchAll</code>. This helps ensure that the asset transfer happens before the EVM transaction, which is a necessary distinction. Unfortunately, this is subject to change with future XCM updates.</p> <p>In the <code>send-batch-transaction.js</code> file, add the following code:</p> send-batch-transaction.js<pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { getTransferMultiassetsCall } from './build-transfer-multiassets-call.js';\nimport { getPolkadotXcmCall } from './build-remote-evm-call.js';\n\nconst originChainProviderWsURL = 'INSERT_ORIGIN_CHAIN_WSS_URL';\n\nconst sendBatchTransaction = async () =&gt; {\n  // Create origin chain API provider\n  const originChainProvider = new WsProvider(originChainProviderWsURL);\n  const originChainAPI = await ApiPromise.create({\n    provider: originChainProvider,\n  });\n\n  // Create the batch transaction\n  const batchTransaction = originChainAPI.tx.utility.batchAll([\n    await getTransferMultiassetsCall(),\n    await getPolkadotXcmCall(),\n  ]);\n\n  // Create a keyring instance to sign the transaction\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'ethereum' });\n  const account = keyring.addFromUri(privateKey);\n\n  // Send the batch transaction\n  const transaction = await batchTransaction.signAndSend(account, ({ status }) =&gt; {\n    if (status.isInBlock) console.log(`Transaction sent!`);\n  });\n\n  originChainAPI.disconnect();\n\n  return transaction;\n};\n\nsendBatchTransaction();\n</code></pre> <p>If you want to see an example project that fully implements this, an example is available in a GitHub repository.</p> <p>It's important to note that not every parachain will have X-Tokens and the other pallets implemented in a way that will allow this path. Substrate-based chains are very flexible, to the point where a standard doesn't exist. If you believe your parachain does not support this path, please provide an alternative solution in the Moonbeam forum and to the Wormhole team.</p>"},{"location":"builders/interoperability/mrl/#tokens-available-through-wormhole","title":"Tokens Available Through Wormhole","text":"<p>While Wormhole has the technical capability to bridge any token across chains, relayers will not support every token for fees. The ERC-20 assets that can be bridged through Wormhole's MRL solution depend on the tokens the xLabs relayer takes in. The tokens that are available to Moonbeam and Moonbase Alpha are listed in the table below:</p> MoonbeamMoonbase Alpha Token Name Symbol Decimals Address Wrapped AVAX wAVAX 18 0xd4937A95BeC789CC1AE1640714C61c160279B22F Wrapped Bitcoin wBTC 8 0xE57eBd2d67B462E9926e04a8e33f01cD0D64346D Wrapped BNB wBNB 18 0xE3b841C3f96e647E6dc01b468d6D0AD3562a9eeb Celo Native Asset CELO 18 0xc1a792041985F65c17Eb65E66E254DC879CF380b Dai Stablecoin DAI 18 0x06e605775296e851FF43b4dAa541Bb0984E9D6fD Wrapped Ethereum wETH 18 0xab3f0245B83feB11d15AAffeFD7AD465a59817eD Wrapped Fantom wFTM 18 0x609AedD990bf45926bca9E4eE988b4Fb98587D3A Wrapped GLMR wGLMR 18 0xAcc15dC74880C9944775448304B263D191c6077F Wrapped Matic wMATIC 18 0x82DbDa803bb52434B1f4F41A6F0Acb1242A7dFa3 Wrapped SOL SOL 9 0x99Fec54a5Ad36D50A4Bba3a41CAB983a5BB86A7d Sui SUI 9 0x484eCCE6775143D3335Ed2C7bCB22151C53B9F49 Tether USD USDT 6 0xc30E9cA94CF52f3Bf5692aaCF81353a27052c46f USDC (Wormhole) USDC 6 0x931715FEE2d06333043d11F658C8CE934aC61D0c Token Name Symbol Decimals Address Wrapped Avax wAVAX 18 0x2E8afeCC19842229358f3650cc3F091908dcbaB4 Wrapped BNB wBNB 18 0x6097E80331B0c6aF4F74D7F2363E70Cb2Fd078A5 Celo Native Asset CELO 18 0x3406a9b09adf0cb36DC04c1523C4b294C6b79513 Dai Stablecoin DAI 18 0xc31EC0108D8e886be58808B4C2C53f8365f1885D Wrapped Ether wETH 18 0xD909178CC99d318e4D46e7E66a972955859670E1 Wrapped Ether (Wormhole) wETH 18 0xd27d8883E31FAA11B2613b14BE83ad8951C8783C Wrapped Fantom wFTM 18 0x566c1cebc6A4AFa1C122E039C4BEBe77043148Ee Wrapped Matic wMATIC 18 0xD2888f015BcB76CE3d27b6024cdEFA16836d0dbb Sui SUI 9 0x2ed4B5B1071A3C676664E9085C0e3826542C1b27 USDC USDC 6 0x6533CE14804D113b1F494dC56c5D60A43cb5C3b5 <p>Please take the time to verify that these assets are still Wormhole assets on Moonbeam by using the Wormhole asset verifier.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/interoperability/protocols/axelar/","title":"Axelar Network","text":""},{"location":"builders/interoperability/protocols/axelar/#introduction","title":"Introduction","text":"<p>Axelar delivers secure cross-chain communication for Web3. Axelar's infrastructure enables dApp users to interact with any asset or application, on any connected chain, with one click. Powered by a permissionless Proof-of-Stake validator set, Axelar network allows dApps to pass arbitrary messages across chains using Turing-complete calls.</p> <p>Axelar is a full-stack transport layer that supports asset transfer, General Message Passing and composability of programs. It securely connects all blockchain ecosystems, applications, assets and users to deliver Web3 interoperability. Axelar is composed of a decentralized network of validators, secure gateway contracts, uniform translation, routing architecture, and a suite of protocols and application programming interfaces (APIs). Take a look at the Tech Stack Diagram for more details.</p> <p></p> <p>The Axelar APIs provide a rich suite for developing Web3 applications, ensuring that developers have the tools they need for building. With these tools and APIs, developers can use the Axelar network and its APIs to write dApps that can be easily deployed across all Axelar-connected ecosystems.  </p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/interoperability/protocols/axelar/#getting-started","title":"Getting Started","text":"<p>There are a couple of resources to get you started building cross-chain applications with Axelar:</p> <ul> <li>Developer documentation - for technical guides</li> <li>Squid - a bridging UI used to transfer assets across chains</li> </ul> <p>There is also a block explorer available to track your cross-chain transfers and more:</p> <ul> <li>Axelarscan for MainNet</li> <li>Axelarscan for TestNet</li> </ul>"},{"location":"builders/interoperability/protocols/axelar/#contracts","title":"Contracts","text":"<p>See the list of Axelar contracts deployed to Moonbeam, and the networks connected to Moonbeam through Axelar.</p> <ul> <li> <p>MainNet Contracts - Moonbeam</p> </li> <li> <p>TestNet Contracts - Moonbase Alpha</p> </li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/interoperability/protocols/hyperlane/","title":"Hyperlane Protocol","text":""},{"location":"builders/interoperability/protocols/hyperlane/#introduction","title":"Introduction","text":"<p>Hyperlane is a security-modular cross-chain communication protocol for Web3. Hyperlane enables dApp users to interact with any asset or application, on any connected chain, with one click. It supports general asset transfer as well as custom cross-chain messaging.  </p> <p>Using Interchain Security Modules (ISMs), Hyperlane allows developers to configure the method by which messages are sent and validated across chains. Hyperlane is composed of validators, relayers, and watchtowers. Validators will watch for and confirm cross-chain messages. Relayers spend the gas to send messages across chains. Watchtowers perform checks to ensure that validators are good-faith actors, securing the protocol. Take a look at the tech stack diagram and their protocol documentation for more details.</p> <p></p> <p>The Hyperlane APIs provide a rich suite for developing Web3 applications, ensuring that developers have the tools they need for building. With these tools and APIs, developers can use the Hyperlane protocol and its APIs to write dApps that can be easily deployed across all Hyperlane-connected ecosystems.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/interoperability/protocols/hyperlane/#getting-started","title":"Getting Started","text":"<p>There are a couple of resources to get you started building cross-chain applications with Hyperlane:</p> <ul> <li>Developer documentation - for technical guides</li> <li>Hyperlane Explorer - to track cross-chain transfers</li> </ul>"},{"location":"builders/interoperability/protocols/hyperlane/#contracts","title":"Contracts","text":"<p>See the list of Hyperlane contracts deployed to Moonbeam, and the networks connected to Moonbeam through Hyperlane.</p> <ul> <li>MainNet and TestNet Contracts</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/interoperability/protocols/layerzero/","title":"LayerZero Protocol","text":""},{"location":"builders/interoperability/protocols/layerzero/#introduction","title":"Introduction","text":"<p>LayerZero delivers secure omnichain interoperability for Web3. It consists of an Oracle actor and a Relayer actor that work separately to provide secure messages from one chain to another. LayerZero's infrastructure enables dApp users to interact with any asset or application, on any connected chain, with one click.</p> <p>LayerZero is a transport layer that enables asset transfer with low-level communication primitives. DApps that utilize LayerZero are known as User Applications, whose messages are relayed across chains by a Relayer, and whose messages are verified on the destination chain by an Oracle's block headers. Take a look at the tech stack diagram below and their conceptual documentation for more details.</p> <p></p> <p>The LayerZero APIs provide a rich suite for developing Web3 applications, ensuring that developers have the tools they need for building. With these tools and APIs, developers can use the LayerZero protocol and its APIs to write dApps that can be easily deployed across all LayerZero-connected ecosystems.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/interoperability/protocols/layerzero/#getting-started","title":"Getting Started","text":"<p>There are a couple of resources to get you started building cross-chain applications with LayerZero:</p> <ul> <li>Developer documentation - for technical guides</li> <li>Stargate - a bridging UI that uses LayerZero, built by the Stargate team</li> </ul>"},{"location":"builders/interoperability/protocols/layerzero/#contracts","title":"Contracts","text":"<p>See the list of LayerZero contracts deployed to Moonbeam, and the networks connected to Moonbeam through LayerZero.</p> <ul> <li> <p>MainNet Contracts - Moonbeam</p> </li> <li> <p>TestNet Contracts - Moonbase Alpha</p> </li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/interoperability/protocols/wormhole/","title":"Wormhole Network","text":""},{"location":"builders/interoperability/protocols/wormhole/#introduction","title":"Introduction","text":"<p>Wormhole is a protocol that validates and secures cross-chain communication for Web3, through messages known as verifiable action approvals (VAAs). Wormhole's infrastructure enables dApp users to interact with any asset or application, on any connected chain, with one click. Powered by a multi-signature schemed protocol and 19 signing Guardians, Wormhole allows dApps to pass arbitrary messages across chains.</p> <p>Wormhole consists of multiple modular swap-in components that can be leveraged independently and supports an increasing number of composable applications built by numerous teams. Building xDapps on top of their protocol allows for quick cross-chain asset transfers and cross-chain logic to deliver maximal Web3 interoperability. Wormhole's architecture includes a signing Guardian network, bridging smart contracts, and relayers. Take a look at the tech stack diagram for more details.</p> <p></p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/interoperability/protocols/wormhole/#getting-started","title":"Getting Started","text":"<p>There are a couple of resources to get you started building cross-chain applications with Wormhole:</p> <ul> <li>Developer documentation - for technical guides</li> <li>Portal - a bridging UI used to transfer assets across chains</li> </ul>"},{"location":"builders/interoperability/protocols/wormhole/#contracts","title":"Contracts","text":"<p>See the list of Wormhole contracts deployed to Moonbeam, and the networks connected to Moonbeam through Wormhole.</p> <ul> <li>MainNet Contracts - Moonbeam</li> </ul>"},{"location":"builders/interoperability/protocols/wormhole/#setting-up-a-specialized-relayer-with-the-relayer-engine","title":"Setting up a Specialized Relayer With the Relayer Engine","text":"<p>In this section, you will deploy a basic Wormhole connected smart contract and spin up a specialized relayer to send messages across chains.</p> <p>First, some context. VAAs, or verifiable action approvals, are Wormhole\u2019s version of validated cross-chain messages. If 13 out of Wormhole's 19 signing Guardians validate a particular message, the message becomes approved and can be received on other chains. Adjacent to the guardian network (which act as the validators of Wormhole\u2019s protocol) are the network spies. They don\u2019t do any validation work. Instead, they watch the guardian network and act as an interface to allow users and applications to see what VAAs have been approved.</p> <p>The relayer\u2019s role is to pay for the destination chain\u2019s execution, and in many protocols, in turn a relayer is paid by the user. Wormhole does not have general relayers available yet, so Wormhole\u2019s architecture requires dApp developers to create and maintain their own specialized relayers (instead of having a relayer that can execute for many different smart contracts). A developer would have to design their own system if they wished to have the contract caller pay for gas on the destination chain. This might seem like a greater amount of work, but it allows for more fine-tuning of how messages are handled. For example, a relayer could send the same message to multiple chains at the same time, known as multicasting.</p>"},{"location":"builders/interoperability/protocols/wormhole/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>Docker installed</li> <li>Have an account be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>Have the same account be funded with native currency from a Wormhole connected EVM of your choice. Faucets are in the table below</li> </ul>"},{"location":"builders/interoperability/protocols/wormhole/#deploying-the-wormhole-contract-with-remix-on-moonbase-alpha","title":"Deploying the Wormhole Contract with Remix on Moonbase Alpha","text":"<p>To send a cross-chain message, in this guide, you will need to deploy and use a smart contract. Every chain connected to Wormhole will have some sort of implementation of the Wormhole core bridge, whose purpose is to publish and verify VAAs. Each implementation of the core bridge contract (one per chain) is watched by every guardian in the guardian network, which is how they know when to start validating a message.  </p> <p>Unlike other cross-chain protocols, Wormhole doesn\u2019t provide a parent smart contract to inherit from for users to build off of. This is because Wormhole\u2019s first chain, Solana, doesn\u2019t have typical inheritance in their smart contracts like Solidity provides. To keep the design experience similar on each chain, Wormhole has their Solidity developers interact directly with the Wormhole core bridge smart contract on EVM chains.  </p> <p>The smart contract that you will be deploying today is stored in a Git repository that is forked from Wormhole\u2019s relayer engine repository. It sends a string from one chain to another, and stores strings when received through Wormhole's protocol. To deploy the script, either copy and paste the contract into Remix or open up this Remix gist link.  </p> <p>First things first, the code in this smart contract is simplified in certain areas (like security). When writing a smart contract for production, review the Wormhole documentation for a better understanding of standards. To be clear, do not use the following smart contract in production.</p> <ol> <li>Go to the Solidity Compiler tab</li> <li>Press the Compile button</li> <li>Then, go to the Deploy &amp; Run Transactions tab of Remix</li> <li>Set the environment to Injected Web3. This will use MetaMask as the Web3 provider. Ensure that your MetaMask is connected to the Moonbase Alpha network</li> </ol> <p></p> <p>To deploy on each chain, you will need the local instance of the Wormhole core bridge and the chain ID of the chain mentioned. All of this data has been provided for a select few TestNets in the table below. You can find other networks\u2019 endpoints on Wormhole\u2019s supported networks documentation. Keep in mind that you should only use EVMs for this demonstration, since the smart contract and relayer designed for this demonstration only supports EVMs.</p> Network &amp; Faucet Core Bridge Address Wormhole Chain ID Polygon Mumbai 0x0CBE91CF822c73C2315FB05100C2F714765d5c20 5 Avalanche Fuji 0x7bbcE28e64B3F8b84d876Ab298393c38ad7aac4C 6 Fantom TestNet 0x1BB3B4119b7BA9dfad76B0545fb3F531383c3bB7 10 Sepolia 0x4a8bc80Ed5a4067f1CCf107057b8270E0cC11A78 10002 Moonbase Alpha 0xa5B7D85a8f27dd7907dc8FdC21FA5657D5E2F901 16 <ol> <li>Ensure that the contract chosen is SimpleGeneralMessage</li> <li>Open up the deploy menu with the arrow button</li> <li>Input the relevant chain ID in the _CHAINID input</li> <li>Input the relevant core bridge address in the WORMHOLE_CORE_BRIDGE_ADDRESS input</li> <li>Press the transact button to start a deployment transaction</li> <li>Press the Confirm button in MetaMask to deploy</li> </ol> <p>Once the contract has been deployed on Moonbase Alpha make sure to copy down its address and repeat the process with one of any of the other EVM TestNets that are connected to Wormhole so that you can send a message across chains. Remember that you will have to change your network in MetaMask to deploy to the right network.</p>"},{"location":"builders/interoperability/protocols/wormhole/#whitelisting-moonbase-alphas-connected-contract","title":"Whitelisting Moonbase Alpha\u2019s Connected Contract","text":"<p>At this point, you should have the same smart contracts deployed twice. One on Moonbase Alpha, and another on another EVM chain.  </p> <p>Wormhole recommends including a whitelisting system in their connected contracts, which you will have to use in <code>SimpleGeneralMessage</code> before attempting to send a cross-chain message.</p> <p>To add a whitelisted contract, you must invoke the <code>addTrustedAddress(bytes32 sender, uint16 _chainId)</code> function, which requires a bytes32 formatted address and a chain ID. You can find the chain ID in the table above and on Wormhole\u2019s documentation.</p> <pre><code>function addTrustedAddress(bytes32 sender, uint16 _chainId) external {\n    myTrustedContracts[sender][_chainId] = true;\n}\n</code></pre> <p>Note that the <code>sender</code> parameter is a <code>bytes32</code> type instead of an <code>address</code> type. Wormhole\u2019s VAAs provide emitter (origin) addresses in the form of <code>bytes32</code>, so they are stored and checked as <code>bytes32</code>. To convert an <code>address</code> type to <code>bytes32</code>, you will need to pad an additional 24 zeros. This is because an <code>address</code> value is 20 bytes, less than the 32 for <code>bytes32</code>. Every byte has 2 hexadecimal characters, so:</p> <pre><code>zeros to add = (32 bytes - 20 bytes) * 2 hexadecimal characters\nzeros to add = 24\n</code></pre> <p>For example, if your connected contract\u2019s address was <code>0xaf108eF646c8214c9DD9C13CBC5fadf964Bbe293</code>, you would input the following into Remix:</p> <pre><code>0x000000000000000000000000af108ef646c8214c9dd9c13cbc5fadf964bbe293\n</code></pre> <p>Now use Remix to ensure that your two connected contracts trust each other. You will have to do this on both contracts that you have deployed if you intend to send messages back and forth. To switch between contracts on different chains, connect to the destination network through MetaMask.</p> <ol> <li>Make sure that you are in the Injected Provider environment</li> <li>Ensure that you are on the right account</li> <li>Also check that the contract is still SimpleGeneralMessage</li> <li>Finally, take the address of the destination contract, and paste it into the At Address input</li> </ol> <p></p> <p>To add trusted remote addresses:</p> <ol> <li>Find the addTrustedAddress function within the deployed contract and open it</li> <li>When you are on Moonbase Alpha, set the sender as the properly formatted (padded with 24 zeros) address of the contract you deployed on the other EVM TestNet</li> <li>Set the _chainId as the Wormhole chain ID of the chain that the other contract is deployed on. Afterwards, transact and confirm in MetaMask</li> </ol> <p>When you are on the alternate EVM TestNet, set the sender as the properly formatted (padded with 24 zeros) address of the contract you deployed on Moonbase Alpha. Set the _chainId as Moonbase Alpha\u2019s Wormhole chain ID (16). Finally, transact and confirm in MetaMask.</p> <p></p> <p>In this section you should have sent two transactions on two chains to whitelist addresses in both contracts. Afterwards, you should be allowed to send messages between the connected contracts.</p>"},{"location":"builders/interoperability/protocols/wormhole/#running-wormhole-guardian-spy","title":"Running a Wormhole Guardian Network Spy","text":"<p>Now you will run a TestNet relayer for Wormhole! This walkthrough is based off of Wormhole\u2019s relayer-engine GitHub repository, which as of time of writing, is on commit <code>cc0aad4</code>. It\u2019s in relatively active development, which can cause great changes in the structure of the folders.</p> <p>Clone the fork of the relayer-engine that has been prepared specifically for interacting with <code>SimpleGeneralMessage</code>. Docker and npm are required to run this relayer, so be sure to install them to your device.  </p> <p>First things first: the setup. Use the npm package manager to install dependencies (like ethers and the relayer engine itself) using the command line.  </p> <pre><code>npm install\ncd plugins/simplegeneralmessage_plugin\nnpm install \n</code></pre> <p>Once that\u2019s finished, take a look around at the different folders. There are three folders: <code>src</code>, <code>relay-engine-config</code>, and <code>plugins</code>. The <code>src</code> folder contains the script that acts as the starting point for the entire application, so it includes setup. The <code>relay-engine-config</code> include JSON configuration files that are specific to the <code>SimpleGeneralMessage</code> smart contract. The <code>plugins</code> folder contains the plugin that has logic pertaining to relaying for the <code>SimpleGeneralMessage</code> smart contract.  </p> <p>Before going into detail about how to run anything or how any of the plugin scripts work, you need to understand the different components of the relayer and what the relayer does.</p> <p>The relayer filters and receives VAAs from the guardian network and does \"something\" with it. In this case, the relayer will filter messages approved by the Guardians that originate from your deployed connected contracts, then parse the VAA, then determine its destination, and finally attempt to execute a function called <code>processMyMessage(bytes32 VAA)</code> at the destination. It is important to understand that other relayers from other actors can receive this VAA and that other relayers can execute any VAA in any way they see fit.</p> <p>From a technical standpoint, the implementation of this relayer has four parts.</p> <ol> <li>A non-validating spy node that watches the Wormhole guardian network for all VAAs</li> <li>A component known as a listener, which receives the output of the spy node, filters out which ones are relevant to the relayer, and packages them into workflow objects</li> <li>A Redis database that stores the workflow objects that the listener outputs</li> <li>A component known as an executor, which pops workflows off the database and processes them in some way (in this case, sends a transaction on the destination chain)</li> </ol> <p>Starting from scratch, this can be a lot. Fortunately, Wormhole provides a <code>relayer-engine</code> package to help with the setup.</p> <p>It\u2019s best to tackle the configuration and setup of these four components in order, so start with the spy node. The spy node uses Docker, so ensure that Docker is active before attempting to start the node. The command to start the Docker container is long, so to simplify things, it has been added as an npm script to the repository's parent directory. Just run:</p> <pre><code>npm run testnet-spy\n</code></pre> <p>First, you should see a few logs from the startup of the Docker container. Then, a lot of logs should be spamming the console. These are all the VAAs that are going through the Wormhole TestNet, and there are a lot! Don\u2019t worry, you won\u2019t have to decipher any of these logs: the code can do that for you. Leave this running in the background and get another terminal instance to move on to the next step.</p> npm run testnet-spy @wormhole-foundation/example-relayer-project@0.0.1 testnet-spy docker run --platform=linux/amd64 -p 7073:7073 --entrypoint /guardiand ghcr.io/wormhole-foundation/guardiand:latest spy --nodeKey /node.key --spyRPC \"[::]:7073\" --network /wormhole/testnet/2/1 --bootstrap /dns4/t-guardian-01.testnet.xlabs.xyz/udp/8999/quic/p2p/12D3KooWCW3LGUtkCVkHZmVSZHzL3C4WRKWfqAiJPz1NR7dT9Bxh INFO  wormhole-spy    spy/spy.go:322  status server listening on [::]:6060 INFO  wormhole-spy    spy/spy.go:270  spy server listening    {\"addr\": \"[::]:7073\"} INFO  wormhole-spy    common/nodekey.go:16    No node key found, generating a new one...  {\"path\": \"/node.key\"} INFO  wormhole-spy.supervisor supervisor/supervisor_processor.go:41   supervisor processor started INFO  wormhole-spy    spy/spy.go:413  Started internal services INFO  wormhole-spy.root.p2p   p2p/p2p.go:276  Connecting to bootstrap peers   {\"bootstrap_peers\": \"/dns4/t-guardian-01.testnet.xlabs.xyz/udp/8999/quic-v1/p2p/12D3KooWCW3LGUtkCVkHZmVSZHzL3C4WRKWfqAiJPz1NR7dT9Bxh\"} INFO  wormhole-spy.root.p2p   p2p/p2p.go:345  Subscribing pubsub topic    {\"topic\": \"/wormhole/testnet/2/1/broadcast\"} INFO  dht/RtRefreshManager    rtrefresh/rt_refresh_manager.go:322 starting refreshing cpl 0 with key CIQAAAAEGIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA (routing table size was 0) INFO  wormhole-spy.root.p2p   p2p/p2p.go:387  Connected to bootstrap peers    {\"num\": 1} INFO  wormhole-spy.root.p2p   p2p/p2p.go:389  Node has been started   {\"peer_id\": \"12D3KooWJmUftCbuZH9rAF6Zzq9dhDhQ5yQrdwEVhiY8PXN3KtTG\", \"addrs\": \"[/ip4/127.0.0.1/udp/8999/quic-v1 /ip4/172.17.0.2/udp/8999/quic-v1 /ip6/::1/udp/8999/quic-v1]\"} 2024-08-01T23:03:51.193Z INFO    wormhole-spy    spy/spy.go:371  Received signed VAA {\"vaa\": \"AQAAAAABAICa9rr2B5VTAg6tcYu/5DCkzbKVC5xG2CT0EZ681BP0Mxmb9RwTvSENT7Cr1GZ8LRmXbW7W0kZVELN+hhAh5boAZqwUVgAAAAAAGuEB+u2sWFHjK5sjtflBGowrrEquPtTde4Ed0acupKpxAAAAAASqMYIBQVVXVgAAAAAACT4b8wAAJxCYq1BJcB42Joc35zEoMLG3u4ARJg==\"}"},{"location":"builders/interoperability/protocols/wormhole/#setting-up-the-listener-component","title":"Setting up the Listener Component","text":"<p>Now to break down the custom code and configurable component of the relayer. The listener component, aptly named, listens to the spy node for relevant messages. To define what the relevant messages are, you must edit a config file.</p> <p>In <code>plugins/simplegeneralmessage_plugin/config/devnet.json</code>, there exists an array named <code>spyServiceFilters</code>. Each object within this array whitelists a contract\u2019s VAAs as relevant to the relayer. The object contains a <code>chainId</code> (a Wormhole chain ID) and an <code>emitterAddress</code>. For example, in the image below, the first object will watch for VAAs sent by <code>0x428097dCddCB00Ab65e63AB9bc56Bb48d106ECBE</code> on Moonbase Alpha (Wormhole chain ID is 16).</p> <p>Be sure to edit the <code>spyServiceFilters</code> array so that the relayer listens to the two contracts that you deployed.</p> <pre><code>\"spyServiceFilters\": [\n    {\n        \"chainId\": 16,\n        \"emitterAddress\": \"0x428097dCddCB00Ab65e63AB9bc56Bb48d106ECBE\"\n    },\n    {\n        \"chainId\": 10,\n        \"emitterAddress\": \"0x5017Fd40aeA8Ab94693bE41b3bE4e90F45860bA4\"\n    }\n]\n</code></pre> <p>In the <code>simplegeneralmessage_plugin</code> folder, open up <code>src/plugin.ts</code>. This file contains plugin code for both the listener and executor components of the relayer, but the comments should make it obvious which functions are relevant to which component. Snippets of the file are shown below and you should be following along, but in case you aren\u2019t, the entire file can be accessed in its GitHub repository.</p> <p>Look at the <code>getFilters()</code> function below. Notice something familiar? The <code>spyServiceFilters</code> object is injected into the plugin class that <code>getFilters()</code> is part of. Note that no filtering is being done, this is only the preparation of the filters. The actual filtering of VAAs occurs within the <code>relayer-engine</code> package, which uses this <code>getFilters()</code> function to understand what to filter.</p> <p>If a developer wanted to add additional logic to the filters, they could here, but for your purposes, simply listing some hard-coded addresses is fine.</p> <pre><code> // How the relayer injects the VAA filters.\n // This is the default implementation provided by the dummy plugin.\n getFilters(): ContractFilter[] {\n   if (this.pluginConfig.spyServiceFilters) {\n     return this.pluginConfig.spyServiceFilters;\n   }\n   this.logger.error('Contract filters not specified in config');\n   throw new Error('Contract filters not specified in config');\n }\n</code></pre> <p>After filtering, the listener needs to write to the Redis database with workflow data in the <code>consumeEvent(vaa, stagingArea)</code> function below.</p> <p>A workflow is just data that the executor needs from the listener to do a proper execution with. In this case, the only information that is being added to the workflow is the time at which the VAA was received and the parsed data in the VAA itself. If a developer wanted to add more relevant information to the workflow, they could do so in the <code>workflowData</code> object.</p> <p>The <code>nextStagingArea</code> object is a way for consumed events (filtered VAAs) to affect each other. For example, if a developer wanted to package two VAAs together into one workflow, they wouldn\u2019t return a <code>workflowData</code> every time.  </p> <pre><code> // Receives VAAs and returns workflows.\n  async consumeEvent(\n    vaa: ParsedVaaWithBytes,\n    stagingArea: StagingAreaKeyLock,\n  ): Promise&lt;\n    | {\n      workflowData: WorkflowPayload;\n      workflowOptions?: WorkflowOptions;\n    }\n    | undefined\n  &gt; {\n    this.logger.debug(`VAA hash: ${vaa.hash.toString('base64')}`);\n\n    return {\n      workflowData: {\n        vaa: vaa.bytes.toString('base64'),\n      },\n    };\n  }\n</code></pre> <p>That\u2019s all that\u2019s necessary for the listener component. Fortunately, most of the code is hidden from the user within the <code>relayer-engine</code> package.</p> <p>If you recall the list of components, the third is the Redis database component. Most of the code that has to do with the database is hidden from the user, since the <code>relayer-engine</code> package will write &amp; read from it, then inject any relevant data back into the plugin code. To run the Redis database, simply run the following command in the parent directory:  </p> <pre><code>npm run redis\n</code></pre>"},{"location":"builders/interoperability/protocols/wormhole/#setting-up-the-executor-component","title":"Setting up the Executor Component","text":"<p>Finally, you must handle the executor component. Recall that the executor component takes workflow data from the Redis database and does some sort of execution action with that data. For most relayers, this execution will involve an on-chain transaction, since a relayer acts as a trustless oracle for VAAs.</p> <p>The <code>relayer-engine</code> package helps handle the wallets for the plugin. Currently, the package only supports Solana and EVM wallets, but with further development more chains will be supported. But it\u2019s not impossible to integrate NEAR or Algorand into the relayer, since you would just have to write your own wallet handling system in addition to the one already provided by the package.</p> <p>To work with the built-in wallet handling system provided by the package, open the file at <code>relayer-engine-config/executor.json.example</code>. This example script is provided to show you how to format your private keys (the current key is provided by Wormhole).</p> <p>Rename the example file to <code>executor.json</code>. In the <code>privateKeys</code> object of <code>executor.json</code>, replace the content of each array with your private key. The account of the private key entries will be the one that pays for execution fees in the relayer\u2019s executor component.</p> <p>Please manage your keys with care, as exposing them can result in loss of funds. While <code>executor.json</code> is ignored by git in this repository, please be sure that the wallet you are using for TestNet has no MainNet funds just to be safe.</p> <pre><code>{\n   \"privateKeys\": {\n       \"16\": [\n           \"0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d\"\n       ],\n       \"2\": [\n           \"0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d\"\n       ],\n       \"5\": [\n           \"0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d\"\n       ],\n       \"6\": [\n           \"0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d\"\n       ],\n       \"10\": [\n           \"0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d\"\n       ],\n\n   }\n}\n</code></pre> <p>Remove any entries from the <code>privateKeys</code> object if their key belongs to a chain that you are not using.  </p> <p>If you are using a chain that wasn\u2019t listed in the EVM TestNet table above, you will have to add your own array. The key for this array should be the Wormhole chain ID of the other EVM that you chose to deploy on before. For example, if you deployed on the Fantom TestNet, you would add the following object, since the Wormhole chain ID of the Fantom TestNet is <code>10</code>.</p> <pre><code>\"10\": [\n    \"INSERT_YOUR_PRIVATE_KEY\"\n]\n</code></pre> <p>Now that the wallets are sorted out for the executor, look at the code of the executor itself, which is in the <code>plugins/simplegeneralmessage_plugin/src/plugin.ts</code> file. If you haven\u2019t been following along, the entire file can be accessed in its GitHub repository.</p> <p>The <code>handleWorkflow(workflow, providers, execute)</code> function is where all of the logic is, though there are some helper functions underneath it. This is the function that the <code>relayer-engine</code> package invokes when there is a workflow in the Redis database that\u2019s to be used. Notice the three parameters that are injected into the function: <code>workflow</code>, <code>providers</code>, and <code>execute</code>.</p> <ul> <li>The <code>workflow</code> object provides the data that was stored in the database during the listener component\u2019s execution of the <code>consumeEvent(vaa, stagingArea)</code> function. In this case, only the VAA and time it was received was stored in the database, which are stored in the local <code>payload</code> variable</li> <li>The <code>providers</code> object injects Ethers and other chains\u2019 providers, which might be helpful for querying on-chain data or doing other blockchain related actions. As mentioned before, the only providers that are currently supported by the package are Solana and EVMs. The <code>providers</code> object isn\u2019t used in this implementation</li> <li>The <code>execute</code> object currently has two functions in it: <code>onEVM(options)</code> and <code>onSolana(options)</code>. These functions require a Wormhole chain ID and a callback function that has a wallet object injected into it. The wallet included is based off of the private key that was configured in the <code>executor.json</code> file</li> </ul> <p>The first substantial thing this function does is parse the workflow object, then parse its VAA with some helper functions. Afterwards, it takes the parsed VAA payload, converts it into a hexadecimal format, and uses the Ethers utility to ABI-decode the payload into its separate values that were defined way-back-when in the smart contract.</p> <p>With the data that was decoded by Ethers, it\u2019s possible to figure out to which contract and which chain the payload is being sent to, since that data was packaged into the message. The function checks if the specified destination chain ID belongs to an EVM, and will execute using the <code>execute.onEVM(options)</code> function mentioned before. Otherwise, it logs an error since this system doesn\u2019t expect to interact with non-EVM chains for simplicity.</p> <pre><code>// Consumes a workflow for execution\nasync handleWorkflow(\n  workflow: Workflow,\n  providers: Providers,\n  execute: ActionExecutor\n): Promise&lt;void&gt; {\n  this.logger.info(`Workflow ${workflow.id} received...`);\n\n  const { vaa } = this.parseWorkflowPayload(workflow);\n  const parsed = wh.parseVaa(vaa);\n  this.logger.info(`Parsed VAA. seq: ${parsed.sequence}`);\n\n  // Here we are parsing the payload so that we can send it to the right recipient\n  const hexPayload = parsed.payload.toString('hex');\n  let [recipient, destID, sender, message] =\n    ethers.utils.defaultAbiCoder.decode(\n      ['bytes32', 'uint16', 'bytes32', 'string'],\n      '0x' + hexPayload\n    );\n  recipient = this.formatAddress(recipient);\n  sender = this.formatAddress(sender);\n  const destChainID = destID as ChainId;\n  this.logger.info(\n    `VAA: ${sender} sent \"${message}\" to ${recipient} on chain ${destID}.`\n  );\n\n  // Execution logic\n  if (wh.isEVMChain(destChainID)) {\n    // This is where you do all of the EVM execution.\n    // Add your own private wallet for the executor to inject in \n    // relayer-engine-config/executor.json\n    await execute.onEVM({\n      chainId: destChainID,\n      f: async (wallet, chainId) =&gt; {\n        const contract = new ethers.Contract(recipient, abi, wallet.wallet);\n        const result = await contract.processMyMessage(vaa);\n        this.logger.info(result);\n      },\n    });\n  } else {\n    // The relayer plugin has a built-in Solana wallet handler, which you could use\n    // here. NEAR &amp; Algorand are supported by Wormhole, but they're not supported by\n    // the relayer plugin. If you want to interact with NEAR or Algorand you'd have\n    // to make your own wallet management system, that's all\n    this.logger.error(\n      'Requested chainID is not an EVM chain, which is currently unsupported.'\n    );\n  }\n};\n</code></pre> <p>In the callback function, it creates a contract object with the Ethers package. The ABI that it imports is exported from the <code>SimpleGeneralMessage</code> contract\u2019s compilation, so this code is assuming that the recipient of the message specified in the VAA is or inherits from a <code>SimpleGeneralMessage</code> contract.</p> <p>Then, the code attempts to execute the <code>processMyMessage(bytes32 VAA)</code> function with the VAA, which was previously defined as the function that messages are relayed to. Recall that this function name was arbitrarily chosen for the smart contract because the relayer could specify any function to call. That freedom is expressed in the ability for a developer to change this relayer\u2019s code!</p> <pre><code>await execute.onEVM({\n  chainId: destChainID,\n  f: async (wallet, chainId) =&gt; {\n    const contract = new ethers.Contract(recipient, abi, wallet.wallet);\n    const result = await contract.processMyMessage(vaa);\n    this.logger.info(result);\n  },\n});\n</code></pre> <p>The final piece is to check <code>relayer-engine-config/common.json</code>. This config file controls the execution of the entire relayer. Ensure that the TestNet EVMs that you are using are listed within the <code>supportedChains</code> object of this file. The plugin will not run properly if it\u2019s not listed. If a chain that you are using is not listed, you will have to import the data from Wormhole\u2019s developer documentation into the config file in a format like below.</p> <p>There are also additional configurations for the relayer. For example, the <code>mode</code> string is set to <code>\"BOTH\"</code> to ensure that both the listener and executor plugins are used, but a developer could decide to run only one if they wanted. Additionally, there are multiple log levels to specify, such as <code>\"error\"</code> for just error messages. For this demo, however, just leave the configuration settings as is.</p> <pre><code> \"mode\": \"BOTH\",\n \"logLevel\": \"debug\",\n ...\n    {\n        \"chainId\": 16,\n        \"chainName\": \"Moonbase Alpha\",\n        \"nodeUrl\": \"https://rpc.api.moonbase.moonbeam.network\",\n        \"bridgeAddress\": \"0xa5B7D85a8f27dd7907dc8FdC21FA5657D5E2F901\",\n        \"tokenBridgeAddress\": \"0xbc976D4b9D57E57c3cA52e1Fd136C45FF7955A96\"\n    },\n</code></pre> <p>That\u2019s it for the configuration! Now to run it. In your terminal instance (one that isn\u2019t running the spy node), navigate to the parent folder. Run the following command:</p> <pre><code>npm run start\n</code></pre> <p>You should see something similar to the logs below in the console.</p> warn | GlobalStorage: You are starting a relayer without a namespace, which could cause issues if you run multiple relayers using the same Redis instance info | main: Running as both executor and listener debug | executorHarness: Finished gathering worker infos. info | Fantom Testnet-0-worker: Spawned info | Moonbase Alpha-0-worker: Spawned info | listenerHarness: Initializing spy listener... info | spyEventSource: Initializing spy listener for plugin SimpleGeneralMessagePlugin... debug | missedVaaFetching: Grouping emitter keys from plugins... debug | listenerHarness: End of listener harness run function warn | koa deprecated Support for generators will be removed in v3. See the documentation for examples of how to convert old middleware https://github.com/koajs/koa/blob/master/docs/migration.md node_modules/relayer-engine/relayer-engine/lib/index.js:138:9 info | spyEventSource: SimpleGeneralMessagePlugin subscribing to spy with raw filters: [{\"chainId\":2,\"emitterAddress\":\"0xfB7327Fe26aD52b693E38232E5D97F4892623075\"},{\"chainId\":5,\"emitterAddress\":\"0xfB7327Fe26aD52b693E38232E5D97F4892623075\"},{\"chainId\":6,\"emitterAddress\":\"0xfB7327Fe26aD52b693E38232E5D97F4892623075\"},{\"chainId\":16,\"emitterAddress\":\"0x428097dCddCB00Ab65e63AB9bc56Bb48d106ECBE\"},{\"chainId\":10,\"emitterAddress\":\"0x5017Fd40aeA8Ab94693bE41b3bE4e90F45860bA4\"}] debug | spyEventSource: SimpleGeneralMessagePlugin using transformed filters: [{\"emitterFilter\":{\"chainId\":2,\"emitterAddress\":\"000000000000000000000000fb7327fe26ad52b693e38232e5d97f4892623075\"}},{\"emitterFilter\":{\"chainId\":5,\"emitterAddress\":\"000000000000000000000000fb7327fe26ad52b693e38232e5d97f4892623075\"}},{\"emitterFilter\":{\"chainId\":6,\"emitterAddress\":\"000000000000000000000000fb7327fe26ad52b693e38232e5d97f4892623075\"}},{\"emitterFilter\":{\"chainId\":16,\"emitterAddress\":\"000000000000000000000000428097dcddcb00ab65e63ab9bc56bb48d106ecbe\"}},{\"emitterFilter\":{\"chainId\":10,\"emitterAddress\":\"0000000000000000000000005017fd40aea8ab94693be41b3be4e90f45860ba4\"}}] debug | missedVaaFetching: Starting nextVaaFetchingWorker... debug | missedVaaFetching: Pessimistically fetching next vaa for all emitters registered by plugins info | spyEventSource: connected to spy service, listening for transfer signed VAAs info | MetricsServer: Prometheus metrics running on port 3001 info | ApiServer: Api running on port 3000 debug | missedVaaFetching: nextVaaFetchingWorker loop completed, sleeping 300000000 ms..."},{"location":"builders/interoperability/protocols/wormhole/#send-message-from-moonbase","title":"Sending a Cross-Chain Message from Moonbase with Wormhole","text":"<p>Now, to send a cross-chain message, you just need to call the <code>sendMessage(string memory message, address destAddress, uint16 destChainId)</code> function.</p> <p>Use the Remix interface. This example is going to send a cross-chain message to the Fantom TestNet, but you can substitute the <code>destChainId</code> for whichever EVM you desire. Check the following things:</p> <ol> <li>The environment is Injected Provider on network 1287 (Moonbase Alpha)</li> <li>You have substantial funds in your wallet from the faucet to cover the transaction gas cost on both the origin and destination chains</li> <li>Put a short message of your choice in the message input of the sendMessage section (in this case, \"this is a message\")</li> <li>Put the address of your instance of SimpleGeneralMessage on destination chain in the destAddress input</li> <li>Put the destination chain\u2019s Wormhole chain ID in the destChainId input of the sendMessage section</li> <li>Once this is all done, transact the execution and confirm it in MetaMask</li> </ol> <p></p> <p>After a few seconds to a minute, cross-chain messages should be properly relayed through the relayer that you are hosting on your local machine.  </p> debug | spyEventSource: 7iWtnE4whSBtCxmUA87FUQkCLhy92gHW/qIg6/vTMNM= debug | spyEventSource: 10 info | missedVaafetching: Fetching missed vas for 10: 0000000000000000000000001fd6d0beaf150526a6e48dbde8484a73a280a45, from 1 to 2 debug | SimpleGeneralMessagePlugin: VAA hash: 7iWtnE4whSBtCmUA87FUQkCLhy92gHW/qIg6/VTMNM= info | leventHarness: Received workflow data from plugin SimpleGeneralMessagePlugin, adding workflow. debug | GlobalStorage: Updating emitter record last seen sequence. debug | GlobalStorage: Found emitterRecord debug | executorHarness: New workflow found info | executorHarness: Starting workflow. info | SimpleGeneralMessagePlugin: Workflow 10/0000000000000000000000001d6d0beaf150526a648dbde8484a73a280a45/2/ee25 a received. info | SimpleGeneralMessagePlugin: Parsed VAA. seq: 2 info | SimpleGeneralMessagePlugin: VAA: 0x0394c0edf cca370b20622721985b577850b@eb75 sent \"this is a message\" to exa8add 09e4fcf1b5edc588c54bee137cb35e61f5b on chain 16. debug | GlobalStorage: Updated emitter record. Key SimpleGeneralMessagePlugin:10:0000000000000000000000001d6d0beaf150 52f6a648dbde8484a73a280a45, {\"lastSeenSequence\":2,\"time\":\"2023-03-14T21:38:11.780Z\"} info | Moonbase Alpha-0-worker: Relaying action for plugin SimpleGeneralMessagePlugin, debug | executorHarness: No new workflows found. info | SimpleGeneralMessagePlugin: [object Object] info | Moonbase Alpha-0-worker: Action SimpleGeneralMessagePlugin completed info | executorHarness: Finished executing workflow."},{"location":"builders/interoperability/protocols/wormhole/#moonbeam-routed-liquidity-integration","title":"Moonbeam Routed Liquidity Integration","text":"<p>Wormhole will provide liquidity to parachains through the Moonbeam Routed Liquidity (MRL) program. This program allows one-click transfers of liquidity from Wormhole connected chains into parachain wallets by sending liquidity through Moonbeam networks. MRL utilizes the GMP Precompile, whose documentation explains how cross-chain messages should be constructed to properly use the precompile.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/interoperability/xcm/overview/","title":"Cross-Consensus Messaging (XCM)","text":""},{"location":"builders/interoperability/xcm/overview/#introduction","title":"Introduction","text":"<p>Polkadot's architecture allows parachains to natively interoperate with each other, enabling cross-blockchain transfers of any type of data or asset.</p> <p>To do so, a Cross-Consensus Message (XCM) format defines a language around how the message transfer between two interoperating blockchains should be performed. XCM is not specific to Polkadot, as it aims to be a generic and extensible language between different consensus systems.</p> <p>This page is a brief introduction and overview of XCM and other related elements. More information can be found in Polkadot's Wiki.</p> <p>If you want to jump to more XCM-related content, feel free to check out the following pages:</p> <ul> <li>Core XCM Concepts - learn topics related to XCM Instructions, Multilocations, and XCM Fees</li> <li>XC Registration - go through the process of Opening an XCM Channel with Moonbeam and how to Register Polkadot Native Assets as XC-20s</li> <li>XC-20s - read an Overview of this Moonbeam-only asset class and learn how to Interact with XC-20s and how to Send them via XCM</li> <li>Remote Execution via XCM - grasp all concepts related to remote execution via XCM, starting with a High-Level Overview, then Computed Origins and wrapping up with Remote Calls via XCM and Remote EVM Calls via XCM</li> <li>XCM SDK - learn how to Use Moonbeam's XCM SDK</li> <li>XCM Debugging and Tools - learn how to test some XCM scenarios by  Sending and Executing Generic XCM Messages, or how to use the XCM Utilities Precompile to access XCM_related utility functions directly within the EVM</li> </ul>"},{"location":"builders/interoperability/xcm/overview/#general-xcm-definitions","title":"General XCM Definitions","text":"<ul> <li>XCM \u2014 stands for Cross-Consensus Message. It is a general way for consensus systems to communicate with each other</li> <li>VMP \u2014 stands for Vertical Message Passing, one of the transport methods for XCMs. It allows parachains to exchange messages with the relay chain. UMP (Upward Message Passing) enables parachains to send messages to their relay chain, while DMP (Downward Message Passing) enables the relay chain to pass messages down to one of their parachains</li> <li>XCMP \u2014 stands for Cross-Consensus Message Passing, one of the transport methods for XCMs. It allows parachains to exchange messages with other parachains on the same relay chain</li> <li> <p>HRMP \u2014 stands for Horizontal Relay-routed Message Passing, a stop-gap protocol while a full XCMP implementation is launched. It has the same interface as XCMP, but messages are stored on the relay chain</p> </li> <li> <p>Sovereign account \u2014  an account each chain in the ecosystem has, one for the relay chain and the other for other parachains. It is calculated as the <code>blake2</code> hash of a specific word and parachain ID concatenated (<code>blake2(para+ParachainID)</code> for the Sovereign account in the relay chain, and <code>blake2(sibl+ParachainID)</code> for the Sovereign account in other parachains), truncating the hash to the correct length. The account is owned by root and can only be used through SUDO (if available) or governance (referenda). The Sovereign account typically signs XCM messages in other chains in the ecosystem</p> </li> <li> <p>Multilocation \u2014  a way to specify a point in the entire relay chain/parachain ecosystem relative to a given origin. For example, it can be used to specify a specific parachain, asset, account, or even a pallet inside a parachain. In general terms, a multilocation is defined with a <code>parents</code> and an <code>interior</code>:</p> <ul> <li><code>parents</code> - refers to how many \"hops\" into a parent blockchain you need to take from a given origin</li> <li><code>interior</code> - refers to how many fields you need to define the target point. </li> </ul> <p>For example, to target a parachain with ID <code>1000</code> from another parachain, the multilocation would be <code>{ \"parents\": 1, \"interior\": { \"X1\": [{ \"Parachain\": 1000 }]}}</code></p> </li> </ul>"},{"location":"builders/interoperability/xcm/overview/#xcm-transport-protocols","title":"Cross-Chain Transport Protocols via XCM","text":"<p>XCM implements two cross-consensus or transport protocols for acting on XCM messages between its constituent parachains, Moonbeam being one of them:</p> <ul> <li> <p>Vertical Message Passing (VMP) \u2014 once a project is onboarded as a parachain, it automatically has a bi-directional communication channel with the relay chain. Therefore, there is no need for chain registration. VMP is divided into two kinds of message-passing transport protocols:</p> <ul> <li>Upward Message Passing (UMP) \u2014 allows parachains to send messages to their relay chain, for example, from Moonbeam to Polkadot</li> <li>Downward Message Passing (DMP) \u2014 allows the relay chain to pass messages down to one of their parachains, for example, from Polkadot to Moonbeam</li> </ul> </li> <li> <p>Cross-Chain Message Passing (XCMP) \u2014 allows two parachains to exchange messages as long as they are connected to the same relay chain. Cross-chain transactions are resolved using a simple queuing mechanism based on a Merkle tree to ensure fidelity. Collators exchange messages between parachains, while the relay chain validators will verify that the message transmission happened</p> </li> </ul> <p>Note</p> <p>Currently, while XCMP is being developed, a stop-gap protocol is implemented called Horizontal Relay-routed Message Passing (HRMP), in which the messages are stored in and read from the relay chain. This will be deprecated in the future for the full XCMP implementation.</p> <p></p>"},{"location":"builders/interoperability/xcm/overview/#channel-registration","title":"Establishing Cross-Chain Communication","text":"<p>Before two chains can start communicating, a messaging channel must be opened. Channels are unidirectional, meaning that a channel from chain A to chain B will only pass messages from A to B. Therefore, two channels must be opened to send messages back and forth.</p> <p>A channel for XCMs between the relay chain and parachain is automatically opened when a connection is established. However, when parachain A wants to open a communication channel with parachain B, parachain A must send an open channel extrinsic to its network. This extrinsic is an XCM as well!</p> <p>Even though parachain A has expressed its intentions of opening an XCM channel with parachain B, the latter has not signaled to the relay chain its intentions to receive messages from parachain A. Therefore, to have an established channel, parachain B must send an extrinsic (an XCM) to the relay chain. The accepting channel extrinsic is similar to the previous one. However, the encoded call data only includes the new method (accept channel) and the parachain ID of the sender (parachain A in this example). Once both parachains have agreed, the channel is opened within the following epoch.</p> <p>To learn more about the channel registration process, please refer to the How to Establish an XC Integration with Moonbeam guide.</p> <p></p> <p>Once the channel is established, cross-chain messages can be sent between parachains. For asset transfers, assets need to be registered before being transferred through XCMs, either by being baked into the runtime as a constant or through a pallet. Moonbeam relies on a Substrate pallet to handle asset registration without the need for runtime upgrades, making the process a lot simpler.</p> <p>To learn how to register an asset on Moonbeam and the information necessary to add Moonbeam assets to another chain, please refer to the How to Register Cross-Chain Assets guide.</p>"},{"location":"builders/interoperability/xcm/overview/#moonbeam-and-xcm","title":"XCM on Moonbeam","text":"<p>As Moonbeam is a parachain within the Polkadot ecosystems, one of the most direct implementations of XCM is to enable asset transfer from Polkadot and other parachains from/to Moonbeam. This allows users to bring their tokens to Moonbeam and all its dApps.</p> <p>To this end, Moonbeam has introduced XC-20s, which expand on Moonbeam's unique Ethereum compatibility features. XC-20s allow Polkadot native assets to be represented via a standard ERC-20 interface through a precompiled contract. When these assets are registered on Moonbeam, they can be set as XCM execution fee assets. Consequently, when a user transfers such an asset to Moonbeam, a small part of the amount will be used to cover the XCM execution fees.</p> <p>In addition, ERC-20s that are deployed to Moonbeam can be sent to other chains in the Polkadot ecosystem via XCM. Consequently, from a developer's perspective, XC-20s are ERC-20 tokens with the added benefit of being an XCM cross-chain asset, and dApps can easily support them through a familiar ERC-20 interface.</p> <p></p> <p>To send XC-20s across the Polkadot ecosystem from Moonbeam, developers need to use the Polkadot XCM Pallet for transfers via the Substrate API and the X-Tokens Precompile or the XCM Precompile for transfers via the Ethereum API.</p> <p>Another unique feature of Moonbeam is the ability to initiate XCM actions from EVM smart contracts or to call its EVM through XCM messages via remote execution. This unlocks a new set of possibilities, where contracts on Moonbeam can access parachain-specific functionalities via XCM, or other parachain ecosystems can use EVM smart contracts on Moonbeam to expand their functions.</p> <p>The following sections provide a high-level overview of the main use cases mentioned before.</p>"},{"location":"builders/interoperability/xcm/overview/#transfers-moonbeam-polkadot","title":"XCM Transfers between Moonbeam &amp; Polkadot","text":"<p>As Moonbeam is a parachain within the Polkadot ecosystem, a straightforward implementation of XCM + VMP is DOT transfers from/to Polkadot/Moonbeam. To this end, DOT was registered as xcDOT on Moonbeam.</p> <p>Alice (Polkadot) wants to transfer a certain amount of DOT from Polkadot to her account on Moonbeam, named Alith. Therefore, she initiates an XCM that expresses her intentions. For such transfers, Moonbeam owns a Sovereign account on Polkadot.</p> <p>Consequently, the XCM message execution on Polkadot will transfer the amount of DOT to Moonbeam's Sovereign account on Polkadot. Once the assets are deposited, the second part of the message is sent to Moonbeam.</p> <p>Moonbeam will locally execute the action the XCM message is programmed to do. In this case, it is to mint and transfer the same amount of xcDOT to the account defined by Alice, which in this case is Alith. The fee to execute the XCM in the target parachain is paid in the asset being transferred (xcDOT for this example).</p> <p></p> <p>Note the following:</p> <ul> <li>The Alice and Alith accounts can be different. For example, Polkadot's accounts are SR25519 (or ED25519), while Moonbeam's are ECDSA (Ethereum-styled) accounts. They can also have different owners</li> <li>There is a certain degree of trust where one chain relies on the other to execute its part of the XCM message. This is programmed at a runtime level so that it can be easily verified</li> <li>For this example, xcDOT is a wrapped representation of the original DOT being held in Moonbeam's Sovereign account on Polkadot. xcDOT can be transferred within Moonbeam at any time, and they can be redeemed for DOT on a 1:1 basis as well (minus some fees)</li> </ul> <p>Alith deposited her xcDOT in a liquidity pool. Next, Charleth acquires some xcDOT by swapping against that liquidity pool, and he wants to transfer some xcDOT to Charley's Polkadot account. Therefore, he initiates an XCM that expresses his intentions.</p> <p>Consequently, the XCM message execution on Moonbeam will burn the number of xcDOT. Once the assets are burned, the second part of the message is sent to Polkadot.</p> <p>Polkadot will execute the action the XCM message is programmed to do locally. In this case, it is to transfer the same amount of xcDOT burned from the Moonbeam Sovereign account to the account defined by Charleth, which in this case is Charley.</p> <p></p>"},{"location":"builders/interoperability/xcm/overview/#transfers-moonbeam-other-parachains","title":"XCM Transfers between Moonbeam &amp; Other Parachains","text":"<p>Since Moonbeam is a parachain within the Polkadot ecosystem, a straightforward implementation of XCM and XCMP asset transfers from and to Moonbeam and other parachains. This section gives a high-level overview of the main differences compared to XCMs from Polkadot/Moonbeam.</p> <p>The first requirement is that a bidirectional channel between the parachains must exist, and the asset being transferred must be registered in the target parachain. Only when both conditions are met can XCMs be sent between parachains.</p> <p>Then, when Alith (Moonbeam) transfers a certain amount of GLMR from Moonbeam to another account (Alice) in a target parachain, tokens are sent to a Sovereign Account owned by that target parachain on Moonbeam.</p> <p>As the XCM message is executed in the target parachain, it is expected that this will mint and transfer the same amount of xcGLMR (cross-chain GLMR) to the account defined by Alith, which in this case is Alice. The fee to execute the XCM in the target parachain is paid in the transferred asset (xcGLMR for this example).</p> <p></p> <p>As explained in the previous section, the process is similar for xcGLMR to move back to Moonbeam. First, the XCM message execution burns the number of xcGLMR returned to Moonbeam. Once burned, the remnant part of the message is sent to Moonbeam via the relay chain. Moonbeam will locally execute the XCM message's and transfer GLMR (the same amount of burned xcGLMR) from the target parachain Sovereign account to the specified address.</p>"},{"location":"builders/interoperability/xcm/overview/#execution-chains-moonbeam","title":"Remote Execution between Other Chains &amp; Moonbeam","text":"<p>As mentioned before, XCM also enables remote execution from/to Moonbeam to other chains in the Polkadot ecosystem.</p> <p>Similarly to the other use cases, it is necessary for XCM-specific channels to be established before remote execution can happen between the chains. Channels are general-purpose, so they can be used for both asset transfers and remote execution.</p> <p>Another important component is the asset for which the remote execution fees are paid. On Moonbeam, when an XC-20 is registered, it can be set as an XCM execution fee asset. Consequently, when transferring that XC-20 to Moonbeam, the XCM execution fee is deducted from the amount being transferred. For remote execution, users can include a small amount of tokens in the XCM message to cover XCM execution fees.</p> <p>Alice (Polkadot) wants to perform a certain remote action through a smart contract on Moonbeam. Therefore, she initiates an XCM that expresses her intentions; she must have previously funded the XCM execution account she owns on Moonbeam with either GLMR or xcDOT.</p> <p>Moonbeam will locally execute the action the XCM message is programmed to do. In this case, it is to withdraw the asset decided by Alice for the XCM execution fee and buy some execution time on Moonbeam to execute the smart contract call on Moonbeam's EVM.</p> <p>You can read more about the flow in detail on the Remote Execution page.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/","title":"Send, Execute, and Test XCM Messages","text":""},{"location":"builders/interoperability/xcm/send-execute-xcm/#introduction","title":"Introduction","text":"<p>XCM messages are comprised of a series of instructions that are executed by the Cross-Consensus Virtual Machine (XCVM). Combinations of these instructions result in predetermined actions, such as cross-chain token transfers. You can create your own custom XCM messages by combining various XCM instructions.</p> <p>Pallets such as Polkadot XCM and XCM Transactor provide functions with a predefined set of XCM instructions to either send XC-20s or remotely execute on other chains via XCM. However, to get a better understanding of the results from combining different XCM instructions, you can build and execute custom XCM messages locally on Moonbeam (only available on Moonbase Alpha). You can also send custom XCM messages to another chain (which will start with the <code>DescendOrigin</code> instruction). Nevertheless, for the XCM message to be successfully executed, the target chain needs to be able to understand the instructions.</p> <p>To execute or send a custom XCM message, you can either use the Polkadot XCM Pallet directly or through the Ethereum API with the XCM Utilities Precompile. In this guide, you'll learn how to use both methods to execute and send custom-built XCM messages locally on Moonbase Alpha.</p> <p>This guide assumes that you are familiar with general XCM concepts, such as general XCM terminology and XCM instructions. For more information, you can check out the XCM Overview documentation.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#polkadot-xcm-pallet-interface","title":"Polkadot XCM Pallet Interface","text":""},{"location":"builders/interoperability/xcm/send-execute-xcm/#extrinsics","title":"Extrinsics","text":"<p>The Polkadot XCM Pallet includes the following relevant extrinsics (functions):</p> execute(message, maxWeight) \u2014 supported on Moonbase Alpha only - executes a custom XCM message on the source chain ParametersPolkadot.js API Example <ul> <li><code>message</code> - the SCALE-encoded versioned XCM message to be executed</li> <li><code>maxWeight</code> - the maximum weight allowed to be consumed, which is defined by specifying the:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst message = { V4: [INSERT_XCM_INSTRUCTIONS] };\nconst maxWeight = { refTime: INSERT_REF_TIME, proofSize: INSERT_PROOF_SIZE };\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.polkadotXcm.execute(message, maxWeight);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\n\nmain();\n</code></pre> send(dest, message) \u2014 supported on Moonbase Alpha only - sends a custom XCM message to a destination chain. For the XCM message to be successfully executed, the target chain needs to be able to understand the instructions in the message ParametersPolkadot.js API Example <ul> <li><code>dest</code> - the XCM versioned multilocation representing a chain in the ecosystem where the XCM message is being sent to (the target chain)</li> <li><code>message</code> - the SCALE-encoded versioned XCM message to be executed</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst dest = { V4: { parents: INSERT_PARENTS, interior: INSERT_INTERIOR } };\nconst message = { V4: [INSERT_XCM_INSTRUCTIONS] };\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.polkadotXcm.send(dest, message);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#storage-methods","title":"Storage Methods","text":"<p>The Polkadot XCM Pallet includes the following relevant read-only storage methods:</p> assetTraps(hash) \u2014 returns the existing number of times an asset has been trapped given a hash of the asset ParametersReturnsPolkadot.js API Example <p><code>hash</code> - (optional) the Blake2-256 hash of the <code>Asset</code></p> <p>The number of times an asset has been trapped. If the hash was omitted, it returns an array of all of the hashes and the number of times each asset has been trapped.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the value\n// If hash was provided:\n10\n\n// If hash was omitted:\n[\n  [\n    0xf7d4341888be30c6a842a77c52617423e8109aa249e88779019cf731ed772fb7\n  ],\n  10\n],\n...\n</code></pre> <pre><code>\n</code></pre> palletVersion() \u2014 returns current pallet version from storage ParametersReturnsPolkadot.js API Example <p>None</p> <p>A number representing the current version of the pallet.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n0\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const palletVersion = await api.query.polkadotXcm.palletVersion();\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this guide, you will need the following:</p> <ul> <li>Your account must be funded with DEV tokens.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#execute-an-xcm-message-locally","title":"Execute an XCM Message Locally","text":"<p>This section of the guide covers the process of building a custom XCM message to be executed locally (i.e., in Moonbeam) via two different methods: the <code>execute</code> function of the Polkadot XCM Pallet and the <code>xcmExecute</code> function of the XCM Utilities Precompile. This functionality provides a playground for you to experiment with different XCM instructions and see firsthand the results of these experiments. This also comes in handy to determine the fees associated with a given XCM message on Moonbeam.</p> <p>In the following example, you'll transfer DEV tokens from one account to another on Moonbase Alpha. To do so, you'll be building an XCM message that contains the following XCM instructions, which are executed locally (in this case, on Moonbase Alpha):</p> <ul> <li><code>WithdrawAsset</code> - removes assets and places them into the holding register</li> <li><code>DepositAsset</code> - removes the assets from the holding register and deposits the equivalent assets to a beneficiary account</li> </ul> <p>Note</p> <p>Typically, when you send an XCM message cross-chain to a target chain, the <code>BuyExecution</code> instruction is needed to pay for remote execution. However, for local execution, this instruction is not necessary as you are already getting charged via the extrinsic call.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#execute-an-xcm-message-with-polkadotjs-api","title":"Execute an XCM Message with the Polkadot.js API","text":"<p>In this example, you'll execute a custom XCM message locally on Moonbase Alpha using the Polkadot.js API to interact directly with the Polkadot XCM Pallet.</p> <p>The <code>execute</code> function of the Polkadot XCM Pallet accepts two parameters: <code>message</code> and <code>maxWeight</code>. You can start assembling these parameters by taking the following steps:</p> <ol> <li> <p>Build the <code>WithdrawAsset</code> instruction, which will require you to define:</p> <ul> <li>The multilocation of the DEV token on Moonbase Alpha</li> <li>The amount of DEV tokens to transfer</li> </ul> <pre><code>const instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 100000000000000000n }, // 0.1 DEV\n    },\n  ],\n};\n</code></pre> </li> <li> <p>Build the <code>DepositAsset</code> instruction, which will require you to define:</p> <ul> <li>The asset identifier for DEV tokens. You can use the <code>WildAsset</code> format, which allows for wildcard matching, to identify the asset</li> <li>The multilocation of the beneficiary account on Moonbase Alpha</li> </ul> <pre><code>const instr2 = {\n  DepositAsset: {\n    assets: {\n      Wild: {\n        AllCounted: 1,\n      },\n    },\n    beneficiary: {\n      parents: 0,\n      interior: {\n        X1: [\n          {\n            AccountKey20: {\n              key: '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0',\n            },\n          },\n        ],\n      },\n    },\n  },\n};\n</code></pre> </li> <li> <p>Combine the XCM instructions into a versioned XCM message:</p> <pre><code>const message = { V4: [instr1, instr2] };\n</code></pre> </li> <li> <p>Specify the <code>maxWeight</code>, which includes a value for <code>refTime</code> and <code>proofSize</code> that you will need to define. You can get both of these values by providing the XCM message as a parameter to the <code>queryXcmWeight</code> method of the <code>xcmPaymentApi</code> runtime call. </p> <pre><code>const maxWeight = { refTime: 7250000000n, proofSize: 19374n };\n</code></pre> </li> </ol> <p>Now that you have the values for each of the parameters, you can write the script for the execution. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The Moonbase Alpha endpoint URL to create the provider</li> <li>The values for each of the parameters of the <code>execute</code> function</li> </ul> </li> <li>Create a Keyring instance that will be used to send the transaction</li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>polkadotXcm.execute</code> extrinsic with the <code>message</code> and <code>maxWeight</code></li> <li>Send the transaction using the <code>signAndSend</code> extrinsic and the Keyring instance you created in the second step</li> </ol> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a JavaScript file.</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\n// 1. Provide input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 100000000000000000n }, // 0.1 DEV\n    },\n  ],\n};\nconst instr2 = {\n  DepositAsset: {\n    assets: {\n      Wild: {\n        AllCounted: 1,\n      },\n    },\n    beneficiary: {\n      parents: 0,\n      interior: {\n        X1: [\n          {\n            AccountKey20: {\n              key: '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0',\n            },\n          },\n        ],\n      },\n    },\n  },\n};\nconst message = { V4: [instr1, instr2] };\nconst maxWeight = { refTime: 7250000000n, proofSize: 19374n };\n\nconst executeXcmMessage = async () =&gt; {\n  // 2. Create Keyring instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'ethereum' });\n  const alice = keyring.addFromUri(privateKey);\n\n  // 3. Create Substrate API provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 4. Craft the extrinsic\n  const tx = api.tx.polkadotXcm.execute(message, maxWeight);\n\n  // 5. Send the transaction\n  const txHash = await tx.signAndSend(alice);\n  console.log(`Submitted with hash ${txHash}`);\n\n  api.disconnect();\n};\n\nexecuteXcmMessage();\n</code></pre> <p>Note</p> <p>You can view an example of the above script, which sends 1 DEV to Bob's account on Moonbase Alpha, on Polkadot.js Apps using the following encoded calldata: <code>0x1c030408000400010403001300008a5d784563010d010204000103003cd0a705a2dc65e5b1e1205896baa2be8a07c6e007803822b001ba2e0100</code>.</p> <p>Once the transaction is processed, the 0.1 DEV tokens should be withdrawn from Alice's account along with the associated XCM fees, and the destination account should have received 0.1 DEV tokens in their account. A <code>polkadotXcm.Attempted</code> event will be emitted with the outcome.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#test-an-xcm-message-with-the-dry-run-api","title":"Test an XCM Message with the Dry Run API","text":"<p>The XCM Dry Run API is an easy and convenient way to test the integrity of your XCM message without incurring any transaction fees. The XCM Dry Run API can be accessed from the Runtime Calls tab of the Developer section of Polkadot.js Apps.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#dry-run-call-api-method","title":"Dry Run Call API Method","text":"<p>This method takes as a parameter the origin and the call data and returns an execution result, actual weight, and event data.  </p> <pre><code>const testAccount = api.createType(\n  'AccountId20',\n  '0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798'\n);\nconst callData =\n  '0x1c030408000400010403001300008a5d784563010d010204000103003cd0a705a2dc65e5b1e1205896baa2be8a07c6e007803822b001ba2e0100';\nconst callDataU8a = hexToU8a(callData);\n\nconst result = await api.call.dryRunApi.dryRunCall(\n  { system: { Signed: testAccount } },\n  callDataU8a\n);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { hexToU8a } from '@polkadot/util';\n\nconst main = async () =&gt; {\n  try {\n    // Construct API provider\n    const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n    const api = await ApiPromise.create({ provider: wsProvider });\n\n    console.log('Connected to the API. Preparing dry run call...');\n\n    // Create a test account (you should replace this with an actual account)\n    const testAccount = api.createType(\n      'AccountId20',\n      '0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798'\n    );\n\n    // The call data (replace with your actual call data)\n    const callData =\n      '0x1c030408000400010403001300008a5d784563010d010204000103003cd0a705a2dc65e5b1e1205896baa2be8a07c6e007803822b001ba2e0100'; // Your hex-encoded call data\n\n    // Convert hex to Uint8Array\n    const callDataU8a = hexToU8a(callData);\n\n    // Perform the dry run call\n    const result = await api.call.dryRunApi.dryRunCall(\n      { system: { Signed: testAccount } }, // origin\n      callDataU8a // call\n    );\n\n    console.log(\n      'Dry run XCM result:',\n      JSON.stringify(result.toJSON(), null, 2)\n    );\n\n    // Disconnect the API\n    await api.disconnect();\n    console.log('Disconnected from the API.');\n  } catch (error) {\n    console.error('An error occurred:', error);\n  }\n};\n\nmain().catch(console.error);\n</code></pre> <p>Upon calling the XCM Dry Run API, the method will tell you whether the call would be successful and returns the event data that would be emitted if the call were actually submitted on chain. You can view the initial output of the <code>dryRunCall</code> below.</p> View the complete output <pre><code>Dry run XCM result: {\n  \"ok\": {\n    \"executionResult\": {\n      \"ok\": {\n        \"actualWeight\": {\n          \"refTime\": 7301615000,\n          \"proofSize\": 20928\n        },\n        \"paysFee\": \"Yes\"\n      }\n    },\n    \"emittedEvents\": [\n      {\n        \"index\": \"0x030b\",\n        \"data\": [\n          \"0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798\",\n          \"0x0000000000000000016345785d8a0000\"\n        ]\n      },\n      {\n        \"index\": \"0x0300\",\n        \"data\": [\n          \"0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0\",\n          \"0x0000000000000000016345785d8a0000\"\n        ]\n      },\n      {\n        \"index\": \"0x030a\",\n        \"data\": [\n          \"0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0\",\n          \"0x0000000000000000016345785d8a0000\"\n        ]\n      },\n      {\n        \"index\": \"0x1c00\",\n        \"data\": [\n          {\n            \"complete\": {\n              \"used\": {\n                \"refTime\": 7250000000,\n                \"proofSize\": 19374\n              }\n            }\n          }\n        ]\n      }\n    ],\n    \"localXcm\": {\n      \"v4\": [\n        {\n          \"withdrawAsset\": [\n            {\n              \"id\": {\n                \"parents\": 0,\n                \"interior\": {\n                  \"x1\": [\n                    {\n                      \"palletInstance\": 3\n                    }\n                  ]\n                }\n              },\n              \"fun\": {\n                \"fungible\": \"0x0000000000000000016345785d8a0000\"\n              }\n            }\n          ]\n        },\n        {\n          \"depositAsset\": {\n            \"assets\": {\n              \"wild\": {\n                \"allCounted\": 1\n              }\n            },\n            \"beneficiary\": {\n              \"parents\": 0,\n              \"interior\": {\n                \"x1\": [\n                  {\n                    \"accountKey20\": {\n                      \"network\": null,\n                      \"key\": \"0x3cd0a705a2dc65e5b1e1205896baa2be8a07c6e0\"\n                    }\n                  }\n                ]\n              }\n            }\n          }\n        }\n      ]\n    } // Additional events returned here\n      // Omitted for clarity \n</code></pre>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#dry-run-xcm-api-method","title":"Dry Run XCM API Method","text":"<p>The <code>dryRunXCM</code> method of the XCM Dry Run API takes a full XCM message as a parameter instead of an encoded call, as well as the origin of the message.</p> <p><code>dryRunXCM</code> takes as a parameter the origin and the XCM message and returns an execution result, actual weight, and event data.  </p> <pre><code>// Define the origin\nconst origin = { V4: { parents: 1, interior: 'Here' } };\n\nconst message = []; // Insert XCM Message Here\n\n// Perform the dry run XCM call\nconst result = await api.call.dryRunApi.dryRunXcm(origin, message);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { hexToU8a } from '@polkadot/util';\n\nconst main = async () =&gt; {\n  try {\n    // Construct API provider\n    const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n    const api = await ApiPromise.create({ provider: wsProvider });\n    console.log('Connected to the API. Preparing dry run XCM call...');\n\n    // Define the origin\n    const origin = { V4: { parents: 1, interior: 'Here' } };\n    const amountToSend = 1000000000000;\n\n    const message = {\n      V4: [\n        {\n          WithdrawAsset: [\n            {\n              id: { parents: 1, interior: 'Here' },\n              fun: { Fungible: amountToSend },\n            },\n          ],\n        },\n        {\n          BuyExecution: {\n            fees: {\n              id: { parents: 1, interior: 'Here' },\n              fun: { Fungible: amountToSend },\n            },\n            weightLimit: { Unlimited: null },\n          },\n        },\n        {\n          DepositAsset: {\n            assets: { Wild: { AllOf: { id: { parents: 1, interior: 'Here' } } } },\n            maxAssets: 1,\n            beneficiary: {\n              parents: 0,\n              interior: {\n                X1: [\n                  {\n                    AccountKey20: {\n                      network: null,\n                      key: hexToU8a('0x3B939FeaD1557C741Ff06492FD0127bd287A421e')\n                    }\n                  }\n                ]\n              }\n            }\n          }\n        }\n      ],\n    };\n\n    // Perform the dry run XCM call\n    const result = await api.call.dryRunApi.dryRunXcm(origin, message);\n\n    console.log(\n      'Dry run XCM result:',\n      JSON.stringify(result.toJSON(), null, 2)\n    );\n\n    await api.disconnect();\n    console.log('Disconnected from the API.');\n  } catch (error) {\n    console.error('An error occurred:', error);\n  }\n};\n\nmain().catch(console.error);\n</code></pre> <p>Upon calling the XCM Dry Run API, the method will tell you whether the call would be successful and returns the event data that would be emitted if the XCM were to be actually submitted on chain. You can view the initial output of the <code>dryRunXCM</code> below.</p> View the complete output <pre><code>Dry run XCM result: {\n  \"ok\": {\n    \"executionResult\": {\n      \"complete\": {\n        \"used\": {\n          \"refTime\": 76473048000,\n          \"proofSize\": 222483\n        }\n      }\n    },\n    \"emittedEvents\": [\n      {\n        \"index\": \"0x1d03\",\n        \"data\": [\n          \"0x1fcacbd218edc0eba20fc2308c778080\",\n          \"0x506172656E740000000000000000000000000000\",\n          1000000000000\n        ]\n      },\n      {\n        \"index\": \"0x1d01\",\n        \"data\": [\n          \"0x1fcacbd218edc0eba20fc2308c778080\",\n          \"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",\n          959944978002\n        ]\n      },\n      {\n        \"index\": \"0x1d01\",\n        \"data\": [\n          \"0x1fcacbd218edc0eba20fc2308c778080\",\n          \"0x6d6F646c70632f74727372790000000000000000\",\n          40055021998\n        ]\n      }\n    ], // Additional events returned here\n      // Omitted for clarity \n</code></pre>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#execute-xcm-utils-precompile","title":"Execute an XCM Message with the XCM Utilities Precompile","text":"<p>In this section, you'll use the <code>xcmExecute</code> function of the XCM Utilities Precompile, which is only supported on Moonbase Alpha, to execute an XCM message locally. The XCM Utilities Precompile is located at the following address:</p> <pre><code>0x000000000000000000000000000000000000080C\n</code></pre> <p>Under the hood, the <code>xcmExecute</code> function of the XCM Utilities Precompile calls the <code>execute</code> function of the Polkadot XCM Pallet, which is a Substrate pallet that is coded in Rust. The benefit of using the XCM Utilities Precompile to call <code>xcmExecute</code> is that you can do so via the Ethereum API and use Ethereum libraries like Ethers.js.</p> <p>The <code>xcmExecute</code> function accepts two parameters: the SCALE encoded versioned XCM message to be executed and the maximum weight to be consumed.</p> <p>First, you'll learn how to generate the encoded calldata, and then you'll learn how to use the encoded calldata to interact with the XCM Utilities Precompile.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#generate-encoded-calldata","title":"Generate the Encoded Calldata of an XCM Message","text":"<p>To get the encoded calldata of the XCM message, you can create a script similar to the one you created in the Execute an XCM Message with the Polkadot.js API section. Instead of building the message and sending the transaction, you'll build the message to get the encoded calldata. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The Moonbase Alpha endpoint URL to create the provider</li> <li>The values for each of the parameters of the <code>execute</code> function as defined in the Execute an XCM Message with the Polkadot.js API section</li> </ul> </li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>polkadotXcm.execute</code> extrinsic with the <code>message</code> and <code>maxWeight</code></li> <li>Use the transaction to get the encoded calldata</li> </ol> <p>The entire script is as follows:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\n// 1. Provide input data\nconst moonbeamAccount = 'INSERT_ADDRESS';\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 100000000000000000n },\n    },\n  ],\n};\nconst instr2 = {\n  DepositAsset: {\n    assets: { Wild: { AllCounted: 1 } },\n    beneficiary: {\n      parents: 0,\n      interior: {\n        X1: [\n          {\n            AccountKey20: {\n              key: moonbeamAccount,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\nconst message = { V4: [instr1, instr2] };\nconst maxWeight = { refTime: 7250000000n, proofSize: 19374n };\n\nconst getEncodedXcmMessage = async () =&gt; {\n  // 2. Create Substrate API provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Craft the extrinsic\n  const tx = api.tx.polkadotXcm.execute(message, maxWeight);\n\n  // 4. Get the encoded XCM message\n  // By using index 0, you'll get just the encoded XCM message.\n  // If you wanted to get the maxWeight, you could use index 1\n  const encodedXcmMessage = tx.args[0].toHex();\n  console.log(`Encoded Calldata for XCM Message: ${encodedXcmMessage}`);\n\n  api.disconnect();\n};\n\ngetEncodedXcmMessage();\n</code></pre>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#execute-xcm-message","title":"Execute the XCM Message","text":"<p>Now that you have the SCALE encoded XCM message, you can use the following code snippets to programmatically call the <code>xcmExecute</code> function of the XCM Utilities Precompile using your Ethereum library of choice. Generally speaking, you'll take the following steps:</p> <ol> <li>Create a provider and signer</li> <li>Create an instance of the XCM Utilities Precompile to interact with</li> <li>Define parameters required for the <code>xcmExecute</code> function, which will be the encoded calldata for the XCM message and the maximum weight to use to execute the message. You can set the <code>maxWeight</code> to be <code>400000000n</code>, which corresponds to the <code>refTime</code>. The <code>proofSize</code> will automatically be set to the default, which is 64KB</li> <li>Execute the XCM message</li> </ol> <p>Remember</p> <p>The following snippets are for demo purposes only. Never store your private keys in a JavaScript or Python file.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport abi from './xcmUtilsABI.js'; // Import the XCM Utilities Precompile ABI\n\nconst privateKey = 'INSERT_YOUR_PRIVATE_KEY';\nconst xcmUtilsAddress = '0x000000000000000000000000000000000000080C';\n\n/* Create Ethers provider and signer */\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n/* Create contract instance of the XCM Utilities Precompile */\nconst xcmUtils = new ethers.Contract(\n  xcmUtilsAddress,\n  abi,\n  signer\n);\n\nconst executeXcmMessageLocally = async () =&gt; {\n  /* Define parameters required for the xcmExecute function */\n  const encodedCalldata = 'INSERT_ENCODED_CALLDATA';\n  const maxWeight = '400000000';\n\n  /* Execute the custom XCM message */\n  const tx = await xcmUtils.xcmExecute(encodedCalldata, maxWeight);\n  await tx.wait();\n  console.log(`Transaction receipt: ${tx.hash}`);\n};\n\nexecuteXcmMessageLocally();\n</code></pre> <pre><code>import { Web3 } from 'web3'; // Import Web3 library\nimport abi from './xcmUtilsABI.js'; // Import the XCM Utilities Precompile ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst accountFrom = web3.eth.accounts.privateKeyToAccount(privateKey).address;\nconst xcmUtilsAddress = '0x000000000000000000000000000000000000080C';\n\n/* Create Web3 provider */\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n/* Create contract instance of the XCM Utilities Precompile */\nconst xcmUtils = new web3.eth.Contract(\n  abi,\n  xcmUtilsAddress,\n  { from: accountFrom } // 'from' is necessary for gas estimation\n);\n\nconst executeXcmMessageLocally = async () =&gt; {\n  /* Define parameters required for the xcmExecute function */\n  const encodedCalldata = 'INSERT_ENCODED_CALLDATA';\n  const maxWeight = '400000000';\n\n  /* Send the custom XCM message */\n  // Craft the extrinsic\n  const tx = await xcmUtils.methods.xcmExecute(encodedCalldata, maxWeight);\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: xcmUtilsAddress,\n      data: tx.encodeABI(),\n      gas: await tx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom),\n    },\n    privateKey\n  );\n  // Send the signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(`Transaction receipt: ${sendTx.transactionHash}`);\n};\n\nexecuteXcmMessageLocally();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_XCM_UTILS_ABI\"  # Paste or import the XCM Utils ABI\n# This is for demo purposes, never store your private key in plain text\nprivate_key = \"INSERT_PRIVATE_KEY\"\n# The wallet address that corresponds to your private key\naddress = \"INSERT_ADDRESS\"\nxcm_utils_address = \"0x000000000000000000000000000000000000080C\"\n\n## Create Web3 provider ##\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n## Create contract instance of the XCM Utilities Precompile ##\nxcm_utils = web3.eth.contract(\n    # XCM Utilities Precompile address\n    address=xcm_utils_address,\n    abi=abi,\n)\n\n\ndef execute_xcm_message_locally():\n    ## Define parameters required for the xcmExecute function ##\n    encoded_calldata = \"INSERT_ENCODED_CALLDATA\"\n    max_weight = 400000000\n\n    ## Execute the custom XCM message ##\n    # Craft the extrinsic\n    tx = xcm_utils.functions.xcmExecute(encoded_calldata, max_weight).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n    # Sign transaction\n    signedTx = web3.eth.account.sign_transaction(tx, private_key)\n    # Send tx\n    hash = web3.eth.send_raw_transaction(signedTx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Transaction receipt: { receipt.transactionHash.hex() }\")\n\n\nexecute_xcm_message_locally()\n</code></pre> <p>And that's it! You've successfully used the Polkadot XCM Pallet and the XCM Utilities Precompile to execute a custom XCM message locally on Moonbase Alpha!</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#send-xcm-message","title":"Send an XCM Message Cross-Chain","text":"<p>This section of the guide covers the process of sending a custom XCM message cross-chain (i.e., from Moonbeam to a target chain, such as the relay chain) via two different methods: the <code>send</code> function of the Polkadot XCM Pallet and the <code>xcmSend</code> function of the XCM Utilities Precompile.</p> <p>For the XCM message to be successfully executed, the target chain needs to be able to understand the instructions in the message. If it doesn't, you'll see a <code>Barrier</code> filter on the destination chain. For security reasons, the XCM message is prepended with the <code>DescendOrigin</code> instruction to prevent XCM execution on behalf of the origin chain Sovereign account. The example in this section will not work for the reasons mentioned above, it is purely for demonstration purposes.</p> <p>In the following example, you'll be building an XCM message that contains the following XCM instructions, which will be executed in the Alphanet relay chain:</p> <ul> <li><code>WithdrawAsset</code> - removes assets and places them into the holding register</li> <li><code>BuyExecution</code> - takes the assets from holding to pay for execution fees. The fees to pay are determined by the target chain</li> <li><code>DepositAsset</code>- removes the assets from the holding register and deposits the equivalent assets to a beneficiary account</li> </ul> <p>Together, the intention of these instructions is to transfer the native asset of the relay chain, which is UNIT for the Alphanet relay chain, from Moonbase Alpha to an account on the relay chain. This example is for demonstration purposes only to show you how a custom XCM message could be sent cross-chain. Please keep in mind that the target chain needs to be able to understand the instructions in the message to execute them.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#send-xcm-message-with-polkadotjs-api","title":"Send an XCM Message with the Polkadot.js API","text":"<p>In this example, you'll send a custom XCM message from your account on Moonbase Alpha to the relay chain using the Polkadot.js API to interact directly with the Polkadot XCM Pallet.</p> <p>The <code>send</code> function of the Polkadot XCM Pallet accepts two parameters: <code>dest</code> and <code>message</code>. You can start assembling these parameters by taking the following steps:</p> <ol> <li> <p>Build the multilocation of the relay chain token, UNIT, for the <code>dest</code>:</p> <pre><code>const dest = { V4: { parents: 1, interior: null } };\n</code></pre> </li> <li> <p>Build the <code>WithdrawAsset</code> instruction, which will require you to define:</p> <ul> <li>The multilocation of the UNIT token on the relay chain</li> <li>The amount of UNIT tokens to withdraw</li> </ul> <pre><code>const instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n  ],\n};\n</code></pre> </li> <li> <p>Build the <code>BuyExecution</code> instruction, which will require you to define:</p> <ul> <li>The multilocation of the UNIT token on the relay chain</li> <li>The amount of UNIT tokens to buy for execution</li> <li>The weight limit</li> </ul> <pre><code>const instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n    { Unlimited: null },\n  ],\n};\n</code></pre> </li> <li> <p>Build the <code>DepositAsset</code> instruction, which will require you to define:</p> <ul> <li>The asset identifier for UNIT tokens. You can use the <code>WildAsset</code> format, which allows for wildcard matching, to identify the asset</li> <li>The multilocation of the beneficiary account on the relay chain</li> </ul> <pre><code>const instr3 = {\n  DepositAsset: {\n    assets: { Wild: 'All' },\n    beneficiary: {\n      parents: 1,\n      interior: {\n        X1: [\n          {\n            AccountId32: {\n              id: relayAccount,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\n</code></pre> </li> <li> <p>Combine the XCM instructions into a versioned XCM message:</p> <pre><code>const message = { V4: [instr1, instr2, instr3] };\n</code></pre> </li> </ol> <p>Now that you have the values for each of the parameters, you can write the script to send the XCM message. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The Moonbase Alpha endpoint URL to create the provider</li> <li>The values for each of the parameters of the <code>send</code> function</li> </ul> </li> <li>Create a Keyring instance that will be used to send the transaction</li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>polkadotXcm.send</code> extrinsic with the <code>dest</code> and <code>message</code></li> <li>Send the transaction using the <code>signAndSend</code> extrinsic and the Keyring instance you created in the second step</li> </ol> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a JavaScript file.</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady, decodeAddress } from '@polkadot/util-crypto';\n\n// 1. Input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\n// You can use the decodeAddress function to ensure that your address is properly\n// decoded. If it isn't decoded, it will decode it and if it is, it will ignore it\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst relayAccount = decodeAddress('INSERT_ADDRESS');\nconst dest = { V4: { parents: 1, interior: null } };\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n  ],\n};\nconst instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n    { Unlimited: null },\n  ],\n};\nconst instr3 = {\n  DepositAsset: {\n    assets: { Wild: 'All' },\n    beneficiary: {\n      parents: 1,\n      interior: {\n        X1: [\n          {\n            AccountId32: {\n              id: relayAccount,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\nconst message = { V4: [instr1, instr2, instr3] };\n\nconst sendXcmMessage = async () =&gt; {\n  // 2. Create Keyring instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'ethereum' });\n  const alice = keyring.addFromUri(privateKey);\n\n  // 3. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 4. Create the extrinsic\n  const tx = api.tx.polkadotXcm.send(dest, message);\n\n  // 5. Send the transaction\n  const txHash = await tx.signAndSend(alice);\n  console.log(`Submitted with hash ${txHash}`);\n\n  api.disconnect();\n};\n\nsendXcmMessage();\n</code></pre> <p>Note</p> <p>You can view an example of the above script, which sends 1 UNIT to Bob's relay chain account, on Polkadot.js Apps using the following encoded calldata: <code>0x1c00040100040c0004010000070010a5d4e813010000070010a5d4e8000d0100010101000c36e9ba26fa63c60ec728fe75fe57b86a450d94e7fee7f9f9eddd0d3f400d67</code>.</p> <p>Once the transaction is processed, a <code>polkadotXcm.sent</code> event is emitted with the details of the sent XCM message.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#send-xcm-utils-precompile","title":"Send an XCM Message with the XCM Utilities Precompile","text":"<p>In this section, you'll use the <code>xcmSend</code> function of the XCM Utilities Precompile, which is only supported on Moonbase Alpha, to send an XCM message cross-chain. The XCM Utilities Precompile is located at the following address:</p> Moonbase Alpha <pre><code>0x000000000000000000000000000000000000080C\n</code></pre> <p>Under the hood, the <code>xcmSend</code> function of the XCM Utilities Precompile calls the <code>send</code> function of the Polkadot XCM Pallet, which is a Substrate pallet that is coded in Rust. The benefit of using the XCM Utilities Precompile to call <code>xcmSend</code> is that you can do so via the Ethereum API and use Ethereum libraries like Ethers.js. For the XCM message to be successfully executed, the target chain needs to be able to understand the instructions in the message.</p> <p>The <code>xcmSend</code> function accepts two parameters: the multilocation of the destination and the SCALE encoded versioned XCM message to be sent.</p> <p>First, you'll learn how to generate the encoded calldata for the XCM message, and then you'll learn how to use the encoded calldata to interact with the XCM Utilities Precompile.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#generate-encoded-calldata","title":"Generate the Encoded Calldata of an XCM Message","text":"<p>To get the encoded calldata of the XCM message, you can create a script similar to the one you created in the Send an XCM Message with the Polkadot.js API section. Instead of building the message and sending the transaction, you'll build the message to get the encoded calldata. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The Moonbase Alpha endpoint URL to create the provider</li> <li>The values for each of the parameters of the <code>send</code> function as defined in the Send an XCM Message with the Polkadot.js API section</li> </ul> </li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>polkadotXcm.execute</code> extrinsic with the <code>message</code> and <code>maxWeight</code></li> <li>Use the transaction to get the encoded calldata</li> </ol> <p>The entire script is as follows:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\nimport { decodeAddress } from '@polkadot/util-crypto';\n\n// 1. Input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\n// You can use the decodeAddress function to ensure that your address is properly\n// decoded. If it isn't decoded, it will decode it and if it is, it will ignore it\nconst relayAccount = decodeAddress('INSERT_ADDRESS');\nconst dest = { V4: { parents: 1, interior: null } };\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n  ],\n};\nconst instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n    { Unlimited: null },\n  ],\n};\nconst instr3 = {\n  DepositAsset: {\n    assets: { Wild: 'All' },\n    beneficiary: {\n      parents: 1,\n      interior: {\n        X1: [\n          {\n            AccountId32: {\n              id: relayAccount,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\nconst message = { V4: [instr1, instr2, instr3] };\n\nconst generateEncodedXcmMessage = async () =&gt; {\n  // 2. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Create the extrinsic\n  const tx = api.tx.polkadotXcm.send(dest, message);\n\n  // 4. Get the encoded XCM message\n  // By using index 1, you'll get just the encoded XCM message.\n  // If you wanted to get the dest, you could use index 0\n  const encodedXcmMessage = tx.args[1].toHex();\n  console.log(`Encoded Calldata for XCM Message: ${encodedXcmMessage}`);\n\n  api.disconnect();\n};\n\ngenerateEncodedXcmMessage();\n</code></pre>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#send-xcm-message","title":"Send the XCM Message","text":"<p>Before you can send the XCM message, you'll also need to build the multilocation of the destination. For this example, you'll target the relay chain with Moonbase Alpha as the origin chain:</p> <pre><code>const dest = [\n  1, // Parents: 1 \n  [] // Interior: Here\n];\n</code></pre> <p>Now that you have the SCALE encoded XCM message and the destination multilocation, you can use the following code snippets to programmatically call the <code>xcmSend</code> function of the XCM Utilities Precompile using your Ethereum library of choice. Generally speaking, you'll take the following steps:</p> <ol> <li>Create a provider and signer</li> <li>Create an instance of the XCM Utilities Precompile to interact with</li> <li>Define parameters required for the <code>xcmSend</code> function, which will be the destination and the encoded calldata for the XCM message</li> <li>Send the XCM message</li> </ol> <p>Remember</p> <p>The following snippets are for demo purposes only. Never store your private keys in a JavaScript or Python file.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport abi from './xcmUtilsABI.js'; // Import the XCM Utilities Precompile ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst xcmUtilsAddress = '0x000000000000000000000000000000000000080C';\n\n/* Create Ethers provider and signer */\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n/* Create contract instance of the XCM Utilities Precompile */\nconst xcmUtils = new ethers.Contract(\n  xcmUtilsAddress,\n  abi,\n  signer\n);\n\nconst sendXcm = async () =&gt; {\n  /* Define parameters required for the xcmSend function */\n  const encodedCalldata = 'INSERT_ENCODED_CALLDATA';\n  const dest = [\n    1, // Parents: 1 \n    [] // Interior: Here\n  ];\n\n  /* Send the custom XCM message */\n  const tx = await xcmUtils.xcmSend(dest, encodedCalldata);\n  await tx.wait();\n  console.log(`Transaction receipt: ${tx.hash}`);\n};\n\nsendXcm();\n</code></pre> <pre><code>import { Web3 } from 'web3'; // Import Web3 library\nimport abi from './xcmUtilsABI.js'; // Import the XCM Utilities Precompile ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst accountFrom = web3.eth.accounts.privateKeyToAccount(privateKey).address;\nconst xcmUtilsAddress = '0x000000000000000000000000000000000000080C';\n\n/* Create Web3 provider */\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n/* Create contract instance of the XCM Utilities Precompile */\nconst xcmUtils = new web3.eth.Contract(\n  abi,\n  xcmUtilsAddress,\n  { from: accountFrom } // 'from' is necessary for gas estimation\n);\n\nconst sendXcm = async () =&gt; {\n  /* Define parameters required for the xcmSend function */\n  const encodedCalldata = 'INSERT_ENCODED_CALLDATA';\n  const dest = [\n    1, // Parents: 1\n    [], // Interior: Here\n  ];\n\n  /* Send the custom XCM message */\n  // Craft the extrinsic\n  const tx = await xcmUtils.methods.xcmSend(dest, encodedCalldata);\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: xcmUtilsAddress,\n      data: tx.encodeABI(),\n      gas: await tx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom),\n    },\n    privateKey\n  );\n  // Send the signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(`Transaction receipt: ${sendTx.transactionHash}`);\n};\n\nsendXcm();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_XCM_UTILS_ABI\"  # Paste or import the XCM Utils ABI\n# This is for demo purposes, never store your private key in plain text\nprivate_key = \"INSERT_PRIVATE_KEY\"\n# The wallet address that corresponds to your private key\naddress = \"INSERT_ADDRESS\"\nxcm_utils_address = \"0x000000000000000000000000000000000000080C\"\n\n## Create Web3 provider ##\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n## Create contract instance of the XCM Utilities Precompile ##\nxcm_utils = web3.eth.contract(\n    # XCM Utilities Precompile address\n    address=xcm_utils_address,\n    abi=abi,\n)\n\n\ndef send_xcm():\n    ## Define parameters required for the xcmSend function ##\n    encoded_calldata = \"INSERT_ENCODED_CALLDATA\"\n    xcm_dest = [1, []]  # Parents: 1  # Interior: Here\n\n    ## Send the custom XCM message ##\n    # Craft the extrinsic\n    tx = xcm_utils.functions.xcmSend(xcm_dest, encoded_calldata).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n    # Sign transaction\n    signed_tx = web3.eth.account.sign_transaction(tx, private_key)\n    # Send tx\n    hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Transaction receipt: { receipt.transactionHash.hex() }\")\n\n\nsend_xcm()\n</code></pre> <p>And that's it! You've successfully used the Polkadot XCM Pallet and the XCM Utilities Precompile to send a message from Moonbase Alpha to another chain!</p>"},{"location":"builders/interoperability/xcm/xcm-utils/","title":"Interacting with the XCM Utilities Precompile","text":""},{"location":"builders/interoperability/xcm/xcm-utils/#xcmutils-precompile","title":"Introduction","text":"<p>The XCM Utilities Precompile contract gives developers XCM-related utility functions directly within the EVM. This allows for easier transactions and interactions with other XCM-related precompiles.</p> <p>Similar to other precompile contracts, the XCM Utilities Precompile is located at the following addresses:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x000000000000000000000000000000000000080C\n</code></pre> <pre><code>0x000000000000000000000000000000000000080C\n</code></pre> <pre><code>0x000000000000000000000000000000000000080C\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/interoperability/xcm/xcm-utils/#xcmutils-solidity-interface","title":"The XCM Utilities Solidity Interface","text":"<p>XcmUtils.sol is an interface to interact with the precompile.</p> <p>Note</p> <p>The precompile will be updated in the future to include additional features. Feel free to suggest additional utility functions in the Discord.</p> <p>The interface includes the following functions:</p> <ul> <li>multilocationToAddress(Multilocation memory multilocation) \u2014 read-only function that returns the Computed Origin account from a given multilocation</li> <li>weightMessage(bytes memory message) \u2014 read-only function that returns the weight that an XCM message will consume on the chain. The message parameter must be a SCALE encoded XCM versioned XCM message</li> <li> <p>getUnitsPerSecond(Multilocation memory multilocation) \u2014 read-only function that gets the units per second for a given asset in the form of a <code>Multilocation</code>. The multilocation must describe an asset that can be supported as a fee payment, such as an external XC-20, or else this function will revert. </p> <p>Note</p> <p>Note that this function still returns units per second data but units per second has been deprecated and replaced by the calculation of relative price. See XC asset registration for more details.</p> </li> <li> <p>xcmExecute(bytes memory message, uint64 maxWeight) - available on Moonbase Alpha only -  executes a custom XCM message given the SCALE encoded versioned message to be executed and the maximum weight to be consumed. This function cannot be called from a smart contract due to the nature of the <code>Transact</code> instruction</p> </li> <li>xcmSend(Multilocation memory dest, bytes memory message) - available on Moonbase Alpha only - sends a custom XCM message given the multilocation of the destination chain to send the message to and the SCALE encoded versioned message to be sent</li> </ul> <p>The <code>Multilocation</code> struct in the XCM Utilities Precompile is built the same as the XCM Transactor Precompile's <code>Multilocation</code>.</p>"},{"location":"builders/interoperability/xcm/xcm-utils/#using-the-xcmutils-precompile","title":"Using the XCM Utilities Precompile","text":"<p>The XCM Utilities precompile allows users to read data off of the Ethereum JSON-RPC instead of having to go through a Polkadot library. The functions are more for convenience, and less for smart contract use cases.</p> <p>For <code>multilocationToAddress</code>, one example use case is being able to allow transactions that originate from other parachains by whitelisting their Computed Origin addresses. A user can whitelist a multilocation by calculating and storing an address. EVM transactions can originate from other parachains via remote EVM calls.  </p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\nimport \"https://github.com/moonbeam-foundation/moonbeam/blob/master/precompiles/xcm-utils/XcmUtils.sol\";\n\ncontract MultilocationWhitelistExample {\n    XcmUtils xcmutils = XcmUtils(0x000000000000000000000000000000000000080C);\n    mapping(address =&gt; bool) public whitelistedAddresses;\n\n    modifier onlyWhitelisted(address addr) {\n        _;\n        require(whitelistedAddresses[addr], \"Address not whitelisted!\");\n        _;\n    }\n\n    function addWhitelistedMultilocation(\n        XcmUtils.Multilocation calldata externalMultilocation\n    ) external onlyWhitelisted(msg.sender) {\n        address derivedAddress = xcmutils.multilocationToAddress(\n            externalMultilocation\n        );\n        whitelistedAddresses[derivedAddress] = true;\n    }\n\n    ...\n}\n</code></pre> <p>To check out an example of how to use the <code>xcmExecute</code> function to execute a custom XCM message locally, please refer to the Create and Execute Custom XCM Messages guide.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/","title":"XCM Instructions","text":""},{"location":"builders/interoperability/xcm/core-concepts/instructions/#introduction","title":"Introduction","text":"<p>XCM messages contain a series of actions and instructions that are executed by the Cross-Consensus Virtual Machine (XCVM). An action (for example, transferring a token from one blockchain to another) consists of instructions that the XCVM partly executes in the origin and destination chains.</p> <p>For example, an XCM message that transfers DOT from Polkadot to Moonbeam will include the following XCM instructions (in that order), some of which are executed on Polkadot and some of which are executed on Moonbeam:</p> <ol> <li>TransferReserveAsset \u2014 executed in Polkadot</li> <li>ReserveAssetDeposited \u2014 executed in Moonbeam</li> <li>ClearOrigin \u2014 executed in Moonbeam</li> <li>BuyExecution \u2014 executed in Moonbeam</li> <li>DepositAsset \u2014 executed in Moonbeam</li> </ol> <p>Building the instructions for an XCM message from scratch is not an easy task. Consequently, there are wrapper functions and pallets that developers can leverage to use XCM features. The Polkadot XCM and XCM Transactor Pallets provide functions with a predefined set of XCM instructions to either send XC-20s or remotely execute on other chains via XCM.</p> <p>If you're interested in experimenting with different combinations of instructions, you can use the Polkadot XCM Pallet to execute and send custom XCM messages.</p> <p>This guide provides an overview of some of the most commonly used XCM instructions, including those in the above example.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#buy-execution","title":"Buy Execution","text":"<p>The <code>BuyExecution</code> instruction typically gets executed in the target chain. It takes assets from the holding register, a temporary position in the Cross-Consensus Virtual Machine (XCVM), to pay for execution fees. The target chain determines the fees to pay.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#clear-origin","title":"Clear Origin","text":"<p>The <code>ClearOrigin</code> instruction gets executed in the target chain. It clears the origin of the XCM author, thereby ensuring that later XCM instructions cannot command the authority of the author.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#deposit-asset","title":"Deposit Asset","text":"<p>The <code>DepositAsset</code> instruction gets executed in the target chain. It removes the assets from the holding register, a temporary position in the Cross-Consensus Virtual Machine (XCVM), and sends them to a destination account on the target chain.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#descend-origin","title":"Descend Origin","text":"<p>The <code>DescendOrigin</code> instruction gets executed in the target chain. It mutates the origin on the target chain to match the origin on the source chain, ensuring execution on the target chain occurs on behalf of the same entity initiating the XCM message on the source chain.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#initiate-reserve-withdraw","title":"Initiate Reserve Withdraw","text":"<p>The <code>InitiateReserveWithdraw</code> instruction gets executed in the source chain. It removes the assets from the holding register, a temporary position in the Cross-Consensus Virtual Machine (XCVM), (essentially burning them), and sends an XCM message to the reserve chain starting with the <code>WithdrawAsset</code> instruction.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#refund-surplus","title":"Refund Surplus","text":"<p>The <code>RefundSurplus</code> instruction typically gets executed in the target chain after the XCM is processed. This instruction will take any leftover assets from the <code>BuyExecution</code> instruction and put the assets into the holding register, a temporary position in the Cross-Consensus Virtual Machine (XCVM).</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#reserve-asset-deposited","title":"Reserve Asset Deposited","text":"<p>The <code>ReserveAssetDeposited</code> instruction gets executed in the target chain. It takes a representation of the assets received in the Sovereign account and places them into the holding register, a temporary position in the Cross-Consensus Virtual Machine (XCVM).</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#set-appendix","title":"Set Appendix","text":"<p>The <code>SetAppendix</code> instruction gets executed in the target chain. It sets the appendix register, which holds code that should be run after the current execution is finished.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#transfer-reserve-asset","title":"Transfer Reserve Asset","text":"<p>The <code>TransferReserveAsset</code> instruction gets executed in the reserve chain. It moves assets from the origin account and deposits them into a destination account on the target chain. It then sends an XCM message to the target chain with the <code>ReserveAssetDeposited</code> instruction, followed by the XCM instructions that are to be executed.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#transact","title":"Transact","text":"<p>The <code>Transact</code> instruction gets executed in the target chain. It dispatches encoded call data from a given origin, allowing for the execution of specific operations or functions on the target chain.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#withdraw-asset","title":"Withdraw Asset","text":"<p>The <code>WithdrawAsset</code> instruction can be executed in either the source or target chain. It removes assets and places them into the holding register, a temporary position in the Cross-Consensus Virtual Machine (XCVM).</p>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/","title":"Multilocations","text":""},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#introduction","title":"Introduction","text":"<p>A multilocation defines a specific point in the entire relay chain/parachain ecosystem relative to a given origin. It can be used to target a specific parachain, asset, account, or even a pallet inside a parachain.</p> <p>Multilocations follow a hierarchical structure, in which some locations are encapsulated within others. For example, a relay chain encapsulates all of the parachains that are connected to it. Similarly, a parachain encapsulates all of the pallets, accounts, and assets that exist within it.</p> <p></p>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#defining-a-multilocation","title":"Defining a Multilocation","text":"<p>A multilocation contains two parameters:</p> <ul> <li><code>parents</code> - refers to how many \"hops\" up into a parent blockchain you need to take from a given origin. From the perspective of a parachain within the relay chain ecosystem, there can only be one parent, so the value for <code>parents</code> can only ever be <code>0</code> to represent the parachain or <code>1</code> to represent the relay chain. When defining universal locations that consider other consensus systems like Ethereum, <code>parents</code> can have higher values</li> <li><code>interior</code> - refers to how many fields you need to define the target point. From the relay chain, you can drill down to target a specific parachain, or account, asset, or pallet on that parachain. Since this downward movement can be more complex, Junctions are used to represent the steps needed to reach the target location and are defined by <code>XN</code>, where <code>N</code> is the number of Junctions required. If no Junctions are required to define the target point, its value would be <code>Here</code> as opposed to <code>X1</code></li> </ul> <p>For example, if you are targeting the relay chain specifically, you'll use <code>Here</code> since you aren't defining an account on the relay chain, a parachain, or a specific point within a parachain.</p> <p>On the flip side, if you're targeting an account on the relay chain, or a parachain, or a specific point within a parachain, you'll use one or more Junctions, as needed.</p>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#junctions","title":"Junctions","text":"<p>A Junction can be any of the following:</p> <ul> <li> <p><code>Parachain</code> - describes a parachain using the parachain's ID</p> <pre><code>{ Parachain: INSERT_PARACHAIN_ID }\n</code></pre> </li> <li> <p><code>AccountId32</code> - describes a 32-byte Substrate-style account. Accepts an optional <code>network</code> parameter, which can be one of the following: <code>Any</code>, <code>Named</code>, <code>Polkadot</code>, or <code>Kusama</code></p> <pre><code>{ AccountId32: { id: INSERT_ADDRESS, network: INSERT_NETWORK } }\n</code></pre> </li> <li> <p><code>AccountIndex64</code> - describes a 64-bit (8-byte) index for an account. Accepts an optional <code>network</code> parameter, which can be one of the following: <code>Any</code>, <code>Named</code>, <code>Polkadot</code>, or <code>Kusama</code></p> <pre><code>{ AccountIndex64: { index: INSERT_ACCOUNT_INDEX, network: INSERT_NETWORK } }\n</code></pre> </li> <li> <p><code>AccountKey20</code> - describes a 20-byte Ethereum-style account, as is used in Moonbeam. Accepts an optional <code>network</code> parameter, which can be one of the following: <code>Any</code>, <code>Named</code>, <code>Polkadot</code>, or <code>Kusama</code></p> <pre><code>{ AccountKey20: { key: INSERT_ADDRESS, network: INSERT_NETWORK } }\n</code></pre> </li> <li> <p><code>PalletInstance</code> - describes the index of a pallet on the target chain</p> <pre><code>{ PalletInstance: INSERT_PALLET_INSTANCE_INDEX }\n</code></pre> </li> <li> <p><code>GeneralIndex</code> - describes a nondescript index that can be used to target data stored in a key-value format</p> <pre><code>{ GeneralIndex: INSERT_GENERAL_INDEX }\n</code></pre> </li> <li> <p><code>GeneralKey</code> - describes a nondescript key that can be used to target more complex data structures. This requires you to specify the <code>data</code> and the <code>length</code> of the data</p> <pre><code>{ GeneralKey: { length: INSERT_LENGTH_OF_DATA, data: [INSERT_DATA] } }\n</code></pre> </li> <li> <p><code>OnlyChild</code> - describes the child of a location if there is only a one-to-one relation between the parent and child. This is currently not used except as a fallback when deriving context</p> </li> <li> <p><code>Plurality</code> - describes multiple elements that meet specific conditions or share common characteristics. This requires you to specify the Body ID and the Body Part that the Junction represents</p> <pre><code>{ Plurality: { id: INSERT_BODY_ID, part: INSERT_BODY_PART } }\n</code></pre> </li> </ul> <p>When using Junctions, you'll use <code>XN</code>, where <code>N</code> is the number of Junctions required to reach the target location. For example, if you're targeting an account on Moonbeam from a parachain, <code>parents</code> needs to be set to <code>1</code>, and you'll need to define two Junctions, the <code>Parachain</code> and the <code>AccountKey20</code>, so you'll use <code>X2</code>, which is an array that will contain each Junction:</p> <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2004 },\n      { AccountKey20: { key: 'INSERT_MOONBEAM_ADDRESS' } },\n    ],\n  },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#example-multilocations","title":"Example Multilocations","text":""},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-moonbeam-from-parachain","title":"Target Moonbeam from Another Parachain","text":"<p>To target a Moonbeam-based chain from another parachain, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 2004 }],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 2023 }],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 1000 }],\n  },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-account-moonbeam-from-parachain","title":"Target an Account on Moonbeam from Another Parachain","text":"<p>To target a specific account on a Moonbeam-based chain from another parachain, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2004 },\n      { AccountKey20: { key: 'INSERT_MOONBEAM_ADDRESS' } },\n    ],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2023 },\n      { AccountKey20: { key: 'INSERT_MOONBEAM_ADDRESS' } },\n    ],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 1000 },\n      { AccountKey20: { key: 'INSERT_MOONBEAM_ADDRESS' } },\n    ],\n  },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-moonbeam-native-asset-from-parachain","title":"Target Moonbeam's Native Asset from Another Parachain","text":"<p>To target the native asset of a Moonbeam-based chain from another parachain, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2004 },\n      { PalletInstance: 10 }, // Index of the Balances Pallet on Moonbeam\n    ],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2023 },\n      { PalletInstance: 10 }, // Index of the Balances Pallet on Moonriver\n    ],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 1000 },\n      { PalletInstance: 3 }, // Index of the Balances Pallet on Moonbase Alpha\n    ],\n  },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-moonbeam-from-relay","title":"Target Moonbeam from the Relay Chain","text":"<p>To target a Moonbeam-based chain from the relay chain, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 0,\n  interior: {\n    X1: [{ Parachain: 2004 }],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 0,\n  interior: {\n    X1: [{ Parachain: 2023 }],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 0,\n  interior: {\n    X1: [{ Parachain: 1000 }],\n  },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-relay-from-moonbeam","title":"Target the Relay Chain from Moonbeam","text":"<p>To target the relay chain from a Moonbeam-based chain, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: Here,\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: Here,\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: Here,\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-account-relay-from-moonbeam","title":"Target an Account on the Relay Chain from Moonbeam","text":"<p>To target a specific account on the relay chain, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: { X1: { AccountId32: { id: INSERT_RELAY_ADDRESS } } },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: { X1: { AccountId32: { id: INSERT_RELAY_ADDRESS } } },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: { X1: { AccountId32: { id: INSERT_RELAY_ADDRESS } } },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-parachain-from-moonbeam","title":"Target Another Parachain from Moonbeam","text":"<p>To target another parachain (for example, a parachain that has an ID of 1234) from Moonbeam, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 1234 }],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 1234 }],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 1234 }],\n  },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#location-to-account-api","title":"Location to Account API","text":"<p>The Location to Account API is an easy way to convert a multilocation into an <code>AccountID20</code> address. The Location to Account API can be accessed from the Runtime Calls tab of the Developer section of Polkadot.js Apps. The <code>convertLocation</code> method of the Location to Account API takes a multilocation as a parameter and returns an <code>AccountID20</code> address.</p> <pre><code>// Query the locationToAccountApi using convertLocation method\nconst result =\n  await api.call.locationToAccountApi.convertLocation(multilocation);\nconsole.log('Conversion result:', result.toHuman());\n</code></pre> <p>You can view the complete script below.</p> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Define the multilocation parameter\n  const multilocation = {\n    V4: {\n      parents: 1,\n      interior: 'Here',\n    },\n  };\n\n  // Query the locationToAccountApi using convertLocation method\n  const result =\n    await api.call.locationToAccountApi.convertLocation(multilocation);\n  console.log('Conversion result:', result.toHuman());\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain().catch(console.error);\n</code></pre> <p>The method will return the <code>AccountID20</code> address corresponding to the provided multilocation as follows:</p> <pre><code>Conversion result: { Ok: '0x506172656E740000000000000000000000000000' }\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/sovereign-accounts/","title":"Overview of Sovereign Accounts","text":""},{"location":"builders/interoperability/xcm/core-concepts/sovereign-accounts/#introduction","title":"Introduction","text":"<p>In Polkadot-based ecosystems, a sovereign account is a unique, keyless account controlled by a blockchain\u2019s runtime through XCM rather than an individual or organization. These accounts are used to store assets when transferring tokens cross-chain. For example, if you send a reserve tokens transfer from a parachain to Moonbeam, the originating parachain locks those tokens in Moonbeam\u2019s sovereign account on the source chain, while a wrapped representation of those tokens is minted on Moonbeam.</p> <p>Sovereign accounts play a central role in reserve-backed transfers, where one chain (the \u201creserve\u201d) holds the real assets and other chains hold derivative tokens. When tokens move across chains, the reserve (or origin) chain locks or unlocks the underlying asset, and derivative tokens are minted or burned on the destination chain.</p>"},{"location":"builders/interoperability/xcm/core-concepts/sovereign-accounts/#calculating-sovereign","title":"Calculating a Parachain Sovereign Account","text":"<p>You can calculate a parachain\u2019s sovereign account on a given relay chain using the xcm-tools repository. This is especially useful when you need to verify where underlying tokens are locked or to fund a parachain\u2019s sovereign account directly.</p> <ol> <li>Clone or navigate to the xcm-tools repository</li> <li>Use the <code>calculate-sovereign-account</code> script, specifying the Parachain ID with the <code>--p</code> flag and the relay chain with the <code>--r</code> flag (default is <code>polkadot</code>; other accepted values are <code>kusama</code> or <code>moonbase</code>)</li> </ol> <p>The parachain ID you need can be found on the respective relay chain\u2019s Polkadot.js Apps Parachains page. The Parachains page can be accessed under the Network dropdown.</p> <p>For example, to calculate the sovereign account address for parachain <code>1000</code> on the Moonbase Alpha testnet:</p> <pre><code>yarn calculate-sovereign-account --p 1000 --r moonbase\n</code></pre> <p>Running the script will generate output like the following:</p> yarn calculate-sovereign-account --p 1000 --r moonbase yarn run v1.22.22 $ ts-node 'scripts/calculate-sovereign-account.ts' --p 1000 --r moonbase Sovereign Account Address on Relay: 0x70617261e8030000000000000000000000000000000000000000000000000000 Sovereign Account Address on other Parachains (Generic): 0x7369626ce8030000000000000000000000000000000000000000000000000000 Sovereign Account Address on Moonbase Alpha: 0x7369626ce8030000000000000000000000000000 <p>The relay address is how the Polkadot or Kusama relay chain references the sovereign account. Generic parachain address is typically used for referencing this parachain\u2019s sovereign account from other parachains. The Moonbase Alpha address is the corresponding sovereign account in the H160 EVM address format used by Moonbase Alpha.</p>"},{"location":"builders/interoperability/xcm/core-concepts/sovereign-accounts/#learn-more","title":"Learn More","text":"<p>Sovereign accounts form the backbone of reserve-backed transfers, enabling safe custody of assets for minting wrapped tokens across Polkadot\u2019s ecosystem. By combining sovereign accounts with the XCM framework, parachains can interoperate seamlessly\u2014locking and unlocking assets in a transparent, trust-minimized way. For more information about how sovereign accounts facilitate cross-chain transfers with XCM, be sure to check out the Send XC-20s section.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/","title":"XCM Fees on Moonbeam","text":""},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#introduction","title":"Introduction","text":"<p>XCM aims to be a language that communicates ideas between consensus systems. Sending an XCM message consists of a series of instructions that are executed in both the origin and the destination chains. The combination of XCM instructions results in actions such as token transfers. In order to process and execute each XCM instruction, there are typically associated fees that must be paid.</p> <p>However, XCM is designed to be general, extensible, and efficient so that it remains valuable and future-proof throughout a growing ecosystem. As such, the generality applies to concepts including payments of fees for XCM execution. In Ethereum, fees are baked into the transaction protocol, whereas in the Polkadot ecosystem, each chain has the flexibility to define how XCM fees are handled.</p> <p>This guide will cover aspects of fee payment, such as who is responsible for paying XCM execution fees, how it is paid for, and how the fees are calculated on Moonbeam.</p> <p>Note</p> <p>The following information is provided for general information purposes only. The weight and extrinsic base cost might have changed since the time of writing. Please ensure you check the actual values, and never use the following information for production apps.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#payment-of-fees","title":"Payment of Fees","text":"<p>Generally speaking, the fee payment process can be described as follows:</p> <ol> <li>Some assets need to be provided</li> <li>The exchange of assets for computing time (or weight) must be negotiated</li> <li>The XCM operations will be performed as instructed, with the provided weight limit or funds available for execution</li> </ol> <p>Each chain can configure what happens with the XCM fees and in which tokens they can be paid (either the native reserve token or an external one). For example:</p> <ul> <li>Polkadot and Kusama - the fees are paid in DOT or KSM (respectively) and given to the validator of the block</li> <li>Moonbeam and Moonriver - the XCM execution fees can be paid in the reserve asset (GLMR or MOVR, respectively), but also in assets originated in other chains if they are registered as an XCM execution asset. When XCM execution (token transfers or remote execution) is paid in the native chain reserve asset (GLMR or MOVR), 100% is burned. When XCM execution is paid in a foreign asset, the fee is sent to the Treasury</li> </ul> <p>Consider the following scenario: Alice has some DOT on Polkadot, and she wants to transfer it to Alith on Moonbeam. She sends an XCM message with a set of XCM instructions that will retrieve a given amount of DOT from her account on Polkadot and mint them as xcDOT into Alith's account. Part of the instructions are executed on Polkadot, and the other part is executed on Moonbeam.</p> <p>How does Alice pay Moonbeam to execute these instructions and fulfill her request? Her request is fulfilled through a series of XCM instructions that are included in the XCM message, which enables her to buy execution time minus any related XCM execution fees. The execution time is used to issue and transfer xcDOT, a representation of DOT on Moonbeam. This means that when Alice sends some DOT to Alith's account on Moonbeam, she'll receive a 1:1 representation of her DOT as xcDOT minus any XCM execution fees. Note that in this scenario, XCM execution fees are paid in xcDOT and sent to the treasury.</p> <p>The exact process for Alice's transfer is as follows:</p> <ol> <li>Assets are sent to an account on Polkadot that is owned by Moonbeam, known as the Sovereign account. After the assets are received, an XCM message is sent to Moonbeam</li> <li>The XCM message in Moonbeam will:<ol> <li>Mint the corresponding asset representation</li> <li>Buy the corresponding execution time</li> <li>Use that execution time to deposit the representation (minus fees) to the destination account</li> </ol> </li> </ol>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#xcm-instructions","title":"XCM Instructions","text":"<p>An XCM message is comprised of a series of XCM instructions. As a result, different combinations of XCM instructions result in different actions. For example, to move DOT to Moonbeam, the following XCM instructions are used:</p> <p>When DOT is transferred from Polkadot to Moonbeam, the following XCM instructions are executed in sequence:</p> <ol> <li> <p><code>TransferReserveAsset</code> - executes on Polkadot, moving the DOT from the sender and depositing it into Moonbeam\u2019s Sovereign account on Polkadot</p> </li> <li> <p><code>ReserveAssetDeposited</code> - executes on Moonbeam, minting the corresponding ERC-20 representation of DOT (xcDOT) on Moonbeam</p> </li> <li> <p><code>ClearOrigin</code> - executes on Moonbeam, clearing any origin data\u2014previously set to Polkadot\u2019s Sovereign account</p> </li> <li> <p><code>BuyExecution</code> - executes on Moonbeam, determining the execution fees. Here, a portion of the newly minted xcDOT is used to pay the cost of XCM</p> </li> <li> <p><code>DepositAsset</code> - executes on Moonbeam, delivering the xcDOT to the intended recipient\u2019s account on Moonbeam</p> </li> </ol> <p>To check how the instructions for an XCM message are built to transfer self-reserve assets to a target chain, such as DOT to Moonbeam, you can refer to the X-Tokens Open Runtime Module Library repository (as an example). You'll want to take a look at the <code>transfer_self_reserve_asset</code> function. You'll notice it calls <code>TransferReserveAsset</code> and passes in <code>assets</code>, <code>dest</code>, and <code>xcm</code> as parameters. In particular, the <code>xcm</code> parameter includes the <code>BuyExecution</code> and <code>DepositAsset</code> instructions. If you then head over to the Polkadot GitHub repository, you can find the <code>TransferReserveAsset</code> instruction. The XCM message is constructed by combining the <code>ReserveAssetDeposited</code> and <code>ClearOrigin</code> instructions with the <code>xcm</code> parameter, which as mentioned includes the <code>BuyExecution</code> and <code>DepositAsset</code> instructions.</p> <p>In scenarios where you want to move an asset back to its reserve chain, such as sending xcDOT from Moonbeam to Polkadot, Moonbeam uses the following set of XCM instructions:</p> <ol> <li> <p><code>WithdrawAsset</code> \u2013 executes on Moonbeam, taking the specified token (xcDOT) from the sender</p> </li> <li> <p><code>InitiateReserveWithdraw</code> \u2013 executes on Moonbeam, which, burns the token on Moonbeam (removing the wrapped representation), and sends an XCM message to Polkadot, indicating the tokens should be released there </p> </li> <li> <p><code>WithdrawAsset</code> \u2013 executes on Polkadot, removing the tokens from Moonbeam\u2019s Sovereign account on Polkadot</p> </li> <li> <p><code>ClearOrigin</code> \u2013 gets executed on Polkadot. Clears any origin data (e.g., the Sovereign account on Moonbeam)</p> </li> <li> <p><code>BuyExecution</code> \u2013 Polkadot determines the execution fees and uses part of the DOT being transferred to pay for them</p> </li> <li> <p><code>DepositAsset</code> \u2013 finally, the native DOT tokens are deposited into the specified Polkadot account</p> </li> </ol> <p>To check how the instructions for an XCM message are built to transfer reserve assets to a target chain, such as xcDOT to Polkadot, you can refer to the X-Tokens Open Runtime Module Library repository. You'll want to take a look at the <code>transfer_to_reserve</code> function. You'll notice that it calls <code>WithdrawAsset</code>, then <code>InitiateReserveWithdraw</code> and passes in <code>assets</code>, <code>dest</code>, and <code>xcm</code> as parameters. In particular, the <code>xcm</code> parameter includes the <code>BuyExecution</code> and <code>DepositAsset</code> instructions. If you then head over to the Polkadot GitHub repository, you can find the <code>InitiateReserveWithdraw</code> instruction. The XCM message is constructed by combining the <code>WithdrawAsset</code> and <code>ClearOrigin</code> instructions with the <code>xcm</code> parameter, which as mentioned includes the <code>BuyExecution</code> and <code>DepositAsset</code> instructions.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#rel-chain-xcm-fee-calc","title":"Relay Chain XCM Fee Calculation","text":"<p>Substrate has introduced a weight system that determines how heavy or, in other words, how expensive from a computational cost perspective an extrinsic is. One unit of weight is defined as one picosecond of execution time. When it comes to paying fees, users will pay a transaction fee based on the weight of the call that is being made, in addition to factors such as network congestion.</p> <p>The following sections will break down how to calculate XCM fees for Polkadot and Kusama. It's important to note that Kusama, in particular, uses benchmarked data to determine the total weight costs for XCM instructions and that some XCM instructions might include database reads and writes, which add weight to the call.</p> <p>There are two databases available in Polkadot and Kusama: RocksDB (which is the default) and ParityDB, both of which have their own associated weight costs for each network.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#polkadot","title":"Polkadot","text":"<p>The total weight costs on Polkadot take into consideration database reads and writes in addition to the weight required for a given instruction. Polkadot uses benchmarked weights for instructions, and database read-and-write operations. The breakdown of weight costs for the database operations can be found on the respective repository files for RocksDB (default) and ParityDB.  </p> <p>Now that you are aware of the weight costs for database reads and writes on Polkadot, you can calculate the weight cost for a given instruction using the base weight for instructions.</p> <p>On Polkadot, the benchmarked base weights are broken up into two categories: fungible and generic. Fungible weights are for XCM instructions that involve moving assets, and generic weights are for everything else. You can view the current weights for fungible assets and generic assets directly in the Polkadot Runtime code.</p> <p>With the instruction weight cost established, you can calculate the cost of each instruction in DOT.</p> <p>In Polkadot, the <code>ExtrinsicBaseWeight</code> is set to <code>126,045,000</code> which is mapped to 1/10th of a cent. Where 1 cent is <code>10^10 / 100</code>.</p> <p>Therefore, to calculate the cost of executing an XCM instruction, you can use the following formula:</p> <pre><code>XCM-DOT-Cost = XCMInstrWeight * DOTWeightToFeeCoefficient\n</code></pre> <p>Where <code>DOTWeightToFeeCoefficient</code> is a constant (map to 1 cent), and can be calculated as:</p> <pre><code>DOTWeightToFeeCoefficient = 10^10 / ( 10 * 100 * DOTExtrinsicBaseWeight )\n</code></pre> <p>Now, you can begin to calculate the final fee in DOT, using <code>DOTWeightToFeeCoefficient</code> as a constant and <code>TotalWeight</code> as the variable:</p> <pre><code>XCM-Planck-DOT-Cost = TotalWeight * DOTWeightToFeeCoefficient\nXCM-DOT-Cost = XCM-Planck-DOT-Cost / DOTDecimalConversion\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#kusama","title":"Kusama","text":"<p>The total weight costs on Kusama take into consideration database reads and writes in addition to the weight required for a given instruction. The breakdown of weight costs for the database operations can be found on the respective repository files for RocksDB (default) and ParityDB. </p> <p>On Kusama, the benchmarked base weights are broken up into two categories: fungible and generic. Fungible weights are for XCM instructions that involve moving assets, and generic weights are for everything else. You can view the current weights for fungible assets and generic assets directly in the Kusama Runtime code.</p> <p>With the instruction weight cost established, you can calculate the cost of the instruction in KSM with the <code>ExtrinsicBaseWeight</code> and the weight fee mapping.</p> <p>To calculate the cost of executing an XCM instruction, you can use the following formula:</p> <pre><code>XCM-KSM-Cost = XCMInstrWeight * KSMWeightToFeeCoefficient\n</code></pre> <p>Where <code>KSMWeightToFeeCoefficient</code> is a constant (map to 1 cent), and can be calculated as:</p> <pre><code>KSMWeightToFeeCoefficient = 10^12 / ( 10 * 3000 * KSMExtrinsicBaseWeight )\n</code></pre> <p>Now, you can begin to calculate the final fee in KSM, using <code>KSMWeightToFeeCoefficient</code> as a constant and <code>TotalWeight</code> as the variable:</p> <pre><code>XCM-Planck-KSM-Cost = TotalWeight * KSMWeightToFeeCoefficient\nXCM-KSM-Cost = XCM-Planck-KSM-Cost / KSMDecimalConversion\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#moonbeam-xcm-fee-calc","title":"Moonbeam-based Networks XCM Fee Calculation","text":"<p>Substrate has introduced a weight system that determines how heavy or, in other words, how expensive an extrinsic is from a computational cost perspective. One unit of weight is defined as one picosecond of execution time. When it comes to paying fees, users will pay a transaction fee based on the weight of the call being made, and each parachain can decide how to convert weight to fee. For example, this may account for additional costs related to transaction size and storage.</p> <p>For all Moonbeam-based networks, the generic XCM instructions are benchmarked, while the fungible XCM instructions still use a fixed amount of weight per instruction. Consequently, the total weight cost of the benchmarked XCM instructions considers the number of database reads and writes in addition to the weight required for a given instruction. The Polkadot SDK has a breakdown of the relevant RocksDB database weights.</p> <p>Now you can calculate the weight cost for both fungible and generic XCM instructions using the base weight for instruction and the extra database reads and writes if applicable.</p> <p>For example, the <code>WithdrawAsset</code> instruction is part of the fungible XCM instructions. Therefore, it is not benchmarked, and the total weight cost of the <code>WithdrawAsset</code> instruction is <code>200,000,000</code>, except for when transferring local XC-20s. The total weight cost for the <code>WithdrawAsset</code> instruction for local XC-20s is based on converting Ethereum gas to Substrate weight.</p> <p>The <code>BuyExecution</code> instruction is generic and therefore has a predefined benchmarked weight. You can view its current base weight in the Moonbeam runtime source code. In addition to the base weight, the instruction performs four database reads, which are added to calculate the total weight.</p> <p>You can find all the weight values for all the XCM instructions in the following table, which apply to all Moonbeam-based networks:</p> Benchmarked Instructions Non-Benchmarked Instructions Generic XCM Instructions Fungible XCM Instructions <p>The following sections will break down how to calculate XCM fees for Moonbeam-based networks. There are two main scenarios:</p> <ul> <li>Fees paid in the reserve token (native tokens like GLMR, MOVR, or DEV)</li> <li>Fees paid in external assets (XC-20s)</li> </ul>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#moonbeam-reserve-assets","title":"Fee Calculation for Reserve Assets","text":"<p>For each XCM instruction, the weight units are converted to balance units as part of the fee calculation. The amount of Wei per weight unit for each of the Moonbeam-based networks is as follows:</p> Moonbeam Moonriver Moonbase Alpha 1,250,000 12,500 12,500 <p>This means that on Moonbeam, for example, the formula to calculate the cost of one XCM instruction in the reserve asset is as follows:</p> <pre><code>XCM-Wei-Cost = XCMInstrWeight * WeiPerWeight\nXCM-GLMR-Cost = XCM-Wei-Cost / 10^18\n</code></pre> <p>Therefore, the actual calculation for fungible instructions, for example, is:</p> <pre><code>XCM-Wei-Cost = 200000000 * 1250000\nXCM-GLMR-Cost = 250000000000000 / 10^18\n</code></pre> <p>The total cost is <code>0.00025 GLMR</code> for an XCM instruction on Moonbeam.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#fee-calc-external-assets","title":"Fee Calculation for External Assets","text":"<p>Moonbeam charges fees for external assets based on the weight of the call. Weight is a struct that contains two fields, <code>refTime</code> and <code>proofSize</code>. <code>refTime</code> refers to the amount of computational time that can be used for execution. <code>proofSize</code> refers to the size of the PoV (Proof of Validity) of the Moonbeam block that gets submitted to the Polkadot Relay Chain for validation. Since both <code>refTime</code> and <code>proofSize</code> are integral components of determining a weight, it is impossible to obtain an accurate weight value with just one of these values.</p> <p>You can query the <code>refTime</code> and <code>proofSize</code> of an XCM instruction with the <code>queryXcmWeight</code> method of the <code>xcmPaymentApi</code>. You can do this programmatically or by visiting the Runtime Calls tab of Polkadot.js Apps. The <code>queryXcmWeight</code> method takes an XCM version and instruction has a parameter and returns the corresponding <code>refTime</code> and <code>proofSize</code> values.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#weight-to-gas-mapping","title":"Weight to Gas Mapping","text":"<p>For calls that are derived from EVM operations, such as the <code>DepositAsset</code> instruction which relies on the EVM operation <code>MintInto</code>, you can calculate their respective weight values by multiplying the gas limit by weight multipliers. For <code>refTime</code>, you'll need to multiply the gas limit by <code>25000</code> and for <code>proofSize</code> you'll need to multiply the gas limit by <code>8</code>.  A chart is included below for convenience. </p> Weight Type Multiplier Value Ref Time 25,000 Proof Size 8 <p>To determine the total weight for Alice's transfer of DOT to Moonbeam, you'll need the weight for each of the four XCM instructions required for the transfer. Note that while the first three instructions have specific <code>refTime</code> and <code>proofSize</code> values corresponding to these instructions that can be retrieved via <code>queryXcmWeight</code> method of the <code>xcmPaymentApi</code>, <code>DepositAsset</code> relies on the EVM operation <code>MintInto</code> and a <code>WeightPerGas</code> conversion of <code>25,000</code> per gas. The <code>refTime</code> of <code>DepositAsset</code> can thus be calculated as: </p> <pre><code>155000 gas * 25000 weight per gas = 3875000000\n</code></pre> <p>And the <code>proofSize</code> of <code>DepositAsset</code> can be calculated as:</p> <pre><code>155000 gas * 8 weight per gas = 1240000\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#weight-to-asset-fee-conversion","title":"Weight to Asset Fee Conversion","text":"<p>Once you have the sum of the <code>refTime</code> and <code>proofSize</code> values, you can easily retrieve the required commensurate fee amount. The <code>queryWeightToAssetFee</code> method of the <code>xcmPaymentApi</code> takes a <code>refTime</code>, <code>proofSize</code>, and asset multilocation as parameters and returns the commensurate fee. By providing the amounts obtained above of <code>4,428,242,000</code> <code>refTime</code> and <code>1,259,056</code> <code>proofSize</code>, and the asset multilocation for DOT, we get a fee amount of <code>88,920,522</code> Plank, which is the smallest unit in Polkadot. We can convert this to DOT by dividing by <code>10^10</code> which gets us a DOT fee amount of <code>0.008892</code> DOT. </p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#xcm-payment-api-exanded-examples","title":"XCM Payment API Expanded Examples","text":"<p>The XCM Payment API methods provide various helpful ways to calculate fees, evaluate acceptable fee payment currencies, and more. Remember that in addition to accessing this via API, you can also interact with the XCM Payment API via the Runtime Calls tab of Polkadot.js Apps.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#query-acceptable-fee-payment-assets","title":"Query Acceptable Fee Payment Assets","text":"<p>This function takes the XCM Version as a parameter and returns a list of acceptable fee assets in multilocation form. </p> <pre><code>const allowedAssets =\n  await api.call.xcmPaymentApi.queryAcceptablePaymentAssets(3);\nconsole.log(allowedAssets);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  const allowedAssets =\n    await api.call.xcmPaymentApi.queryAcceptablePaymentAssets(4);\n  console.log(allowedAssets);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#weight-to-asset-fee-conversion","title":"Weight to Asset Fee Conversion","text":"<p>This method converts a weight into a fee for the specified asset. It takes as parameters a weight and an asset multilocation and returns the respective fee amount.</p> <pre><code>const fee = await api.call.xcmPaymentApi.queryWeightToAssetFee(\n  {\n    refTime: 10_000_000_000n,\n    proofSize: 0n,\n  },\n  {\n    V3: {\n      Concrete: { parents: 1, interior: 'Here' },\n    },\n  }\n);\n\nconsole.log(fee);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  const fee = await api.call.xcmPaymentApi.queryWeightToAssetFee(\n    {\n      refTime: 10_000_000_000n,\n      proofSize: 0n,\n    },\n    {\n      V3: {\n        Concrete: { parents: 1, interior: 'Here' },\n      },\n    }\n  );\n\n  console.log(fee);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#query-xcm-weight","title":"Query XCM Weight","text":"<p>This method takes an XCM message as a parameter and returns the weight of the message. </p> <pre><code>const message = { V3: [instr1, instr2] };\n\nconst theWeight = await api.call.xcmPaymentApi.queryXcmWeight(message);\nconsole.log(theWeight);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  const amountToSend = BigInt(1 * 10 ** 12); // Sending 1 token (assuming 12 decimal places)\n  const assetMultiLocation = {\n    parents: 0,\n    interior: { X1: { PalletInstance: 3 } },\n  }; // The asset's location (adjust PalletInstance as needed)\n  const recipientAccount = '0x1234567890abcdef1234567890abcdef12345678'; // The recipient's account on the destination chain\n\n  // 2. XCM Destination (e.g., Parachain ID 2000)\n  const dest = { V3: { parents: 1, interior: { X1: { Parachain: 2000 } } } };\n\n  // 3. XCM Instruction 1: Withdraw the asset from the sender\n  const instr1 = {\n    WithdrawAsset: [\n      {\n        id: { Concrete: assetMultiLocation },\n        fun: { Fungible: amountToSend },\n      },\n    ],\n  };\n\n  // 4. XCM Instruction 2: Deposit the asset into the recipient's account on the destination chain\n  const instr2 = {\n    DepositAsset: {\n      assets: { Wild: 'All' }, // Sending all withdrawn assets (in this case, 1 token)\n      beneficiary: {\n        parents: 0,\n        interior: { X1: { AccountKey20: { key: recipientAccount } } },\n      },\n    },\n  };\n\n  // 5. Build the XCM Message\n  const message = { V3: [instr1, instr2] };\n\n  const theWeight = await api.call.xcmPaymentApi.queryXcmWeight(message);\n  console.log(theWeight);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/computed-origins/","title":"Computed Origin Accounts","text":""},{"location":"builders/interoperability/xcm/remote-execution/computed-origins/#introduction","title":"Introduction","text":"<p>The Computed Origin, previously referred to as the multilocation-derivative account, is an account computed when executing remote calls via XCM.</p> <p>Computed origins are keyless (the private key is unknown). Consequently, Computed Origins can only be accessed through XCM extrinsics from the origin account. In other words, the origin account is the only account that can initiate transactions on your Computed Origin account, and if you lose access to your origin account, you\u2019ll also lose access to your Computed Origin account.</p> <p>The Computed Origin is calculated from the origin that is being used to execute the XCM in the destination chain. By default, this is the Sovereign account of the source chain in the destination chain. This origin can be mutated by the <code>DescendOrigin</code> XCM instruction. However, the destination chain can decide whether or not to use the newly mutated origin for the execution of the XCM. On Moonbeam, the Computed Origin account is used to execute the XCM.</p> <p>Moonbeam-based networks follow the Computed Origins standard set by Polkadot, that is, through a <code>blake2</code> hash of a data structure that depends on the origin of the XCM message. However, because Moonbeam uses Ethereum-styled accounts, Computed Origins are truncated to 20 bytes.</p>"},{"location":"builders/interoperability/xcm/remote-execution/computed-origins/#origin-conversion","title":"The Origin Conversion","text":"<p>The origin conversion for a remote call happens when the <code>Transact</code> instruction gets executed. The new origin on the target chain is the one that pays for the fees for XCM execution on the target chain.</p> <p>For example, from the relay chain, the <code>DescendOrigin</code> instruction is natively injected by the XCM Pallet. In the case of Moonbase Alpha's relay chain (based on Westend), it has the following format (a multilocation junction):</p> <pre><code>{\n  DescendOrigin: {\n    X1: {\n      AccountId32: {\n        network: { westend: null },\n        id: decodedAddress,\n      },\n    },\n  },\n}\n</code></pre> <p>Where the <code>decodedAddress</code> corresponds to the address of the account who signed the transaction on the relay chain (in a decoded 32-byte format). You can make sure that your address is properly decoded by using the following snippet, which will decode an address if needed and ignore it if not:</p> <pre><code>import { decodeAddress } from '@polkadot/util-crypto';\nconst decodedAddress = decodeAddress('INSERT_ADDRESS');\n</code></pre> <p>When the XCM instruction gets executed in Moonbeam (Moonbase Alpha in this example), the origin will have mutated to the following multilocation:</p> <pre><code>{\n  DescendOrigin: {\n    parents: 1,\n    interior: {\n      X1: {\n        AccountId32: {\n          network: { westend: null },\n          id: decodedAddress,\n        },\n      },\n    },\n  },\n}\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/computed-origins/#calculate-computed-origin","title":"How to Calculate the Computed Origin","text":"<p>You can easily calculate the Computed Origin account through the <code>calculate-multilocation-derivative-account</code> or the <code>calculate-remote-origin</code> script in the xcm-tools repository.</p> <p>The script accepts the following inputs:</p> <ul> <li><code>--ws-provider</code> or <code>-w</code> - corresponds to the endpoint to use to fetch the Computed Origin. This should be the endpoint for the target chain</li> <li><code>--address</code> or <code>--a</code> - specifies the source chain address that is sending the XCM message</li> <li><code>--para-id</code> or <code>--p</code> - (optional) specifies the parachain ID of the origin chain of the XCM message. It is optional, as the XCM message might come from the relay chain (no parachain ID). Or parachains can act as relay chains for other parachains</li> <li><code>--parents</code> - (optional) corresponds to the parents value of the source chain in relation to the target chain. If you're calculating the Computed Origin account for an account on the relay chain, this value would be <code>1</code>. If left out, the parents value defaults to <code>0</code></li> </ul> <p>To use the script, you can take the following steps:</p> <ol> <li>Clone the xcm-tools repo</li> <li>Run <code>yarn</code> to install the necessary packages</li> <li> <p>Run the script</p> <pre><code>yarn calculate-multilocation-derivative-account \\\n--ws-provider INSERT_RPC_ENDPOINT \\\n--address INSERT_ORIGIN_ACCOUNT \\\n--para-id INSERT_ORIGIN_PARACHAIN_ID_IF_APPLIES \\\n--parents INSERT_PARENTS_VALUE_IF_APPLIES\n</code></pre> </li> </ol> <p>You can also calculate the Computed Origin account using the <code>multilocationToAddress</code> function of the XCM Utilities Precompile.</p>"},{"location":"builders/interoperability/xcm/remote-execution/computed-origins/#calculate-the-computed-origin-on-moonbeam","title":"Calculate the Computed Origin on a Moonbeam-based Network","text":"<p>For example, to calculate the Computed Origin on Moonbase Alpha for Alice's relay chain account, which is <code>5DV1dYwnQ27gKCKwhikaw1rz1bYdvZZUuFkuduB4hEK3FgDT</code>, you would use the following command to run the script:</p> <pre><code>yarn calculate-multilocation-derivative-account \\\n--ws-provider wss://wss.api.moonbase.moonbeam.network \\\n--address 5DV1dYwnQ27gKCKwhikaw1rz1bYdvZZUuFkuduB4hEK3FgDT \\\n--parents 1\n</code></pre> <p>Note</p> <p>For Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>The returned output includes the following values:</p> Name Value Origin Chain Encoded Address <code>5DV1dYwnQ27gKCKwhikaw1rz1bYdvZZUuFkuduB4hEK3FgDT</code> Origin Chain Decoded Address <code>0x3ec5f48ad0567c752275d87787954fef72f557b8bfa5eefc88665fa0beb89a56</code> Multilocation Received in Destination Chain <code>{\"parents\":1,\"interior\":{\"x1\":{\"accountId32\":{\"network\": {\"westend\":null},\"id\":\"0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0afb2e78fdbbbf4ce26c2556c\"}}}}</code> Computed Origin Account (32 bytes) <code>0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0afb2e78fdbbbf4ce26c2556c</code> Computed Origin Account (20 bytes) <code>0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0</code> <p>Consequently, for this example, Alice's Computed Origin account on Moonbase Alpha is <code>0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0</code>. Note that Alice is the only person who can access this account through a remote transact from the relay chain, as she is the owner of its private keys and the Computed Origin account is keyless.</p>"},{"location":"builders/interoperability/xcm/remote-execution/overview/","title":"Remote Execution via XCM","text":""},{"location":"builders/interoperability/xcm/remote-execution/overview/#introduction","title":"Introduction","text":"<p>The Cross-Consensus Message (XCM) format defines how messages can be sent between interoperable blockchains. This format opens the door to sending an XCM message that executes an arbitrary set of bytes in a Moonbeam-based network, the relay chain, or other parachains in the Polkadot/Kusama ecosystems.</p> <p>Remote execution via XCM opens a new set of possibilities for cross-chain interactions, from chains executing actions on other chains to users performing remote actions without switching chains.</p> <p>This page covers the fundamentals of XCM remote execution. If you want to learn how to perform remote execution via XCM, please refer to the Remote Execution via the Substrate API or the Remote Execution via the Ethereum API guides.</p>"},{"location":"builders/interoperability/xcm/remote-execution/overview/#execution-origin","title":"Execution Origin","text":"<p>Generally speaking, all transactions have an origin, which is where a call comes from. Ethereum transactions have only one origin type, the <code>msg.sender</code>, which is the account that initiated the transaction.</p> <p>Substrate-based transactions are more complex, as they can have different origins with different privilege levels. This is similar to having an EVM smart contract call with a specific <code>require</code> statement in which the call must come from an allowed address. In contrast, these privilege levels are programmed in the Substrate-based runtime itself.</p> <p>Origins are super important across different components of the Substrate runtime and, hence, the Moonbeam runtime. For example, they define the authority level they inherit in the on-chain governance implementation.</p> <p>During the execution of an XCM message, the origin defines the context in which the XCM is being executed. By default, the XCM is executed by the source chain's Sovereign account in the destination chain. This Polkadot-specific property of having remote origins that are calculated when executing XCM is known as Computed Origins (formerly known as Multilocation Derivative Accounts).</p> <p>Depending on the destination chain's configuration, including the <code>DescendOrigin</code> XCM instruction can mutate the origin from which the XCM message is executed. This property is significant for remote XCM execution, as the action being executed considers the context of the newly mutated origin and not the source chain's Sovereign account.</p>"},{"location":"builders/interoperability/xcm/remote-execution/overview/#xcm-instructions-remote-execution","title":"XCM Instructions for Remote Execution","text":"<p>The core XCM instructions required to perform remote execution on Moonbeam (as an example) via XCM are the following:</p> <ul> <li><code>DescendOrigin</code> - (optional) gets executed in Moonbeam. Mutates the origin to create a new Computed Origin that represents a keyless account controlled via XCM by the sender in the source chain</li> <li><code>WithdrawAsset</code> - gets executed in Moonbeam. Takes funds from the Computed Origin</li> <li><code>BuyExecution</code> - gets executed in Moonbeam. Uses the funds taken by the previous XCM instruction to pay for the XCM execution, including the remote call</li> <li><code>Transact</code> - gets executed in Moonbeam. Executes the arbitrary bytes provided in the XCM instruction</li> </ul> <p>The XCM instructions detailed above can be complemented by other XCM instructions to handle certain scenarios, like failure on execution, more accurately. One example is the inclusion of <code>SetAppendix</code>, <code>RefundSurplus</code>, and <code>Deposit</code>.</p>"},{"location":"builders/interoperability/xcm/remote-execution/overview/#general-remote-execution-via-xcm-flow","title":"General Remote Execution via XCM Flow","text":"<p>A user initiates a transaction in the source chain through a pallet that builds the XCM with at least the required XCM instructions for remote execution. The transaction is executed in the source chain, which sends an XCM message with the given instructions to the destination chain.</p> <p>The XCM message arrives at the destination chain, which executes it. It is executed with the source chain's Sovereign account as a Computed Origin by default. One example that uses this type of origin is when chains open or accept an HRMP channel on the relay chain.</p> <p>If the XCM message included a <code>DescendOrigin</code> instruction, the destination chain may mutate the origin to calculate a new Computed Origin (as is the case with Moonbeam-based networks).</p> <p>Next, <code>WithdrawAsset</code> takes funds from the Computed Origin (either a Sovereign account or mutated), which are then used to pay for the XCM execution through the <code>BuyExecution</code> XCM instruction. Note that on both instructions, you need to specify which asset you want to use. In addition, you must include the bytes to be executed in the amount of execution to buy.</p> <p>Lastly, <code>Transact</code> executes an arbitrary set of bytes that correspond to a pallet and function in the destination chain. You have to specify the type of origin to use (typically <code>SovereignAccount</code>) and the weight required to execute the bytes (similar to gas in the Ethereum realm).</p> <p></p>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/","title":"Remote EVM Calls Through XCM","text":""},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#introduction","title":"Introduction","text":"<p>The XCM Transactor Pallet provides a simple interface to perform remote cross-chain calls through XCM. However, this does not consider the possibility of doing remote calls to Moonbeam's EVM, only to Substrate-specific pallets (functionalities).</p> <p>Moonbeam's EVM is only accessible through the Ethereum Pallet. Among many other things, this pallet handles certain validations of transactions before getting them into the transaction pool. Then, it performs another validation step before inserting a transaction from the pool into a block. Lastly, it provides the interface through a <code>transact</code> function to execute a validated transaction. All these steps follow the same behavior as an Ethereum transaction in terms of structure and signature scheme.</p> <p>However, calling the Ethereum Pallet directly through an XCM <code>Transact</code> is not feasible. Mainly because the dispatcher account for the remote EVM call (referred to as <code>msg.sender</code> in Ethereum) does not sign the XCM transaction on the Moonbeam side. The XCM extrinsic is signed in the origin chain, and the XCM executor dispatches the call, through the <code>Transact</code> instruction, from a known caller linked to the sender in the origin chain. In this context, the Ethereum Pallet will not be able to verify the signature and, ultimately, validate the transaction.</p> <p>To this end, the Ethereum XCM Pallet was introduced. It acts as a middleware between the XCM <code>Transact</code> instruction and the Ethereum Pallet, as special considerations need to be made when performing EVM calls remotely through XCM. The pallet performs the necessary checks and validates the transaction. Next, the pallet calls the Ethereum Pallet to dispatch the transaction to the EVM. Due to how the EVM is accessed, there are some differences between regular and remote EVM calls.</p> <p>The happy path for both regular and remote EVM calls through XCM is portrayed in the following diagram:</p> <p></p> <p>This guide will go through the differences between regular and remote EVM calls. In addition, it will show you how to perform remote EVM calls through the extrinsic exposed by the Ethereum XCM pallet.</p> <p>Note</p> <p>Remote EVM calls are done through the XCM Transactor Pallet. Therefore, it is recommended to get familiar with XCM Transactor concepts before trying to perform remote EVM calls through XCM.</p> <p>Note that remote calls to Moonbeam's EVM through XCM are still being actively developed. In addition, developers must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, it is essential to test XCM features on a TestNet before moving to a production environment.</p>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#differences-regular-remote-evm","title":"Differences between Regular and Remote EVM Calls through XCM","text":"<p>As explained in the introduction, the paths that regular and remote EVM calls take to get to the EVM are quite different. The main reason behind this difference is the dispatcher of the transaction.</p> <p>A regular EVM call has an apparent sender who signs the Ethereum transaction with its private key. The signature, of ECDSA type, can be verified with the signed message and the <code>r-s</code> values that are produced by the signing algorithm. Ethereum signatures use an additional variable called <code>v</code>, which is the recovery identifier.</p> <p>With remote EVM calls, the signer signs an XCM transaction in another chain. Moonbeam receives that XCM message, which follows the conventional remote execution via XCM form:</p> <ul> <li><code>DescendOrigin</code> (optional)</li> <li><code>WithdrawAsset</code></li> <li><code>BuyExecution</code></li> <li><code>Transact</code></li> </ul> <p>XCM execution happens through a Computed Origin account mechanism, which by default uses the source chain's Sovereign account in the destination chain. If <code>DescendOrigin</code> is included, Moonbeam will mutate the origin of the XCM call to a keyless account that a user from the source chain can control remotely via XCM. The remote EVM call is dispatched from that keyless account (or a related proxy). Therefore, because the transaction is not signed, it does not have the real <code>v-r-s</code> values of the signature, but <code>0x1</code> instead.</p> <p>Since remote EVM calls do not have the actual <code>v-r-s</code> values of the signature, there could be collision problems with the EVM transaction hash, as it is calculated as the keccak256 hash of the signed transaction blob. In consequence, if two accounts with the same nonce submit the same transaction object, they will end up with the same EVM transaction hash. Therefore, all remote EVM transactions use a global nonce that is attached to the Ethereum XCM Pallet.</p> <p>Another significant difference is in terms of the gas price. The fee for remote EVM calls is charged at an XCM execution level. Consequently, the gas price at an EVM level is zero, and the EVM will not charge for the execution itself. This can also be seen in the receipt of a remote EVM call transaction. Accordingly, the XCM message must be configured so that the <code>BuyExecution</code> buys enough weight to cover the gas cost.</p> <p>The last difference is in terms of the gas limit. Ethereum uses a gas-metered system to moderate the amount of execution that can be done in a block. On the contrary, Moonbeam uses a weight-based system in which each call is characterized by the time it takes to execute in a block. Each unit of weight corresponds to one picosecond of execution time.</p> <p>As of runtime 2900, the configuration of the XCM queue suggests that XCM messages should be executable within the following weight units:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>125,000,000,000 (0.125 seconds of block execution time)\n</code></pre> <pre><code>500,000,000,000 (0.5 seconds of block execution time)\n</code></pre> <pre><code>500,000,000,000 (0.5 seconds of block execution time)\n</code></pre> <p>Note</p> <p>Prior to runtime 2900, the weight limit of XCM messages across all networks was <code>20,000,000,000</code> weight units (this is, <code>0.02</code> seconds of block execution time).</p> <p>Suppose the XCM message can't be executed due to the lack of execution time in a given block, and the weight requirement exceeds the above limits. In that case, the XCM message will be marked as <code>overweight</code> and only be executable through democracy.</p> <p>The maximum weight limit per XCM message constrains the gas limit available for remote EVM calls through XCM. For all Moonbeam-based networks, there is a ratio of <code>25,000</code> units of gas per unit of weight (<code>WEIGHT_REF_TIME_PER_SECOND</code> / <code>GAS_PER_SECOND</code>). Considering that you need some XCM message weight to execute the XCM instructions, a remote EVM call might consume\u00a02,000,000,000\u00a0units. The following equation can be used to determine the maximum gas units for a remote EVM call:</p> <pre><code>Maximum Gas Units = (Maximum Weight Units - Remote EVM Weight Units) / 25,000\n</code></pre> <p>Therefore, the maximum gas limit you can provide for a remote EVM call can be calculated:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>Maximum Gas Units = (125,000,000,000 - 2,000,000,000) / 25,000\nMaximum Gas Units = 4,920,000\n</code></pre> <pre><code>Maximum Gas Units = (500,000,000,000 - 2,000,000,000) / 25,000\nMaximum Gas Units = 19,920,000\n</code></pre> <pre><code>Maximum Gas Units = (500,000,000,000 - 2,000,000,000) / 25,000\nMaximum Gas Units = 19,920,000\n</code></pre> <p>Note</p> <p>These values are subject to change in the future.</p> <p>In summary, these are the main differences between regular and remote EVM calls:</p> <ul> <li>Remote EVM calls use a global nonce (owned by the Ethereum XCM Pallet) instead of a nonce per account</li> <li>The <code>v-r-s</code> values of the signature for remote EVM calls are <code>0x1</code>. The sender can't be retrieved from the signature through standard methods (for example, through ECRECOVER). Nevertheless, the <code>from</code> is included in both the transaction receipt and when getting the transaction by hash (using the Ethereum JSON-RPC)</li> <li>The gas price for all remote EVM calls is zero. The EVM execution is charged at an XCM execution level and not at an EVM level</li> <li>The current maximum gas limit you can set for a remote EVM call is different, as outlined above</li> </ul>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#ethereum-xcm-pallet-interface","title":"Ethereum XCM Pallet Interface","text":""},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#extrinsics","title":"Extrinsics","text":"<p>The Ethereum XCM Pallet provides the following extrinsics (functions) that can be called by the <code>Transact</code> instruction to access Moonbeam's EVM through XCM:</p> transact(xcmTransaction) \u2014 function to remotely call the EVM through XCM. Only callable through the execution of an XCM message ParametersPolkadot.js API Example <ul> <li><code>xcmTransaction</code> - the Ethereum transaction details of the call that will be dispatched. The <code>xcmTransaction</code> structure, which is versioned, contains the following:<ul> <li><code>gasLimit</code> - the gas limit for the Ethereum transaction</li> <li><code>action</code> - the action to be executed, which provides two options: <code>Call</code> and <code>Create</code>. The current implementation of the Ethereum XCM Pallet does not support the <code>CREATE</code> operation. Therefore, you can't deploy a smart contract through remote EVM calls. For <code>Call</code>, you'll need to specify the contract address you're interacting with</li> <li><code>value</code> - the amount of native tokens to send</li> <li><code>input</code> - the encoded call data of the contract interaction</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst xcmTransaction = {\n  V2: {\n    gasLimit: INSERT_GAS_LIMIT,\n    action: { Call: 'INSERT_CONTRACT_ADDRESS_TO_CALL' },\n    value: INSERT_VALUE,\n    input: 'INSERT_CONTRACT_CALL_DATA',\n  },\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.ethereumXcm.transact(xcmTransaction);\n};\n\nmain();      \n</code></pre> <p>Note</p> <p>In the following sections, you'll learn exactly how to get the Ethereum transaction call data and build an XCM message using this extrinsic.</p> transactThroughProxy(transactAs, xcmTransaction) \u2014 function to remotely call the EVM through XCM and be dispatched from a given account with known keys (the <code>msg.sender</code>) ParametersPolkadot.js API Example <ul> <li><code>xcmTransaction</code> - the Ethereum transaction details of the call that will be dispatched. The <code>xcmTransaction</code> structure, which is versioned, contains the following:<ul> <li><code>gasLimit</code> - the gas limit for the Ethereum transaction</li> <li><code>action</code> - the action to be executed, which provides two options: <code>Call</code> and <code>Create</code>. The current implementation of the Ethereum XCM Pallet does not support the <code>CREATE</code> operation. Therefore, you can't deploy a smart contract through remote EVM calls. For <code>Call</code>, you'll need to specify the contract address you're interacting with</li> <li><code>value</code> - the amount of native tokens to send</li> <li><code>input</code> - the encoded call data of the contract interaction</li> </ul> </li> <li><code>xcmTransactAs</code> - the account from which the remote EVM call will be dispatched (the <code>msg.sender</code>). This account needs to have set the Computed Origin account as a proxy of type <code>any</code> on Moonbeam, or the remote EVM call will fail. Transaction fees are still paid by the Computed Origin account</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst xcmTransaction = {\n  V2: {\n    gasLimit: INSERT_GAS_LIMIT,\n    action: { Call: 'INSERT_CONTRACT_ADDRESS_TO_CALL' },\n    value: INSERT_VALUE,\n    input: 'INSERT_CONTRACT_CALL_DATA',\n  },\n};\nconst xcmTransactAs = 'INSERT_COMPUTED_ORIGIN_PROXY_ADDRESS';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.ethereumXcm.transactThroughProxy(\n    xcmTransaction,\n    xcmTransactAs\n  );\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#build-remote-evm-call-xcm","title":"Building a Remote EVM Call Through XCM","text":"<p>This guide covers building an XCM message for remote EVM calls using the XCM Pallet from the relay chain to Moonbase Alpha. More specifically, it will use the <code>transact</code> function. The steps to use the <code>transactThroughProxy</code> function are identical. However, you'll need to provide the <code>transactAs</code> account and ensure that this account has set the Computed Origin account as a proxy of type <code>any</code> on Moonbase Alpha.</p> <p>Note</p> <p>When using <code>transactThroughProxy</code>, the EVM call is dispatched by the <code>transactAs</code> account you provide, acting as the <code>msg.sender</code>, as long as this account has set the Computed Origin account as a proxy of type <code>any</code> in the Moonbeam-based network you are using. However, transaction fees are still paid by the Computed Origin account, so you need to ensure it has enough funds to cover them.</p> <p>The process for building and performing the remote execution can be summarized as follows:</p> <ol> <li>Calculate the call data for the EVM call that will be performed on Moonbase Alpha</li> <li>Use the EVM call data to generate the call data for the <code>transact</code> extrinsic of the Ethereum XCM Pallet on Moonbase Alpha</li> <li>Build the XCM message on the relay chain, which will include the <code>WithdrawAsset</code>, <code>BuyExecution</code>, and <code>Transact</code> instructions. In the <code>Transact</code> instruction, you'll use the Ethereum XCM <code>transact</code> call data</li> <li>Using Alice's account on the relay chain, you'll send the XCM message via the <code>send</code> extrinsic of the XCM Pallet</li> <li>Alice's Computed Origin account on Moonbase Alpha will dispatch the EVM call data</li> </ol>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#ethereumxcm-check-prerequisites","title":"Checking Prerequisites","text":"<p>To be able to send the call from the relay chain, you need the following:</p> <ul> <li>An account on the relay chain with funds (UNIT) to pay for the transaction fees. You can acquire some xcUNIT by swapping for DEV tokens (Moonbase Alpha's native token) on Moonbeam-Swap, a demo Uniswap-V2 clone on Moonbase Alpha, and then send them to the relay chain. Additionally, you can contact us on Discord to get some UNIT tokens directly</li> <li>The address of your Computed Origin account. Please refer to the Computed Origin guide to learn how to calculate your Computed Origin address</li> <li>To fund your Computed Origin account. The account must have enough DEV tokens (or GLMR/MOVR for Moonbeam/Moonriver) to cover the cost of the XCM execution of the remote EVM call. Note that this is the account from which the remote EVM call will be dispatched (the <code>msg.sender</code>). Consequently, the account must satisfy whatever conditions are required for the EVM call to be executed correctly. For example, hold any relevant ERC-20 token if you are doing an ERC-20 transfer</li> </ul> <p>Note</p> <p>Suppose you are using the <code>transactThroughProxy</code> function. In that case, the <code>transactAs</code> account must satisfy whatever conditions are required for the EVM call to be executed correctly, as it acts as the <code>msg.sender</code>. However, the Computed Origin account is the one that needs to hold the DEV tokens (or GLMR/MOVR for Moonbeam/Moonriver) to cover the cost of the XCM execution of the remote EVM call.</p>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#ethereumxcm-transact-data","title":"Ethereum XCM Transact Call Data","text":"<p>Before you send the XCM message from the relay chain to Moonbase Alpha, you need to get the encoded call data that will be dispatched through the execution of the <code>Transact</code> XCM instruction.</p> <p>In this example, you'll be interacting with the <code>transact</code> function of the Ethereum XCM Pallet, which accepts an <code>xcmTransaction</code> as a parameter.</p> <p>The <code>xcmTransaction</code> parameter requires you to define the <code>gasLimit</code>, <code>action</code>, <code>value</code>, and <code>input</code>.</p> <p>For the action to be executed, you'll be performing a contract interaction with a simple incrementer contract, which is located at <code>0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8</code>. You'll be calling the <code>increment</code> function, which has no input argument and will increase the value of the <code>number</code> by one. It will also store the block's timestamp in which the function is executed to the <code>timestamp</code> variable.</p> <p>The encoded call data for the <code>increment</code> function is <code>0xd09de08a</code>, which is the function selector and is the first eight hexadecimal characters (or 4 bytes) of the keccak256 hash of <code>increment()</code>. If you choose to interact with a function that has input parameters, they also need to be encoded. The easiest way to get the encoded call data is to emulate a transaction either in Remix or Moonscan. Then, in Metamask, check the HEX DATA: 4 BYTES selector under the HEX tab to get the call data. You don't need to sign the transaction.</p> <p>Now that you have the encoded contract interaction data, you can determine the gas limit for this call using the <code>eth_estimateGas</code> JSON-RPC method. For this example, you can set the gas limit to <code>155000</code>.</p> <p>For the value, you can set it to <code>0</code> since this particular interaction does not need DEV (or GLMR/MOVR for Moonbeam/Moonriver). For an interaction that requires DEV, you'll need to modify this value accordingly.</p> <p>Now that you have all of the components required for the <code>xcmTransaction</code> parameter, you can build it:</p> <pre><code>const xcmTransaction = {\n  V2: {\n    gasLimit: 155000,\n    action: { Call: '0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8' },\n    value: 0,\n    input: '0xd09de08a',\n  },\n};\n</code></pre> <p>Next, you can write the script to get the encoded call data for the transaction. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The Moonbase Alpha endpoint URL to create the provider</li> <li>The value for the <code>xcmTransaction</code> parameter of the <code>transact</code> function</li> </ul> </li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>ethereumXcm.transact</code> extrinsic with the <code>xcmTransaction</code> value</li> <li>Get the encoded call data for the extrinsic. You don't need to sign and send the transaction</li> </ol> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\n// 1. Input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst xcmTransaction = {\n  V2: {\n    gasLimit: 155000,\n    action: { Call: '0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8' },\n    value: 0,\n    input: '0xd09de08a',\n  },\n};\n\nconst getEncodedCalldata = async () =&gt; {\n  // 2. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Create the extrinsic\n  const tx = api.tx.ethereumXcm.transact(xcmTransaction);\n\n  // 4. Get the encoded call data\n  const encodedCall = tx.method.toHex();\n  console.log(`Encoded Calldata: ${encodedCall}`);\n\n  api.disconnect();\n};\n\ngetEncodedCalldata();\n</code></pre> <p>Note</p> <p>You can view an example of the output of the above script on Polkadot.js Apps using the following encoded call data: <code>0x260001785d02000000000000000000000000000000000000000000000000000000000000a72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8000000000000000000000000000000000000000000000000000000000000000010d09de08a00</code>.</p> <p>You'll use the encoded call data in the <code>Transact</code> instruction in the following section.</p>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#estimate-weight-required-at-most","title":"Estimate Weight Required at Most","text":"<p>When using the <code>Transact</code> instruction, you'll need to define the <code>requireWeightAtMost</code> field, which is the required weight for the transaction. This field accepts two arguments: the <code>refTime</code> and <code>proofSize</code>. The <code>refTime</code> is the amount of computational time that can be used for execution, and the <code>proofSize</code> is the amount of storage in bytes that can be used.</p> <p>To get an estimate for the <code>refTime</code> and <code>proofSize</code>, you can use the <code>paymentInfo</code> method of the Polkadot.js API. Since these weights are required for the <code>Transact</code> call data, you can extend the script from the previous section to add in the call to <code>paymentInfo</code>.</p> <p>The <code>paymentInfo</code> method accepts the same parameters you would normally pass to the <code>.signAndSend</code> method, which is the sending account and, optionally, some additional values such as a nonce or signer.</p> <p>To modify the encoded call data script, you'll need to add Alice's Computed Origin address and use it to call the <code>tx.paymentInfo</code> method.</p> Modified script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\n// 1. Input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst xcmTransaction = {\n  V2: {\n    gasLimit: 155000,\n    action: { Call: '0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8' },\n    value: 0,\n    input: '0xd09de08a',\n  },\n};\n\nconst getEncodedCalldata = async () =&gt; {\n  // 2. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Create the extrinsic\n  const tx = api.tx.ethereumXcm.transact(xcmTransaction);\n\n  // 4. Estimate the required weight\n  const alice = '0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0';\n  const info = await tx.paymentInfo(alice);\n  console.log(`Required Weight: ${info.weight}`);\n\n  api.disconnect();\n};\n\ngetEncodedCalldata();\n</code></pre> <p>The script, at the time of writing, returns an estimate of <code>3900000000</code> for <code>refTime</code> and <code>9687</code> for <code>proofSize</code>.</p>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#build-xcm-remote-evm","title":"Building the XCM for Remote XCM Execution","text":"<p>Now that you've generated the call data for the EVM call, you're going to use the XCM Pallet on the relay chain to perform the remote execution. To do so, you'll use the <code>send</code> function, which accepts two parameters:</p> <ul> <li><code>dest</code> - the XCM versioned multilocation representing a chain in the ecosystem where the XCM message is being sent to (the target chain)</li> <li><code>message</code> - the SCALE-encoded versioned XCM message to be executed</li> </ul> <p>You can start assembling these parameters by taking the following steps:</p> <ol> <li> <p>Build the multilocation of the destination, which is Moonbase Alpha:</p> <pre><code>const dest = { V4: { parents: 0, interior: { X1: [{ Parachain: 1000 }] } } };\n</code></pre> </li> <li> <p>Build the <code>WithdrawAsset</code> instruction, which will require you to define:</p> <ul> <li>The multilocation of the DEV token on Moonbase Alpha</li> <li>The amount of DEV tokens to withdraw</li> </ul> <pre><code>const instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 10000000000000000n }, // 0.01 DEV\n    },\n  ],\n};\n</code></pre> </li> <li> <p>Build the <code>BuyExecution</code> instruction, which will require you to define:</p> <ul> <li>The multilocation of the DEV token on Moonbase Alpha</li> <li>The amount of DEV tokens to buy for execution</li> <li>The weight limit</li> </ul> <pre><code>const instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 10000000000000000n }, // 0.01 DEV\n    },\n    { Unlimited: null },\n  ],\n};\n</code></pre> </li> <li> <p>Build the <code>Transact</code> instruction, which will require you to define:</p> <ul> <li>The origin kind</li> <li>The required weight for the transaction, which you calculated in the Estimate Weight Required at Most section</li> <li>The encoded call data, which you generated in the Ethereum XCM Transact Call Data section</li> </ul> <pre><code>const instr3 = {\n  Transact: {\n    originKind: 'SovereignAccount',\n    requireWeightAtMost: { refTime: 3900000000n, proofSize: 9687n },\n    call: {\n      encoded:\n        '0x260001785d02000000000000000000000000000000000000000000000000000000000000a72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8000000000000000000000000000000000000000000000000000000000000000010d09de08a00',\n    },\n  },\n};\n</code></pre> </li> <li> <p>Combine the XCM instructions into a versioned XCM message:</p> <pre><code>const message = { V4: [instr1, instr2, instr3] };\n</code></pre> </li> </ol> <p>Now that you have the values for each of the parameters, you can write the script for the execution. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The relay chain endpoint URL to create the provider</li> <li>The values for each of the parameters of the <code>send</code> function</li> </ul> </li> <li>Create a Keyring instance that will be used to send the transaction</li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>xcmPallet.send</code> extrinsic with the <code>dest</code> and <code>message</code> values</li> <li>Send the transaction using the <code>signAndSend</code> extrinsic and the Keyring instance you created in the second step</li> </ol> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a JavaScript file.</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\n// 1. Input data\nconst providerWsURL =\n  'wss://relay.api.moonbase.moonbeam.network';\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst dest = { V4: { parents: 0, interior: { X1: [{ Parachain: 1000 }] } } };\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 10000000000000000n }, // 0.01 DEV\n    },\n  ],\n};\nconst instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 10000000000000000n }, // 0.01 DEV\n    },\n    { Unlimited: null },\n  ],\n};\nconst instr3 = {\n  Transact: {\n    originKind: 'SovereignAccount',\n    requireWeightAtMost: { refTime: 3900000000n, proofSize: 9687n },\n    call: {\n      encoded:\n        '0x260001785d02000000000000000000000000000000000000000000000000000000000000a72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8000000000000000000000000000000000000000000000000000000000000000010d09de08a00',\n    },\n  },\n};\nconst message = { V4: [instr1, instr2, instr3] };\n\nconst sendXcmMessage = async () =&gt; {\n  // 2. Create Keyring instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'sr25519' });\n  const alice = keyring.addFromUri(privateKey);\n\n  // 3. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 4. Create the extrinsic\n  const tx = api.tx.xcmPallet.send(dest, message);\n\n  // 5. Send the transaction\n  const txHash = await tx.signAndSend(alice);\n  console.log(`Submitted with hash ${txHash}`);\n\n  api.disconnect();\n};\n\nsendXcmMessage();\n</code></pre> <p>Note</p> <p>You can view an example of the output of the above script on Polkadot.js Apps using the following encoded call data: <code>0x630004000100a10f040c000400010403001300008a5d784563011300010403001300008a5d784563010006010300286bee007901260001581501000000000000000000000000000000000000000000000000000000000000a72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8000000000000000000000000000000000000000000000000000000000000000010d09de08a00</code>.</p> <p>Once the transaction is processed, you can check the relevant extrinsics and events in the relay chain and Moonbase Alpha.</p> <p>In the relay chain, the extrinsic is <code>xcmPallet.send</code>, and the associated event is <code>xcmPallet.Sent</code> (among others related to the fee). In Moonbase Alpha, the XCM execution happens within the <code>parachainSystem.setValidationData</code> extrinsic, and there are multiple associated events that can be highlighted:</p> <ul> <li>parachainSystem.DownwardMessagesReceived \u2014 event that signals that a message from the relay chain was received. With the current XCM implementation, messages from other parachains will show the same event</li> <li>balances.Withdraw \u2014 event related to the withdrawing of tokens to pay for the execution of the call. Note that the <code>who</code> address is the Computed Origin account calculated before</li> <li>ethereum.Executed \u2014 event associated with the execution of the remote EVM call. It provides the <code>from</code>, <code>to</code>, <code>transactionHash</code> (calculated with the non-standard signature and global pallet nonce), and the <code>exitReason</code>. Currently, some common EVM errors, like out of gas, will show <code>Reverted</code> in the exit reason</li> <li>polkadotXcm.AssetsTrapped \u2014 event that is emitted when part of the tokens withdrawn from the account (for fees) are not used. Generally, when there are leftover tokens in the registry that are not allocated to an account. These tokens are temporarily burned and can be retrieved through a democracy proposal. A combination of both <code>RefundSurplus</code> and <code>DepositAsset</code> XCM instructions can prevent assets from getting trapped</li> </ul> <p>To verify that the remote EVM call through XCM was successful, you can head to the contract's page in Moonscan and verify the new value for the number and its timestamp.</p>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#remote-evm-call-txhash","title":"Remote EVM Call Transaction by Hash","text":"<p>As mentioned before, there are some differences between regular and remote XCM EVM calls. Some main differences can be seen when retrieving the transaction by its hash using the Ethereum JSON-RPC.</p> <p>To do so, you first need to retrieve the transaction hash you want to query. For this example, you can use the transaction hash from the previous section, which is 0x753588d6e59030eeffd31aabccdd0fb7c92db836fcaa8ad71512cf3a7d0cb97f. Open the terminal, and execute the following command:</p> <pre><code>curl --location --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"eth_getTransactionByHash\",\n    \"params\": [\"0x753588d6e59030eeffd31aabccdd0fb7c92db836fcaa8ad71512cf3a7d0cb97f\"]\n  }\n'\n</code></pre> <p>If the JSON-RPC request is sent correctly, the response should look like this:</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"result\": {\n        \"hash\": \"0x753588d6e59030eeffd31aabccdd0fb7c92db836fcaa8ad71512cf3a7d0cb97f\",\n        \"nonce\": \"0x129\",\n        \"blockHash\": \"0xeb8222567e434215f472f0c53f68a606c77ea8f475e5fbc3a5b715db6cce8887\",\n        \"blockNumber\": \"0x46c268\",\n        \"transactionIndex\": \"0x0\",\n        \"from\": \"0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0\",\n        \"to\": \"0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8\",\n        \"value\": \"0x0\",\n        \"gasPrice\": \"0x0\",\n        \"maxFeePerGas\": \"0x0\",\n        \"maxPriorityFeePerGas\": \"0x0\",\n        \"gas\": \"0x25d78\",\n        \"input\": \"0xd09de08a\",\n        \"creates\": null,\n        \"raw\": \"0x02eb820507820129808083025d7894a72f549a1a12b9b49f30a7f3aeb1f4e96389c5d88084d09de08ac0010101\",\n        \"publicKey\": \"0x14745b9075ac0f0426c61c9a2895f130ea6f3b964e8f49cefdb4e2d248306f19396361d877f8b9ad60a94a5ec28325a1b9baa2ae59e7a9f6fe1731caec130ab4\",\n        \"chainId\": \"0x507\",\n        \"standardV\": \"0x1\",\n        \"v\": \"0x1\",\n        \"r\": \"0x1\",\n        \"s\": \"0x1\",\n        \"accessList\": [],\n        \"type\": \"0x2\"\n    },\n    \"id\": 1\n}\n</code></pre> <p>Note that the <code>v-r-s</code> values are set to <code>0x1</code>, and the gas price-related fields are set to <code>0x0</code>. In addition, the <code>nonce</code> field corresponds to a global nonce of the Ethereum XCM Pallet, and not the transaction count of the dispatcher account.</p> <p>Note</p> <p>You might be able to find some transaction hash collisions in the Moonbase Alpha TestNet, as early versions of remote EVM calls through XCM did not use a global nonce of the Ethereum XCM Pallet.</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/","title":"Using the XCM Transactor Pallet for Remote Execution","text":""},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#introduction","title":"Introduction","text":"<p>XCM messages are comprised of a series of instructions that are executed by the Cross-Consensus Virtual Machine (XCVM). Combinations of these instructions result in predetermined actions such as cross-chain token transfers and, more interestingly, remote cross-chain execution. Remote execution involves executing operations or actions on one blockchain from another blockchain while maintaining the integrity of the sender's identity and permissions.</p> <p>Typically, XCM messages are sent from the root origin (that is, SUDO or through governance), which is not ideal for projects that want to leverage remote cross-chain calls via a simple transaction. The XCM Transactor Pallet makes it easy to transact on a remote chain through either the Sovereign account, which should only be allowed through governance, or a Computed Origin account via a simple transaction from the source chain.</p> <p>This guide will show you how to use the XCM Transactor Pallet to send XCM messages from a Moonbeam-based network to other chains in the ecosystem. In addition, you'll also learn how to use the XCM Transactor Precompile to perform the same actions via the Ethereum API.</p> <p>Note that there are still limitations to what you can remotely execute through XCM messages.</p> <p>Developers must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, it is essential to test XCM features on a TestNet before moving to a production environment.</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcm-transactor-pallet-interface","title":"XCM Transactor Pallet Interface","text":""},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#extrinsics","title":"Extrinsics","text":"<p>The XCM Transactor Pallet provides the following extrinsics (functions):</p> hrmpManage(action, fee, weightInfo) - manages HRMP operations related to opening, accepting, and closing an HRMP channel <p>On Moonbeam or Moonriver, this function must be executed via governance through the General Admin or the Root Track. On Moonbase Alpha or a Moonbeam development node, this function can also be executed via sudo.</p> ParametersPolkadot.js API Example <ul> <li><code>action</code> - the action to execute. Can be either <code>InitOpen</code>, <code>Accept</code>, <code>Close</code>, or <code>Cancel</code></li> <li><code>fee</code> - the asset to be used for fees. This contains the <code>currency</code> and the <code>feeAmount</code>:<ul> <li><code>currency</code> -  defines how you are specifying the token to use to pay for the fees, which can be either of the following:<ul> <li><code>AsCurrencyId</code> - the currency ID of the asset to use for the fees. The currency ID can be either:<ul> <li><code>SelfReserve</code> - uses the native asset</li> <li><code>ForeignAsset</code> - uses an external XC-20. It requires you to specify the asset ID of the XC-20</li> <li><code>LocalAssetReserve</code> - deprecated - use Local XC-20s instead via the <code>Erc20</code> currency type</li> <li><code>Erc20</code> - uses a local XC-20. It requires you to specify the contract address of the local XC-20</li> </ul> </li> <li><code>AsMultiLocation</code> - the XCM versioned multilocation for the asset to use for the fees</li> </ul> </li> <li><code>feeAmount</code> - (optional) the amount to use for fees</li> </ul> </li> <li><code>weightInfo</code> - the weight information to be used. The <code>weightInfo</code> structure contains the following:<ul> <li><code>transactRequiredWeightAtMost</code> \u2014 the weight required to perform the execution of the <code>Transact</code> call.  The <code>transactRequiredWeightAtMost</code> structure contains the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> <li><code>overallWeight</code> \u2014 (optional) the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> can be defined as either:<ul> <li><code>Unlimited</code> - allows an unlimited amount of weight that can be purchased</li> <li><code>Limited</code> - limits the amount of weight that can be purchased by defining the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> </ul> </li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst action = 'InitOpen'; // Or 'Accept', 'Close', or 'Cancel'\nconst fee = {\n  currency: {\n    AsCurrencyId: { ForeignAsset: INSERT_ASSET_ID },\n  },\n  feeAmount: INSERT_FEE_AMOUNT,\n};\nconst weightInfo = {\n  transactRequiredWeightAtMost: {\n    refTime: INSERT_REF_TIME,\n    proofSize: INSERT_PROOF_SIZE,\n  },\n  overallWeight: { Unlimited: null },\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.hrmpManage(action, fee, weightInfo);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\nmain();\n</code></pre> removeFeePerSecond(assetLocation) \u2014 remove the fee per second information for a given asset in its reserve chain <p>On Moonbeam or Moonriver, this function must be executed via governance through the General Admin or the Root Track. On Moonbase Alpha or a Moonbeam development node, this function can also be executed via sudo.</p> ParametersPolkadot.js API Example <ul> <li><code>assetLocation</code> - the XCM versioned multilocation of the asset to remove the fee per second information for</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst assetLocation = {\n  V4: {\n    parents: INSERT_PARENTS,\n    interior: INSERT_INTERIOR,\n  },\n};;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.removeFeePerSecond(assetLocation);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\nmain();\n</code></pre> removeTransactInfo(location) \u2014 remove the transact information for a given chain <p>On Moonbeam or Moonriver, this function must be executed via governance through the General Admin or the Root Track. On Moonbase Alpha or a Moonbeam development node, this function can also be executed via sudo.</p> ParametersPolkadot.js API Example <ul> <li><code>location</code> - the XCM versioned multilocation of a given chain that you wish to remove the transact information for</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst assetLocation = {\n  V4: {\n    parents: INSERT_PARENTS,\n    interior: INSERT_INTERIOR,\n  },\n};;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.removeTransactInfo(assetLocation);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\nmain();\n</code></pre> setFeePerSecond(assetLocation, feePerSecond) \u2014 sets the fee per second for a given asset on its reserve chain. The fee per second information typically relates to the cost of executing XCM instructions <p>On Moonbeam or Moonriver, this function must be executed via governance through the General Admin or the Root Track. On Moonbase Alpha or a Moonbeam development node, this function can also be executed via sudo.</p> ParametersPolkadot.js API Example <ul> <li><code>assetLocation</code> - the XCM versioned multilocation of the asset to remove the fee per second information for</li> <li><code>feePerSecond</code> - the number of token units per second of XCM execution that will be charged to the sender of the extrinsic when executing XCM instructions</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst assetLocation = {\n  V4: {\n    parents: INSERT_PARENTS,\n    interior: INSERT_INTERIOR,\n  },\n};\nconst feePerSecond = INSERT_FEE_PER_SECOND;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.setFeePerSecond(assetLocation, feePerSecond);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\n\nmain();\n</code></pre> setTransactInfo(location, transactExtraWeight, maxWeight) \u2014 sets the transact information for a given chain. The transact information typically includes details about the weight required for executing XCM instructions as well as the maximum weight allowed for remote XCM execution on the target chain <p>On Moonbeam or Moonriver, this function must be executed via governance through the General Admin or the Root Track. On Moonbase Alpha or a Moonbeam development node, this function can also be executed via sudo.</p> ParametersPolkadot.js API Example <ul> <li><code>location</code> - the XCM versioned multilocation of a given chain that you wish to set the transact information for</li> <li><code>transactExtraWeight</code> \u2014 the weight to cover execution fees of the XCM instructions (<code>WithdrawAsset</code>, <code>BuyExecution</code>, and <code>Transact</code>), which is estimated to be at least 10% over what the remote XCM instructions execution uses. The <code>transactExtraWeight</code> structure contains the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> <li><code>maxWeight</code> \u2014 maximum weight units allowed for the remote XCM execution. The <code>maxWeight</code> structure also contains <code>refTime</code> and <code>proofSize</code></li> <li><code>transactExtraWeightSigned</code> \u2014 (optional) the weight to cover execution fees of the XCM instructions (<code>DescendOrigin</code>, <code>WithdrawAsset</code>, <code>BuyExecution</code>, and <code>Transact</code>), which is estimated to be at least 10% over what the remote XCM instructions execution uses. The <code>transactExtraWeightSigned</code> structure also contains <code>refTime</code> and <code>proofSize</code></li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst location = INSERT_MULTILOCATION;\nconst transactExtraWeight = {\n  refTime: INSERT_REF_TIME,\n  proofSize: INSERT_PROOF_SIZE,\n};\nconst maxWeight = {\n  refTime: INSERT_REF_TIME,\n  proofSize: INSERT_PROOF_SIZE,\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.setTransactInfo(\n    location,\n    transactExtraWeight,\n    maxWeight\n  );\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\n\nmain();\n</code></pre> transactThroughSigned(destination, fee, call, weightInfo, refund) \u2014 sends an XCM message with instructions to remotely execute a call in the destination chain. The remote call will be signed and executed by a new account that the destination parachain must compute. Moonbeam-based networks follow the Computed Origins standard set by Polkadot ParametersPolkadot.js API Example <ul> <li><code>dest</code> - the XCM versioned multilocation for a chain in the ecosystem where the XCM message is being sent to (the target chain)</li> <li><code>fee</code> - the asset to be used for fees. This contains the <code>currency</code> and the <code>feeAmount</code>:<ul> <li><code>currency</code> -  defines how you are specifying the token to use to pay for the fees, which can be either of the following:<ul> <li><code>AsCurrencyId</code> - the currency ID of the asset to use for the fees. The currency ID can be either:<ul> <li><code>SelfReserve</code> - uses the native asset</li> <li><code>ForeignAsset</code> - uses an external XC-20. It requires you to specify the asset ID of the XC-20</li> <li><code>LocalAssetReserve</code> - deprecated - use Local XC-20s instead via the <code>Erc20</code> currency type</li> <li><code>Erc20</code> - uses a local XC-20. It requires you to specify the contract address of the local XC-20</li> </ul> </li> <li><code>AsMultiLocation</code> - the XCM versioned multilocation for the asset to use for the fees</li> </ul> </li> <li><code>feeAmount</code> - (optional) the amount to use for fees</li> </ul> </li> <li><code>call</code> - encoded call data of the call that will be executed in the target chain</li> <li><code>weightInfo</code> - the weight information to be used. The <code>weightInfo</code> structure contains the following:<ul> <li><code>transactRequiredWeightAtMost</code> \u2014 the weight required to perform the execution of the <code>Transact</code> call.  The <code>transactRequiredWeightAtMost</code> structure contains the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> <li><code>overallWeight</code> \u2014 (optional) the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> can be defined as either:<ul> <li><code>Unlimited</code> - allows an unlimited amount of weight that can be purchased</li> <li><code>Limited</code> - limits the amount of weight that can be purchased by defining the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> </ul> </li> </ul> </li> <li><code>refund</code> - a boolean indicating whether or not to add the <code>RefundSurplus</code> and <code>DepositAsset</code> instructions to the XCM message to refund any leftover fees </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst dest = {\n  V4: {\n    parents: INSERT_PARENTS,\n    interior: INSERT_INTERIOR,\n  },\n};\nconst fee = {\n  currency: {\n    AsCurrencyId: { ForeignAsset: INSERT_ASSET_ID },\n  },\n  feeAmount: INSERT_FEE_AMOUNT,\n};\nconst call = 'INSERT_ENCODED_CALL_DATA';\nconst weightInfo = {\n  transactRequiredWeightAtMost: {\n    refTime: INSERT_REF_TIME,\n    proofSize: INSERT_PROOF_SIZE,\n  },\n  overallWeight: { Unlimited: null },\n};\nconst refund = INSERT_BOOLEAN_FOR_REFUND;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.transactThroughSigned(\n    dest,\n    fee,\n    call,\n    weightInfo,\n    refund\n  );\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\n\nmain();      \n</code></pre> <p>Note</p> <p>In the following sections, you'll learn exactly how to retrieve all of the arguments needed to build and send an XCM message using this extrinsic.</p> transactThroughSovereign(dest, feePayer, fee, call, originKind, weightInfo, refund) \u2014 sends an XCM message with instructions to remotely execute a given call at the given destination. The remote call will be signed by the origin parachain Sovereign account (who pays the fees), but the transaction is dispatched from a given origin. The XCM Transactor Pallet calculates the fees for the remote execution and charges the given account the estimated amount in the corresponding XC-20 token ParametersPolkadot.js API Example <ul> <li><code>dest</code> - the XCM versioned multilocation for a chain in the ecosystem where the XCM message is being sent to (the target chain)</li> <li><code>feePayer</code> - (optional) the address that will pay for the remote XCM execution in the corresponding XC-20 token. If you don't specify the <code>feePayer</code>, the XCM execution fees will be paid by the Sovereign account on the destination chain</li> <li><code>fee</code> - the asset to be used for fees. This contains the <code>currency</code> and the <code>feeAmount</code>:<ul> <li><code>currency</code> -  defines how you are specifying the token to use to pay for the fees, which can be either of the following:<ul> <li><code>AsCurrencyId</code> - the currency ID of the asset to use for the fees. The currency ID can be either:<ul> <li><code>SelfReserve</code> - uses the native asset</li> <li><code>ForeignAsset</code> - uses an external XC-20. It requires you to specify the asset ID of the XC-20</li> <li><code>LocalAssetReserve</code> - deprecated - use Local XC-20s instead via the <code>Erc20</code> currency type</li> <li><code>Erc20</code> - uses a local XC-20. It requires you to specify the contract address of the local XC-20</li> </ul> </li> <li><code>AsMultiLocation</code> - the XCM versioned multilocation for the asset to use for the fees</li> </ul> </li> <li><code>feeAmount</code> - (optional) the amount to use for fees</li> </ul> </li> <li><code>call</code> - encoded call data of the call that will be executed in the target chain</li> <li><code>originKind</code> \u2014 dispatcher of the remote call in the destination chain. There are four types of dispatchers available: <code>Native</code>, <code>SovereignAccount</code>, <code>Superuser</code>, or <code>Xcm</code></li> <li><code>weightInfo</code> - the weight information to be used. The <code>weightInfo</code> structure contains the following:<ul> <li><code>transactRequiredWeightAtMost</code> \u2014 the weight required to perform the execution of the <code>Transact</code> call.  The <code>transactRequiredWeightAtMost</code> structure contains the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> <li><code>overallWeight</code> \u2014 (optional) the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> can be defined as either:<ul> <li><code>Unlimited</code> - allows an unlimited amount of weight that can be purchased</li> <li><code>Limited</code> - limits the amount of weight that can be purchased by defining the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> </ul> </li> </ul> </li> <li><code>refund</code> - a boolean indicating whether or not to add the <code>RefundSurplus</code> and <code>DepositAsset</code> instructions to the XCM message to refund any leftover fees </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst dest = {\n  V4: {\n    parents: INSERT_PARENTS,\n    interior: INSERT_INTERIOR,\n  },\n};\nconst fee = {\n  currency: {\n    AsCurrencyId: { ForeignAsset: INSERT_ASSET_ID },\n  },\n  feeAmount: INSERT_FEE_AMOUNT,\n};\nconst feePayer = 'INSERT_ADDRESS_RESPONSIBLE_FOR_FEES';\nconst call = 'INSERT_ENCODED_CALL_DATA';\nconst originKind = 'INSERT_ORIGIN_KIND';\nconst weightInfo = {\n  transactRequiredWeightAtMost: {\n    refTime: INSERT_REF_TIME,\n    proofSize: INSERT_PROOF_SIZE,\n  },\n  overallWeight: { Unlimited: null },\n};\nconst refund = INSERT_BOOLEAN_FOR_REFUND;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.transactThroughSovereign(\n    dest,\n    feePayer,\n    fee,\n    call,\n    originKind,\n    weightInfo,\n    refund\n  );\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#storage-methods","title":"Storage Methods","text":"<p>The XCM Transactor Pallet includes the following read-only storage method:</p> destinationAssetFeePerSecond(location) - returns the fee per second for a given asset ParametersReturnsPolkadot.js API Example <ul> <li><code>location</code> - (optional) the XCM versioned multilocation for a specific destination asset</li> </ul> <p>A number representing the value for fee per second of the given asset. This value may be returned in a different format depending on the chain and how they store their data. You can use the <code>@polkadot/util</code> library for a variety of conversions, for example, to convert a hex value to a big integer using the <code>hexToBigInt</code> method.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n10000000000000\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst location = {\n  parents: INSERT_PARENTS,\n  interior: INSERT_INTERIOR,\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const feePerSecond =\n    await api.query.xcmTransactor.destinationAssetFeePerSecond(location);\n\n  if (feePerSecond.isSome) {\n    const data = feePerSecond.unwrap();\n    console.log(data.toJSON());\n  }\n};\n\nmain();\n</code></pre> palletVersion() \u2014 returns current pallet version from storage ParametersReturnsPolkadot.js API Example <p>None</p> <p>A number representing the current version of the pallet.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n0\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const palletVersion = await api.query.xcmTransactor.palletVersion();\n};\n\nmain();\n</code></pre> transactInfoWithWeightLimit(location) \u2014 returns the transact information for a given multilocation ParametersReturnsPolkadot.js API Example <ul> <li><code>location</code> - (optional) the XCM versioned multilocation for a specific destination asset</li> </ul> <p>The transact information object.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n{\n  transactExtraWeight: { refTime: 3000000000, proofSize: 131072 },\n  maxWeight: { refTime: 20000000000, proofSize: 131072 },\n  transactExtraWeightSigned: { refTime: 4000000000, proofSize: 131072 },\n}\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst location = {\n  parents: INSERT_PARENTS,\n  interior: INSERT_INTERIOR,\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const transactInfoWithWeightLimit =\n    await api.query.xcmTransactor.transactInfoWithWeightLimit(location);\n\n  if (transactInfoWithWeightLimit.isSome) {\n    const data = transactInfoWithWeightLimit.unwrap();\n    console.log(data.toJSON());\n  }\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#constants","title":"Pallet Constants","text":"<p>The XCM Transactor Pallet includes the following read-only functions to obtain pallet constants:</p> baseXcmWeight() - returns the base XCM weight required for execution, per XCM instruction ReturnsPolkadot.js API Example <p>The base XCM weight object.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n{ refTime: 200000000, proofSize: 0 }\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const baseXcmWeight = api.consts.xcmTransactor.baseXcmWeight;\n  console.log(baseXcmWeight.toJSON());\n};\n\nmain();\n</code></pre> selfLocation() - returns the multilocation of the chain ReturnsPolkadot.js API Example <p>The self-location multilocation object.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n{ parents: 0, interior: { here: null } }\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const selfLocation = api.consts.xcmTransactor.selfLocation;\n  console.log(selfLocation.toJSON());\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcm-instructions-for-remote-execution","title":"XCM Instructions for Remote Execution","text":"<p>The relevant XCM instructions to perform remote execution through XCM are, but are not limited to:</p> <ul> <li><code>DescendOrigin</code> - gets executed in the target chain. It mutates the origin on the target chain to match the origin on the source chain, ensuring execution on the target chain occurs on behalf of the same entity initiating the XCM message on the source chain</li> <li><code>WithdrawAsset</code> - gets executed in the target chain. Removes assets and places them into a holding register</li> <li><code>BuyExecution</code> - gets executed in the target chain. Takes the assets from holding to pay for execution fees. The fees to pay are determined by the target chain</li> <li><code>Transact</code> - gets executed in the target chain. Dispatches encoded call data from a given origin, allowing for the execution of specific operations or functions</li> </ul>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcmtransactor-transact-through-signed","title":"Transact through a Computed Origin Account","text":"<p>This section covers building an XCM message for remote execution using the XCM Transactor Pallet, specifically with the <code>transactThroughSigned</code> function. This function uses a Computed Origin account on the destination chain to dispatch the remote call.</p> <p>The example in this section uses a destination parachain that is not publicly available, so you won't be able to follow along exactly. You can modify the example as needed for your own use case.</p> <p>Note</p> <p>You need to ensure that the call you are going to execute remotely is allowed in the destination chain!</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcmtransactor-signed-check-prerequisites","title":"Checking Prerequisites","text":"<p>To be able to send the extrinsics in this section, you need to have:</p> <ul> <li>An account in the origin chain with funds</li> <li>Funds in the Computed Origin account on the target chain. To learn how to calculate the address of the Computed Origin account, please refer to the How to Calculate the Computed Origin documentation</li> </ul> <p>For this example, the following accounts will be used:</p> <ul> <li>Alice's account in the origin parachain (Moonbase Alpha): <code>0x44236223aB4291b93EEd10E4B511B37a398DEE55</code></li> <li>Her Computed Origin address in the target parachain (Parachain 888): <code>0x5c27c4bb7047083420eddff9cddac4a0a120b45c</code></li> </ul>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcm-transact-through-signed","title":"Building the XCM","text":"<p>Since you'll be interacting with the <code>transactThroughSigned</code> function of the XCM Transactor Pallet, you'll need to assemble the values for the <code>dest</code>, <code>fee</code>, <code>call</code>, <code>weightInfo</code>, and <code>refund</code> parameters. To do so, you can take the following steps:</p> <ol> <li> <p>Define the destination multilocation, which will target parachain 888</p> <pre><code>const privateKey = 'INSERT_PRIVATE_KEY';\nconst dest = {\n  V4: {\n    parents: 1,\n    interior: { X1: [{ Parachain: 888 }] },\n  },\n</code></pre> </li> <li> <p>Define the <code>fee</code> information, which will require you to define the currency and set the fee amount</p> External XC-20sLocal XC-20s <pre><code>const fee = {\n  currency: {\n    AsCurrencyId: { ForeignAsset: 35487752324713722007834302681851459189n },\n  },\n  feeAmount: 50000000000000000n,\n};\n</code></pre> <pre><code>const fee = {\n  currency: {\n    AsCurrencyId: { Erc20: { contractAddress: ERC_20_ADDRESS} },\n  },\n  feeAmount: 50000000000000000n,\n};\n</code></pre> </li> <li> <p>Define the <code>call</code> that will be executed in the destination chain, which is the encoded call data of the pallet, method, and input to be called. It can be constructed in Polkadot.js Apps (which must be connected to the destination chain) or using the Polkadot.js API. For this example, the inner call is a simple balance transfer of 1 token of the destination chain to Alice's account there</p> <pre><code>const call = '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\n</code></pre> </li> <li> <p>Set the <code>weightInfo</code>, which includes the weight specific to the inner call (<code>transactRequiredWeightAtMost</code>) and the optional overall weight of the transact plus XCM execution (<code>overallWeight</code>). For each parameter, you can follow these guidelines:</p> <ul> <li>For <code>transactRequiredAtMost</code>, you can set <code>refTime</code> to <code>1000000000</code> weight units and <code>proofSize</code> to <code>40000</code></li> <li>For <code>overallWeight</code>, the value must be the total of <code>transactRequiredWeightAtMost</code> plus the weight needed to cover the execution costs for the XCM instructions in the destination chain. If you do not provide this value, the pallet will use the element in storage (if it exists) and add it to <code>transactRequiredWeightAtMost</code>. For this example, you can set the <code>overallWeight</code> to <code>Unlimited</code>, which removes the need to know how much weight the destination chain will require to execute the XCM</li> </ul> <pre><code>const weightInfo = {\n  transactRequiredWeightAtMost: { refTime: 1000000000n, proofSize: 40000n },\n  overallWeight: { Unlimited: null },\n};\n</code></pre> <p>Note</p> <p>For accurate estimates of the <code>refTime</code> and <code>proofSize</code> figures for <code>transactRequiredAtMost</code>, you can use the <code>paymentInfo</code> method of the Polkadot.js API.</p> </li> <li> <p>To refund any leftover XCM fees, you can set the <code>refund</code> value to <code>true</code>. Otherwise, set it to <code>false</code></p> <pre><code>const refund = true;\n</code></pre> </li> </ol>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#sending-the-xcm","title":"Sending the XCM","text":"<p>Now that you have the values for each of the parameters, you can write the script for the transaction. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The Moonbase Alpha endpoint URL to create the provider</li> <li>The values for each of the parameters of the <code>transactThroughSigned</code> function</li> </ul> </li> <li>Create a Keyring instance that will be used to send the transaction</li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>xcmTransactor.transactThroughSigned</code> extrinsic with the <code>dest</code>, <code>fee</code>, <code>call</code>, <code>weightInfo</code>, and <code>refund</code> values</li> <li>Send the transaction using the <code>signAndSend</code> extrinsic and the Keyring instance you created in the second step</li> </ol> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a JavaScript file.</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\n// 1. Provide input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst dest = {\n  V4: {\n    parents: 1,\n    interior: { X1: [{ Parachain: 888 }] },\n  },\n};\nconst fee = {\n  currency: {\n    AsCurrencyId: { ForeignAsset: 35487752324713722007834302681851459189n },\n  },\n  feeAmount: 50000000000000000n,\n};\nconst call = '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\nconst weightInfo = {\n  transactRequiredWeightAtMost: { refTime: 1000000000n, proofSize: 40000n },\n  overallWeight: { Unlimited: null },\n};\nconst refund = true;\n\nconst transactThroughSigned = async () =&gt; {\n  // 2. Create Keyring instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'ethereum' });\n  const alice = keyring.addFromUri(privateKey);\n\n  // 3. Create Substrate API provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 4. Craft the extrinsic\n  const tx = api.tx.xcmTransactor.transactThroughSigned(\n    dest,\n    fee,\n    call,\n    weightInfo,\n    refund\n  );\n\n  // 5. Send the transaction\n  const txHash = await tx.signAndSend(alice);\n  console.log(`Submitted with hash ${txHash}`);\n\n  api.disconnect();\n};\n\ntransactThroughSigned();\n</code></pre> <p>Note</p> <p>You can view an example of the above script, which sends one token to Alice's Computed Origin account on parachain 888, on Polkadot.js Apps using the following encoded calldata: <code>0x210604010100e10d00017576e5e612ff054915d426c546b1b21a010000c52ebca2b10000000000000000007c030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d02286bee02710200010001</code>.</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#transact-through-computed-origin-fees","title":"XCM Transact through Computed Origin Fees","text":"<p>When transacting through the Computed Origin account, the transaction fees are paid by the same account from which the call is dispatched, which is a Computed Origin account in the destination chain. Consequently, the Computed Origin account must hold the necessary funds to pay for the entire execution. Note that the destination token, for which fees are paid, does not need to be registered as an XC-20 in the origin chain.</p> <p>To estimate the amount of tokens Alice's Computed Origin account will need to execute the remote call, you need to check the transact information specific to the destination chain. You can use the following script to get the transact information for parachain 888:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\n\nconst location = { parents: 1, interior: { X1: [{ Parachain: 888 }] } };\n\nconst main = async () =&gt; {\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  const transactInfoWithWeightLimit =\n    await api.query.xcmTransactor.transactInfoWithWeightLimit(location);\n\n  if (transactInfoWithWeightLimit.isSome) {\n    const data = transactInfoWithWeightLimit.unwrap();\n    const transactExtraWeightSigned =\n      data.toJSON().transactExtraWeightSigned.refTime;\n    console.log(transactExtraWeightSigned);\n  }\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> <p>The response shows that the <code>transactExtraWeightSigned</code> is <code>400,000,000</code>. This weight is needed to execute the four XCM instructions for this remote call in that specific destination chain. Next, you need to find out how much the destination chain charges per weight of XCM execution in reference to the asset's price. Previously, this was done by sourcing a units per second value. However, this method has been replaced by calculating a relative price. Relative price refers to how many units of the foreign asset correspond to one unit of the native token (GLMR or MOVR) from a value (i.e., price) perspective. For example, if the foreign asset is worth $5 and GLMR is worth $0.25, the relative price would be 0.05. However, we must scale the result to 18 decimals to correspond to the Wei units used. In this case, the relative price would be <code>50000000000000000</code>.</p> <p>You can calculate the relative price with a script in the XCM Tools repo. The script is also reproduced below: </p> Calculate Relative Price <pre><code>import axios from 'axios';\nimport chalk from 'chalk';\n\n// CoinGecko IDs for the networks\nconst NETWORK_IDS = {\n  GLMR: 'moonbeam',\n  MOVR: 'moonriver',\n};\n\nasync function calculateRelativePrice(\n  assetPrice: number,\n  network: 'GLMR' | 'MOVR'\n): Promise&lt;string&gt; {\n  try {\n    // Fetch the native token price from CoinGecko\n    const response = await axios.get(\n      `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[network]}&amp;vs_currencies=usd`\n    );\n\n    const nativeTokenPrice = response.data[NETWORK_IDS[network]].usd;\n\n    // Calculate relative price with 18 decimal places\n    // Formula: (nativeTokenPrice / assetPrice) * 10^18\n    // This gives us how many units of the asset we need to equal 1 unit of native token\n    const relativePrice = (nativeTokenPrice / assetPrice) * Math.pow(10, 18);\n\n    // Return as string to preserve precision\n    return relativePrice.toFixed(0);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Failed to calculate relative price: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\nfunction validateInput(\n  price: string,\n  network: string\n): { assetPrice: number; network: 'GLMR' | 'MOVR' } {\n  // Validate price\n  const assetPrice = parseFloat(price);\n  if (isNaN(assetPrice) || assetPrice &lt;= 0) {\n    throw new Error('Price must be a positive number');\n  }\n\n  // Validate network\n  const upperNetwork = network.toUpperCase() as 'GLMR' | 'MOVR';\n  if (!['GLMR', 'MOVR'].includes(upperNetwork)) {\n    throw new Error('Network must be either GLMR or MOVR');\n  }\n\n  return { assetPrice, network: upperNetwork };\n}\n\nfunction printUsage() {\n  console.log('\\nUsage:');\n  console.log('npx ts-node relative-price-calculator.ts &lt;price&gt; &lt;network&gt;');\n  console.log('\\nExample:');\n  console.log('npx ts-node relative-price-calculator.ts 0.25 GLMR');\n  console.log('\\nParameters:');\n  console.log('price   - The price of your asset in USD');\n  console.log('network - Either GLMR or MOVR');\n}\n\nasync function main() {\n  try {\n    // Get command line arguments\n    const [, , price, network] = process.argv;\n\n    // Check if help flag is passed\n    if (price === '--help' || price === '-h') {\n      printUsage();\n      return;\n    }\n\n    // Check if required arguments are provided\n    if (!price || !network) {\n      console.error('Error: Missing required arguments');\n      printUsage();\n      process.exit(1);\n    }\n\n    // Validate inputs\n    const { assetPrice, network: validNetwork } = validateInput(price, network);\n\n    console.log(\n      `\\nCalculating relative price for asset worth $${assetPrice} against ${validNetwork}...`\n    );\n    const relativePrice = await calculateRelativePrice(\n      assetPrice,\n      validNetwork\n    );\n    const nativeTokenPrice = (\n      await axios.get(\n        `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[validNetwork]}&amp;vs_currencies=usd`\n      )\n    ).data[NETWORK_IDS[validNetwork]].usd;\n\n    const decimalRatio = nativeTokenPrice / assetPrice;\n\n    console.log(`\\nResults:`);\n    console.log(`Asset Price: $${assetPrice}`);\n    console.log(`Network: ${validNetwork}`);\n    console.log(`Native Token Price (from CoinGecko): $${nativeTokenPrice}`);\n    console.log(`\\nRelative Price Analysis:`);\n    console.log(\n      `1 ${validNetwork} is equal to approximately ${decimalRatio.toFixed(\n        3\n      )} of your specified token.`\n    );\n    console.log(\n      `With 18 decimals, 1 ${validNetwork} or in WEI, 1000000000000000000 is equal to a relative price of ${relativePrice} units of your token`\n    );\n    console.log(chalk.bold(`\\nRelative Price: ${relativePrice}`));\n    console.log(\n      `\\nThe relative price you should specify in asset registration steps is ${relativePrice}\\n`\n    );\n  } catch (error) {\n    console.error('\\nError:', error instanceof Error ? error.message : error);\n    process.exit(1);\n  }\n}\n\nmain();\n</code></pre> <p>Note that the relative price value is related to the cost estimated in the relay chain XCM fee calculation section or to the one shown in the units per weight section if the target is another parachain. You'll need to find the correct value to ensure that the amount of tokens the Computed Origin account holds is correct. Calculating the associated XCM execution fee is as simple as multiplying the <code>transactExtraWeightSigned</code> times the <code>relativePrice</code> (for an estimation):</p> <pre><code>XCM-Wei-Token-Cost = transactExtraWeightSigned * relativePrice\nXCM-Token-Cost = XCM-Wei-Token-Cost / DecimalConversion\n</code></pre> <p>Therefore, the actual calculation for one XCM Transactor transact through derivative call is:</p> <pre><code>XCM-Wei-Token-Cost = 400000000 * 50000000000000000\nXCM-Token-Cost = 20000000000000 / 10^18\n</code></pre> <p>The cost of transacting through a Computed Origin is <code>0.00002 TOKEN</code>. Note that this does not include the cost of the call being remotely executed, only XCM execution fees.</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/","title":"Using the XCM Transactor Precompile for Remote Execution","text":"<p>XCM messages are comprised of a series of instructions that are executed by the Cross-Consensus Virtual Machine (XCVM). Combinations of these instructions result in predetermined actions such as cross-chain token transfers and, more interestingly, remote cross-chain execution. Remote execution involves executing operations or actions on one blockchain from another blockchain while maintaining the integrity of the sender's identity and permissions.</p> <p>Typically, XCM messages are sent from the root origin (that is, SUDO or through governance), which is not ideal for projects that want to leverage remote cross-chain calls via a simple transaction. The XCM Transactor Pallet makes it easy to transact on a remote chain through either the Sovereign account, which should only be allowed through governance, or a Computed Origin account via a simple transaction from the source chain.</p> <p>However, the XCM Transactor Pallet is coded in Rust and is normally not accessible from the Ethereum API side of Moonbeam. As such, Moonbeam introduced the XCM Transactor Precompile, which is a Solidity interface that allows you to interact directly with the Substrate pallet using the Ethereum API.</p> <p>This guide will show you how to use the XCM Transactor Precompile to send XCM messages from a Moonbeam-based network to other chains in the ecosystem.</p> <p>Note that there are still limitations to what you can remotely execute through XCM messages.</p> <p>Developers must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, it is essential to test XCM features on a TestNet before moving to a production environment.</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#precompile-address","title":"XCM Transactor Precompile Contract Address","text":"<p>There are several versions of the XCM Transactor Precompile. V1 will be deprecated in the near future, so all implementations must migrate to the newer interfaces.</p> <p>The XCM Transactor Precompiles are located at the following addresses:</p> MoonbeamMoonriverMoonbase Alpha Version Address V1 <pre><code>0x0000000000000000000000000000000000000806</code></pre> V2 <pre><code>0x000000000000000000000000000000000000080d</code></pre> V3 <pre><code>0x0000000000000000000000000000000000000817</code></pre> Version Address V1 <pre><code>0x0000000000000000000000000000000000000806</code></pre> V2 <pre><code>0x000000000000000000000000000000000000080d</code></pre> V3 <pre><code>0x0000000000000000000000000000000000000817</code></pre> Version Address V1 <pre><code>0x0000000000000000000000000000000000000806</code></pre> V2 <pre><code>0x000000000000000000000000000000000000080d</code></pre> V3 <pre><code>0x0000000000000000000000000000000000000817</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcmtrasactor-solidity-interface","title":"The XCM Transactor Solidity Interface","text":"<p>The XCM Transactor Precompile is a Solidity interface through which developers can interact with the XCM Transactor Pallet using the Ethereum API.</p> XcmTransactorV1.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The XcmTransactorV1 contract's address.\naddress constant XCM_TRANSACTOR_V1_ADDRESS = 0x0000000000000000000000000000000000000806;\n\n/// @dev The XcmTransactorV1 contract's instance.\nXcmTransactorV1 constant XCM_TRANSACTOR_V1_CONTRACT = XcmTransactorV1(\n    XCM_TRANSACTOR_V1_ADDRESS\n);\n\n/// @author The Moonbeam Team\n/// @title Xcm Transactor Interface\n/// @dev The interface through which solidity contracts will interact with xcm transactor pallet\n/// @custom:address 0x0000000000000000000000000000000000000806\ninterface XcmTransactorV1 {\n    // A multilocation is defined by its number of parents and the encoded junctions (interior)\n    struct Multilocation {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    /// Get index of an account in xcm transactor\n    /// @custom:selector 3fdc4f36\n    /// @param index The index of which we want to retrieve the account\n    /// @return owner The owner of the derivative index\n    ///\n    function indexToAccount(uint16 index) external view returns (address owner);\n\n    /// DEPRECATED, replaced by transactInfoWithSigned\n    /// Get transact info of a multilocation\n    /// @custom:selector d07d87c3\n    /// @param multilocation The location for which we want to know the transact info\n    /// @return transactExtraWeight The extra weight involved in the XCM message of using derivative\n    /// @return feePerSecond The amount of fee charged for a second of execution in the dest\n    /// @return maxWeight Maximum allowed weight for a single message in dest\n    ///\n    function transactInfo(Multilocation memory multilocation)\n        external\n        view\n        returns (\n            uint64 transactExtraWeight,\n            uint256 feePerSecond,\n            uint64 maxWeight\n        );\n\n    /// Get transact info of a multilocation\n    /// @custom:selector b689e20c\n    /// @param multilocation The location for which we want to know the transact info\n    /// @return transactExtraWeight The extra weight involved in the XCM message of using derivative\n    /// @return transactExtraWeightSigned The extra weight involved in the XCM message of using signed\n    /// @return maxWeight Maximum allowed weight for a single message in dest\n    ///\n    function transactInfoWithSigned(Multilocation memory multilocation)\n        external\n        view\n        returns (\n            uint64 transactExtraWeight,\n            uint64 transactExtraWeightSigned,\n            uint64 maxWeight\n        );\n\n    /// Get fee per second charged in its reserve chain for an asset\n    /// @custom:selector 906c9990\n    /// @param multilocation The asset location for which we want to know the fee per second value\n    /// @return feePerSecond The fee per second that the reserve chain charges for this asset\n    ///\n    function feePerSecond(Multilocation memory multilocation)\n        external\n        view\n        returns (uint256 feePerSecond);\n\n    /// Transact through XCM using fee based on its multilocation\n    /// @custom:selector 94a63c54\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param transactor The transactor to be used\n    /// @param index The index to be used\n    /// @param feeAsset The asset in which we want to pay fees.\n    /// It has to be a reserve of the destination chain\n    /// @param weight The weight we want to buy in the destination chain\n    /// @param innerCall The inner call to be executed in the destination chain\n    function transactThroughDerivativeMultilocation(\n        uint8 transactor,\n        uint16 index,\n        Multilocation memory feeAsset,\n        uint64 weight,\n        bytes memory innerCall\n    ) external;\n\n    /// Transact through XCM using fee based on its currencyId\n    /// @custom:selector 02ae072d\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param transactor The transactor to be used\n    /// @param index The index to be used\n    /// @param currencyId Address of the currencyId of the asset to be used for fees\n    /// It has to be a reserve of the destination chain\n    /// @param weight The weight we want to buy in the destination chain\n    /// @param innerCall The inner call to be executed in the destination chain\n    function transactThroughDerivative(\n        uint8 transactor,\n        uint16 index,\n        address currencyId,\n        uint64 weight,\n        bytes memory innerCall\n    ) external;\n\n    /// Transact through XCM using fee based on its multilocation through signed origins\n    /// @custom:selector 71d31587\n    /// @dev No token is burnt before sending the message. The caller must ensure the destination\n    /// is able to understand the DescendOrigin message, and create a unique account from which\n    /// dispatch the call\n    /// @param dest The destination chain (as multilocation) where to send the message\n    /// @param feeLocation The asset multilocation that indentifies the fee payment currency\n    /// It has to be a reserve of the destination chain\n    /// @param weight The weight we want to buy in the destination chain for the call to be made\n    /// @param call The call to be executed in the destination chain\n    function transactThroughSignedMultilocation(\n        Multilocation memory dest,\n        Multilocation memory feeLocation,\n        uint64 weight,\n        bytes memory call\n    ) external;\n\n    /// Transact through XCM using fee based on its erc20 address through signed origins\n    /// @custom:selector 42ca339d\n    /// @dev No token is burnt before sending the message. The caller must ensure the destination\n    /// is able to understand the DescendOrigin message, and create a unique account from which\n    /// dispatch the call\n    /// @param dest The destination chain (as multilocation) where to send the message\n    /// @param feeLocationAddress The ERC20 address of the token we want to use to pay for fees\n    /// only callable if such an asset has been BRIDGED to our chain\n    /// @param weight The weight we want to buy in the destination chain for the call to be made\n    /// @param call The call to be executed in the destination chain\n    function transactThroughSigned(\n        Multilocation memory dest,\n        address feeLocationAddress,\n        uint64 weight,\n        bytes memory call\n    ) external;\n\n    /// @dev Encode 'utility.as_derivative' relay call\n    /// @custom:selector ff86378d\n    /// @param transactor The transactor to be used\n    /// @param index: The derivative index to use\n    /// @param innerCall: The inner call to be executed from the derivated address\n    /// @return result The bytes associated with the encoded call\n    function encodeUtilityAsDerivative(uint8 transactor, uint16 index, bytes memory innerCall)\n        external\n        pure\n        returns (bytes memory result);\n}\n</code></pre> XcmTransactorV2.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.0;\n\n/// @dev The XcmTransactorV2 contract's address.\naddress constant XCM_TRANSACTOR_V2_ADDRESS = 0x000000000000000000000000000000000000080D;\n\n/// @dev The XcmTransactorV2 contract's instance.\nXcmTransactorV2 constant XCM_TRANSACTOR_V2_CONTRACT = XcmTransactorV2(\n    XCM_TRANSACTOR_V2_ADDRESS\n);\n\n/// @author The Moonbeam Team\n/// @title Xcm Transactor Interface\n/// The interface through which solidity contracts will interact with xcm transactor pallet\n/// @custom:address 0x000000000000000000000000000000000000080D\ninterface XcmTransactorV2 {\n    // A multilocation is defined by its number of parents and the encoded junctions (interior)\n    struct Multilocation {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    /// Get index of an account in xcm transactor\n    /// @custom:selector 3fdc4f36\n    /// @param index The index of which we want to retrieve the account\n    /// @return owner The owner of the derivative index\n    ///\n    function indexToAccount(uint16 index) external view returns (address owner);\n\n    /// Get transact info of a multilocation\n    /// @custom:selector b689e20c\n    /// @param multilocation The location for which we want to know the transact info\n    /// @return transactExtraWeight The extra weight involved in the XCM message of using derivative\n    /// @return transactExtraWeightSigned The extra weight involved in the XCM message of using signed\n    /// @return maxWeight Maximum allowed weight for a single message in dest\n    ///\n    function transactInfoWithSigned(Multilocation memory multilocation)\n        external\n        view\n        returns (\n            uint64 transactExtraWeight,\n            uint64 transactExtraWeightSigned,\n            uint64 maxWeight\n        );\n\n    /// Get fee per second charged in its reserve chain for an asset\n    /// @custom:selector 906c9990\n    /// @param multilocation The asset location for which we want to know the fee per second value\n    /// @return feePerSecond The fee per second that the reserve chain charges for this asset\n    ///\n    function feePerSecond(Multilocation memory multilocation)\n        external\n        view\n        returns (uint256 feePerSecond);\n\n    /// Transact through XCM using fee based on its multilocation\n    /// @custom:selector fe430475\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param transactor The transactor to be used\n    /// @param index The index to be used\n    /// @param feeAsset The asset in which we want to pay fees.\n    /// It has to be a reserve of the destination chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain\n    /// @param innerCall The inner call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message.\n    ///\n    function transactThroughDerivativeMultilocation(\n        uint8 transactor,\n        uint16 index,\n        Multilocation memory feeAsset,\n        uint64 transactRequiredWeightAtMost,\n        bytes memory innerCall,\n        uint256 feeAmount,\n        uint64 overallWeight\n    ) external;\n\n    /// Transact through XCM using fee based on its currency_id\n    /// @custom:selector 185de2ae\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param transactor The transactor to be used\n    /// @param index The index to be used\n    /// @param currencyId Address of the currencyId of the asset to be used for fees\n    /// It has to be a reserve of the destination chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain\n    /// @param innerCall The inner call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message.\n    function transactThroughDerivative(\n        uint8 transactor,\n        uint16 index,\n        address currencyId,\n        uint64 transactRequiredWeightAtMost,\n        bytes memory innerCall,\n        uint256 feeAmount,\n        uint64 overallWeight\n    ) external;\n\n    /// Transact through XCM using fee based on its multilocation through signed origins\n    /// @custom:selector d7ab340c\n    /// @dev No token is burnt before sending the message. The caller must ensure the destination\n    /// is able to understand the DescendOrigin message, and create a unique account from which\n    /// dispatch the call\n    /// @param dest The destination chain (as multilocation) where to send the message\n    /// @param feeLocation The asset multilocation that indentifies the fee payment currency\n    /// It has to be a reserve of the destination chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain for the call to be made\n    /// @param call The call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message.\n    function transactThroughSignedMultilocation(\n        Multilocation memory dest,\n        Multilocation memory feeLocation,\n        uint64 transactRequiredWeightAtMost,\n        bytes memory call,\n        uint256 feeAmount,\n        uint64 overallWeight\n    ) external;\n\n    /// Transact through XCM using fee based on its erc20 address through signed origins\n    /// @custom:selector b648f3fe\n    /// @dev No token is burnt before sending the message. The caller must ensure the destination\n    /// is able to understand the DescendOrigin message, and create a unique account from which\n    /// dispatch the call\n    /// @param dest The destination chain (as multilocation) where to send the message\n    /// @param feeLocationAddress The ERC20 address of the token we want to use to pay for fees\n    /// only callable if such an asset has been BRIDGED to our chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain for the call to be made\n    /// @param call The call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message.\n    function transactThroughSigned(\n        Multilocation memory dest,\n        address feeLocationAddress,\n        uint64 transactRequiredWeightAtMost,\n        bytes memory call,\n        uint256 feeAmount,\n        uint64 overallWeight\n    ) external;\n\n    /// @dev Encode 'utility.as_derivative' relay call\n    /// @custom:selector ff86378d\n    /// @param transactor The transactor to be used\n    /// @param index: The derivative index to use\n    /// @param innerCall: The inner call to be executed from the derivated address\n    /// @return result The bytes associated with the encoded call\n    function encodeUtilityAsDerivative(uint8 transactor, uint16 index, bytes memory innerCall)\n        external\n        pure\n        returns (bytes memory result);\n}\n</code></pre> XcmTransactorV3.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.0;\n\n/// @dev The XcmTransactorV3 contract's address.\naddress constant XCM_TRANSACTOR_V3_ADDRESS = 0x0000000000000000000000000000000000000817;\n\n/// @dev The XcmTransactorV3 contract's instance.\nXcmTransactorV3 constant XCM_TRANSACTOR_V3_CONTRACT = XcmTransactorV3(\n    XCM_TRANSACTOR_V3_ADDRESS\n);\n\n/// @author The Moonbeam Team\n/// @title Xcm Transactor Interface\n/// The interface through which solidity contracts will interact with xcm transactor pallet\n/// @custom:address 0x0000000000000000000000000000000000000817\ninterface XcmTransactorV3 {\n    // A multilocation is defined by its number of parents and the encoded junctions (interior)\n    struct Multilocation {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    // Support for Weights V2\n    struct Weight {\n        uint64 refTime;\n        uint64 proofSize;\n    }\n\n    /// Get index of an account in xcm transactor\n    /// @custom:selector 3fdc4f36\n    /// @param index The index of which we want to retrieve the account\n    /// @return owner The owner of the derivative index\n    ///\n    function indexToAccount(uint16 index) external view returns (address owner);\n\n    /// Get transact info of a multilocation\n    /// @custom:selector b689e20c\n    /// @param multilocation The location for which we want to know the transact info\n    /// @return transactExtraWeight The extra weight involved in the XCM message of using derivative\n    /// @return transactExtraWeightSigned The extra weight involved in the XCM message of using signed\n    /// @return maxWeight Maximum allowed weight for a single message in dest\n    ///\n    function transactInfoWithSigned(Multilocation memory multilocation)\n        external\n        view\n        returns (\n            Weight memory transactExtraWeight,\n            Weight memory transactExtraWeightSigned,\n            Weight memory maxWeight\n        );\n\n    /// Get fee per second charged in its reserve chain for an asset\n    /// @custom:selector 906c9990\n    /// @param multilocation The asset location for which we want to know the fee per second value\n    /// @return feePerSecond The fee per second that the reserve chain charges for this asset\n    ///\n    function feePerSecond(Multilocation memory multilocation)\n        external\n        view\n        returns (uint256 feePerSecond);\n\n    /// Transact through XCM using fee based on its multilocation\n    /// @custom:selector bdacc26b\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param transactor The transactor to be used\n    /// @param index The index to be used\n    /// @param feeAsset The asset in which we want to pay fees.\n    /// It has to be a reserve of the destination chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain\n    /// @param innerCall The inner call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message. If uint64:MAX is passed \n    /// through refTime field, Unlimited variant will be used. \n    /// @param refund Indicates if RefundSurplus instruction will be appended\n    function transactThroughDerivativeMultilocation(\n        uint8 transactor,\n        uint16 index,\n        Multilocation memory feeAsset,\n        Weight memory transactRequiredWeightAtMost,\n        bytes memory innerCall,\n        uint256 feeAmount,\n        Weight memory overallWeight,\n        bool refund\n    ) external;\n\n    /// Transact through XCM using fee based on its currency_id\n    /// @custom:selector ca8c82d8\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param transactor The transactor to be used\n    /// @param index The index to be used\n    /// @param currencyId Address of the currencyId of the asset to be used for fees\n    /// It has to be a reserve of the destination chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain\n    /// @param innerCall The inner call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message. If uint64:MAX is passed \n    /// through refTime field, Unlimited variant will be used. \n    /// @param refund Indicates if RefundSurplus instruction will be appended\n    function transactThroughDerivative(\n        uint8 transactor,\n        uint16 index,\n        address currencyId,\n        Weight memory transactRequiredWeightAtMost,\n        bytes memory innerCall,\n        uint256 feeAmount,\n        Weight memory overallWeight,\n        bool refund\n    ) external;\n\n    /// Transact through XCM using fee based on its multilocation through signed origins\n    /// @custom:selector 27b1d492\n    /// @dev No token is burnt before sending the message. The caller must ensure the destination\n    /// is able to understand the DescendOrigin message, and create a unique account from which\n    /// dispatch the call\n    /// @param dest The destination chain (as multilocation) where to send the message\n    /// @param feeLocation The asset multilocation that indentifies the fee payment currency\n    /// It has to be a reserve of the destination chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain for the call to be made\n    /// @param call The call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message. If uint64:MAX is passed \n    /// through refTime field, Unlimited variant will be used. \n    /// @param refund Indicates if RefundSurplus instruction will be appended\n    function transactThroughSignedMultilocation(\n        Multilocation memory dest,\n        Multilocation memory feeLocation,\n        Weight memory transactRequiredWeightAtMost,\n        bytes memory call,\n        uint256 feeAmount,\n        Weight memory overallWeight,\n        bool refund\n    ) external;\n\n    /// Transact through XCM using fee based on its erc20 address through signed origins\n    /// @custom:selector b18270cf\n    /// @dev No token is burnt before sending the message. The caller must ensure the destination\n    /// is able to understand the DescendOrigin message, and create a unique account from which\n    /// dispatch the call\n    /// @param dest The destination chain (as multilocation) where to send the message\n    /// @param feeLocationAddress The ERC20 address of the token we want to use to pay for fees\n    /// only callable if such an asset has been BRIDGED to our chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain for the call to be made\n    /// @param call The call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message. If uint64:MAX is passed \n    /// through refTime field, Unlimited variant will be used. \n    /// @param refund Indicates if RefundSurplus instruction will be appended\n    function transactThroughSigned(\n        Multilocation memory dest,\n        address feeLocationAddress,\n        Weight memory transactRequiredWeightAtMost,\n        bytes memory call,\n        uint256 feeAmount,\n        Weight memory overallWeight,\n        bool refund\n    ) external;\n\n    /// @dev Encode 'utility.as_derivative' relay call\n    /// @custom:selector ff86378d\n    /// @param transactor The transactor to be used\n    /// @param index: The derivative index to use\n    /// @param innerCall: The inner call to be executed from the derivated address\n    /// @return result The bytes associated with the encoded call\n    function encodeUtilityAsDerivative(uint8 transactor, uint16 index, bytes memory innerCall)\n        external\n        pure\n        returns (bytes memory result);\n}\n</code></pre> <p>Note</p> <p>The XCM Transactor Precompile V1 will be deprecated in the near future, so all implementations must migrate to the newer interfaces.</p> <p>The interface varies slightly from version to version. You can find an overview of each version's interface below.</p> V2V3 <p>The V2 interface includes the following functions:</p> transactInfoWithSigned(Multilocation memory multilocation) \u2014 read-only function that returns the transact information for a given chain ParametersReturns <ul> <li><code>multilocation</code> - the multilocation of the chain to get the transact information for</li> </ul> <p>The transact information for:</p> <ul> <li>The three XCM instructions associated with the external call execution (<code>transactExtraWeight</code>)</li> <li>The extra weight information associated with the <code>DescendOrigin</code> XCM instruction for the transact through signed extrinsic (<code>transactExtraWeightSigned</code>)</li> <li>The maximum allowed weight for the message in the given chain</li> </ul> <pre><code>[ 173428000n, 0n, 20000000000n ]\n</code></pre> feePerSecond(Multilocation memory multilocation) \u2014 read-only function that returns units of tokens per second of the XCM execution that is charged as the XCM execution fee for a given asset. This is useful when, for a given chain, there are multiple assets that can be used for fee payment ParametersReturns <ul> <li><code>multilocation</code> - the multilocation of the asset to get the units per second value for</li> </ul> <p>The fee per second that the reserve chain charges for the given asset.</p> <pre><code>13764626000000n\n</code></pre> transactThroughSignedMultilocation(Multilocation memory dest, Multilocation memory feeLocation, uint64 transactRequiredWeightAtMost, bytes memory call, uint256 feeAmount, uint64 overallWeight) \u2014 sends an XCM message with instructions to remotely execute a call in the destination chain. The remote call will be signed and executed by a new account, called the Computed Origin account, that the destination parachain must compute. Moonbeam-based networks follow the Computed Origins standard set by Polkadot. You need to provide the asset multilocation of the token that is used for fee payment instead of the address of the XC-20 token Parameters <ul> <li><code>dest</code> - the multilocation of a chain in the ecosystem where the XCM message is being sent to (the target chain). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>feeLocation</code> - the multilocation of the asset to use for fee payment. The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>transactRequiredWeightAtMost</code> - the weight to buy in the destination chain for the execution of the call defined in the <code>Transact</code> instruction</li> <li><code>call</code> - the call to be executed in the destination chain, as defined in the <code>Transact</code> instruction </li> <li><code>feeAmount</code> - the amount to be used as a fee</li> <li><code>overallWeight</code> - the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> structure also contains <code>refTime</code> and <code>proofSize</code>. If you pass in the maximum value for a uint64 for the <code>refTime</code>, you'll allow for an unlimited amount of weight to be purchased, which removes the need to know exactly how much weight the destination chain requires to execute the XCM</li> </ul> transactThroughSigned(Multilocation memory dest, address feeLocationAddress, uint64 transactRequiredWeightAtMost, bytes memory call, uint256 feeAmount, uint64 overallWeight) \u2014 sends an XCM message with instructions to remotely execute a call in the destination chain. The remote call will be signed and executed by a new account, called the Computed Origin account, that the destination parachain must compute. Moonbeam-based networks follow the Computed Origins standard set by Polkadot. You need to provide the address of the XC-20 asset to be used for fee payment Parameters <ul> <li><code>dest</code> - the multilocation of a chain in the ecosystem where the XCM message is being sent to (the target chain). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>feeLocationAddress</code> - the XC-20 address of the asset to use for fee payment</li> <li><code>transactRequiredWeightAtMost</code> - the weight to buy in the destination chain for the execution of the call defined in the <code>Transact</code> instruction</li> <li><code>call</code> - the call to be executed in the destination chain, as defined in the <code>Transact</code> instruction </li> <li><code>feeAmount</code> - the amount to be used as a fee</li> <li><code>overallWeight</code> - the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> structure also contains <code>refTime</code> and <code>proofSize</code>. If you pass in the maximum value for a uint64 for the <code>refTime</code>, you'll allow for an unlimited amount of weight to be purchased, which removes the need to know exactly how much weight the destination chain requires to execute the XCM</li> </ul> <p>The V3 interface adds support for Weights V2, which updates the <code>Weight</code> type to represent proof size in addition to computational time. As such, this requires that <code>refTime</code> and <code>proofSize</code> be defined, where <code>refTime</code> is the amount of computational time that can be used for execution and <code>proofSize</code> is the amount of storage in bytes that can be used. </p> <p>The following struct was added to the XCM Transactor Precompile to support Weights V2:</p> <pre><code>struct Weight {\n    uint64 refTime;\n    uint65 proofSize;\n}\n</code></pre> <p>Additionally, support for the <code>RefundSurplus</code> and <code>DepositAsset</code> instructions was added. To append the <code>RefundSurplus</code> instruction to the XCM message, you can use the <code>refund</code> parameter, which will refund any leftover funds not used for the <code>Transact</code> if set to <code>true</code>.</p> <p>The V3 interface includes the following functions:</p> transactInfoWithSigned(Multilocation memory multilocation) \u2014 read-only function that returns the transact information for a given chain ParametersReturns <ul> <li><code>multilocation</code> - the multilocation of the chain to get the transact information for</li> </ul> <p>The transact information for:</p> <ul> <li>The three XCM instructions associated with the external call execution (<code>transactExtraWeight</code>)</li> <li>The extra weight information associated with the <code>DescendOrigin</code> XCM instruction for the transact through signed extrinsic (<code>transactExtraWeightSigned</code>)</li> <li>The maximum allowed weight for the message in the given chain</li> </ul> <pre><code>[ 173428000n, 0n, 20000000000n ]\n</code></pre> feePerSecond(Multilocation memory multilocation) \u2014 read-only function that returns units of token per second of the XCM execution that is charged as the XCM execution fee for a given asset. This is useful when, for a given chain, there are multiple assets that can be used for fee payment ParametersReturns <ul> <li><code>multilocation</code> - the multilocation of the asset to get the units per second value for</li> </ul> <p>The fee per second that the reserve chain charges for the given asset.</p> <pre><code>13764626000000n\n</code></pre> transactThroughSignedMultilocation(Multilocation memory dest, Multilocation memory feeLocation, Weight transactRequiredWeightAtMost, bytes memory call, uint256 feeAmount, Weight overallWeight, bool refund) \u2014 sends an XCM message with instructions to remotely execute a call in the destination chain. The remote call will be signed and executed by a new account, called the Computed Origin account, that the destination parachain must compute. Moonbeam-based networks follow the Computed Origins standard set by Polkadot. You need to provide the asset multilocation of the token that is used for fee payment instead of the address of the XC-20 token Parameters <ul> <li><code>dest</code> - the multilocation of a chain in the ecosystem where the XCM message is being sent to (the target chain). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>feeLocation</code> - the multilocation of the asset to use for fee payment. The multilocation must be formatted in a particular way, which is described in the following section</li> <li><code>transactRequiredWeightAtMost</code> - the weight to buy in the destination chain for the execution of the call defined in the <code>Transact</code> instruction. The <code>transactRequiredWeightAtMost</code> structure contains the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used It should be formatted as follows: <pre><code>[ INSERT_REF_TIME, INSERT_PROOF_SIZE ]\n</code></pre></li> </ul> </li> <li><code>call</code> - the call to be executed in the destination chain, as defined in the <code>Transact</code> instruction </li> <li><code>feeAmount</code> - the amount to be used as a fee</li> <li><code>overallWeight</code> - the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> structure also contains <code>refTime</code> and <code>proofSize</code>. If you pass in the maximum value for a uint64 for the <code>refTime</code>, you'll allow for an unlimited amount of weight to be purchased, which removes the need to know exactly how much weight the destination chain requires to execute the XCM</li> <li><code>refund</code> -  a boolean indicating whether or not to add the <code>RefundSurplus</code> and <code>DepositAsset</code> instructions to the XCM message to refund any leftover fees </li> </ul> transactThroughSigned(Multilocation memory dest, address feeLocationAddress, Weight transactRequiredWeightAtMost, bytes memory call, uint256 feeAmount, Weight overallWeight, bool refund) \u2014 sends an XCM message with instructions to remotely execute a call in the destination chain. The remote call will be signed and executed by a new account, called the Computed Origin account, that the destination parachain must compute. Moonbeam-based networks follow the Computed Origins standard set by Polkadot. You need to provide the address of the XC-20 asset to be used for fee payment Parameters <ul> <li><code>dest</code> - the multilocation of a chain in the ecosystem where the XCM message is being sent to (the target chain). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>feeLocationAddress</code> - the XC-20 address of the asset to use for fee payment</li> <li><code>transactRequiredWeightAtMost</code> - the weight to buy in the destination chain for the execution of the call defined in the <code>Transact</code> instruction. The <code>transactRequiredWeightAtMost</code> structure contains the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used It should be formatted as follows: <pre><code>[ INSERT_REF_TIME, INSERT_PROOF_SIZE ]\n</code></pre></li> </ul> </li> <li><code>call</code> - the call to be executed in the destination chain, as defined in the <code>Transact</code> instruction </li> <li><code>feeAmount</code> - the amount to be used as a fee</li> <li><code>overallWeight</code> - the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> structure also contains <code>refTime</code> and <code>proofSize</code>. If you pass in the maximum value for a uint64 for the <code>refTime</code>, you'll allow for an unlimited amount of weight to be purchased, which removes the need to know exactly how much weight the destination chain requires to execute the XCM</li> <li><code>refund</code> -  a boolean indicating whether or not to add the <code>RefundSurplus</code> and <code>DepositAsset</code> instructions to the XCM message to refund any leftover fees </li> </ul>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcm-instructions-for-remote-execution","title":"XCM Instructions for Remote Execution","text":"<p>The relevant XCM instructions to perform remote execution through XCM are, but are not limited to:</p> <ul> <li><code>DescendOrigin</code> - gets executed in the target chain. It mutates the origin on the target chain to match the origin on the source chain, ensuring execution on the target chain occurs on behalf of the same entity initiating the XCM message on the source chain</li> <li><code>WithdrawAsset</code> - gets executed in the target chain. Removes assets and places them into a holding register</li> <li><code>BuyExecution</code> - gets executed in the target chain. Takes the assets from holding to pay for execution fees. The fees to pay are determined by the target chain</li> <li><code>Transact</code> - gets executed in the target chain. Dispatches encoded call data from a given origin, allowing for the execution of specific operations or functions</li> </ul>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#building-the-precompile-multilocation","title":"Building the Precompile Multilocation","text":"<p>In the XCM Transactor Precompile interface, the <code>Multilocation</code> structure is defined as follows:</p> <pre><code> struct Multilocation {\n    uint8 parents;\n    bytes[] interior;\n}\n</code></pre> <p>As with a standard multilocation, there are <code>parents</code> and <code>interior</code> elements. However, instead of defining the multilocation as an object, with Ethereum libraries, the struct is defined as an array, which contains a <code>uint8</code> for the <code>parents</code> as the first element and a bytes array for the <code>interior</code> as the second element.</p> <p>The normal values you would see for the <code>parents</code> element are:</p> Origin Destination Parents Value Parachain A Parachain A 0 Parachain A Relay Chain 1 Parachain A Parachain B 1 <p>For the <code>interior</code> element, the number of fields you need to drill down to in the target chain to reach the exact location of the target, such as the specific asset or account, represents the size of the bytes array:</p> Array Size Interior Value [] 0 Here [XYZ] 1 X1 [XYZ, ABC] 2 X2 [XYZ, ... N] N XN <p>Note</p> <p>Interior value <code>Here</code> is often used for the relay chain (either as a destination or to target the relay chain asset).</p> <p>Each field required to reach the exact location of the target needs to be defined as a hex string. The first byte (2 hexadecimal characters) corresponds to the selector of the field. For example:</p> Byte Value Selector Data Type 0x00 Parachain bytes4 0x01 AccountId32 bytes32 0x02 AccountIndex64 u64 0x03 AccountKey20 bytes20 0x04 PalletInstance byte 0x05 GeneralIndex u128 0x06 GeneralKey bytes[] <p>Next, depending on the selector and its data type, the following bytes correspond to the actual data being provided. Note that for <code>AccountId32</code>, <code>AccountIndex64</code>, and <code>AccountKey20</code>, the optional <code>network</code> field is appended at the end. For example:</p> Selector Data Value Represents Parachain \"0x00+000007E7\" Parachain ID 2023 AccountId32 \"0x01+AccountId32+00\" AccountId32, Network(Option) Null AccountId32 \"0x01+AccountId32+03\" AccountId32, Network Polkadot AccountKey20 \"0x03+AccountKey20+00\" AccountKey20, Network(Option) Null PalletInstance \"0x04+03\" Pallet Instance 3 <p>Note</p> <p>The <code>interior</code> data usually needs to be wrapped around quotes, or you might get an <code>invalid tuple value</code> error.</p> <p>The following code snippet goes through some examples of <code>Multilocation</code> structures, as they would need to be fed into the XCM Transactor Precompile functions:</p> <pre><code>// Multilocation targeting the relay chain asset from a parachain\n[\n  1, // parents = 1\n  [], // interior = here\n]\n\n// Multilocation targeting Moonbase Alpha DEV token from another parachain\n[\n  1, // parents = 1\n  [  // interior = X2 (the array has a length of 2)\n    \"0x00000003E8\", // Parachain selector + Parachain ID 1000 (Moonbase Alpha)\n    \"0x0403\", // Pallet Instance selector + Pallet Instance 3 (Balances Pallet)\n  ],\n]\n\n// Multilocation targeting aUSD asset on Acala\n[\n  1, // parents = 1\n  [  // interior = X2 (the array has a length of 2)\n    \"0x00000007D0\", // Parachain selector + Parachain ID 2000 (Acala)\n    \"0x060001\", // General Key selector + Asset Key\n  ],\n]\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcmtransactor-transact-through-signed","title":"Transact through a Computed Origin Account","text":"<p>This section covers building an XCM message for remote execution using the XCM Transactor Pallet, specifically with the <code>transactThroughSigned</code> function. This function uses a Computed Origin account on the destination chain to dispatch the remote call.</p> <p>The example in this section uses a destination parachain that is not publicly available, so you won't be able to follow along exactly. You can modify the example as needed for your own use case.</p> <p>Note</p> <p>You need to ensure that the call you are going to execute remotely is allowed in the destination chain!</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcmtransactor-signed-check-prerequisites","title":"Checking Prerequisites","text":"<p>To be able to send the extrinsics in this section, you need to have:</p> <ul> <li>An account in the origin chain with funds</li> <li>Funds in the Computed Origin account on the target chain. To learn how to calculate the address of the Computed Origin account, please refer to the How to Calculate the Computed Origin documentation</li> </ul> <p>For this example, the following accounts will be used:</p> <ul> <li>Alice's account in the origin parachain (Moonbase Alpha): <code>0x44236223aB4291b93EEd10E4B511B37a398DEE55</code></li> <li>Her Computed Origin address in the target parachain (Parachain 888): <code>0x5c27c4bb7047083420eddff9cddac4a0a120b45c</code></li> </ul>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcm-transact-through-signed","title":"Building the XCM","text":"<p>For this example, you'll interact with the <code>transactThroughSigned</code> function of the XCM Transactor Precompile V3. To use this function, you'll take these general steps:</p> <ol> <li>Create a provider using a Moonbase Alpha RPC endpoint</li> <li>Create a signer to send the transaction. This example uses a private key to create the signer and is for demo purposes only. Never store your private key in a JavaScript file</li> <li> <p>Create a contract instance of the XCM Transactor V3 Precompile using the address and ABI of the precompile</p> XCM Transactor V3 ABI <pre><code>[\n  {\n    inputs: [\n      {\n        internalType: 'uint8',\n        name: 'transactor',\n        type: 'uint8',\n      },\n      {\n        internalType: 'uint16',\n        name: 'index',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes',\n        name: 'innerCall',\n        type: 'bytes',\n      },\n    ],\n    name: 'encodeUtilityAsDerivative',\n    outputs: [\n      {\n        internalType: 'bytes',\n        name: 'result',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Multilocation',\n        name: 'multilocation',\n        type: 'tuple',\n      },\n    ],\n    name: 'feePerSecond',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: 'feePerSecond',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint16',\n        name: 'index',\n        type: 'uint16',\n      },\n    ],\n    name: 'indexToAccount',\n    outputs: [\n      {\n        internalType: 'address',\n        name: 'owner',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Multilocation',\n        name: 'multilocation',\n        type: 'tuple',\n      },\n    ],\n    name: 'transactInfoWithSigned',\n    outputs: [\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'transactExtraWeight',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'transactExtraWeightSigned',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'maxWeight',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint8',\n        name: 'transactor',\n        type: 'uint8',\n      },\n      {\n        internalType: 'uint16',\n        name: 'index',\n        type: 'uint16',\n      },\n      {\n        internalType: 'address',\n        name: 'currencyId',\n        type: 'address',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'transactRequiredWeightAtMost',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'innerCall',\n        type: 'bytes',\n      },\n      {\n        internalType: 'uint256',\n        name: 'feeAmount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'overallWeight',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bool',\n        name: 'refund',\n        type: 'bool',\n      },\n    ],\n    name: 'transactThroughDerivative',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint8',\n        name: 'transactor',\n        type: 'uint8',\n      },\n      {\n        internalType: 'uint16',\n        name: 'index',\n        type: 'uint16',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Multilocation',\n        name: 'feeAsset',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'transactRequiredWeightAtMost',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'innerCall',\n        type: 'bytes',\n      },\n      {\n        internalType: 'uint256',\n        name: 'feeAmount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'overallWeight',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bool',\n        name: 'refund',\n        type: 'bool',\n      },\n    ],\n    name: 'transactThroughDerivativeMultilocation',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Multilocation',\n        name: 'dest',\n        type: 'tuple',\n      },\n      {\n        internalType: 'address',\n        name: 'feeLocationAddress',\n        type: 'address',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'transactRequiredWeightAtMost',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'call',\n        type: 'bytes',\n      },\n      {\n        internalType: 'uint256',\n        name: 'feeAmount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'overallWeight',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bool',\n        name: 'refund',\n        type: 'bool',\n      },\n    ],\n    name: 'transactThroughSigned',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Multilocation',\n        name: 'dest',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Multilocation',\n        name: 'feeLocation',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'transactRequiredWeightAtMost',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'call',\n        type: 'bytes',\n      },\n      {\n        internalType: 'uint256',\n        name: 'feeAmount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'overallWeight',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bool',\n        name: 'refund',\n        type: 'bool',\n      },\n    ],\n    name: 'transactThroughSignedMultilocation',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> </li> <li> <p>Assemble the arguments for the <code>transactThroughSigned</code> function:</p> <ul> <li> <p><code>dest</code> - the multilocation of the destination, which is parachain 888:</p> <pre><code>const dest = [\n  1, // parents = 1\n  [  // interior = X1 (the array has a length of 1)\n    '0x0000000378', // Parachain selector + Parachain ID 888\n  ],\n];\n</code></pre> </li> <li> <p><code>feeLocationAddress</code> - the address of the XC-20 to use for fees, which is parachain 888's native asset:</p> <pre><code>const feeLocationAddress = '0xFFFFFFFF1AB2B146C526D4154905FF12E6E57675';\n</code></pre> </li> <li> <p><code>transactRequiredWeightAtMost</code> - the weight required to execute the call in the <code>Transact</code> instruction. You can get this information by using the <code>paymentInfo</code> method of the Polkadot.js API on the call</p> <pre><code>const transactRequiredWeightAtMost = [1000000000n, 5000n];\n</code></pre> </li> <li> <p><code>call</code> - the encoded call data of the pallet, method, and input to be called. It can be constructed in Polkadot.js Apps (which must be connected to the destination chain) or using the Polkadot.js API. For this example, the inner call is a simple balance transfer of 1 token of the destination chain to Alice's account there:</p> <pre><code>const call =\n  '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\n</code></pre> </li> <li> <p><code>feeAmount</code> - the amount to use for fees</p> <pre><code>const feeAmount = 50000000000000000n;\n</code></pre> </li> <li> <p><code>overallWeight</code> - the weight specific to the inner call (<code>transactRequiredWeightAtMost</code>) plus the weight needed to cover the execution costs for the XCM instructions in the destination chain: <code>DescendOrigin</code>, <code>WithdrawAsset</code>, <code>BuyExecution</code>, and <code>Transact</code>. It's important to note that each chain defines its own weight requirements. To determine the weight required for each XCM instruction on a given chain, please refer to the chain's documentation or reach out to a member of their team. Alternatively, you can pass in the maximum value for a uint64 for the <code>refTime</code> (the first index of the array). This will be interpreted as using an unlimited amount of weight, which removes the need to know exactly how much weight the destination chain requires to execute the XCM</p> <pre><code>const overallWeight = [18446744073709551615n, 10000n];\n</code></pre> </li> </ul> </li> <li> <p>Create the <code>transactThroughSigned</code> function, passing in the arguments</p> </li> <li>Sign and send the transaction</li> </ol> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\n\nconst abi = INSERT_ABI;\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n// Create contract instance\nconst xcmTransactorV3 = new ethers.Contract(\n  '0x0000000000000000000000000000000000000817',\n  abi,\n  signer\n);\n\n// Arguments for the transactThroughSigned function\nconst dest = [\n  1, // parents = 1\n  [\n    // interior = X1 (the array has a length of 1)\n    '0x0000000378', // Parachain selector + Parachain ID 888\n  ],\n];\nconst feeLocationAddress = '0xFFFFFFFF1AB2B146C526D4154905FF12E6E57675';\nconst transactRequiredWeightAtMost = [1000000000n, 5000n];\nconst call = '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\nconst feeAmount = 50000000000000000n;\nconst overallWeight = [2000000000n, 10000n];\nconst refund = true;\n\n// Sends 1 token to Alice's account on parachain 888\nasync function transactThroughSigned() {\n  // Creates, signs, and sends the transfer transaction\n  const transaction = await xcmTransactorV3.transactThroughSigned(\n    dest,\n    feeLocationAddress,\n    transactRequiredWeightAtMost,\n    call,\n    feeAmount,\n    overallWeight,\n    refund\n  );\n\n  // Waits for the transaction to be included in a block\n  await transaction.wait();\n  console.log(transaction);\n}\n\ntransactThroughSigned();\n</code></pre> <pre><code>import Web3 from 'web3'; // Import Web3 library\n\nconst abi = INSERT_ABI;\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Web3 provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n// Create contract instance\nconst xcmTransactorV3 = new web3.eth.Contract(\n  abi,\n  '0x0000000000000000000000000000000000000817',\n  { from: web3.eth.accounts.privateKeyToAccount(privateKey).address } // 'from' is necessary for gas estimation\n);\n\n// Arguments for the transactThroughSigned function\nconst dest = [\n  1, // parents = 1\n  [\n    // interior = X1 (the array has a length of 1)\n    '0x0000000378', // Parachain selector + Parachain ID 888\n  ],\n];\nconst feeLocationAddress = '0xFFFFFFFF1AB2B146C526D4154905FF12E6E57675';\nconst transactRequiredWeightAtMost = [1000000000n, 5000n];\nconst call = '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\nconst feeAmount = 50000000000000000n;\nconst overallWeight = [2000000000n, 10000n];\nconst refund = true;\n\n// Sends 1 token to Alice's account on parachain 888\nasync function transactThroughSigned() {\n  // Create transaction\n  const transferTx = xcmTransactorV3.methods.transactThroughSigned(\n    dest,\n    feeLocationAddress,\n    transactRequiredWeightAtMost,\n    call,\n    feeAmount,\n    overallWeight,\n    refund\n  );\n\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: '0x000000000000000000000000000000000000080d',\n      data: transferTx.encodeABI(),\n      gas: await transferTx.estimateGas(),\n    },\n    privateKey\n  );\n\n  // Send signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(sendTx);\n}\n\ntransactThroughSigned();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_ABI\"  # Paste or import the XCM Transactor V3 ABI\nprivate_key = \"INSERT_PRIVATE_KEY\"  # This is for demo purposes, never store your private key in plain text\naddress = \"INSERT_ADDRESS\"  # The wallet address that corresponds to your private key\n\n# Create Web3 provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create contract instance\nxcm_transactor_v3 = web3.eth.contract(\n    address=\"0x0000000000000000000000000000000000000817\", abi=abi\n)\n\n# Arguments for the transactThroughSigned function\ndest = [\n    1,  # parents = 1\n    [\n        # interior = X1 (the array has a length of 1)\n        \"0x0000000378\",  # Parachain selector + Parachain ID 888\n    ],\n]\nfeeLocationAddress = \"0xFFFFFFFF1AB2B146C526D4154905FF12E6E57675\"\ntransactRequiredWeightAtMost = [1000000000, 5000]\ncall = \"0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d\"\nfeeAmount = 50000000000000000\noverallWeight = [2000000000, 10000]\nrefund = True\n\n\n# Sends 1 xcUNIT to the relay chain using the transferMultiasset function\ndef transact_through_signed():\n    # Create transaction\n    transferTx = xcm_transactor_v3.functions.transactThroughSigned(\n        dest,\n        feeLocationAddress,\n        transactRequiredWeightAtMost,\n        call,\n        feeAmount,\n        overallWeight,\n        refund,\n    ).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n\n    # Sign transaction\n    signedTx = web3.eth.account.sign_transaction(transferTx, private_key)\n\n    # Send tx and wait for receipt\n    hash = web3.eth.send_raw_transaction(signedTx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Tx successful with hash: { receipt.transactionHash.hex() }\")\n\n\ntransact_through_signed()\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#transact-through-computed-origin-fees","title":"XCM Transact through Computed Origin Fees","text":"<p>When transacting through the Computed Origin account, the transaction fees are paid by the same account from which the call is dispatched, which is a Computed Origin account in the destination chain. Consequently, the Computed Origin account must hold the necessary funds to pay for the entire execution. Note that the destination token, for which fees are paid, does not need to be registered as an XC-20 in the origin chain.</p> <p>To estimate the amount of token Alice's Computed Origin account will need to have to execute the remote call, you need to check the transact information specific to the destination chain. You can use the following script to get the transact information for parachain 888:</p> <pre><code>import { ethers } from 'ethers'; // Import Ethers library\n\nconst abi = INSERT_ABI;\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers wallet &amp; contract instance\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\nconst xcmTransactorV3 = new ethers.Contract(\n  '0x0000000000000000000000000000000000000817',\n  abi,\n  signer\n);\n\n// Multilocation for parachain 888\nconst multilocation = [\n  1, // parents = 1\n  [  // interior = X1 (the array has a length of 1)\n    '0x0000000378', // Parachain selector + Parachain ID 888\n  ],\n];\n\nconst main = async () =&gt; {\n  const transactInfoWithSigned = await xcmTransactorV3.transactInfoWithSigned(\n    multilocation\n  );\n  console.log(transactInfoWithSigned);\n};\n\nmain();\n</code></pre> <p>The response shows that the <code>transactExtraWeightSigned</code> is <code>400,000,000</code>. This weight is needed to execute the four XCM instructions for this remote call in that specific destination chain. Next, you need to find out how much the destination chain charges per weight of XCM execution in reference to the asset's price. Previously, this was done by sourcing a units per second value. However, this method has been replaced by calculating a relative price. Relative price refers to how many units of the foreign asset correspond to one unit of the native token (GLMR or MOVR) from a value (i.e., price) perspective. For example, if the foreign asset is worth $5 and GLMR is worth $0.25, the relative price would be 0.05. However, we must scale the result to 18 decimals to correspond to the Wei units used. In this case, the relative price would be <code>50000000000000000</code>.</p> <p>You can calculate the relative price with a script in the XCM Tools repo. The script is also reproduced below: </p> Calculate Relative Price <pre><code>import axios from 'axios';\nimport chalk from 'chalk';\n\n// CoinGecko IDs for the networks\nconst NETWORK_IDS = {\n  GLMR: 'moonbeam',\n  MOVR: 'moonriver',\n};\n\nasync function calculateRelativePrice(\n  assetPrice: number,\n  network: 'GLMR' | 'MOVR'\n): Promise&lt;string&gt; {\n  try {\n    // Fetch the native token price from CoinGecko\n    const response = await axios.get(\n      `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[network]}&amp;vs_currencies=usd`\n    );\n\n    const nativeTokenPrice = response.data[NETWORK_IDS[network]].usd;\n\n    // Calculate relative price with 18 decimal places\n    // Formula: (nativeTokenPrice / assetPrice) * 10^18\n    // This gives us how many units of the asset we need to equal 1 unit of native token\n    const relativePrice = (nativeTokenPrice / assetPrice) * Math.pow(10, 18);\n\n    // Return as string to preserve precision\n    return relativePrice.toFixed(0);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Failed to calculate relative price: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\nfunction validateInput(\n  price: string,\n  network: string\n): { assetPrice: number; network: 'GLMR' | 'MOVR' } {\n  // Validate price\n  const assetPrice = parseFloat(price);\n  if (isNaN(assetPrice) || assetPrice &lt;= 0) {\n    throw new Error('Price must be a positive number');\n  }\n\n  // Validate network\n  const upperNetwork = network.toUpperCase() as 'GLMR' | 'MOVR';\n  if (!['GLMR', 'MOVR'].includes(upperNetwork)) {\n    throw new Error('Network must be either GLMR or MOVR');\n  }\n\n  return { assetPrice, network: upperNetwork };\n}\n\nfunction printUsage() {\n  console.log('\\nUsage:');\n  console.log('npx ts-node relative-price-calculator.ts &lt;price&gt; &lt;network&gt;');\n  console.log('\\nExample:');\n  console.log('npx ts-node relative-price-calculator.ts 0.25 GLMR');\n  console.log('\\nParameters:');\n  console.log('price   - The price of your asset in USD');\n  console.log('network - Either GLMR or MOVR');\n}\n\nasync function main() {\n  try {\n    // Get command line arguments\n    const [, , price, network] = process.argv;\n\n    // Check if help flag is passed\n    if (price === '--help' || price === '-h') {\n      printUsage();\n      return;\n    }\n\n    // Check if required arguments are provided\n    if (!price || !network) {\n      console.error('Error: Missing required arguments');\n      printUsage();\n      process.exit(1);\n    }\n\n    // Validate inputs\n    const { assetPrice, network: validNetwork } = validateInput(price, network);\n\n    console.log(\n      `\\nCalculating relative price for asset worth $${assetPrice} against ${validNetwork}...`\n    );\n    const relativePrice = await calculateRelativePrice(\n      assetPrice,\n      validNetwork\n    );\n    const nativeTokenPrice = (\n      await axios.get(\n        `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[validNetwork]}&amp;vs_currencies=usd`\n      )\n    ).data[NETWORK_IDS[validNetwork]].usd;\n\n    const decimalRatio = nativeTokenPrice / assetPrice;\n\n    console.log(`\\nResults:`);\n    console.log(`Asset Price: $${assetPrice}`);\n    console.log(`Network: ${validNetwork}`);\n    console.log(`Native Token Price (from CoinGecko): $${nativeTokenPrice}`);\n    console.log(`\\nRelative Price Analysis:`);\n    console.log(\n      `1 ${validNetwork} is equal to approximately ${decimalRatio.toFixed(\n        3\n      )} of your specified token.`\n    );\n    console.log(\n      `With 18 decimals, 1 ${validNetwork} or in WEI, 1000000000000000000 is equal to a relative price of ${relativePrice} units of your token`\n    );\n    console.log(chalk.bold(`\\nRelative Price: ${relativePrice}`));\n    console.log(\n      `\\nThe relative price you should specify in asset registration steps is ${relativePrice}\\n`\n    );\n  } catch (error) {\n    console.error('\\nError:', error instanceof Error ? error.message : error);\n    process.exit(1);\n  }\n}\n\nmain();\n</code></pre> <p>Note that the relative price value is related to the cost estimated in the relay chain XCM fee calculation section or to the one shown in the units per weight section if the target is another parachain. You'll need to find the correct value to ensure that the amount of tokens the Computed Origin account holds is correct. Calculating the associated XCM execution fee is as simple as multiplying the <code>transactExtraWeightSigned</code> times the <code>relativePrice</code> (for an estimation):</p> <pre><code>XCM-Wei-Token-Cost = transactExtraWeightSigned * relativePrice\nXCM-Token-Cost = XCM-Wei-Token-Cost / DecimalConversion\n</code></pre> <p>Therefore, the actual calculation for one XCM Transactor transact through derivative call is:</p> <pre><code>XCM-Wei-Token-Cost = 400000000 * 50000000000000000\nXCM-Token-Cost = 20000000000000 / 10^18\n</code></pre> <p>The cost of transacting through a Computed Origin is <code>0.00002 TOKEN</code>. Note that this does not include the cost of the call being remotely executed, only XCM execution fees.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/","title":"How to Register Cross-Chain Assets via Governance","text":""},{"location":"builders/interoperability/xcm/xc-registration/assets/#introduction","title":"Introduction","text":"<p>For an asset to be transferred across chains via XCM, there needs to be an open channel between the two chains, and the asset needs to be registered on the destination chain. If a channel does not exist between the two chains, one will need to be opened. Please check out the XC Channel Registration guide for information on how to establish a channel between Moonbeam and another chain.</p> <p>This guide will show you how to register external XC-20s on Moonbeam and provide the information you need to register Moonbeam assets, including Moonbeam native assets (GLMR, MOVR, and DEV) and local XC-20s (XCM-enabled ERC-20s), on another chain.</p> <p>The examples in this guide use a CLI tool developed to ease the entire process, which you can find in the xcm-tools GitHub repository.</p> <pre><code>git clone https://github.com/Moonsong-Labs/xcm-tools &amp;&amp; \\\ncd xcm-tools &amp;&amp; \\\nyarn\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#register-xc-20s","title":"Register External XC-20s on Moonbeam","text":"<p>Registering External XC-20s on Moonbeam is a multi-step process that, at a high level, involves proposing the asset registration on the Moonbeam Community Forum and creating an on-chain governance proposal.</p> <p>If a channel between Moonbeam and the origin chain of the asset does not yet exist, one will need to be opened. You can batch the channel-related calls with the asset registration calls, so you only need to submit a single proposal. You must start by creating a couple of forum posts: an XCM Disclosure post and an XCM Proposal post.</p> <p>After you've collected feedback from community members, you can create a proposal to open a channel and register any assets. Please refer to the Establishing an XC Integration with Moonbeam guide for more information on opening a channel.</p> <p></p> <p>If a channel between the chains already exists, you'll need to create a forum post to register the asset, collect feedback, and then submit the proposal to register the asset.</p> <p></p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#create-a-forum-post","title":"Create a Forum Post","text":"<p>To create a forum post on the Moonbeam Community Forum, you'll need to make sure that you're adding the post to the correct category and adding relevant content. For general guidelines and a template to follow, please refer to the Moonbeam Community Forum Templates for XCM Integrations page.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#calculate-relative-price","title":"Calculate Relative Price","text":"<p>An asset's <code>relativePrice</code> refers to a <code>u128</code> value that indicates how many units of said asset (in its smallest denomination) equate to one unit\u2014i.e., <code>1 \u00d7 10^18 Wei</code>\u2014of the native token (GLMR or MOVR). This helps determine how much of your asset to use for fees initially quoted in the native token, particularly in cross-chain messaging (XCM).</p> <p>You can use the following script (also available as part of xcm-tools ) to calculate the correct <code>relativePrice</code> value for your asset.</p> Calculate Relative Price <pre><code>\n</code></pre> <p>Only three parameters are required to calculate the relative price of an asset: </p> <ul> <li>Asset Price (USD) - a positive number representing how much 1 unit (in human-readable form) of your asset costs in USD</li> <li>Asset Decimals - the number of decimal places your asset uses. For example, if your token has 12 decimals, specify 12</li> <li>Network - either GLMR (Moonbeam) or MOVR (Moonriver). This should correspond to the network that you're registering the asset on, and this determines which native token\u2019s USD price the script will fetch from CoinGecko</li> </ul> <p>First, ensure that you've installed the required dependencies by running:</p> <pre><code>yarn\n</code></pre> <p>Execute the script, making sure to provide the USD price of the asset you're registering, the number of decimals it has, and the network you're registering the asset on (either GLMR or MOVR):</p> <pre><code>yarn calculate-relative-price INSERT_ASSET_PRICE INSERT_DECIMALS GLMR\n</code></pre> <p>For example, if the asset you're registering has a USD price of $0.25 and 12 decimals and you're registering the asset on the Moonbeam network, you would run: </p> <pre><code>yarn calculate-relative-price 0.25 12 GLMR\n</code></pre> <p>This instructs the script to calculate how many smallest units of an asset (priced at $0.25, with 12 decimals) correspond to 1 GLMR token.</p> <p>Upon successful execution, the script prints the computed <code>relativePrice</code> as a <code>BigInt</code>. This value represents the scaled ratio between the asset\u2019s USD price and the native token\u2019s USD price, multiplied up to 18 decimals. You can then use this result in on-chain asset registration or fee calculation scenarios\u2014especially where a <code>u128</code> 18-decimal format is required.</p> <p>For additional info, usage details, or to see an example in action, you can invoke the help command by running: </p> <pre><code>yarn calculate-relative-price --help\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#generate-encoded-calldata-for-asset-registration","title":"Generate the Encoded Calldata for the Asset Registration","text":"<p>Submitting a governance proposal on Moonbeam requires two steps: first, submit a preimage that defines the actions to be executed, then use that preimage to submit the proposal. For more details, see the Governance on Moonbeam page. To submit a preimage for asset registration, you'll need the encoded calldata for both the <code>evmForeignAssets.createForeignAsset</code> and <code>xcmWeightTrader.addAsset</code> extrinsics. An existing asset's price can be updated with <code>xcmWeightTrader.editAsset</code>. </p> <p>Proposals must be submitted via the Fast General Admin track. A channel must be established before an asset can be registered. To get the encoded calldata for the <code>evmForeignAssets.createForeignAsset</code> extrinsic, you will need to provide the following arguments:</p> <ul> <li><code>assetId</code> - unique identifier of the asset, generated from the <code>calculate-external-asset-info.ts</code> script</li> <li><code>xcmLocation</code> - the multilocation of the asset relative to Moonbeam </li> <li><code>decimals</code> - the number of decimals of the asset</li> <li><code>symbol</code>  - the symbol of the asset. Remember that \"xc\" should be prepended to the symbol to indicate the asset is an XCM-enabled asset</li> <li><code>name</code> - the asset name</li> </ul> <p>Using the above information, you can generate the encoded call data for the <code>createForeignAsset</code> call either via the Polkadot API or on Polkadot.js Apps.</p> <p>You can generate this required calldata using the xcm-asset-registrator script as follows:</p> <pre><code>yarn register-asset --w wss://wss.api.moonbeam.network  \\\n--asset \"INSERT_MULTILOCATION\" \\\n--symbol \"INSERT_ASSET_SYMBOL\" \\\n--decimals INSERT_DECIMALS \\\n--name \"INSERT_ASSET_NAME\" \\\n--relative-price INSERT_RELATIVE_PRICE\n</code></pre> <p>Upon running the script with the relevant parameters, you'll see output like the following: </p> <p>The script will provide the encoded call data for each of the following calls:</p> <ul> <li>The <code>registerAsset</code> call</li> <li>The <code>setRelativePrice</code> call</li> <li>The <code>batch</code> call that combines all of the above</li> </ul> <p></p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#construct-the-add-asset-call","title":"Construct the Add Asset Call","text":"<p>If you've already used the xcm-asset-registrator script shown above, you can skip this section. This section dives into more detail about how the <code>xcmWeightTrader.addAsset</code> call is constructed. To get the encoded calldata for the <code>xcmWeightTrader.addAsset</code> extrinsic, you will need to provide the following arguments:</p> <ul> <li><code>xcmLocation</code> - the multilocation of the asset relative to Moonbeam </li> <li><code>relativePrice</code> - A numeric value (u128) representing the fraction of the native token\u2019s price that your asset\u2019s price constitutes, scaled to 18 decimals. This value calculates cross-chain fees by determining how many units of the non-native asset are required to cover XCM operation costs </li> </ul> <p>Using the above information, you can generate the encoded call data for the <code>addAsset</code> call either via the Polkadot API or on Polkadot.js Apps.</p> <p>To create a batch transaction that combines both the <code>xcmWeightTrader.addAsset</code> and the <code>evmForeignAssets.createForeignAsset</code> calls together, you can use the Polkadot API's <code>batch</code> method. As mentioned previously, the XCM asset registrator script can help you build and submit the required calls. </p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#submit-preimage-proposal","title":"Submit the Preimage and Proposal for Asset Registration","text":"<p>Your next task is to submit the preimage of your batched call containing both the <code>xcmWeightTrader.addAsset</code> and the <code>evmForeignAssets.createForeignAsset</code> by following the guidelines in the Submit a Democracy Proposal Guide.</p> <p>You do not need to go through governance for Moonbase Alpha, as Moonbase Alpha has sudo access. Instead, you can provide the output of the batch call data to the Moonbeam team, and they can submit the call with sudo. This will be a faster and easier process than going through governance. However, you may still wish to go through governance on Moonbase Alpha to prepare for Moonbeam's governance process.</p> <p>After submitting the preimage, you can submit the proposal by following the guidelines in the Submitting a Proposal section.</p> <p>If you prefer the script method and you're comfortable working with the scripts in the XCM tools repo, you can use the generic call proposer by passing in the requisite calls, including the acceptance and proposal of the XCM Channel, and the asset registration. The generic call proposer can help you assemble the multiple requisite calls as follows:</p> <pre><code>yarn generic-call-propose \\\n  --call INSERT_CALLDATA_INCOMING_XCM_CHANNEL \\\n  --call INSERT_CALLDATA_OUTGOING_XCM_CHANNEL \\\n  --call INSERT_CALLDATA_BATCH_ASSET_REGISTRATION \\\n  --ws-provider INSERT_WSS_PROVIDER\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#test-asset-registration","title":"Test the Asset Registration on Moonbeam","text":"<p>After your asset is registered, the team will provide the asset ID and the XC-20 precompile address. Your XC-20 precompile address is calculated by converting the asset ID decimal number to hex and prepending it with F's until you get a 40-hex character (plus the \u201c0x\u201d) address. For more information on how it is calculated, please refer to the Calculate External XC-20 Precompile Addresses section of the External XC-20 guide. After the asset is successfully registered, you can transfer tokens from your parachain to the Moonbeam-based network you are integrating with.</p> <p>Note</p> <p>Remember that Moonbeam-based networks use AccountKey20 (Ethereum-style addresses).</p> <p>For testing, please also provide your parachain WSS endpoint so that the Moonbeam dApp can connect to it. Lastly, please fund the corresponding account:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>AccountId: 5E6kHM4zFdH5KEJE3YEzX5QuqoETVKUQadeY8LVmeh2HyHGt\nHex:       0x5a071f642798f89d68b050384132eea7b65db483b00dbb05548d3ce472cfef48\n</code></pre> <pre><code>AccountId: 5E6kHM4zFdH5KEJE3YEzX5QuqoETVKUQadeY8LVmeh2HyHGt\nHex:       0x5a071f642798f89d68b050384132eea7b65db483b00dbb05548d3ce472cfef48\n</code></pre> <pre><code>AccountId: 5GWpSdqkkKGZmdKQ9nkSF7TmHp6JWt28BMGQNuG4MXtSvq3e\nHex:       0xc4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a063\n</code></pre> <p>Note</p> <p>For Moonbeam and Moonriver testing, please send $50 worth of tokens to the aforementioned account. In addition, provide an Ethereum-style account to send $50 worth of GLMR/MOVR for testing purposes.</p> <p>XC-20s are Substrate-based assets with an ERC-20 interface. This means they can be added to MetaMask and composed with any EVM DApp that exists in the ecosystem. The team can connect you with any DApp you find relevant for an XC-20 integration.</p> <p>If you need DEV tokens (the native token for Moonbase Alpha) to use your XC-20 asset, you can get some from the Moonbase Alpha Faucet, which dispenses 1.1 DEV tokens every 24 hours. If you need more, feel free to reach out to the team on Telegram or Discord.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#set-bytecode","title":"Set XC-20 Precompile Bytecode","text":"<p>Once your XC-20 has been registered on Moonbeam, you can set the XC-20's precompile bytecode. This is necessary because precompiles are implemented inside the Moonbeam runtime and, by default, do not have bytecode. In Solidity, when a contract is called, there are checks that require the contract bytecode to be non-empty. So, setting the bytecode as a placeholder bypasses these checks and allows the precompile to be called.</p> <p>You can use the Precompile Registry, which is a Solidity interface, to update the XC-20 precompile's bytecode to avoid any issues and ensure that the precompile is callable from Solidity. To do so, you'll use the Precompile Registry's <code>updateAccountCode</code> function.</p> <p>To get started, you'll need to calculate your XC-20's precompile address and have the Precompile Registry's ABI.</p> Precompile Registry ABI <pre><code>[\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isActivePrecompile\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isPrecompile\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"updateAccountCode\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    }\n]\n</code></pre> <p>Then, you can use the following scripts to set the dummy code for your XC-20's precompile.</p> <p>Remember</p> <p>The following snippets are for demo purposes only. Never store your private keys in a JavaScript or Python file.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>After running the script to set the bytecode, you should see <code>The XC-20 precompile's bytecode is: 0x60006000fd</code> printed to your terminal.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#register-moonbeam-assets-on-another-chain","title":"Register Moonbeam Assets on Another Chain","text":"<p>To enable cross-chain transfers of Moonbeam assets, including Moonbeam native assets (GLMR, MOVR, DEV) and local XC-20s (XCM-enabled ERC-20s) deployed on Moonbeam, between Moonbeam and another chain, you'll need to register the assets on the other chain. Since each chain stores cross-chain assets differently, the exact steps to register Moonbeam assets on another chain will vary depending on the chain. At the very least, you'll need to know the metadata and the multilocation of the assets on Moonbeam.</p> <p>There are additional steps aside from asset registration that will need to be taken to enable cross-chain integration with Moonbeam. For more information, please refer to the Establishing an XC Integration with Moonbeam guide.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#register-moonbeam-native-assets","title":"Register Moonbeam Native Assets on Another Chain","text":"<p>The metadata for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Name Glimmer Symbol GLMR Decimals 18 Existential deposit 1 (1 * 10^-18 GLMR) Variable Value Name Moonriver Symbol MOVR Decimals 18 Existential deposit 1 (1 * 10^-18 MOVR) Variable Value Name DEV Symbol DEV Decimals 18 Existential deposit 1 (1 * 10^-18 DEV) <p>The multilocation of Moonbeam native assets includes the parachain ID of the Moonbeam network and the pallet instance where Moonbeam assets live, which corresponds to the index of the Balances Pallet. The multilocation for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { \n          Parachain: 2004\n        },\n        {\n          PalletInstance: 10\n        }\n      ]\n    }\n  }\n}\n</code></pre> <pre><code>{\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { \n          Parachain: 2023\n        },\n        {\n          PalletInstance: 10\n        }\n      ]\n    }\n  }\n}\n</code></pre> <pre><code>{\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { \n          Parachain: 1000\n        },\n        {\n          PalletInstance: 3\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#register-local-xc20","title":"Register Local XC-20s on Another Chain","text":"<p>The multilocation for local XC-20s include the parachain ID of Moonbeam, the pallet instance, and the address of the ERC-20. The pallet instance corresponds to the index of the ERC-20 XCM Bridge Pallet, as this is the pallet that enables any ERC-20 to be transferred via XCM.</p> <p>To be registered on other chains, local XC-20s must strictly comply with the standard ERC-20 interface as described in EIP-20. In particular, the <code>transfer</code> function must be as described in EIP-20:</p> <pre><code>function transfer(address _to, uint256 _value) public returns (bool success)\n</code></pre> <p>If the function selector of the <code>transfer</code> function deviates from the standard, the cross-chain transfer will fail.</p> <p>You can use the following multilocation to register a local XC-20:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: {\n    X3: [\n      { \n        Parachain: 2004\n      },\n      {\n        PalletInstance: 110\n      },\n      {\n        AccountKey20: {\n          key: 'INSERT_ERC20_ADDRESS'\n        }\n      }\n    ]\n  }\n}\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X3: [\n      { \n        Parachain: 2023\n      },\n      {\n        PalletInstance: 110\n      },\n      {\n        AccountKey20: {\n          key: 'INSERT_ERC20_ADDRESS'\n        }\n      }\n    ]\n  }\n}\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X3: [\n      { \n        Parachain: 1000\n      },\n      {\n        PalletInstance: 48\n      },\n      {\n        AccountKey20: {\n          key: 'INSERT_ERC20_ADDRESS'\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>Since local XC-20s are ERC-20s on Moonbeam, there are no deposits required to create an ERC-20 on Moonbeam. However, deposits may be required to register the asset on another parachain. Please consult with the parachain team you wish to register the asset with for more information.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#managing-xc-assets","title":"Managing XC Assets","text":"<p>After completing the registration process for an XC asset, you may need to periodically update asset details, such as the XCM multilocation details or asset price. This section will cover these topics.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#updating-foreign-asset-xcm-location","title":"Updating Foreign Asset XCM Location","text":"<p>You can update the multilocation of an asset with the <code>evmForeignAssets.changeXcmLocation</code> call, which takes as parameters the <code>assetId</code> and the new multilocation. You'll need to raise a governance proposal and submit the update under the General Admin track. If you're testing in Moonbase Alpha, you can ask the Moonbeam Team to submit the extrinsic using Sudo to speed up the process. You can also submit the requisite governance proposal on Moonbase Alpha. </p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#freezing-a--foreign-asset","title":"Freezing a Foreign Asset","text":"<p>You can freeze a foreign asset by calling <code>evmForeignAssets.freezeForeignAsset</code>, which takes as parameters the <code>assetId</code> and an <code>allowXcmDeposit</code> boolean. If set to true, XCM deposits from remote chains will still be allowed and mint tokens. If set to false, XCM deposits from remote chains will fail as no minting will be permitted. </p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#paying-xcm-fees-with-foreign-assets","title":"Paying XCM Fees with Foreign Assets","text":"<p>After you've registered the foreign asset via the <code>evmForeignAssets</code> and the <code>xcmWeightTrader</code> pallet, your asset will now be among the supported assets for paying XCM fees. To verify, you can query the <code>xcmWeightTrader</code> pallet and the <code>supportedAssets</code> chain state query. Toggle the Include Option slider off to see the complete list, or you can filter the list by the multilocation of your asset. </p>"},{"location":"builders/interoperability/xcm/xc-registration/forum-templates/","title":"Moonbeam Community Forum Templates for XCM Integrations","text":""},{"location":"builders/interoperability/xcm/xc-registration/forum-templates/#introduction","title":"Introduction","text":"<p>When starting an XCM integration on Moonriver or Moonbeam MainNet, there are two preliminary posts that must be made on the Moonbeam Community Forum so that the voting community has the chance to provide feedback. The two preliminary posts are an XCM disclosure and an XCM proposal. This step is not necessary when connecting to Moonbase Alpha.</p> <p>If only an asset is being registered, the cross-chain channel must already be established, and so only an XCM proposal post is required to register the asset.</p> <p>It is recommended that this be done five days before the actual proposal is submitted on chain to provide time for community feedback.</p>"},{"location":"builders/interoperability/xcm/xc-registration/forum-templates/#xcm-disclosure","title":"XCM Disclosures","text":"<p>The first post that should be made are the key disclosures within the XCM Disclosures category, which highlight key information that is important to a voter's decision. This post is only required when establishing an XCM integration; it is not necessary if the integration already exists and you only need to register an asset.</p> <p>Once you hit the New Topic button, a template is provided with the relevant information to be filled in. Please use either the Moonbeam/Moonriver tag, depending on the network you are integrating with.</p> <p>In the post, please provide the following information:</p> <ul> <li>Title - XCM Disclosure: YOUR_NETWORK_NAME</li> <li>Network Information \u2014 one sentence summarizing your network and relevant links to your website, Twitter, and other social channels</li> </ul> <p>You'll also need to provide answers to the following questions:</p> <ul> <li>Is the blockchain network's code open source? If so, please provide the GitHub link. If not, provide an explanation of why not</li> <li>Is SUDO disabled on the network? If SUDO is disabled, is the network controlled by a select group of addresses?  </li> <li>Has the integration of the network been tested completely on the Moonbase Alpha TestNet?  </li> <li>(For Moonbeam HRMP proposals only) Does your network have a Kusama deployment? If so, provide its network name and whether the Kusama deployment is integrated with Moonriver</li> <li>Is the blockchain network's code audited? If so, please provide:</li> <li>Auditor name(s)</li> <li>Dates of audit reports</li> <li>Links to audit reports</li> </ul>"},{"location":"builders/interoperability/xcm/xc-registration/forum-templates/#xcm-proposals","title":"XCM Proposals","text":"<p>The second post is a preliminary draft of the proposal in the XCM Proposals category. Once a proposal is submitted on-chain and available for voting, you must also add a description to it in either the Moonbeam Polkassembly or Moonriver Polkassembly.</p> <p>Once you hit the New Topic button, a template is provided with the relevant information to be filled in. Please use either the Moonbeam or Moonriver tag, depending on the network you are integrating with.</p> <p>In both the Moonbeam XCM Proposals forum post and in Polkassembly, add the following sections and information:</p> <ul> <li>Title \u2014 YOUR_NETWORK_NAME Proposal to Open Channel &amp; Register ASSET_NAME. If you're only registering an asset, you can use: YOUR_NETWORK_NAME Proposal to Register ASSET_NAME</li> <li>Introduction \u2014 one sentence summarizing the proposal</li> <li>Network Information \u2014 one sentence summarizing your network and relevant links to your website, Twitter, and other social channels</li> <li>Summary \u2014 brief description of the content of the proposal</li> <li>On-Chain Proposal Reference \u2014 include if it is a Moonbeam or Moonriver proposal, the proposal number, and the proposal hash</li> <li>Technical Details \u2014 provide technical information required for the community to understand the use cases and purpose of the proposal</li> <li>Additional Information \u2014 any additional information you would like the community to know</li> </ul>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/","title":"Self-Serve Asset Registration for Sibling Parachains","text":""},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#introduction","title":"Introduction","text":"<p>Registering your parachain's native tokens on Moonbeam or Moonriver lets your community enjoy ERC\u201120\u2013style UX and deep EVM integrations while retaining full on\u2011chain provenance. This guide shows sibling Polkadot parachain teams how to self\u2011register a foreign asset using the new <code>ForeignAssetOwnerOrigin</code> introduced in Moonbeam Runtime 3600.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#why-a-new-origin","title":"Why a New Origin?","text":"<p>Moonbeam introduced a new dedicated origin called <code>ForeignAssetOwnerOrigin</code>, which only permits an XCM message whose origin contains the asset's multilocation to execute calls in the <code>evm\u2011foreign\u2011assets</code> pallet. In practice, that means only the sovereign account of the parachain that owns the asset, or Moonbeam governance, can create, freeze, unfreeze, or relocate it. Alongside this, a configurable runtime constant called <code>ForeignAssetCreationDeposit</code> is reserved from the caller's sovereign account at creation time. The deposit discourages spam registrations.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#required-deposits","title":"Required Deposits","text":"<p>To prevent spam, a <code>ForeignAssetCreationDeposit</code> is required and locked for the lifetime of the asset. The deposit is funded from the sibling parachain's sovereign account on the Moonbeam network, which thus needs to be sufficiently funded to cover the asset deposit and the associated transaction fees. If the asset is destroyed through governance, the deposit is unreserved and returned to the original sovereign account.</p> <p>Deposits are network\u2011specific and can be adjusted by Moonbeam governance via the <code>parameters</code> pallet:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Foreign Asset Deposit 10,000 GLMR Variable Value Foreign Asset Deposit 1,000 MOVR Variable Value Foreign Asset Deposit 100 DEV"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#prerequisites","title":"Prerequisites","text":"<p>There are a few prerequisites to be aware of: </p> <ul> <li>The sibling parachain's sovereign account on Moonbeam must be sufficiently funded to cover the asset deposit and the transaction fees. It's recommended that you have an extra buffer of additional funds for any subsequent transactions. See this guide to calculating a sovereign account</li> <li>Your parachain should support XCM V4</li> <li>Your parachain needs bidirectional XCM channels with Moonbeam. See this guide for information on opening XCM channels with Moonbeam </li> </ul>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#assemble-your-asset-details","title":"Assemble Your Asset Details","text":"<p>Before you register your sibling-parachain token on Moonbeam, you'll need to gather four pieces of information:</p> <ul> <li><code>AssetID</code>: A deterministic <code>u128</code> derived from the token's <code>multilocation</code> (see below).</li> <li><code>Decimals</code>: How many decimal places the token uses (for example, <code>18</code>).</li> <li><code>Symbol</code>: A short ticker such as <code>xcTEST</code>. The ticker should be prepended with <code>xc</code>.</li> <li><code>Name</code>: A human-readable name such as <code>Test Token</code>.</li> </ul> <pre><code>const ASSET_ID = 42259045809535163221576417993425387648n;\nconst DECIMALS = 18n;\nconst SYMBOL   = \"xcTEST\";\nconst NAME     = \"Test Token\";\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#calculate-asset-id","title":"How to Calculate Asset ID","text":"<p>To generate a token's asset ID, you'll first need to know its multilocation. <code>assetLocation</code> is a SCALE\u2011encoded multilocation that pinpoints the existing token on your sibling parachain. There are various ways to define assets and your multilocation may including parachain ID, the pallet that manages assets there, and the local asset index. Because the extrinsic executes on Moonbeam, you describe the path from Moonbeam's perspective: first hop up one level to the Relay <code>(\"parents\": 1)</code>, then down into your parachain <code>(Parachain: &lt;paraId&gt;)</code>, the pallet, and the asset index. Moonbeam uses this to verify that the caller actually \"contains\" the asset before allowing any registration or updates. </p> <p>Once you've constructed your multilocation, keep it handy, as you'll need it in the next step. A typical asset multilocation looks like this:</p> <pre><code>{\n  \"parents\": 1,          // Up to Relay\n  \"interior\": {\n    \"X3\": [              // Down to sibling para asset\n      { \"Parachain\": 4 },\n      { \"PalletInstance\": 12 },\n      { \"GeneralIndex\": 15 }  // Arbitrary example values\n    ]\n  }\n}\n</code></pre> <p>The XCM tools repo has a helpful Calculate External Asset Info script that you can use to generate the asset ID programmatically. The script takes two parameters, namely, the multilocation of your asset and the target network (Moonbeam or Moonriver). Call the <code>calculate-external-asset-info.ts</code> helper script with your asset's multilocation and target network, as shown below, to easily generate its asset ID.</p> <pre><code>ts-node scripts/calculate-external-asset-info.ts \\\n  --asset '{\"parents\":1,\"interior\":{\"X3\":[{\"Parachain\":4},{\"PalletInstance\":12},{\"GeneralIndex\":15}]}}' \\\n  --network moonbeam\n</code></pre> <p>The script will return the <code>assetID</code> you are now ready to pass to <code>evmForeignAssets.createForeignAsset</code>.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#derive-the-xc-20-address","title":"Derive the XC-20 Address","text":"<p>Convert <code>assetID</code> to hex, left-pad it to 32 hex chars, and prepend eight <code>F</code>s as follows:</p> <pre><code>xc20Address = 0xFFFFFFFF + hex(assetId).padStart(32, '0')\n</code></pre> <p>The XC-20 address of xcDOT as an example can be calculated like so: </p> FormulaExample <pre><code>const xc20Address = `0xFFFFFFFF${hex(assetId).padStart(32, \"0\")}`;\n</code></pre> <pre><code>0xFFFFFFFF1FCACBD218EDC0EBA20FC2308C778080\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#generate-the-encoded-call-data","title":"Generate the Encoded Call Data","text":"<p>The snippet below shows how to build the call that needs to be sent to Moonbeam that creates the foreign asset. Save the resulting hex string because you will embed it inside a subsequent XCM <code>Transact</code> call dispatched from your sibling parachain.</p> <pre><code>import '@moonbeam-network/api-augment';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\nimport { blake2AsHex } from '@polkadot/util-crypto';\n\nconst moonbeam = await ApiPromise.create({\n  provider: new WsProvider(MOONBEAM_WSS),\n});\n\nconst tx = moonbeam.tx.evmForeignAssets.createForeignAsset(\n  ASSET_ID,\n  assetLocation,\n  DECIMALS,\n  SYMBOL,\n  NAME\n);\n\n// SCALE-encoded call data (includes call index 0x3800)\nconst encodedCall = tx.method.toHex();\nconsole.log('Encoded call data:', encodedCall);\n\n// Optional: 32-byte call hash (blake2_256)\nconsole.log('Call hash:', blake2AsHex(encodedCall));\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#dispatch-the-call-with-xcm-transact","title":"Dispatch the Call with XCM Transact","text":"<p>To register your asset, wrap the SCALE\u2011encoded <code>createForeignAsset</code> bytes in a single <code>Transact</code> instruction executed from your parachain's sovereign account. The basic structure of the call is outlined below:</p> <pre><code>Transact {\n  originKind: SovereignAccount,\n  requireWeightAtMost: &lt;weight&gt;,\n  call: &lt;encodedCall&gt;\n}\n</code></pre> <p>Send the transact instruction via <code>xcmPallet.send</code>, targeting parachain <code>2004</code> for Moonbeam (or <code>2023</code> for Moonriver). </p> <pre><code>xcmPallet.send(\n  dest: { Parachain: 2004 },\n  message: VersionedXcm::V4(INSERT_TRANSACT_INSTRUCTION)\n);\n</code></pre> <p>Finally, look for the following event emitted successfully on Moonbeam:</p> <pre><code>EvmForeignAssets.ForeignAssetCreated(assetId, location, creator)\n</code></pre> <p>Its presence confirms the XC-20 asset is live.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#managing-an-existing-foreign-asset","title":"Managing an Existing Foreign Asset","text":"<p>After a foreign asset has been created, the following extrinsics can be used to update it. Note that in the case of the sovereign account sending a call, the sovereign account and location must still be inside the origin. Otherwise, the only other authorized origin is <code>Root</code> from a Moonbeam governance action. </p> Extrinsic Who can call? Notes <code>changeXcmLocation</code> Sibling sovereign account or Moonbeam governance Requires deposit already reserved. <code>freezeForeignAsset</code> / <code>unfreezeForeignAsset</code> Sibling sovereign account or Moonbeam governance <code>freeze</code> optionally destroys the asset's metadata."},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#faqs","title":"FAQs","text":""},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#how-do-i-reclaim-the-deposit","title":"How do I reclaim the deposit?","text":"<p>Deposits remain reserved for the life of the asset. If the asset is destroyed through governance, the deposit is unreserved and returned to the original sovereign account.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#can-a-normal-eoa-register-an-asset","title":"Can a normal EOA register an asset?","text":"<p>No. Calls from non\u2011sovereign, non\u2011governance accounts fail with <code>BadOrigin</code>.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#what-happens-if-my-xcm-location-is-outside-my-origin","title":"What happens if my XCM location is outside my origin?","text":"<p>The call is rejected with <code>LocationOutsideOfOrigin</code>. Double\u2011check the <code>Parachain</code>, <code>PalletInstance</code>, and <code>GeneralIndex</code> fields.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#is-there-a-limit-to-how-many-assets-can-be-created","title":"Is there a limit to how many assets can be created?","text":"<p>Yes, there is a limit of <code>256</code> foreign assets per network (e.g., Moonbeam, Moonriver). Attempts beyond this return <code>TooManyForeignAssets</code>. If this threshold is approached, a revision can be made in a future runtime upgrade to lift this limit.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/","title":"How to Establish an XC Integration with Moonbeam","text":""},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#introduction","title":"Introduction","text":"<p>While Cross-Chain Message Passing (XCMP) is being developed, a stop-gap protocol has been implemented called Horizontal Relay-routed Message Passing (HRMP). It has the same interface and functionality as XCMP, but the messages are stored in and read from the relay chain. Whereas with XCMP, only the message's associated metadata is stored in the relay chain. Since all messages are passed via the relay chain with HRMP, it is much more demanding on resources. As such, HRMP will be phased out once XCMP is implemented.</p> <p>All XCMP channel integrations with Moonbeam are unidirectional, meaning messages flow only in one direction. If chain A initiates a channel to chain B, chain A will only be allowed to send messages to B, and B will not be able to send messages back to chain A. As such, chain B will also need to initiate a channel with chain A to send messages back and forth between the two chains.</p> <p>Once the XCMP (or HRMP) channels have been opened, the corresponding assets from both chains will need to be registered on the opposing chain before being able to be transferred. To find step-by-step details on how to register an asset, you can refer to the How to Register Cross-Chain Assets guide.</p> <p>This guide will cover the process of opening and accepting an HRMP channel between a parachain and a Moonbeam-based network. In addition, the guide provides the necessary steps to create a batch proposal that combines opening and accepting a channel and registering an asset on Moonbeam into a single proposal.</p> <p>All of the examples in this guide use a CLI tool developed to ease the entire process, which you can find in the xcm-tools GitHub repository.</p> <pre><code>git clone https://github.com/Moonsong-Labs/xcm-tools &amp;&amp; \\\ncd xcm-tools &amp;&amp; \\\nyarn\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#moonbase-alpha-xcm","title":"Moonbase Alpha XCM Integration Overview","text":"<p>The first step for a Moonriver/Moonbeam XCM integration is to integrate with the Moonbase Alpha TestNet through the Alphanet relay chain. Then a Moonriver integration must be completed before proceeding with Moonbeam (if applicable).</p> <p>The entire process of getting started with Moonbase Alpha can be summarized as follows:</p> <ol> <li>Sync a node with the Alphanet relay chain</li> <li>Calculate your parachain Sovereign account on the Alphanet relay chain</li> <li>Once your node is fully synced, please get in touch with the Moonbeam team on Telegram or Discord, so the team can onboard your parachain to the relay chain. Provide the following information for onboarding:</li> <li>The WASM/Genesis head hash</li> <li>Your parachain ID</li> <li>Your Sovereign account's address. The Moonbeam team will fund your Sovereign account at the relay chain level. This step is required to be able to create the HRMP channel</li> <li>The encoded call data to open an HRMP channel to your parachain, accept the incoming HRMP channel, and register the assets (if applicable). This will be executed through sudo</li> <li>Open an HRMP channel to Moonbase Alpha from your parachain (through sudo or via governance)</li> <li>Accept the HRMP channel from Moonbase Alpha (through sudo or via governance)</li> <li>(Optional) Register Moonbase Alpha's DEV token on your parachain</li> <li>For testing the XCM integration, please send some tokens to:</li> </ol> <pre><code>AccountId (Encoded): 5GWpSdqkkKGZmdKQ9nkSF7TmHp6JWt28BMGQNuG4MXtSvq3e\nDecoded (32-Bytes):  0xc4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a063\n</code></pre> <ol> <li>Test the XCM integration</li> </ol> <p></p> <p>Once all of these steps are completed and both teams have successfully tested asset transfers, your parachain token can be added to the Cross Chain Assets section of the Moonbeam DApp. If deposits and withdrawals work as expected, integration with Moonriver can begin.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#sync-a-node","title":"Sync a Node","text":"<p>To sync a node, you can use the Alphanet relay chain specs (note: the relay chain is Westend-based, and will probably take one day to sync).</p> <p>For reference, you can use Moonbase Alpha's spec file. You'll need to adapt it to your chain.</p> <p>There are also some snapshots for the Alphanet ecosystem relay chain you can use to quickly get started, these are provided by the community.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#calculate-and-fund-the-parachain-sovereign-account","title":"Calculate and Fund the Parachain Sovereign Account","text":"<p>You can calculate the Sovereign account information using a script from the xcm-tools repository. To run the script, you must provide the parachain ID and the name of the associated relay chain.</p> <p>You can find the parachain IDs that have already been used on the relay chain's Polkadot.js Apps page.</p> <p>The accepted values for the relay chain are <code>polkadot</code> (default), <code>kusama</code>, and <code>moonbase</code>.</p> <p>For example, Moonbase Alpha's Sovereign account for both the relay chain and other parachains can be obtained with the following:</p> <pre><code>yarn calculate-sovereign-account --p 1000 --r moonbase\n</code></pre> <p>Which should result in the following response:</p> <pre><code>Sovereign Account Address on Relay: 0x70617261e8030000000000000000000000000000000000000000000000000000\nSovereign Account Address on other Parachains (Generic): 0x7369626ce8030000000000000000000000000000000000000000000000000000\nSovereign Account Address on Moonbase Alpha: 0x7369626ce8030000000000000000000000000000\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#moonriver-moonbeam","title":"Moonriver &amp; Moonbeam XCM Integration Overview","text":"<p>From a technical perspective, the process of creating an HRMP channel with Moonriver and Moonbeam is nearly identical. However, engagement with the Moonbeam community is crucial and required before a proposal will pass.</p> <p>Please check the HRMP channel guidelines that the community voted on for Moonriver and Moonbeam before starting.</p> <p>The process can be summarized in the following steps:</p> <ol> <li>Open (or ensure there is) an HRMP channel from your chain to Moonriver/Moonbeam. Optionally, register MOVR/GLMR</li> <li>Create two Moonbeam Community forum posts with some key information for the XCM integration:</li> <li>An XCM Disclosure post, where you'll provide some disclosures about the project, the code base, and social network channels</li> <li>An XCM Proposal post, where you'll provide some technical information about the proposal itself</li> <li> <p>Create a batch proposal on Moonbeam/Moonriver to:</p> </li> <li> <p>Accept the incoming HRMP channel</p> </li> <li>Propose the opening of an outgoing HRMP channel from Moonriver/Moonbeam</li> <li>Register the asset as an XC-20 token (if applicable)</li> </ol> <p>Proposals should be done in the General Admin Track from OpenGov. The normal enactment times are as follows:</p> <ul> <li>Moonriver - the Decision Period is approximately 14 days and the enactment time is at least 1 day</li> <li> <p>Moonbeam - the Decision Period is approximately 14 days and the enactment time is at least 1 day</p> </li> <li> <p>Accept the HRMP channel from Moonriver/Moonbeam on the connecting parachain</p> </li> <li>Exchange $50 worth of tokens for testing the XCM integration. Please send the tokens to:</li> </ul> <pre><code>AccountId (Encoded): 5E6kHM4zFdH5KEJE3YEzX5QuqoETVKUQadeY8LVmeh2HyHGt\nDecoded (32-Bytes):  0x5a071f642798f89d68b050384132eea7b65db483b00dbb05548d3ce472cfef48\n</code></pre> <ol> <li>Provide an Ethereum-styled address for MOVR/GLMR</li> <li>Test the XCM integration with the provided tokens</li> </ol> <p>An example of this process with a successful proposal on Moonbeam is depicted in the following diagram.</p> <p></p> <p>Once these steps are successfully completed, marketing efforts can be coordinated, and the new XC-20 on Moonriver/Moonbeam can be added to the Cross Chain Assets section of the Moonbeam DApp.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#create-forum-posts","title":"Create Forum Posts","text":"<p>To create forum posts on the Moonbeam Community Forum, you'll need to make sure that you're adding the posts to the correct category and adding relevant content. For general guidelines and templates to follow, please refer to the Moonbeam Community Forum Templates for XCM Integrations page.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#create-an-hrmp-channel","title":"Creating HRMP Channels","text":"<p>Before any messages can be sent from your parachain to Moonbeam, an HRMP channel must be opened. To create an HRMP channel, you'll need to send an XCM message to the relay chain that will request a channel be opened through the relay chain. The message will need to contain at least the following XCM instructions:</p> <ol> <li>WithdrawAsset - takes funds out of the Sovereign account (in the relay chain) of the origin parachain to a holding state</li> <li>BuyExecution - buys execution time from the relay chain to execute the XCM message</li> <li>Transact - provides the relay chain call data to be executed. In this case, the call will be an HRMP extrinsic</li> </ol> <p>Note</p> <p>You can add DepositAsset to refund the leftover funds after the execution. If this is not provided, no refunds will be made. In addition, you could also add a RefundSurplus after Transact to get any leftover funds not used for the Transact. But you'll have to calculate if it is worth paying the execution cost of the extra XCM instructions.</p> <p>To send these XCM messages to the relay chain, the Polkadot XCM Pallet is typically invoked. Moonbeam also has an XCM Transactor Pallet that simplifies the process into a call that abstracts the XCM messaging constructor.</p> <p>You could potentially generate the calldata for an HRMP action by using Polkadot.js Apps, but the xcm-tools GitHub repository can build it for you, and it is the recommended tool for this process.</p> <pre><code>git clone https://github.com/Moonsong-Labs/xcm-tools &amp;&amp; \\\ncd xcm-tools &amp;&amp; \\\nyarn\n</code></pre> <p>The xcm-tools repository has a specific script for HRMP interactions called <code>hrmp-channel-manipulator.ts</code>. This command generates encoded calldata for a specific HRMP action, as long as it is given the correct details. The script builds the XCM message with the DepositAsset XCM instruction but not with RefundSurplus.</p> <p>The encoded calldata is then used to submit a governance proposal that will execute the HRMP action. All HRMP-related proposals should be assigned to the General Admin Track.</p> <p>The <code>hrmp-channel-manipulator.ts</code> script is meant to be generic. It should work for any chain that includes the Polkadot XCM Pallet, although it will try to use the <code>hrmpManage</code> extrinsic of the XCM Transactor Pallet first. If the XCM Transactor Pallet doesn't exist on a chain, the <code>send</code> extrinsic of the Polkadot XCM Pallet will be used. Note that it expects the pallet name to be <code>polkadotXcm</code>, as the extrinsic will be built as <code>api.tx.polkadotXcm.send()</code>. For Moonbeam, the General Admin Track can't execute <code>polkadotXcm.send</code> calls, as such the <code>xcmTransactor.hrmpManage</code> extrinsic must be used.</p> <p>The following sections go through the steps of creating and accepting open channel requests in a Moonbeam-based network, but they can also be adapted to your parachain.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#accept-an-hrmp-channel-on-moonbeam","title":"Accept an HRMP Channel on Moonbeam","text":"<p>When a parachain receives an incoming HRMP channel open request from another parachain, it must signal to the relay chain that it accepts this channel before the channel can be used. This requires an XCM message to the relay chain with the Transact instruction calling the HRMP Pallet and <code>hrmpAcceptOpenChannel</code> extrinsic.</p> <p>Fortunately, the xcm-tools GitHub repository's <code>hrmp-channel-manipulator.ts</code> script can build the XCM for you!</p> <p>To use the script, you'll need to provide the following required arguments:</p> <ul> <li><code>--parachain-ws-provider</code> or <code>--w</code> - specifies the parachain WebSocket provider that will be issuing the requests</li> <li><code>--relay-ws-provider</code> or <code>--wr</code> - specifies the relay chain WebSocket provider that will be issuing the requests</li> <li><code>--hrmp-action</code> or <code>--hrmp</code> - accepts the following action to take, which can be any of the following: <code>accept</code>, <code>cancel</code>, <code>close</code>, and <code>open</code></li> <li><code>--target-para-id</code> or <code>-p</code> - the target parachain ID for the requests</li> </ul> <p>Running the following command will provide the encoded calldata to accept an open HRMP channel request on a Moonbeam network. Replace <code>YOUR_PARACHAIN_ID</code> with the ID of your parachain:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonbeam.network  \\\n--relay-ws-provider wss://rpc.polkadot.io \\\n--hrmp-action accept\n</code></pre> <pre><code>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonriver.moonbeam.network  \\\n--relay-ws-provider wss://kusama-rpc.polkadot.io \\\n--hrmp-action accept\n</code></pre> <pre><code>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonbase.moonbeam.network  \\\n--relay-ws-provider wss://relay.api.moonbase.moonbeam.network \\\n--hrmp-action accept\n</code></pre> <p>Note</p> <p>You can adapt the script for your parachain by changing the <code>parachain-ws-provider</code>.</p> <p>After running the script, you'll see output that looks like the following:</p> yarn hrmp-manipulator --target-para-id 3370 \\ --parachain-ws-provider wss://moonbeam.public.blastapi.io  \\ --relay-ws-provider wss://polkadot-rpc.publicnode.com \\ --hrmp-action accept yarn run v1.22.22 warning ../../../package.json: No license field $ ts-node 'scripts/hrmp-channel-manipulator.ts' --target-para-id 3370 --parachain-ws-provider wss://moonbeam.public.blastapi.io --relay-ws-provider wss://polkadot-rpc.publicnode.com --hrmp-action accept Genesis hash is: 0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3 Polkadot FeeAmount is: 10000000000 XCM Version is V4 Encoded Call Data for Tx is 0x6b09012a0d0000010401000100e40b5402000000000000000000000002286bee020004000100 \u2728  Done in 4.39s. <p>Running the script as shown above will return the encoded calldata to accept an HRMP channel. You can also use the script to create and submit a preimage and proposal on chain for the given HRMP action. For Moonbeam and Moonriver, the proposal must be submitted via the General Admin Track.</p> <p>Please refer to the README for a complete list of the arguments, including optional arguments, and examples on how to use the HRMP-manipulator script.</p> <p>If you plan to batch the transaction with other calls, copy the resultant calldata for later use when using the batch transactions script.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#open-an-hrmp-channel-from-moonbeam","title":"Open HRMP Channels from Moonbeam","text":"<p>Parachains need bidirectional HRMP channels before sending XCM to each other. The first step to establishing an HRMP channel is to create an open channel request. This requires an XCM message to the relay chain with the Transact instruction calling the HRMP Pallet and <code>hrmpInitOpenChannel</code> extrinsic.</p> <p>Fortunately, the xcm-tools GitHub repository's <code>hrmp-channel-manipulator.ts</code> script can build the XCM for you!</p> <p>To use the script, you'll need to provide the following required arguments:</p> <ul> <li><code>--parachain-ws-provider</code> or <code>--w</code> - specifies the parachain WebSocket provider that will be issuing the requests</li> <li><code>--relay-ws-provider</code> or <code>--wr</code> - specifies the relay chain WebSocket provider that will be issuing the requests</li> <li><code>--hrmp-action</code> or <code>--hrmp</code> - accepts the following action to take, which can be any of the following: <code>accept</code>, <code>cancel</code>, <code>close</code>, and <code>open</code></li> <li><code>--target-para-id</code> or <code>-p</code> - the target parachain ID for the requests</li> </ul> <p>Running the following command will provide the encoded calldata to create the HRMP channel request from a Moonbeam network. The maximum message size and capacity values can be obtained from the relay chain's Configuration Pallet and <code>activeConfig</code> extrinsic. Replace <code>YOUR_PARACHAIN_ID</code> with the ID of your parachain:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonbeam.network  \\\n--relay-ws-provider wss://rpc.polkadot.io \\\n--max-capacity 1000 --max-message-size 102400 \\\n--hrmp-action open\n</code></pre> <pre><code>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonriver.moonbeam.network  \\\n--relay-ws-provider wss://kusama-rpc.polkadot.io \\\n--max-capacity 1000 --max-message-size 102400 \\\n--hrmp-action open\n</code></pre> <pre><code>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonbase.moonbeam.network  \\\n--relay-ws-provider wss://relay.api.moonbase.moonbeam.network \\\n--max-capacity 1000 --max-message-size 102400 \\\n--hrmp-action open\n</code></pre> <p>Note</p> <p>You can adapt the script for your parachain by changing the <code>parachain-ws-provider</code>.</p> <p>After running the script, you'll see output that looks like the following:</p> yarn hrmp-manipulator --target-para-id 3370 \\ --parachain-ws-provider wss://moonbeam.public.blastapi.io  \\ --relay-ws-provider wss://polkadot-rpc.publicnode.com \\ --max-capacity 1000 --max-message-size 102400 \\ --hrmp-action open yarn run v1.22.22 warning ../../../package.json: No license field $ ts-node 'scripts/hrmp-channel-manipulator.ts' --target-para-id 3370 --parachain-ws-provider wss://moonbeam.public.blastapi.io --relay-ws-provider wss://polkadot-rpc.publicnode.com --max-capacity 1000 --max-message-size 102400 --hrmp-action open Genesis hash is: 0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3 Polkadot FeeAmount is: 10000000000 XCM Version is V4 Encoded Call Data for Tx is 0x6b09002a0d0000e803000000900100010401000100e40b5402000000000000000000000002286bee020004000100 \u2728  Done in 4.25s. <p>Running the script as shown above will return the encoded calldata to open an HRMP channel. You can also use the script to create and submit a preimage and proposal on-chain for the given HRMP action. For Moonbeam and Moonriver, the proposal must be submitted via the General Admin Track.</p> <p>Please refer to the README for a complete list of the arguments, including optional arguments, and examples on how to use the HRMP-manipulator script.</p> <p>If you plan to batch the transaction with other calls, copy the resultant calldata for later use when using the batch transactions script.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#batch-actions-into-one","title":"Batch Actions Into One","text":"<p>The most efficient way to complete the XCM process on parachains is to batch all transactions together. The xcm-tools repository provides a script to batch extrinsic calls into a single call, thus requiring only a single transaction. This can be helpful if your parachain would like to open an HRMP channel and register an asset simultaneously. This should be used when proposing channel registration on a Moonbeam network.</p> <p>If you are registering an asset in addition to establishing a channel, please refer to the How to Register Cross-Chain Assets guide to learn how to generate the encoded calldata required for asset registration.</p> <p>The process of batching all of the transactions into one is depicted in the following diagram.</p> <p></p> <p>You will now use the encoded calldata outputs for opening a channel, accepting a channel, and registering an asset and insert them into the following command to send the batch proposal to democracy.</p> <p>You can add a <code>--call \"INSERT_CALL\"</code> for each call you want to batch. Replace the following values before running the command:</p> <ul> <li><code>OPEN_CHANNEL_CALL</code> is the SCALE encoded calldata for opening an HRMP channel from Moonbeam to your parachain</li> <li><code>ACCEPT_INCOMING_CALL</code> is the SCALE encoded calldata for accepting the channel request from your parachain</li> <li><code>REGISTER_ASSET_CALL</code> is the SCALE encoded calldata for registering a cross-chain asset. If you have more than one asset to be registered on Moonbeam, you can include additional registration SCALE encoded calldata with additional <code>--call</code> flags</li> </ul> MoonbeamMoonriverMoonbase Alpha <pre><code>yarn generic-call-propose -w wss://wss.api.moonbeam.network \\\n--call \"OPEN_CHANNEL_CALL\" \\\n--call \"ACCEPT_INCOMING_CALL\" \\\n--call \"REGISTER_ASSET_CALL\" \\\n</code></pre> <pre><code>yarn generic-call-propose -w wss://wss.api.moonriver.moonbeam.network \\\n--call \"OPEN_CHANNEL_CALL\" \\\n--call \"ACCEPT_INCOMING_CALL\" \\\n--call \"REGISTER_ASSET_CALL\" \\\n</code></pre> <pre><code>yarn generic-call-propose -w wss://wss.api.moonbase.moonbeam.network  \\\n--call \"OPEN_CHANNEL_CALL\" \\\n--call \"ACCEPT_INCOMING_CALL\" \\\n--call \"REGISTER_ASSET_CALL\" \\\n</code></pre> <p>Note</p> <p>You can readapt the script for your parachain by changing the <code>parachain-ws-provider</code>.</p> <p>With the encoded calldata, you can then submit the governance proposal. For Moonbeam and Moonriver, you must assign the proposal to the General Admin Track. It is recommended to become familiar with the OpenGov: Governance v2 process on Moonbeam-based networks.</p> <p>If you want to send the governance proposal directly from the CLI, you'll need to use these additional flags:</p> <pre><code>--account-priv-key YOUR_PRIVATE_KEY \\\n--send-preimage-hash true \\\n--send-proposal-as v2 \\\n--track '{ \"Origins\": \"GeneralAdmin\" }'\n</code></pre> <p>For Moonbase Alpha, you will not need to provide a private key or go through governance. Instead, you can use the <code>--sudo</code> flag and provide the output to the Moonbeam team so that the asset and channel can be added quickly through sudo.</p> <p>Feel free to check out the additional flags available for this script.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#additional-flags-xcm-tools","title":"Additional Flags for XCM-Tools","text":"<p>The xcm-tools GitHub repository and most of its functions can be called with some additional flags that create some wrappers around the actions being taken. For example, you might want to wrap the send of the XCM message in sudo, or via a democracy proposal.</p> <p>The complete options that can be used with the script are as follows:</p> Flag Type Description account-priv-key string (Required for send-proposal-as, send-preimage-hash) The private key of the account to send a transaction with sudo boolean Whether to wrap the extrinsic calldata inside of a <code>sudo.sudo</code> extrinsic. If <code>account-priv-key</code> is present, it will attempt to send the transaction send-preimage-hash boolean Whether to submit the encoded calldata as a preimage and retrieve its hash send-proposal-as democracy/council-external/v2 Whether to send the encoded calldata through democracy or Council (Governance v1), or OpenGov (Governance v2) collective-threshold number (Required for council-external) The threshold for the Council deciding the proposal delay number (Required for v2) The number of blocks to delay an OpenGovV2 proposal's execution by track string (JSON encoded origin) (Required for v2) The JSON encoded origin for an OpenGovV2 proposal. For Moonbeam networks: \"Root\", \"WhitelistedCaller\", \"GeneralAdmin\", \"ReferendumCanceller\", \"ReferendumKiller\" at-block number Whether to wrap the extrinsic calldata inside of a <code>scheduler.schedule</code> extrinsic. The block in the future that the action should be scheduled to take place fee-currency string (multilocation) (Required for non-Moonbeam chains that use XCM Transactor) The multilocation of the relay chain's asset <p>Note</p> <p>The track option must be specified like so: <code>'{ \"Origins\": \"INSERT_ORIGIN\" }'</code>, where you can insert any of the following as the Origin: \"Root\", \"WhitelistedCaller\", \"GeneralAdmin\", \"ReferendumCanceller\", \"ReferendumKiller\".</p>"},{"location":"builders/interoperability/xcm/xc20/interact/","title":"Interact with XC-20s on Moonbeam","text":""},{"location":"builders/interoperability/xcm/xc20/interact/#introduction","title":"Introduction","text":"<p>As mentioned in the XC-20s Overview page, XC-20s are a unique asset class on Moonbeam. Although they are Substrate-native assets, they also have an ERC-20 interface and can be interacted with like any other ERC-20. Additionally, the ERC-20 Permit interface is available for all external XC-20s.</p> <p>This guide covers the XC-20 Solidity interfaces, including the standard ERC-20 interface and the ERC-20 Permit interface, and how to interact with external XC-20s using these interfaces.</p>"},{"location":"builders/interoperability/xcm/xc20/interact/#xc20s-solidity-interface","title":"XC-20s Solidity Interface","text":"<p>Both types of XC-20s have the standard ERC-20 interface. In addition, all external XC-20s also possess the ERC-20 Permit interface. The following two sections describe each of the interfaces separately.</p>"},{"location":"builders/interoperability/xcm/xc20/interact/#the-erc20-interface","title":"The ERC-20 Solidity Interface","text":"<p>As mentioned, you can interact with XC-20s via an ERC-20 interface. The ERC20.sol interface on Moonbeam follows the EIP-20 Token Standard, which is the standard API interface for tokens within smart contracts. The standard defines the required functions and events that a token contract must implement to be interoperable with different applications.</p> <p>The interface includes the following functions:</p> <ul> <li>name() \u2014 read-only function that returns the name of the token</li> <li>symbol() \u2014 read-only function that returns the symbol of the token</li> <li>decimals() \u2014 read-only function that returns the decimals of the token</li> <li>totalSupply() \u2014 read-only function that returns the total number of tokens in existence</li> <li>balanceOf(address who) \u2014 read-only function that returns the balance of the specified address</li> <li>allowance(address owner, address spender) \u2014  read-only function that checks and returns the amount of tokens that a spender is allowed to spend on behalf of the owner</li> <li>transfer(address to, uint256 value) \u2014 transfers a given amount of tokens to a specified address and returns <code>true</code> if the transfer was successful</li> <li>approve(address spender, uint256 value) \u2014 approves the provided address to spend a specified amount of tokens on behalf of <code>msg.sender</code>. Returns <code>true</code> if successful</li> <li>transferFrom(address from, address to, uint256 value) \u2014 transfers tokens from one given address to another given address and returns <code>true</code> if successful</li> </ul> <p>Note</p> <p>The ERC-20 standard does not specify the implications of multiple calls to <code>approve</code>. Changing an allowance with this function numerous times enables a possible attack vector. To avoid incorrect or unintended transaction ordering, you can first reduce the <code>spender</code> allowance to <code>0</code> and then set the desired allowance afterward. For more details on the attack vector, you can check out the ERC-20 API: An Attack Vector on Approve/TransferFrom Methods overview.</p> <p>The interface also includes the following required events:</p> <ul> <li>Transfer(address indexed from, address indexed to, uint256 value) - emitted when a transfer has been performed</li> <li>Approval(address indexed owner, address indexed spender, uint256 value) - emitted when an approval has been registered</li> </ul>"},{"location":"builders/interoperability/xcm/xc20/interact/#the-erc20-permit-interface","title":"The ERC-20 Permit Solidity Interface","text":"<p>External XC-20s also have the ERC-20 Permit interface. The Permit.sol interface on Moonbeam follows the EIP-2612 standard, which extends the ERC-20 interface with the <code>permit</code> function. Permits are signed messages that can be used to change an account's ERC-20 allowance. Note that local XC-20s can have also the Permit interface, but it is not a requirement for them to be XCM-ready.</p> <p>The standard ERC-20 <code>approve</code> function is limited in its design as the <code>allowance</code> can only be modified by the sender of the transaction, the <code>msg.sender</code>. This can be seen in OpenZeppelin's implementation of the ERC-20 interface, which sets the <code>owner</code> through the <code>msgSender</code> function, which ultimately sets it to <code>msg.sender</code>.</p> <p>Instead of signing the <code>approve</code> transaction, a user can sign a message, and that signature can be used to call the <code>permit</code> function to modify the <code>allowance</code>.  As such, it allows for gas-less token transfers. In addition, users no longer need to send two transactions to approve and transfer tokens. To see an example of the <code>permit</code> function, you can check out OpenZeppelin's implementation of the ERC-20 Permit extension.</p> <p>The Permit.sol interface includes the following functions:</p> <ul> <li>permit(address owner, address spender, uint256, value, uint256, deadline, uint8 v, bytes32 r, bytes32 s) - consumes an approval permit, which can be called by anyone</li> <li>nonces(address owner) - returns the current nonce for the given owner</li> <li>DOMAIN_SEPARATOR() - returns the EIP-712 domain separator, which is used to avoid replay attacks. It follows the EIP-2612 implementation</li> </ul> <p>The DOMAIN_SEPARATOR() is defined in the EIP-712 standard, and is calculated as:</p> <pre><code>keccak256(PERMIT_DOMAIN, name, version, chain_id, address)\n</code></pre> <p>The parameters of the hash can be broken down as follows:</p> <ul> <li>PERMIT_DOMAIN - is the <code>keccak256</code> of <code>EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)</code></li> <li>name - is the token name but with the following considerations:<ul> <li>If the token has a name defined, the name for the domain is <code>XC20: &lt;name&gt;</code>, where <code>&lt;name&gt;</code> is the token name</li> <li>If the token has no name defined, the name for the domain is <code>XC20: No name</code></li> </ul> </li> <li>version - is the version of the signing domain. For this case, version is set to <code>1</code></li> <li>chainId - is the chain ID of the network</li> <li>verifyingContract - is the XC-20 address</li> </ul> <p>Note</p> <p>Prior to runtime upgrade 1600, the name field did not follow the standard EIP-2612 implementation.</p> <p>The calculation of the domain separator can be seen in Moonbeam's EIP-2612 implementation, with a practical example shown in OpenZeppelin's <code>EIP712</code> contract.</p> <p>Aside from the domain separator, the <code>hashStruct</code> guarantees that the signature can only be used for the <code>permit</code> function with the given function arguments. It uses a given nonce to ensure the signature is not subject to a replay attack. The calculation of the hash struct can be seen in Moonbeam's EIP-2612 implementation, with a practical example shown in OpenZeppelin's <code>ERC20Permit</code> contract.</p> <p>The domain separator and the hash struct can be used to build the final hash of the fully encoded message. A practical example is shown in OpenZeppelin's <code>EIP712</code> contract.</p> <p>With the final hash and the <code>v</code>, <code>r</code>, and <code>s</code> values, the signature can be verified and recovered. If successfully verified, the nonce will increase by one and the allowance will be updated.</p>"},{"location":"builders/interoperability/xcm/xc20/interact/#interact-with-the-precompile-using-remix","title":"Interact with External XC-20s Using an ERC-20 Interface","text":"<p>This section of the guide will show you how to interact with XC-20s via the ERC-20 interface using Remix. Because local XC-20s are representations of regular ERC-20s, this section is focused on external XC-20s.</p> <p>To interact with external XC-20s, you'll need to first calculate the precompile address of the XC-20 asset you want to interact with. Then, you can interact with the ERC-20 interface as you would with any other ERC-20.</p> <p>You can adapt the instructions in this section to be used with the Permit.sol interface.</p>"},{"location":"builders/interoperability/xcm/xc20/interact/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To approve a spend or transfer external XC-20s via the ERC-20 interface, you will need:</p> <ul> <li>MetaMask installed and connected to the Moonbase Alpha TestNet</li> <li>Create or have two accounts on Moonbase Alpha</li> <li>At least one of the accounts will need to be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/interoperability/xcm/xc20/interact/#calculate-xc20-address","title":"Calculate External XC-20 Precompile Addresses","text":"<p>Before you can interact with an external XC-20 via the ERC-20 interface, you need to derive the external XC-20's precompile address from the asset ID.</p> <p>The external XC-20 precompile address is calculated using the following:</p> <pre><code>address = '0xFFFFFFFF...' + DecimalToHex(AssetId)\n</code></pre> <p>Given the above calculation, the first step is to take the u128 representation of the asset ID and convert it to a hex value. You can use your search engine of choice to look up a simple tool for converting decimals to hex values. For asset ID <code>42259045809535163221576417993425387648</code>, the hex value is <code>1FCACBD218EDC0EBA20FC2308C778080</code>.</p> <p>External XC-20 precompiles can only fall between <code>0xFFFFFFFF00000000000000000000000000000000</code> and <code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code>.</p> <p>Since Ethereum addresses are 40 characters long, you will need to start with the initial eight <code>F</code>s and then prepend <code>0</code>s to the hex value until the address has 40 characters.</p> <p>The hex value that was already calculated is 32 characters long, so prepending eight <code>F</code>s to the hex value will give you the 40-character address you need to interact with the XC-20 precompile. For this example, the full address is <code>0xFFFFFFFF1FCACBD218EDC0EBA20FC2308C778080</code>.</p> <p>Now that you've calculated the external XC-20 precompile address, you can use the address to interact with the XC-20 like you would with any other ERC-20 in Remix.</p>"},{"location":"builders/interoperability/xcm/xc20/interact/#add-the-interface-to-remix","title":"Add &amp; Compile the Interface","text":"<p>You can interact with the ERC-20 interface using Remix. First, you will need to add the interface to Remix:</p> <ol> <li>Get a copy of ERC20.sol</li> <li>Paste the file contents into a Remix file named IERC20.sol</li> </ol> <p></p> <p>Once you have the ERC-20 interface loaded in Remix, you will need to compile it:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Compile the IERC20.sol file</li> </ol> <p></p> <p>If the interface was compiled successfully, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/interoperability/xcm/xc20/interact/#access-the-precompile","title":"Access the Precompile","text":"<p>Instead of deploying the ERC-20 precompile, you will access the interface given the address of the XC-20:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note that the precompiled contract is already deployed</li> <li>Make sure Injected Web3 is selected in the ENVIRONMENT dropdown. Once you select Injected Web3, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure IERC20 - IERC20.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract, there is no need to deploy any code. Instead, you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the XC-20. For local XC-20s, which you should have already calculated in the  Calculate External XC-20 Precompile Addresses section. For this example, you can use <code>0xFFFFFFFF1FCACBD218EDC0EBA20FC2308C778080</code> and click At Address</li> </ol> <p></p> <p>Note</p> <p>Optionally, you can checksum the XC-20 precompile address by going to your search engine of choice and searching for a tool to checksum the address. Once the address has been checksummed, you can use it in the At Address field instead.</p> <p>The IERC20 precompile for the XC-20 will appear in the list of Deployed Contracts. Now you can feel free to call any of the standard ERC-20 functions to get information about the XC-20 or transfer the XC-20.</p> <p></p> <p>To learn how to interact with each of the functions, you can check out the ERC-20 Precompile guide and modify it for interacting with the XC-20 Precompile.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/","title":"Overview of XC-20s","text":""},{"location":"builders/interoperability/xcm/xc20/overview/#introduction","title":"Introduction","text":"<p>The Cross-Consensus Message (XCM) format provides a universal way for blockchains to exchange messages and transfer assets. To extend this interoperability to the EVM, Moonbeam introduced XC-20s, ERC-20 tokens on Moonbeam that are fully compatible with XCM transfers.</p> <p>Any ERC-20 deployed on Moonbeam can be configured as an XC-20, making it accessible to any chain connected via XCM. This allows EVM-focused developers to work with familiar ERC-20 workflows while benefiting from Polkadot\u2019s native cross-chain functionality, all without needing Substrate-specific expertise.</p> <p>From a technical standpoint, local XC-20s are ERC-20 tokens originating on Moonbeam (including bridged tokens deemed native once issued on Moonbeam), whereas external XC-20s are wrapped representations of tokens whose canonical ledger exists on another parachain or the relay chain. In all cases, XC-20s function just like standard ERC-20s\u2014supporting common EVM-based use cases (such as DeFi, DEXs, and lending platforms)\u2014but with the added advantage of seamless cross-chain operability.</p> <p></p> <p>This page aims to cover the basics on XC-20s; if you want to learn how to interact with or transfer XC-20s, please refer to the Send XC-20s guide.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#types-of-xc-20s","title":"Types of XC-20s","text":"<p>There are two types of XC-20s: local and external.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#local-xc20s","title":"What are Local XC-20s?","text":"<p>Local XC-20s are all ERC-20s that exist on the EVM, and that can be transferred cross-chain through XCM. For local XC-20s to be transferred to another parachain, the asset must be registered on that chain. When transferring local XC-20s, the underlying tokens reside in the destination chain's Sovereign account on Moonbeam. A sovereign account is a keyless account governed by a blockchain runtime\u2014rather than an individual\u2014that can hold assets and interact with other chains. Local XC-20s must follow the ERC-20 interface outlined in this guide. They must implement the standard ERC-20 function signatures, including the correct function selector of the <code>transfer</code> function as described in EIP-20. However, additional functionality can still be added as long as it doesn\u2019t break the base methods. </p> <p>Creating a local XC-20 is equivalent to deploying a standard ERC-20 and enabling cross-chain features on any Moonbeam network.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#external-xc20s","title":"What are External XC-20s?","text":"<p>External XC-20s are cross-chain tokens originating from another parachain or the relay chain, and they are represented on Moonbeam as ERC-20 tokens. The original tokens remain locked in a Moonbeam sovereign account on their home chain, while the wrapped ERC-20 representation can be freely utilized on Moonbeam. When you transfer external XC-20s, the canonical assets remain in the sovereign account on their source chain, while the ERC-20 representation is what circulates on Moonbeam.</p> <p>External XC-20s all have xc prepended to their names to distinguish them as cross-chain assets. For example, DOT, native to the Polkadot relay chain, is known as xcDOT when represented as an XC-20 on Moonbeam.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#local-xc-20s-vs-external-xc-20s","title":"Local XC-20s vs External XC-20s","text":"<p>Local XC-20s are EVM-native ERC-20 tokens whose \u201chome\u201d (or reserve chain) is Moonbeam from a Polkadot perspective. This includes tokens originally bridged in from outside Polkadot (for example, Wormhole-wrapped ETH), because once they\u2019re issued on Moonbeam as ERC-20s, Polkadot views them as local to Moonbeam. When local XC-20s are transferred to another parachain, the tokens move into that chain\u2019s sovereign account on Moonbeam.</p> <p>External XC-20s, on the other hand, are ERC-20 representations of tokens whose canonical ledger remains on another parachain or the relay chain. Moonbeam holds the \u201cwrapped\u201d version, while the underlying tokens stay locked in Moonbeam\u2019s sovereign account on the originating chain.</p> <p>From a cross-chain transfer perspective, local and external XC-20s can be sent through Polkadot\u2019s XCM infrastructure using the Ethereum or Substrate API. Because the underlying asset is an ERC-20 with EVM bytecode following the EIP-20 token standard, both transfers initiated via the Substrate and Ehereum APIs generate EVM logs visible to EVM-based explorers such as Moonscan. In contrast, you can't send a regular ERC-20 transfer using the Substrate API. Aside from cross-chain transfers through XCM, all other XC-20 interactions (such as querying balances or adjusting allowances) must occur in the EVM.</p> <p>Cross-chain transfers of XC-20s are executed via the Polkadot XCM Pallet, which utilizes regular mint, burn, and transfer mechanisms of ERC-20s for the XCM asset flow. If you\u2019d like to learn how to send XC-20s using that pallet, refer to the Using the Polkadot XCM Pallet guide.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#asset-reserves","title":"Asset Reserves","text":"<p>When transferring tokens across chains in the Polkadot or Kusama ecosystems, each token has a \u201creserve\u201d chain that holds its canonical ledger\u2014the source of truth for minting, burning, and supply management. For XC-20s, understanding which chain is the reserve determines whether the asset is managed locally on Moonbeam or remotely on another chain.</p> <p>Regardless of where the reserve is located, XC-20s on Moonbeam are still ERC-20 tokens that developers and users can interact with in the EVM. However, from an XCM perspective, the reserve chain determines how the tokens are locked, unlocked, minted, or burned behind the scenes when performing cross-chain operations.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#local-reserve-assets","title":"Local Reserve Assets","text":"<p>A local reserve asset on Moonbeam is a token whose canonical ledger\u2014from an XCM perspective\u2014resides natively on Moonbeam. In other words, Moonbeam is the asset\u2019s home chain, where minting and burning take place. </p> <p>For example, Wormhole-wrapped ETH (wETH) is considered a local reserve asset on Moonbeam, even though Ethereum is the ultimate source of ETH. Once ETH is wrapped by Wormhole and enters the Polkadot ecosystem via Moonbeam, wETH can be transferred to other parachains through Moonbeam Routed Liquidity (MRL).</p> <p>The important caveat is that, on a purely Ethereum-level view, ETH remains governed by and minted on Ethereum. However, from an XCM standpoint, wETH on Moonbeam is treated as a local reserve asset, meaning the canonical supply of wETH (as far as Polkadot ecosystems are concerned) exists on Moonbeam.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#remote-reserve-assets","title":"Remote Reserve Assets","text":"<p>A remote reserve asset is a token whose canonical ledger\u2014the source of truth for minting and burning\u2014resides on a chain different from where it\u2019s currently in use. In the case of xcDOT on Moonbeam, the underlying DOT tokens representing the xcDOT remain locked in Moonbeam\u2019s sovereign account on the Polkadot relay chain, while xcDOT functions as a wrapped representation in Moonbeam\u2019s EVM environment.</p> <p>Users can hold and transact with xcDOT on Moonbeam (for DeFi, governance, and more), knowing that the underlying DOT is safely locked on the relay chain. At any point, the wrapped xcDOT can be redeemed for the original DOT, effectively burning the xcDOT and unlocking the corresponding DOT tokens on Polkadot.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#current-xc20-assets","title":"Current List of External XC-20s","text":"<p>The current list of available external XC-20 assets per network is as follows:</p> MoonbeamMoonriverMoonbase Alpha Origin Symbol XC-20 Address Polkadot xcDOT 0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080 Acala xcaUSD 0xfFfFFFFF52C56A9257bB97f4B2b6F7B2D624ecda Acala xcACA 0xffffFFffa922Fef94566104a6e5A35a4fCDDAA9f Acala xcLDOT 0xFFfFfFffA9cfFfa9834235Fe53f4733F1b8B28d4 Apillon xcNCTR 0xFfFFfFfF8A9736B44EbF188972725bED67BF694E Astar xcASTR 0xFfFFFfffA893AD19e540E172C10d78D4d479B5Cf Bifrost xcBNC 0xFFffffFf7cC06abdF7201b350A1265c62C8601d2 Bifrost xcBNCS 0xfFfffffF6aF229AE7f0F4e0188157e189a487D59 Bifrost xcFIL 0xfFFfFFFF6C57e17D210DF507c82807149fFd70B2 Bifrost xcvASTR 0xFffFffff55C732C47639231a4C4373245763d26E Bifrost xcvBNC 0xffFffFff31d724194b6A76e1d639C8787E16796b Bifrost xcvDOT 0xFFFfffFf15e1b7E3dF971DD813Bc394deB899aBf Bifrost xcvFIL 0xFffffFffCd0aD0EA6576B7b285295c85E94cf4c1 Bifrost xcvGLMR 0xFfFfFFff99dABE1a8De0EA22bAa6FD48fdE96F6c Bifrost xcvMANTA 0xFFfFFfFfdA2a05FB50e7ae99275F4341AEd43379 Centrifuge xcCFG 0xFFfFfFff44bD9D2FFEE20B25D1Cf9E78Edb6Eae3 Composable xcIBCMOVR 0xFfFfffFF3AFcd2cAd6174387df17180a0362E592 Composable xcIBCPICA 0xfFFFFfFFABe9934e61db3b11be4251E6e869cf59 Composable xcIBCIST 0xfFfFffff6A3977d5B65D1044FD744B14D9Cef932 Composable xcIBCBLD 0xFffFffff9664be0234ea4dc64558F695C4f2A9EE Composable xcIBCTIA 0xFFFfFfff644a12F6F01b754987D175F5A780A75B Composable xcIBCATOM 0xffFFFffF6807D5082ff2f6F86BdE409245e2D953 Darwinia xcRING 0xFfffFfff5e90e365eDcA87fB4c8306Df1E91464f DED xcDED 0xfFffFFFf5da2d7214D268375cf8fb1715705FdC6 Equilibrium xcEQ 0xFffFFfFf8f6267e040D8a0638C576dfBa4F0F6D6 Equilibrium xcEQD 0xFFffFfFF8cdA1707bAF23834d211B08726B1E499 HydraDX xcHDX 0xFFFfFfff345Dc44DDAE98Df024Eb494321E73FcC Interlay xcIBTC 0xFFFFFfFf5AC1f9A51A93F5C527385edF7Fe98A52 Interlay xcINTR 0xFffFFFFF4C1cbCd97597339702436d4F18a375Ab Manta xcMANTA 0xfFFffFFf7D3875460d4509eb8d0362c611B4E841 Nodle xcNODL 0xfffffffFe896ba7Cb118b9Fa571c6dC0a99dEfF1 OriginTrail Parachain xcNEURO 0xFfffffFfB3229c8E7657eABEA704d5e75246e544 Parallel xcPARA 0xFfFffFFF18898CB5Fe1E88E668152B4f4052A947 Peaq xcPEAQ 0xFffFFFFFEC4908b74688a01374f789B48E9a3eab Pendulum xcPEN 0xffFFfFFf2257622F345E1ACDe0D4f46D7d1D77D0 Phala xcPHA 0xFFFfFfFf63d24eCc8eB8a7b5D0803e900F7b6cED Polkadex xcPDEX 0xfFffFFFF43e0d9b84010b1b67bA501bc81e33C7A Polkadot Asset Hub xcPINK 0xfFfFFfFf30478fAFBE935e466da114E14fB3563d Polkadot Asset Hub xcSTINK 0xFffFffFf54c556bD1d0F64ec6c78f1B477525E56 Polkadot Asset Hub xcUSDC 0xFFfffffF7D2B0B761Af01Ca8e25242976ac0aD7D Polkadot Asset Hub xcUSDT 0xFFFFFFfFea09FB06d082fd1275CD48b191cbCD1d Polkadot Asset Hub xcWIFD 0xfffffffF2e1D1ac9eA1686255bEfe995B31abc96 Snowbridge WBTC.e 0xfFffFFFf1B4Bb1ac5749F73D866FfC91a3432c47 Snowbridge wstETH.e 0xFfFFFfFF5D5DEB44BF7278DEE5381BEB24CB6573 Snowbridge WETH.e 0xfFffFFFF86829AFE1521AD2296719DF3ACE8DED7 Subsocial xcSUB 0xfFfFffFf43B4560Bc0C451a3386E082bff50aC90 Unique xcUNQ 0xFffffFFFD58f77E6693CFB99EbE273d73C678DC2 Zeitgeist xcZTG 0xFFFFfffF71815ab6142E0E20c7259126C6B40612 <p>*You can check each Asset ID on Polkadot.js Apps</p> Origin Symbol XC-20 Address Kusama xcKSM 0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080 Bifrost xcBNC 0xFFfFFfFFF075423be54811EcB478e911F22dDe7D Bifrost xcvBNC 0xFFffffff3646A00f78caDf8883c5A2791BfCDdc4 Bifrost xcvKSM 0xFFffffFFC6DEec7Fc8B11A2C8ddE9a59F8c62EFe Bifrost xcvMOVR 0xfFfffFfF98e37bF6a393504b5aDC5B53B4D0ba11 Calamari xcKMA 0xffffffffA083189F870640B141AE1E882C2B5BAD Crab xcCRAB 0xFFFffFfF8283448b3cB519Ca4732F2ddDC6A6165 Crust-Shadow xcCSM 0xffFfFFFf519811215E05eFA24830Eebe9c43aCD7 Heiko xcHKO 0xffffffFF394054BCDa1902B6A6436840435655a3 Integritee xcTEER 0xFfFfffFf4F0CD46769550E5938F6beE2F5d4ef1e Karura xcKAR 0xFfFFFFfF08220AD2E6e157f26eD8bD22A336A0A5 Karura xcaSEED 0xFfFffFFfa1B026a00FbAA67c86D5d1d5BF8D8228 Khala xcPHA 0xffFfFFff8E6b63d9e447B6d4C45BDA8AF9dc9603 Kintsugi xcKINT 0xfffFFFFF83F4f317d3cbF6EC6250AeC3697b3fF2 Kintsugi xckBTC 0xFFFfFfFfF6E528AD57184579beeE00c5d5e646F0 Kusama Asset Hub xcRMRK 0xffffffFF893264794d9d57E1E0E21E0042aF5A0A Kusama Asset Hub xcUSDT 0xFFFFFFfFea09FB06d082fd1275CD48b191cbCD1d Litmus xcLIT 0xfffFFfFF31103d490325BB0a8E40eF62e2F614C0 Mangata xcMGX 0xffFfFffF58d867EEa1Ce5126A4769542116324e9 Picasso xcPICA 0xFffFfFFf7dD9B9C60ac83e49D7E3E1f7A1370aD2 Robonomics xcXRT 0xFffFFffF51470Dca3dbe535bD2880a9CcDBc6Bd9 Shiden xcSDN 0xFFFfffFF0Ca324C842330521525E7De111F38972 Tinkernet xcTNKR 0xfFFfFffF683474B842852111cc31d470bD8f5081 Turing xcTUR 0xfFffffFf6448d0746f2a66342B67ef9CAf89478E <p>*You can check each Asset ID on Polkadot.js Apps</p> Origin Symbol XC-20 Address Relay Chain Alphanet xcUNIT 0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080 <p>*You can check each Asset ID on Polkadot.js Apps</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#list-xchain-assets","title":"Retrieve List of External XC-20s and Their Metadata","text":"<p>To fetch a list of the currently available external XC-20s along with their associated metadata, you can query the chain state using the Polkadot.js API. You'll take the following steps:</p> <ol> <li> <p>Create an API provider for the network you'd like to get the list of assets for. You can use the following WSS endpoints for each network:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>wss://wss.api.moonbeam.network\n</code></pre> <pre><code>wss://wss.api.moonriver.moonbeam.network\n</code></pre> <pre><code>wss://wss.api.moonbase.moonbeam.network\n</code></pre> </li> <li> <p>Query the <code>assets</code> pallet for all assets</p> </li> <li>Iterate over the list of assets to get all of the asset IDs along with their associated metadata</li> </ol> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst getXc20s = async () =&gt; {\n  try {\n    const substrateProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n    const api = await ApiPromise.create({ provider: substrateProvider });\n\n    const assets = await api.query.assets.asset.entries();\n\n    await Promise.all(\n      assets.map(async ([{ args: [id] }]) =&gt; {\n        try {\n          const metadata = await api.query.assets.metadata(id);\n          const humanMetadata = metadata.toHuman();\n\n          console.log(`\\nAsset ID: ${id}`);\n          console.log('Metadata:');\n          console.log('  Name:', humanMetadata.name);\n          console.log('  Symbol:', humanMetadata.symbol);\n          console.log('  Decimals:', humanMetadata.decimals);\n          console.log('  Deposit:', humanMetadata.deposit);\n          console.log('  IsFrozen:', humanMetadata.isFrozen);\n          console.log('-----');\n        } catch (error) {\n          console.error(`Error fetching metadata for asset ${id}:`, error);\n        }\n      })\n    );\n\n    await api.disconnect();\n  } catch (error) {\n    console.error('Error in getXc20s:', error);\n  }\n};\n\ngetXc20s().catch(console.error);\n</code></pre> <p>The result will display the asset ID along with some additional information for all of the registered external XC-20s.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#retrieve-local-xc20-metadata","title":"Retrieve Local XC-20 Metadata","text":"<p>Since local XC-20s are ERC-20s on Moonbeam that can be transferred via XCM to another parachain, you can interact with local XC-20s like you would an ERC-20. As long as you have the address and the ABI of the ERC-20, you can retrieve its metadata by interacting with its ERC-20 interface to retrieve the name, symbol, and decimals for the asset.</p> <p>The following is an example that retrieves the asset metadata for the Jupiter token on Moonbase Alpha:</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers';\n\nconst providerRPC = {\n  moonbase: {\n    name: 'moonbase',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network', // Insert your RPC URL here\n    chainId: 1287, // 0x507 in hex,\n  },\n};\n\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n});\n\n// Replace with the address of the ERC-20 token\nconst tokenAddress = '0x9Aac6FB41773af877a2Be73c99897F3DdFACf576';\nconst tokenABI = [\n  'function name() view returns (string)',\n  'function symbol() view returns (string)',\n  'function decimals() view returns (uint8)',\n];\n\nconst tokenContract = new ethers.Contract(tokenAddress, tokenABI, provider);\nasync function getTokenMetadata() {\n  try {\n    const [name, symbol, decimals] = await Promise.all([\n      tokenContract.name(),\n      tokenContract.symbol(),\n      tokenContract.decimals(),\n    ]);\n    console.log(`Name: ${name}`);\n    console.log(`Symbol: ${symbol}`);\n    console.log(`Decimals: ${decimals}`);\n  } catch (error) {\n    console.error('Error fetching token metadata:', error);\n  }\n}\ngetTokenMetadata();\n</code></pre> <pre><code>import { Web3 } from 'web3';\n\n// Insert your RPC URL here\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\n// Replace with the address of the ERC-20 token\nconst tokenAddress = '0x9Aac6FB41773af877a2Be73c99897F3DdFACf576';\nconst tokenABI = [\n  // ERC-20 ABI\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [{ name: '', type: 'string' }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [{ name: '', type: 'string' }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [{ name: '', type: 'uint8' }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n];\nconst tokenContract = new web3.eth.Contract(tokenABI, tokenAddress);\nasync function getTokenMetadata() {\n  try {\n    const [name, symbol, decimals] = await Promise.all([\n      tokenContract.methods.name().call(),\n      tokenContract.methods.symbol().call(),\n      tokenContract.methods.decimals().call(),\n    ]);\n    console.log(`Name: ${name}`);\n    console.log(`Symbol: ${symbol}`);\n    console.log(`Decimals: ${decimals}`);\n  } catch (error) {\n    console.error('Error fetching token metadata:', error);\n  }\n}\ngetTokenMetadata();\n</code></pre> <pre><code>from web3 import Web3\n\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Replace with the address of the ERC-20 token\ntoken_address = \"0x9Aac6FB41773af877a2Be73c99897F3DdFACf576\"\ntoken_abi = [  # ERC-20 ABI\n    {\n        \"constant\": True,\n        \"inputs\": [],\n        \"name\": \"name\",\n        \"outputs\": [{\"name\": \"\", \"type\": \"string\"}],\n        \"payable\": False,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\",\n    },\n    {\n        \"constant\": True,\n        \"inputs\": [],\n        \"name\": \"symbol\",\n        \"outputs\": [{\"name\": \"\", \"type\": \"string\"}],\n        \"payable\": False,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\",\n    },\n    {\n        \"constant\": True,\n        \"inputs\": [],\n        \"name\": \"decimals\",\n        \"outputs\": [{\"name\": \"\", \"type\": \"uint8\"}],\n        \"payable\": False,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\",\n    },\n]\ntoken_contract = web3.eth.contract(address=token_address, abi=token_abi)\n\n\ndef get_token_metadata():\n    try:\n        name = token_contract.functions.name().call()\n        symbol = token_contract.functions.symbol().call()\n        decimals = token_contract.functions.decimals().call()\n        print(f\"Name: {name}\")\n        print(f\"Symbol: {symbol}\")\n        print(f\"Decimals: {decimals}\")\n    except Exception as e:\n        print(f\"Error fetching token metadata: {e}\")\n\n\nget_token_metadata()\n</code></pre>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/","title":"XCM Precompile","text":""},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#introduction","title":"Introduction","text":"<p>As a Polkadot parachain, Moonbeam has the inherent ability to communicate and exchange data with other connected parachains. This native cross-chain communication allows safe and fast token transfers leveraging the Cross-Consensus Message format (XCM for short), facilitating communication between different consensus systems.</p> <p>The communication protocol enabling token transfers is built on Substrate and runs on a lower level than the EVM, making it harder for EVM developers to access.</p> <p>Nevertheless, Moonbeam networks have an XCM Precompile that fills the gap between execution layers. This precompile exposes a smart contract interface that abstracts away the underlying complexities, making the execution of cross-chain token transfers as easy as any other smart contract call. </p> <p>This guide will show you how to interact with the XCM Interface precompile to execute cross-chain token transfers through the Ethereum API.</p> <p>The XCM Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x000000000000000000000000000000000000081A\n</code></pre> <pre><code>0x000000000000000000000000000000000000081A\n</code></pre> <pre><code>0x000000000000000000000000000000000000081A\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#the-xcm-solidity-interface","title":"The XCM Solidity Interface","text":"<p>The <code>XCMInterface.sol</code> is a Solidity interface that allows developers to interact with the methods of <code>pallet-xcm</code>.</p> XCMInterface.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The XCM contract's address.\naddress constant XCM_CONTRACT_ADDRESS = 0x000000000000000000000000000000000000081A;\n\n/// @dev The XCM contract's instance.\nXCM constant XCM_CONTRACT = XCM(XCM_CONTRACT_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title XCM precompile Interface\n/// @dev The interface that Solidity contracts use to interact with the substrate pallet-xcm.\ninterface XCM {\n    // A location is defined by its number of parents and the encoded junctions (interior)\n    struct Location {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    // Support for Weights V2\n    struct Weight {\n        uint64 refTime;\n        uint64 proofSize;\n    }\n\n    // A way to represent fungible assets in XCM using Location format\n    struct AssetLocationInfo {\n        Location location;\n        uint256 amount;\n    }\n\n    // A way to represent fungible assets in XCM using address format\n    struct AssetAddressInfo {\n        address asset;\n        uint256 amount;\n    }\n\n    // The values start at `0` and are represented as `uint8`\n    enum TransferType {\n        Teleport,\n        LocalReserve,\n        DestinationReserve\n    }\n\n    /// @dev Function to send assets via XCM using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector 9ea8ada7\n    /// @param dest The destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on dest.\n    /// @param assets The combination (array) of assets to send in Location format.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    function transferAssetsLocation(\n        Location memory dest,\n        Location memory beneficiary,\n        AssetLocationInfo[] memory assets,\n        uint32 feeAssetItem\n    ) external;\n\n    /// @dev Function to send assets via XCM to a 20 byte-like parachain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector a0aeb5fe\n    /// @param paraId The para-id of the destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on paraId destination.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    function transferAssetsToPara20(\n        uint32 paraId,\n        address beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem\n    ) external;\n\n    /// @dev Function to send assets via XCM to a 32 byte-like parachain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector f23032c3\n    /// @param paraId The para-id of the destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on paraId destination.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    function transferAssetsToPara32(\n        uint32 paraId,\n        bytes32 beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem\n    ) external;\n\n    /// @dev Function to send assets via XCM to the relay chain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector 6521cc2c\n    /// @param beneficiary The actual account that will receive the tokens on the relay chain.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    function transferAssetsToRelay(\n        bytes32 beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem\n    ) external;\n\n    /// @dev Function to send assets through transfer_assets_using_type_and_then() pallet-xcm\n    /// extrinsic.\n    /// Important: in this selector RemoteReserve type (for either assets or fees) is not allowed.\n    /// If users want to send assets and fees (in Location format) with a remote reserve, \n    /// they must use the selector fc19376c.\n    /// @custom:selector 8425d893\n    /// @param dest The destination chain.\n    /// @param assets The combination (array) of assets to send in Location format.\n    /// @param assetsTransferType The TransferType corresponding to assets being sent.\n    /// @param remoteFeesIdIndex The index of the asset (inside assets array) to use as fees.\n    /// @param feesTransferType The TransferType corresponding to the asset used as fees.\n    /// @param customXcmOnDest The XCM message to execute on destination chain.\n    function transferAssetsUsingTypeAndThenLocation(\n        Location memory dest,\n        AssetLocationInfo[] memory assets,\n        TransferType assetsTransferType,\n        uint8 remoteFeesIdIndex,\n        TransferType feesTransferType,\n        bytes memory customXcmOnDest\n    ) external;\n\n    /// @dev Function to send assets through transfer_assets_using_type_and_then() pallet-xcm\n    /// extrinsic.\n    /// @custom:selector fc19376c\n    /// @param dest The destination chain.\n    /// @param assets The combination (array) of assets to send in Location format.\n    /// @param remoteFeesIdIndex The index of the asset (inside assets array) to use as fees.\n    /// @param customXcmOnDest The XCM message to execute on destination chain.\n    /// @param remoteReserve The remote reserve corresponding for assets and fees. They MUST\n    /// share the same reserve.\n    function transferAssetsUsingTypeAndThenLocation(\n        Location memory dest,\n        AssetLocationInfo[] memory assets,\n        uint8 remoteFeesIdIndex,\n        bytes memory customXcmOnDest,\n        Location memory remoteReserve\n    ) external;\n\n    /// @dev Function to send assets through transfer_assets_using_type_and_then() pallet-xcm\n    /// extrinsic.\n    /// Important: in this selector RemoteReserve type (for either assets or fees) is not allowed.\n    /// If users want to send assets and fees (in Address format) with a remote reserve, \n    /// they must use the selector aaecfc62.\n    /// @custom:selector 998093ee\n    /// @param dest The destination chain.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param assetsTransferType The TransferType corresponding to assets being sent.\n    /// @param remoteFeesIdIndex The index of the asset (inside assets array) to use as fees.\n    /// @param feesTransferType The TransferType corresponding to the asset used as fees.\n    /// @param customXcmOnDest The XCM message to execute on destination chain.\n    function transferAssetsUsingTypeAndThenAddress(\n        Location memory dest,\n        AssetAddressInfo[] memory assets,\n        TransferType assetsTransferType,\n        uint8 remoteFeesIdIndex,\n        TransferType feesTransferType,\n        bytes memory customXcmOnDest\n    ) external;\n\n    /// @dev Function to send assets through transfer_assets_using_type_and_then() pallet-xcm\n    /// extrinsic.\n    /// @custom:selector aaecfc62\n    /// @param dest The destination chain.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param remoteFeesIdIndex The index of the asset (inside assets array) to use as fees.\n    /// @param customXcmOnDest The XCM message to execute on destination chain.\n    /// @param remoteReserve The remote reserve corresponding for assets and fees. They MUST\n    /// share the same reserve.\n    function transferAssetsUsingTypeAndThenAddress(\n        Location memory dest,\n        AssetAddressInfo[] memory assets,\n        uint8 remoteFeesIdIndex,\n        bytes memory customXcmOnDest,\n        Location memory remoteReserve\n    ) external;\n}\n</code></pre> <p>The interface includes the necessary data structures along with the following functions:</p> transferAssetsToPara20(paraId, beneficiary, assets, feeAssetItem) \u2014 sends assets via XCM to a 20 byte-like parachain using the underlying <code>transfer_assets()</code> transaction included in the XCM pallet module ParametersExample <ul> <li><code>paraId</code> uint32 - the para-id of the destination chain</li> <li><code>beneficiary</code> address - the ECDSA-type account in the destination chain that will receive the tokens</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send in Address format</li> <li><code>feeAssetItem</code> uint32 - the index of the asset that will be used to pay fees</li> </ul> <ul> <li><code>paraId</code> - 888</li> <li><code>beneficiary</code> - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> </ul> transferAssetsToPara32(paraId, beneficiary, assets, feeAssetItem) \u2014 sends assets via XCM to a 32 byte-like parachain using the underlying <code>transfer_assets()</code> transaction included in the XCM pallet module ParametersExample <ul> <li><code>paraId</code> uint32 - the para-id of the destination chain</li> <li><code>beneficiary</code> bytes32 - the actual account that will receive the tokens on paraId destination</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send in Address format</li> <li><code>feeAssetItem</code> uint32 - the index of the asset that will be used to pay fees</li> </ul> <ul> <li><code>paraId</code> - 888</li> <li><code>beneficiary</code> - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> </ul> transferAssetsToRelay(beneficiary, assets, feeAssetItem) \u2014 sends assets via XCM to the relay chain using the underlying <code>transfer_assets()</code> transaction included in the XCM pallet module ParametersExample <ul> <li><code>beneficiary</code> bytes32 - the actual account that will receive the tokens on the relay chain</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send in Address format</li> <li><code>feeAssetItem</code> uint32 - the index of the asset that will be used to pay fees</li> </ul> <ul> <li><code>beneficiary</code> - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> </ul> transferAssetsLocation(dest, beneficiary, assets, feeAssetItem) \u2014 sends assets using the underlying <code>transfer_assets()</code> transaction included in the XCM pallet module ParametersExample <ul> <li><code>dest</code> Location memory - the destination chain</li> <li><code>beneficiary</code> Location memory - the account in the destination chain that will receive the tokens</li> <li><code>assets</code> AssetLocationInfo[] memory - an array of assets to send</li> <li><code>feeAssetItem</code> uint32 - the index of the asset that will be used to pay fees</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>beneficiary</code> - [0, [\"0x01f831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a0600\"]]</li> <li><code>assets</code> - [[[1, [\"0x010000000000000000000000000000000000000800\"]], 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> </ul> transferAssetsUsingTypeAndThenLocation(dest, assets, assetsTransferType, remoteFeesIdIndex, feesTransferType, customXcmOnDest) \u2014 sends assets through <code>transfer_assets_using_type_and_then()</code> pallet-xcm extrinsic. Important: RemoteReserve type (for either assets or fees) is prohibited. For sending assets and fees (in Location format) with a remote reserve, use the subsequent <code>transferAssetsUsingTypeAndThenLocation</code> which shares the same function name as this but takes a different set of parameters ParametersExample <ul> <li><code>dest</code> Location memory - the destination chain</li> <li><code>assets</code> AssetLocationInfo[] memory - an array of assets to send in Location format</li> <li><code>assetsTransferType</code> TransferType - the TransferType corresponding to assets being sent (Teleport = 0, LocalReserve = 1, DestinationReserve = 2)</li> <li><code>remoteFeesIdIndex</code> uint8 - the index of the asset (inside assets array) to use as fees</li> <li><code>feesTransferType</code> TransferType - the TransferType corresponding to the asset used as fees (Teleport = 0, LocalReserve = 1, DestinationReserve = 2)</li> <li><code>customXcmOnDest</code> bytes memory - the XCM message to execute on destination chain</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>assets</code> - [[[1, [\"0x010000000000000000000000000000000000000802\"]], 1000000000000000000]]</li> <li><code>assetsTransferType</code> - 0  </li> <li><code>remoteFeesIdIndex</code> - 0</li> <li><code>feesTransferType</code> - 1    </li> <li><code>customXcmOnDest</code> - 0x0408000400010403001300008a5d784563010d01020400010300f8234bedd9553e7668c4e0d60aced12e22bd2d45  </li> </ul> transferAssetsUsingTypeAndThenLocation(dest, assets, remoteFeesIdIndex, customXcmOnDest, remoteReserve) \u2014 sends assets through <code>transfer_assets_using_type_and_then()</code> pallet-xcm extrinsic. Important: The remote reserve must be shared between assets and fees ParametersExample <ul> <li><code>dest</code> Location memory - the destination chain</li> <li><code>assets</code> AssetLocationInfo[] memory - an array of assets to send in Location format</li> <li><code>remoteFeesIdIndex</code> uint8 - the index of the asset (inside assets array) to use as fees</li> <li><code>customXcmOnDest</code> bytes memory - the XCM message to execute on destination chain</li> <li><code>remoteReserve</code> Location memory - the remote reserve corresponding for assets and fees (must be shared)</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>assets</code> - [[[1, [\"0x010000000000000000000000000000000000000800\"]], 1000000000000000000]]</li> <li><code>remoteFeesIdIndex</code> - 0</li> <li><code>customXcmOnDest</code> - 0x0408000400010403001300008a5d784563010d01020400010300f8234bedd9553e7668c4e0d60aced12e22bd2d45  </li> <li><code>remoteReserve</code> - [1,[]]  </li> </ul> transferAssetsUsingTypeAndThenAddress(dest, assets, assetsTransferType, remoteFeesIdIndex, feesTransferType, customXcmOnDest) \u2014 sends assets through <code>transfer_assets_using_type_and_then()</code> pallet-xcm extrinsic. Important: RemoteReserve type (for either assets or fees) is not allowed. For sending assets and fees (in Address format) with a remote reserve, use the subsequent <code>transferAssetsUsingTypeAndThenAddress</code>, which shares the same name as this function but takes a different set of parameters ParametersExample <ul> <li><code>dest</code> Location memory - the destination chain</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send in Address format</li> <li><code>assetsTransferType</code> TransferType - the TransferType corresponding to assets being sent (Teleport = 0, LocalReserve = 1, DestinationReserve = 2)</li> <li><code>remoteFeesIdIndex</code> uint8 - the index of the asset (inside assets array) to use as fees</li> <li><code>feesTransferType</code> TransferType - the TransferType corresponding to the asset used as fees (Teleport = 0, LocalReserve = 1, DestinationReserve = 2)</li> <li><code>customXcmOnDest</code> bytes memory - the XCM message to execute on destination chain</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>assetsTransferType</code> - 0  </li> <li><code>remoteFeesIdIndex</code> - 0</li> <li><code>feesTransferType</code> - 1   </li> <li><code>customXcmOnDest</code> - 0x0408000400010403001300008a5d784563010d01020400010300f8234bedd9553e7668c4e0d60aced12e22bd2d45 </li> </ul> transferAssetsUsingTypeAndThenAddress(dest, assets, remoteFeesIdIndex, customXcmOnDest, remoteReserve) \u2014 sends assets through <code>transfer_assets_using_type_and_then()</code> pallet-xcm extrinsic. Important: The remote reserve must be shared between assets and fees ParametersExample <ul> <li><code>dest</code> Location memory - the destination chain</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send in Address format</li> <li><code>remoteFeesIdIndex</code> uint8 - the index of the asset (inside assets array) to use as fees</li> <li><code>customXcmOnDest</code> bytes memory - the XCM message to execute on destination chain</li> <li><code>remoteReserve</code> Location memory - the remote reserve corresponding for assets and fees (must be shared)</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>remoteFeesIdIndex</code> - 0</li> <li><code>customXcmOnDest</code> - 0x0408000400010403001300008a5d784563010d01020400010300f8234bedd9553e7668c4e0d60aced12e22bd2d45</li> <li><code>remoteReserve</code> - [1,[]] </li> </ul>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow this tutorial, you must have your preferred EVM wallet configured and an account funded with native tokens. You can add Moonbeam to MetaMask wallet following this guide: Interacting with Moonbeam Using MetaMask.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#remix-set-up","title":"Remix Set Up","text":"<p>You can interact with the XCM Precompile using Remix. To add the precompile to Remix, you will need to:</p> <ol> <li>Get a copy of <code>XCMInterface.sol</code></li> <li>Paste the file contents into a Remix file named <code>XCMInterface.sol</code></li> </ol>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#compile-the-contract","title":"Compile the Contract","text":"<p>Next, you will need to compile the interface in Remix:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Compile the interface by clicking on Compile XcmInterface.sol</li> </ol> <p></p> <p>When the compilation is completed, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#access-the-contract","title":"Access the Contract","text":"<p>Instead of deploying the precompile, you will access the interface given the address of the precompiled contract:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note that the precompiled contracts are already accessible at their respective addresses. Therefore, there is no deployment step</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT dropdown. Once you select Injected Provider - Metamask, you may be prompted by MetaMask to connect your account to Remix if it's not already connected</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure XCM - XcmInterface.sol is selected in the CONTRACT dropdown. Given that it is a precompiled contract, there is no deployment step. Instead, you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the precompile: <code>0x000000000000000000000000000000000000081A</code> and click At Address</li> </ol> <p></p> <p>The XCM Interface precompile will appear in the list of Deployed Contracts.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#transfer-to-evm-chains","title":"Send Tokens Over to Another EVM-Compatible Appchain","text":"<p>To send tokens over to an account in another EVM-compatible appchain, please follow these steps:</p> <ol> <li>Expand the transferAssetsToPara20 function</li> <li>Enter the appchain ID (paraId)</li> <li>Enter the 20-byte (Ethereum-like) destination account (beneficiary)</li> <li>Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer</li> <li>Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is <code>0</code>, the second is <code>1</code>, and so on</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, wait a few blocks for the transfer to reach the destination chain and reflect the new balance.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#transfer-to-substrate-chains","title":"Send Tokens Over to a Substrate Appchain","text":"<p>To send tokens over to an account in a Substrate appchain, please follow these steps:</p> <ol> <li>Expand the transferAssetsToPara32 function</li> <li>Enter the appchain ID (<code>paraId</code>)</li> <li>Enter the sr25519-type destination account (beneficiary)</li> <li>Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer</li> </ol> <p>!!! note        There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p> <ol> <li>Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is <code>0</code>, the second is <code>1</code>, and so on</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, wait a few blocks for the transfer to reach the destination chain and reflect the new balance.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#transfer-to-relay-chain","title":"Send Tokens Over to the Relay Chain","text":"<p>To send tokens over to an account in the relay chain, please follow these steps:</p> <ol> <li>Expand the transferAssetsToRelay function</li> <li>Enter the sr25519-type destination account (beneficiary)</li> <li>Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer</li> </ol> <p>!!! note        There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p> <ol> <li>Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is <code>0</code>, the second is <code>1</code>, and so on</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, wait a few blocks for the transfer to reach the destination chain and reflect the new balance.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#transfer-locations","title":"Send Tokens Over Specific Locations","text":"<p>There are two methods that share names with closely related methods, <code>transferAssetsUsingTypeAndThenLocation</code> and <code>transferAssetsUsingTypeAndThenAddress</code>. However, these are not duplicates. For each function, there is one that accepts five parameters and another that accepts six. The function with five parameters can only be used when the remote reserve is shared between assets and fees. If the remote reserve is not shared between assets and fees, you can use the six parameter version of the method to specify the information needed.</p> <p>The following example will demonstrate <code>transferAssetsUsingTypeAndThenAddress</code> when the remote reverse is shared between assets and fees. To follow along with the tutorial, take the following steps:</p> <ol> <li>Expand the transferAssetsUsingTypeAndThenAddress function</li> <li>Enter the multilocation that specifies the destination chain. Note that any chain can be specified, regardless of its configuration or type</li> <li>Enter the combination array of assets to send in Address format</li> <li>Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is <code>0</code>, the second is <code>1</code>, and so on</li> <li>Enter the XCM message to be executed on destination chain. For more information about creating XCM call data see Send and Execute XCM Messages </li> <li>Enter the remote reserve, e.g. <code>[1,[]]</code></li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, wait a few blocks for the transfer to reach the destination chain and reflect the new balance.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/overview/","title":"Overview of XC-20 Transfers","text":""},{"location":"builders/interoperability/xcm/xc20/send-xc20s/overview/#introduction","title":"Introduction","text":"<p>Assets can move between parachains using XCM. Two main approaches exist:</p> <ul> <li>Asset teleporting \u2013 destroys tokens on the reserve chain and mints the same amount on the destination chain. Each chain holds the native asset as a reserve, similar to a burn-mint bridging mechanism. Because each chain can create tokens, a degree of trust is required</li> <li>Remote transfers \u2013 moves tokens from the reserve chain to a Sovereign account (an account on the reserve chain trustlessly controlled by the destination chain). The destination chain then mints a wrapped (also called \u201cvirtual\u201d or \u201ccross-chain\u201d) representation. This wrapped version is always interchangeable 1:1 with the original asset, functioning like a lock-mint and burn-unlock bridge. The chain where the asset originates is known as the reserve chain</li> </ul> <p></p> <p>Moonbeam currently uses remote transfers for XC-20 transfers.</p> <p>This page covers the fundamentals of XCM-based remote transfers. To learn how to perform XC-20 transfers, refer to the the XC-20 transfers via the Substrate API guide.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/overview/#xcm-instructions-for-asset-transfers","title":"XCM Instructions for Asset Transfers","text":"<p>The XCM Pallet and Precompile abstract much of the complexity involved in cross-chain asset transfers, automatically constructing the necessary XCM messages. Nevertheless, having a basic understanding of the underlying instructions can be useful. </p> <p>For reference, you can find the Polkadot XCM Pallet extrinsics for sending XC-20s in the Using the Polkadot XCM Pallet To Send XC-20s guide.</p> <p>The instructions in each XCM transfer vary depending on the asset and the transfer route. For example, returning a native token like xcDOT to its reserve chain (from Moonbeam to Polkadot) differs from sending DOT from Polkadot to Moonbeam. Below are examples of the instructions commonly involved in these token transfers.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/overview/#transfer-native-from-origin","title":"Instructions to Transfer a Reserve Asset from the Reserve Chain","text":"<p>When DOT is transferred from Polkadot to Moonbeam, the following XCM instructions are executed in sequence:</p> <ol> <li> <p><code>TransferReserveAsset</code> - executes on Polkadot, moving the DOT from the sender and depositing it into Moonbeam\u2019s Sovereign account on Polkadot</p> </li> <li> <p><code>ReserveAssetDeposited</code> - executes on Moonbeam, minting the corresponding ERC-20 representation of DOT (xcDOT) on Moonbeam</p> </li> <li> <p><code>ClearOrigin</code> - executes on Moonbeam, clearing any origin data\u2014previously set to Polkadot\u2019s Sovereign account</p> </li> <li> <p><code>BuyExecution</code> - executes on Moonbeam, determining the execution fees. Here, a portion of the newly minted xcDOT is used to pay the cost of XCM</p> </li> <li> <p><code>DepositAsset</code> - executes on Moonbeam, delivering the xcDOT to the intended recipient\u2019s account on Moonbeam</p> </li> </ol> <p>This process invokes <code>TransferReserveAsset</code> with <code>assets</code>, <code>dest</code>, and <code>xcm</code>parameters. Within the <code>xcm</code> parameter, you typically specify the <code>BuyExecution</code> and <code>DepositAsset</code> instructions. As shown in the <code>TransferReserveAsset</code> instruction, the flow also includes <code>ReserveAssetDeposited</code> and <code>ClearOrigin</code> to complete the transfer.</p> <p>For more information on constructing an XCM message for asset transfers, such as DOT to Moonbeam, refer to the Polkadot XCM Pallet guide.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/overview/#transfer-native-to-origin","title":"Instructions to Transfer a Reserve Asset back to the Reserve Chain","text":"<p>In scenarios where you want to move an asset back to its reserve chain, such as sending xcDOT from Moonbeam to Polkadot, Moonbeam uses the following set of XCM instructions:</p> <ol> <li> <p><code>WithdrawAsset</code> \u2013 executes on Moonbeam, taking the specified token (xcDOT) from the sender</p> </li> <li> <p><code>InitiateReserveWithdraw</code> \u2013 executes on Moonbeam, which, burns the token on Moonbeam (removing the wrapped representation), and sends an XCM message to Polkadot, indicating the tokens should be released there </p> </li> <li> <p><code>WithdrawAsset</code> \u2013 executes on Polkadot, removing the tokens from Moonbeam\u2019s Sovereign account on Polkadot</p> </li> <li> <p><code>ClearOrigin</code> \u2013 gets executed on Polkadot. Clears any origin data (e.g., the Sovereign account on Moonbeam)</p> </li> <li> <p><code>BuyExecution</code> \u2013 Polkadot determines the execution fees and uses part of the DOT being transferred to pay for them</p> </li> <li> <p><code>DepositAsset</code> \u2013 finally, the native DOT tokens are deposited into the specified Polkadot account</p> </li> </ol> <p>Steps 3 through 6 are automatically triggered by the <code>InitiateReserveWithdraw</code> instruction (step 2) and execute on Polkadot. Once <code>InitiateReserveWithdraw</code> is invoked on Moonbeam, the assembled XCM message instructs Polkadot to run those final instructions, completing the cross-chain transfer. In other words, while Moonbeam constructs the XCM instructions behind the scenes, they ultimately execute on Polkadot to complete the asset\u2019s return to its reserve chain.</p> <p>For more information on constructing an XCM message to transfer reserve assets to a target chain, such as xcDOT to Polkadot, you refer to the guide to the Polkadot XCM Pallet.</p> <p>Note</p> <p>The specific instructions may vary over time, but this overall flow remains consistent: the tokens are withdrawn from the user on Moonbeam, burned from the local representation, and unlocked on the reserve chain. At the end of the process, they become fully accessible again on their reserve chain.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/","title":"Using the Polkadot XCM Pallet To Send XC-20s","text":""},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#introduction","title":"Introduction","text":"<p>Note</p> <p>The Polkadot XCM Pallet replaces the deprecated XTokens Pallet. Accordingly, ensure that you are using the Polkadot XCM Pallet to interact with XC-20s.</p> <p>Manually crafting an XCM message for fungible asset transfers is a challenging task. Consequently, developers can leverage wrapper functions and pallets to use XCM features on Polkadot and Kusama. One example of such wrappers is the XCM Pallet, which provides different methods to transfer fungible assets via XCM.</p> <p>This guide will show you how to leverage the Polkadot XCM Pallet to send XC-20s from a Moonbeam-based network to other chains in the ecosystem (relay chain/parachains).</p> <p>Developers must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, testing XCM features on a TestNet is essential before moving to a production environment.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#nomenclature","title":"Nomenclature","text":"<p>Because there are various XCM-related pallets and precompiles with similar-sounding names, the following section will clarify the differences between each. </p> <ul> <li><code>PolkadotXCM</code> - this pallet (and the focus of this page) enables you to interact with XC-20s on Moonbeam, replacing the deprecated <code>XTokens</code> pallet </li> <li><code>pallet-xcm</code>- the general Polkadot XCM pallet allows you to interact with cross-chain assets. Moonbeam's <code>PolkadotXCM</code> pallet is essentially a wrapper of <code>pallet-xcm</code>. Because of this, you may see <code>PolkadotXCM</code> and <code>pallet-xcm</code> referred to interchangeably</li> <li><code>XTokens</code> - This pallet is now deprecated and replaced by <code>PolkadotXCM</code></li> <li><code>XCMInterface.sol</code> - This precompile is the solidity interface that replaces <code>XTokens.sol</code> and enables you to interact with the methods of <code>PolkadotXCM</code> from the EVM via a solidity interface</li> </ul>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#polkadotxcm-pallet-interface","title":"Polkadot XCM Pallet Interface","text":""},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#extrinsics","title":"Extrinsics","text":"<p>The Polkadot XCM Pallet provides the following extrinsics (functions):</p> forceDefaultXcmVersion(maybeXcmVersion) \u2014 sets a safe default XCM version for message encoding (admin origins only) Parameters <ul> <li><code>maybeXcmVersion</code> - the default XCM encoding version to be used when a destination's supported version is unknown. Can be either:<ul> <li>A version number</li> <li><code>None</code> to disable the default version setting</li> </ul> </li> </ul> transferAssets(dest, beneficiary, assets, feeAssetItem, weightLimit) \u2014 transfers assets from the local chain to a destination chain using reserve or teleport methods Parameters <ul> <li><code>dest</code> - the destination context for the assets. Typically specified as:<ul> <li><code>X2(Parent, Parachain(..))</code> for parachain to parachain transfers</li> <li><code>X1(Parachain(..))</code> for relay to parachain transfers</li> </ul> </li> <li><code>beneficiary</code> - the recipient location in the context of the destination. Generally an <code>AccountId32</code> value</li> <li><code>assets</code> - the assets to be transferred. Must:<ul> <li>Have the same reserve location or be teleportable to destination (excluding fee assets)</li> <li>Include assets for fee payment</li> </ul> </li> <li><code>feeAssetItem</code> - the index in the <code>assets</code> array indicating which asset should be used to pay fees</li> <li><code>weightLimit</code> - the weight limit for XCM fee purchase on the destination chain. Can be defined as:<ul> <li><code>Unlimited</code> - allows an unlimited amount of weight</li> <li><code>Limited</code> - specifies a maximum weight value</li> </ul> </li> </ul> <p>The transfer behavior varies based on asset type:</p> <ul> <li> <p>Local Reserve: </p> <ul> <li>Transfers assets to destination chain's sovereign account</li> <li>Sends XCM to mint and deposit reserve-based assets to beneficiary</li> </ul> </li> <li> <p>Destination Reserve:</p> <ul> <li>Burns local assets</li> <li>Notifies destination to withdraw reserves from this chain's sovereign account</li> <li>Deposits to beneficiary</li> </ul> </li> <li> <p>Remote Reserve:</p> <ul> <li>Burns local assets</li> <li>Sends XCM to move reserves between sovereign accounts</li> <li>Notifies destination to mint and deposit to beneficiary</li> </ul> </li> <li> <p>Teleport:</p> <ul> <li>Burns local assets</li> <li>Sends XCM to mint/teleport assets and deposit to beneficiary</li> </ul> </li> </ul> <p>As a reminder, the origin must be capable of both withdrawing the specified assets and executing XCM. If more weight is needed than specified in <code>weightLimit</code>, the operation will fail and teleported assets may be at risk</p> transferAssetsUsingTypeAndThen(dest, assets, assetsTransferType, remoteFeesId, feesTransferType, customXcmOnDest, weightLimit) \u2014 transfers assets with explicit transfer types and custom destination behavior Parameters <ul> <li><code>dest</code> - the destination context for the assets. Can be specified as:<ul> <li><code>[Parent, Parachain(..)]</code> for parachain to parachain transfers</li> <li><code>[Parachain(..)]</code> for relay to parachain transfers</li> <li><code>(parents: 2, (GlobalConsensus(..), ..))</code> for cross-bridge ecosystem transfers</li> </ul> </li> <li><code>assets</code> - the assets to be transferred. Must either:<ul> <li>Have the same reserve location</li> <li>Be teleportable to destination</li> </ul> </li> <li><code>assetsTransferType</code> - specifies how the main assets should be transferred:<ul> <li><code>LocalReserve</code> - transfers to sovereign account, mints at destination</li> <li><code>DestinationReserve</code> - burns locally, withdraws from sovereign account at destination</li> <li><code>RemoteReserve(reserve)</code> - burns locally, moves reserves through specified chain (typically Asset Hub)</li> <li><code>Teleport</code> - burns locally, mints/teleports at destination</li> </ul> </li> <li><code>remoteFeesId</code> - specifies which of the included assets should be used for fee payment</li> <li><code>feesTransferType</code> - specifies how the fee payment asset should be transferred (same options as <code>assetsTransferType</code>)</li> <li><code>customXcmOnDest</code> - XCM instructions to execute on the destination chain as the final step. Typically used to:<ul> <li>Deposit assets to beneficiary: <code>Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])</code></li> <li>Or perform more complex operations with the transferred assets</li> </ul> </li> <li><code>weightLimit</code> - the weight limit for XCM fee purchase on the destination chain. Can be defined as:<ul> <li><code>Unlimited</code> - allows an unlimited amount of weight</li> <li><code>Limited</code> - specifies a maximum weight value</li> </ul> </li> </ul> <p>A few reminders:</p> <ul> <li><code>BuyExecution</code> is used to purchase execution time using the specified <code>remoteFeesId</code> asset</li> <li>Fee payment asset can use a different transfer type than the main assets</li> <li>The origin must be capable of both withdrawing the specified assets and executing XCM</li> <li>If more weight is needed than specified in <code>weightLimit</code>, the operation will fail and transferred assets may be at risk</li> </ul>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#storage-methods","title":"Storage Methods","text":"<p>The Polkadot XCM Pallet includes the following read-only storage methods. Note, this is not an exhaustive list. To see the current available storage methods, check the Chain State of Polkadot.js Apps.</p> assetTraps(h256 hash) \u2014 returns the count of trapped assets for a given hash ParametersReturnsPolkadot.js API Example <ul> <li><code>hash</code>: <code>H256</code> - The hash identifier for the asset trap. When an asset is trapped, a unique hash identifier is assigned to it. You can omit this field to return information about all assets trapped</li> </ul> <p>Returns a <code>U32</code> (unsigned 32-bit integer) representing the number of times an asset has been trapped at this hash location. <pre><code>// Example return values showing hash \u2192 count mappings\n[\n  [[0x0140f264543926e689aeefed15a8379f6e75a8c6884b0cef0832bb913a343b53], 1],\n  [[0x0d14fd8859d8ff15dfe4d4002b402395129cdc4b69dea5575efa1dc205b96020], 425],\n  [[0x166f82439fd2b25b28b82224e82ad9f26f2da26b8257e047182a6a7031accc9a], 3]\n]\n</code></pre></p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://wss.api.moonbeam.network'),\n  });\n\n  const hash =\n    '0x166f82439fd2b25b28b82224e82ad9f26f2da26b8257e047182a6a7031accc9a';\n  const trapCount = await api.query.polkadotXcm.assetTraps(hash);\n\n  console.log('Trap count:', trapCount.toNumber());\n};\n\nmain();\n</code></pre> queryCounter() \u2014 the latest available query index ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u64</code> - The latest available query index</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://wss.api.moonbeam.network'),\n  });\n\n  const queryIndex = await api.query.polkadotXcm.queryCounter();\n\n  console.log('Query Index:', queryIndex.toNumber());\n};\n\nmain();\n</code></pre> safeXcmVersion() \u2014 default version to encode XCM when destination version is unknown ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - default version to encode XCM when destination version is unknown</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://wss.api.moonbeam.network'),\n  });\n\n  const safeVersion = await api.query.polkadotXcm.safeXcmVersion();\n\n  console.log('Safe XCM Version:', safeVersion.toHuman());\n};\n\nmain();\n</code></pre> supportedVersion(XcmVersion, Multilocation) \u2014 returns the supported XCM version for a given location ParametersReturnsPolkadot.js API Example <ul> <li>version <code>u32</code>: XcmVersion - The version number to check</li> <li>location: MultiLocation - The location to check for version support</li> </ul> <p>Returns a mapping of locations to their supported XCM versions. Each entry contains a MultiLocation specifying the parachain location (including parent and interior information) and an XcmVersion number indicating the supported version</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://wss.api.moonbase.moonbeam.network'),\n  });\n\n  const testLocation = {\n    V4: {\n      parents: 1,\n      interior: 'Here',\n    },\n  };\n\n  const supportedVersion = await api.query.polkadotXcm.supportedVersion(\n    4, // Testing XCM v4\n    testLocation\n  );\n\n  console.log('Location:', JSON.stringify(testLocation, null, 2));\n  console.log('Supported Version:', supportedVersion.toHuman());\n};\n\nmain();\n</code></pre> palletVersion() \u2014 returns current pallet version from storage ParametersReturnsPolkadot.js API Example <p>None</p> <p>A number representing the current version of the pallet.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n0\n</code></pre> <pre><code> import { ApiPromise, WsProvider } from '@polkadot/api';\n\n const main = async () =&gt; {\n   const api = await ApiPromise.create({\n     provider: new WsProvider('wss://wss.api.moonbase.moonbeam.network'),\n   });\n   const palletVersion = await api.query.polkadotXcm.palletVersion();\n   console.log(\"The pallet version is \" + palletVersion);\n };\n\n main();\n</code></pre>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#constants","title":"Pallet Constants","text":"<p>There are no constants part of the Polkadot XCM pallet.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#build-with-PolkadotXCM-pallet","title":"Building an XCM Message with the Polkadot XCM Pallet","text":"<p>This guide covers the process of building an XCM message using the Polkadot XCM Pallet, specifically the <code>transferAssets</code> function.</p> <p>Note</p> <p>Each parachain can allow and forbid specific methods from a pallet. Consequently, developers must ensure that they use methods that are allowed, or the transaction will fail with an error similar to <code>system.CallFiltered</code>.</p> <p>You'll be transferring xcUNIT tokens, which are the XC-20 representation of the Alphanet relay chain token, UNIT. You can adapt this guide for any other XC-20.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#polkadotxcm-check-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with the examples in this guide, you need to have the following:</p> <ul> <li>An account with funds.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li> <p>Some xcUNIT tokens. You can swap DEV tokens (Moonbase Alpha's native token) for xcUNITs on Moonbeam-Swap, a demo Uniswap-V2 clone on Moonbase Alpha</p> <p>Note</p> <p>You can adapt this guide to transfer another external XC-20 or a local XC-20. For external XC-20s, you'll need the asset ID and the number of decimals the asset has. For local XC-20s, you'll need the contract address.</p> <p></p> </li> </ul> <p>To check your xcUNIT balance, you can add the XC-20's precompile address to MetaMask with the following address:</p> <pre><code>0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080\n</code></pre>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#polkadotxcm-transfer-assets-function","title":"Polkadot XCM Transfer Assets Function","text":"<p>In this example, you'll build an XCM message to transfer xcUNIT from Moonbase Alpha back to the Alphanet relay chain through the <code>transferAssets</code> function of the Polkadot XCM Pallet using the Polkadot.js API.</p> <p>To perform a limited reserve transfer using the <code>polkadotXcm</code> pallet, follow these steps:</p> <ol> <li> <p>Install the required dependencies: <code>@polkadot/api</code> for blockchain interaction, <code>@polkadot/util</code> for utility functions, and <code>@polkadot/util-crypto</code> for cryptographic functions.</p> </li> <li> <p>Set up your network connection by creating a WebSocket provider using the Moonbase Alpha endpoint: <code>wss://wss.api.moonbase.moonbeam.network</code>. Initialize the Polkadot API with this provider.</p> </li> <li> <p>Configure your account using the Ethereum format. Create a keyring instance for Ethereum addresses, then add your account using your private key. Remember to prepend the private key with <code>0x</code>, which is omitted when exporting your keys from MetaMask </p> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a JavaScript file.</p> </li> <li> <p>Prepare the destination address by converting the SS58 format address to raw bytes using the <code>decodeAddress</code> function. If the destination SS58 address is already in hexadecimal format, no conversion is needed </p> </li> <li> <p>Construct the XCM transfer transaction with: the relay chain as the destination (parent chain with <code>parents: 1</code>), beneficiary (using <code>AccountId32</code> format), assets (amount with 12 decimals), fee asset item (0), and weight limit ('Unlimited').</p> Define the destination, beneficiary, and asset <pre><code> // dest\n      {\n        V4: {\n          parents: 1,\n          interior: {\n            Here: null\n          }\n        }\n      },\n      // beneficiary\n      {\n        V4: {\n          parents: 1,                   \n          interior: {\n            X1: [                        \n              {\n                AccountId32: {\n                  id: Array.from(beneficiaryRaw),\n                  network: null\n                }\n              }\n            ]\n          }\n        }\n      },\n      // assets\n      {\n        V4: [                           \n          {\n            fun: {                      \n              Fungible: 1000000000000n \n            },\n            id: {                       \n              parents: 1,\n              interior: {\n                Here: null              \n              }\n            }\n          }\n        ]\n      },\n      0,           // feeAssetItem\n      'Unlimited'  // weightLimit\n    );\n</code></pre> </li> <li> <p>Submit your transaction and implement monitoring logic with error handling </p> </li> <li> <p>Once the transaction is finalized, the script will automatically exit. Any errors during the process will be logged to the console for troubleshooting</p> </li> </ol> View the full script <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api';\nimport { decodeAddress } from '@polkadot/util-crypto';\n\nconst main = async () =&gt; {\n  // Setup provider and API\n  const wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Setup account with ethereum format\n  const keyring = new Keyring({ type: 'ethereum' });\n  const account = keyring.addFromUri('INSERT_PRIVATE_KEY');\n\n  // Convert the SS58 address to raw bytes\n  const beneficiaryRaw = decodeAddress('INSERT_DESTINATION_ADDRESS');\n\n  try {\n    // Create the transaction (XCM v4)\n    const tx = api.tx.polkadotXcm.transferAssets(\n      // Destination (V4)\n      {\n        V4: {\n          parents: 1,\n          interior: {\n            Here: null\n          }\n        }\n      },\n      // Beneficiary (V4)\n      {\n        V4: {\n          parents: 1,\n          interior: {\n            X1: [\n              {\n                AccountId32: {\n                  network: null,\n                  id: beneficiaryRaw\n                }\n              }\n            ]\n          }\n        }\n      },\n      // Assets (V4)\n      {\n        V4: [\n          {\n            fun: {\n              Fungible: 1000000000000n\n            },\n            id: {\n              parents: 1,\n              interior: {\n                Here: null\n              }\n            }\n          }\n        ]\n      },\n      0,           // feeAssetItem\n      'Unlimited'  // weightLimit\n    );\n\n    // Sign and send the transaction\n    const unsub = await tx.signAndSend(account, ({ status }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in blockHash ${status.asInBlock}`);\n      } else if (status.isFinalized) {\n        console.log(`Transaction finalized in blockHash ${status.asFinalized}`);\n        unsub();\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error:', error);\n    process.exit(1);\n  }\n};\n\nmain().catch(console.error);\n</code></pre> <p>Note</p> <p>You can view an example of the above script, which sends 1 xcUNIT to Alice's account on the relay chain, on Polkadot.js Apps using the following encoded calldata: <code>0x1c0b0401000400010100d4620637e11439598c5fbae0506dc68b9fb1edb33b316761bf99987a1034a96b0404010000070010a5d4e80000000000</code>.</p> <p>Once the transaction is processed, the target account on the relay chain should have received the transferred amount minus a small fee that is deducted to execute the XCM on the destination chain. </p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#troubleshooting","title":"Troubleshooting","text":"<p>If you're having difficulty replicating the demo, take the following troubleshooting steps:</p> <ul> <li>Ensure your sending account is funded with DEV tokens </li> <li>Ensure your sending account is funded with xcUNIT tokens (or another XC-20 that you have specified)</li> <li>Check the Explorer on Polkadot.js Apps on Moonbase Alpha to ensure a successful transaction on the origin chain</li> <li>Check the Explorer on Polkadot.js Apps and review the XCM messages received on Moonbase Relay Chain</li> </ul>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/","title":"Using the X-Tokens Precompile To Send XC-20s","text":""},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#introduction","title":"Introduction","text":"<p>Building an XCM message for fungible asset transfers is not an easy task. Consequently, there are wrapper functions and pallets that developers can leverage to use XCM features on Polkadot and Kusama. One example of such wrappers is the Polkadot XCM Pallet, which provides different methods to transfer fungible assets via XCM.</p> <p>The Polkadot XCM Pallet is coded in Rust and is normally not accessible from the Ethereum API side of Moonbeam. However, the XCM Precompile and the X-Tokens Precompile allow you to interact directly with the Polkadot XCM pallet to send XC-20s from a Solidity interface.</p> <p>This guide will show you how to leverage the X-Tokens Precompile to send XC-20s from a Moonbeam-based network to other chains in the ecosystem (relay chain/parachains) using Ethereum libraries like Ethers and Web3.</p> <p>Developers must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, it is essential to test XCM features on a TestNet before moving to a production environment.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#contract-address","title":"X-Tokens Precompile Contract Address","text":"<p>The X-Tokens Precompile is located at the following addresses:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000804\n</code></pre> <pre><code>0x0000000000000000000000000000000000000804\n</code></pre> <pre><code>0x0000000000000000000000000000000000000804\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#xtokens-solidity-interface","title":"The X-Tokens Solidity Interface","text":"<p>Xtokens.sol is an interface through which developers can interact with the X-Tokens Pallet using the Ethereum API.</p> Xtokens.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Xtokens contract's address.\naddress constant XTOKENS_ADDRESS = 0x0000000000000000000000000000000000000804;\n\n/// @dev The Xtokens contract's instance.\nXtokens constant XTOKENS_CONTRACT = Xtokens(XTOKENS_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Xtokens Interface\n/// @dev The interface through which solidity contracts will interact with xtokens pallet\n/// @custom:address 0x0000000000000000000000000000000000000804\ninterface Xtokens {\n    // A multilocation is defined by its number of parents and the encoded junctions (interior)\n    struct Multilocation {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    // A MultiAsset is defined by a multilocation and an amount\n    struct MultiAsset {\n        Multilocation location;\n        uint256 amount;\n    }\n\n    // A Currency is defined by address and the amount to be transferred\n    struct Currency {\n        address currencyAddress;\n        uint256 amount;\n    }\n\n    /// Transfer a token through XCM based on its currencyId\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param currencyAddress The ERC20 address of the currency we want to transfer\n    /// @param amount The amount of tokens we want to transfer\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector b9f813ff\n    function transfer(\n        address currencyAddress,\n        uint256 amount,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer a token through XCM based on its currencyId specifying fee\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param currencyAddress The ERC20 address of the currency we want to transfer\n    /// @param amount The amount of tokens we want to transfer\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector 3e506ef0\n    function transferWithFee(\n        address currencyAddress,\n        uint256 amount,\n        uint256 fee,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer a token through XCM based on its MultiLocation\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param asset The asset we want to transfer, defined by its multilocation.\n    /// Currently only Concrete Fungible assets\n    /// @param amount The amount of tokens we want to transfer\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector b4f76f96\n    function transferMultiasset(\n        Multilocation memory asset,\n        uint256 amount,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer a token through XCM based on its MultiLocation specifying fee\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param asset The asset we want to transfer, defined by its multilocation.\n    /// Currently only Concrete Fungible assets\n    /// @param amount The amount of tokens we want to transfer\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector 150c016a\n    function transferMultiassetWithFee(\n        Multilocation memory asset,\n        uint256 amount,\n        uint256 fee,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer several tokens at once through XCM based on its address specifying fee\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param currencies The currencies we want to transfer, defined by their address and amount.\n    /// @param feeItem Which of the currencies to be used as fee\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector ab946323\n    function transferMultiCurrencies(\n        Currency[] memory currencies,\n        uint32 feeItem,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer several tokens at once through XCM based on its location specifying fee\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param assets The assets we want to transfer, defined by their location and amount.\n    /// @param feeItem Which of the currencies to be used as fee\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector 797b45fd\n    function transferMultiAssets(\n        MultiAsset[] memory assets,\n        uint32 feeItem,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n}\n</code></pre> <p>The interface includes the following functions:</p> transfer(address currencyAddress, uint256 amount, Multilocation memory destination, uint64 weight) \u2014 transfer a currency, given the contract address of the currency Parameters <ul> <li><code>currencyAddress</code> - the address of the asset to transfer<ul> <li>For External XC-20s, provide the XC-20 precompile address</li> <li>For native tokens (i.e., GLMR, MOVR, and DEV), provide the ERC-20 precompile address, which is <code>0x0000000000000000000000000000000000000802</code></li> <li>For Local XC-20s, provide the token's address</li> </ul> </li> <li><code>amount</code> - the number of tokens that are going to be sent via XCM</li> <li><code>destination</code> - the multilocation of the destination address for the tokens being sent via XCM. It supports different address formats, such as 20- or 32-byte addresses (Ethereum or Substrate). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>weight</code> - the weight to be purchased to pay for XCM execution on the destination chain, which is charged from the transferred asset</li> </ul> transferWithFee(address currencyAddress, uint256 amount, uint256 fee, Multilocation memory destination, uint64 weight) \u2014 transfer a currency, defined as either the native token (self-reserved) or the asset ID, and specify the fee separately from the amount Parameters <ul> <li><code>currencyAddress</code> - the address of the asset to transfer<ul> <li>For External XC-20s, provide the XC-20 precompile address</li> <li>For native tokens (i.e., GLMR, MOVR, and DEV), provide the ERC-20 precompile address, which is <code>0x0000000000000000000000000000000000000802</code></li> <li>For Local XC-20s, provide the token's address</li> </ul> </li> <li><code>amount</code> - the number of tokens that are going to be sent via XCM</li> <li><code>fee</code> \u2014 the amount to be spent to pay for the XCM execution in the target (destination) chain. If this value is not high enough to cover execution costs, the assets will be trapped in the destination chain</li> <li><code>destination</code> - the multilocation of the destination address for the tokens being sent via XCM. It supports different address formats, such as 20- or 32-byte addresses (Ethereum or Substrate). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>weight</code> - the weight to be purchased to pay for XCM execution on the destination chain, which is charged from the transferred asset</li> </ul> transferMultiasset(Multilocation memory asset, uint256 amount, Multilocation memory destination, uint64 weight) \u2014 transfer a fungible asset, defined by its multilocation Parameters <ul> <li><code>asset</code> - the multilocation of the asset to transfer. The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>amount</code> - the number of tokens that are going to be sent via XCM</li> <li><code>destination</code> - the multilocation of the destination address for the tokens being sent via XCM. It supports different address formats, such as 20- or 32-byte addresses (Ethereum or Substrate). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>weight</code> - the weight to be purchased to pay for XCM execution on the destination chain, which is charged from the transferred asset</li> </ul> transferMultiassetWithFee(Multilocation memory asset, uint256 amount, uint256 fee, Multilocation memory destination, uint64 weight) \u2014 transfer a fungible asset, defined by its multilocation, and pay the fee with a different asset, also defined by its multilocation Parameters <ul> <li><code>asset</code> - the multilocation of the asset to transfer. The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>amount</code> - the number of tokens that are going to be sent via XCM</li> <li><code>fee</code> \u2014 the amount to be spent to pay for the XCM execution in the target (destination) chain. If this value is not high enough to cover execution costs, the assets will be trapped in the destination chain</li> <li><code>destination</code> - the multilocation of the destination address for the tokens being sent via XCM. It supports different address formats, such as 20- or 32-byte addresses (Ethereum or Substrate). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>weight</code> - the weight to be purchased to pay for XCM execution on the destination chain, which is charged from the transferred asset</li> </ul> transferMulticurrencies(Currency[] memory currencies, uint32 feeItem, Multilocation memory destination, uint64 weight) \u2014 transfer different currencies, specifying which is used as the fee. Each currency is defined as either the native token (self-reserved) or the asset ID Parameters <ul> <li><code>currencies</code> - an array of the currencies to send, which are identified by their currency address, and the amount to send</li> <li><code>feeItem</code> \u2014 an index to define the asset position of an array of assets being sent, used to pay for the XCM execution in the target chain. For example, if only one asset is being sent, the <code>feeItem</code> would be <code>0</code></li> <li><code>destination</code> - the multilocation of the destination address for the tokens being sent via XCM. It supports different address formats, such as 20- or 32-byte addresses (Ethereum or Substrate). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>weight</code> - the weight to be purchased to pay for XCM execution on the destination chain, which is charged from the transferred asset</li> </ul> transferMultiassets(MultiAsset[] memory assets, uint32 feeItem, Multilocation memory destination, uint64 weight) \u2014 transfer several fungible assets, defined by their multilocation, and pay the fee with one of the assets, also defined by its multilocation Parameters <ul> <li><code>assets</code> - an array of the multilocations of each asset to transfer. The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>feeItem</code> \u2014 an index to define the asset position of an array of assets being sent, used to pay for the XCM execution in the target chain. For example, if only one asset is being sent, the <code>feeItem</code> would be <code>0</code></li> <li><code>destination</code> - the multilocation of the destination address for the tokens being sent via XCM. It supports different address formats, such as 20- or 32-byte addresses (Ethereum or Substrate). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>weight</code> - the weight to be purchased to pay for XCM execution on the destination chain, which is charged from the transferred asset</li> </ul>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#building-the-precompile-multilocation","title":"Building the Precompile Multilocation","text":"<p>Multilocations define a specific point in the entire relay chain/parachain ecosystem relative to a given origin. They are frequently used by the X-Tokens Precompile to define the location of assets and destination chains and accounts.</p> <p>Multilocations need to be formatted in a specific way that precompiles can understand, which is different than the format seen when interacting with pallets. In the X-Tokens Precompile interface, the <code>Multilocation</code> structure is defined as follows:</p> <pre><code> struct Multilocation {\n    uint8 parents;\n    bytes[] interior;\n}\n</code></pre> <p>As with a standard multilocation, there are <code>parents</code> and <code>interior</code> elements. However, instead of defining the multilocation as an object, with Ethereum libraries, the struct is defined as an array, which contains a <code>uint8</code> for the <code>parents</code> as the first element and a bytes array for the <code>interior</code> as the second element.</p> <p>The normal values you would see for the <code>parents</code> element are:</p> Origin Destination Parents Value Parachain A Parachain A 0 Parachain A Relay Chain 1 Parachain A Parachain B 1 <p>For the <code>interior</code> element, the number of fields you need to drill down to in the target chain to reach the exact location of the target, such as the specific asset or account, represents the size of the bytes array:</p> Array Size Interior Value [] 0 Here [XYZ] 1 X1 [XYZ, ABC] 2 X2 [XYZ, ... N] N XN <p>Note</p> <p>Interior value <code>Here</code> is often used for the relay chain (either as a destination or to target the relay chain asset).</p> <p>Each field required to reach the exact location of the target needs to be defined as a hex string. The first byte (2 hexadecimal characters) corresponds to the selector of the field. For example:</p> Byte Value Selector Data Type 0x00 Parachain bytes4 0x01 AccountId32 bytes32 0x02 AccountIndex64 u64 0x03 AccountKey20 bytes20 0x04 PalletInstance byte 0x05 GeneralIndex u128 0x06 GeneralKey bytes[] <p>Next, depending on the selector and its data type, the following bytes correspond to the actual data being provided. Note that for <code>AccountId32</code>, <code>AccountIndex64</code>, and <code>AccountKey20</code>, the optional <code>network</code> field is appended at the end. For example:</p> Selector Data Value Represents Parachain \"0x00+000007E7\" Parachain ID 2023 AccountId32 \"0x01+AccountId32+00\" AccountId32, Network(Option) Null AccountId32 \"0x01+AccountId32+03\" AccountId32, Network Polkadot AccountKey20 \"0x03+AccountKey20+00\" AccountKey20, Network(Option) Null PalletInstance \"0x04+03\" Pallet Instance 3 <p>Note</p> <p>The <code>interior</code> data usually needs to be wrapped around quotes, or you might get an <code>invalid tuple value</code> error.</p> <p>The following code snippet goes through some examples of multilocation structures, as they would need to be fed into the X-Tokens Precompile functions:</p> <pre><code>// Multilocation targeting the relay chain or its asset from a parachain\n[\n  1, // parents = 1\n  [], // interior = here\n]\n\n// Multilocation targeting Moonbase Alpha DEV token from another parachain\n[\n  1, // parents = 1\n  [  // interior = X2 (the array has a length of 2)\n    '0x00000003E8', // Parachain selector + Parachain ID 1000 (Moonbase Alpha)\n    '0x0403', // Pallet Instance selector + Pallet Instance 3 (Balances Pallet)\n  ],\n]\n\n// Multilocation targeting Alice's account on the relay chain from Moonbase Alpha\n[\n  1, // parents = 1\n  [  // interior = X1 (the array has a length of 1)\n     // AccountKey32 selector + AccountId32 address in hex + Network(Option) Null\n    '0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300', \n  ],\n]\n</code></pre>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#build-xcm-xtokens-precompile","title":"Building an XCM Message","text":"<p>This guide covers the process of building an XCM message using the X-Tokens Precompile, more specifically, with the <code>transfer</code> and <code>transferMultiasset</code> functions. Nevertheless, these two cases can be extrapolated to the other functions of the precompile, especially once you become familiar with multilocations.</p> <p>You'll be transferring xcUNIT tokens, which are the XC-20 representation of the Alphanet relay chain token, UNIT. You can adapt this guide for any other XC-20.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#xtokens-check-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with the examples in this guide, you need to have the following:</p> <ul> <li> <p>The ABI of the X-Tokens Precompile</p> X-Tokens Precompile ABI <pre><code>export default [\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'currencyAddress',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transfer',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              {\n                internalType: 'uint8',\n                name: 'parents',\n                type: 'uint8',\n              },\n              {\n                internalType: 'bytes[]',\n                name: 'interior',\n                type: 'bytes[]',\n              },\n            ],\n            internalType: 'struct Xtokens.Multilocation',\n            name: 'location',\n            type: 'tuple',\n          },\n          {\n            internalType: 'uint256',\n            name: 'amount',\n            type: 'uint256',\n          },\n        ],\n        internalType: 'struct Xtokens.MultiAsset[]',\n        name: 'assets',\n        type: 'tuple[]',\n      },\n      {\n        internalType: 'uint32',\n        name: 'feeItem',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferMultiAssets',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'address',\n            name: 'currencyAddress',\n            type: 'address',\n          },\n          {\n            internalType: 'uint256',\n            name: 'amount',\n            type: 'uint256',\n          },\n        ],\n        internalType: 'struct Xtokens.Currency[]',\n        name: 'currencies',\n        type: 'tuple[]',\n      },\n      {\n        internalType: 'uint32',\n        name: 'feeItem',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferMultiCurrencies',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'asset',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferMultiasset',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'asset',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: 'fee',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferMultiassetWithFee',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'currencyAddress',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: 'fee',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferWithFee',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> </li> <li> <p>An account with funds.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</p> </li> <li> <p>Some xcUNIT tokens. You can swap DEV tokens (Moonbase Alpha's native token) for xcUNITs on Moonbeam-Swap, a demo Uniswap-V2 clone on Moonbase Alpha</p> <p>Note</p> <p>You can adapt this guide to transfer another external XC-20 or a local XC-20. For external XC-20s, you'll need the asset ID and the number of decimals the asset has. For local XC-20s, you'll need the contract address.</p> <p></p> <p>To check your xcUNIT balance, you can add the XC-20's precompile address to MetaMask with the following address:</p> <pre><code>0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080\n</code></pre> </li> </ul> <p>Note</p> <p>To test out the examples on Moonbeam or Moonriver, you can replace the RPC URL with your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#determining-weight","title":"Determining Weight Needed for XCM Execution","text":"<p>To determine the weight needed for XCM execution on the destination chain, you'll need to know which XCM instructions are executed on the destination chain. You can find an overview of the XCM instructions used in the XCM Instructions for Transfers via X-Tokens guide.</p> <p>Note</p> <p>Some weights include database reads and writes; for example, the <code>WithdrawAsset</code> and <code>DepositAsset</code> instructions include both one database read and one write. To get the total weight, you'll need to add the weight of any required database reads or writes to the base weight of the given instruction.</p> <p>For Westend-based relay chains, like Alphanet, you can get the weight cost for read and write database operations for Rocks DB (which is the default database) in the polkadot-sdk repository on GitHub.</p> <p>Since Alphanet is a Westend-based relay chain, you can refer to the instruction weights defined in the Westend runtime code, which are broken up into two types of instructions: fungible and generic.</p> <p>It's important to note that each chain defines its own weight requirements. To determine the weight required for each XCM instruction on a given chain, please refer to the chain's documentation or reach out to a member of their team. To learn how to find the weights required by Moonbeam, Polkadot, or Kusama, you can refer to our documentation on Weights and Fees.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#precompile-transfer","title":"X-Tokens Precompile Transfer Function","text":"<p>To use the <code>transfer</code> function of the X-Tokens Precompile, you'll take these general steps:</p> <ol> <li>Create a provider using a Moonbase Alpha RPC endpoint</li> <li>Create a signer to send the transaction. This example uses a private key to create the signer and is for demo purposes only. Never store your private key in a JavaScript file</li> <li>Create a contract instance of the X-Tokens Precompile using the address and ABI of the precompile</li> <li> <p>Assemble the arguments for the <code>transfer</code> function:</p> <ul> <li><code>currencyAddress</code> - the address for xcUNIT: <code>0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080</code></li> <li><code>amount</code> - 1 xcUNIT. Since xcUNIT has 12 decimals, you can use: <code>1000000000000</code></li> <li><code>destination</code> - the multilocation of the destination, which targets Alice's account on the relay chain: <code>'0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'</code></li> <li><code>weight</code> - the weight to purchase for the XCM execution on the destination chain: <code>305,986,000</code></li> </ul> </li> <li> <p>Create the <code>transfer</code> function, passing in the arguments</p> </li> <li>Sign and send the transaction</li> </ol> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport abi from './xtokensABI.js'; // Import the X-Tokens ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n// Create X-Tokens contract instance\nconst xTokens = new ethers.Contract(\n  '0x0000000000000000000000000000000000000804',\n  abi,\n  signer\n);\n\n// Arguments for the transfer function\nconst currencyAddress = '0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080'; // xcUNIT address\nconst amount = 1000000000000;\nconst destination = [\n  // Target the relay chain from Moonbase Alpha\n  1,\n  // Target Alice's 32-byte relay chain account\n  ['0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'],\n];\nconst weight = 305986000;\n\n// Sends 1 xcUNIT to the relay chain using the transfer function\nasync function transferToAlice() {\n  // Creates, signs, and sends the transfer transaction\n  const transaction = await xTokens.transfer(\n    currencyAddress,\n    amount,\n    destination,\n    weight\n  );\n\n  // Waits for the transaction to be included in a block\n  await transaction.wait();\n  console.log(transaction);\n}\n\ntransferToAlice();\n</code></pre> <pre><code>import Web3 from 'web3'; // Import Web3 library\nimport abi from './xtokensABI.js'; // Import the X-Tokens ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Web3 provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n// Create contract instance\nconst xTokens = new web3.eth.Contract(\n  abi,\n  '0x0000000000000000000000000000000000000804',\n  { from: web3.eth.accounts.privateKeyToAccount(privateKey).address } // 'from' is necessary for gas estimation\n);\n\n// Arguments for the transfer function\nconst currencyAddress = '0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080'; // xcUNIT address\nconst amount = 1000000000000;\nconst destination = [\n  // Target the relay chain from Moonbase Alpha\n  1,\n  // Target Alice's 32-byte relay chain account\n  ['0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'],\n];\nconst weight = 305986000;\n\n// Sends 1 xcUNIT to the relay chain using the transfer function\nasync function transferToAlice() {\n  // Create transaction\n  const transferTx = xTokens.methods.transfer(\n    currencyAddress,\n    amount,\n    destination,\n    weight\n  );\n\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: '0x0000000000000000000000000000000000000804',\n      data: transferTx.encodeABI(),\n      gas: await transferTx.estimateGas(),\n    },\n    privateKey\n  );\n\n  // Send signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(sendTx);\n}\n\ntransferToAlice();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_XTOKENS_ABI\"  # Paste or import the x-tokens ABI\nprivate_key = \"INSERT_PRIVATE_KEY\"  # This is for demo purposes, never store your private key in plain text\naddress = \"INSERT_ADDRESS\"  # The wallet address that corresponds to your private key\n\n# Create Web3 provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create contract instance\nx_tokens = web3.eth.contract(\n    address=\"0x0000000000000000000000000000000000000804\", abi=abi\n)\n\n# Arguments for the transfer function\ncurrencyAddress = \"0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080\" # xcUNIT address\namount = 1000000000000\ndestination = [\n    # Target the relay chain from Moonbase Alpha\n    1,\n    # Target Alice's 32-byte relay chain account\n    [\"0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300\"],\n]\nweight = 305986000\n\n# Sends 1 xcUNIT to the relay chain using the transfer function\ndef transfer_to_alice():\n    # Create transaction\n    transferTx = x_tokens.functions.transfer(\n        currencyAddress, amount, destination, weight\n    ).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n\n    # Sign transaction\n    signedTx = web3.eth.account.sign_transaction(transferTx, private_key)\n\n    # Send tx and wait for receipt\n    hash = web3.eth.send_raw_transaction(signedTx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Tx successful with hash: { receipt.transactionHash.hex() }\")\n\n\ntransfer_to_alice()\n</code></pre>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#precompile-transfer-multiasset","title":"X-Tokens Precompile Transfer Multiasset Function","text":"<p>To use the <code>transfer</code> function of the X-Tokens Precompile, you'll take these general steps:</p> <ol> <li>Create a provider using a Moonbase Alpha RPC endpoint</li> <li>Create a signer to send the transaction. This example uses a private key to create the signer and is for demo purposes only. Never store your private key in a JavaScript file</li> <li>Create a contract instance of the X-Tokens Precompile using the address and ABI of the precompile</li> <li> <p>Assemble the arguments for the <code>transferMultiasset</code> function:</p> <ul> <li><code>asset</code> - the multilocation for xcUNIT: <code>[1, []]</code></li> <li><code>amount</code> - 1 xcUNIT. Since xcUNIT has 12 decimals, you can use: <code>1000000000000</code></li> <li><code>destination</code> - the multilocation of the destination, which targets Alice's account on the relay chain: <code>'0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'</code></li> <li><code>weight</code> - the weight to purchase for the XCM execution on the destination chain: <code>305986000</code></li> </ul> </li> <li> <p>Create the <code>transferMultiasset</code> function, passing in the arguments</p> </li> <li>Sign and send the transaction</li> </ol> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport abi from './xtokensABI.js'; // Import the X-Tokens ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n// Create X-Tokens contract instance\nconst xTokens = new ethers.Contract(\n  '0x0000000000000000000000000000000000000804',\n  abi,\n  signer\n);\n\n// Arguments for the transfer multiasset function\nconst asset = [1, []]; // Multilocation targeting the relay chain\nconst amount = 1000000000000;\nconst dest = [\n  // Target the relay chain from Moonbase Alpha\n  1,\n  // Target Alice's 32-byte relay chain account\n  ['0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'],\n];\nconst weight = 305986000;\n\n// Sends 1 xcUNIT to the relay chain using the transferMultiasset function\nasync function transferMultiassetToAlice() {\n  const transaction = await xTokens.transferMultiasset(\n    asset,\n    amount,\n    dest,\n    weight\n  );\n  await transaction.wait();\n  console.log(transaction);\n}\n\ntransferMultiassetToAlice();\n</code></pre> <pre><code>import Web3 from 'web3'; // Import Web3 library\nimport abi from './xtokensABI.js'; // Import the X-Tokens ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Web3 provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n// Create contract instance\nconst xTokens = new web3.eth.Contract(\n  abi,\n  '0x0000000000000000000000000000000000000804',\n  { from: web3.eth.accounts.privateKeyToAccount(privateKey).address } // 'from' is necessary for gas estimation\n);\n\n// Arguments for the transfer multiasset function\nconst asset = [1, []]; // Multilocation targeting the relay chain\nconst amount = 1000000000000;\nconst dest = [\n  // Target the relay chain from Moonbase Alpha\n  1,\n  // Target Alice's 32-byte relay chain account\n  ['0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'],\n];\nconst weight = 305986000;\n\n// Sends 1 xcUNIT to the relay chain using the transferMultiasset function\nasync function transferMultiassetToAlice() {\n  // Create transaction\n  const transferTx = xTokens.methods.transferMultiasset(\n    asset,\n    amount,\n    dest,\n    weight\n  );\n\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: '0x0000000000000000000000000000000000000804',\n      data: transferTx.encodeABI(),\n      gas: await transferTx.estimateGas(),\n    },\n    privateKey\n  );\n\n  // Send signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(sendTx);\n}\n\ntransferMultiassetToAlice();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_XTOKENS_ABI\"  # Paste or import the x-tokens ABI\nprivate_key = \"INSERT_PRIVATE_KEY\"  # This is for demo purposes, never store your private key in plain text\naddress = \"INSERT_ADDRESS\"  # The wallet address that corresponds to your private key\n\n# Create Web3 provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create contract instance\nx_tokens = web3.eth.contract(\n    address=\"0x0000000000000000000000000000000000000804\", abi=abi\n)\n\n# Arguments for the transfer function\nasset = [1, []]  # Multilocation targeting the relay chain\namount = 1000000000000\ndest = [\n    # Target the relay chain from Moonbase Alpha\n    1,\n    # Target Alice's 32-byte relay chain account\n    [\"0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300\"],\n]\nweight = 305986000\n\n\n# Sends 1 xcUNIT to the relay chain using the transferMultiasset function\ndef transfer_multiasset_to_alice():\n    # Create transaction\n    transferTx = x_tokens.functions.transferMultiasset(\n        asset, amount, dest, weight\n    ).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n\n    # Sign transaction\n    signedTx = web3.eth.account.sign_transaction(transferTx, private_key)\n\n    # Send tx and wait for receipt\n    hash = web3.eth.send_raw_transaction(signedTx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Tx successful with hash: { receipt.transactionHash.hex() }\")\n\n\ntransfer_multiasset_to_alice()\n</code></pre>"},{"location":"builders/substrate/dev-env/chopsticks/","title":"How to Use Chopsticks to Fork Moonbeam","text":""},{"location":"builders/substrate/dev-env/chopsticks/#introduction","title":"Introduction","text":"<p>Chopsticks provides a developer-friendly method of locally forking existing Substrate based chains. It allows for the replaying of blocks to easily examine how extrinsics affect state, the forking of multiple blocks for XCM testing, and more. This allows developers to test and experiment with their own custom blockchain configurations in a local development environment, without the need to deploy a live network.  </p> <p>Overall, Chopsticks aims to simplify the process of building blockchain applications on Substrate and make it accessible to a wider range of developers.</p>"},{"location":"builders/substrate/dev-env/chopsticks/#forking-moonbeam","title":"Forking Moonbeam with Chopsticks","text":"<p>To use Chopsticks, you can install it as a package with the Node package manager or Yarn:  </p> <pre><code>npm i @acala-network/chopsticks@latest\n</code></pre> <p>Once installed, you can run commands with the Node package executor. For example, this runs Chopstick's base command:  </p> <pre><code>npx @acala-network/chopsticks@latest\n</code></pre> <p>To run Chopsticks, you will need some sort of configuration, typically through a file. Chopsticks' source repository includes a set of YAML configuration files that can be used to create a local copy of a variety of Substrate chains. You can download the configuration files from the source repository's <code>configs</code> folder.  </p> <p>Moonbeam, Moonriver, and Moonbase Alpha all have default files available:  </p> MoonbeamMoonriverMoonbase Alpha <pre><code>endpoint: wss://wss.api.moonbeam.network\nmock-signature-host: true\ndb: ./db.sqlite\n\nimport-storage:\n  System:\n    Account:\n      -\n        -\n          - \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n        - data:\n            free: \"100000000000000000000000\"\n  TechCommitteeCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  CouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  TreasuryCouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  AuthorFilter:\n    EligibleRatio: 100\n    EligibleCount: 100\n</code></pre> <pre><code>endpoint: wss://wss.moonriver.moonbeam.network\nmock-signature-host: true\ndb: ./db.sqlite\n\nimport-storage:\n  System:\n    Account:\n      -\n        -\n          - \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n        - data:\n            free: \"100000000000000000000000\"\n  TechCommitteeCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  CouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  TreasuryCouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  AuthorFilter:\n    EligibleRatio: 100\n    EligibleCount: 100\n</code></pre> <pre><code>endpoint: wss://wss.api.moonbase.moonbeam.network\nmock-signature-host: true\ndb: ./db.sqlite\n\nimport-storage:\n  System:\n    Account:\n      -\n        -\n          - \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n        - data:\n            free: \"100000000000000000000000\"\n  TechCommitteeCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  CouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  TreasuryCouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  Sudo:\n    Key: \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n  AuthorFilter:\n    EligibleRatio: 100\n    EligibleCount: 100\n</code></pre> <p>These are the settings that can be included in the config file:  </p> Option Description <code>genesis</code> The link to a parachain's raw genesis file to build the fork from, instead of an endpoint. <code>timestamp</code> Timestamp of the block to fork from. <code>endpoint</code> The endpoint of the parachain to fork. <code>block</code> Use to specify at which block hash or number to replay the fork. <code>wasm-override</code> Path of the WASM to use as the parachain runtime, instead of an endpoint's runtime. <code>db</code> Path to the name of the file that stores or will store the parachain's database. <code>config</code> Path or URL of the config file. <code>port</code> The port to expose an endpoint on. <code>build-block-mode</code> How blocks should be built in the fork: batch, manual, instant. <code>import-storage</code> A pre-defined JSON/YAML storage file path to override in the parachain's storage. <code>allow-unresolved-imports</code> Whether to allow WASM unresolved imports when using a WASM to build the parachain. <code>html</code> Include to generate storage diff preview between blocks. <code>mock-signature-host</code> Mock signature host so that any signature starts with <code>0xdeadbeef</code> and filled by <code>0xcd</code> is considered valid. <p>You can use the configuration file with the base command <code>npx @acala-network/chopsticks@latest</code> to fork assets by providing it with the <code>--config</code> flag.  </p> <p>You can use a raw GitHub URL of the default configuration files, a path to a local configuration file, or simply use the chain's name for the <code>--config</code> flag. For example, the following commands all use Moonbeam's configuration in the same way:  </p> Chain NameGitHub URLLocal File Path <pre><code>npx @acala-network/chopsticks@latest --config=moonbeam\n</code></pre> <pre><code>npx @acala-network/chopsticks@latest \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbeam.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks@latest --config=configs/moonbeam.yml\n</code></pre> <p>Note</p> <p>If using a file path, make sure you've downloaded the Moonbeam configuration file, or have created your own.</p> <p>A configuration file is not necessary, however. All of the settings (except <code>genesis</code> and <code>timestamp</code>) can also be passed as flags to configure the environment completely in the command line. For example, the following command forks Moonbase Alpha at block 100.</p> <pre><code>npx @acala-network/chopsticks@latest --endpoint wss://wss.api.moonbase.moonbeam.network --block 100\n</code></pre>"},{"location":"builders/substrate/dev-env/chopsticks/#quickstart","title":"Quickstart","text":"<p>The simplest way to fork Moonbeam is through the configuration files that are stored in the Chopsticks GitHub repository:  </p> MoonbeamMoonriverMoonbase Alpha <pre><code>npx @acala-network/chopsticks@latest \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbeam.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks@latest \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonriver.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks@latest \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbase-alpha.yml\n</code></pre>"},{"location":"builders/substrate/dev-env/chopsticks/#interacting-with-a-fork","title":"Interacting with a Fork","text":"<p>When running a fork, by default it will be accessible at:</p> <pre><code>ws://localhost:8000\n</code></pre> <p>You will be able to interact with the parachain via libraries such as Polkadot.js and its user interface, Polkadot.js Apps.  </p> <p>You can interact with Chopsticks via the Polkadot.js Apps hosted user interface. To do so, visit the page and take the following steps:  </p> <ol> <li>Click the icon in the top left</li> <li>Go to the bottom and open Development</li> <li>Select the Custom endpoint and enter <code>ws://localhost:8000</code></li> <li>Click the Switch button</li> </ol> <p> </p> <p>You should now be able to interact with the fork as you would an active parachain or relay chain.</p> <p>Note</p> <p>If your browser cannot connect to the WebSocket endpoint provided by Chopsticks, you might need to allow insecure connections for the Polkadot.js Apps URL. Another solution is to run the Docker version of Polkadot.js Apps.</p>"},{"location":"builders/substrate/dev-env/chopsticks/#replaying-blocks","title":"Replaying Blocks","text":"<p>In the case where you would like to replay a block and retrieve its information to dissect the effects of an extrinsic, you can use the <code>npx @acala-network/chopsticks@latest run-block</code> command. Its following flags are:  </p> Flag Description <code>endpoint</code> The endpoint of the parachain to fork. <code>block</code> Use to specify at which block hash or number to replay the fork. <code>wasm-override</code> Path of the WASM to use as the parachain runtime, instead of an endpoint's runtime. <code>db</code> Path to the name of the file that stores or will store the parachain's database. <code>config</code> Path or URL of the config file. <code>output-path=/[file_path]</code> Use to print out results to a JSON file instead of printing it out in the console. <code>html</code> Include to generate an HTML representation of the storage diff preview between blocks. <code>open</code> Whether to open the HTML representation. <p>For example, running the following command will re-run Moonbeam's block 1000, and write the storage diff and other data in a <code>moonbeam-output.json</code> file:  </p> <pre><code>npx @acala-network/chopsticks@latest run-block  \\\n--endpoint wss://wss.api.moonbeam.network  \\\n--output-path=./moonbeam-output.json  \\\n--block 1000\n</code></pre>"},{"location":"builders/substrate/dev-env/chopsticks/#xcm-testing","title":"XCM Testing","text":"<p>To test out XCM messages between networks, you can fork multiple parachains and a relay chain locally. For example, the following will fork Moonriver, Karura, and Kusama given that you've downloaded the <code>configs</code> directory from the source GitHub repository:  </p> <pre><code>npx @acala-network/chopsticks@latest xcm \\\n--r=kusama.yml \\\n--p=moonriver.yml \\\n--p=karura.yml\n</code></pre> <p>You should see something like the following output:  </p> <pre><code>[13:50:57.807] INFO (rpc/64805): Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonriver.yml\n[13:50:59.655] INFO (rpc/64805): Moonriver RPC listening on port 8000\n[13:50:59.656] INFO (rpc/64805): Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/karura.yml\n[13:51:03.275] INFO (rpc/64805): Karura RPC listening on port 8001\n[13:51:03.586] INFO (xcm/64805): Connected parachains [2000,2023]\n[13:51:03.586] INFO (rpc/64805): Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/kusama.yml\n[13:51:07.241] INFO (rpc/64805): Kusama RPC listening on port 8002\n[13:51:07.700] INFO (xcm/64805): Connected relaychain 'Kusama' with parachain 'Moonriver'\n[13:51:08.386] INFO (xcm/64805): Connected relaychain 'Kusama' with parachain 'Karura'\n</code></pre> <p>Including the <code>r</code> flag as the relay chain is optional, as Chopsticks will automatically mock a relay chain between networks. You can also use a raw GitHub URL or the name of a popular branch, similar to the base command.  </p>"},{"location":"builders/substrate/dev-env/chopsticks/#websocket-commands","title":"WebSocket Commands","text":"<p>Chopsticks' internal websocket server has special endpoints that allows the manipulation of the local Substrate chain. These are the methods that can be invoked:  </p> Method Parameters Description <code>dev_newBlock</code> <code>options</code> Generates one or more new blocks. <code>dev_setStorage</code> <code>values</code>, <code>blockHash</code> Create or overwrite the value of any storage. <code>dev_timeTravel</code> <code>date</code> Sets the timestamp of the block to the <code>date</code> value. <code>dev_setHead</code> <code>hashOrNumber</code> Sets the head of the blockchain to a specific hash or number. <p>The parameters above are formatted in the following ways:  </p> Parameter Format Example <code>options</code> <code>{ \"to\": number, \"count\": number }</code> <code>{ \"count\": 5 }</code> <code>values</code> <code>Object</code> <code>{ \"Sudo\": { \"Key\": \"0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b\" } }</code> <code>blockHash</code> <code>string</code> <code>\"0x1a34506b33e918a0106b100db027425a83681e2332fe311ee99d6156d2a91697\"</code> <code>date</code> <code>Date</code> <code>\"2030-08-15T00:00:00\"</code> <code>hashOrNumber</code> <code>number               |                                string</code> <ul> <li><code>options</code> { \"to\": number, \"count\": number } - a JSON object where <code>\"to\"</code> will create blocks up to a certain value, and <code>\"count\"</code> will increase by a certain number of blocks. Use only one entry at a time within the JSON object  </li> <li><code>values</code> Object - a JSON object resembling the path to a storage value, similar to what you would retrieve via Polkadot.js  </li> <li><code>blockHash</code> string - optional, the blockhash at which the storage value is changed  </li> <li><code>date</code> Date - a Date string (compatible with the JavaScript Date library) that will change the time stamp from which the next blocks being created will be at. All future blocks will be sequentially after that point in time  </li> <li><code>hashOrNumber</code> number | string - if found, the chain head will be set to the block with the block number or block hash of this value  </li> </ul> <p>Each method can be invoked by connecting to the websocket (<code>ws://localhost:8000</code> by default) and sending the data and parameters in the following format. Replace <code>METHOD_NAME</code> with the name of the method, and replace or delete <code>PARAMETER_1</code> and <code>PARAMETER_2</code> with the parameter data relevant to the method:  </p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"METHOD_NAME\",\n    \"params\": [\"PARAMETER_1\", \"PARAMETER_2\", \"...\"]\n}\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/substrate/interfaces/account/identity/","title":"The Identity Pallet","text":""},{"location":"builders/substrate/interfaces/account/identity/#introduction","title":"Introduction","text":"<p>The Substrate Identity Pallet is an out-of-the-box solution for adding personal information to your on-chain account. Personal information can include default fields such as your legal name, display name, website, Twitter handle, and Riot (now known as Element) name. You can also take advantage of custom fields to include any other relevant information.</p> <p>The pallet also includes functionality to request judgments and verify on-chain identities from registrars, which are accounts appointed via governance to verify the identity information submitted and provide judgment on their findings for a fee.</p> <p>This guide will provide an overview of the extrinsics, storage methods, and getters for the pallet constants available in the Identity Pallet on Moonbeam. This guide assumes you are familiar with identity-related terminology; if not, please check out the Managing your Account Identity page for more information.</p>"},{"location":"builders/substrate/interfaces/account/identity/#preimage-pallet-interface","title":"Identity Pallet Interface","text":""},{"location":"builders/substrate/interfaces/account/identity/#extrinsics","title":"Extrinsics","text":"<p>The Identity Pallet provides the following extrinsics (functions):</p> addRegistrar(account) - adds an account as a registrar. Must be executed by the General Admin Origin ParametersPolkadot.js API Example <ul> <li><code>account</code> - the account to add as a registrar</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst account = INSERT_ACCOUNT;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.addRegistrar(account);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> addSub(sub, data) - adds an account as a sub-account of the caller. You can optionally provide a name for the sub-account. This function is not callable via a <code>NonTransfer</code> proxy. You can sign the transaction directly or use a different proxy type (<code>Any</code>, <code>IdentityJudgement</code>, etc.) ParametersPolkadot.js API Example <ul> <li><code>sub</code> - the account to add as a sub-account</li> <li><code>data</code> - an object that specifies the name of the sub-account, where the key is the data type and the value is the data. You can use any of the following data types to define the name of the sub-account:<ul> <li><code>None</code> - no name should be used</li> <li><code>Raw</code> - a raw value using hex or ascii</li> <li><code>BlakeTwo256</code> - a BLAKE2-256 hash value</li> <li><code>Sha256</code> - a SHA-256 value</li> <li><code>Keccak256</code> - a Keccak-256 value</li> <li><code>ShaThree256</code> - a SHA3-256 value</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst sub = 'INSERT_SUB_ACCOUNT';\nconst data = { INSERT_DATA_TYPE: 'INSERT_DATA' };\n/* \n        For None, use the following format:\n        const data = { 'None': null };\n\n        For all other data types, use the name of the data type\n        and the value formatted in that specific type. For example:\n        const data = { 'Raw': 'Alice' };\n        */\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.addSub(sub, data);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> cancelRequest(regIndex) - cancels the caller's request for judgment from a given registrar ParametersPolkadot.js API Example <ul> <li><code>regIndex</code> - the index of the registrar</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst regIndex = 'INSERT_INDEX_OF_REGISTRAR';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.cancelRequest(regIndex);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> clearIdentity() - clears the identity for the caller ParametersPolkadot.js API Example <p>None.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.clearIdentity();\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> killIdentity(target) - removes an account's identity and sub-accounts. Must be executed by the General Admin Origin ParametersPolkadot.js API Example <ul> <li><code>target</code> - the account to remove the identity and sub-accounts for</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst target = 'INSERT_TARGET_ACCOUNT';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.killIdentity(target);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> provideJudgement(regIndex, target, judgement, identity) - provides judgment on an account's identity.  The caller must be the registrar account that corresponds to the <code>index</code>. Must be executed by a registrar ParametersPolkadot.js API Example <ul> <li><code>regIndex</code> - the index of the registrar submitting the judgement</li> <li><code>target</code> - the account to provide the judgment for</li> <li><code>judgement</code> - the judgement or level of confidence in the identity information provided. There are seven levels of confidence, you can either provide the name or the index of the confidence level:<ul> <li><code>Unknown</code> or <code>0</code> - no judgement made yet. This is the default value</li> <li><code>FeePaid</code> or <code>1</code> - indicates a user has requested judgement and it is in progress</li> <li><code>Reasonable</code> or <code>2</code> - the information appears reasonable, but no in-depth checks were performed using legal identity documents</li> <li><code>KnownGood</code> or <code>3</code> - the information is correct and is based upon review of legal identity documents</li> <li><code>OutOfDate</code> or <code>4</code> - the information used to be good, but is now out of date</li> <li><code>LowQuality</code> or <code>5</code> - the information is low quality or imprecise, but can be updated as needed</li> <li><code>Erroneous</code> or <code>6</code> - the information is erroneous and may indicate malicious intent. This state cannot be modified and can only be removed if the entire identity has been removed</li> </ul> </li> <li><code>identity</code> - the 32-byte hash of the identity</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst regIndex = 'INSERT_REGISTRAR_INDEX';\nconst target = 'INSERT_TARGET_ACCOUNT';\nconst judgement = 'INSERT_JUDGEMENT';\nconst identity = 'INSERT_IDENTITY';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.provideJudgement(\n    regIndex,\n    target,\n    judgement,\n    identity\n  );\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> quitSub() - removes the caller as a sub-identity account ParametersPolkadot.js API Example <p>None.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.quitSub();\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> removeSub(sub) - removes a sub-identity account for the caller ParametersPolkadot.js API Example <ul> <li><code>sub</code> - the sub-identity account to remove</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst sub = 'INSERT_ACCOUNT';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.removeSub(sub);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n</code></pre> renameSub(sub) - renames a sub-identity account for the caller ParametersPolkadot.js API Example <ul> <li><code>sub</code> - the sub-identity account to rename</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst sub = 'INSERT_ACCOUNT';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.rename(sub);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n</code></pre> requestJudgement(regIndex, maxFee) - requests judgment from a given registrar along with the maximum fee the caller is willing to pay ParametersPolkadot.js API Example <ul> <li><code>regIndex</code> - the index of the registrar to request judgement from</li> <li><code>maxFee</code> - the maximum fee in Wei that can be paid to the registrar for providing judgement</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst regIndex = INSERT_REGISTRAR_INDEX;\nconst maxFee = INSERT_MAX_FEE;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.requestJudgement(regIndex, maxFee);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> setAccountId(index, new) - sets a new account for an existing registrar. Must be executed by the registrar account that corresponds to the <code>index</code>. ParametersPolkadot.js API Example <ul> <li><code>index</code> - the index of the registrar</li> <li><code>new</code> - the account to set as the registrar's new account</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst index = INSERT_REGISTRAR_INDEX;\nconst newAccount = 'INSERT_NEW_ACCOUNT';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.setAccountId(index, newAccount);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> setFee(index, fee) - sets the fee for a registar. Must be executed by the registrar account that corresponds to the <code>index</code> ParametersPolkadot.js API Example <ul> <li><code>index</code> - the index of the registrar</li> <li><code>fee</code> - the fee in Wei required to be paid to the registrar for a judgement</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst index = INSERT_REGISTRAR_INDEX;\nconst fee = INSERT_FEE;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.setFee(index, fee);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> setFields(index, fields) - sets the fields that a registrar cares about when providing judgements. Must be executed by the registrar account that corresponds to the <code>index</code> ParametersPolkadot.js API Example <ul> <li><code>index</code> - the index of the registrar</li> <li><code>fields</code> - an array of the fields that the registrar cares about. The fields can be any of the following:<ul> <li><code>Display</code> - a display name</li> <li><code>Legal</code> - a legal name</li> <li><code>Web</code> - a website</li> <li><code>Riot</code> - a Riot username</li> <li><code>Email</code> - an email address</li> <li><code>PpgFingerprint</code> - a PPG fingerprint</li> <li><code>Image</code> - an image</li> <li><code>Twitter</code> - a Twitter username</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst index = INSERT_REGISTRAR_INDEX;\nconst fields = [INSERT_FIELDS];\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.setFields(index, fields);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> setIdentity(info) - sets the identity for the caller ParametersPolkadot.js API Example <ul> <li><code>info</code> - the identity information. The identity information can include any of the following optional fields:<ul> <li><code>display</code> - a display name</li> <li><code>legal</code> - a legal name</li> <li><code>web</code> - a website</li> <li><code>riot</code> - a Riot username</li> <li><code>email</code> - an email address</li> <li><code>ppgFingerprint</code> - a PPG fingerprint</li> <li><code>image</code> - an image</li> <li><code>twitter</code> - a Twitter username</li> <li><code>additional</code> - an array that contains custom fields for additional information. Each additional item is represented as an array that contains two objects: one for the field name and one for the field value. You can define the additional field names and values in the following formats:<ul> <li><code>None</code> - no additional information should be used</li> <li><code>Raw</code> - a raw value using hex or ascii</li> <li><code>BlakeTwo256</code> - a BLAKE2-256 hash value</li> <li><code>Sha256</code> - a SHA-256 value</li> <li><code>Keccak256</code> - a Keccak-256 value</li> <li><code>ShaThree256</code> - a SHA3-256 value</li> </ul> </li> </ul> </li> </ul> <p>When setting an identity, a deposit is required. If setting additional fields, an additional deposit will be required per each additional field. For more information, please refer to the Manage an Identity documentation.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\n/*\n        Add as many or as few fields as you would like\n        */\nconst info = {\n  display: 'INSERT_DISPLAY_NAME',\n  legal: 'INSERT_LEGAL_NAME',\n  additional: [[{ Raw: 'Discord' }, { Raw: 'INSERT_DISCORD_USERNAME' }]],\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.setIdentity(info);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> setSubs(subs) - sets the sub-accounts for the caller. This function is not callable via a <code>NonTransfer</code> proxy. You can sign the transaction directly or use a different proxy type (<code>Any</code>, <code>IdentityJudgement</code>, etc.) ParametersPolkadot.js API Example <ul> <li><code>subs</code> - an array that defines the sub-accounts. Each sub-account is represented as an array itself, with the address of the sub-account as the zero index and the name as the first index. The name is an object that can be defined in the following formats:<ul> <li><code>None</code> - no additional information should be used</li> <li><code>Raw</code> - a raw value using hex or ascii</li> <li><code>BlakeTwo256</code> - a BLAKE2-256 hash value</li> <li><code>Sha256</code> - a SHA-256 value</li> <li><code>Keccak256</code> - a Keccak-256 value</li> <li><code>ShaThree256</code> - a SHA3-256 value</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst subs = [\n  [INSERT_ACCOUNT, { Raw: 'INSERT_SUB_ACCOUNT_NAME' }],\n  [INSERT_ACCOUNT, { None: null }],\n];\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.identity.setSubs(subs);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/account/identity/#storage-methods","title":"Storage Methods","text":"<p>The Identity Pallet includes the following read-only storage methods to obtain chain state data:</p> authorityOf(account) \u2013 returns authority properties for a given account ParametersReturnsPolkadot.js API Example <ul> <li><code>account</code> \u2013 the 20-byte account ID (<code>AccountId20</code>) you want to inspect.</li> </ul> <p>An <code>Option&lt;PalletIdentityAuthorityProperties&gt;</code></p> <p>If the supplied account is not a username-granting authority, the call returns <code>null</code>.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Connect to Moonbase\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-rpc.dwellir.com'),\n  });\n\n  // --- OPTION 1: Check a single account ----------------------\n  // const account = '0x1234...';  // AccountId20 as hex\n  // const infoOpt = await api.query.identity.authorityOf(account);\n  // console.log(infoOpt.isSome ? infoOpt.unwrap().toHuman() : 'Not an authority');\n\n  // --- OPTION 2: List *all* registered authorities -----------\n  const entries = await api.query.identity.authorityOf.entries();\n\n  if (entries.length === 0) {\n    console.log('No authority accounts are registered.');\n  } else {\n    console.log(`Found ${entries.length} authority account(s):\\n`);\n    for (const [storageKey, optProps] of entries) {\n      if (optProps.isSome) {\n        const account = storageKey.args[0].toString();\n        const { allowAutoClaim, deposit, provider } = optProps.unwrap();\n\n        console.log(`\u2022 ${account}`);\n        console.log(`    allowAutoClaim : ${allowAutoClaim.toString()}`);\n        console.log(`    deposit        : ${deposit.toString()}`);\n        console.log(`    provider       : ${provider.toString()}\\n`);\n      }\n    }\n  }\n\n  await api.disconnect();\n};\n\nmain().catch(console.error);\n</code></pre> identityOf(account) - returns identity information for a given account ParametersReturnsPolkadot.js API Example <ul> <li><code>account</code> - the account to get identity information for</li> </ul> <p>Identity information for the given account, including judgments (if the account has requested a judgment from a registrar), the deposit is held for the identity and the identity information. If the account does not have an identity set, <code>null</code> is returned.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n{\n  judgements: [],\n  deposit: '0x00000000000000000e53d254821d0000',\n  info: {\n    additional: [ [Array] ],\n    display: { raw: '0x416c697468' },\n    legal: { none: null },\n    web: { none: null },\n    riot: { none: null },\n    email: { raw: '0x616c69746840616c6974682e636f6d' },\n    pgpFingerprint: null,\n    image: { none: null },\n    twitter: { none: null }\n  }\n}\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\n// Helper function to decode hex to string\nconst hexToString = (hex) =&gt; {\n  // Remove '0x' prefix if present\n  const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;\n  // Convert hex to string\n  const str = Buffer.from(cleanHex, 'hex').toString('utf8');\n  return str;\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    const account = 'INSERT_ACCOUNT';\n    const identity = await api.query.identity.identityOf(account);\n\n    console.log('Raw identity response:', identity.toString());\n\n    if (identity) {\n      // Parse the raw response\n      const rawResponse = JSON.parse(identity.toString());\n\n      if (rawResponse[0]) {\n        const formattedIdentity = {\n          judgements: rawResponse[0].judgements,\n          deposit: rawResponse[0].deposit,\n          info: {\n            additional: rawResponse[0].info.additional,\n            display: rawResponse[0].info.display.raw\n              ? hexToString(rawResponse[0].info.display.raw)\n              : null,\n            legal: rawResponse[0].info.legal,\n            web: rawResponse[0].info.web,\n            riot: rawResponse[0].info.riot,\n            email: rawResponse[0].info.email,\n            pgpFingerprint: rawResponse[0].info.pgpFingerprint,\n            image: rawResponse[0].info.image,\n            twitter: rawResponse[0].info.twitter,\n          },\n        };\n\n        console.log(\n          'Formatted Identity:',\n          JSON.stringify(formattedIdentity, null, 2)\n        );\n      } else {\n        console.log('No identity data found in the response');\n      }\n    } else {\n      console.log('No identity found for this account');\n    }\n  } catch (error) {\n    console.error('Error querying identity:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> palletVersion() - returns the current pallet version ParametersReturnsPolkadot.js API Example <p>None</p> <p>The version of the pallet, e.g. <code>1</code></p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Create the API instance\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Query the identity pallet version\n  const version = await api.query.identity.palletVersion();\n\n  // Log the version to console\n  console.log('Identity Pallet Version:', version.toString());\n\n  // Disconnect from the API\n  await api.disconnect();\n};\n\nmain().catch(console.error);\n</code></pre> pendingUsernames(username) - returns information for a pending username ParametersReturnsPolkadot.js API Example <ul> <li><code>username</code> \u2013 the username to query.   Pass it as a <code>Bytes</code> value (hex-encoded or plain ASCII).</li> </ul> <p>An <code>Option</code> that is:</p> <ul> <li><code>null</code> \u2013 if the username is not pending, or  </li> <li><code>(AccountId20, u32, PalletIdentityProvider)</code> \u2013 when pending, where  <ul> <li><code>AccountId20</code> is the account that has been offered the username  </li> <li><code>u32</code> is the block number deadline by which the account must accept it  </li> <li><code>PalletIdentityProvider</code> is the authority that issued the username</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Connect to a Moonbase RPC endpoint\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-rpc.dwellir.com'),\n  });\n\n  // Fetch *all* [StorageKey, Option&lt;(AccountId20, u32, PalletIdentityProvider)&gt;] pairs\n  const entries = await api.query.identity.pendingUsernames.entries();\n\n  if (entries.length === 0) {\n    console.log('There are no pending usernames right now.');\n  } else {\n    console.log(`Found ${entries.length} pending username(s):\\n`);\n    for (const [storageKey, optValue] of entries) {\n      if (optValue.isSome) {\n        const [account, deadline, provider] = optValue.unwrap();\n\n        // The username itself is part of the storage key after the 32-byte hash prefix\n        // api.registry.createType('Bytes', rawBytes) makes it human-readable\n        const raw = storageKey.args[0];               // Bytes\n        const username = api.registry.createType('Bytes', raw).toUtf8();\n\n        console.log(`\u2022 ${username}`);\n        console.log(`    owner   : ${account.toString()}`);\n        console.log(`    expires : block ${deadline.toNumber()}`);\n        console.log(`    provider: ${provider.toString()}\\n`);\n      }\n    }\n  }\n\n  await api.disconnect();\n};\n\nmain().catch(console.error);\n</code></pre> registrars() - returns the set of registrars ParametersReturnsPolkadot.js API Example <p>None</p> <p>The set of registrators as a vector</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Create the API instance\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Query the registrars\n  const registrars = await api.query.identity.registrars();\n\n  // Format and log the registrars data\n  const formattedRegistrars = registrars\n    .map((reg) =&gt; {\n      if (!reg.isSome) return null;\n      const { account, fee, fields } = reg.unwrap();\n      return {\n        account: account.toString(),\n        fee: fee.toHuman(),\n        fields: fields.toNumber(),\n      };\n    })\n    .filter((reg) =&gt; reg !== null);\n\n  console.log('Registrars:', JSON.stringify(formattedRegistrars, null, 2));\n\n  // Disconnect from the API\n  await api.disconnect();\n};\n\nmain().catch(console.error);\n</code></pre> subsOf(AccountId20) - returns the sub-identities for all accounts or a given account ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> the account to check the sub-identities for</li> </ul> <p>The sub-identities, if any.</p> <pre><code>Raw subs response: [0,[]]\n    Formatted Subs: {\n      \"deposit\": \"0\",\n      \"subAccounts\": []\n    }\n    Number of sub-accounts: 0\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    const account = 'INSERT_ACCOUNT';\n    const subs = await api.query.identity.subsOf(account);\n\n    // Log raw response for debugging\n    console.log('Raw subs response:', subs.toString());\n\n    if (subs) {\n      // The response includes a tuple of [deposit, accounts]\n      const [deposit, subAccounts] = subs;\n\n      const formattedSubs = {\n        deposit: deposit.toHuman(),\n        subAccounts: subAccounts.toHuman(),\n      };\n\n      console.log('Formatted Subs:', JSON.stringify(formattedSubs, null, 2));\n      console.log('Number of sub accounts:', subAccounts.length);\n    } else {\n      console.log('No sub identities found for this account');\n    }\n  } catch (error) {\n    console.error('Error querying sub identities:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> superOf(AccountId20) - returns the super identity of all sub-accounts or for a given sub-account ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> - the account to check the super identities of</li> </ul> <p>The super identities, if any.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    const account = 'INSERT_ACCOUNT';\n    const superOf = await api.query.identity.superOf(account);\n\n    // Log raw response for debugging\n    console.log('Raw superOf response:', superOf.toString());\n\n    if (superOf.isSome) {\n      // The response includes a tuple of [parentAccount, dataName]\n      const [parentAccount, dataName] = superOf.unwrap();\n\n      const formattedSuper = {\n        parentAccount: parentAccount.toString(),\n        dataName: dataName.toHuman(),\n      };\n\n      console.log(\n        'Formatted Super Identity:',\n        JSON.stringify(formattedSuper, null, 2)\n      );\n    } else {\n      console.log('This account is not a sub-identity of any other account');\n    }\n  } catch (error) {\n    console.error('Error querying super identity:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> unbindingUsernames(username) \u2013 returns the block height at which a username being revoked will be released ParametersReturnsPolkadot.js API Example <ul> <li><code>username</code> \u2013 the username to inspect, supplied as <code>Bytes</code> (plain ASCII or hex).</li> </ul> <p>An <code>Option&lt;u32&gt;</code>: it is <code>null</code> when the username is not in the unbinding process; otherwise it contains the block number after which the username becomes free to claim again.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Connect to Moonbase\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-rpc.dwellir.com'),\n  });\n\n  // Fetch every (StorageKey, Option&lt;u32&gt;) pair\n  const entries = await api.query.identity.unbindingUsernames.entries();\n\n  if (entries.length === 0) {\n    console.log('There are no usernames in the unbinding process.');\n  } else {\n    console.log(`Found ${entries.length} unbinding username(s):\\n`);\n    for (const [storageKey, optBlock] of entries) {\n      if (optBlock.isSome) {\n        // The username itself is the single argument encoded in the storage key\n        const rawUsername = storageKey.args[0];\n        const username = api.registry.createType('Bytes', rawUsername).toUtf8();\n\n        const releaseBlock = optBlock.unwrap().toNumber();\n        console.log(`${username} \u2192 releases at block ${releaseBlock}`);\n      }\n    }\n  }\n\n  await api.disconnect();\n};\n\nmain().catch(console.error);\n</code></pre> usernameInfoOf(username) \u2013 returns information for a given username ParametersReturnsPolkadot.js API Example <ul> <li><code>username</code> \u2013 the username to look up.   Supply it as a <code>Bytes</code> value (plain ASCII or hex).</li> </ul> <p>An <code>AccountId20</code> of the Account currently bound to the username and a provider value, i.e., the authority that issued the username.</p> <p>If the username is unregistered, the call returns <code>null</code>.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Connect to Moonbase-Alpha\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-rpc.dwellir.com'),\n  });\n\n  // Username to query (ASCII automatically wrapped as Bytes)\n  const username = api.registry.createType('Bytes', 'alice');\n\n  // Fetch username information\n  const infoOpt = await api.query.identity.usernameInfoOf(username);\n\n  if (infoOpt.isSome) {\n    const { owner, provider } = infoOpt.unwrap();\n\n    console.log(`Username          : ${username.toUtf8()}`);\n    console.log(`  Owner account   : ${owner.toString()}`);\n    console.log(`  Issued by       : ${provider.toString()}`);\n  } else {\n    console.log('Username is not registered.');\n  }\n\n  await api.disconnect();\n};\n\nmain().catch(console.error);\n</code></pre> usernameOf(account) \u2013 returns the primary username bound to an account ParametersReturnsPolkadot.js API Example <ul> <li><code>account</code> \u2013 the <code>AccountId20</code> you want to query.</li> </ul> <p>Returns an <code>Option&lt;Bytes&gt;</code>: it is null when the account has no primary username; otherwise, it contains a Bytes value with the UTF-8 (or hex-encoded) string of the account\u2019s primary username.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Connect to Moonbase\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-rpc.dwellir.com'),\n  });\n\n  // Replace with any AccountId20 you wish to inspect\n  const account = 'INSERT_ACCOUNT';\n\n  // Query the storage item\n  const usernameOpt = await api.query.identity.usernameOf(account);\n\n  if (usernameOpt.isSome) {\n    // Convert Bytes \u2192 UTF-8 for readability\n    const username = usernameOpt.unwrap().toUtf8();\n    console.log(`Primary username for ${account}: ${username}`);\n  } else {\n    console.log(`Account ${account} has no primary username set.`);\n  }\n\n  await api.disconnect();\n};\n\nmain().catch(console.error);\n</code></pre>"},{"location":"builders/substrate/interfaces/account/identity/#constants","title":"Pallet Constants","text":"<p>The Identity Pallet includes the following read-only functions to obtain pallet constants:</p> basicDeposit() - returns the amount held on deposit for a registered identity ParametersPolkadot.js API ExampleExample Response <p>None</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Query the basicDeposit constant\n    const basicDeposit = api.consts.identity.basicDeposit;\n\n    // Log raw response for debugging\n    console.log('Raw basicDeposit response:', basicDeposit.toString());\n\n    // Format the deposit amount\n    console.log('Basic Deposit (formatted):', basicDeposit.toHuman());\n  } catch (error) {\n    console.error('Error querying basic deposit:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Raw basicDeposit response: 1025800000000000000\nBasic Deposit (formatted): 1,025,800,000,000,000,000\n</code></pre> byteDeposit() - returns the amount held on deposit per additional bytes of data for a registered identity ParametersPolkadot.js API ExampleExample Response <p>None</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Query the byteDeposit constant\n    const byteDeposit = api.consts.identity.byteDeposit;\n\n    // Log raw response for debugging\n    console.log('Raw byteDeposit response:', byteDeposit.toString());\n\n    // Format the deposit amount\n    console.log('Byte Deposit (formatted):', byteDeposit.toHuman());\n  } catch (error) {\n    console.error('Error querying byte deposit:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Raw byteDeposit response: 100000000000000\nByte Deposit (formatted): 100,000,000,000,000\n</code></pre> maxRegistrars() - returns the maximum number of registrars allowed in the system ParametersReturnsPolkadot.js API Example <p>None</p> <ul> <li><code>u32</code> - Maximum number of registrars allowed</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Query the maxRegistrars constant\n    const maxRegistrars = api.consts.identity.maxRegistrars;\n\n    // Get the number as a plain integer\n    console.log('Max Registrars (number):', maxRegistrars.toNumber());\n  } catch (error) {\n    console.error('Error querying max registrars:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> maxSubAccounts() - returns the maximum number of sub-accounts allowed per account ParametersReturnsPolkadot.js API Example <p>None</p> <ul> <li><code>u32</code> - Maximum number of sub-accounts allowed per identity</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    const maxSubAccounts = api.consts.identity.maxSubAccounts;\n    console.log('Max SubAccounts (number):', maxSubAccounts.toNumber());\n  } catch (error) {\n    console.error('Error querying max subaccounts:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> subAccountDeposit() - returns the amount held on deposit for a registered sub-account ParametersReturnsPolkadot.js API Example <p>None</p> <ul> <li><code>Balance</code> - Amount of currency held on deposit for a sub-account</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    const subAccountDeposit = api.consts.identity.subAccountDeposit;\n    console.log('SubAccount Deposit:', subAccountDeposit.toHuman());\n  } catch (error) {\n    console.error('Error querying subaccount deposit:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> pendingUsernameExpiration() - returns the time period for which a username remains pending ParametersReturnsPolkadot.js API Example <p>None</p> <ul> <li><code>BlockNumber</code> - Number of blocks before a pending username expires</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Query the pendingUsernameExpiration constant from identity pallet\n    const pendingExpiration = api.consts.identity.pendingUsernameExpiration;\n    console.log('Pending Username Expiration:', pendingExpiration.toHuman());\n  } catch (error) {\n    console.error('Error querying pending username expiration:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> maxSuffixLength() - returns the maximum length allowed for a username suffix ParametersReturnsPolkadot.js API Example <p>None</p> <ul> <li><code>u32</code> - Maximum number of characters allowed in a username suffix</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    const maxSuffixLength = api.consts.identity.maxSuffixLength;\n    console.log('Max Suffix Length:', maxSuffixLength.toHuman());\n  } catch (error) {\n    console.error('Error querying max suffix length:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> maxUsernameLength() - returns the maximum length allowed for a username ParametersReturnsPolkadot.js API Example <p>None</p> <ul> <li><code>u32</code> - Maximum number of characters allowed in a username</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    const maxUsernameLength = api.consts.identity.maxUsernameLength;\n    console.log('Max Username Length:', maxUsernameLength.toHuman());\n  } catch (error) {\n    console.error('Error querying max username length:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"builders/substrate/interfaces/account/multisig/","title":"The Multisig Pallet","text":""},{"location":"builders/substrate/interfaces/account/multisig/#introduction","title":"Introduction","text":"<p>Multisig wallets are a special type of wallet that requires multiple signatures in order to execute transactions, as the name implies. A multisig has a set of signers and defines a threshold for the number of signatures required to approve a transaction. This type of wallet provides an additional layer of security and decentralization.</p> <p>The Multisig Pallet on Moonbeam taps into Substrate functionality to allow for the ability to natively approve and dispatch calls from a multisig. With the Multisig Pallet, multiple signers, also referred to as signatories in Substrate, approve and dispatch transactions from an origin that is derivable deterministically from the set of signers' account IDs and the threshold for the number of accounts from the set that must approve calls before they can be dispatched.</p> <p>This page will provide an overview of the extrinsics, storage methods, and getters for the pallet constants available in the Multisig Pallet on Moonbeam. It will also include a brief demo on how to create a multisig account and send a transaction that requires two of three signers to approve and dispatch the transaction.</p>"},{"location":"builders/substrate/interfaces/account/multisig/#multisig-pallet-interface","title":"Multisig Pallet Interface","text":""},{"location":"builders/substrate/interfaces/account/multisig/#extrinsics","title":"Extrinsics","text":"<p>The Multisig Pallet provides the following extrinsics (functions):</p> asMulti(threshold, otherSignatories, maybeTimepoint, call, maxWeight) - approves and if possible dispatches a call from a composite origin formed from a number of signed origins (a multisig). If the call has been approved by enough of the other signatories, the call will be dispatched. The <code>depositBase</code> will be reserved if this is the first approval plus the <code>threshold</code> times the <code>depositFactor</code>. The total reserved amount will be returned once the call is dispatched or cancelled. This function should be used if it is the final approval, otherwise you'll want to use <code>approveAsMulti</code> instead since it only requires a hash of the call ParametersPolkadot.js API ExampleExample Response <ul> <li><code>threshold</code> - The total number of approvals required for the dispatch to be executed</li> <li><code>otherSignatories</code> - The accounts (other than the sender) who can approve the dispatch</li> <li><code>maybeTimepoint</code> - The timepoint (block number and transaction index) of the first approval transaction. Must be <code>None</code> if this is the first approval</li> <li><code>call</code> - The actual call to be executed once approved</li> <li><code>maxWeight</code> - The maximum weight allowed for the dispatch</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\nimport { bnToHex, stringToHex } from '@polkadot/util';\n\nconst main = async () =&gt; {\n  // Initialize API connection\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Configuration\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const MULTISIG_ADDRESS = 'INSERT_ADDRESS_MULTISIG';\n\n    // Multisig parameters\n    const threshold = 2;\n    const otherSignatories = ['INSERT_SIGNER_1', 'INSERT_SIGNER_2'].sort(); // Addresses must be sorted\n\n    // Create an EVM transaction\n    const TARGET_ADDRESS = 'INSERT_DESTINATION_ADDRESS';\n    const VALUE = '1000000000000000000'; // 1 TOKEN in Wei\n\n    // Construct the EVM call data\n    const call = api.tx.evm.call(\n      MULTISIG_ADDRESS, // source address\n      TARGET_ADDRESS, // target address\n      VALUE, // value in Wei\n      '0x', // input data (empty for simple transfer)\n      '2100000', // gas limit\n      '1000000000', // max fee per gas (1 GWei)\n      '1000000000', // max priority fee per gas (1 GWei)\n      null, // nonce (optional)\n      [] // access list (optional)\n    );\n\n    // Weight limits for the dispatch\n    const maxWeight = {\n      refTime: '806342022',\n      proofSize: '211174',\n    };\n\n    const account = keyring.addFromUri(PRIVATE_KEY);\n\n    // Check for existing timepoint\n    const callHash = call.method.hash.toHex();\n    const multisigs = await api.query.multisig.multisigs(\n      MULTISIG_ADDRESS,\n      callHash\n    );\n\n    let maybeTimepoint = null;\n    if (multisigs.isSome) {\n      const multisigInfo = multisigs.unwrap();\n      maybeTimepoint = {\n        height: multisigInfo.when.height.toNumber(),\n        index: multisigInfo.when.index.toNumber(),\n      };\n    }\n\n    console.log('Validation checks:');\n    console.log('Account address:', account.address);\n    console.log('Multisig address:', MULTISIG_ADDRESS);\n    console.log('Other signatories:', otherSignatories);\n    console.log('Threshold:', threshold);\n    console.log('Call hash:', callHash);\n    console.log('Max weight:', maxWeight);\n    console.log('Timepoint:', maybeTimepoint);\n\n    // Create and send the asMulti transaction\n    const tx = api.tx.multisig.asMulti(\n      threshold,\n      otherSignatories,\n      maybeTimepoint,\n      call,\n      maxWeight\n    );\n\n    // Sign and send the transaction\n    await tx.signAndSend(account, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n\n            console.error('Failure reason:', errorInfo);\n          }\n        });\n\n        // Check for specific multisig events\n        const multisigEvent = events.find(\n          ({ event }) =&gt;\n            event.section === 'multisig' &amp;&amp;\n            (event.method === 'MultisigExecuted' ||\n              event.method === 'NewMultisig')\n        );\n\n        if (multisigEvent) {\n          console.log('Multisig event:', multisigEvent.event.method);\n        }\n\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in multisig execution:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Validation checks:\nAccount address: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e\nMultisig address: 0x2c6a9d09E7C01f3D4154000193BDDcC597523221\nOther signatories: [\n  '0x253b05C595222a1e3E7Bcf1611cA1307194a030F',\n  '0x4B718e1CCeb83bfE87FD5f79cb98FFc2d4600C7E'\n]\nThreshold: 2\nCall hash: 0xdbbc67f35ca518976f4d392fb32745786e6b58fc526fab0dafb6eda44d9850a3\nMax weight: { refTime: '806342022', proofSize: '211174' }\nTimepoint: null\nTransaction included in block hash: 0x0050f1b137e5814dc4eb16390d10287d9234de1d5827dd64ba85c878d4c53849\n    balances.Withdraw: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",4858229333763]\n    balances.Reserved: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",\"0x00000000000000000e1107d468560000\"]\n    multisig.NewMultisig: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",\"0x2c6a9d09E7C01f3D4154000193BDDcC597523221\",\"0xdbbc67f35ca518976f4d392fb32745786e6b58fc526fab0dafb6eda44d9850a3\"]\n    balances.Deposit: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",1222550823750]\n    balances.Deposit: [\"0x6d6F646c70632f74727372790000000000000000\",727135702003]\n    transactionPayment.TransactionFeePaid: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3635678510013,0]\n    system.ExtrinsicSuccess: [{\"weight\":{\"refTime\":404917324,\"proofSize\":5587},\"class\":\"Normal\",\"paysFee\":\"Yes\"}]\nMultisig event: NewMultisig\n</code></pre> approveAsMulti(threshold, otherSignatories, maybeTimepoint, callHash, maxWeight) - approves a call from a composite origin. For the final approval, you'll want to use <code>asMulti</code> instead ParametersPolkadot.js API ExampleExample Response <ul> <li><code>threshold</code> - The total number of approvals required for the dispatch to be executed</li> <li><code>otherSignatories</code> - The accounts (other than the sender) who can approve the dispatch</li> <li><code>maybeTimepoint</code> - The timepoint (block number and transaction index) of the first approval transaction. Must be <code>None</code> if this is the first approval</li> <li><code>callHash</code> - The hash of the call to be executed</li> <li><code>maxWeight</code> - The maximum weight allowed for the dispatch</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n\n    const threshold = 2;\n    const otherSignatories = ['INSERT_SIGNER_1', 'INSERT_SIGNER_2'].sort();\n\n    const callHash = 'INSERT_CALL_HASH';\n\n    const maxWeight = {\n      refTime: '806342022',\n      proofSize: '211174',\n    };\n\n    // Query the multisig address instead of the signer's address\n    const MULTISIG_ADDRESS = 'INSERT_ADDRESS_MULTISIG';\n    const multisigs = await api.query.multisig.multisigs(\n      MULTISIG_ADDRESS,\n      callHash\n    );\n\n    if (!multisigs.isSome) {\n      console.error('No existing multisig found for this call hash');\n      process.exit(1);\n    }\n\n    const multisigInfo = multisigs.unwrap();\n    const timepoint = {\n      height: multisigInfo.when.height.toNumber(),\n      index: multisigInfo.when.index.toNumber(),\n    };\n\n    const account = keyring.addFromUri(PRIVATE_KEY);\n\n    console.log('Found timepoint:', timepoint);\n    console.log('Validation checks:');\n    console.log('Account address:', account.address);\n    console.log('Multisig address:', MULTISIG_ADDRESS);\n    console.log('Other signatories:', otherSignatories);\n    console.log('Threshold:', threshold);\n    console.log('Call hash:', callHash);\n    console.log('Max weight:', maxWeight);\n    console.log('Timepoint:', timepoint);\n\n    const tx = api.tx.multisig.approveAsMulti(\n      threshold,\n      otherSignatories,\n      timepoint,\n      callHash,\n      maxWeight\n    );\n\n    await tx.signAndSend(account, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n\n            console.error('Failure reason:', errorInfo);\n          }\n        });\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in multisig approval:', error);\n    process.exit(1);\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Found timepoint: { height: 9174086, index: 5 }\nValidation checks:\nAccount address: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e\nMultisig address: 0x2c6a9d09E7C01f3D4154000193BDDcC597523221\nOther signatories: [\n  '0x253b05C595222a1e3E7Bcf1611cA1307194a030F',\n  '0x4B718e1CCeb83bfE87FD5f79cb98FFc2d4600C7E'\n]\nThreshold: 2\nCall hash: 0xa2902805948bdd92fcaf661965215efd6a5980d0092c065e7470859c1b37b6a9\nMax weight: { refTime: '806342022', proofSize: '211174' }\nTimepoint: { height: 9174086, index: 5 }\nTransaction included in block hash: 0xb7b0f712dc7aa3d471e1db89e0d182b59e1febf8bb1df73a03f36417fe19b506\n    balances.Withdraw: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",4512391685922]\n    multisig.MultisigApproval: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",{\"height\":9174086,\"index\":5},\"0x2c6a9d09E7C01f3D4154000193BDDcC597523221\",\"0xa2902805948bdd92fcaf661965215efd6a5980d0092c065e7470859c1b37b6a9\"]\n    balances.Deposit: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",1025179732500]\n    balances.Deposit: [\"0x6d6F646c70632f74727372790000000000000000\",697442390685]\n    transactionPayment.TransactionFeePaid: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3487211953422,0]\n    system.ExtrinsicSuccess: [{\"weight\":{\"refTime\":389364247,\"proofSize\":5587},\"class\":\"Normal\",\"paysFee\":\"Yes\"}]\n</code></pre> asMultiThreshold(otherSignatories, call) - immediately dispatches a multisig call using a single approval from the caller ParametersPolkadot.js API ExampleExample Response <ul> <li><code>otherSignatories</code> - The accounts (other than the sender) who can approve the dispatch</li> <li><code>call</code> - The actual call to be executed once approved</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n\n    const threshold = 2;\n    const otherSignatories = ['INSERT_SIGNER_1', 'INSERT_SIGNER_2'].sort();\n\n    const callHash = 'INSERT_CALL_HASH';\n\n    const maxWeight = {\n      refTime: '806342022',\n      proofSize: '211174',\n    };\n\n    const MULTISIG_ADDRESS = 'INSERT_ADDRESS_MULTISIG';\n    const multisigs = await api.query.multisig.multisigs(\n      MULTISIG_ADDRESS,\n      callHash\n    );\n\n    if (!multisigs.isSome) {\n      console.error('No existing multisig found for this call hash');\n      process.exit(1);\n    }\n\n    const multisigInfo = multisigs.unwrap();\n    const timepoint = {\n      height: multisigInfo.when.height.toNumber(),\n      index: multisigInfo.when.index.toNumber(),\n    };\n\n    const account = keyring.addFromUri(PRIVATE_KEY);\n\n    console.log('Found timepoint:', timepoint);\n    console.log('Validation checks:');\n    console.log('Account address:', account.address);\n    console.log('Multisig address:', MULTISIG_ADDRESS);\n    console.log('Other signatories:', otherSignatories);\n    console.log('Threshold:', threshold);\n    console.log('Call hash:', callHash);\n    console.log('Max weight:', maxWeight);\n    console.log('Timepoint:', timepoint);\n\n    const tx = api.tx.multisig.approveAsMulti(\n      threshold,\n      otherSignatories,\n      timepoint,\n      callHash,\n      maxWeight\n    );\n\n    await tx.signAndSend(account, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n\n            console.error('Failure reason:', errorInfo);\n          }\n        });\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in multisig approval:', error);\n    process.exit(1);\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Found timepoint: { height: 9174086, index: 5 }\nValidation checks:\nAccount address: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e\nMultisig address: 0x2c6a9d09E7C01f3D4154000193BDDcC597523221\nOther signatories: [\n  '0x253b05C595222a1e3E7Bcf1611cA1307194a030F',\n  '0x4B718e1CCeb83bfE87FD5f79cb98FFc2d4600C7E'\n]\nThreshold: 2\nCall hash: 0xa2902805948bdd92fcaf661965215efd6a5980d0092c065e7470859c1b37b6a9\nMax weight: { refTime: '806342022', proofSize: '211174' }\nTimepoint: { height: 9174086, index: 5 }\nTransaction included in block hash: 0xb7b0f712dc7aa3d471e1db89e0d182b59e1febf8bb1df73a03f36417fe19b506\n    balances.Withdraw: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",4512391685922]\n    multisig.MultisigApproval: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",{\"height\":9174086,\"index\":5},\"0x2c6a9d09E7C01f3D4154000193BDDcC597523221\",\"0xa2902805948bdd92fcaf661965215efd6a5980d0092c065e7470859c1b37b6a9\"]\n    balances.Deposit: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",1025179732500]\n    balances.Deposit: [\"0x6d6F646c70632f74727372790000000000000000\",697442390685]\n    transactionPayment.TransactionFeePaid: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3487211953422,0]\n    system.ExtrinsicSuccess: [{\"weight\":{\"refTime\":389364247,\"proofSize\":5587},\"class\":\"Normal\",\"paysFee\":\"Yes\"}]\n</code></pre> cancelAsMulti(threshold, otherSignatories, maybeTimepoint, callHash) - cancels a preexisting, ongoing call from a composite origin. Any reserved deposit will be returned upon successful cancellation ParametersPolkadot.js API ExampleExample Response <ul> <li><code>threshold</code> - The total number of approvals required for the dispatch to be executed</li> <li><code>otherSignatories</code> - The accounts (other than the sender) who can approve the dispatch</li> <li><code>maybeTimepoint</code> - The timepoint (block number and transaction index) of the first approval transaction. Must be <code>None</code> if this is the first approval</li> <li><code>callHash</code> - The hash of the call to be executed</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n\n    const threshold = 2;\n    const otherSignatories = ['INSERT_SIGNER_1', 'INSERT_SIGNER_2'].sort();\n\n    const callHash = 'INSERT_CALL_HASH';\n\n    // Query the multisig address for the timepoint\n    const MULTISIG_ADDRESS = 'INSERT_ADDRESS_MULTISIG';\n    const multisigs = await api.query.multisig.multisigs(\n      MULTISIG_ADDRESS,\n      callHash\n    );\n\n    if (!multisigs.isSome) {\n      console.error('No existing multisig found for this call hash');\n      process.exit(1);\n    }\n\n    const multisigInfo = multisigs.unwrap();\n    const timepoint = {\n      height: multisigInfo.when.height.toNumber(),\n      index: multisigInfo.when.index.toNumber(),\n    };\n\n    const account = keyring.addFromUri(PRIVATE_KEY);\n\n    console.log('Found timepoint:', timepoint);\n    console.log('Validation checks:');\n    console.log('Account address:', account.address);\n    console.log('Multisig address:', MULTISIG_ADDRESS);\n    console.log('Other signatories:', otherSignatories);\n    console.log('Threshold:', threshold);\n    console.log('Call hash:', callHash);\n    console.log('Timepoint:', timepoint);\n\n    const tx = api.tx.multisig.cancelAsMulti(\n      threshold,\n      otherSignatories,\n      timepoint,\n      callHash\n    );\n\n    await tx.signAndSend(account, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n\n            console.error('Failure reason:', errorInfo);\n          }\n        });\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in multisig cancellation:', error);\n    process.exit(1);\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Found timepoint: { height: 9174086, index: 5 }\nValidation checks:\nAccount address: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e\nMultisig address: 0x2c6a9d09E7C01f3D4154000193BDDcC597523221\nOther signatories: [\n  '0x253b05C595222a1e3E7Bcf1611cA1307194a030F',\n  '0x4B718e1CCeb83bfE87FD5f79cb98FFc2d4600C7E'\n]\nThreshold: 2\nCall hash: 0xa2902805948bdd92fcaf661965215efd6a5980d0092c065e7470859c1b37b6a9\nMax weight: { refTime: '806342022', proofSize: '211174' }\nTimepoint: { height: 9174086, index: 5 }\nTransaction included in block hash: 0xb7b0f712dc7aa3d471e1db89e0d182b59e1febf8bb1df73a03f36417fe19b506\n    balances.Withdraw: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",4512391685922]\n    multisig.MultisigApproval: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",{\"height\":9174086,\"index\":5},\"0x2c6a9d09E7C01f3D4154000193BDDcC597523221\",\"0xa2902805948bdd92fcaf661965215efd6a5980d0092c065e7470859c1b37b6a9\"]\n    balances.Deposit: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",1025179732500]\n    balances.Deposit: [\"0x6d6F646c70632f74727372790000000000000000\",697442390685]\n    transactionPayment.TransactionFeePaid: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3487211953422,0]\n    system.ExtrinsicSuccess: [{\"weight\":{\"refTime\":389364247,\"proofSize\":5587},\"class\":\"Normal\",\"paysFee\":\"Yes\"}]\n</code></pre>"},{"location":"builders/substrate/interfaces/account/multisig/#storage-methods","title":"Storage Methods","text":"<p>The Multisig Pallet includes the following read-only storage methods to obtain chain state data:</p> multisigs() - returns the set of open multisig operations for a given account. ParametersPolkadot.js API ExampleExample Response <ul> <li><code>account</code> - The address of the multisig</li> <li><code>callHash</code> - (Optional) The hash of the multisig call</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // The account to query multisigs for\n    const account = 'INSERT_ACCOUNT';\n\n    // Get all storage keys and values for this account's multisigs\n    const entries = await api.query.multisig.multisigs.entries(account);\n\n    if (entries.length === 0) {\n      console.log('No multisigs found for this account');\n    } else {\n      console.log(`Found ${entries.length} multisig(s):`);\n\n      entries.forEach(([key, value]) =&gt; {\n        // The key contains the call hash in its final 32 bytes\n        const callHash = key.args[1].toHex();\n        console.log('\\nCall Hash:', callHash);\n        console.log('Details:', value.unwrap().toHuman());\n      });\n    }\n  } catch (error) {\n    console.error('Error querying multisigs:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>[\n  [\n    [\n      0x2c6a9d09E7C01f3D4154000193BDDcC597523221\n      0xa2902805948bdd92fcaf661965215efd6a5980d0092c065e7470859c1b37b6a9\n    ]\n    {\n      when: {\n        height: 9,174,086\n        index: 5\n      }\n      deposit: 1,013,600,000,000,000,000\n      depositor: 0x253b05C595222a1e3E7Bcf1611cA1307194a030F\n      approvals: [\n        0x253b05C595222a1e3E7Bcf1611cA1307194a030F\n      ]\n    }\n  ]\n]\n</code></pre> palletVersion() - returns the current pallet version ParametersPolkadot.js API ExampleExample Response <p>None</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Create the API instance\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Query the identity pallet version\n  const version = await api.query.multisig.palletVersion();\n\n  // Log the version to console\n  console.log('Identity Pallet Version:', version.toString());\n\n  // Disconnect from the API\n  await api.disconnect();\n};\n\nmain().catch(console.error);\n</code></pre> <p><code>1</code></p>"},{"location":"builders/substrate/interfaces/account/multisig/#constants","title":"Pallet Constants","text":"<p>The Multisig Pallet includes the following read-only functions to obtain pallet constants:</p> depositBase() - returns the base amount of currency needed to reserve for creating a multisig execution or to store a dispatch call for later. This is held for an additional storage item whose key size is <code>32 + sizeof(AccountId)</code> bytes, which is <code>32 + 20</code> on Moonbeam, and whose value size is <code>4 + sizeof((BlockNumber, Balance, AccountId))</code> bytes, which is <code>4 + 4 + 16 +20</code> bytes on Moonbeam ParametersPolkadot.js API ExampleExample Response <p>None</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    const depositBase = api.consts.multisig.depositBase;\n    console.log('Multisig Deposit Base:', depositBase.toHuman());\n  } catch (error) {\n    console.error('Error querying deposit base:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Multisig Deposit Base: 1,009,600,000,000,000,000\n</code></pre> depositFactor() - returns the amount of currency needed per unit threshold when creating a multisig execution. This is held for adding 20 bytes more into a preexisting storage value ParametersPolkadot.js API ExampleExample Response <p>None</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    const depositFactor = api.consts.multisig.depositFactor;\n    console.log('Multisig Deposit Factor:', depositFactor.toHuman());\n  } catch (error) {\n    console.error('Error querying deposit factor:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Multisig Deposit Factor: 2,000,000,000,000,000\n</code></pre> maxSignatories() - returns the maximum amount of signatories allowed in the multisig ParametersPolkadot.js API ExampleExample Response <p>None</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    const maxSignatories = api.consts.multisig.maxSignatories;\n    console.log('Multisig Max Signatories:', maxSignatories.toHuman());\n  } catch (error) {\n    console.error('Error querying max signatories:', error);\n  } finally {\n    await api.disconnect();\n  }\n};\n\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Multisig Max Signatories: 100\n</code></pre>"},{"location":"builders/substrate/interfaces/account/multisig/#create-a-multisig-account","title":"How to Create a Multisig Account","text":"<p>You can easily create a multisig account from the Polkadot.js Apps interface. The easiest way to do so is from the Accounts page.</p> <p>To get started, go ahead and click on Multisig.</p> <p></p> <p>Next, you can take the following steps:</p> <ol> <li>Choose which accounts you want to add to the multisig. For this example, three accounts will be chosen: Alice, Bob, and Charlie</li> <li>Enter a number for threshold. This example will use <code>2</code></li> <li>Add a name for the multisig. This example uses <code>ABC</code> for Alice, Bob, and Charlie</li> <li>Click Create</li> </ol> <p></p> <p>Now, the ABC multisig account will appear under the multisig section on the Accounts page.</p> <p></p> <p>You can click on the colored icon next to the multisig account to copy the address and fund it with DEV tokens. You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet.</p>"},{"location":"builders/substrate/interfaces/account/multisig/#create-a-multisig-transaction","title":"How to Create a Multisig Transaction","text":"<p>Now that you've created a multisig account, you can create a multisig call from one of the accounts that make up the multisig. This example will create the call from Alice's account. As such, Alice will need to submit a deposit. The deposit is calculated as follows:</p> <pre><code>Deposit = depositBase + threshold * depositFactor\n</code></pre> <p>You can retrieve the <code>depositBase</code> and <code>depositFactor</code> using the getter functions for the Pallet Constants.</p> <p>Once the call is approved and dispatched or cancelled the deposit will be returned to Alice.</p> <p>Since there is a threshold of two for this multisig, at least Bob or Charlie will need to approve the call if not both of them. The last account to approve the call will also need to dispatch the call. Dispatching the call is done automatically when the <code>asMulti</code> function is used to approve the call.</p> <p>With the basics out of the way, you can begin to create a multisig call. For this example, you can create a call that will transfer 0.1 DEV from the ABC multisig account to Charlie's account. First, you'll need to get the encoded call data for the transfer. Go ahead and navigate to the Extrinsics page on Polkadot.js Apps and take the following steps:</p> <ol> <li>Make sure an account is selected. It doesn't have to be the ABC multisig account, as the selected account is not included in the encoded call data</li> <li>Select the balances pallet and the transfer extrinsic</li> <li>Set Charlie as the dest account</li> <li>Enter the amount to transfer, which is <code>0.1</code> DEV for this example</li> <li>Click the copy button next to the encoded call data</li> <li>Click the copy button next to the encoded call hash. Please note that you do not have to submit the extrinsic, you only need the encoded call data and the encoded call hash</li> </ol> <p></p> <p>Make sure you've copied and saved the encoded call data and the encoded call hash as you'll need them both to approve the multisig call later on in the tutorial. For this example, the encoded call data and hash are as follows:</p> Encoded call dataEncoded call hash <pre><code>0x0300798d4ba9baf0064ec19eb4f0a1a45785ae9d6dfc1300008a5d78456301\n</code></pre> <pre><code>0x76d1a0a8f6eb177dd7a561ef954e83893823fa5d77f576910f3fdc6cb4666dea\n</code></pre> <p>Next, you can create the multisig call by using the <code>asMulti</code> extrinsic, you'll take the following steps:</p> <ol> <li>Select the account you want to create the call with. For this example, Alice is used</li> <li>Select the multisig pallet and the asMulti extrinsic</li> <li>Set the threshold of the multisig to the same value as you initially set from the Accounts page, which should be <code>2</code></li> <li>Add the other accounts that are associated with the multisig: Bob and Charlie</li> <li>Since this is the first transaction to create the multisig call, make sure the include option slider is toggled off for the maybeTimepoint field. You would only enter this information for approvals that rely on knowing the timepoint at which the call was created</li> <li>Provide the call information for the balance transfer similarly to how you did it in the previous set of steps. Select the balances pallet and the transfer extrinsic</li> <li>Set the dest account to Charlie</li> <li>Set the value to <code>0.1</code> DEV tokens</li> <li>You can leave the refTime and proofSize fields set to <code>0</code></li> <li>Click Submit Transaction to create the multisig call</li> </ol> <p></p> <p>Now that you've created the multisig call, you can submit approval transactions from either Bob's or Charlie's account, or both. Remember, for the call to be approved and dispatched, you need to have at least two of three members of the multisig to approve it. Since Alice created the multisig call, that means she has already automatically approved it.</p> <p>You can easily approve the transactions through the Accounts page of Polkadot.js Apps. Next to your multisig account, you'll notice there is a multisig icon there that you can hover over. Once you hover over it, you'll be able to click on View pending approvals.</p> <p></p> <p>The pending call hashes pop-up will appear where you can follow these steps:</p> <ol> <li>Since you should only have one hash at this point, you can select it from this list. If you have multiple hashes, you can compare the hashes in the list with the encoded call hash you copied earlier on in this section</li> <li>The depositor should be automatically populated. For this example, it should be Alice</li> <li>For the approval type, you can choose to either approve or reject the call. For this example, you can select Approve this call hash</li> <li>Choose the account you want to approve the transaction from. This example uses Bob's account</li> <li>Click Approve to submit the approval transaction. Under the hood, this uses the <code>approveAsMulti</code> extrinsic of the Multisig Pallet</li> </ol> <p></p> <p>So far, Alice and Bob have approved the multisig call, which means the threshold has been met. However, the call has not been dispatched yet since you have not yet submitted an executing approval. To do so, you'll take the same steps as above plus these additional steps:</p> <ol> <li>Select the account you want to approve the transaction from. This example uses Charlie's account</li> <li>Toggle the multisig message with call (for final approval) switch to on. Under the hood, this switches the extrinsic to <code>asMulti</code>, which automatically approves and dispatches the call if the threshold for approvals has been met as is the case at this point</li> <li>The call data for final approval field will appear. Enter the encoded call data that you copied earlier on in this section</li> <li>Click Approve to submit the approval, which will also dispatch the multisig call</li> </ol> <p></p> <p>Once the final transaction has been submitted, 0.1 DEV tokens will be transferred from the ABC multisig account to Charlie's account and the multisig deposit will be returned to Alice's account. And that's it! You've successfully created a multisig call, approved the call, and dispatched it.</p>"},{"location":"builders/substrate/interfaces/account/proxy/","title":"The Proxy Pallet","text":""},{"location":"builders/substrate/interfaces/account/proxy/#introduction","title":"Introduction","text":"<p>Proxy accounts can be set up to perform a limited number of actions on behalf of users and are useful for keeping the underlying accounts safe. They allow users to keep their primary account secured safely in cold storage while enabling the proxy to actively perform functions and participate in the network with the weight of the tokens in the primary account.</p> <p>Substrate's proxy pallet enables you to create proxy accounts, remove proxy accounts, make calls as a proxy account, and announce proxy transactions. To add and remove proxy accounts, you can use the proxy precompile: a Solidity interface that can be interacted through the Ethereum API. For more information on how to use this contract, please refer to the Proxy Precompile guide.</p> <p>This page will provide an overview of the extrinsics, storage methods, and getters for the pallet constants available in the proxy pallet.</p>"},{"location":"builders/substrate/interfaces/account/proxy/#proxy-pallet-interface","title":"Proxy Pallet Interface","text":""},{"location":"builders/substrate/interfaces/account/proxy/#extrinsics","title":"Extrinsics","text":"<p>The proxy pallet provides the following extrinsics (functions):</p> addProxy(delegate, proxyType, delay) - registers a proxy account for the sender that is able to make calls on the sender's behalf. If <code>delay</code> is set to a value greater than 0, the proxy account will have to announce a transaction and wait that value of blocks before attempting to execute it as a proxy. Emits a <code>ProxyAdded</code> event ParametersPolkadot.js API ExampleExample Response <ul> <li><code>delegate</code> - The account that will act as proxy (H160 format address, e.g., '0x123...'). This address will be able to submit transactions on behalf of the caller</li> <li><code>proxyType</code> - The permissions granted to the proxy account. Available options are:<ul> <li><code>Any</code>: Allows all transactions</li> <li><code>NonTransfer</code>: Allows all transactions except balance transfers</li> <li><code>Governance</code>: Allows governance-related transactions</li> <li><code>Staking</code>: Allows staking-related transactions</li> <li><code>CancelProxy</code>: Only allows canceling other proxies</li> <li><code>Balances</code>: Allows balance transfers</li> <li><code>AuthorMapping</code>: Allows author mapping transactions</li> <li><code>IdentityJudgement</code>: Allows providing identity judgements</li> </ul> </li> <li><code>delay</code> - Number of blocks that must pass after announcing a proxy transaction before it can be executed (u32). Set to <code>0</code> for immediate execution</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const account = keyring.addFromUri(PRIVATE_KEY);\n\n    // Use an existing account as proxy\n    const proxyAccount = 'INSERT_PROXY_ACCOUNT';\n\n    // Define proxy parameters\n    // Use the Staking variant from the ProxyType enum\n    const proxyType = { Staking: null };\n    const delay = 0; // No delay\n\n    console.log('Validation checks:');\n    console.log('Account address:', account.address);\n    console.log('Proxy account address:', proxyAccount);\n    console.log('Proxy type:', JSON.stringify(proxyType));\n    console.log('Delay:', delay);\n\n    // Create the addProxy transaction\n    const tx = api.tx.proxy.addProxy(proxyAccount, proxyType, delay);\n\n    // Sign and send the transaction\n    await tx.signAndSend(account, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful proxy addition\n          if (section === 'proxy' &amp;&amp; method === 'ProxyAdded') {\n            console.log('Proxy successfully added!');\n          }\n        });\n\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in adding proxy:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Validation checks:\nAccount address: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e\nProxy account address: 0x569BE8d8b04538318e1722f6e375FD381D2da865\nProxy type: {\"Staking\":null}\nDelay: 0\nTransaction included in block hash: 0xd9763b3eec3e50dfeec246f1537421a632ec5a3ab821a5e5e6b507c12930cd64\n    balances.Withdraw: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3431276154061]\n    balances.Reserved: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",2100000000000000]\n    proxy.ProxyAdded: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",\"0x569BE8d8b04538318e1722f6e375FD381D2da865\",\"Staking\",0]\nProxy successfully added!\n    balances.Deposit: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",0]\n    balances.Deposit: [\"0x6d6F646c70632f74727372790000000000000000\",686255230813]\n    transactionPayment.TransactionFeePaid: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3431276154061,0]\n    system.ExtrinsicSuccess: [{\"weight\":{\"refTime\":398219506,\"proofSize\":4310},\"class\":\"Normal\",\"paysFee\":\"Yes\"}]\n</code></pre> announce(real, callHash) - registers an announcement of a proxy transaction by proxy accounts that require a delay. Emits an <code>Announced</code> event ParametersPolkadot.js API ExampleExample Response <ul> <li><code>real</code> - The account being proxied (H160 format address, e.g., '0x123...'). This is the account on whose behalf the delayed proxy intends to execute a call</li> <li><code>callHash</code> - The hash of the call that the proxy intends to execute after the delay period (32-byte hex string, e.g., '0x570ff355...'). This hash is derived from the actual call data that will be executed later</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup accounts\n    const PROXY_PRIVATE_KEY = 'INSERT_PROXY_PRIVATE_KEY';\n    const proxyAccount = keyring.addFromUri(PROXY_PRIVATE_KEY);\n\n    // The real account that the proxy will act on behalf of\n    const realAccount = 'INSERT_REAL_ACCOUNT';\n\n    // Use the provided call hash\n    const callHash = 'INSERT_CALL_HASH';\n\n    console.log('Validation checks:');\n    console.log('Proxy account address:', proxyAccount.address);\n    console.log('Real account address:', realAccount);\n    console.log('Call hash:', callHash);\n\n    // Create the announce transaction\n    const tx = api.tx.proxy.announce(realAccount, callHash);\n\n    // Sign and send the transaction\n    await tx.signAndSend(proxyAccount, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful announcement\n          if (section === 'proxy' &amp;&amp; method === 'Announced') {\n            console.log('Proxy call successfully announced!');\n            console.log(\n              'You can execute the actual call after the delay period'\n            );\n          }\n        });\n\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in announcing proxy call:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Validation checks:\nProxy account address: 0x569BE8d8b04538318e1722f6e375FD381D2da865\nReal account address: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e\nCall hash: 0x570ff355e1471d3528cb4e2586bee7eafebc2efc89dd6f827188c69b15fff965\nTransaction included in block hash: 0xdb5b9bb961ce3153387d2131911de218c08b8b09d8a625f36271ad98b2abf567\nbalances.Withdraw: [\"0x569BE8d8b04538318e1722f6e375FD381D2da865\",3682233905542]\nbalances.Reserved: [\"0x569BE8d8b04538318e1722f6e375FD381D2da865\",\"0x00000000000000000df77377c5f40000\"]\nproxy.Announced: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",\"0x569BE8d8b04538318e1722f6e375FD381D2da865\",\"0x570ff355e1471d3528cb4e2586bee7eafebc2efc89dd6f827188c69b15fff965\"]\nProxy call successfully announced!\nYou can execute the actual call after the delay period\nbalances.Deposit: [\"0x569BE8d8b04538318e1722f6e375FD381D2da865\",0]\nbalances.Deposit: [\"0x6d6F646c70632f74727372790000000000000000\",736446781109]\ntransactionPayment.TransactionFeePaid: [\"0x569BE8d8b04538318e1722f6e375FD381D2da865\",3682233905542,0]\nsystem.ExtrinsicSuccess: [{\"weight\":{\"refTime\":577384531,\"proofSize\":5302},\"class\":\"Normal\",\"paysFee\":\"Yes\"}]\n</code></pre> proxy(real, forceProxyType, call) - makes a transaction as a proxy. Emits a <code>ProxyExecuted</code> event ParametersPolkadot.js API ExampleExample Response <ul> <li><code>real</code> - The account being proxied (H160 format address, e.g., '0x123...'). This is the account on whose behalf the proxy will execute the call</li> <li><code>forceProxyType</code> - The type of proxy right required to execute this call. Must match the proxy type that was specified when the proxy was added. Available options are:<ul> <li><code>Any</code>: Allows all transactions</li> <li><code>NonTransfer</code>: Allows all transactions except balance transfers</li> <li><code>Governance</code>: Allows governance-related transactions</li> <li><code>Staking</code>: Allows staking-related transactions</li> <li><code>CancelProxy</code>: Only allows canceling other proxies</li> <li><code>Balances</code>: Allows balance transfers</li> <li><code>AuthorMapping</code>: Allows author mapping transactions</li> <li><code>IdentityJudgement</code>: Allows providing identity judgements</li> </ul> </li> <li><code>call</code> - The actual call data to be executed by the proxy on behalf of the real account. This is the transaction that will be performed (e.g., a transfer, a stake, or any other valid runtime call)</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup proxy account from private key\n    const PROXY_PRIVATE_KEY = 'INSERT_PROXY_PRIVATE_KEY';\n    const proxyAccount = keyring.addFromUri(PROXY_PRIVATE_KEY);\n\n    // The real account that we're making the transaction for\n    const realAccount = 'INSERT_REAL_ACCOUNT';\n\n    // Destination account for the simple demo transfer\n    const destinationAccount = 'INSERT_DESTINATION_ADDRESS';\n\n    // Amount to transfer (1 DEV = 1e18 Wei)\n    const transferAmount = '1000000000000000000'; // 1 DEV\n\n    // Create the transfer call that we want to make via proxy\n    const transferCall = api.tx.balances.transferAllowDeath(\n      destinationAccount,\n      transferAmount\n    );\n\n    // Create the proxy transaction\n    // We'll specify Balances as the force proxy type since we're doing a transfer\n    const tx = api.tx.proxy.proxy(\n      realAccount,\n      { Any: null }, // forceProxyType\n      transferCall\n    );\n\n    console.log('Validation checks:');\n    console.log('Proxy account:', proxyAccount.address);\n    console.log('Real account:', realAccount);\n    console.log('Destination account:', destinationAccount);\n    console.log('Transfer amount:', transferAmount, 'Wei (1 DEV)');\n\n    // Sign and send the transaction\n    await tx.signAndSend(proxyAccount, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful transfer\n          if (section === 'balances' &amp;&amp; method === 'Transfer') {\n            console.log('\\nTransfer successfully executed via proxy!');\n            const [from, to, amount] = data;\n            console.log('From:', from.toString());\n            console.log('To:', to.toString());\n            console.log('Amount:', amount.toString());\n          }\n        });\n\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in proxy transaction:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Validation checks:\nProxy account: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e\nReal account: 0x569BE8d8b04538318e1722f6e375FD381D2da865\nDestination account: 0x8c9c5F11d162a69E979F2DB9047A862ecbcA23Cb\nTransfer amount: 1000000000000000000 Wei (1 DEV)\nForce proxy type: Balances\nTransaction included in block hash: 0xc347d714324e795c0e27ef574c8f924d7a52935314044cf2e2a395bc32ef5070\n    balances.Withdraw: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3817444390449]\n    balances.Transfer: [\"0x569BE8d8b04538318e1722f6e375FD381D2da865\",\"0x8c9c5F11d162a69E979F2DB9047A862ecbcA23Cb\",\"0x00000000000000000de0b6b3a7640000\"]\n\nTransfer successfully executed via proxy!\nFrom: 0x569BE8d8b04538318e1722f6e375FD381D2da865\nTo: 0x8c9c5F11d162a69E979F2DB9047A862ecbcA23Cb\nAmount: 1000000000000000000\n    proxy.ProxyExecuted: [{\"ok\":null}]\n    balances.Deposit: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",0]\n    balances.Deposit: [\"0x6d6F646c70632f74727372790000000000000000\",763488878090]\n    transactionPayment.TransactionFeePaid: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3817444390449,0]\n    system.ExtrinsicSuccess: [{\"weight\":{\"refTime\":684752866,\"proofSize\":8691},\"class\":\"Normal\",\"paysFee\":\"Yes\"}]\n</code></pre> proxyAnnounced(delegate, real, forceProxyType, call) - makes a transaction as a proxy and removes previous corresponding announcements. Emits a <code>ProxyExecuted</code> event ParametersPolkadot.js API ExampleExample Response <ul> <li><code>delegate</code> - The account that previously made the announcement (H160 format address, e.g., '0x123...'). This must match the proxy account that called the announce function</li> <li><code>real</code> - The account being proxied (H160 format address, e.g., '0x123...'). This is the account on whose behalf the proxy will execute the call</li> <li><code>forceProxyType</code> - The type of proxy right required to execute this call. Must match the proxy type that was specified when the proxy was added. Available options are:<ul> <li><code>Any</code>: Allows all transactions</li> <li><code>NonTransfer</code>: Allows all transactions except balance transfers</li> <li><code>Governance</code>: Allows governance-related transactions</li> <li><code>Staking</code>: Allows staking-related transactions</li> <li><code>CancelProxy</code>: Only allows canceling other proxies</li> <li><code>Balances</code>: Allows balance transfers</li> <li><code>AuthorMapping</code>: Allows author mapping transactions</li> <li><code>IdentityJudgement</code>: Allows providing identity judgements</li> </ul> </li> <li><code>call</code> - The actual call to be executed (must match the call that was previously announced). This is the transaction that will be performed (e.g., a transfer, a stake, or any other valid runtime call)</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup proxy account from private key (this is the account executing the call)\n    const PROXY_PRIVATE_KEY = 'INSERT_PROXY_PRIVATE_KEY';\n    const proxyAccount = keyring.addFromUri(PROXY_PRIVATE_KEY);\n\n    // The account that delegated proxy rights\n    const realAccount = 'INSERT_REAL_ACCOUNT';\n\n    // The delegate account (the proxy account that made the announcement)\n    const delegateAccount = proxyAccount.address;\n\n    // Destination account for the transfer\n    const destinationAccount = 'INSERT_DESTINATION_ADDRESS';\n\n    // Amount to transfer (1 DEV = 1e18 Wei)\n    const transferAmount = '1000000000000000000'; // 1 DEV\n\n    // Create the transfer call that was previously announced\n    const transferCall = api.tx.balances.transferAllowDeath(\n      destinationAccount,\n      transferAmount\n    );\n\n    // Create the proxyAnnounced transaction\n    const tx = api.tx.proxy.proxyAnnounced(\n      delegateAccount,\n      realAccount,\n      { Balances: null }, // forceProxyType\n      transferCall\n    );\n\n    console.log('Validation checks:');\n    console.log('Delegate (Proxy) account:', delegateAccount);\n    console.log('Real account:', realAccount);\n    console.log('Force proxy type: Balances');\n    console.log('Call details:');\n    console.log('- Destination:', destinationAccount);\n    console.log('- Amount:', transferAmount, 'Wei (1 DEV)');\n\n    // Sign and send the transaction\n    await tx.signAndSend(proxyAccount, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful proxy execution\n          if (section === 'proxy' &amp;&amp; method === 'ProxyExecuted') {\n            console.log('\\nProxy call successfully executed!');\n          }\n\n          // Log successful transfer\n          if (section === 'balances' &amp;&amp; method === 'Transfer') {\n            const [from, to, amount] = data;\n            console.log('Transfer details:');\n            console.log('From:', from.toString());\n            console.log('To:', to.toString());\n            console.log('Amount:', amount.toString());\n          }\n        });\n\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in proxy announced transaction:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>    Validation checks:\n    Proxy account: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e\n    Real account: 0x569BE8d8b04538318e1722f6e375FD381D2da865\n    Destination account: 0x8c9c5F11d162a69E979F2DB9047A862ecbcA23Cb\n    Transfer amount: 1000000000000000000 Wei (1 DEV)\n    Force proxy type: Balances\n    Transaction included in block hash: 0xc347d714324e795c0e27ef574c8f924d7a52935314044cf2e2a395bc32ef5070\n        balances.Withdraw: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3817444390449]\n        balances.Transfer: [\"0x569BE8d8b04538318e1722f6e375FD381D2da865\",\"0x8c9c5F11d162a69E979F2DB9047A862ecbcA23Cb\",\"0x00000000000000000de0b6b3a7640000\"]\n\n    Transfer successfully executed via proxy!\n    From: 0x569BE8d8b04538318e1722f6e375FD381D2da865\n    To: 0x8c9c5F11d162a69E979F2DB9047A862ecbcA23Cb\n    Amount: 1000000000000000000\n        proxy.ProxyExecuted: [{\"ok\":null}]\n        balances.Deposit: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",0]\n        balances.Deposit: [\"0x6d6F646c70632f74727372790000000000000000\",763488878090]\n        transactionPayment.TransactionFeePaid: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3817444390449,0]\n        system.ExtrinsicSuccess: [{\"weight\":{\"refTime\":684752866,\"proofSize\":8691},\"class\":\"Normal\",\"paysFee\":\"Yes\"}]\n</code></pre> rejectAnnouncement(delegate, callHash) - if the sender is a prime account, this removes a specific announcement from their proxy account ParametersPolkadot.js API ExampleExample Response <ul> <li><code>delegate</code> - The account that previously made the announcement (H160 format address, e.g., '0x123...'). This must match the proxy account that called the announce function</li> <li><code>callHash</code> - The hash call to be executed (must match the call that was previously announced)</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup the real account (the one that will reject the announcement)\n    const REAL_PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const realAccount = keyring.addFromUri(REAL_PRIVATE_KEY);\n\n    // The proxy account that made the announcement\n    const delegateAccount = 'INSERT_PROXY_ACCOUNT';\n\n    // The call hash of the announcement to reject\n    const callHash = 'INSERT_CALL_HASH';\n\n    console.log('Validation checks:');\n    console.log('Real account (rejector):', realAccount.address);\n    console.log('Delegate account to reject:', delegateAccount);\n    console.log('Call hash to reject:', callHash);\n\n    // Create the reject announcement transaction\n    const tx = api.tx.proxy.rejectAnnouncement(delegateAccount, callHash);\n\n    // Sign and send the transaction\n    await tx.signAndSend(realAccount, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful rejection\n          if (section === 'proxy' &amp;&amp; method === 'AnnouncementRejected') {\n            console.log('\\nAnnouncement successfully rejected!');\n            const [accountId, hash] = data;\n            console.log('Rejected delegate:', accountId.toString());\n            console.log('Rejected call hash:', hash.toString());\n          }\n        });\n\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in rejecting announcement:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <p>Validation checks: Real account (rejector): 0x569BE8d8b04538318e1722f6e375FD381D2da865 Delegate account to reject: 0x569BE8d8b04538318e1722f6e375FD381D2da865 Call hash to reject: 0xaf2dd398c8ee31d963d1f24764b8857e27314b3e937385c3ff60c034a36e925c Transaction included in block hash: 0x76073a7b5eae1b9efb4a8142916fb33fa9f11a31f9e1f231ecb1ebd1af7a2a47     balances.Withdraw: [\"0x569BE8d8b04538318e1722f6e375FD381D2da865\",3621382860542]     balances.Deposit: [\"0x569BE8d8b04538318e1722f6e375FD381D2da865\",0]     balances.Deposit: [\"0x6d6F646c70632f74727372790000000000000000\",724276572109]     transactionPayment.TransactionFeePaid: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3621382860542,0]     [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3817444390449,0]         system.ExtrinsicSuccess: [{\"weight\":{\"refTime\":684752866,\"proofSize\":8691},\"class\":\"Normal\",\"paysFee\":\"Yes\"}]</p> removeAnnouncement(real, callHash) - if the sender is a proxy account, this removes a specific announcement to their prime account ParametersPolkadot.js API ExampleExample Response <ul> <li><code>real</code> - The account that was designated as the real account in the original announcement (H160 format address, e.g., '0x123...'). This is the account on whose behalf the proxy had announced a future transaction</li> <li><code>callHash</code> - The hash of the call from the original announcement (32-byte hex string, e.g., '0x570ff355...'). This uniquely identifies which announced transaction should be removed</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup the proxy account (the one that will remove its own announcement)\n    const PROXY_PRIVATE_KEY = 'INSERT_PROXY_PRIVATE_KEY';\n    const proxyAccount = keyring.addFromUri(PROXY_PRIVATE_KEY);\n\n    // The real account that the announcement was made for\n    const realAccount = 'INSERT_REAL_ACCOUNT';\n\n    // The call hash of the announcement to remove\n    const callHash = 'INSERT_CALL_HASH';\n\n    console.log('Validation checks:');\n    console.log('Proxy account (remover):', proxyAccount.address);\n    console.log('Real account:', realAccount);\n    console.log('Call hash to remove:', callHash);\n\n    // Create the remove announcement transaction\n    const tx = api.tx.proxy.removeAnnouncement(realAccount, callHash);\n\n    // Sign and send the transaction\n    await tx.signAndSend(proxyAccount, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful announcement removal\n          if (section === 'proxy' &amp;&amp; method === 'AnnouncementRejected') {\n            console.log('\\nAnnouncement successfully removed!');\n            const [accountId, hash] = data;\n            console.log('Removed for real account:', accountId.toString());\n            console.log('Removed call hash:', hash.toString());\n          }\n        });\n\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in removing announcement:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Validation checks:\nProxy account (remover): 0x3B939FeaD1557C741Ff06492FD0127bd287A421e\nReal account: 0x569BE8d8b04538318e1722f6e375FD381D2da865\nCall hash to remove: 0x570ff355e1471d3528cb4e2586bee7eafebc2efc89dd6f827188c69b15fff965\nTransaction included in block hash: 0x767724a583d93b558c56f2e241d2334bf91773269ceb1e0a60435f7cbbe2205a\n    balances.Withdraw: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3621330308042]\n    balances.Deposit: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",0]\n    balances.Deposit: [\"0x6d6F646c70632f74727372790000000000000000\",724266061609]\n    transactionPayment.TransactionFeePaid: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3621330308042,0]\n    [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3817444390449,0]\n        system.ExtrinsicSuccess: [{\"weight\":{\"refTime\":684752866,\"proofSize\":8691},\"class\":\"Normal\",\"paysFee\":\"Yes\"}]\n</code></pre> removeProxies() - unregisters all proxy accounts for the sender ParametersPolkadot.js API ExampleExample Response <p>None</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup the account that wants to remove all its proxies\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const account = keyring.addFromUri(PRIVATE_KEY);\n\n    console.log('Validation checks:');\n    console.log('Account removing all proxies:', account.address);\n\n    // Optional: Query existing proxies before removal\n    const proxies = await api.query.proxy.proxies(account.address);\n    console.log('\\nCurrent proxies before removal:', proxies.toHuman());\n\n    // Create the removeProxies transaction\n    const tx = api.tx.proxy.removeProxies();\n\n    // Sign and send the transaction\n    await tx.signAndSend(account, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful proxy removals\n          if (section === 'proxy' &amp;&amp; method === 'ProxyRemoved') {\n            console.log('\\nProxy successfully removed!');\n            const [delegator, delegate, proxyType, delay] = data;\n            console.log('Delegator:', delegator.toString());\n            console.log('Removed delegate:', delegate.toString());\n            console.log('Proxy type:', proxyType.toString());\n            console.log('Delay:', delay.toString());\n          }\n        });\n\n        // Optional: Query proxies after removal to confirm\n        api.query.proxy.proxies(account.address).then((afterProxies) =&gt; {\n          console.log('\\nProxies after removal:', afterProxies.toHuman());\n          process.exit(0);\n        });\n      }\n    });\n  } catch (error) {\n    console.error('Error in removing all proxies:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Validation checks:\nAccount removing all proxies: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e\n\nCurrent proxies before removal: [\n  [\n    {\n      delegate: '0x0000000000000000000000000000000000000000',\n      proxyType: 'Governance',\n      delay: '0'\n    },\n    {\n      delegate: '0x4b8C667590E6a28497Ea4be5FACB7e9869A64EAE',\n      proxyType: 'Staking',\n      delay: '0'\n    },\n    {\n      delegate: '0x569BE8d8b04538318e1722f6e375FD381D2da865',\n      proxyType: 'Staking',\n      delay: '0'\n    },\n    {\n      delegate: '0x569BE8d8b04538318e1722f6e375FD381D2da865',\n      proxyType: 'Balances',\n      delay: '100'\n    }\n  ],\n  '1,009,200,000,000,000,000'\n]\n\nTransaction included in block hash: 0x2ef80fe655c98f47ba82cc2ee7937e03d2c6211195dc03ef02e6d47fbbdcd944\n    balances.Withdraw: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3403192090986]\n    balances.Unreserved: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",\"0x00000000000000000e01660d93530000\"]\n    balances.Deposit: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",0]\n    balances.Deposit: [\"0x6d6F646c70632f74727372790000000000000000\",680638418198]\n    transactionPayment.TransactionFeePaid: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3403192090986,0]\n    system.ExtrinsicSuccess: [{\"weight\":{\"refTime\":395752965,\"proofSize\":4310},\"class\":\"Normal\",\"paysFee\":\"Yes\"}]\n\nProxies after removal: [ [], '0' ]\n</code></pre> removeProxy(delegate, proxyType, delay) - unregisters a specific proxy account for the sender. Emits a <code>ProxyRemoved</code> event ParametersPolkadot.js API ExampleExample Response <ul> <li><code>delegate</code> - The proxy account to remove (H160 format address, e.g., '0x123...'). This must be an existing proxy account that was previously registered using addProxy</li> <li><code>proxyType</code> - The type of proxy to remove. Must match exactly what was set when the proxy was added. Available options are:<ul> <li><code>Any</code>: Allows all transactions</li> <li><code>NonTransfer</code>: Allows all transactions except balance transfers</li> <li><code>Governance</code>: Allows governance-related transactions</li> <li><code>Staking</code>: Allows staking-related transactions</li> <li><code>CancelProxy</code>: Only allows canceling other proxies</li> <li><code>Balances</code>: Allows balance transfers</li> <li><code>AuthorMapping</code>: Allows author mapping transactions</li> <li><code>IdentityJudgement</code>: Allows providing identity judgements</li> </ul> </li> <li><code>delay</code> - The announcement delay in blocks that was set when adding the proxy (u32). Must match exactly what was set when the proxy was added (e.g., if proxy was added with delay=100, must use delay=100 to remove it)</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup the account that wants to remove a specific proxy\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const account = keyring.addFromUri(PRIVATE_KEY);\n\n    // The proxy account to remove\n    const proxyToRemove = 'INSERT_PROXY_ACCOUNT';\n\n    // Must match the original proxy type and delay that was set when adding the proxy\n    const proxyType = { Any: null };\n    const delay = 0;\n\n    console.log('Validation checks:');\n    console.log('Account removing proxy:', account.address);\n    console.log('Proxy being removed:', proxyToRemove);\n    console.log('Proxy type:', JSON.stringify(proxyType));\n    console.log('Delay:', delay);\n\n    // Optional: Query existing proxies before removal\n    const proxiesBefore = await api.query.proxy.proxies(account.address);\n    console.log('\\nCurrent proxies before removal:', proxiesBefore.toHuman());\n\n    // Create the removeProxy transaction\n    const tx = api.tx.proxy.removeProxy(proxyToRemove, proxyType, delay);\n\n    // Sign and send the transaction\n    await tx.signAndSend(account, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful proxy removal\n          if (section === 'proxy' &amp;&amp; method === 'ProxyRemoved') {\n            console.log('\\nProxy successfully removed!');\n            const [delegator, delegate, proxyType, delay] = data;\n            console.log('Delegator:', delegator.toString());\n            console.log('Removed delegate:', delegate.toString());\n            console.log('Proxy type:', proxyType.toString());\n            console.log('Delay:', delay.toString());\n          }\n        });\n\n        // Optional: Query proxies after removal to confirm\n        api.query.proxy.proxies(account.address).then((afterProxies) =&gt; {\n          console.log('\\nProxies after removal:', afterProxies.toHuman());\n          process.exit(0);\n        });\n      }\n    });\n  } catch (error) {\n    console.error('Error in removing proxy:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> <pre><code>Validation checks:\nAccount removing proxy: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e\nProxy being removed: 0x569BE8d8b04538318e1722f6e375FD381D2da865\nProxy type: {\"Any\":null}\nDelay: 0\n\nCurrent proxies before removal: [\n  [\n    {\n      delegate: '0x569BE8d8b04538318e1722f6e375FD381D2da865',\n      proxyType: 'Any',\n      delay: '0'\n    }\n  ],\n  '1,002,900,000,000,000,000'\n]\n\nTransaction included in block hash: 0x8402c11ca656798ad54eea16c5c05b5fefa5d5d23beb590d214d2fa4168d8af9\n    balances.Withdraw: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3431367169061]\n    balances.Unreserved: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",\"0x00000000000000000deb043c853d4000\"]\n    proxy.ProxyRemoved: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",\"0x569BE8d8b04538318e1722f6e375FD381D2da865\",\"Any\",0]\n\nProxy successfully removed!\nDelegator: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e\nRemoved delegate: 0x569BE8d8b04538318e1722f6e375FD381D2da865\nProxy type: Any\nDelay: 0\n    balances.Deposit: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",0]\n    balances.Deposit: [\"0x6d6F646c70632f74727372790000000000000000\",686273433813]\n    transactionPayment.TransactionFeePaid: [\"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",3431367169061,0]\n    system.ExtrinsicSuccess: [{\"weight\":{\"refTime\":398292318,\"proofSize\":4310},\"class\":\"Normal\",\"paysFee\":\"Yes\"}]\n\nProxies after removal: [ [], '0' ]\n</code></pre> <p>Note</p> <p>Anonymous proxies are disabled on Moonbeam networks because they are easy to misuse. Incorrect usage can cause a permanent loss of funds and unreserved balances.</p>"},{"location":"builders/substrate/interfaces/account/proxy/#storage-methods","title":"Storage Methods","text":"<p>The proxy pallet includes the following read-only storage methods to obtain chain state data:</p> announcements(AccountId20) - returns all announcements made by the specified proxy account ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> - The proxy account's address in H160 format (e.g., '0x123...') whose announcements you want to query</li> </ul> <p>Returns a tuple containing: - Array of announcements, each containing:     - real: AccountId20 (The account the announcement was made for)     - callHash: H256 (The hash of the announced call)     - height: BlockNumber (The block number when announced) - Balance (The amount reserved to place the announcements)</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  try {\n    // Initialize connection to the network\n    const api = await ApiPromise.create({\n      provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n    });\n\n    // The proxy address to query\n    const proxyAddress = 'INSERT_PROXY_ACCOUNT';\n\n    // Query announcements\n    const announcements = await api.query.proxy.announcements(proxyAddress);\n\n    // Log the results\n    console.log('Querying announcements for proxy:', proxyAddress);\n    console.log(\n      '\\nAnnouncements:',\n      JSON.stringify(announcements.toHuman(), null, 2)\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error occurred:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> palletVersion() - returns the current pallet version ParametersReturnsPolkadot.js API Example <ul> <li>None</li> </ul> <p>Returns a single number representing the current version of the proxy pallet</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  try {\n    // Initialize connection to the network\n    const api = await ApiPromise.create({\n      provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n    });\n\n    // Query pallet version\n    const version = await api.query.proxy.palletVersion();\n\n    // Log the result\n    console.log('Proxy Pallet Version:', version.toHuman());\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error occurred:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> proxies(AccountId20) - returns a map and count of all proxy accounts for a specified primary account ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> - The primary account's address in H160 format (e.g., '0x123...') whose proxies you want to query</li> </ul> <p>Returns a tuple containing: - Array of ProxyDefinition, each containing:     - delegate: AccountId20 (The proxy account address)     - proxyType: Enum (The type of proxy)     - delay: Number (The announcement delay in blocks) - Balance (The amount reserved to place the proxies)</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  try {\n    // Initialize connection to the network\n    const api = await ApiPromise.create({\n      provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n    });\n\n    // The account address to query proxies for\n    const accountAddress = 'INSERT_REAL_ACCOUNT';\n\n    // Query proxies\n    const [proxies, deposit] = await api.query.proxy.proxies(accountAddress);\n\n    // Log the results with formatted JSON\n    console.log('Querying proxies for account:', accountAddress);\n    console.log('\\nProxies:', JSON.stringify(proxies.toHuman(), null, 2));\n    console.log('Required deposit:', deposit.toHuman());\n\n    // Display in a more readable format\n    console.log('\\nProxy Details:');\n    proxies.forEach((proxy, index) =&gt; {\n      console.log(`\\nProxy #${index + 1}:`);\n      console.log('  Delegate:', proxy.delegate.toString());\n      console.log('  Proxy Type:', proxy.proxyType.toString());\n      console.log('  Delay:', proxy.delay.toString());\n    });\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error occurred:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"builders/substrate/interfaces/account/proxy/#constants","title":"Pallet Constants","text":"<p>The proxy pallet includes the following read-only functions to obtain pallet constants:</p> announcementDepositBase() - returns the base amount of currency needed to reserve for creating an announcement ParametersReturnsPolkadot.js API Example <ul> <li>None</li> </ul> <p>Returns a Balance value representing the base deposit amount in Wei required for creating a proxy announcement</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Query the base deposit\n  const baseDeposit = await api.consts.proxy.announcementDepositBase;\n\n  console.log('Announcement Base Deposit:', baseDeposit.toHuman());\n\n  process.exit(0);\n};\n\nmain().catch(console.error);\n</code></pre> announcementDepositFactor() - returns the amount of currency needed per announcement made ParametersReturnsPolkadot.js API Example <p>None</p> <p>Returns a Balance value representing the additional deposit amount in Wei required for each announcement made</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Query the deposit factor\n  const depositFactor = await api.consts.proxy.announcementDepositFactor;\n\n  console.log('Announcement Deposit Factor:', depositFactor.toHuman());\n\n  process.exit(0);\n};\n\nmain().catch(console.error);\n</code></pre> maxPending() - returns the maximum amount of time-delayed announcements that are allowed to be pending ParametersReturnsPolkadot.js API Example <p>None</p> <p>Returns a u32 value representing the maximum number of announcements that can be pending for a proxy account</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Query max pending announcements\n  const maxPending = await api.consts.proxy.maxPending;\n\n  console.log('Maximum Pending Announcements:', maxPending.toHuman());\n\n  process.exit(0);\n};\n\nmain().catch(console.error);\n</code></pre> maxProxies() - returns the maximum amount of proxies allowed for a single account ParametersReturnsPolkadot.js API Example <p>None</p> <p>Returns a u32 value representing the maximum number of proxy accounts that can be registered to a single account</p> <pre><code> import { ApiPromise, WsProvider } from '@polkadot/api';\n\n const main = async () =&gt; {\n   // Initialize the API\n   const api = await ApiPromise.create({\n     provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n   });\n\n   // Query max proxies allowed\n   const maxProxies = await api.consts.proxy.maxProxies;\n\n   console.log('Maximum Proxies per Account:', maxProxies.toHuman());\n\n   process.exit(0);\n };\n\n main().catch(console.error);\n</code></pre> proxyDepositBase() - returns the base amount of currency needed to reserve for creating a proxy ParametersReturnsPolkadot.js API Example <p>None</p> <p>Returns a Balance value representing the base deposit amount in Wei required for creating a proxy</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Query the base deposit for proxy creation\n  const baseDeposit = await api.consts.proxy.proxyDepositBase;\n\n  console.log('Proxy Base Deposit:', baseDeposit.toHuman());\n\n  process.exit(0);\n};\n\nmain().catch(console.error);\n</code></pre> proxyDepositFactor() - returns the amount of currency needed per proxy added ParametersReturnsPolkadot.js API Example <p>None</p> <p>Returns a Balance value representing the additional deposit amount in Wei required for each proxy registered</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Query the deposit factor for proxies\n  const depositFactor = await api.consts.proxy.proxyDepositFactor;\n\n  console.log('Proxy Deposit Factor:', depositFactor.toHuman());\n\n  process.exit(0);\n};\n\nmain().catch(console.error);\n</code></pre>"},{"location":"builders/substrate/interfaces/features/randomness/","title":"The Randomness Pallet","text":""},{"location":"builders/substrate/interfaces/features/randomness/#introduction","title":"Introduction","text":"<p>Moonbeam utilizes verifiable random functions (VRF) to generate randomness that can be verified on-chain. A VRF is a cryptographic function that takes some input and produces random values, along with a proof of authenticity that these random values were generated by the submitter. The proof can be verified by anyone to ensure the random values generated were calculated correctly. For more information on Moonbeam's on-chain randomness, such as an overview on the randomness sources, the request and fulfill cycle, and more, please refer to the Randomness on Moonbeam overview page.</p> <p>The randomness pallet enables you to check on randomness requests that have not been fulfilled or purged, randomness results, and more. To actually request and fulfill randomness, you can use the randomness precompile and randomness consumer contracts. The precompile is a Solidity interface that enables you to request randomness, check on the status of requests, fulfill requests, and more through the Ethereum API. For more information on how to use both of these contracts, please refer to the Randomness Precompile guide.</p> <p>This page will provide an overview of the storage methods and getters for the pallet constants available in the randomness pallet.</p>"},{"location":"builders/substrate/interfaces/features/randomness/#randomness-pallet-interface","title":"Randomness Pallet Interface","text":""},{"location":"builders/substrate/interfaces/features/randomness/#storage-methods","title":"Storage Methods","text":"<p>The randomness pallet includes the following read-only storage methods to obtain chain state data:</p> localVrfOutput() - returns the current local per-block VRF randomness ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>H256</code> - A 32-byte (256-bit) hex value, starting with \"0x\"`</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the local VRF output from randomness pallet\n    const localVrf = await api.query.randomness.localVrfOutput();\n\n    console.log('Local VRF Output:', localVrf.toString());\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying local VRF output:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> palletVersion() - returns the current pallet version ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u16</code> - The pallet version</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the pallet version from randomness pallet\n    const version = await api.query.randomness.palletVersion();\n\n    console.log('Randomness Pallet Version:', version.toString());\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying randomness pallet version:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> randomnessResults(PalletRandomnessRequestType) - snapshot of randomness to fulfill all requests that are for the same raw randomness ParametersReturnsPolkadot.js API Example <ul> <li><code>PalletRandomnessRequestType</code> - You can optionally provide the type of randomness you'd like, e.g. <code>Local</code> or <code>BabeEpoch</code> Randomness. If you omit this, you'll receive all types of randomness. </li> </ul> <p>The query returns mappings of request types to their randomness outcomes, where:</p> <ol> <li> <p>Key: Identifies the source and timing of the randomness request. e.g. <code>{ Local: '4,619,640' }</code> indicates this was a Local randomness request from block number 4,619,640. The Local type uses block numbers as identifiers, while BabeEpoch uses epoch numbers.</p> </li> <li> <p>Value: Contains two pieces of information, including <code>randomness</code>: A 32-byte hex string (0x15b5f6...c816) representing the random value generated and <code>requestCount</code>: The number of requests that used this same random value (e.g. '1')</p> </li> </ol> <p>Multiple requests for randomness at the same block/epoch would share the same random value, which is why there's a requestCount field.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Query Babe Epoch randomness results\n    const babeResults = await api.query.randomness.randomnessResults({\n      BabeEpoch: 0,\n    });\n    console.log('\\nBabe Epoch Randomness Results:');\n    console.log(babeResults.toHuman());\n\n    // Query Local randomness results\n    const localResults = await api.query.randomness.randomnessResults({\n      Local: 0,\n    });\n    console.log('\\nLocal Randomness Results:');\n    console.log(localResults.toHuman());\n\n    // Get the available keys/entries\n    console.log('\\nAll Available Randomness Results:');\n    const entries = await api.query.randomness.randomnessResults.entries();\n    entries.forEach(([key, value]) =&gt; {\n      console.log(\n        'Key:',\n        key.args.map((k) =&gt; k.toHuman())\n      );\n      console.log('Value:', value.toHuman());\n      console.log('---');\n    });\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying randomness results:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> relayEpoch() - returns the relay epoch ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u64</code> -  the relay epoch</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the relay epoch\n    const relayEpoch = await api.query.randomness.relayEpoch();\n\n    console.log('Current Relay Epoch:', relayEpoch.toString());\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying relay epoch:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> requestCount() - returns the number of randomness requests made so far, and is used to generate the next request's uid ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u64</code> -  the request count</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the request count\n    const requestCount = await api.query.randomness.requestCount();\n\n    console.log('Total Randomness Requests:', requestCount.toString());\n    console.log(\n      'Next Request UID will be:',\n      (Number(requestCount) + 1).toString()\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying request count:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> requests(u64) - returns a given randomness request or all of the randomness requests that have not been fulfilled nor purged yet ParametersReturnsPolkadot.js API Example <ul> <li><code>u64</code> - The request ID number (optional)</li> </ul> <p>Returns an Option containing the request information if it exists and hasn't been fulfilled/purged, including:</p> <ul> <li>The request type (Local or Babe)</li> <li>When it can be fulfilled</li> <li>Number of random words requested</li> <li>The requester's information</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // First get the current request count\n    const requestCount = await api.query.randomness.requestCount();\n    console.log('Total Request Count:', requestCount.toString());\n\n    // Query most recent request as an example\n    if (requestCount &gt; 0) {\n      const latestRequestId = requestCount - 1;\n      const specificRequest =\n        await api.query.randomness.requests(latestRequestId);\n\n      console.log('\\nLatest Request (ID:', latestRequestId.toString(), '):');\n      if (specificRequest.isSome) {\n        console.log(specificRequest.unwrap().toHuman());\n      } else {\n        console.log('Request has been fulfilled or purged');\n      }\n    }\n\n    // Query all available requests\n    console.log('\\nAll Pending Requests:');\n    const allRequests = await api.query.randomness.requests.entries();\n\n    if (allRequests.length === 0) {\n      console.log('No pending requests found');\n    } else {\n      allRequests.forEach(([key, value]) =&gt; {\n        const requestId = key.args[0].toString();\n        console.log('\\nRequest ID:', requestId);\n        if (value.isSome) {\n          const request = value.unwrap();\n          console.log('Request Details:', request.toHuman());\n        }\n      });\n\n      // Show some statistics\n      console.log('\\nRequest Statistics:');\n      console.log('Total Pending Requests:', allRequests.length);\n    }\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying randomness requests:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"builders/substrate/interfaces/features/randomness/#constants","title":"Pallet Constants","text":"<p>The randomness pallet includes the following read-only functions to obtain pallet constants:</p> blockExpirationDelay() - the number of blocks that must pass before a local VRF request expires and can be purged ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - the number of blocks that must pass before a local VRF request expires and can be purged</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the block expiration delay constant\n    const blockExpirationDelay =\n      await api.consts.randomness.blockExpirationDelay;\n\n    console.log(\n      'Block Expiration Delay:',\n      blockExpirationDelay.toString(),\n      'blocks'\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying block expiration delay:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> deposit() - the amount that should be taken as a security deposit when requesting random words. There is one deposit per request ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u128</code> - the amount that should be taken as a security deposit when requesting random words</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the deposit constant\n    const deposit = await api.consts.randomness.deposit;\n\n    console.log('Randomness Request Deposit:', deposit.toString(), 'Wei');\n    console.log(\n      'Deposit in DEV:',\n      (BigInt(deposit) / BigInt(10 ** 18)).toString()\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying randomness deposit:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> epochExpirationDelay() - the number of epochs that must pass before a BABE request expires and can be purged ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u64</code> - the number of epochs that must pass before a BABE request expires and can be purged</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the epoch expiration delay constant\n    const epochExpirationDelay =\n      await api.consts.randomness.epochExpirationDelay;\n\n    console.log(\n      'Epoch Expiration Delay:',\n      epochExpirationDelay.toString(),\n      'epochs'\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying epoch expiration delay:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> maxBlockDelay() - the maximum number of blocks (after the block in which the request was made) that can pass before a local VRF request is fulfilled ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - the maximum number of blocks that can pass before a local VRF request is fulfilled</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the maximum block delay constant\n    const maxBlockDelay = await api.consts.randomness.maxBlockDelay;\n\n    console.log('Maximum Block Delay:', maxBlockDelay.toString(), 'blocks');\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying max block delay:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> maxRandomWords() - the maximum number of random words that can be requested ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u8</code> - the maximum number of random words that can be requested</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the maximum random words constant\n    const maxRandomWords = await api.consts.randomness.maxRandomWords;\n\n    console.log('Maximum Random Words:', maxRandomWords.toString(), 'words');\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying max random words:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> minBlockDelay() - the minimum number of blocks (after the block in which the request was made) that must pass before a local VRF request can be fulfilled ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - the minimum number of blocks (after the block in which the request was made) that must pass before a local VRF request can be fulfilled</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the minimum block delay constant\n    const minBlockDelay = await api.consts.randomness.minBlockDelay;\n\n    console.log('Minimum Block Delay:', minBlockDelay.toString(), 'blocks');\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying min block delay:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"builders/substrate/interfaces/features/staking/","title":"The Parachain Staking Pallet","text":""},{"location":"builders/substrate/interfaces/features/staking/#introduction","title":"Introduction","text":"<p>Moonbeam uses a Delegated Proof of Stake (DPoS) system that determines which collators are eligible to produce blocks based on their total stake in the network. For general information on staking, such as general terminology, staking variables, and more, please refer to the Staking on Moonbeam page.</p> <p>The DPoS system is powered by the parachain staking pallet, allowing token holders (delegators) to express exactly which collator candidates they would like to support and with what quantity of stake. The design of the parachain staking pallet is such that it enforces shared risk/reward on chain between delegators and candidates.</p> <p>Some of the functionality of the parachain staking pallet is also available through a staking precompile. The precompile is a Solidity interface that enables you to perform staking actions through the Ethereum API. Please refer to the Staking Precompile guide for more information.</p> <p>This guide will provide an overview of the extrinsics, storage methods, and getters for the pallet constants available in the parachain staking pallet.</p>"},{"location":"builders/substrate/interfaces/features/staking/#exit-delays","title":"Exit Delays","text":"<p>Some of the staking pallet extrinsics include exit delays that you must wait before the request can be executed. The exit delays to note are as follows:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Decrease candidate bond 28 rounds (168 hours) Decrease delegator bond 28 rounds (168 hours) Revoke delegation 28 rounds (168 hours) Leave candidates 28 rounds (168 hours) Leave delegators 28 rounds (168 hours) Variable Value Decrease candidate bond 24 rounds (48 hours) Decrease delegator bond 24 rounds (48 hours) Revoke delegation 24 rounds (48 hours) Leave candidates 24 rounds (48 hours) Leave delegators 24 rounds (48 hours) Variable Value Decrease candidate bond 2 rounds (4 hours) Decrease delegator bond 2 rounds (4 hours) Revoke delegation 2 rounds (4 hours) Leave candidates 2 rounds (4 hours) Leave delegators 2 rounds (4 hours)"},{"location":"builders/substrate/interfaces/features/staking/#parachain-staking-pallet-interface","title":"Parachain Staking Pallet Interface","text":""},{"location":"builders/substrate/interfaces/features/staking/#extrinsics","title":"Extrinsics","text":"<p>The parachain staking pallet provides the following extrinsics (functions):</p> cancelCandidateBondLess() - cancels a pending scheduled request to decrease a candidate's self bond amount ParametersPolkadot.js API Example <p>None</p> <pre><code> import { ApiPromise, WsProvider } from '@polkadot/api';\n import { Keyring } from '@polkadot/keyring';\n\n const main = async () =&gt; {\n   // Initialize the API\n   const api = await ApiPromise.create({\n     provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n   });\n\n   // Initialize the keyring with ethereum type\n   const keyring = new Keyring({ type: 'ethereum' });\n\n   try {\n     // Setup account from private key\n     const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n     const account = keyring.addFromUri(PRIVATE_KEY);\n\n     console.log('Account address:', account.address);\n\n     // Create the cancel transaction\n     const tx = api.tx.parachainStaking.cancelCandidateBondLess();\n\n     // Sign and send the transaction\n     await tx.signAndSend(account, ({ status, events }) =&gt; {\n       if (status.isInBlock) {\n         console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n         // Process events\n         events.forEach(({ event }) =&gt; {\n           const { section, method, data } = event;\n           console.log(`\\t${section}.${method}:`, data.toString());\n\n           // Handle any failures\n           if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n             const [dispatchError] = data;\n             let errorInfo;\n\n             if (dispatchError.isModule) {\n               const decoded = api.registry.findMetaError(\n                 dispatchError.asModule\n               );\n               errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n             } else {\n               errorInfo = dispatchError.toString();\n             }\n             console.error('Failure reason:', errorInfo);\n           }\n\n           // Log successful cancellation\n           if (\n             section === 'parachainStaking' &amp;&amp;\n             method === 'CancelledCandidateBondLess'\n           ) {\n             const [candidate, amount, executeRound] = data;\n             console.log('\\nSuccessfully cancelled bond decrease request!');\n             console.log('Candidate:', candidate.toString());\n             console.log('Amount that was to be decreased:', amount.toString());\n             console.log(\n               'Round it was to be executed:',\n               executeRound.toString()\n             );\n           }\n         });\n\n         process.exit(0);\n       }\n     });\n   } catch (error) {\n     console.error('Error in cancelling candidate bond less:', error);\n     process.exit(1);\n   }\n };\n\n // Execute the script\n main().catch((error) =&gt; {\n   console.error('Script error:', error);\n   process.exit(1);\n });\n</code></pre> cancelDelegationRequest(candidate) - cancels any pending delegation requests provided the address of a candidate ParametersPolkadot.js API Example <ul> <li><code>candidate</code> - The address of the relevant collator</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup delegator account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const delegator = keyring.addFromUri(PRIVATE_KEY);\n\n    // The candidate's address for which to cancel the delegation request\n    const candidateAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    console.log('Delegator address:', delegator.address);\n    console.log('Candidate address:', candidateAddress);\n\n    // Create the cancel delegation request transaction\n    const tx =\n      api.tx.parachainStaking.cancelDelegationRequest(candidateAddress);\n\n    // Sign and send the transaction\n    await tx.signAndSend(delegator, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful cancellation\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'CancelledDelegationRequest'\n          ) {\n            const [delegatorAddress, scheduledRequest, candidateAddress] = data;\n            console.log('\\nSuccessfully cancelled delegation request!');\n            console.log('Delegator:', delegatorAddress.toString());\n            console.log('Candidate:', candidateAddress.toString());\n\n            const request = scheduledRequest.toJSON();\n            console.log('Request details:');\n            console.log('- Execution round:', request.whenExecutable);\n            if (request.action.decrease) {\n              console.log('- Action: Decrease by', request.action.decrease);\n            } else if (request.action.revoke) {\n              console.log('- Action: Revoke amount', request.action.revoke);\n            }\n          }\n        });\n\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in cancelling delegation request:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> cancelLeaveCandidates(candidateCount) - cancels a candidate's pending scheduled request to leave the candidate pool given the current number of candidates in the pool ParametersPolkadot.js API Example <ul> <li><code>candidateCount</code> - The current number of collator candidates in the pool</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup candidate account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const candidate = keyring.addFromUri(PRIVATE_KEY);\n\n    // First, get the current candidate count from the chain\n    const candidates = await api.query.parachainStaking.candidatePool();\n    const candidateCount = candidates.length;\n\n    console.log('Candidate address:', candidate.address);\n    console.log('Current candidate count:', candidateCount);\n\n    // Create the cancel leave candidates transaction\n    const tx = api.tx.parachainStaking.cancelLeaveCandidates(candidateCount);\n\n    // Sign and send the transaction\n    await tx.signAndSend(candidate, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful cancellation\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'CancelledLeaveCandidates'\n          ) {\n            const [candidateAddress, candidateCount] = data;\n            console.log('\\nSuccessfully cancelled leave candidates request!');\n            console.log('Candidate:', candidateAddress.toString());\n            console.log(\n              'Candidate count at cancellation:',\n              candidateCount.toString()\n            );\n          }\n        });\n\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in cancelling leave candidates request:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> candidateBondMore(more) - request to increase a candidate's self bond by a specified amount ParametersPolkadot.js API Example <ul> <li><code>more</code> - The amount of WEI by which to increase the candidate's self bond</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup candidate account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const candidate = keyring.addFromUri(PRIVATE_KEY);\n\n    // Amount to increase bond by (e.g., 1 DEV = 1_000_000_000_000_000_000)\n    const moreBond = '1000000000000000000';\n\n    console.log('Candidate address:', candidate.address);\n    console.log('Increasing bond by:', moreBond, 'Wei (1 DEV)');\n\n    // Query current bond before increasing\n    const candidateInfo = await api.query.parachainStaking.candidateInfo(\n      candidate.address\n    );\n    if (candidateInfo.isSome) {\n      console.log('Current bond:', candidateInfo.unwrap().bond.toString());\n    }\n\n    // Create the increase bond transaction\n    const tx = api.tx.parachainStaking.candidateBondMore(moreBond);\n\n    // Sign and send the transaction\n    await tx.signAndSend(candidate, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in block hash: ${status.asInBlock}`);\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful bond increase\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'CandidateBondedMore'\n          ) {\n            const [candidateAddress, amount, newTotal] = data;\n            console.log('\\nSuccessfully increased candidate bond!');\n            console.log('Candidate:', candidateAddress.toString());\n            console.log('Amount increased:', amount.toString());\n            console.log('New total bond:', newTotal.toString());\n          }\n        });\n\n        // Query updated bond after transaction\n        api.query.parachainStaking\n          .candidateInfo(candidate.address)\n          .then((newInfo) =&gt; {\n            if (newInfo.isSome) {\n              console.log('\\nUpdated bond:', newInfo.unwrap().bond.toString());\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in increasing candidate bond:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> delegateWithAutoCompound(candidate, amount, autoCompound, candidateDelegationCount, candidateAutoCompoundingDelegationCount, delegationCount) - delegates a collator candidate and sets the percentage of rewards to auto-compound given an integer (no decimals) for the <code>amount</code> between 0-100. If the caller is not a delegator, this function adds them to the set of delegators. If the caller is already a delegator, then it adjusts their delegation amount ParametersPolkadot.js API Example <ul> <li><code>candidate</code> - The collator's address you want to delegate to</li> <li><code>amount</code> - The amount to delegate (in Wei, e.g. 1000000000000000000 for 1 DEV)</li> <li><code>autoCompound</code> - The percentage of rewards to automatically compound (0-100)</li> <li><code>candidateDelegationCount</code> - The current number of delegations to the collator</li> <li><code>candidateAutoCompoundingDelegationCount</code> - The current number of auto-compounding delegations for the collator</li> <li><code>delegationCount</code> - The total number of delegations you have across all collators</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup delegator account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const delegator = keyring.addFromUri(PRIVATE_KEY);\n\n    // The candidate's address to delegate to\n    const candidateAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    // Amount to delegate (e.g., 1 DEV = 1_000_000_000_000_000_000)\n    const amount = '1000000000000000000';\n\n    // Auto-compound percentage (0-100)\n    const autoCompound = 50; // 50% of rewards will be auto-compounded\n\n    // Get current delegation counts\n    const candidateInfo =\n      await api.query.parachainStaking.candidateInfo(candidateAddress);\n    const delegatorState = await api.query.parachainStaking.delegatorState(\n      delegator.address\n    );\n    const autoCompoundDelegations =\n      await api.query.parachainStaking.autoCompoundingDelegations(\n        candidateAddress\n      );\n\n    // Get delegation counts\n    let candidateDelegationCount = 0;\n    let candidateAutoCompoundingDelegationCount = 0;\n    let delegationCount = 0;\n\n    if (candidateInfo.isSome) {\n      candidateDelegationCount = candidateInfo.unwrap().delegationCount;\n    }\n\n    candidateAutoCompoundingDelegationCount = autoCompoundDelegations.length;\n\n    if (delegatorState.isSome) {\n      delegationCount = delegatorState.unwrap().delegations.length;\n    }\n\n    console.log('Delegation Details:');\n    console.log('Delegator address:', delegator.address);\n    console.log('Candidate address:', candidateAddress);\n    console.log('Delegation amount:', amount, 'Wei (1 DEV)');\n    console.log('Auto-compound percentage:', autoCompound, '%');\n    console.log('\\nCurrent Stats:');\n    console.log(\n      'Candidate delegation count:',\n      candidateDelegationCount.toString()\n    );\n    console.log(\n      'Candidate auto-compounding delegation count:',\n      candidateAutoCompoundingDelegationCount.toString()\n    );\n    console.log('Delegator total delegations:', delegationCount.toString());\n\n    // Create the delegate with auto-compound transaction\n    const tx = api.tx.parachainStaking.delegateWithAutoCompound(\n      candidateAddress,\n      amount,\n      autoCompound,\n      candidateDelegationCount,\n      candidateAutoCompoundingDelegationCount,\n      delegationCount\n    );\n\n    // Sign and send the transaction\n    await tx.signAndSend(delegator, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful delegation\n          if (section === 'parachainStaking' &amp;&amp; method === 'Delegation') {\n            const [delegator, amount, candidate, autoCompound] = data;\n            console.log('\\nSuccessfully delegated with auto-compound!');\n            console.log('Delegator:', delegator.toString());\n            console.log('Candidate:', candidate.toString());\n            console.log('Amount:', amount.toString());\n            console.log(\n              'Auto-compound percentage:',\n              autoCompound.toString(),\n              '%'\n            );\n          }\n        });\n\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error in delegation with auto-compound:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> delegatorBondMore(candidate, more) - request to increase a delegator's amount delegated for a specific candidate ParametersPolkadot.js API Example <ul> <li><code>candidate</code> - the address of the respective collator</li> <li><code>more</code> - The amount you want to increase your delegation by (in Wei, e.g. 1000000000000000000 for 1 DEV)</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup delegator account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const delegator = keyring.addFromUri(PRIVATE_KEY);\n\n    // The candidate's address for which to increase delegation\n    const candidateAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    // Amount to increase delegation by (e.g., 1 DEV = 1_000_000_000_000_000_000)\n    const moreBond = '1000000000000000000';\n\n    // Query current delegation before increasing\n    const delegatorState = await api.query.parachainStaking.delegatorState(\n      delegator.address\n    );\n\n    console.log('Current Delegation Info:');\n    console.log('Delegator address:', delegator.address);\n    console.log('Candidate address:', candidateAddress);\n\n    if (delegatorState.isSome) {\n      const state = delegatorState.unwrap();\n      const currentDelegation = state.delegations.find(\n        (d) =&gt;\n          d.owner.toString().toLowerCase() === candidateAddress.toLowerCase()\n      );\n      if (currentDelegation) {\n        console.log(\n          'Current delegation amount:',\n          currentDelegation.amount.toString()\n        );\n      }\n    }\n\n    console.log('Amount to increase by:', moreBond, 'Wei (1 DEV)');\n\n    // Create the increase delegation transaction\n    const tx = api.tx.parachainStaking.delegatorBondMore(\n      candidateAddress,\n      moreBond\n    );\n\n    // Sign and send the transaction\n    await tx.signAndSend(delegator, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful bond increase\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'DelegationIncreased'\n          ) {\n            const [delegator, candidate, amount, inTopDelegations] = data;\n            console.log('\\nSuccessfully increased delegation!');\n            console.log('Delegator:', delegator.toString());\n            console.log('Candidate:', candidate.toString());\n            console.log('Amount increased by:', amount.toString());\n            console.log('In top delegations:', inTopDelegations.toString());\n          }\n        });\n\n        // Query updated delegation after transaction\n        api.query.parachainStaking\n          .delegatorState(delegator.address)\n          .then((newState) =&gt; {\n            if (newState.isSome) {\n              const state = newState.unwrap();\n              const updatedDelegation = state.delegations.find(\n                (d) =&gt;\n                  d.owner.toString().toLowerCase() ===\n                  candidateAddress.toLowerCase()\n              );\n              if (updatedDelegation) {\n                console.log(\n                  '\\nNew delegation amount:',\n                  updatedDelegation.amount.toString()\n                );\n              }\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in increasing delegation:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> executeCandidateBondLess(candidate) - executes any scheduled due requests to decrease a candidate's self bond amount ParametersPolkadot.js API Example <ul> <li><code>candidate</code> - the address of the respective collator</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup account from private key (this can be any account, doesn't need to be the candidate)\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const executor = keyring.addFromUri(PRIVATE_KEY);\n\n    // The candidate's address whose bond decrease should be executed\n    const candidateAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    // Query current candidate info before execution\n    const candidateInfo =\n      await api.query.parachainStaking.candidateInfo(candidateAddress);\n\n    console.log('Execution Details:');\n    console.log('Executor address:', executor.address);\n    console.log('Candidate address:', candidateAddress);\n\n    if (candidateInfo.isSome) {\n      const info = candidateInfo.unwrap();\n      console.log('\\nCandidate current bond:', info.bond.toString());\n      console.log('Candidate status:', info.status.toString());\n    }\n\n    // Create the execute bond decrease transaction\n    const tx =\n      api.tx.parachainStaking.executeCandidateBondLess(candidateAddress);\n\n    // Sign and send the transaction\n    await tx.signAndSend(executor, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful execution\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'CandidateBondedLess'\n          ) {\n            const [candidate, amount, newBond] = data;\n            console.log('\\nSuccessfully executed candidate bond decrease!');\n            console.log('Candidate:', candidate.toString());\n            console.log('Amount decreased:', amount.toString());\n            console.log('New bond amount:', newBond.toString());\n          }\n        });\n\n        // Query updated candidate info after execution\n        api.query.parachainStaking\n          .candidateInfo(candidateAddress)\n          .then((newInfo) =&gt; {\n            if (newInfo.isSome) {\n              const info = newInfo.unwrap();\n              console.log('\\nUpdated candidate bond:', info.bond.toString());\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in executing candidate bond decrease:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> executeDelegationRequest(delegator, candidate) - executes any scheduled due delegation requests for a specific delegator provided the address of the candidate ParametersPolkadot.js API Example <ul> <li><code>delegator</code> - The address of the delegator who made the delegation request</li> <li><code>candidate</code> - The collator's address associated with the delegation request</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup executor account from private key (this can be any account)\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const executor = keyring.addFromUri(PRIVATE_KEY);\n\n    // The delegator's address whose request will be executed\n    const delegatorAddress = 'INSERT_DELEGATOR_ADDRESS';\n\n    // The candidate's address for the delegation request\n    const candidateAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    // Query current delegation info before execution\n    const delegatorState =\n      await api.query.parachainStaking.delegatorState(delegatorAddress);\n\n    console.log('Execution Details:');\n    console.log('Executor address:', executor.address);\n    console.log('Delegator address:', delegatorAddress);\n    console.log('Candidate address:', candidateAddress);\n\n    if (delegatorState.isSome) {\n      const state = delegatorState.unwrap();\n      const currentDelegation = state.delegations.find(\n        (d) =&gt;\n          d.owner.toString().toLowerCase() === candidateAddress.toLowerCase()\n      );\n      if (currentDelegation) {\n        console.log(\n          '\\nCurrent delegation amount:',\n          currentDelegation.amount.toString()\n        );\n      }\n    }\n\n    // Create the execute delegation request transaction\n    const tx = api.tx.parachainStaking.executeDelegationRequest(\n      delegatorAddress,\n      candidateAddress\n    );\n\n    // Sign and send the transaction\n    await tx.signAndSend(executor, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful delegation decrease/revoke\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'DelegationDecreased'\n          ) {\n            const [delegator, candidate, amount, inTopDelegations] = data;\n            console.log('\\nSuccessfully executed delegation decrease!');\n            console.log('Delegator:', delegator.toString());\n            console.log('Candidate:', candidate.toString());\n            console.log('Amount decreased:', amount.toString());\n            console.log('In top delegations:', inTopDelegations.toString());\n          }\n\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'DelegationRevoked'\n          ) {\n            const [delegator, candidate, amount] = data;\n            console.log('\\nSuccessfully executed delegation revocation!');\n            console.log('Delegator:', delegator.toString());\n            console.log('Candidate:', candidate.toString());\n            console.log('Amount revoked:', amount.toString());\n          }\n        });\n\n        // Query updated delegation info after execution\n        api.query.parachainStaking\n          .delegatorState(delegatorAddress)\n          .then((newState) =&gt; {\n            if (newState.isSome) {\n              const state = newState.unwrap();\n              const updatedDelegation = state.delegations.find(\n                (d) =&gt;\n                  d.owner.toString().toLowerCase() ===\n                  candidateAddress.toLowerCase()\n              );\n              if (updatedDelegation) {\n                console.log(\n                  '\\nNew delegation amount:',\n                  updatedDelegation.amount.toString()\n                );\n              } else {\n                console.log('\\nDelegation has been fully revoked');\n              }\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in executing delegation request:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> executeLeaveCandidates(candidate, candidateDelegationCount) - executes any scheduled due requests to leave the set of collator candidates ParametersPolkadot.js API Example <ul> <li><code>candidate</code> - The address of the collator who requested to leave the candidate pool</li> <li><code>candidateDelegationCount</code> - The current number of delegations for the leaving candidate</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup executor account from private key (this can be any account)\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const executor = keyring.addFromUri(PRIVATE_KEY);\n\n    // The candidate's address who is scheduled to leave\n    const candidateAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    // Get candidate information and delegation count\n    const candidateInfo =\n      await api.query.parachainStaking.candidateInfo(candidateAddress);\n    let candidateDelegationCount = 0;\n\n    console.log('Execution Details:');\n    console.log('Executor address:', executor.address);\n    console.log('Candidate address:', candidateAddress);\n\n    if (candidateInfo.isSome) {\n      const info = candidateInfo.unwrap();\n      candidateDelegationCount = info.delegationCount;\n      console.log('\\nCandidate Information:');\n      console.log('Current bond:', info.bond.toString());\n      console.log('Delegation count:', candidateDelegationCount.toString());\n      console.log('Status:', info.status.toString());\n    } else {\n      console.log('\\nWarning: Candidate info not found');\n    }\n\n    // Create the execute leave candidates transaction\n    const tx = api.tx.parachainStaking.executeLeaveCandidates(\n      candidateAddress,\n      candidateDelegationCount\n    );\n\n    // Sign and send the transaction\n    await tx.signAndSend(executor, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful execution of leave request\n          if (section === 'parachainStaking' &amp;&amp; method === 'CandidateLeft') {\n            const [candidate, amount, remainingCount] = data;\n            console.log('\\nSuccessfully executed leave candidates request!');\n            console.log('Candidate:', candidate.toString());\n            console.log('Amount unlocked:', amount.toString());\n            console.log('Remaining candidates:', remainingCount.toString());\n          }\n        });\n\n        // Query final candidate state\n        api.query.parachainStaking\n          .candidateInfo(candidateAddress)\n          .then((finalState) =&gt; {\n            if (finalState.isNone) {\n              console.log(\n                '\\nCandidate has been successfully removed from the candidate pool'\n              );\n            } else {\n              console.log('\\nWarning: Candidate still exists in the pool');\n              console.log('Current state:', finalState.unwrap().toString());\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in executing leave candidates request:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> goOffline() - allows a collator candidate to temporarily leave the pool of candidates without unbonding ParametersPolkadot.js API Example <p>None</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup collator account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const collator = keyring.addFromUri(PRIVATE_KEY);\n\n    // Query current collator info before going offline\n    const candidateInfo = await api.query.parachainStaking.candidateInfo(\n      collator.address\n    );\n\n    console.log('Collator Details:');\n    console.log('Collator address:', collator.address);\n\n    if (candidateInfo.isSome) {\n      const info = candidateInfo.unwrap();\n      console.log('\\nCurrent Status:');\n      console.log('Bond:', info.bond.toString());\n      console.log('Delegation Count:', info.delegationCount.toString());\n      console.log('Status:', info.status.toString());\n    } else {\n      console.log('\\nWarning: Not found in candidate pool');\n      process.exit(1);\n    }\n\n    // Create the go offline transaction\n    const tx = api.tx.parachainStaking.goOffline();\n\n    // Sign and send the transaction\n    await tx.signAndSend(collator, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful offline status change\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'CandidateWentOffline'\n          ) {\n            const [collatorAccount] = data;\n            console.log('\\nSuccessfully went offline!');\n            console.log('Collator:', collatorAccount.toString());\n          }\n        });\n\n        // Query final collator state\n        api.query.parachainStaking\n          .candidateInfo(collator.address)\n          .then((finalState) =&gt; {\n            if (finalState.isSome) {\n              const info = finalState.unwrap();\n              console.log('\\nUpdated Status:');\n              console.log('Bond:', info.bond.toString());\n              console.log('Delegation Count:', info.delegationCount.toString());\n              console.log('Status:', info.status.toString());\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in going offline:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> goOnline() - allows a collator candidate to rejoin the pool of candidates after previously calling <code>goOffline()</code> ParametersPolkadot.js API Example <p>None</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup collator account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const collator = keyring.addFromUri(PRIVATE_KEY);\n\n    // Query current collator info before going online\n    const candidateInfo = await api.query.parachainStaking.candidateInfo(\n      collator.address\n    );\n\n    console.log('Collator Details:');\n    console.log('Collator address:', collator.address);\n\n    if (candidateInfo.isSome) {\n      const info = candidateInfo.unwrap();\n      console.log('\\nCurrent Status:');\n      console.log('Bond:', info.bond.toString());\n      console.log('Delegation Count:', info.delegationCount.toString());\n      console.log('Status:', info.status.toString());\n    } else {\n      console.log('\\nWarning: Not found in candidate pool');\n      process.exit(1);\n    }\n\n    // Create the go online transaction\n    const tx = api.tx.parachainStaking.goOnline();\n\n    // Sign and send the transaction\n    await tx.signAndSend(collator, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful online status change\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'CandidateBackOnline'\n          ) {\n            const [collatorAccount] = data;\n            console.log('\\nSuccessfully went back online!');\n            console.log('Collator:', collatorAccount.toString());\n          }\n        });\n\n        // Query final collator state\n        api.query.parachainStaking\n          .candidateInfo(collator.address)\n          .then((finalState) =&gt; {\n            if (finalState.isSome) {\n              const info = finalState.unwrap();\n              console.log('\\nUpdated Status:');\n              console.log('Bond:', info.bond.toString());\n              console.log('Delegation Count:', info.delegationCount.toString());\n              console.log('Status:', info.status.toString());\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in going online:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> joinCandidates(bond, candidateCount) - request to join the set of collator candidates with a specified bond amount and provided the current candidate count ParametersPolkadot.js API Example <ul> <li><code>bond</code> - The amount to stake as collator bond (in Wei, e.g. 500000000000000000000 for 500 DEV)</li> <li><code>candidateCount</code> - The total number of candidates currently in the candidate pool</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const account = keyring.addFromUri(PRIVATE_KEY);\n\n    // Set bond amount to 500 DEV (multiply by 10^18 for proper decimals)\n    const bondAmount = '500000000000000000000';\n\n    // Get current candidate count\n    const candidates = await api.query.parachainStaking.candidatePool();\n    const candidateCount = candidates.length;\n\n    // Check account balance\n    const balance = await api.query.system.account(account.address);\n\n    console.log('Join Candidates Details:');\n    console.log('Account address:', account.address);\n    console.log('Current free balance:', balance.data.free.toString());\n    console.log('Bond amount:', bondAmount, '(501 DEV)');\n    console.log('Current candidate count:', candidateCount);\n\n    // Create the join candidates transaction\n    const tx = api.tx.parachainStaking.joinCandidates(\n      bondAmount,\n      candidateCount\n    );\n\n    // Sign and send the transaction\n    await tx.signAndSend(account, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful joining\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'JoinedCollatorCandidates'\n          ) {\n            const [account, amountLocked, newTotalAmountLocked] = data;\n            console.log('\\nSuccessfully joined collator candidates!');\n            console.log('Account:', account.toString());\n            console.log('Amount locked:', amountLocked.toString());\n            console.log(\n              'New total amount locked:',\n              newTotalAmountLocked.toString()\n            );\n          }\n        });\n\n        // Query final candidate state\n        api.query.parachainStaking\n          .candidateInfo(account.address)\n          .then((finalState) =&gt; {\n            if (finalState.isSome) {\n              const info = finalState.unwrap();\n              console.log('\\nNew Candidate Status:');\n              console.log('Bond:', info.bond.toString());\n              console.log('Delegation Count:', info.delegationCount.toString());\n              console.log('Status:', info.status.toString());\n            }\n\n            // Get updated candidate count\n            api.query.parachainStaking.candidatePool().then((newCandidates) =&gt; {\n              console.log('New candidate count:', newCandidates.length);\n              process.exit(0);\n            });\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in joining candidates:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> notifyInactiveCollator(collator) - marks a collator as inactive if they have not been producing blocks for the maximum number of offline rounds, as returned by the <code>maxOfflineRounds</code> pallet constant ParametersPolkadot.js API Example <ul> <li><code>collator</code> - the address of the collator to be notified</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup notifier account from private key (this can be any account)\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const notifier = keyring.addFromUri(PRIVATE_KEY);\n\n    // The potentially inactive collator's address\n    const inactiveCollator = 'INSERT_COLLATOR_ADDRESS';\n\n    // Get max offline rounds from constants\n    const maxOfflineRounds = await api.consts.parachainStaking.maxOfflineRounds;\n\n    // Get current round info\n    const round = await api.query.parachainStaking.round();\n\n    // Get collator info\n    const collatorInfo =\n      await api.query.parachainStaking.candidateInfo(inactiveCollator);\n\n    console.log('Notify Inactive Collator Details:');\n    console.log('Notifier address:', notifier.address);\n    console.log('Inactive collator address:', inactiveCollator);\n    console.log('Maximum allowed offline rounds:', maxOfflineRounds.toString());\n    console.log('Current round:', round.current.toString());\n\n    if (collatorInfo.isSome) {\n      const info = collatorInfo.unwrap();\n      console.log('\\nCollator Current Status:');\n      console.log('Bond:', info.bond.toString());\n      console.log('Delegation Count:', info.delegationCount.toString());\n      console.log('Status:', info.status.toString());\n    }\n\n    // Create the notify inactive collator transaction\n    const tx = api.tx.parachainStaking.notifyInactiveCollator(inactiveCollator);\n\n    // Sign and send the transaction\n    await tx.signAndSend(notifier, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful notification\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'CollatorWentOffline'\n          ) {\n            const [collatorAccount] = data;\n            console.log('\\nSuccessfully notified inactive collator!');\n            console.log('Collator:', collatorAccount.toString());\n          }\n        });\n\n        // Query final collator state\n        api.query.parachainStaking\n          .candidateInfo(inactiveCollator)\n          .then((finalState) =&gt; {\n            if (finalState.isSome) {\n              const info = finalState.unwrap();\n              console.log('\\nUpdated Collator Status:');\n              console.log('Bond:', info.bond.toString());\n              console.log('Delegation Count:', info.delegationCount.toString());\n              console.log('Status:', info.status.toString());\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in notifying inactive collator:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> scheduleCandidateBondLess(less) - schedules a request to decrease a candidate's self bond by a specified amount. There is an exit delay that must be waited before you can execute the request via the <code>executeCandidateBondLess</code> extrinsic ParametersPolkadot.js API Example <ul> <li><code>less</code> - The amount you want to decrease your delegation by (in Wei, e.g. 1000000000000000000 for 1 DEV)</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup candidate account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const candidate = keyring.addFromUri(PRIVATE_KEY);\n\n    // Amount to decrease bond by (e.g., 1 DEV = 1_000_000_000_000_000_000)\n    const decreaseAmount = '1000000000000000000'; // 1 DEV\n\n    // Get current candidate info\n    const candidateInfo = await api.query.parachainStaking.candidateInfo(\n      candidate.address\n    );\n\n    console.log('Schedule Bond Decrease Details:');\n    console.log('Candidate address:', candidate.address);\n    console.log('Bond decrease amount:', decreaseAmount, 'Wei (1 DEV)');\n\n    if (candidateInfo.isSome) {\n      const info = candidateInfo.unwrap();\n      console.log('\\nCurrent Candidate Status:');\n      console.log('Current bond:', info.bond.toString());\n      console.log('Delegation Count:', info.delegationCount.toString());\n      console.log('Status:', info.status.toString());\n    } else {\n      console.log('\\nWarning: Account is not a candidate');\n      process.exit(1);\n    }\n\n    // Create the schedule bond decrease transaction\n    const tx =\n      api.tx.parachainStaking.scheduleCandidateBondLess(decreaseAmount);\n\n    // Get current round\n    const round = await api.query.parachainStaking.round();\n    const currentRound = round.current.toNumber();\n\n    // Sign and send the transaction\n    await tx.signAndSend(candidate, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful scheduling\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'CandidateBondLessRequested'\n          ) {\n            const [candidate, amountToDecrease, executeRound] = data;\n            console.log('\\nSuccessfully scheduled bond decrease!');\n            console.log('Candidate:', candidate.toString());\n            console.log('Amount to decrease:', amountToDecrease.toString());\n            console.log('Execute round:', executeRound.toString());\n            console.log(\n              `\\nNote: You must wait until round ${executeRound.toString()} to execute the decrease request`\n            );\n          }\n        });\n\n        // Query final candidate state\n        api.query.parachainStaking\n          .candidateInfo(candidate.address)\n          .then((finalState) =&gt; {\n            if (finalState.isSome) {\n              const info = finalState.unwrap();\n              console.log('\\nUpdated Candidate Status:');\n              console.log('Bond:', info.bond.toString());\n              console.log('Delegation Count:', info.delegationCount.toString());\n              console.log('Status:', info.status.toString());\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in scheduling bond decrease:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> scheduleDelegatorBondLess(candidate, less) - schedules a request for a delegator to bond less with respect to a specific candidate. There is an exit delay that must be waited before you can execute the request via the <code>executeDelegationRequest</code> extrinsic ParametersPolkadot.js API Example <ul> <li><code>candidate</code> - The collator's address for which you want to decrease your delegation</li> <li><code>less</code> - The amount you want to decrease your delegation by (in Wei, e.g. 1000000000000000000 for 1 DEV)</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup delegator account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const delegator = keyring.addFromUri(PRIVATE_KEY);\n\n    // The candidate's address to decrease delegation for\n    const candidateAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    // Amount to decrease delegation by (e.g., 1 DEV = 1_000_000_000_000_000_000)\n    const decreaseAmount = '1000000000000000000'; // 1 DEV\n\n    // Get current delegation info\n    const delegatorState = await api.query.parachainStaking.delegatorState(\n      delegator.address\n    );\n\n    console.log('Schedule Delegation Decrease Details:');\n    console.log('Delegator address:', delegator.address);\n    console.log('Candidate address:', candidateAddress);\n    console.log('Amount to decrease:', decreaseAmount, 'Wei (1 DEV)');\n\n    if (delegatorState.isSome) {\n      const state = delegatorState.unwrap();\n      const currentDelegation = state.delegations.find(\n        (d) =&gt;\n          d.owner.toString().toLowerCase() === candidateAddress.toLowerCase()\n      );\n      if (currentDelegation) {\n        console.log(\n          '\\nCurrent Delegation Amount:',\n          currentDelegation.amount.toString()\n        );\n      } else {\n        console.log(\n          '\\nWarning: No existing delegation found for this candidate'\n        );\n        process.exit(1);\n      }\n    } else {\n      console.log('\\nWarning: Account is not a delegator');\n      process.exit(1);\n    }\n\n    // Get current round\n    const round = await api.query.parachainStaking.round();\n    console.log('Current round:', round.current.toString());\n\n    // Create the schedule decrease transaction\n    const tx = api.tx.parachainStaking.scheduleDelegatorBondLess(\n      candidateAddress,\n      decreaseAmount\n    );\n\n    // Sign and send the transaction\n    await tx.signAndSend(delegator, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful scheduling\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'DelegationDecreaseScheduled'\n          ) {\n            const [delegator, candidate, amountToDecrease, executeRound] = data;\n            console.log('\\nSuccessfully scheduled delegation decrease!');\n            console.log('Delegator:', delegator.toString());\n            console.log('Candidate:', candidate.toString());\n            console.log('Amount to decrease:', amountToDecrease.toString());\n            console.log('Execute round:', executeRound.toString());\n            console.log(\n              `\\nNote: You must wait until round ${executeRound.toString()} to execute the decrease request`\n            );\n          }\n        });\n\n        // Query final delegation state\n        api.query.parachainStaking\n          .delegatorState(delegator.address)\n          .then((finalState) =&gt; {\n            if (finalState.isSome) {\n              const state = finalState.unwrap();\n              const updatedDelegation = state.delegations.find(\n                (d) =&gt;\n                  d.owner.toString().toLowerCase() ===\n                  candidateAddress.toLowerCase()\n              );\n              if (updatedDelegation) {\n                console.log('\\nCurrent Delegation Status:');\n                console.log('Amount:', updatedDelegation.amount.toString());\n                console.log(\n                  'Note: Amount will decrease after execution in the scheduled round'\n                );\n              }\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in scheduling delegation decrease:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> scheduleLeaveCandidates(candidateCount) - schedules a request for a candidate to remove themselves from the candidate pool. There is an exit delay that must be waited before you can execute the request via the <code>executeLeaveCandidates</code> extrinsic ParametersPolkadot.js API Example <ul> <li><code>candidateCount</code> - The total number of candidates currently in the candidate pool</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup collator account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const collator = keyring.addFromUri(PRIVATE_KEY);\n\n    // Get current candidate pool information\n    const candidates = await api.query.parachainStaking.candidatePool();\n    const candidateCount = candidates.length;\n\n    // Get current candidate info\n    const candidateInfo = await api.query.parachainStaking.candidateInfo(\n      collator.address\n    );\n\n    console.log('Schedule Leave Details:');\n    console.log('Collator address:', collator.address);\n    console.log('Current candidate count:', candidateCount);\n\n    if (candidateInfo.isSome) {\n      const info = candidateInfo.unwrap();\n      console.log('\\nCurrent Candidate Status:');\n      console.log('Bond:', info.bond.toString());\n      console.log('Delegation Count:', info.delegationCount.toString());\n      console.log('Status:', info.status.toString());\n    } else {\n      console.log('\\nWarning: Account is not a candidate');\n      process.exit(1);\n    }\n\n    // Create the schedule leave transaction\n    const tx = api.tx.parachainStaking.scheduleLeaveCandidates(candidateCount);\n\n    // Get the current round\n    const round = await api.query.parachainStaking.round();\n    const currentRound = round.current.toNumber();\n\n    // Sign and send the transaction\n    await tx.signAndSend(collator, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful scheduling\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'CandidateScheduledExit'\n          ) {\n            const [round, candidate, scheduledExit] = data;\n            console.log('\\nSuccessfully scheduled leave candidates!');\n            console.log('Candidate:', candidate.toString());\n            console.log('Current round:', round.toString());\n            console.log('Scheduled exit round:', scheduledExit.toString());\n            console.log(\n              `\\nNote: You must wait until round ${scheduledExit.toString()} to execute the leave request`\n            );\n          }\n        });\n\n        // Query final candidate state\n        api.query.parachainStaking\n          .candidateInfo(collator.address)\n          .then((finalState) =&gt; {\n            if (finalState.isSome) {\n              const info = finalState.unwrap();\n              console.log('\\nUpdated Candidate Status:');\n              console.log('Bond:', info.bond.toString());\n              console.log('Delegation Count:', info.delegationCount.toString());\n              console.log(\n                'Status:',\n                info.status.toString(),\n                '(Leaving status shows the exit round)'\n              );\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in scheduling leave candidates:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> scheduleRevokeDelegation(collator) - schedules a request to revoke a delegation given the address of a candidate. There is an exit delay that must be waited before you can execute the request via the <code>executeDelegationRequest</code> extrinsic ParametersPolkadot.js API Example <ul> <li><code>collator</code> - The collator's address from which you want to revoke your delegation</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup delegator account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const delegator = keyring.addFromUri(PRIVATE_KEY);\n\n    // The collator's address to revoke delegation from\n    const collatorAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    // Get current delegation info\n    const delegatorState = await api.query.parachainStaking.delegatorState(\n      delegator.address\n    );\n\n    console.log('Schedule Revoke Delegation Details:');\n    console.log('Delegator address:', delegator.address);\n    console.log('Collator address:', collatorAddress);\n\n    if (delegatorState.isSome) {\n      const state = delegatorState.unwrap();\n      const currentDelegation = state.delegations.find(\n        (d) =&gt;\n          d.owner.toString().toLowerCase() === collatorAddress.toLowerCase()\n      );\n      if (currentDelegation) {\n        console.log(\n          '\\nCurrent Delegation Amount:',\n          currentDelegation.amount.toString()\n        );\n      } else {\n        console.log(\n          '\\nWarning: No existing delegation found for this collator'\n        );\n        process.exit(1);\n      }\n    } else {\n      console.log('\\nWarning: Account is not a delegator');\n      process.exit(1);\n    }\n\n    // Get current round\n    const round = await api.query.parachainStaking.round();\n    console.log('Current round:', round.current.toString());\n\n    // Create the schedule revoke transaction\n    const tx =\n      api.tx.parachainStaking.scheduleRevokeDelegation(collatorAddress);\n\n    // Sign and send the transaction\n    await tx.signAndSend(delegator, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful scheduling\n          if (\n            section === 'parachainStaking' &amp;&amp;\n            method === 'DelegationRevocationScheduled'\n          ) {\n            const [round, delegator, candidate, executeRound] = data;\n            console.log('\\nSuccessfully scheduled delegation revocation!');\n            console.log('Round:', round.toString());\n            console.log('Delegator:', delegator.toString());\n            console.log('Collator:', candidate.toString());\n            console.log('Execute round:', executeRound.toString());\n            console.log(\n              `\\nNote: You must wait until round ${executeRound.toString()} to execute the revocation request`\n            );\n          }\n        });\n\n        // Query final delegation state\n        api.query.parachainStaking\n          .delegatorState(delegator.address)\n          .then((finalState) =&gt; {\n            if (finalState.isSome) {\n              const state = finalState.unwrap();\n              const updatedDelegation = state.delegations.find(\n                (d) =&gt;\n                  d.owner.toString().toLowerCase() ===\n                  collatorAddress.toLowerCase()\n              );\n              if (updatedDelegation) {\n                console.log('\\nCurrent Delegation Status:');\n                console.log('Amount:', updatedDelegation.amount.toString());\n                console.log(\n                  'Note: Delegation will be fully revoked after execution in the scheduled round'\n                );\n              }\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in scheduling delegation revocation:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> setAutoCompound(candidate, value, candidateAutoCompoundingDelegationCountHint, delegationCountHint) - sets the percentage of rewards to be auto-compounded for an existing delegation given an integer (no decimals) for the <code>value</code> between 0-100 ParametersPolkadot.js API Example <ul> <li><code>candidate</code> - The collator's address you're delegating to</li> <li><code>value</code> - Auto-compound percentage (0-100)</li> <li><code>candidateAutoCompoundingDelegationCountHint</code> - Number of auto-compounding delegations for this collator</li> <li><code>delegationCountHint</code> - Total number of delegations you have across all collators</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Keyring } from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  // Initialize the keyring with ethereum type\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  try {\n    // Setup delegator account from private key\n    const PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\n    const delegator = keyring.addFromUri(PRIVATE_KEY);\n\n    // The candidate's address for the delegation\n    const candidateAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    // Auto-compound percentage (0-100)\n    const autoCompoundValue = 50; // 50% of rewards will be auto-compounded\n\n    // Get auto-compounding delegations count\n    const autoCompoundDelegations =\n      await api.query.parachainStaking.autoCompoundingDelegations(\n        candidateAddress\n      );\n    const candidateAutoCompoundingDelegationCount =\n      autoCompoundDelegations.length;\n\n    // Get delegator state for delegation count\n    const delegatorState = await api.query.parachainStaking.delegatorState(\n      delegator.address\n    );\n    let delegationCount = 0;\n\n    console.log('Set Auto-Compound Details:');\n    console.log('Delegator address:', delegator.address);\n    console.log('Candidate address:', candidateAddress);\n    console.log('Auto-compound percentage:', autoCompoundValue, '%');\n\n    if (delegatorState.isSome) {\n      const state = delegatorState.unwrap();\n      delegationCount = state.delegations.length;\n      const currentDelegation = state.delegations.find(\n        (d) =&gt;\n          d.owner.toString().toLowerCase() === candidateAddress.toLowerCase()\n      );\n      if (currentDelegation) {\n        console.log(\n          '\\nCurrent Delegation Amount:',\n          currentDelegation.amount.toString()\n        );\n      } else {\n        console.log(\n          '\\nWarning: No existing delegation found for this candidate'\n        );\n        process.exit(1);\n      }\n    } else {\n      console.log('\\nWarning: Account is not a delegator');\n      process.exit(1);\n    }\n\n    console.log('\\nDelegation Counts:');\n    console.log(\n      'Auto-compounding delegations:',\n      candidateAutoCompoundingDelegationCount\n    );\n    console.log('Total delegations:', delegationCount);\n\n    // Create the set auto-compound transaction\n    const tx = api.tx.parachainStaking.setAutoCompound(\n      candidateAddress,\n      autoCompoundValue,\n      candidateAutoCompoundingDelegationCount,\n      delegationCount\n    );\n\n    // Sign and send the transaction\n    await tx.signAndSend(delegator, ({ status, events }) =&gt; {\n      if (status.isInBlock) {\n        console.log(\n          `\\nTransaction included in block hash: ${status.asInBlock}`\n        );\n\n        // Process events\n        events.forEach(({ event }) =&gt; {\n          const { section, method, data } = event;\n          console.log(`\\t${section}.${method}:`, data.toString());\n\n          // Handle any failures\n          if (section === 'system' &amp;&amp; method === 'ExtrinsicFailed') {\n            const [dispatchError] = data;\n            let errorInfo;\n\n            if (dispatchError.isModule) {\n              const decoded = api.registry.findMetaError(\n                dispatchError.asModule\n              );\n              errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;\n            } else {\n              errorInfo = dispatchError.toString();\n            }\n            console.error('Failure reason:', errorInfo);\n          }\n\n          // Log successful auto-compound setting\n          if (section === 'parachainStaking' &amp;&amp; method === 'AutoCompoundSet') {\n            const [candidate, delegator, value] = data;\n            console.log('\\nSuccessfully set auto-compound percentage!');\n            console.log('Candidate:', candidate.toString());\n            console.log('Delegator:', delegator.toString());\n            console.log('Auto-compound value:', value.toString(), '%');\n          }\n        });\n\n        // Query updated auto-compound settings\n        api.query.parachainStaking\n          .autoCompoundingDelegations(candidateAddress)\n          .then((newAutoCompound) =&gt; {\n            const delegatorSetting = newAutoCompound.find(\n              (d) =&gt;\n                d.delegator.toString().toLowerCase() ===\n                delegator.address.toLowerCase()\n            );\n            if (delegatorSetting) {\n              console.log('\\nUpdated Auto-Compound Setting:');\n              console.log('Value:', delegatorSetting.value.toString(), '%');\n            }\n            process.exit(0);\n          });\n      }\n    });\n  } catch (error) {\n    console.error('Error in setting auto-compound:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"builders/substrate/interfaces/features/staking/#storage-methods","title":"Storage Methods","text":"<p>The parachain staking pallet includes the following read-only storage methods to obtain chain state data:</p> atStake(u32, AccountId20) - provides a snapshot of a collator's delegation stake and the percentage of rewards set to auto-compound given a round number and, optionally, the collator's address ParametersReturnsPolkadot.js API Example <ul> <li><code>u32</code> - round number</li> <li><code>AccountId20</code> - collator address to query. If omitted, information about all collators will be returned</li> </ul> <p>Information about a collator's delegations including delegator addresses, amounts, and auto-compound percentages</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get current round information\n    const round = await api.query.parachainStaking.round();\n    const currentRound = round.current.toNumber();\n\n    // Example collator address\n    const collatorAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    console.log('Query Parameters:');\n    console.log('Current round:', currentRound);\n    console.log('Collator address:', collatorAddress);\n\n    // Query current round\n    console.log('\\nQuerying current round stake...');\n    const currentStake = await api.query.parachainStaking.atStake(\n      currentRound,\n      collatorAddress\n    );\n\n    if (currentStake) {\n      console.log('\\nCurrent Round Stake Details:');\n      const stakeInfo = currentStake.toHuman();\n      console.log(JSON.stringify(stakeInfo, null, 2));\n\n      // Get raw values for calculations if needed\n      const rawStake = currentStake.toJSON();\n      console.log('\\nRaw Stake Values:');\n      console.log('Total stake:', rawStake.total);\n      console.log('Own stake:', rawStake.bond);\n    }\n\n    // Query previous round\n    const previousRound = currentRound - 1;\n    console.log('\\nQuerying previous round stake...');\n    const previousStake = await api.query.parachainStaking.atStake(\n      previousRound,\n      collatorAddress\n    );\n\n    if (previousStake) {\n      console.log('\\nPrevious Round Stake Details:');\n      const previousStakeInfo = previousStake.toHuman();\n      console.log(JSON.stringify(previousStakeInfo, null, 2));\n    }\n\n    // Get scheduled delegation requests\n    const delegationRequests =\n      await api.query.parachainStaking.delegationScheduledRequests(\n        collatorAddress\n      );\n\n    console.log('\\nScheduled Delegation Changes:');\n    if (delegationRequests.length &gt; 0) {\n      console.log(JSON.stringify(delegationRequests.toHuman(), null, 2));\n    } else {\n      console.log('No scheduled delegation changes');\n    }\n\n    // Get auto-compound settings\n    const autoCompound =\n      await api.query.parachainStaking.autoCompoundingDelegations(\n        collatorAddress\n      );\n\n    console.log('\\nAuto-Compound Settings:');\n    if (autoCompound.length &gt; 0) {\n      console.log(JSON.stringify(autoCompound.toHuman(), null, 2));\n    } else {\n      console.log('No auto-compound settings found');\n    }\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying at stake:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> autoCompoundingDelegations(AccountId20) - returns a list of delegators for a given candidate that have set up auto-compounding along with the percentage of rewards set to be auto-compounded ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> - the collator address to query. If omitted, information about all collators will be returned</li> </ul> <p>The list of delegators who have auto-compounding enabled and the respective percentage of rewards they have set to be auto-compounded</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Example candidate address\n    const candidateAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    console.log('Query Parameters:');\n    console.log('Candidate address:', candidateAddress);\n\n    // Query auto-compounding delegations\n    const autoCompoundDelegations =\n      await api.query.parachainStaking.autoCompoundingDelegations(\n        candidateAddress\n      );\n\n    // Get candidate info\n    const candidateInfo =\n      await api.query.parachainStaking.candidateInfo(candidateAddress);\n\n    if (candidateInfo.isSome) {\n      const info = candidateInfo.unwrap();\n      console.log('\\nCandidate Information:');\n      console.log('Total delegations:', info.delegationCount.toString());\n      console.log('Bond amount:', info.bond.toString());\n    }\n\n    console.log('\\nAuto-Compounding Delegations:');\n    if (autoCompoundDelegations.length &gt; 0) {\n      console.log(\n        'Total auto-compounding delegators:',\n        autoCompoundDelegations.length\n      );\n\n      // Display each auto-compounding delegation\n      autoCompoundDelegations.forEach((delegation, index) =&gt; {\n        const { delegator, value } = delegation;\n        console.log(`\\nDelegator #${index + 1}:`);\n        console.log('Address:', delegator.toString());\n        console.log('Auto-compound percentage:', value.toString(), '%');\n      });\n\n      // Get more detailed information for each delegator\n      console.log('\\nDetailed Delegation Information:');\n      for (const delegation of autoCompoundDelegations) {\n        const delegatorState = await api.query.parachainStaking.delegatorState(\n          delegation.delegator\n        );\n        if (delegatorState.isSome) {\n          const state = delegatorState.unwrap();\n          const specificDelegation = state.delegations.find(\n            (d) =&gt;\n              d.owner.toString().toLowerCase() ===\n              candidateAddress.toLowerCase()\n          );\n\n          if (specificDelegation) {\n            console.log(`\\nDelegator ${delegation.delegator.toString()}:`);\n            console.log(\n              'Delegation amount:',\n              specificDelegation.amount.toString()\n            );\n            console.log(\n              'Auto-compound value:',\n              delegation.value.toString(),\n              '%'\n            );\n          }\n        }\n      }\n\n      // Calculate some statistics\n      const averageCompounding =\n        autoCompoundDelegations.reduce(\n          (acc, curr) =&gt; acc + curr.value.toNumber(),\n          0\n        ) / autoCompoundDelegations.length;\n      console.log('\\nStatistics:');\n      console.log(\n        'Average auto-compound percentage:',\n        averageCompounding.toFixed(2),\n        '%'\n      );\n\n      const maxCompounding = Math.max(\n        ...autoCompoundDelegations.map((d) =&gt; d.value.toNumber())\n      );\n      const minCompounding = Math.min(\n        ...autoCompoundDelegations.map((d) =&gt; d.value.toNumber())\n      );\n      console.log('Highest auto-compound setting:', maxCompounding, '%');\n      console.log('Lowest auto-compound setting:', minCompounding, '%');\n    } else {\n      console.log('No auto-compounding delegations found for this candidate');\n    }\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying auto-compounding delegations:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> awardedPts(u32, AccountId20) - returns the awarded points for each collator per round given a round number and, optionally, the collator's address ParametersReturnsPolkadot.js API Example <ul> <li><code>u32</code> - the round number</li> <li><code>AccountId20</code> - the collator to query. If omitted, information about all collators will be returned</li> </ul> <p>The number of awarded points for a given round and collator. </p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get current round information\n    const round = await api.query.parachainStaking.round();\n    const currentRound = round.current.toNumber();\n\n    // Example collator address - you can set this to null to query all collators\n    const collatorAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    // Query several recent rounds\n    const roundsToQuery = 5;\n    const rounds = Array.from(\n      { length: roundsToQuery },\n      (_, i) =&gt; currentRound - i\n    );\n\n    console.log('Query Parameters:');\n    console.log('Current round:', currentRound);\n    console.log('Collator address:', collatorAddress || 'All collators');\n    console.log(`Querying last ${roundsToQuery} rounds:`, rounds);\n\n    // Store points data for analysis\n    const pointsData = {};\n\n    // Query points for each round\n    for (const roundNumber of rounds) {\n      let roundPoints;\n\n      if (collatorAddress) {\n        // Query specific collator\n        roundPoints = await api.query.parachainStaking.awardedPts(\n          roundNumber,\n          collatorAddress\n        );\n        console.log(\n          `\\nRound ${roundNumber} Points for ${collatorAddress}:`,\n          roundPoints.toString()\n        );\n\n        pointsData[roundNumber] = {\n          [collatorAddress]: roundPoints.toNumber(),\n        };\n      } else {\n        // Query all collators for this round\n        roundPoints =\n          await api.query.parachainStaking.awardedPts.entries(roundNumber);\n        console.log(`\\nRound ${roundNumber} Points:`);\n\n        pointsData[roundNumber] = {};\n\n        for (const [key, points] of roundPoints) {\n          const collator = key.args[1].toString();\n          const pointsValue = points.toNumber();\n          console.log(`Collator ${collator}: ${pointsValue} points`);\n\n          pointsData[roundNumber][collator] = pointsValue;\n        }\n      }\n    }\n\n    // Calculate statistics\n    console.log('\\nStatistics:');\n\n    if (collatorAddress) {\n      // Statistics for specific collator\n      const collatorPoints = rounds.map(\n        (r) =&gt; pointsData[r][collatorAddress] || 0\n      );\n      const totalPoints = collatorPoints.reduce((a, b) =&gt; a + b, 0);\n      const averagePoints = totalPoints / rounds.length;\n      const maxPoints = Math.max(...collatorPoints);\n      const minPoints = Math.min(...collatorPoints);\n\n      console.log(`\\nCollator ${collatorAddress}:`);\n      console.log('Total points:', totalPoints);\n      console.log('Average points per round:', averagePoints.toFixed(2));\n      console.log('Highest points:', maxPoints);\n      console.log('Lowest points:', minPoints);\n    } else {\n      // Statistics for all collators\n      const collators = new Set(\n        rounds.flatMap((r) =&gt; Object.keys(pointsData[r]))\n      );\n\n      for (const collator of collators) {\n        const collatorPoints = rounds.map((r) =&gt; pointsData[r][collator] || 0);\n        const totalPoints = collatorPoints.reduce((a, b) =&gt; a + b, 0);\n        const averagePoints = totalPoints / rounds.length;\n        const maxPoints = Math.max(...collatorPoints);\n        const minPoints = Math.min(...collatorPoints);\n\n        console.log(`\\nCollator ${collator}:`);\n        console.log('Total points:', totalPoints);\n        console.log('Average points per round:', averagePoints.toFixed(2));\n        console.log('Highest points:', maxPoints);\n        console.log('Lowest points:', minPoints);\n        console.log('Points history:', collatorPoints.join(', '));\n      }\n    }\n\n    // Get current selected candidates for context\n    const selectedCandidates =\n      await api.query.parachainStaking.selectedCandidates();\n    console.log('\\nCurrently Selected Candidates:', selectedCandidates.length);\n    console.log(selectedCandidates.map((c) =&gt; c.toString()).join('\\n'));\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying awarded points:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> bottomDelegations(AccountId20) - returns at the most the bottom 50 delegations for all candidates or for a given candidate's address ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> - the collator to query. If omitted, information about all collators will be returned</li> </ul> <p>The bottom 50 delegations for a given collator address</p> <pre><code> import { ApiPromise, WsProvider } from '@polkadot/api';\n\n const main = async () =&gt; {\n   // Initialize the API\n   const api = await ApiPromise.create({\n     provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n   });\n\n   try {\n     // Example candidate address\n     const candidateAddress = 'INSERT_COLLATOR_ADDRESS';\n\n     // Get candidate info first\n     const candidateInfo =\n       await api.query.parachainStaking.candidateInfo(candidateAddress);\n\n     console.log('Query Parameters:');\n     console.log('Candidate address:', candidateAddress);\n\n     if (candidateInfo.isSome) {\n       const info = candidateInfo.unwrap();\n       console.log('\\nCandidate Information:');\n       console.log('Total delegations:', info.delegationCount.toString());\n       console.log('Bond amount:', info.bond.toString(), 'Wei');\n     }\n\n     // Query bottom delegations\n     const bottomDelegations =\n       await api.query.parachainStaking.bottomDelegations(candidateAddress);\n\n     if (bottomDelegations.isSome) {\n       const delegations = bottomDelegations.unwrap();\n       console.log('\\nBottom Delegations:');\n       console.log(\n         'Total bottom delegations found:',\n         delegations.delegations.length\n       );\n\n       // Sort delegations by amount in descending order\n       const sortedDelegations = [...delegations.delegations].sort(\n         (a, b) =&gt; BigInt(b.amount) - BigInt(a.amount)\n       );\n\n       // Display each delegation\n       sortedDelegations.forEach((delegation, index) =&gt; {\n         console.log(`\\nDelegation #${index + 1}:`);\n         console.log('Delegator:', delegation.owner.toString());\n         console.log('Amount:', delegation.amount.toString(), 'Wei');\n         // Convert Wei to DEV (1 DEV = 10^18 Wei)\n         const devAmount = BigInt(delegation.amount) / BigInt(10 ** 18);\n         console.log('Amount in DEV:', devAmount.toString(), 'DEV');\n       });\n\n       // Calculate some statistics\n       if (sortedDelegations.length &gt; 0) {\n         const total = sortedDelegations.reduce(\n           (acc, curr) =&gt; acc + BigInt(curr.amount),\n           BigInt(0)\n         );\n         const average = total / BigInt(sortedDelegations.length);\n         const highest = sortedDelegations[0].amount;\n         const lowest = sortedDelegations[sortedDelegations.length - 1].amount;\n\n         console.log('\\nStatistics:');\n         console.log('Total delegated in bottom:', total.toString(), 'Wei');\n         console.log('Average delegation:', average.toString(), 'Wei');\n         console.log('Highest bottom delegation:', highest.toString(), 'Wei');\n         console.log('Lowest bottom delegation:', lowest.toString(), 'Wei');\n\n         // Show in DEV for readability\n         console.log('\\nStatistics (in DEV):');\n         console.log(\n           'Total delegated:',\n           (BigInt(total) / BigInt(10 ** 18)).toString(),\n           'DEV'\n         );\n         console.log(\n           'Average delegation:',\n           (BigInt(average) / BigInt(10 ** 18)).toString(),\n           'DEV'\n         );\n         console.log(\n           'Highest bottom delegation:',\n           (BigInt(highest) / BigInt(10 ** 18)).toString(),\n           'DEV'\n         );\n         console.log(\n           'Lowest bottom delegation:',\n           (BigInt(lowest) / BigInt(10 ** 18)).toString(),\n           'DEV'\n         );\n       }\n\n       // Get top delegations for comparison\n       const topDelegations =\n         await api.query.parachainStaking.topDelegations(candidateAddress);\n       if (topDelegations.isSome) {\n         const top = topDelegations.unwrap();\n         console.log('\\nComparison with Top Delegations:');\n         console.log('Number of top delegations:', top.delegations.length);\n         console.log('Number of bottom delegations:', sortedDelegations.length);\n\n         if (top.delegations.length &gt; 0) {\n           const lowestTop = top.delegations[top.delegations.length - 1].amount;\n           console.log('Lowest top delegation:', lowestTop.toString(), 'Wei');\n           console.log(\n             'Lowest top delegation in DEV:',\n             (BigInt(lowestTop) / BigInt(10 ** 18)).toString(),\n             'DEV'\n           );\n         }\n       }\n     } else {\n       console.log('\\nNo bottom delegations found for this candidate');\n     }\n\n     process.exit(0);\n   } catch (error) {\n     console.error('Error querying bottom delegations:', error);\n     process.exit(1);\n   }\n };\n\n // Execute the script\n main().catch((error) =&gt; {\n   console.error('Script error:', error);\n   process.exit(1);\n });\n</code></pre> candidateInfo(AccountId20) - returns candidate information such as the candidate's bond, delegation count, and more for all candidates or for a given candidate's address ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> - The collator address to query. If omitted, information about all collators will be returned</li> </ul> <p>Information about the relevant collator including collator bond, total backing stake, delegation count, lowest included delegation amount, collator status, and capacity information</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Example candidate address\n    const candidateAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    console.log('Query Parameters:');\n    console.log('Candidate address:', candidateAddress);\n\n    // Query candidate info\n    const candidateInfo =\n      await api.query.parachainStaking.candidateInfo(candidateAddress);\n\n    if (candidateInfo.isSome) {\n      const info = candidateInfo.unwrap();\n\n      console.log('\\nCandidate Information:');\n      console.log('Bond:', info.bond.toString(), 'Wei');\n      console.log(\n        'Bond in DEV:',\n        (BigInt(info.bond) / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n      console.log('Delegation Count:', info.delegationCount.toString());\n      console.log('Status:', info.status.toString());\n      console.log(\n        'Lowest Top Delegation Amount:',\n        info.lowestTopDelegationAmount.toString(),\n        'Wei'\n      );\n      console.log(\n        'Lowest Top Delegation in DEV:',\n        (BigInt(info.lowestTopDelegationAmount) / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n      console.log(\n        'Highest Bottom Delegation Amount:',\n        info.highestBottomDelegationAmount.toString(),\n        'Wei'\n      );\n      console.log(\n        'Highest Bottom Delegation in DEV:',\n        (\n          BigInt(info.highestBottomDelegationAmount) / BigInt(10 ** 18)\n        ).toString(),\n        'DEV'\n      );\n      console.log(\n        'Lowest Bottom Delegation Amount:',\n        info.lowestBottomDelegationAmount.toString(),\n        'Wei'\n      );\n      console.log(\n        'Lowest Bottom Delegation in DEV:',\n        (\n          BigInt(info.lowestBottomDelegationAmount) / BigInt(10 ** 18)\n        ).toString(),\n        'DEV'\n      );\n      console.log('Top Capacity:', info.topCapacity.toString());\n      console.log('Bottom Capacity:', info.bottomCapacity.toString());\n\n      // Get additional context\n      const round = await api.query.parachainStaking.round();\n      console.log('\\nCurrent Round:', round.current.toString());\n\n      // Check if in selected candidates\n      const selectedCandidates =\n        await api.query.parachainStaking.selectedCandidates();\n      const isSelected = selectedCandidates.some(\n        (c) =&gt; c.toString() === candidateAddress\n      );\n      console.log('Is Selected Candidate:', isSelected);\n\n      // Get top delegations\n      const topDelegations =\n        await api.query.parachainStaking.topDelegations(candidateAddress);\n      if (topDelegations.isSome) {\n        const top = topDelegations.unwrap();\n        console.log('\\nTop Delegations Count:', top.delegations.length);\n        console.log('Total Top Delegated:', top.total.toString(), 'Wei');\n        console.log(\n          'Total Top Delegated in DEV:',\n          (BigInt(top.total) / BigInt(10 ** 18)).toString(),\n          'DEV'\n        );\n      }\n\n      // Get bottom delegations\n      const bottomDelegations =\n        await api.query.parachainStaking.bottomDelegations(candidateAddress);\n      if (bottomDelegations.isSome) {\n        const bottom = bottomDelegations.unwrap();\n        console.log('\\nBottom Delegations Count:', bottom.delegations.length);\n        console.log('Total Bottom Delegated:', bottom.total.toString(), 'Wei');\n        console.log(\n          'Total Bottom Delegated in DEV:',\n          (BigInt(bottom.total) / BigInt(10 ** 18)).toString(),\n          'DEV'\n        );\n      }\n\n      // Get auto-compounding delegations\n      const autoCompounding =\n        await api.query.parachainStaking.autoCompoundingDelegations(\n          candidateAddress\n        );\n      console.log(\n        '\\nAuto-compounding Delegations Count:',\n        autoCompounding.length\n      );\n\n      // Calculate some total statistics\n      const totalStake =\n        BigInt(info.bond) +\n        (topDelegations.isSome\n          ? BigInt(topDelegations.unwrap().total)\n          : BigInt(0)) +\n        (bottomDelegations.isSome\n          ? BigInt(bottomDelegations.unwrap().total)\n          : BigInt(0));\n\n      console.log('\\nTotal Statistics:');\n      console.log('Total Stake:', totalStake.toString(), 'Wei');\n      console.log(\n        'Total Stake in DEV:',\n        (totalStake / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n\n      // Check recent points (last 3 rounds)\n      console.log('\\nRecent Points:');\n      const currentRound = round.current.toNumber();\n      for (let i = 0; i &lt; 3; i++) {\n        const roundNumber = currentRound - i;\n        const points = await api.query.parachainStaking.awardedPts(\n          roundNumber,\n          candidateAddress\n        );\n        console.log(`Round ${roundNumber}: ${points.toString()} points`);\n      }\n    } else {\n      console.log('\\nNo candidate information found for this address');\n    }\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying candidate info:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> candidatePool() - returns a list of each of the candidates in the pool and their total backing stake ParametersReturnsPolkadot.js API Example <p>None</p> <p>A list of each of the candidates in the pool and their total backing stake</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get current round information\n    const round = await api.query.parachainStaking.round();\n    console.log('Current Round:', round.current.toString());\n\n    // Query candidate pool\n    const candidatePool = await api.query.parachainStaking.candidatePool();\n\n    console.log('\\nCandidate Pool Information:');\n    console.log('Total Candidates:', candidatePool.length);\n\n    // Sort candidates by amount, handling BigInt comparison correctly\n    const sortedCandidates = [...candidatePool].sort((a, b) =&gt; {\n      const amountA = BigInt(a.amount);\n      const amountB = BigInt(b.amount);\n      if (amountA &lt; amountB) return 1;\n      if (amountA &gt; amountB) return -1;\n      return 0;\n    });\n\n    // Get selected candidates for comparison\n    const selectedCandidates =\n      await api.query.parachainStaking.selectedCandidates();\n    const selectedSet = new Set(selectedCandidates.map((c) =&gt; c.toString()));\n\n    // Track total stake in pool\n    let totalStake = BigInt(0);\n\n    // Display each candidate's information\n    console.log('\\nDetailed Candidate Information:');\n    for (const [index, candidate] of sortedCandidates.entries()) {\n      const { owner, amount } = candidate;\n      totalStake += BigInt(amount);\n\n      // Get candidate info\n      const candidateInfo =\n        await api.query.parachainStaking.candidateInfo(owner);\n\n      console.log(`\\nCandidate #${index + 1}:`);\n      console.log('Address:', owner.toString());\n      console.log('Total Stake:', amount.toString(), 'Wei');\n      console.log(\n        'Total Stake in DEV:',\n        (BigInt(amount) / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n      console.log('Is Selected Collator:', selectedSet.has(owner.toString()));\n\n      if (candidateInfo.isSome) {\n        const info = candidateInfo.unwrap();\n        console.log('Self Bond:', info.bond.toString(), 'Wei');\n        console.log(\n          'Self Bond in DEV:',\n          (BigInt(info.bond) / BigInt(10 ** 18)).toString(),\n          'DEV'\n        );\n        console.log('Delegation Count:', info.delegationCount.toString());\n        console.log('Status:', info.status.toString());\n      }\n\n      // Get auto-compounding delegations count\n      const autoCompounding =\n        await api.query.parachainStaking.autoCompoundingDelegations(owner);\n      console.log('Auto-compounding Delegations:', autoCompounding.length);\n\n      // Get recent points (last 3 rounds)\n      const currentRound = round.current.toNumber();\n      let totalPoints = 0;\n      console.log('Recent Points:');\n      for (let i = 0; i &lt; 3; i++) {\n        const roundNumber = currentRound - i;\n        const points = await api.query.parachainStaking.awardedPts(\n          roundNumber,\n          owner\n        );\n        console.log(`  Round ${roundNumber}: ${points.toString()} points`);\n        totalPoints += points.toNumber();\n      }\n      console.log(\n        'Average Points (last 3 rounds):',\n        (totalPoints / 3).toFixed(2)\n      );\n    }\n\n    // Display pool statistics\n    console.log('\\nPool Statistics:');\n    console.log('Total Candidates:', candidatePool.length);\n    console.log('Selected Collators:', selectedCandidates.length);\n    console.log('Total Stake in Pool:', totalStake.toString(), 'Wei');\n    console.log(\n      'Total Stake in Pool (DEV):',\n      (totalStake / BigInt(10 ** 18)).toString(),\n      'DEV'\n    );\n    console.log(\n      'Average Stake per Candidate (DEV):',\n      (totalStake / BigInt(candidatePool.length) / BigInt(10 ** 18)).toString(),\n      'DEV'\n    );\n\n    // Calculate stake distribution\n    const stakes = sortedCandidates.map((c) =&gt; BigInt(c.amount));\n    const median = stakes[Math.floor(stakes.length / 2)];\n    const highest = stakes[0];\n    const lowest = stakes[stakes.length - 1];\n\n    console.log('\\nStake Distribution:');\n    console.log(\n      'Highest Stake (DEV):',\n      (highest / BigInt(10 ** 18)).toString()\n    );\n    console.log('Median Stake (DEV):', (median / BigInt(10 ** 18)).toString());\n    console.log('Lowest Stake (DEV):', (lowest / BigInt(10 ** 18)).toString());\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying candidate pool:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> candidateState(AccountId20) - deprecated as of runtime 1200 - use <code>candidateInfo</code> instead ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> - the collator account to query</li> </ul> <p>Deprecated as of runtime 1200 - use <code>candidateInfo</code> instead</p> <p>Deprecated as of runtime 1200 - use <code>candidateInfo</code> instead</p> collatorCommission() - returns the commission percent taken off of rewards for all collators ParametersReturnsPolkadot.js API Example <p>None</p> <p>The percent collator commission, e.g. <code>20.00%</code> </p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Query collator commission\n    const commission = await api.query.parachainStaking.collatorCommission();\n\n    // Get the current round for context\n    const round = await api.query.parachainStaking.round();\n\n    // Get selected candidates count for context\n    const selectedCandidates =\n      await api.query.parachainStaking.selectedCandidates();\n\n    console.log('\\nCollator Commission Information:');\n    console.log('Current Round:', round.current.toString());\n    console.log('Commission Rate:', commission.toString(), 'Per Billion');\n    // Convert to percentage (commission is stored as parts per billion)\n    const commissionPercent = (Number(commission) / 10_000_000).toFixed(2);\n    console.log('Commission Percentage:', commissionPercent + '%');\n\n    console.log('\\nNetwork Context:');\n    console.log('Active Collators:', selectedCandidates.length);\n\n    // Example calculation for a reward\n    const exampleReward = BigInt(1000000000000000000); // 1 DEV\n    const commissionAmount =\n      (exampleReward * BigInt(commission)) / BigInt(1000000000);\n\n    console.log('\\nExample Reward Calculation:');\n    console.log('For a reward of 1 DEV:');\n    console.log(\n      'Commission Amount:',\n      (commissionAmount / BigInt(10 ** 18)).toString(),\n      'DEV'\n    );\n    console.log(\n      'Remaining Reward:',\n      ((exampleReward - commissionAmount) / BigInt(10 ** 18)).toString(),\n      'DEV'\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying collator commission:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> collatorState2(AccountId20) - deprecated as of runtime 1001 - use <code>candidateInfo</code> instead ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> - the collator to query</li> </ul> <p>Deprecated as of runtime 1001* - use <code>candidateInfo</code> instead</p> <p>Deprecated as of runtime 1001* - use <code>candidateInfo</code> instead</p> delayedPayouts(u32) - returns the delayed payouts for all rounds or for a given round ParametersReturnsPolkadot.js API Example <ul> <li><code>u32</code> - the round to query. If omitted, the latest round information will be returned</li> </ul> <p>The round issuance, the total staking reward, and collator commission.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get current round information\n    const round = await api.query.parachainStaking.round();\n    const currentRound = round.current.toNumber();\n\n    console.log('Current Round:', currentRound);\n\n    // Query several recent rounds for delayed payouts\n    const roundsToCheck = 5;\n    const rounds = Array.from(\n      { length: roundsToCheck },\n      (_, i) =&gt; currentRound - i\n    );\n\n    console.log(\n      '\\nChecking Delayed Payouts for the Last',\n      roundsToCheck,\n      'Rounds:'\n    );\n\n    // Track statistics\n    let totalPayouts = 0;\n    let totalRewards = BigInt(0);\n\n    for (const roundNumber of rounds) {\n      console.log(`\\nRound ${roundNumber}:`);\n\n      const delayedPayout =\n        await api.query.parachainStaking.delayedPayouts(roundNumber);\n\n      if (delayedPayout.isSome) {\n        const payout = delayedPayout.unwrap();\n\n        // Debug log to see the structure\n        console.log(\n          'Raw payout data:',\n          JSON.stringify(payout.toJSON(), null, 2)\n        );\n\n        // Safely access the data\n        const payoutData = payout.toJSON();\n\n        console.log('Found Delayed Payout:');\n        if (payoutData) {\n          totalPayouts++;\n\n          // Calculate total rewards if data is available\n          if (payoutData.colReward &amp;&amp; payoutData.delReward) {\n            const roundReward =\n              BigInt(payoutData.colReward) + BigInt(payoutData.delReward);\n            totalRewards += roundReward;\n\n            console.log('Collator:', payoutData.toCollator);\n            console.log('Collator Reward:', payoutData.colReward, 'Wei');\n            console.log(\n              'Collator Reward in DEV:',\n              (BigInt(payoutData.colReward) / BigInt(10 ** 18)).toString(),\n              'DEV'\n            );\n            console.log('Total Delegator Reward:', payoutData.delReward, 'Wei');\n            console.log(\n              'Total Delegator Reward in DEV:',\n              (BigInt(payoutData.delReward) / BigInt(10 ** 18)).toString(),\n              'DEV'\n            );\n            console.log('Total Round Reward:', roundReward.toString(), 'Wei');\n            console.log(\n              'Total Round Reward in DEV:',\n              (roundReward / BigInt(10 ** 18)).toString(),\n              'DEV'\n            );\n\n            // Get collator information if available\n            if (payoutData.toCollator) {\n              const collatorInfo =\n                await api.query.parachainStaking.candidateInfo(\n                  payoutData.toCollator\n                );\n              if (collatorInfo.isSome) {\n                const info = collatorInfo.unwrap();\n                console.log('\\nCollator Information:');\n                console.log(\n                  'Delegation Count:',\n                  info.delegationCount.toString()\n                );\n                console.log('Self Bond:', info.bond.toString(), 'Wei');\n                console.log(\n                  'Self Bond in DEV:',\n                  (BigInt(info.bond) / BigInt(10 ** 18)).toString(),\n                  'DEV'\n                );\n              }\n\n              // Get awarded points for context\n              const points = await api.query.parachainStaking.awardedPts(\n                roundNumber,\n                payoutData.toCollator\n              );\n              console.log('Points earned in round:', points.toString());\n            }\n          }\n        }\n      } else {\n        console.log('No delayed payout found');\n      }\n    }\n\n    // Display statistics\n    console.log('\\nPayout Statistics:');\n    console.log('Total Rounds with Payouts:', totalPayouts);\n    console.log(\n      'Average Payouts per Round:',\n      (totalPayouts / roundsToCheck).toFixed(2)\n    );\n    if (totalPayouts &gt; 0) {\n      console.log(\n        'Average Reward per Payout:',\n        (totalRewards / BigInt(totalPayouts) / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n      console.log(\n        'Total Rewards:',\n        (totalRewards / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n    }\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying delayed payouts:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> delegationScheduledRequests(AccountId20) - returns the outstanding scheduled delegation requests for all collators or for a given collator's address ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> - the address of the collator. If omitted, information about all collators will be returned</li> </ul> <p>The set of pending scheduled delegation requests including the delegator's address, the action requested, and eligible block at which the action can be executed.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Example collator address\n    const collatorAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    // Get current round information for context\n    const round = await api.query.parachainStaking.round();\n    const currentRound = round.current.toNumber();\n\n    console.log('Query Parameters:');\n    console.log('Collator address:', collatorAddress);\n    console.log('Current round:', currentRound);\n\n    // Get collator info for context\n    const collatorInfo =\n      await api.query.parachainStaking.candidateInfo(collatorAddress);\n    if (collatorInfo.isSome) {\n      const info = collatorInfo.unwrap();\n      console.log('\\nCollator Information:');\n      console.log('Delegation Count:', info.delegationCount.toString());\n      console.log('Current Bond:', info.bond.toString(), 'Wei');\n      console.log(\n        'Current Bond in DEV:',\n        (BigInt(info.bond) / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n    }\n\n    // Query scheduled delegation requests\n    const requests =\n      await api.query.parachainStaking.delegationScheduledRequests(\n        collatorAddress\n      );\n\n    console.log('\\nScheduled Delegation Requests:');\n    if (requests.length &gt; 0) {\n      console.log('Total requests:', requests.length);\n\n      // Process each request\n      requests.forEach((request, index) =&gt; {\n        console.log(`\\nRequest #${index + 1}:`);\n        const { delegator, whenExecutable, action } = request;\n        console.log('Delegator:', delegator.toString());\n        console.log('Executable at round:', whenExecutable.toString());\n        console.log(\n          'Rounds until executable:',\n          whenExecutable.toNumber() - currentRound\n        );\n\n        // Handle different types of actions\n        if (action.isDecrease) {\n          const amount = action.asDecrease;\n          console.log('Action: Decrease');\n          console.log('Amount:', amount.toString(), 'Wei');\n          console.log(\n            'Amount in DEV:',\n            (BigInt(amount) / BigInt(10 ** 18)).toString(),\n            'DEV'\n          );\n        } else if (action.isRevoke) {\n          const amount = action.asRevoke;\n          console.log('Action: Revoke');\n          console.log('Amount:', amount.toString(), 'Wei');\n          console.log(\n            'Amount in DEV:',\n            (BigInt(amount) / BigInt(10 ** 18)).toString(),\n            'DEV'\n          );\n        }\n      });\n\n      // Calculate some statistics\n      let totalDecreaseAmount = BigInt(0);\n      let totalRevokeAmount = BigInt(0);\n      let decreaseCount = 0;\n      let revokeCount = 0;\n\n      requests.forEach((request) =&gt; {\n        if (request.action.isDecrease) {\n          totalDecreaseAmount += BigInt(request.action.asDecrease);\n          decreaseCount++;\n        } else if (request.action.isRevoke) {\n          totalRevokeAmount += BigInt(request.action.asRevoke);\n          revokeCount++;\n        }\n      });\n\n      console.log('\\nRequest Statistics:');\n      console.log('Decrease requests:', decreaseCount);\n      if (decreaseCount &gt; 0) {\n        console.log(\n          'Total decrease amount:',\n          totalDecreaseAmount.toString(),\n          'Wei'\n        );\n        console.log(\n          'Total decrease amount in DEV:',\n          (totalDecreaseAmount / BigInt(10 ** 18)).toString(),\n          'DEV'\n        );\n        console.log(\n          'Average decrease amount in DEV:',\n          (\n            totalDecreaseAmount /\n            BigInt(decreaseCount) /\n            BigInt(10 ** 18)\n          ).toString(),\n          'DEV'\n        );\n      }\n\n      console.log('Revoke requests:', revokeCount);\n      if (revokeCount &gt; 0) {\n        console.log(\n          'Total revoke amount:',\n          totalRevokeAmount.toString(),\n          'Wei'\n        );\n        console.log(\n          'Total revoke amount in DEV:',\n          (totalRevokeAmount / BigInt(10 ** 18)).toString(),\n          'DEV'\n        );\n        console.log(\n          'Average revoke amount in DEV:',\n          (\n            totalRevokeAmount /\n            BigInt(revokeCount) /\n            BigInt(10 ** 18)\n          ).toString(),\n          'DEV'\n        );\n      }\n\n      // Show impact on collator's delegation\n      const totalImpact = totalDecreaseAmount + totalRevokeAmount;\n      console.log('\\nTotal Impact:');\n      console.log('Total amount to be removed:', totalImpact.toString(), 'Wei');\n      console.log(\n        'Total amount to be removed in DEV:',\n        (totalImpact / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n    } else {\n      console.log('No scheduled delegation requests found');\n    }\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying delegation requests:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> delegatorState(AccountId20) - returns delegator information such as their delegations, delegation status, and total delegation amount for all delegators or for a given delegator's address ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> - the address of the delegator to query</li> </ul> <p>Delegator state information including the collators delegated and their respective amounts</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Example delegator address\n    const delegatorAddress = 'INSERT_DELEGATOR_ADDRESS';\n\n    // Get current round information for context\n    const round = await api.query.parachainStaking.round();\n    const currentRound = round.current.toNumber();\n\n    console.log('Query Parameters:');\n    console.log('Delegator address:', delegatorAddress);\n    console.log('Current round:', currentRound);\n\n    // Query delegator state\n    const delegatorState =\n      await api.query.parachainStaking.delegatorState(delegatorAddress);\n\n    if (delegatorState.isSome) {\n      const state = delegatorState.unwrap();\n      const delegations = state.delegations;\n\n      console.log('\\nDelegator Information:');\n      console.log('Total Delegations:', delegations.length);\n\n      // Calculate total delegated amount\n      let totalDelegated = BigInt(0);\n      delegations.forEach((d) =&gt; {\n        totalDelegated += BigInt(d.amount);\n      });\n\n      console.log('Total Amount Delegated:', totalDelegated.toString(), 'Wei');\n      console.log(\n        'Total Amount Delegated in DEV:',\n        (totalDelegated / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n\n      // Show detailed delegation information\n      console.log('\\nDetailed Delegations:');\n      for (const [index, delegation] of delegations.entries()) {\n        console.log(`\\nDelegation #${index + 1}:`);\n        console.log('Collator:', delegation.owner.toString());\n        console.log('Amount:', delegation.amount.toString(), 'Wei');\n        console.log(\n          'Amount in DEV:',\n          (BigInt(delegation.amount) / BigInt(10 ** 18)).toString(),\n          'DEV'\n        );\n\n        // Get collator information\n        const collatorInfo = await api.query.parachainStaking.candidateInfo(\n          delegation.owner\n        );\n        if (collatorInfo.isSome) {\n          const info = collatorInfo.unwrap();\n          console.log('Collator Status:', info.status.toString());\n          console.log('Collator Total Bond:', info.bond.toString(), 'Wei');\n          console.log(\n            'Collator Delegation Count:',\n            info.delegationCount.toString()\n          );\n        }\n\n        // Check auto-compound setting\n        const autoCompoundDelegations =\n          await api.query.parachainStaking.autoCompoundingDelegations(\n            delegation.owner\n          );\n        const autoCompound = autoCompoundDelegations.find(\n          (d) =&gt;\n            d.delegator.toString().toLowerCase() ===\n            delegatorAddress.toLowerCase()\n        );\n        if (autoCompound) {\n          console.log(\n            'Auto-compound Percentage:',\n            autoCompound.value.toString(),\n            '%'\n          );\n        } else {\n          console.log('Auto-compound: Not set');\n        }\n\n        // Check for scheduled requests\n        const requests =\n          await api.query.parachainStaking.delegationScheduledRequests(\n            delegation.owner\n          );\n        const delegatorRequests = requests.filter(\n          (r) =&gt;\n            r.delegator.toString().toLowerCase() ===\n            delegatorAddress.toLowerCase()\n        );\n\n        if (delegatorRequests.length &gt; 0) {\n          console.log('\\nPending Requests:');\n          delegatorRequests.forEach((request) =&gt; {\n            console.log(\n              'Executable at round:',\n              request.whenExecutable.toString()\n            );\n            if (request.action.isDecrease) {\n              console.log('Action: Decrease');\n              console.log(\n                'Amount:',\n                request.action.asDecrease.toString(),\n                'Wei'\n              );\n              console.log(\n                'Amount in DEV:',\n                (\n                  BigInt(request.action.asDecrease) / BigInt(10 ** 18)\n                ).toString(),\n                'DEV'\n              );\n            } else if (request.action.isRevoke) {\n              console.log('Action: Revoke');\n              console.log('Amount:', request.action.asRevoke.toString(), 'Wei');\n              console.log(\n                'Amount in DEV:',\n                (BigInt(request.action.asRevoke) / BigInt(10 ** 18)).toString(),\n                'DEV'\n              );\n            }\n          });\n        }\n      }\n\n      // Calculate statistics\n      const amounts = delegations.map((d) =&gt; BigInt(d.amount));\n      const averageDelegation = totalDelegated / BigInt(delegations.length);\n      const maxDelegation = amounts.reduce(\n        (a, b) =&gt; (a &gt; b ? a : b),\n        BigInt(0)\n      );\n      const minDelegation = amounts.reduce(\n        (a, b) =&gt; (a &lt; b ? a : b),\n        amounts[0] || BigInt(0)\n      );\n\n      console.log('\\nDelegation Statistics:');\n      console.log(\n        'Average Delegation:',\n        (averageDelegation / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n      console.log(\n        'Largest Delegation:',\n        (maxDelegation / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n      console.log(\n        'Smallest Delegation:',\n        (minDelegation / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n\n      // Get network context\n      const selectedCandidates =\n        await api.query.parachainStaking.selectedCandidates();\n      console.log('\\nNetwork Context:');\n      console.log('Total Selected Collators:', selectedCandidates.length);\n      console.log(\n        'Delegating to Selected Collators:',\n        delegations.filter((d) =&gt;\n          selectedCandidates.some((c) =&gt; c.toString() === d.owner.toString())\n        ).length\n      );\n    } else {\n      console.log('\\nNo delegator state found for this address');\n    }\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying delegator state:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> enabledMarkingOffline() - returns a boolean indicating whether or not the marking offline feature for inactive collators is enabled ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>boolean</code> - Indicating whether or not the marking offline feature for inactive collators is enabled</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get marking offline status with the correct method name\n    const isEnabled = await api.query.parachainStaking.enableMarkingOffline();\n\n    console.log('Marking Offline Feature Status:', isEnabled.toHuman());\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying marking offline status:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> inflationConfig() - returns the inflation configuration ParametersReturnsPolkadot.js API Example <p>None</p> <p>A JSON object that contains the minimum, ideal, and maximum inflation parameters in each of the following thresholds: expected, annual, and round. </p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Query inflation configuration\n    const inflationConfig = await api.query.parachainStaking.inflationConfig();\n\n    // Get current round info for context\n    const round = await api.query.parachainStaking.round();\n\n    console.log('Current Round:', round.current.toString());\n\n    console.log('\\nInflation Configuration (Human Readable):');\n    const config = inflationConfig.toHuman();\n    console.log(JSON.stringify(config, null, 2));\n\n    // Access the nested structure correctly\n    const rawConfig = inflationConfig.toJSON();\n\n    console.log('\\nDetailed Configuration Breakdown:');\n\n    // Expected rewards\n    console.log('\\nExpected Rewards:');\n    console.log('Min:', rawConfig.expect.min);\n    console.log('Ideal:', rawConfig.expect.ideal);\n    console.log('Max:', rawConfig.expect.max);\n\n    // Annual inflation rates (divide by 10^7 to get percentage)\n    console.log('\\nAnnual Inflation Rates:');\n    console.log('Min:', (rawConfig.annual.min / 10_000_000).toFixed(2) + '%');\n    console.log(\n      'Ideal:',\n      (rawConfig.annual.ideal / 10_000_000).toFixed(2) + '%'\n    );\n    console.log('Max:', (rawConfig.annual.max / 10_000_000).toFixed(2) + '%');\n\n    // Round inflation rates\n    console.log('\\nRound Inflation Rates:');\n    console.log('Min:', (rawConfig.round.min / 10_000_000).toFixed(4) + '%');\n    console.log(\n      'Ideal:',\n      (rawConfig.round.ideal / 10_000_000).toFixed(4) + '%'\n    );\n    console.log('Max:', (rawConfig.round.max / 10_000_000).toFixed(4) + '%');\n\n    // Example calculations for 100 DEV with annual rates\n    const exampleStake = 100n * BigInt(10 ** 18); // 100 DEV\n    console.log('\\nExample Annual Returns for 100 DEV stake:');\n\n    // Convert to BigInt for calculations\n    const annualMin =\n      (BigInt(rawConfig.annual.min) * exampleStake) /\n      BigInt(10_000_000) /\n      BigInt(10 ** 18);\n    const annualIdeal =\n      (BigInt(rawConfig.annual.ideal) * exampleStake) /\n      BigInt(10_000_000) /\n      BigInt(10 ** 18);\n    const annualMax =\n      (BigInt(rawConfig.annual.max) * exampleStake) /\n      BigInt(10_000_000) /\n      BigInt(10 ** 18);\n\n    console.log('Min:', annualMin.toString(), 'DEV');\n    console.log('Ideal:', annualIdeal.toString(), 'DEV');\n    console.log('Max:', annualMax.toString(), 'DEV');\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying inflation configuration:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> nominatorState2(AccountId20) - deprecated as of runtime 1001 - use <code>delegatorState</code> instead ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> - The account to query</li> </ul> <p>Deprecated as of runtime 1001* - use <code>delegatorState</code> instead</p> <p>Deprecated as of runtime 1001* - use <code>delegatorState</code> instead</p> palletVersion() - returns the current pallet version ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u16</code> - current pallet version</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Query pallet version\n    const version = await api.query.parachainStaking.palletVersion();\n\n    console.log('Parachain Staking Pallet Version:', version.toString());\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying pallet version:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> points(u32) - returns the total points awarded to collators for block production in all rounds or for a given round ParametersReturnsPolkadot.js API Example <ul> <li><code>u32</code> - a round number. If omitted, the data for the last three rounds will be returned</li> </ul> <ul> <li><code>u32</code> - total points awarded to collators in the given round </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get current round information\n    const round = await api.query.parachainStaking.round();\n    const currentRound = round.current.toNumber();\n\n    // Query points for several recent rounds\n    const roundsToCheck = 5;\n    const rounds = Array.from(\n      { length: roundsToCheck },\n      (_, i) =&gt; currentRound - i\n    );\n\n    console.log('Current Round:', currentRound);\n\n    // Get selected candidates for context\n    const selectedCandidates =\n      await api.query.parachainStaking.selectedCandidates();\n    console.log('Number of Selected Collators:', selectedCandidates.length);\n\n    // Check each round\n    for (const roundNumber of rounds) {\n      console.log(`\\nPoints for Round ${roundNumber}:`);\n      const roundPoints = await api.query.parachainStaking.points(roundNumber);\n\n      if (roundPoints.toNumber() === 0) {\n        console.log('No points recorded for this round');\n      } else {\n        console.log('Total Points:', roundPoints.toString());\n\n        // Get individual collator points for this round\n        let collatorPoints = [];\n        for (const collator of selectedCandidates) {\n          const points = await api.query.parachainStaking.awardedPts(\n            roundNumber,\n            collator\n          );\n          if (points.toNumber() &gt; 0) {\n            collatorPoints.push({\n              collator: collator.toString(),\n              points: points.toNumber(),\n            });\n          }\n        }\n\n        // Sort collators by points\n        collatorPoints.sort((a, b) =&gt; b.points - a.points);\n\n        // Display collator points\n        if (collatorPoints.length &gt; 0) {\n          console.log('\\nCollator Performance:');\n          collatorPoints.forEach(({ collator, points }) =&gt; {\n            console.log(`Collator ${collator}: ${points} points`);\n          });\n\n          // Calculate statistics\n          const totalPoints = collatorPoints.reduce(\n            (sum, { points }) =&gt; sum + points,\n            0\n          );\n          const averagePoints = totalPoints / collatorPoints.length;\n          const maxPoints = collatorPoints[0].points;\n          const minPoints = collatorPoints[collatorPoints.length - 1].points;\n\n          console.log('\\nRound Statistics:');\n          console.log('Active Collators:', collatorPoints.length);\n          console.log('Average Points:', averagePoints.toFixed(2));\n          console.log('Highest Points:', maxPoints);\n          console.log('Lowest Points:', minPoints);\n        }\n      }\n    }\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying points:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> round() - returns the current round number, the first block of the current round, and the length of the round ParametersReturnsPolkadot.js API Example <p>None</p> <p>Returns the current round number, the first block of the current round, and the length of the round</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Query round information\n    const roundInfo = await api.query.parachainStaking.round();\n\n    console.log('Round Information:');\n    console.log('Current Round:', roundInfo.current.toString());\n    console.log('First Block of Round:', roundInfo.first.toString());\n    console.log('Round Length:', roundInfo.length.toString());\n\n    // Calculate some additional useful information\n    const currentBlock = await api.rpc.chain.getBlock();\n    const currentBlockNumber = currentBlock.block.header.number.toNumber();\n\n    // Calculate blocks remaining in current round\n    const blocksIntoRound = currentBlockNumber - roundInfo.first.toNumber();\n    const blocksRemaining = roundInfo.length.toNumber() - blocksIntoRound;\n\n    console.log('\\nAdditional Information:');\n    console.log('Current Block:', currentBlockNumber);\n    console.log('Blocks Into Current Round:', blocksIntoRound);\n    console.log('Blocks Remaining in Round:', blocksRemaining);\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying round information:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> selectedCandidates() - returns the collator candidates selected to be in the active set for the current round ParametersReturnsPolkadot.js API Example <p>None</p> <p>A set of <code>AccountId20</code>s - collator candidates selected to be in the active set for the current round  </p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get current round for context\n    const round = await api.query.parachainStaking.round();\n    console.log('Current Round:', round.current.toString());\n\n    // Query selected candidates\n    const selectedCandidates =\n      await api.query.parachainStaking.selectedCandidates();\n\n    console.log('\\nSelected Candidates:');\n    console.log('Total Selected:', selectedCandidates.length);\n\n    // Get detailed information for each candidate\n    console.log('\\nDetailed Candidate Information:');\n    for (const [index, candidate] of selectedCandidates.entries()) {\n      const candidateInfo =\n        await api.query.parachainStaking.candidateInfo(candidate);\n\n      if (candidateInfo.isSome) {\n        const info = candidateInfo.unwrap();\n        console.log(`\\nCandidate #${index + 1}:`);\n        console.log('Address:', candidate.toString());\n        console.log('Bond:', info.bond.toString(), 'Wei');\n        console.log(\n          'Bond in DEV:',\n          (BigInt(info.bond) / BigInt(10 ** 18)).toString(),\n          'DEV'\n        );\n        console.log('Delegation Count:', info.delegationCount.toString());\n        console.log('Status:', info.status.toString());\n\n        // Get recent points for context (last 3 rounds)\n        const currentRound = round.current.toNumber();\n        let recentPoints = 0;\n        console.log('Recent Points:');\n        for (let i = 0; i &lt; 3; i++) {\n          const roundPoints = await api.query.parachainStaking.awardedPts(\n            currentRound - i,\n            candidate\n          );\n          console.log(`  Round ${currentRound - i}: ${roundPoints.toString()}`);\n          recentPoints += roundPoints.toNumber();\n        }\n        console.log('Total Points (last 3 rounds):', recentPoints);\n      }\n    }\n\n    // Calculate some statistics\n    let totalBond = BigInt(0);\n    let totalDelegations = 0;\n\n    for (const candidate of selectedCandidates) {\n      const candidateInfo =\n        await api.query.parachainStaking.candidateInfo(candidate);\n      if (candidateInfo.isSome) {\n        const info = candidateInfo.unwrap();\n        totalBond += BigInt(info.bond);\n        totalDelegations += info.delegationCount.toNumber();\n      }\n    }\n\n    console.log('\\nCollective Statistics:');\n    console.log('Total Bonded:', totalBond.toString(), 'Wei');\n    console.log(\n      'Total Bonded in DEV:',\n      (totalBond / BigInt(10 ** 18)).toString(),\n      'DEV'\n    );\n    console.log(\n      'Average Bond in DEV:',\n      (\n        totalBond /\n        BigInt(selectedCandidates.length) /\n        BigInt(10 ** 18)\n      ).toString(),\n      'DEV'\n    );\n    console.log(\n      'Average Delegations per Candidate:',\n      (totalDelegations / selectedCandidates.length).toFixed(2)\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying selected candidates:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> topDelegations(AccountId20) - returns at the most the top 300 delegations for all collators or for a given collator's address ParametersReturnsPolkadot.js API Example <ul> <li><code>AccountId20</code> - Address of the given collator. If no address is provided then the top 300 delegations for all collators is returned.</li> </ul> <p>Returns up to the top 300 delegations for a given collator, including the address of the delegator and the amount delegated</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Example collator address\n    const collatorAddress = 'INSERT_COLLATOR_ADDRESS';\n\n    // Get collator info first\n    const candidateInfo =\n      await api.query.parachainStaking.candidateInfo(collatorAddress);\n\n    console.log('Query Parameters:');\n    console.log('Collator address:', collatorAddress);\n\n    if (candidateInfo.isSome) {\n      const info = candidateInfo.unwrap();\n      console.log('\\nCollator Information:');\n      console.log('Total delegations:', info.delegationCount.toString());\n      console.log('Self bond:', info.bond.toString(), 'Wei');\n      console.log(\n        'Self bond in DEV:',\n        (BigInt(info.bond) / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n    }\n\n    // Query top delegations\n    const topDelegations =\n      await api.query.parachainStaking.topDelegations(collatorAddress);\n\n    if (topDelegations.isSome) {\n      const delegations = topDelegations.unwrap();\n      console.log('\\nTop Delegations:');\n      console.log('Total delegations found:', delegations.delegations.length);\n      console.log(\n        'Total amount delegated:',\n        delegations.total.toString(),\n        'Wei'\n      );\n      console.log(\n        'Total amount delegated in DEV:',\n        (BigInt(delegations.total) / BigInt(10 ** 18)).toString(),\n        'DEV'\n      );\n\n      // Sort delegations by amount in descending order\n      const sortedDelegations = [...delegations.delegations].sort(\n        (a, b) =&gt; BigInt(b.amount) - BigInt(a.amount)\n      );\n\n      // Display each delegation\n      console.log('\\nDelegation Details:');\n      sortedDelegations.forEach((delegation, index) =&gt; {\n        console.log(`\\nDelegation #${index + 1}:`);\n        console.log('Delegator:', delegation.owner.toString());\n        console.log('Amount:', delegation.amount.toString(), 'Wei');\n        console.log(\n          'Amount in DEV:',\n          (BigInt(delegation.amount) / BigInt(10 ** 18)).toString(),\n          'DEV'\n        );\n      });\n\n      // Calculate statistics\n      if (sortedDelegations.length &gt; 0) {\n        const amounts = sortedDelegations.map((d) =&gt; BigInt(d.amount));\n        const total = amounts.reduce((a, b) =&gt; a + b, BigInt(0));\n        const average = total / BigInt(sortedDelegations.length);\n        const highest = amounts[0];\n        const lowest = amounts[amounts.length - 1];\n        const median = amounts[Math.floor(amounts.length / 2)];\n\n        console.log('\\nDelegation Statistics:');\n        console.log(\n          'Average delegation:',\n          (average / BigInt(10 ** 18)).toString(),\n          'DEV'\n        );\n        console.log(\n          'Highest delegation:',\n          (highest / BigInt(10 ** 18)).toString(),\n          'DEV'\n        );\n        console.log(\n          'Median delegation:',\n          (median / BigInt(10 ** 18)).toString(),\n          'DEV'\n        );\n        console.log(\n          'Lowest delegation:',\n          (lowest / BigInt(10 ** 18)).toString(),\n          'DEV'\n        );\n\n        // Distribution analysis\n        const totalDelegated = BigInt(delegations.total);\n        console.log('\\nStake Distribution:');\n        console.log(\n          'Top 5 delegators control:',\n          (\n            (amounts.slice(0, 5).reduce((a, b) =&gt; a + b, BigInt(0)) *\n              BigInt(100)) /\n            totalDelegated\n          ).toString() + '%'\n        );\n        if (sortedDelegations.length &gt;= 10) {\n          console.log(\n            'Top 10 delegators control:',\n            (\n              (amounts.slice(0, 10).reduce((a, b) =&gt; a + b, BigInt(0)) *\n                BigInt(100)) /\n              totalDelegated\n            ).toString() + '%'\n          );\n        }\n      }\n\n      // Check auto-compound settings\n      const autoCompoundDelegations =\n        await api.query.parachainStaking.autoCompoundingDelegations(\n          collatorAddress\n        );\n      console.log('\\nAuto-compound Settings:');\n      console.log(\n        'Delegators with auto-compound:',\n        autoCompoundDelegations.length\n      );\n    } else {\n      console.log('\\nNo top delegations found for this collator');\n    }\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying top delegations:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> total() - returns the total capital locked in the staking pallet ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u128</code> - returns the total capital locked in the staking pallet</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get total staked amount\n    const totalStaked = await api.query.parachainStaking.total();\n\n    console.log('Total Staked:');\n    console.log('Amount:', totalStaked.toString(), 'Wei');\n    console.log(\n      'Amount in DEV:',\n      (BigInt(totalStaked) / BigInt(10 ** 18)).toString(),\n      'DEV'\n    );\n\n    // Get some context information\n    const selectedCandidates =\n      await api.query.parachainStaking.selectedCandidates();\n    console.log('\\nNetwork Context:');\n    console.log('Number of Selected Collators:', selectedCandidates.length);\n\n    // Get total issuance for percentage calculation\n    const totalIssuance = await api.query.balances.totalIssuance();\n    const percentageStaked =\n      (BigInt(totalStaked) * BigInt(100)) / BigInt(totalIssuance);\n    console.log('\\nStaking Metrics:');\n    console.log(\n      'Total Issuance:',\n      (BigInt(totalIssuance) / BigInt(10 ** 18)).toString(),\n      'DEV'\n    );\n    console.log(\n      'Percentage of Total Supply Staked:',\n      percentageStaked.toString() + '%'\n    );\n\n    // Calculate average stake per collator\n    const averageStakePerCollator =\n      BigInt(totalStaked) / BigInt(selectedCandidates.length);\n    console.log(\n      'Average Stake per Collator:',\n      (averageStakePerCollator / BigInt(10 ** 18)).toString(),\n      'DEV'\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying total staked:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> totalSelected() - returns the total number of collator candidates that can be selected for the active set ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - returns the total number of collator candidates that can be selected for the active set</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get total number of collators that can be selected\n    const totalSelected = await api.query.parachainStaking.totalSelected();\n\n    console.log(\n      'Maximum Number of Collators that can be Selected:',\n      totalSelected.toString()\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying total selected:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"builders/substrate/interfaces/features/staking/#constants","title":"Pallet Constants","text":"<p>The parachain staking pallet includes the following read-only functions to obtain pallet constants:</p> candidateBondLessDelay() - returns the number of rounds that must be waited until a candidate's scheduled request to decrease their self bond can be executed ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - returns the number of rounds that must be waited until a candidate's scheduled request to decrease their self bond can be executed</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the bond less delay constant\n    const delay = await api.consts.parachainStaking.candidateBondLessDelay;\n\n    console.log('Candidate Bond Less Delay:', delay.toString(), 'rounds');\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying candidate bond less delay:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> defaultBlocksPerRound() -  deprecated as of runtime 1900 - returns the default number of blocks per round ParametersReturnsPolkadot.js API Example <p>None</p> <p>Deprecated as of runtime 1900</p> <p>Deprecated as of runtime 1900</p> defaultCollatorCommission() - deprecated as of runtime 1900 - returns the default commission due to collators ParametersReturnsPolkadot.js API Example <p>None</p> <p>Deprecated as of runtime 1900</p> <p>Deprecated as of runtime 1900</p> defaultParachainBondReservePercent() - deprecated as of runtime 1900 - returns the default percent of inflation set aside for the parachain bond account ParametersReturnsPolkadot.js API Example <p>None</p> <p>Deprecated as of runtime 1900</p> <p>Deprecated as of runtime 1900</p> delegationBondLessDelay() - returns the number of rounds that must be waited until a scheduled request to decrease a delegation can be executed ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - returns the number of rounds that must be waited until a scheduled request to decrease a delegation can be executed</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the delegation bond less delay constant\n    const delay = await api.consts.parachainStaking.delegationBondLessDelay;\n\n    console.log('Delegation Bond Less Delay:', delay.toString(), 'rounds');\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying delegation bond less delay:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> leaveCandidatesDelay() - returns the number of rounds that must be waited before a scheduled request for a candidate to leave the candidate pool can be executed ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - returns the number of rounds that must be waited before a scheduled request for a candidate to leave the candidate pool can be executed</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the leaveCandidatesDelay constant from the parachainStaking module\n    const leaveCandidatesDelay =\n      await api.consts.parachainStaking.leaveCandidatesDelay;\n\n    console.log(\n      'Leave Candidates Delay:',\n      leaveCandidatesDelay.toString(),\n      'rounds'\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying leave candidates delay:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> leaveDelegatorsDelay() - returns the number of rounds that must be waited before a scheduled request for a delegator to leave the set of delegators can be executed ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - returns the number of rounds that must be waited before a scheduled request for a delegator to leave the set of delegators can be executed</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the leaveDelegatorsDelay constant from the parachainStaking module\n    const leaveDelegatorsDelay =\n      await api.consts.parachainStaking.leaveDelegatorsDelay;\n\n    console.log(\n      'Leave Delegators Delay:',\n      leaveDelegatorsDelay.toString(),\n      'rounds'\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying leave delegators delay:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> linearInflationThreshold() - returns the total supply threshold at which inflation becomes linear instead of exponential ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>Option&lt;u128&gt;</code> - returns the total supply threshold at which inflation becomes linear instead of exponential. When the total supply reaches this amount, inflation transitions from exponential to linear. Returns <code>Some(value)</code> if configured, or <code>None</code> if not set.</p> <p>Example values are approximately 1.2B DEV for Moonbase, 1.0B MOVR for Moonriver, and 1.2B GLMR for Moonbeam.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Get the linear inflation threshold constant\n  const linearInflationThreshold = api.consts.parachainStaking.linearInflationThreshold;\n\n  console.log(`Linear Inflation Threshold: ${linearInflationThreshold.toHuman()}`);\n\n  // Disconnect from the API\n  await api.disconnect();\n};\n\nmain().catch(console.error);\n</code></pre> maxBottomDelegationsPerCandidate() - returns the maximum number of bottom delegations per candidate ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - returns the maximum number of bottom delegations per candidate</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the maxBottomDelegationsPerCandidate constant from the parachainStaking module\n    const maxBottomDelegationsPerCandidate =\n      await api.consts.parachainStaking.maxBottomDelegationsPerCandidate;\n\n    console.log(\n      'Max Bottom Delegations Per Candidate:',\n      maxBottomDelegationsPerCandidate.toString()\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error(\n      'Error querying max bottom delegations per candidate:',\n      error\n    );\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> maxCandidates() - returns the maximum number of candidates allowed in the candidate pool ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - returns the maximum number of candidates allowed in the candidate pool</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the maximum number of candidates allowed\n    const maxCandidates = await api.consts.parachainStaking.maxCandidates;\n\n    console.log('Maximum Allowed Candidates:', maxCandidates.toString());\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying max candidates:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> maxDelegationsPerDelegator() - returns the maximum number of delegations per delegator ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - returns the maximum number of delegations per delegator</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the maximum number of delegations per delegator\n    const maxDelegations =\n      await api.consts.parachainStaking.maxDelegationsPerDelegator;\n\n    console.log(\n      'Maximum Delegations Per Delegator:',\n      maxDelegations.toString()\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying max delegations per delegator:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> maxOfflineRounds() - returns the number of rounds that must pass before a collator that has stopped producing blocks is marked as inactive ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - returns the number of rounds that must pass before a collator that has stopped producing blocks is marked as inactive</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the maximum number of offline rounds\n    const maxOfflineRounds = await api.consts.parachainStaking.maxOfflineRounds;\n\n    console.log('Maximum Offline Rounds:', maxOfflineRounds.toString());\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying max offline rounds:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> maxTopDelegationsPerCandidate() - returns the maximum number of top delegations per candidate ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - returns the maximum number of top delegations per candidate</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the maximum number of top delegations per candidate\n    const maxTopDelegations =\n      await api.consts.parachainStaking.maxTopDelegationsPerCandidate;\n\n    console.log(\n      'Maximum Top Delegations Per Candidate:',\n      maxTopDelegations.toString()\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying max top delegations per candidate:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> minBlocksPerRound() - returns the minimum number of blocks per round ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - returns the minimum number of blocks per round</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the minimum number of blocks per round\n    const minBlocksPerRound =\n      await api.consts.parachainStaking.minBlocksPerRound;\n\n    console.log('Minimum Blocks Per Round:', minBlocksPerRound.toString());\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying min blocks per round:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> minCandidateStk() - returns the minimum stake required for a candidate to be a collator candidate ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u128</code> - returns the minimum stake required for a candidate to be a collator candidate</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the minimum candidate stake required\n    const minCandidateStake = await api.consts.parachainStaking.minCandidateStk;\n\n    console.log(\n      'Minimum Candidate Stake:',\n      minCandidateStake.toString(),\n      'Wei'\n    );\n    console.log(\n      'Minimum Candidate Stake in DEV:',\n      (BigInt(minCandidateStake) / BigInt(10 ** 18)).toString()\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying min candidate stake:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> minCollatorStk() - deprecated as of runtime 2400 - returns the minimum stake required for a candidate to be in the active set ParametersReturnsPolkadot.js API Example <p>None</p> <p>Deprecated as of runtime 2400</p> <p>Deprecated as of runtime 2400</p> minDelegation() - returns the minimum delegation amount ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u128</code> - returns the minimum delegation amount</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the minimum delegation amount\n    const minDelegation = await api.consts.parachainStaking.minDelegation;\n\n    console.log('Minimum Delegation Amount:', minDelegation.toString(), 'Wei');\n    console.log(\n      'Minimum Delegation Amount in DEV:',\n      (BigInt(minDelegation) / BigInt(10 ** 18)).toString()\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying min delegation amount:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> minDelegatorStk() - deprecated as of runtime 2500 - returns the minimum stake for an account to be a delegator ParametersReturnsPolkadot.js API Example <p>None</p> <p>Deprecated as of runtime 2500</p> <p>Deprecated as of runtime 2500</p> minSelectedCandidates() - returns the minimum number of selected candidates in the active set every round ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - the minimum number of selected candidates in the active set every round</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the minimum number of selected candidates\n    const minSelectedCandidates =\n      await api.consts.parachainStaking.minSelectedCandidates;\n\n    console.log(\n      'Minimum Selected Candidates:',\n      minSelectedCandidates.toString()\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying min selected candidates:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> revokeDelegationDelay() - returns the number of rounds that must be waited before a scheduled request to revoke a delegation can be executed ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - the number of rounds that must be waited before a scheduled request to revoke a delegation can be executed</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the revoke delegation delay\n    const revokeDelegationDelay =\n      await api.consts.parachainStaking.revokeDelegationDelay;\n\n    console.log(\n      'Revoke Delegation Delay:',\n      revokeDelegationDelay.toString(),\n      'rounds'\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying revoke delegation delay:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre> rewardPaymentDelay() - returns the number of rounds that must be waited after which block authors are rewarded ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - The number of rounds that must be waited after which block authors are rewarded</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Initialize the API\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://moonbase-alpha.public.blastapi.io'),\n  });\n\n  try {\n    // Get the reward payment delay\n    const rewardPaymentDelay =\n      await api.consts.parachainStaking.rewardPaymentDelay;\n\n    console.log(\n      'Reward Payment Delay:',\n      rewardPaymentDelay.toString(),\n      'rounds'\n    );\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Error querying reward payment delay:', error);\n    process.exit(1);\n  }\n};\n\n// Execute the script\nmain().catch((error) =&gt; {\n  console.error('Script error:', error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"builders/substrate/interfaces/features/governance/conviction-voting/","title":"The Conviction Voting Pallet","text":""},{"location":"builders/substrate/interfaces/features/governance/conviction-voting/#introduction","title":"Introduction","text":"<p>The Conviction Voting Pallet allows token holders to make, delegate, and manage Conviction-weighted votes on referenda.</p> <p>Governance-related functionality is based on three new pallets and precompiles: the Preimage Pallet and Preimage Precompile, the Referenda Pallet and Referenda Precompile, and the Conviction Voting Pallet and Conviction Voting Precompile. The aforementioned precompiles are Solidity interfaces that enable you to perform governance functions using the Ethereum API.</p> <p>This guide will provide an overview of the extrinsics, storage methods, and getters for the pallet constants available in the Conviction Voting Pallet on Moonbeam on Moonbeam. This guide assumes you are familiar with governance-related terminology; if not, please check out the governance overview page for more information.</p>"},{"location":"builders/substrate/interfaces/features/governance/conviction-voting/#preimage-pallet-interface","title":"Conviction Voting Pallet Interface","text":""},{"location":"builders/substrate/interfaces/features/governance/conviction-voting/#extrinsics","title":"Extrinsics","text":"<p>The Conviction Voting Pallet provides the following extrinsics (functions):</p> delegate(class, to, conviction, balance) - delegate the voting power (with some given Conviction) to another account for a particular class (Origin and, by extension, Track) of polls (referenda). The balance delegated is locked for as long as it's delegated, and thereafter for the time appropriate for the Conviction's lock period. Emits a <code>Delegated</code> event ParametersPolkadot.js API Example <ul> <li><code>class</code> - the index of the Track that the delegate account is permitted to vote on proposals for. The index for each Track is as follows:<ul> <li><code>0</code> - Root Track</li> <li><code>1</code> - Whitelisted Track</li> <li><code>2</code> - General Admin Track</li> <li><code>3</code> - Emergency Canceller Track</li> <li><code>4</code> - Emergency Killer Track</li> </ul> </li> <li><code>to</code> - the account to delegate voting power to</li> <li><code>conviction</code> - the Conviction multiplier value to use for the delegation. You can specify either the name of the Conviction multiplier value or the index associated with the value:<ul> <li><code>'None'</code> or <code>0</code></li> <li><code>'Locked1x'</code> or <code>1</code></li> <li><code>'Locked2x'</code> or <code>2</code></li> <li><code>'Locked3x'</code> or <code>3</code></li> <li><code>'Locked4x'</code> or <code>4</code></li> <li><code>'Locked5x'</code> or <code>5</code></li> <li><code>'Locked6x'</code> or <code>6</code></li> </ul> </li> <li><code>balance</code> -the number of tokens to delegate to the other account in Wei</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst classIndex = INSERT_TRACK_INDEX;\nconst to = INSERT_DELEGATE_ACCOUNT;\nconst conviction = INSERT_CONVICTION;\nconst balance = INSERT_BALANCE_TO_DELEGATE;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.convictionVoting.delegate(\n    classIndex,\n    to,\n    conviction,\n    balance\n  );\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> removeOtherVote(target, class, index) - removes a vote for a poll (referendum). If the <code>target</code> is equal to the signer, then this function is exactly equivalent to <code>removeVote</code>. If not equal to the signer, then the vote must have expired, either because the poll was canceled, the voter lost the poll, or because the Conviction period is over ParametersPolkadot.js API Example <ul> <li><code>target</code> - the voter to remove the vote for</li> <li><code>class</code> - the index of the Track the poll belongs to. The index for each Track is as follows:<ul> <li><code>0</code> - Root Track</li> <li><code>1</code> - Whitelisted Track</li> <li><code>2</code> - General Admin Track</li> <li><code>3</code> - Emergency Canceller Track</li> <li><code>4</code> - Emergency Killer Track</li> </ul> </li> <li><code>index</code> - the index of the poll (referendum)</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst target = INSERT_ADDRESS;\nconst classIndex = INSERT_TRACK_INDEX;\nconst index = INSERT_REFERENDUM_INDEX;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.convictionVoting.removeOtherVote(target, classIndex, index);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> removeVote(class, index) - removes a vote for a poll <p>This can occur if one of the following is true:</p> <ul> <li>If the poll was canceled, tokens are immediately available for unlocking if there is no other pending lock</li> <li>If the poll is ongoing, the token holder's votes no longer count for the tallying, and tokens are immediately available for unlocking if there is no other pending lock</li> <li>If the poll has ended, there are two different scenarios:<ul> <li>If the token holder voted against the tallied result or voted with no Conviction, the tokens are immediately available for unlocking if there is no other pending lock</li> <li>If, however, the poll has ended and the results coincide with the vote of the token holder (with a given Conviction) and the lock period of the Conviction is not over, then the lock will be aggregated into the overall account's lock. This may involve overlocking (where the two locks are combined into a single lock that is the maximum of both the amount locked and the time it is locked)</li> </ul> </li> </ul> ParametersPolkadot.js API Example <ul> <li><code>class</code> - the index of the Track the poll belongs to. The index for each Track is as follows:<ul> <li><code>0</code> - Root Track</li> <li><code>1</code> - Whitelisted Track</li> <li><code>2</code> - General Admin Track</li> <li><code>3</code> - Emergency Canceller Track</li> <li><code>4</code> - Emergency Killer Track</li> </ul> </li> <li><code>index</code> - the index of the poll (referendum)</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst classIndex = INSERT_TRACK_INDEX;\nconst index = INSERT_REFERENDUM_INDEX;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.convictionVoting.removeVote(classIndex, index);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> undelegate(class) - undelegates the voting power for a particular class (Origin and, by extension, Track) of polls (referenda). Tokens may be unlocked after an amount of time consistent with the lock period of the Conviction with which the delegation was issued. Emits an <code>Undelegated</code> event ParametersPolkadot.js API Example <ul> <li><code>class</code> - the index of the Track to remove the voting power for. The index for each Track is as follows:<ul> <li><code>0</code> - Root Track</li> <li><code>1</code> - Whitelisted Track</li> <li><code>2</code> - General Admin Track</li> <li><code>3</code> - Emergency Canceller Track</li> <li><code>4</code> - Emergency Killer Track</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst classIndex = INSERT_TRACK_INDEX;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.convictionVoting.undelegate(classIndex);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> unlock(class, target) - removes a lock for a prior vote or delegation vote within a particular class (Origin and, by extension, Track), which has expired ParametersPolkadot.js API Example <ul> <li><code>class</code> - the index of the Track that the poll is assigned to. The index for each Track is as follows:<ul> <li><code>0</code> - Root Track</li> <li><code>1</code> - Whitelisted Track</li> <li><code>2</code> - General Admin Track</li> <li><code>3</code> - Emergency Canceller Track</li> <li><code>4</code> - Emergency Killer Track</li> </ul> </li> <li><code>target</code> - the account to remove the lock for</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst classIndex = INSERT_TRACK_INDEX;\nconst target = INSERT_ADDRESS;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.convictionVoting.unlock(classIndex, target);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> vote(pollIndex, vote) - submits a vote in a poll (referendum). If the vote is \"Aye\", the vote is to enact the proposal; if it is a \"Nay\", the vote is to keep the status quo ParametersPolkadot.js API Example <ul> <li><code>pollIndex</code> - the index of the poll (referendum)</li> <li><code>vote</code> - the vote and the amount to lock for the vote. There are three types of votes: <ul> <li><code>Standard</code> - votes a Conviction-weighted vote, with a given amount locked for \"Aye\" or \"Nay\". To use <code>Standard</code>, you'll have to specify the following:<ul> <li><code>aye</code> - a boolean indicating whether the vote is an \"Aye\" or a \"Nay\"</li> <li><code>conviction</code> - the Conviction multiplier value to use for the delegation. You can specify either the name of the Conviction multiplier value or the index associated with the value:<ul> <li><code>0</code> or <code>'None'</code></li> <li><code>1</code> or <code>'Locked1x'</code></li> <li><code>2</code> or <code>'Locked2x'</code></li> <li><code>3</code> or <code>'Locked3x'</code></li> <li><code>4</code> or <code>'Locked4x'</code></li> <li><code>5</code> or <code>'Locked5x'</code></li> <li><code>6</code> or <code>'Locked6x'</code></li> <li>balance - the number of tokens to lock for the vote</li> </ul> </li> </ul> </li> <li><code>Split</code> - votes a split vote, with a given amount locked for \"Aye\" and a given amount locked for \"Nay\". To use <code>Split</code>, you'll have to specify the following:<ul> <li><code>aye</code> - the balance to lock for an \"Aye\" vote</li> <li><code>nay</code> - the balance to lock for a \"Nay\" vote</li> </ul> </li> <li><code>SplitAbstain</code> - votes a split abstained vote, with a given amount locked for \"Aye\", a given amount locked for \"Nay\", and a given amount locked for an abstain vote (support). To use <code>SplitAbstain</code>, you'll have to specify the following:<ul> <li><code>aye</code> - the balance to lock for an \"Aye\" vote</li> <li><code>nay</code> - the balance to lock for a \"Nay\" vote</li> <li><code>abstain</code> - the balance to lock for an abstain vote</li> </ul> </li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst pollIndex = INSERT_REFERENDUM_INDEX;\nconst vote = INSERT_VOTE;\n/*\nFor Standard, use the following format:\nconst vote = {\n  Standard: {\n    Vote: { aye: INSERT_BOOLEAN, conviction: INSERT_CONVICTION },\n    balance: INSERT_BALANCE,\n  },\n};\n\nFor Split, use the following format:\nconst vote = {\n  Split: {\n    aye: INSERT_BALANCE,\n    nay: INSERT_BALANCE,\n  },\n};\n\nFor SplitAbstrain, use the following format:\nconst vote = {\n   SplitAbstain: {\n     aye: INSERT_BALANCE,\n     nay: INSERT_BALANCE,\n     abstain: INSERT_BALANCE,\n   },\n };        \n*/\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.convictionVoting.vote(pollIndex, vote);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/features/governance/conviction-voting/#storage-methods","title":"Storage Methods","text":"<p>The Conviction Voting Pallet includes the following read-only storage methods to obtain chain state data:</p> classLocksFor(account) - returns the voting classes (Origins and, by extension, Tracks), which have a non-zero lock requirement, and the lock amounts that they require ParametersReturnsPolkadot.js API Example <ul> <li><code>account</code> - the account to get voting information for</li> </ul> <p>An array containing the class locks. Each class lock is an array that includes the index of the class (Origin and, by extension, Track) and the balance the voter has locked in the class. The index for each Track is as follows:     - <code>0</code> - Root Track     - <code>1</code> - Whitelisted Track     - <code>2</code> - General Admin Track     - <code>3</code> - Emergency Canceller Track     - <code>4</code> - Emergency Killer Track</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n[\n  [\n    2, // Index of the class\n    '0x00000000000000000de0b6b3a7640000' // Amount locked\n  ]\n]\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst account = INSERT_ADDRESS;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const classLocksFor = await api.query.convictionVoting.classLocksFor(account);\n};\n\nmain();\n</code></pre> palletVersion() - returns the current pallet version ParametersReturnsPolkadot.js API Example <p>None.</p> <p>A number representing the current version of the pallet.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n0\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const palletVersion = await api.query.convictionVoting.palletVersion();\n};\n\nmain();\n</code></pre> votingFor(account, class) - returns all of the votes for a particular voter in a particular voting class (Origin and, by extension, Track) ParametersReturnsPolkadot.js API Example <ul> <li><code>account</code> - the account to get the voting information for</li> <li><code>class</code> - the index of the voting class. The index for each Track is as follows:<ul> <li><code>0</code> - Root Track</li> <li><code>1</code> - Whitelisted Track</li> <li><code>2</code> - General Admin Track</li> <li><code>3</code> - Emergency Canceller Track</li> <li><code>4</code> - Emergency Killer Track</li> </ul> </li> </ul> <p>The voting information for the given voter. The voter can be either <code>casting</code>, if the voter isn't actively delegating, or <code>delegating</code>, if the user is actively delegating The information for each type.</p> CastingDelegating <p>If the voter isn't actively delegating. If the voter was previously assigned as a delegate, any delegate votes will appear under <code>delegations</code>.</p> <pre><code>{\n  casting: {\n    votes: [ \n      [ \n        0, // Track Index\n        {\n          standard: { // Vote type can be either Standard, Split, or SplitAbstain\n            vote: '0x81', // The vote (Aye or Nay) and the Conviction\n            balance: '0x0000000000001999c6880e003a480000' // Vote value\n          } \n        } \n      ] \n    ],\n    delegations: { // Delegate votes\n      votes: '0x000000000000000ad78ebc5ac6200000', // Total Conviction-weighted votes\n      capital: '0x00000000000000056bc75e2d63100000' // Total delegated amount\n    },\n    prior: [ // Locked votes. After unlocking votes, this will reset to [0, 0]\n      56328, // The block at which the delegated amount can be unlocked\n      '0x00000000000000056bc75e2d63100000'  // The delegated amount\n    ]\n  }\n}\n</code></pre> <p>If the voter is actively delegating their votes to another voter. If the voter was previously delegated by another voter, their votes will appear under <code>delegations</code>.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n{\n  delegating: {\n    balance: '0x00000000000000056bc75e2d63100000', // The delegated amount\n    target: '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0', // The delegate account\n    conviction: 'Locked2x', // The permitted Conviction\n    delegations: { // Delegate votes (if voter was previously delegated)\n      votes: 0,  // Total Conviction-weighted votes\n      capital: 0 // Total delegated amount\n    },\n    prior: [ // Locked votes\n      0, // The block at which the delegated amount can be unlocked\n      0  // The delegated amount\n    ]\n  }\n}\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst account = INSERT_ADDRESS;\nconst classIndex = INSERT_TRACK_INDEX;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const votingFor = await api.query.convictionVoting.votingFor(\n    account,\n    classIndex\n  );\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/features/governance/conviction-voting/#constants","title":"Pallet Constants","text":"<p>The Conviction Voting Pallet includes the following read-only functions to obtain pallet constants:</p> maxVotes() - returns the maximum number of concurrent votes an account may have ParametersReturnsPolkadot.js API Example <p>None.</p> <p>The maximum number of votes.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the result\n20\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const maxVotes = api.consts.convictionVoting.maxVotes;\n};\n\nmain();\n</code></pre> voteLockingPeriod() - returns the minimum period of vote locking. It should not be shorter than the Enactment Period to ensure that, in the case of an approval, those successful voters are locked into the consequences that their votes entail ParametersReturnsPolkadot.js API Example <p>None.</p> <p>The vote-locking period.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the result\n7200\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const voteLockingPeriod = api.consts.convictionVoting.voteLockingPeriod;\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/features/governance/parameters/","title":"The Parameters Pallet","text":""},{"location":"builders/substrate/interfaces/features/governance/parameters/#introduction","title":"Introduction","text":"<p>The Parameters Pallet on Moonbeam is a governance-focused module that enables community-driven modifications to key network configuration items, such as the deposit requirement for the randomness module, directly on-chain through proposals and votes, without necessarily requiring a runtime upgrade. By removing the need for frequent code changes, the Parameters Pallet allows the network to respond more quickly to evolving needs while maintaining transparency and consensus.</p> <p>This guide will provide an overview of the extrinsics, storage methods, and getters for the pallet constants available in the Parameters Pallet on Moonbeam. This guide assumes you are familiar with governance-related terminology; if not, please check out the governance overview page for more information.</p>"},{"location":"builders/substrate/interfaces/features/governance/parameters/#parameter-pallet-interface","title":"Parameters Pallet Interface","text":""},{"location":"builders/substrate/interfaces/features/governance/parameters/#extrinsics","title":"Extrinsics","text":"<p>The Parameters Pallet provides one extrinsic (function):</p> setParameter(keyValue) - sets the value of a parameter ParametersExamplePolkadot.js API Example <ul> <li><code>keyValue</code> - the key to the storage item to be modified</li> </ul> <p>Suppose you want to adjust the deposit parameter for the randomness pallet. You'd start by crafting a call to the <code>setParameter</code> function, specifying the randomness pallet's key and the new deposit value. In Polkadot.js Apps, this involves selecting <code>parameters.setParameter(keyValue)</code> and then updating the deposit field for <code>PalletRandomness</code>. While you can generate and review this call data beforehand, the actual change must still go through the governance process\u2014meaning it needs to be proposed, voted on, and approved by the community before the new deposit value takes effect on-chain</p> <pre><code>// This is an example of crafting the encoded call data via the Polkadot API\n// but remember you won't submit the call here as it needs to go thru governance.\n\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Replace with your node's WSS endpoint\n  const provider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider });\n\n  // Construct the setParameter call for changing the randomness deposit\n  // Keep in mind that actual submission must go through governance (proposal, voting, etc.)\n  const tx = api.tx.parameters.setParameter({\n    PalletRandomness: {\n      // The deposit parameter is declared as a tuple: (variant, Option&lt;u128&gt;).\n      // Here we're setting the deposit to 5 tokens (5000000000000000000),\n      // e.g., 'MoonbaseRuntimeRuntimeParamsDynamicParamsPalletRandomnessDeposit' is the variant,\n      // and the second element is the actual deposit value in the Option&lt;u128&gt;.\n      Deposit: [\n        'MoonbaseRuntimeRuntimeParamsDynamicParamsPalletRandomnessDeposit',\n        '5000000000000000000',\n      ],\n    },\n  });\n\n  // Print out the call in hex format (useful for creating a governance proposal)\n  console.log('Encoded call data:', tx.toHex());\n\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/features/governance/parameters/#storage-methods","title":"Storage Methods","text":"<p>The Parameters Pallet includes the following read-only storage methods to obtain chain state data:</p> parameters(parameters) - when queried with a parameter key, it returns either the corresponding value variant (e.g., <code>RuntimeConfig</code> with <code>FeesTreasuryProportion</code>) or <code>None</code> if no value is set ParametersReturnsPolkadot.js API Example <ul> <li><code>parameters</code> - the name of the pallet combined with the specific key identifying the storage item to retrieve</li> </ul> <p>The <code>parameters</code> storage method is a dictionary that stores dynamic runtime parameters under specific keys. When queried with a parameter key, it returns either the corresponding value variant (e.g., <code>RuntimeConfig</code> with <code>FeesTreasuryProportion</code>) or <code>None</code> if no value is set</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Replace with the appropriate WebSocket endpoint\n  const provider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider });\n\n  // Define the parameter key\n  const paramKey = {\n    RuntimeConfig: 'FeesTreasuryProportion',\n  };\n\n  // Query the storage\n  const currentValue = await api.query.parameters.parameters(paramKey);\n\n  if (currentValue.isSome) {\n    const unwrapped = currentValue.unwrap();\n    console.log('Unwrapped value (toHuman):', unwrapped.toHuman());\n    console.log('Unwrapped value (toJSON):', unwrapped.toJSON());\n  } else {\n    console.log('None. No value stored for the given key.');\n  }\n\n  // Disconnect once done\n  await api.disconnect();\n};\n\nmain();\n</code></pre> palletVersion() - returns the current pallet version ParametersReturnsPolkadot.js API Example <p>None</p> <p>A number representing the current version of the pallet</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n0\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const palletVersion = await api.query.parameters.palletVersion();\n  console.log('The palletVersion is ' + palletVersion);\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/features/governance/parameters/#constants","title":"Pallet Constants","text":"<p>The Parameters Pallet does not have any constants.</p>"},{"location":"builders/substrate/interfaces/features/governance/preimage/","title":"The Preimage Pallet","text":""},{"location":"builders/substrate/interfaces/features/governance/preimage/#introduction","title":"Introduction","text":"<p>The Preimage Pallet allows users and the runtime to store the preimage of some encoded call data on chain. Furthermore, other pallets can use preimage hashes to store and manage large byte-blobs. For example, token holders can submit a governance proposal through the Referenda Pallet using a preimage hash of the action to be carried out.</p> <p>Governance-related functionality is based on three new pallets and precompiles: the Preimage Pallet and Preimage Precompile, the Referenda Pallet and Referenda Precompile, and the Conviction Voting Pallet and Conviction Voting Precompile. The aforementioned precompiles are Solidity interfaces that enable you to perform governance functions using the Ethereum API.</p> <p>This guide will provide an overview of the extrinsics, storage methods, and getters for the pallet constants available in the Preimage Pallet on Moonbeam. This guide assumes you are familiar with governance-related terminology; if not, please check out the governance overview page for more information.</p>"},{"location":"builders/substrate/interfaces/features/governance/preimage/#preimage-pallet-interface","title":"Preimage Pallet Interface","text":""},{"location":"builders/substrate/interfaces/features/governance/preimage/#extrinsics","title":"Extrinsics","text":"<p>The Preimage Pallet provides the following extrinsics (functions):</p> notePreimage(encodedProposal) - registers a preimage for an upcoming proposal, given the encoded preimage of a proposal. If the preimage was previously requested, no fees or deposits are taken for providing the preimage. Otherwise, a deposit is taken proportional to the size of the preimage. Emits a <code>Noted</code> event ParametersPolkadot.js API Example <ul> <li><code>encodedProposal</code> - the encoded call data of the action that is being proposed. Please refer to the How to Generate the Encoded Proposal section for more information</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst encodedProposal = INSERT_ENCODED_PROPOSAL;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.preimage.notePreimage(encodedProposal);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> requestPreimage(bytes) - requests a preimage to be uploaded to the chain without paying any fees or deposits. Once the preimage request has been submitted on-chain, the user who submitted the preimage and deposit will get their deposit back, and they will no longer control the preimage. Must be executed by the Root Origin. Emits a <code>Requested</code> event ParametersPolkadot.js API Example <ul> <li><code>bytes</code> - the hash of a preimage</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst bytes = INSERT_PREIMAGE_HASH;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.preimage.requestPreimage(bytes);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> unnotePreimage(hash) - clears an unrequested preimage from the runtime storage, given the hash of the preimage to be removed. Emits a <code>Cleared</code> event ParametersPolkadot.js API Example <ul> <li><code>hash</code> - the hash of a preimage</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst hash = INSERT_PREIMAGE_HASH;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.preimage.unnotePreimage(hash);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> unrequestPreimage(hash) - clears a previously made request for a preimage. Must be executed by the Root Origin. Emits a <code>Cleared</code> event ParametersPolkadot.js API Example <ul> <li><code>hash</code> - the hash of a preimage</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst hash = INSERT_PREIMAGE_HASH;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.preimage.unrequestPreimage(hash);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/features/governance/preimage/#storage-methods","title":"Storage Methods","text":"<p>The Preimage Pallet includes the following read-only storage methods to obtain chain state data:</p> palletVersion() - returns the current pallet version ParametersReturnsPolkadot.js API Example <p>None.</p> <p>A number representing the current version of the pallet.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n0\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const palletVersion = await api.query.preimage.palletVersion();\n};\n\nmain();\n</code></pre> preimageFor([hash, length]) - returns the encoded proposal for a preimage, given the hash and length of the preimage ParametersReturnsPolkadot.js API Example <ul> <li><code>[hash, length]</code> - a tuple containing the hash and the length of the preimage</li> </ul> <p>The encoded call data of the proposal.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n0x00002c68656c6c6f5f776f726c64\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst preimageInfo = [INSERT_PREIMAGE_HASH, INSERT_PREIMAGE_LENGTH];\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const preimageFor = await api.query.preimage.preimageFor(preimageInfo);\n};\n\nmain();\n</code></pre> statusFor(hash) - returns the request status for a given preimage hash ParametersReturnsPolkadot.js API Example <ul> <li><code>hash</code> - the preimage hash to get the request status for</li> </ul> <p>Status information for the preimage, which includes the status, the preimage deposit information, and the length of the preimage. The status can be either <code>unrequested</code> or <code>requested</code>.</p> <pre><code>{\n  unrequested: { // Request status\n    deposit: [\n      '0x3B939FeaD1557C741Ff06492FD0127bd287A421e', // Depositor\n      '0x00000000000000004569f6996d8c8000' // Amount deposited\n    ],\n    len: 18 // Length of the preimage\n  }\n}\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst hash = INSERT_PREIMAGE_HASH;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const statusFor = await api.query.preimage.statusFor(hash);\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/features/governance/preimage/#generate-encoded-proposal","title":"How to Generate an Encoded Proposal","text":"<p>To generate an encoded proposal, you must first create the extrinsic that will be run if the proposal passes the governance process. Instead of attempting to send the extrinsic, you'll obtain the SCALE-encoded hash of the extrinsic, which you'll use to submit the preimage.</p> <p>For example, if you wanted to set an on-chain remark that said \"Hello World,\" you could generate the encoded call data using the following snippet:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('ws://127.0.0.1:9944'),\n  });\n\n  const encodedProposal = api.tx.system.remark('Hello World').method.toHex();\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> <p>Then, you can use the encoded call data to submit the preimage for the proposal:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const encodedProposal = api.tx.system.remark('Hello World').method.toHex();\n\n  const tx = api.tx.preimage.notePreimage(encodedProposal);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/features/governance/referenda/","title":"The Referenda Pallet","text":""},{"location":"builders/substrate/interfaces/features/governance/referenda/#introduction","title":"Introduction","text":"<p>The Referenda Pallet allows token holders to make, delegate, and manage Conviction-weighted votes on referenda.</p> <p>Governance-related functionality is based on three new pallets and precompiles: the Preimage Pallet and Preimage Precompile, the Referenda Pallet and Referenda Precompile, and the Conviction Voting Pallet and Conviction Voting Precompile. The aforementioned precompiles are Solidity interfaces that enable you to perform governance functions using the Ethereum API.</p> <p>This guide will provide an overview of the extrinsics, storage methods, and getters for the pallet constants available in the Referenda Pallet on Moonbeam. This guide assumes you are familiar with governance-related terminology, if not, please check out the governance overview page for more information.</p>"},{"location":"builders/substrate/interfaces/features/governance/referenda/#referenda-pallet-interface","title":"Referenda Pallet Interface","text":""},{"location":"builders/substrate/interfaces/features/governance/referenda/#extrinsics","title":"Extrinsics","text":"<p>The Referenda Pallet provides the following extrinsics (functions):</p> cancel(index) - cancels an ongoing referendum given the index of the referendum to cancel. This type of action requires a proposal to be created and assigned to either the Root Track or the Emergency Canceller Track ParametersPolkadot.js API Example <ul> <li><code>index</code> - the index of the referendum to cancel</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst index = INSERT_REFERENDUM_INDEX;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.referenda.cancel(index);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> kill(index) - cancels an ongoing referendum and slashes the deposits given the index of the referendum to cancel. This type of action requires a proposal to be created and assigned to either the Root Track or the Emergency Killer Track ParametersPolkadot.js API Example <ul> <li><code>index</code> - the index of the referendum to kill</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst index = INSERT_REFERENDUM_INDEX;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.referenda.kill(index);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> placeDecisionDeposit(index) - posts the Decision Deposit for a referendum, given the index of the referendum ParametersPolkadot.js API Example <ul> <li><code>index</code> - the index of the referendum to place the Decision Deposit for</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst index = INSERT_REFERENDUM_INDEX;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.referenda.placeDecisionDeposit(index);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> refundDecisionDeposit(index) - refunds the Decision Deposit for a closed referendum back to the depositor, given the index of the referendum ParametersPolkadot.js API Example <ul> <li><code>index</code> - the index of the referendum to refund the Decision Deposit for</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst index = INSERT_REFERENDUM_INDEX;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.referenda.refundDecisionDeposit(index);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> refundSubmissionDeposit(index) - refunds the Submission Deposit for a closed referendum back to the depositor, given the index of the referendum ParametersPolkadot.js API Example <ul> <li><code>index</code> - the index of the referendum to refund the Submission Deposit for</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst index = INSERT_REFERENDUM_INDEX;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.referenda.refundSubmissionDeposit(index);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> submit(proposalOrigin, proposal, enactmentMoment) - proposes a referendum on a privileged action given the Origin from which the proposal should be executed, the proposal, and the moment that the proposal should be enacted ParametersPolkadot.js API Example <ul> <li><code>proposalOrigin</code> - the Origin and, by extension, the Track from which the proposal should be executed. Typically, this should be set to one of the following:<ul> <li><code>system</code> - indicates the proposal should be executed by a system-level Origin. You can specify the name of the Origin or the index associated with the Origin:<ul> <li><code>Root</code> or <code>0</code> - submits a proposal to the Root Track</li> </ul> </li> <li><code>Origins</code> - indicates the proposal should be executed by one of the governance Origins. To submit a proposal to any of the Tracks aside from Root, you can specify the name of the Origin or the index associated with the Origin:<ul> <li><code>WhitelistedCaller</code> or <code>0</code> - submits a proposal to the Whitelisted Track</li> <li><code>GeneralAdmin</code> or <code>1</code> - submits a proposal to the General Admin Track</li> <li><code>ReferendumCanceller</code> or <code>2</code> - submits a proposal to the Emergency Canceller Track</li> <li><code>ReferendumKiller</code> or <code>3</code> - submits a proposal to the Emergency Killer Track</li> </ul> </li> </ul> </li> <li><code>proposal</code> - the action being proposed. To define the proposal to submit, you can use the following method: <ul> <li><code>Lookup</code> - defines the preimage associated with the proposal using the following arguments:<ul> <li><code>hash_</code> - the hash of the preimage</li> <li><code>len</code> - the length of the preimage</li> </ul> </li> </ul> </li> <li><code>enactmentMoment</code> - when the proposal will be executed, either at a specific block or after a specific number of blocks:<ul> <li><code>At</code> -  a specific block to enact the proposal at</li> <li><code>After</code> - the number of blocks to delay enactment after proposal approval</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst proposalOrigin = INSERT_PROPOSAL_ORIGIN;\n/*\nFor Root Origin, use the following format:\nconst proposalOrigin = { system: 'Root' };\n\nFor all other OpenGov Origins, use the following format:\nconst proposalOrigin = { Origins: 'INSERT_ORIGIN_NAME_OR_INDEX' };\n*/\n\nconst proposal = {\n  Lookup: {\n    hash_: 'INSERT_PREIMAGE_HASH',\n    len: 'INSERT_PREIMAGE_LENGTH',\n  },\n};\n\nconst enactmentMoment = { At: INSERT_BLOCK };\n/*\nOr for After, use the following:\nconst enactmentMoment = { After: INSERT_BLOCK }\n*/\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.referenda.submit(proposalOrigin, proposal, enactmentMoment);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/features/governance/referenda/#storage-methods","title":"Storage Methods","text":"<p>The Referenda Pallet includes the following read-only storage methods to obtain chain state data:</p> decidingCount(index) - returns the number of referenda being decided currently ParametersReturnsPolkadot.js API Example <ul> <li><code>index</code> - the index of the Track to get the deciding count for. The index for each Track is as follows:<ul> <li><code>0</code> - Root Track</li> <li><code>1</code> - Whitelisted Track</li> <li><code>2</code> - General Admin Track</li> <li><code>3</code> - Emergency Canceller Track</li> <li><code>4</code> - Emergency Killer Track</li> </ul> </li> </ul> <p>The number of referenda currently being decided on for the given Track.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n1\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst track = INSERT_TRACK_INDEX;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const statusFor = await api.query.referenda.decidingCount(track);\n};\n\nmain();\n</code></pre> palletVersion() - returns the current pallet version ParametersReturnsPolkadot.js API Example <p>None.</p> <p>A number representing the current version of the pallet.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n0\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const palletVersion = await api.query.referenda.palletVersion();\n};\n\nmain();\n</code></pre> referendumCount() - returns the number of referenda started so far ParametersReturnsPolkadot.js API Example <p>None.</p> <p>The number of referenda started so far.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n1\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const statusFor = await api.query.referenda.referendumCount();\n};\n\nmain();\n</code></pre> referendumInfoFor(index) - returns information concerning any given referendum ParametersReturnsPolkadot.js API Example <ul> <li><code>index</code> - the index of the referendum to get the information for</li> </ul> <p>The status of the referendum and additional information depending on the status. The status can be any of the following:</p> OngoingApprovedRejectedCancelledTimed OutKilled <p>The referendum has been submitted and is being voted on. The returned data includes information on the proposal, the deposits, the current state of the referendum, and more.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n{\n  ongoing: {\n    track: 2,\n    origin: { origins: 'GeneralAdmin' },\n    proposal: { \n      lookup: {\n        hash: '0xa5d90079f950888dabb2ef77e159096701784141dd2c8c95a67ced96ec0c1c21',\n        len: 15\n      } \n    },\n    enactment: { after: 100 },\n    submitted: 5724140,\n    submissionDeposit: {\n      who: '0xD720165D294224A7d16F22ffc6320eb31f3006e1',\n      amount: '0x00000000000000008ac7230489e80000'\n    },\n    decisionDeposit: {\n      who: '0xD720165D294224A7d16F22ffc6320eb31f3006e1',\n      amount: '0x000000000000001b1ae4d6e2ef500000'\n    },\n    deciding: { since: 5724440, confirming: null },\n    tally: { ayes: 0, nays: 0, support: 0 },\n    inQueue: false,\n    alarm: [ 5825240, [ 5825240, 0 ] ]\n  }\n}               \n</code></pre> <p>The referendum finished with approval. The returned data includes the block at which the proposal was approved and deposit information, including the account(s) that placed a deposit and the deposit amount for that account.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n{\n  approved: [\n    3715966, // Block at which the proposal was approved\n    { // Deposit information\n      who: '0xE6c5B9500035cb5557E8FDBAa758d78a15361A0E',\n      amount: '0x00000000000000056bc75e2d63100000'\n    },\n    null // Additional deposit information or null if there isn't any\n  ]\n}\n</code></pre> <p>The referendum ended with a rejection. The returned data includes the block at which the proposal was rejected and deposit information, including the account(s) that placed a deposit and the deposit amount for that account.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n{\n  rejected: [\n    5213165, // Block at which the proposal was rejected\n    { // Deposit information\n      who: '0xb926E36D439106090Be1151347CFB916E44AFE00',\n      amount: '0x00000000000000008ac7230489e80000'\n    },\n    null // Additional deposit information or null if there isn't any\n  ]\n}\n</code></pre> <p>The referendum ended with a cancellation. The returned data includes the block at which the proposal was cancelled and deposit information, including the account(s) that placed a deposit and the deposit amount for that account.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n{\n  cancelled: [\n    3613947, // Block at which the proposal was cancelled\n    { // Deposit information\n      who: '0xE6c5B9500035cb5557E8FDBAa758d78a15361A0E',\n      amount: '0x00000000000000056bc75e2d63100000'\n    },\n    null // Additional deposit information or null if there isn't any\n  ]\n}\n</code></pre> <p>The referendum ended and was never decided. The returned data includes the block at which the proposal timed out and deposit information, including the account(s) that placed a deposit and the deposit amount for that account.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n{\n  timedOut: [\n    4585127, // Block at which the proposal timed out\n    { // Deposit information\n      who: '0x657a901AFC4d85A28eEf0F6696E42ae2099219cd',\n      amount: '0x00000000000000008ac7230489e80000'\n    },\n    null // Additional deposit information or null if there isn't any\n  ]\n}\n</code></pre> <p>The referendum ended with a kill. The block at which the referendum was killed is returned.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n{ killed: 1806494 } // The block at which the referendum was killed\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst index = INSERT_REFERENDUM_INDEX;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const referendumInfoFor = await api.query.referenda.referendumInfoFor(index);\n};\n\nmain();\n</code></pre> trackQueue(index) - returns the sorted list of referenda ready to be decided but not yet being decided on for a given Track. The referenda are sorted by Conviction-weighted approvals ParametersReturnsPolkadot.js API Example <ul> <li><code>index</code> - the index of the Track to get the queue information for. The index for each Track is as follows:<ul> <li><code>0</code> - Root Track</li> <li><code>1</code> - Whitelisted Track</li> <li><code>2</code> - General Admin Track</li> <li><code>3</code> - Emergency Canceller Track</li> <li><code>4</code> - Emergency Killer Track</li> </ul> </li> </ul> <p>The list of referenda queued for a given Track. This should return an empty array if the deciding count is less than the maximum number of referenda that can be decided on.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n[ \n  [ \n    5, // Referendum Index\n    0  // Track Index\n  ]\n]\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst index = INSERT_TRACK_INDEX;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const trackQueue = await api.query.referenda.trackQueue(index);\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/features/governance/referenda/#constants","title":"Pallet Constants","text":"<p>The Referenda Pallet includes the following read-only functions to obtain pallet constants:</p> maxQueued() - returns the maximum size of the referendum queue for a single Track ParametersReturnsPolkadot.js API Example <p>None.</p> <p>The maximum number of queued referenda for a single Track.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n100\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const maxQueued = api.consts.referenda.maxQueued;\n};\n\nmain();\n</code></pre> submissionDeposit() - returns the minimum amount to be used as a deposit for a public referendum proposal ParametersReturnsPolkadot.js API Example <p>None.</p> <p>The minimum amount required for the Submission Deposit.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n0x00000000000000008ac7230489e80000\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const submissionDeposit = api.consts.referenda.submissionDeposit;\n};\n\nmain();\n</code></pre> tracks() - returns information concerning the different referendum Tracks ParametersReturnsPolkadot.js API Example <p>None.</p> <p>Information on each Track. This includes general, period, and Approval and Support parameters.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n[\n  [\n    0, // Track Index\n    {\n      name: 'root',\n      maxDeciding: 5,\n      decisionDeposit: '0x000000000000152d02c7e14af6800000',\n      preparePeriod: 7200,\n      decisionPeriod: 100800,\n      confirmPeriod: 7200,\n      minEnactmentPeriod: 7200,\n      minApproval: { \n        reciprocal: { factor: 999999999, xOffset: 999999999, yOffset: 0 } \n      },\n      minSupport: {\n        linearDecreasing: { length: 1000000000, floor: 5000000, ceil: 250000000 }\n      }\n    }\n  ],\n  [\n    1,\n    {\n      name: 'whitelisted_caller',\n      maxDeciding: 100,\n      decisionDeposit: '0x000000000000021e19e0c9bab2400000',\n      preparePeriod: 50,\n      decisionPeriod: 100800,\n      confirmPeriod: 50,\n      minEnactmentPeriod: 150,\n      minApproval: {\n        reciprocal: { factor: 999999999, xOffset: 999999999, yOffset: 0 } \n      },\n      minSupport: { \n        reciprocal: { factor: 60061, xOffset: 2994150, yOffset: -59882 } \n      }\n    }\n  ],\n  [\n    2,\n    {\n      name: 'general_admin',\n      maxDeciding: 10,\n      decisionDeposit: '0x000000000000001b1ae4d6e2ef500000',\n      preparePeriod: 300,\n      decisionPeriod: 100800,\n      confirmPeriod: 7200,\n      minEnactmentPeriod: 7200,\n      minApproval: { \n        reciprocal: { factor: 999999999, xOffset: 999999999, yOffset: 0 } \n      },\n      minSupport: { \n        reciprocal: { factor: 222222224, xOffset: 333333335, yOffset: -166666668 }\n      }\n    }\n  ],\n  [\n    3,\n    {\n      name: 'referendum_canceller',\n      maxDeciding: 20,\n      decisionDeposit: '0x000000000000021e19e0c9bab2400000',\n      preparePeriod: 300,\n      decisionPeriod: 100800,\n      confirmPeriod: 900,\n      minEnactmentPeriod: 50,\n      minApproval: { \n        reciprocal: { factor: 999999999, xOffset: 999999999, yOffset: 0 } \n      },\n      minSupport: { \n        reciprocal: { factor: 787400, xOffset: 1572327, yOffset: -786164 }\n      }\n    }\n  ],\n  [\n    4,\n    {\n      name: 'referendum_killer',\n      maxDeciding: 100,\n      decisionDeposit: '0x000000000000043c33c1937564800000',\n      preparePeriod: 300,\n      decisionPeriod: 100800,\n      confirmPeriod: 900,\n      minEnactmentPeriod: 50,\n      minApproval: { \n        reciprocal: { factor: 999999999, xOffset: 999999999, yOffset: 0 }\n      },\n      minSupport: { \n        reciprocal: { factor: 869501, xOffset: 8620680, yOffset: -862069 }\n      }\n    }\n  ]\n]\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tracks = api.consts.referenda.tracks;\n};\n\nmain();\n</code></pre> undecidingTimeout() - the number of blocks after submission that a referendum must begin being decided by. Once this passes, then anyone may cancel the referendum ParametersReturnsPolkadot.js API Example <p>None.</p> <p>The number of blocks before a timeout occurs.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n151200\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const undecidingTimeout = api.consts.referenda.undecidingTimeout;\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/utility/utility/","title":"The Utility Pallet","text":""},{"location":"builders/substrate/interfaces/utility/utility/#introduction","title":"Introduction","text":"<p>Through Substrate's Utility Pallet, users on Moonbeam can include multiple calls into a single transaction through the two available batch extrinsics and use derivative accounts to send calls.</p> <p>This guide will provide an overview and examples of the extrinsics and getters for the pallet constants available in the Utility Pallet on Moonbeam.</p>"},{"location":"builders/substrate/interfaces/utility/utility/#derivative-accounts","title":"Derivative Accounts","text":"<p>Derivative accounts are accounts that are derived from another account using an index. This enables the derivative account to dispatch transactions and use the origin account to pay for transaction fees. Since the private key of this account is unknown, transactions must be initiated with the <code>asDerivative</code> extrinsic of this pallet. For example, Alice has a derivative account with an index of <code>0</code>. If she transfers any balance using the <code>asDerivative</code> function, Alice would still pay for transaction fees, but the funds being transferred will be withdrawn from the derivative account at index <code>0</code>.</p> <p>The derivation is done by calculating the Blake2 hash of <code>modlpy/utilisuba</code> + <code>originalAddress</code> + <code>index</code>.  You can use a script to calculate a derivative account given an origin account and index.</p> <p>One use case of derivative accounts can be found in the XCM Transactor Pallet. The pallet allows users to perform remote cross-chain calls from an account derived from the Sovereign account, which enables the calls to be easily executed with a simple transaction. For more information, please refer to the Using the XCM Transactor Pallet for Remote Executions guide.</p>"},{"location":"builders/substrate/interfaces/utility/utility/#utility-pallet-interface","title":"Utility Pallet Interface","text":""},{"location":"builders/substrate/interfaces/utility/utility/#extrinsics","title":"Extrinsics","text":"<p>The Utility Pallet provides the following extrinsics (functions):</p> asDerivative(index, call) - sends a call through an indexed pseudonym of the sender ParametersPolkadot.js API Example <ul> <li><code>index</code> - the indexed pseudonym of the sender</li> <li><code>call</code> - the encoded call data of the call</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst index = INSERT_INDEX;\nconst call = 'INSERT_ENCODED_CALL_DATA';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.utility.asDerivative(index, call);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> batch(calls) - sends a batch of calls to be dispatched. If a call fails, any successful calls up until that point will be processed, and a <code>BatchInterrupted</code> event will be emitted. If all calls are successful, then the <code>BatchCompleted</code> event is emitted. The number of calls must not exceed the limit ParametersPolkadot.js API Example <ul> <li><code>calls</code> - an array that contains the encoded call data for each of the calls to be dispatched</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst calls = ['INSERT_ENCODED_CALL_DATA'];\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.utility.batch(calls);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> batchAll(calls) - sends a batch of calls to be dispatched and atomically executes them. If one of the calls fails, the entire transaction will roll back and fail. The number of calls must not exceed the limit ParametersPolkadot.js API Example <ul> <li><code>calls</code> - an array that contains the encoded call data for each of the calls to be dispatched</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst calls = ['INSERT_ENCODED_CALL_DATA'];\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.utility.batchAll(calls);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> dispatchAs(asOrigin, call) - dispatches a function call provided an origin and the call to be dispatched. The dispatch origin for this call must be Root ParametersPolkadot.js API Example <ul> <li><code>asOrigin</code> - the dispatch origin</li> <li><code>call</code> - the encoded call data of the call to be dispatched</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst asOrigin = { System: 'Root' };\nconst call = 'INSERT_ENCODED_CALL_DATA';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.utility.dispatchAs(asOrigin, call);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n\n  api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/utility/utility/#constants","title":"Pallet Constants","text":"<p>The Utility Pallet includes the following read-only functions to obtain pallet constants:</p> batchedCallsLimit() - returns the limit on the number of batched calls ParametersReturnsPolkadot.js API Example <p>None.</p> <p>The maximum number of calls that can be batched.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the query results\n10922\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const batchedCallsLimit = api.consts.utility.batchedCallsLimit;\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/interfaces/utility/utility/#generating-encoded-call-data","title":"Generating Encoded Call Data","text":"<p>To use the extrinsics in the Utility Pallet, you'll need to generate the encoded call data of the call(s) that you're dispatching. You can do this using the Polkadot.js API. You'll assemble the call, and instead of signing and sending it, you'll call <code>method.toHex()</code> on the assembled call to get the encoded call data.</p> <p>For example, to generate the encoded call data of a simple transfer extrinsic, you can use the following code snippet:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const tx = api.tx.balances.transferAllowDeath('INSERT_ADDRESS', 'INSERT_AMOUNT');\n  const encodedCallData = tx.method.toHex();\n};\n\nmain();\n</code></pre> <p>You can then pass the <code>encodedCallData</code> value into the extrinsic that you're using.</p>"},{"location":"builders/substrate/interfaces/utility/utility/#using-the-batch-extrinsics","title":"Using the Batch Extrinsics","text":"<p>You can access the batch extrinsics using the Polkadot.js Apps interface or through the Polkadot.js API. This example will show you how to use the <code>batch</code> extrinsic with Polkadot.js Apps. If you're using the Polkadot.js API, you can access the Utility Pallet through the <code>api.tx.utility.batch</code> interface. For more information on batching transactions with the API, please refer to the Polkadot.js API Library page.</p> <p>To get started, you can navigate to Polkadot.js Apps and connect to Moonbase Alpha. This example can also be adapted for Moonbeam or Moonriver.</p> <p>You can send any combination of calls, whether they're balance transfers, democracy actions, staking actions, or more.</p> <p>As a basic example, you can send two balance transfers at once. To get started, click on the Developer dropdown, select Extrinsics, and take the following steps:</p> <ol> <li>Select the account to submit the <code>batch</code> extrinsic with</li> <li>Choose utility from the submit the following extrinsic menu</li> <li>Select the batch extrinsic</li> <li>Fields for the first call should already appear, and to add a second call click on Add item</li> <li>For the first call, select balances</li> <li>Choose the transfer extrinsic</li> <li>Enter the destination account to send the funds to</li> <li>Enter an amount of DEV tokens to send in the value field, make sure you account for 18 decimals</li> <li>For the second call, you can repeat steps 5 through 8</li> <li>To send the calls at once, click on Submit Transaction</li> </ol> <p></p> <p>Next, you will need to enter your password and click on Sign and Submit. Then you can review the extrinsic on Subscan</p> <p>Note</p> <p>As a reference, you can view the exact extrinsic for this example on Subscan.</p> <p>If you take a look at the Events tab at the bottom of the extrinsic page, you should see several events, including two <code>balances (Transfer)</code> events, two <code>utility (ItemCompleted)</code> events, and a <code>utility (BatchCompleted)</code> event containing the details of the batch transaction.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/","title":"Polkadot.js API Library","text":""},{"location":"builders/substrate/libraries/polkadot-js-api/#introduction","title":"Introduction","text":"<p>Polkadot.js is a collection of tools that allow you to interact with Polkadot and its parachains, such as Moonbeam. The Polkadot.js API is one component of Polkadot.js and is a library that allows application developers to query a Moonbeam node and interact with the node's Substrate interfaces using JavaScript, enabling you to read and write data to the network.</p> <p>You can use the Polkadot.js API to query on-chain data and send extrinsics from the Substrate side of Moonbeam. You can query Moonbeam's runtime constants, chain state, events, transaction (extrinsic) data, and more.</p> <p>Here you will find an overview of the available functionalities and some commonly used code examples to get you started on interacting with Moonbeam networks using the Polkadot.js API library.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Installing and using Polkadot.js API library requires Node.js to be installed.</p> <p>You need to install Node.js (for this example, you can use v16.x) and the npm package manager. You can download directly from Node.js or in your terminal:</p> UbuntuMacOS <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n\nsudo apt install -y nodejs\n</code></pre> <pre><code># You can use homebrew (https://docs.brew.sh/Installation)\nbrew install node\n\n# Or you can use nvm (https://github.com/nvm-sh/nvm)\nnvm install node\n</code></pre> <p>You can verify that everything is installed correctly by querying the version for each package:</p> <pre><code>node -v\n</code></pre> <pre><code>npm -v\n</code></pre> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#installing-polkadot.js-api-library","title":"Install Polkadot.js API","text":"<p>First, you need to install the Polkadot.js API library for your project through a package manager such as <code>yarn</code>. Install it in your project directory with the following command:</p> npmyarn <pre><code>npm i @polkadot/api\n</code></pre> <pre><code>yarn add @polkadot/api\n</code></pre> <p>The library also includes other core components like Keyring for account management, or some utilities that are used throughout this guide.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#creating-an-API-provider-instance","title":"Create an API Provider Instance","text":"<p>Similar to Ethereum API libraries, you must first instantiate an API instance of the Polkadot.js API. Create the <code>WsProvider</code> using the WebSocket endpoint of the Moonbeam network you wish to interact with.</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_API_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n}\n\nmain();\n</code></pre> <pre><code>// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_API_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n}\n\nmain();\n</code></pre> <pre><code>// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n}\n\nmain();\n</code></pre> <pre><code>// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('ws://127.0.0.1:9944');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n}\n\nmain();\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#metadata-and-dynamic-api-decoration","title":"Metadata and Dynamic API Decoration","text":"<p>Before diving into the details of performing different tasks via the Polkadot.js API library, it's useful to understand some of the basic workings of the library.</p> <p>When the Polkadot.js API connects to a node, one of the first things it does is retrieve the metadata and decorate the API based on the metadata information. The metadata effectively provides data in the form of:</p> <pre><code>api.&lt;type&gt;.&lt;module&gt;.&lt;section&gt;\n</code></pre> <p>Where <code>&lt;type&gt;</code> can be either:</p> <ul> <li><code>query</code> - for endpoints to read all the state queries</li> <li><code>tx</code> - for endpoints related to transactions</li> <li><code>rpc</code> - for endpoints specific to RPC calls</li> <li><code>consts</code> - for endpoints specific to runtime constants</li> </ul> <p>And therefore, none of the information contained in the <code>api.{query, tx, rpc, consts}.&lt;module&gt;.&lt;method&gt;</code> endpoints are hard-coded in the API. This allows parachains like Moonbeam to have custom endpoints through its pallets that can be directly accessed via the Polkadot.js API library.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#querying-for-information","title":"Query On-Chain Data on Moonbeam","text":"<p>In this section, you will learn how to query for on-chain information using the Polkadot.js API library.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#state-queries","title":"Moonbeam Chain State Queries","text":"<p>This category of queries retrieves information related to the current state of the chain. These endpoints are generally of the form <code>api.query.&lt;module&gt;.&lt;method&gt;</code>, where the module and method decorations are generated through metadata. You can see a list of all available endpoints by examining the <code>api.query</code> object, for example via:</p> <pre><code>console.log(api.query);\n</code></pre> <p>Assuming you've initialized the API, here is a code sample for retrieving basic account information given its address :</p> <pre><code>// Define wallet address\nconst addr = 'INSERT_ADDRESS';\n\n// Retrieve the last timestamp\nconst now = await api.query.timestamp.now();\n\n// Retrieve the account balance &amp; current nonce via the system module\nconst { nonce, data: balance } = await api.query.system.account(addr);\n\nconsole.log(\n  `${now}: balance of ${balance.free} and a current nonce of ${nonce}`\n);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Define wallet address\n  const addr = 'INSERT_ADDRESS';\n\n  // Retrieve the last timestamp via the timestamp module\n  const now = await api.query.timestamp.now();\n\n  // Retrieve the account balance &amp; current nonce via the system module\n  const { nonce, data: balance } = await api.query.system.account(addr);\n\n  console.log(\n    `${now}: balance of ${balance.free} and a current nonce of ${nonce}`\n  );\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#rpc-queries","title":"Moonbeam RPC Queries","text":"<p>The RPC calls provide the backbone for the transmission of data to and from the node. This means that all API endpoints such as <code>api.query</code>, <code>api.tx</code> or <code>api.derive</code> just wrap RPC calls, providing information in the encoded format as expected by the node. You can see a list of all available endpoints by examining the <code>api.rpc</code> object, for example via:</p> <pre><code>console.log(api.rpc);\n</code></pre> <p>The <code>api.rpc</code> interface follows the a similar format to <code>api.query</code>, for instance:</p> <pre><code>// Retrieve the chain name\nconst chain = await api.rpc.system.chain();\n\n// Retrieve the latest header\nconst lastHeader = await api.rpc.chain.getHeader();\n\n// Log the information\nconsole.log(\n  `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain name\n  const chain = await api.rpc.system.chain();\n\n  // Retrieve the latest header\n  const lastHeader = await api.rpc.chain.getHeader();\n\n  // Log the information\n  console.log(\n    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n  );\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#query-subscriptions","title":"Query Subscriptions","text":"<p>The <code>rpc</code> API also provide endpoints for subscriptions. You can adapt the previous example to start using subscriptions to listen to new blocks. Note that you need to remove the API disconnect when using subscriptions, to avoid normal closures of the WSS connection.</p> <pre><code>// Retrieve the chain name\nconst chain = await api.rpc.system.chain();\n\n// Subscribe to the new headers\nawait api.rpc.chain.subscribeNewHeads((lastHeader) =&gt; {\n  console.log(\n    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n  );\n});\n// Remove await api.disconnect()!\n</code></pre> <p>The general pattern for <code>api.rpc.subscribe*</code> functions is to pass a callback into the subscription function, and this will be triggered on each new entry as they are imported.</p> <p>Other calls under <code>api.query.*</code> can be modified in a similar fashion to use subscription, including calls that have parameters. Here is an example of how to subscribe to balance changes in an account:</p> <pre><code>// Define wallet address\nconst addr = 'INSERT_ADDRESS';\n\n// Subscribe to balance changes for a specified account\nawait api.query.system.account(addr, ({ nonce, data: balance }) =&gt; {\n  console.log(\n    `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`\n  );\n});\n\n// Remove await api.disconnect()!\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain name\n  const chain = await api.rpc.system.chain();\n\n  // Subscribe to the new headers\n  await api.rpc.chain.subscribeNewHeads((lastHeader) =&gt; {\n    console.log(\n      `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n    );\n  });\n\n  // Define wallet address\n  const addr = 'INSERT_ADDRESS';\n\n  // Subscribe to balance changes for a specified account\n  await api.query.system.account(addr, ({ nonce, data: balance }) =&gt; {\n    console.log(\n      `free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`\n    );\n\n    // Handle API disconnect here if needed\n  });\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#keyrings","title":"Create a Keyring for a Moonbeam Account","text":"<p>The Keyring object is used for maintaining key pairs, and the signing of any data, whether it's a transfer, a message, or a contract interaction.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#creating-a-keyring-instance","title":"Create a Keyring Instance","text":"<p>You can create an instance by just creating an instance of the Keyring class, and specifying the default type of wallet address used. For Moonbeam networks, the default wallet type should be <code>ethereum</code>.</p> <pre><code>// Import the keyring as required\nimport Keyring from '@polkadot/keyring';\n\n// Create a keyring instance\nconst keyring = new Keyring({ type: 'ethereum' });\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#adding-accounts","title":"Add an Account to a Keyring","text":"<p>There are a number of ways to add an account to the keyring instance, including from the mnemonic phrase and from the shortform private key.</p> From MnemonicFrom Private Key <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\nimport { u8aToHex } from '@polkadot/util';\nimport { mnemonicToLegacySeed, hdEthereum } from '@polkadot/util-crypto';\n\n// Import Ethereum account from mnemonic\nconst keyringECDSA = new Keyring({ type: 'ethereum' });\nconst mnemonic = 'INSERT_MNEMONIC';\n\n// Define index of the derivation path and the derivation path\nconst index = 0;\nconst ethDerPath = \"m/44'/60'/0'/0/\" + index;\nconsole.log(`Mnemonic: ${mnemonic}`);\nconsole.log(`--------------------------\\n`);\n\n// Extract Ethereum address from mnemonic\nconst alice = keyringECDSA.addFromUri(`${mnemonic}/${ethDerPath}`);\nconsole.log(`Ethereum Derivation Path: ${ethDerPath}`);\nconsole.log(`Derived Ethereum Address from Mnemonic: ${alice.address}`);\n\n// Extract private key from mnemonic\nconst privateKey = u8aToHex(\n  hdEthereum(mnemonicToLegacySeed(mnemonic, '', false, 64), ethDerPath)\n    .secretKey\n);\nconsole.log(`Derived Private Key from Mnemonic: ${privateKey}`);\n</code></pre> <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\n\n// Import Ethereum account from mnemonic\nconst keyringECDSA = new Keyring({ type: 'ethereum' });\nconst privateKeyInput = 'INSERT_PK';\n\n// Extract address from private key\nconst alice = keyringECDSA.addFromUri(privateKeyInput);\nconsole.log(`Derived Address from provided Private Key: ${alice.address}`);\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#dry-run-api","title":"Dry Run API","text":"<p>The Dry Run API is an easy and convenient way to test the integrity of a call without incurring any transaction fees. The Dry Run API can be accessed from the Runtime Calls tab of the Developer section of Polkadot.js Apps. While primarily intended for the testing of XCM messages, the Dry Run API can be used to test any arbitrary call.</p> <p>This method takes the origin and call data as parameters and returns an execution result and additional event data. </p> <pre><code>const testAccount = api.createType(\n  'AccountId20',\n  '0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798'\n);\nconst callData =\n  '0x030088bce0b038effa09e58fe6d24fde4b5af21aa79813000064a7b3b6e00d';\nconst callDataU8a = hexToU8a(callData);\n\nconst result = await api.call.dryRunApi.dryRunCall(\n  { system: { Signed: testAccount } },\n  callDataU8a\n);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { hexToU8a } from '@polkadot/util';\n\nconst main = async () =&gt; {\n  try {\n    // Construct API provider\n    const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n    const api = await ApiPromise.create({ provider: wsProvider });\n\n    console.log('Connected to the API. Preparing dry run call...');\n\n    // Create a test account (you should replace this with an actual account)\n    const testAccount = api.createType(\n      'AccountId20',\n      '0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798'\n    );\n\n    // The call data (replace with your actual call data)\n    const callData =\n      '0x030088bce0b038effa09e58fe6d24fde4b5af21aa79813000064a7b3b6e00d'; // Your hex-encoded call data\n\n    // Convert hex to Uint8Array\n    const callDataU8a = hexToU8a(callData);\n\n    // Perform the dry run call\n    const result = await api.call.dryRunApi.dryRunCall(\n      { system: { Signed: testAccount } }, // origin\n      callDataU8a // call\n    );\n\n    console.log(\n      'Dry run XCM result:',\n      JSON.stringify(result.toJSON(), null, 2)\n    );\n\n    // Disconnect the API\n    await api.disconnect();\n    console.log('Disconnected from the API.');\n  } catch (error) {\n    console.error('An error occurred:', error);\n  }\n};\n\nmain().catch(console.error);\n</code></pre> <p>Upon calling the Dry Run API, the method will tell you whether the call would be successful and returns the event data that would be emitted if the call were actually submitted on chain. You can view the initial output of the <code>dryRunCall</code> below.</p> View the complete output <pre><code>Dry run XCM result: {\n  \"ok\": {\n    \"executionResult\": {\n      \"ok\": {\n        \"actualWeight\": null,\n        \"paysFee\": \"Yes\"\n      }\n    },\n    \"emittedEvents\": [],\n    \"localXcm\": null,\n\n      // Additional data returned here\n      // Omitted for clarity \n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#transactions","title":"Send Transactions on Moonbeam","text":"<p>Transaction endpoints are exposed on endpoints generally of the form <code>api.tx.&lt;module&gt;.&lt;method&gt;</code>, where the module and method decorations are generated through metadata. These allow you to submit transactions for inclusion in blocks, be it transfers, interacting with pallets, or anything else Moonbeam supports. You can see a list of all available endpoints by examining the <code>api.tx</code> object, for example via:</p> <pre><code>console.log(api.tx);\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#sending-basic-transactions","title":"Send a Transaction","text":"<p>The Polkadot.js API library can be used to send transactions to the network. For example, assuming you've initialized the API and a keyring instance, you can use the following snippet to send a basic transaction (this code sample will also retrieve the encoded calldata of the transaction as well as the transaction hash after submitting):</p> <pre><code>// Initialize wallet key pairs\nconst alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\nconst bob = 'INSERT_BOBS_ADDRESS';\n\n// Form the transaction\nconst tx = await api.tx.balances.transferAllowDeath(bob, 12345n);\n\n// Retrieve the encoded calldata of the transaction\nconst encodedCalldata = tx.method.toHex();\nconsole.log(`Encoded calldata: ${encodedCallData}`);\n\n// Sign and send the transaction\nconst txHash = await tx\n  .signAndSend(alice);\n\n// Show the transaction hash\nconsole.log(`Submitted with hash ${txHash}`);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport Keyring from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Create a keyring instance (ECDSA)\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  // Initialize wallet key pairs\n  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n  const bob = 'INSERT_BOBS_ADDRESS';\n\n  // Form the transaction\n  const tx = await api.tx.balances.transferAllowDeath(bob, BigInt(12345));\n\n  // Retrieve the encoded calldata of the transaction\n  const encodedCalldata = tx.method.toHex();\n  console.log(`Encoded calldata: ${encodedCalldata}`);\n\n  // Sign and send the transaction\n  const txHash = await tx.signAndSend(alice);\n\n  // Show the transaction hash\n  console.log(`Submitted with hash ${txHash}`);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre> <p>Note</p> <p>Prior to client v0.35.0, the extrinsic used to perform a simple balance transfer was the <code>balances.transfer</code> extrinsic. It has since been deprecated and replaced with the <code>balances.transferAllowDeath</code> extrinsic.</p> <p>Note that the <code>signAndSend</code> function can also accept optional parameters, such as the <code>nonce</code>. For example, <code>signAndSend(alice, { nonce: aliceNonce })</code>. You can use the sample code from the State Queries section to retrieve the correct nonce, including transactions in the mempool.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#fees","title":"Fee Information","text":"<p>The transaction endpoint also offers a method to obtain weight information for a given <code>api.tx.&lt;module&gt;.&lt;method&gt;</code>. To do so, you'll need to use the <code>paymentInfo</code> function after having built the entire transaction with the specific <code>module</code> and <code>method</code>.</p> <p>The <code>paymentInfo</code> function returns weight information in terms of <code>refTime</code> and <code>proofSize</code>, which can be used to determine the transaction fee. This is extremely helpful when crafting remote execution calls via XCM.</p> <p>For example, assuming you've initialized the API, the following snippet shows how you can get the weight information for a simple balance transfer between two accounts:</p> <pre><code>// Transaction to get weight information\nconst tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(12345));\n\n// Get weight info\nconst { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');\n\nconsole.log(`Transaction weight: ${weight}`);\nconsole.log(`Transaction fee: ${partialFee.toHuman()}`);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Transaction to get weight information\n  const tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(12345));\n\n  // Get weight info\n  const { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');\n\n  console.log(`Transaction weight: ${weight}`);\n  console.log(`Transaction fee: ${partialFee.toHuman()}`);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#transaction-events","title":"Transaction Events","text":"<p>Any transaction will emit events, as a bare minimum this will always be either a <code>system.ExtrinsicSuccess</code> or <code>system.ExtrinsicFailed</code> event for the specific transaction. These provide the overall execution result for the transaction, i.e. execution has succeeded or failed.</p> <p>Depending on the transaction sent, some other events may however be emitted, for instance for a balance transfer event, this could include one or more <code>balance.Transfer</code> events.</p> <p>The Transfer API page includes an example code snippet for subscribing to new finalized block headers, and retrieving all <code>balance.Transfer</code> events.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#batching-transactions","title":"Batch Transactions","text":"<p>The Polkadot.js API allows transactions to be batch processed via the <code>api.tx.utility.batch</code> method. The batched transactions are processed sequentially from a single sender. The transaction fee can be estimated using the <code>paymentInfo</code> helper method.</p> <p>For example, assuming you've initialized the API, a keyring instance and added an account, the following example makes a couple of transfers and also uses the <code>api.tx.parachainStaking</code> module to schedule a request to decrease the bond of a specific collator candidate:</p> <pre><code>// Construct a list of transactions to batch\nconst collator = 'INSERT_COLLATORS_ADDRESS';\nconst txs = [\n  api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(12345)),\n  api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(12345)),\n  api.tx.parachainStaking.scheduleDelegatorBondLess(collator, BigInt(12345)),\n];\n\n// Estimate the fees as RuntimeDispatchInfo, using the signer (either\n// address or locked/unlocked keypair)\nconst info = await api.tx.utility.batch(txs).paymentInfo(alice);\n\nconsole.log(`Estimated fees: ${info}`);\n\n// Construct the batch and send the transactions\napi.tx.utility.batch(txs).signAndSend(alice, ({ status }) =&gt; {\n  if (status.isInBlock) {\n    console.log(`included in ${status.asInBlock}`);\n\n    // Disconnect API here!\n  }\n});\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport Keyring from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Create a keyring instance (ECDSA)\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  // Initialize wallet key pairs\n  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n\n  // Construct a list of transactions to batch\n  const collator = 'INSERT_COLLATORS_ADDRESS';\n  const txs = [\n    api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(12345)),\n    api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(12345)),\n    api.tx.parachainStaking.scheduleDelegatorBondLess(collator, BigInt(12345)),\n  ];\n\n  // Estimate the fees as RuntimeDispatchInfo, using the signer (either\n  // address or locked/unlocked keypair)\n  const info = await api.tx.utility.batch(txs).paymentInfo(alice);\n\n  console.log(`Estimated fees: ${info}`);\n\n  // Construct the batch and send the transactions\n  api.tx.utility.batch(txs).signAndSend(alice, async ({ status }) =&gt; {\n    if (status.isInBlock) {\n      console.log(`Included in ${status.asInBlock}`);\n\n      // Disconnect the API\n      await api.disconnect();\n    }\n  });\n};\n\nmain();\n</code></pre> <p>Note</p> <p>You can check out all of the available functions for the <code>parachainStaking</code> module by adding <code>console.log(api.tx.parachainStaking);</code> to your code.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#substrate-and-custom-json-rpc-endpoints","title":"Substrate and Custom JSON-RPC Endpoints","text":"<p>RPCs are exposed as a method on a specific module. This means that once available, you can call any RPC via <code>api.rpc.&lt;module&gt;.&lt;method&gt;(...params[])</code>. This also works for accessing Ethereum RPCs using the Polkadot.js API, in the form of <code>polkadotApi.rpc.eth.*</code>.</p> <p>Some of the methods available through the Polkadot.js API interface are also available as JSON-RPC endpoints on Moonbeam nodes. This section will provide some examples; you can check for a list of exposed RPC endpoints by calling <code>api.rpc.rpc.methods()</code> or the <code>rpc_methods</code> endpoint listed below.</p> <ul> <li> <p><code>methods()</code></p> <ul> <li>Interface -  <code>api.rpc.rpc.methods</code></li> <li>JSON-RPC - <code>rpc_methods</code></li> <li>Returns - The list of RPC methods that are exposed by the node</li> </ul> <pre><code>  curl --location --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"rpc_methods\",\n    \"params\": []\n  }'\n</code></pre> </li> <li> <p><code>getBlock(hash?: BlockHash)</code></p> <ul> <li>Interface - <code>api.rpc.chain.getBlock</code></li> <li>JSON-RPC - <code>chain_getBlock</code></li> <li>Returns - The header and body of a block as specified by the block hash parameter</li> </ul> <pre><code>  curl --location --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"chain_getBlock\",\n    \"params\": [\"0x870ad0935a27ed8684048860ffb341d469e091abc2518ea109b4d26b8c88dd96\"]\n  }'\n</code></pre> </li> <li> <p><code>getFinalizedHead()</code></p> <ul> <li>Interface <code>api.rpc.chain.getFinalizedHead</code></li> <li>JSON-RPC <code>chain_getFinalizedHead</code></li> <li>Returns The block hash of the last finalized block in the canonical chain</li> </ul> <pre><code>  curl --location --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"chain_getHeader\",\n    \"params\": []\n  }'\n</code></pre> </li> </ul> <p>The Consensus and Finality page has sample code for using the exposed custom and Substrate RPC calls to check the finality of a given transaction.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#utilities","title":"Polkadot.js API Utility Functions","text":"<p>The Polkadot.js API also includes a number of utility libraries for computing commonly used cryptographic primitives and hash functions.</p> <p>The following example computes the deterministic transaction hash of a raw Ethereum legacy transaction by first computing its RLP (Recursive Length Prefix) encoding, then hashing the result with keccak256.</p> <pre><code>import { encode } from '@polkadot/util-rlp';\nimport { keccakAsHex } from '@polkadot/util-crypto';\nimport { numberToHex } from '@polkadot/util';\n\n// Define the raw signed transaction\nconst txData = {\n  nonce: numberToHex(1),\n  gasPrice: numberToHex(21000000000),\n  gasLimit: numberToHex(21000),\n  to: '0xc390cC49a32736a58733Cf46bE42f734dD4f53cb',\n  value: numberToHex(1000000000000000000),\n  data: '',\n  v: '0507',\n  r: '0x5ab2f48bdc6752191440ce62088b9e42f20215ee4305403579aa2e1eba615ce8',\n  s: '0x3b172e53874422756d48b449438407e5478c985680d4aaa39d762fe0d1a11683',\n};\n\n// Extract the values to an array\nvar txDataArray = Object.keys(txData).map(function (key) {\n  return txData[key];\n});\n\n// Calculate the RLP encoded transaction\nvar encoded_tx = encode(txDataArray);\n\n// Hash the encoded transaction using keccak256\nconsole.log(keccakAsHex(encoded_tx));\n</code></pre> <p>You can check the respective NPM repository page for a list of available methods in the <code>@polkadot/util-crypto</code> library and their descriptions.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/substrate/libraries/py-substrate-interface/","title":"Python Substrate Interface","text":""},{"location":"builders/substrate/libraries/py-substrate-interface/#introduction","title":"Introduction","text":"<p>Python Substrate Interface library allows application developers to query a Moonbeam node and interact with the node's Polkadot or Substrate features using a native Python interface. Here you will find an overview of the available functionalities and some commonly used code examples to get you started on interacting with Moonbeam networks using Python Substrate Interface.</p>"},{"location":"builders/substrate/libraries/py-substrate-interface/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> <li>Have <code>pip</code> installed</li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"},{"location":"builders/substrate/libraries/py-substrate-interface/#installing-python-substrate-interface","title":"Installing Python Substrate Interface","text":"<p>You can install Python Substrate Interface library for your project through <code>pip</code>. Run the following command in your project directory:</p> <pre><code>pip install substrate-interface\n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#creating-an-API-provider-instance","title":"Creating an API Provider Instance","text":"<p>Similar to ETH API libraries, you must first instantiate an API instance of Python Substrate Interface API. Create the <code>WsProvider</code> using the websocket endpoint of the Moonbeam network you wish to interact with.</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"INSERT_WSS_API_ENDPOINT\",\n) \n</code></pre> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"INSERT_WSS_API_ENDPOINT\",\n)   \n</code></pre> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)   \n</code></pre> <pre><code># Import\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"ws://127.0.0.1:9944\",\n)   \n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#querying-for-information","title":"Querying for Information","text":"<p>In this section, you will learn how to query for on-chain information of Moonbeam networks using Python Substrate Interface library.</p>"},{"location":"builders/substrate/libraries/py-substrate-interface/#accessing-runtime-constants","title":"Accessing Runtime Constants","text":"<p>All runtime constants, such as <code>BlockWeights</code>, <code>DefaultBlocksPerRound</code> and <code>ExistentialDeposit</code>, are provided in the metadata. You can use the <code>get_metadata_constants</code> method to see a list of available runtime constants within Moonbeam network's metadata.</p> <p>Runtime constants available in the metadata can be queried through the <code>get_constant</code> method.</p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)   \n\n# List of available runtime constants in the metadata\nconstant_list = ws_provider.get_metadata_constants()\nprint(constant_list)\n\n# Retrieve the Existential Deposit constant on Moonbeam, which is 0\nconstant = ws_provider.get_constant(\"Balances\", \"ExistentialDeposit\")\nprint(constant.value)\n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#retrieving-blocks-and-extrinsics","title":"Retrieving Blocks and Extrinsics","text":"<p>You can retrieve basic information about Moonbeam networks, such as blocks and extrinsics, using the Python Substrate Interface API.</p> <p>To retrieve a block, you can use the <code>get_block</code> method. You can also access extrinsics and their data fields inside a block object, which is simply a Python dictionary.</p> <p>To retrieve a block header, you can use the <code>get_block_header</code> method.  </p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# Retrieve the latest block\nblock = ws_provider.get_block()\n\n# Retrieve the latest finalized block\nblock = ws_provider.get_block_header(finalized_only=True)\n\n# Retrieve a block given its Substrate block hash\nblock_hash = \"0xa499d4ebccdabe31218d232460c0f8b91bd08f72aca25f9b25b04b6dfb7a2acb\"\nblock = ws_provider.get_block(block_hash=block_hash)\n\n# Iterate through the extrinsics inside the block\nfor extrinsic in block[\"extrinsics\"]:\n    if \"address\" in extrinsic:\n        signed_by_address = extrinsic[\"address\"].value\n    else:\n        signed_by_address = None\n    print(\n        \"\\nPallet: {}\\nCall: {}\\nSigned by: {}\".format(\n            extrinsic[\"call\"][\"call_module\"].name,\n            extrinsic[\"call\"][\"call_function\"].name,\n            signed_by_address,\n        )\n    )\n</code></pre> <p>Note</p> <p>The block hash used in the above code sample is the Substrate block hash. The standard methods in Python Substrate Interface assume you are using the Substrate version of primitives, such as block or tx hashes.</p>"},{"location":"builders/substrate/libraries/py-substrate-interface/#subscribing-to-new-block-headers","title":"Subscribing to New Block Headers","text":"<p>You can also adapt the previous example to use a subscription based model to listen to new block headers.</p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n\ndef subscription_handler(obj, update_nr, subscription_id):\n    print(f\"New block #{obj['header']['number']}\")\n\n    if update_nr &gt; 10:\n        return {\n            \"message\": \"Subscription will cancel when a value is returned\",\n            \"updates_processed\": update_nr,\n        }\n\n\nresult = ws_provider.subscribe_block_headers(subscription_handler)\n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#querying-for-storage-information","title":"Querying for Storage Information","text":"<p>You can use the <code>get_metadata_storage_functions</code> to see a list of available storage functions within Moonbeam network's metadata.</p> <p>Chain states that are provided in the metadata through storage functions can be queried through the <code>query</code> method.</p> <p>The Substrate system modules, such as <code>System</code>, <code>Timestamp</code>, and <code>Balances</code>, can be queried to provide basic information such as account nonce and balance. The available storage functions are read from the metadata dynamically, so you can also query for storage information on Moonbeam custom modules, such as <code>ParachainStaking</code> and <code>Democracy</code>, for state information that's specific to Moonbeam.</p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# List of available storage functions in the metadata\nmethod_list = ws_provider.get_metadata_storage_functions()\nprint(method_list)\n\n# Query basic account information\naccount_info = ws_provider.query(\n    module=\"System\",\n    storage_function=\"Account\",\n    params=[\"0x578002f699722394afc52169069a1FfC98DA36f1\"],\n)\n# Log the account nonce\nprint(account_info.value[\"nonce\"])\n# Log the account free balance\nprint(account_info.value[\"data\"][\"free\"])\n\n# Query candidate pool information from Moonbeam's Parachain Staking module\ncandidate_pool_info = ws_provider.query(\n    module=\"ParachainStaking\", storage_function=\"CandidatePool\", params=[]\n)\nprint(candidate_pool_info)\n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#signing-and-transactions","title":"Signing and Transactions","text":""},{"location":"builders/substrate/libraries/py-substrate-interface/#creating-a-keypair","title":"Creating a Keypair","text":"<p>The keypair object in Python Substrate Interface is used in the signing of any data, whether it's a transfer, a message, or a contract interaction.  </p> <p>You can create a keypair instance from the shortform private key or from the mnemonic. For Moonbeam networks, you also need to specify the <code>KeypairType</code> to be <code>KeypairType.ECDSA</code>.</p> <pre><code># Imports\nfrom substrateinterface import Keypair, KeypairType\n\n# Define the shortform private key\nprivatekey = bytes.fromhex(\"INSERT_PRIVATE_KEY_WITHOUT_0X_PREFIX\")\n\n# Define the account mnemonic\nmnemonic = \"INSERT_MNEMONIC\"\n\n# Generate the keypair from shortform private key\nkeypair = Keypair.create_from_private_key(privatekey, crypto_type=KeypairType.ECDSA)\n\n# Generate the keypair from mnemonic\nkeypair = Keypair.create_from_mnemonic(mnemonic, crypto_type=KeypairType.ECDSA)\n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#forming-and-sending-a-transaction","title":"Forming and Sending a Transaction","text":"<p>The <code>compose_call</code> method can be used to compose a call payload which can be used as an unsigned extrinsic or a proposal.</p> <p>Then the payload can be signed using a keypair through the <code>create_signed_extrinsic</code> method.</p> <p>The signed extrinsic can then be submitted using the <code>submit_extrinsic</code> method.</p> <p>This method will also return an <code>ExtrinsicReceipt</code> object which contains information about the on-chain execution of the extrinsic. If you need to examine the receipt object, you can set the <code>wait_for_inclusion</code> to <code>True</code> when submitting the extrinsic to wait until the extrinsic is successfully included into the block.</p> <p>The following sample code will show a complete example for sending a transaction.</p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface, Keypair, KeypairType\nfrom substrateinterface.exceptions import SubstrateRequestException\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# Define the shortform private key of the sending account\nprivatekey = bytes.fromhex(\"INSERT_PRIVATE_KEY_WITHOUT_0X_PREFIX\")\n\n# Generate the keypair\nkeypair = Keypair.create_from_private_key(privatekey, crypto_type=KeypairType.ECDSA)\n\n# Form a transaction call\ncall = ws_provider.compose_call(\n    call_module=\"Balances\",\n    call_function=\"transfer_allow_death\",\n    call_params={\n        \"dest\": \"0x44236223aB4291b93EEd10E4B511B37a398DEE55\",\n        \"value\": 1 * 10**18,\n    },\n)\n\n# Form a signed extrinsic\nextrinsic = ws_provider.create_signed_extrinsic(call=call, keypair=keypair)\n\n# Submit the extrinsic\ntry:\n    receipt = ws_provider.submit_extrinsic(extrinsic, wait_for_inclusion=True)\n    print(\n        \"Extrinsic '{}' sent and included in block '{}'\".format(\n            receipt.extrinsic_hash, receipt.block_hash\n        )\n    )\nexcept SubstrateRequestException as e:\n    print(\"Failed to send: {}\".format(e))\n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#offline-signing","title":"Offline Signing","text":"<p>You can sign transaction payloads or any arbitrary data using a keypair object through the <code>sign</code> method. This can be used for offline signing of transactions.</p> <ol> <li> <p>First, generate the signature payload on an online machine:</p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# Construct a transaction call\ncall = ws_provider.compose_call(\n    call_module=\"Balances\",\n    call_function=\"transfer_allow_death\",\n    call_params={\n        \"dest\": \"0x44236223aB4291b93EEd10E4B511B37a398DEE55\",\n        \"value\": 1 * 10**18,\n    },\n)\n\n# Generate the signature payload\nsignature_payload = ws_provider.generate_signature_payload(call=call)\n</code></pre> </li> <li> <p>On an offline machine, create a keypair with the private key of the sending account, and sign the signature payload:</p> <pre><code># Imports\nfrom substrateinterface import Keypair, KeypairType\n\n# Define the signature payload from the offline machine\nsignature_payload = \"INSERT_SIGNATURE_PAYLOAD\"\n\n# Define the shortform private key of the sender account\nprivatekey = bytes.fromhex(\"INSERT_PRIVATE_KEY_WITHOUT_0X_PREFIX\")\n\n# Generate the keypair from shortform private key\nkeypair = Keypair.create_from_private_key(privatekey, crypto_type=KeypairType.ECDSA)\n\n# Sign the signature_payload \nsignature = keypair.sign(signature_payload)\n</code></pre> </li> <li> <p>On an online machine, create a keypair with the public key of the sending account, and submit the extrinsic with the generated signature from the offline machine:</p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface, Keypair, KeypairType\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# Define the signature from the offline machine\nsignature_payload = \"INSERT_SIGNATURE_PAYLOAD\"\n\n# Construct a keypair with the Ethereum style wallet address of the sending account\nkeypair = Keypair(public_key=\"INSERT_ADDRESS_WITHOUT_0X\", crypto_type=KeypairType.ECDSA)\n\n# Construct the same transaction call that was signed\ncall = ws_provider.compose_call(\n    call_module=\"Balances\",\n    call_function=\"transfer_allow_death\",\n    call_params={\n        \"dest\": \"0x44236223aB4291b93EEd10E4B511B37a398DEE55\",\n        \"value\": 1 * 10**18,\n    },\n)\n\n# Construct the signed extrinsic with the generated signature\nextrinsic = ws_provider.create_signed_extrinsic(\n    call=call, keypair=keypair, signature=signature\n)\n\n# Submit the signed extrinsic\nresult = ws_provider.submit_extrinsic(extrinsic=extrinsic)\n\n# Print the execution result\nprint(result.extrinsic_hash)\n</code></pre> </li> </ol>"},{"location":"builders/substrate/libraries/py-substrate-interface/#custom-rpc-requests","title":"Custom RPC Requests","text":"<p>You can also make custom RPC requests with the <code>rpc_request</code> method.</p> <p>This is particularly useful for interacting with Moonbeam's Ethereum JSON-RPC endpoints or Moonbeam's custom RPC endpoints.</p> <p>The Consensus and Finality page has examples for using the custom RPC calls through Python Substrate Interface to check the finality of a transaction given its transaction hash.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/substrate/libraries/sidecar/","title":"Using Substrate API Sidecar with Moonbeam","text":""},{"location":"builders/substrate/libraries/sidecar/#introduction","title":"Introduction","text":"<p>Substrate API Sidecar allows applications to access blocks, account balance, and other information of Substrate-based blockchains through a REST API. This can be useful for exchanges, wallets or other types of applications that need to keep track of account balance and other state changes on a Moonbeam network. This page will describe how to install and run a Substrate API Sidecar for Moonbeam, and the commonly used API endpoints.</p>"},{"location":"builders/substrate/libraries/sidecar/#installing-and-running-substrate-api-sidecar","title":"Installing and Running Substrate API Sidecar","text":"<p>There are multiple ways of installing and running the Substrate API Sidecar. This guide will describe the steps for installing and running it locally through NPM. For running Substrate API Sidecar through Docker, or building and running it from source, please refer to the Substrate API Sidecar Github Repository.</p>"},{"location":"builders/substrate/libraries/sidecar/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Running this service locally through NPM requires Node.js to be installed.</p> <p>You need to install Node.js (for this example, you can use v16.x) and the npm package manager. You can download directly from Node.js or in your terminal:</p> UbuntuMacOS <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n\nsudo apt install -y nodejs\n</code></pre> <pre><code># You can use homebrew (https://docs.brew.sh/Installation)\nbrew install node\n\n# Or you can use nvm (https://github.com/nvm-sh/nvm)\nnvm install node\n</code></pre> <p>You can verify that everything is installed correctly by querying the version for each package:</p> <pre><code>node -v\n</code></pre> <pre><code>npm -v\n</code></pre>"},{"location":"builders/substrate/libraries/sidecar/#installing-the-substrate-api-sidecar","title":"Installing the Substrate API Sidecar","text":"<p>To install the Substrate API Sidecar service locally in the current directory, run this from the command line:</p> <pre><code>npm install @substrate/api-sidecar@20.2.0\n</code></pre> <p>Note</p> <p>If the current folder does not already have a Node.js project structure, you need to manually create the <code>node_modules</code> directory by typing <code>mkdir node_modules</code>.</p> <p>Substrate API Sidecar v20.2.0 is the current stable version that has been tested to work with Moonbeam networks. You can verify the installation was successful by typing from the installation directory root:</p> <pre><code>node_modules/.bin/substrate-api-sidecar --version\n</code></pre>"},{"location":"builders/substrate/libraries/sidecar/#setting-up-the-substrate-api-sidecar","title":"Setting up the Substrate API Sidecar","text":"<p>In the terminal that Sidecar will run, export the environmental variable for the WS endpoint of the network. Examples:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>export SAS_SUBSTRATE_URL=wss://wss.api.moonbeam.network\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=wss://wss.api.moonriver.moonbeam.network\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=wss://wss.api.moonbase.moonbeam.network\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=ws://127.0.0.1:9944\n</code></pre> <p>Please reference the Public Endpoints page for a full list of Moonbeam network endpoints.</p> <p>After setting the environmental variable, you can use the <code>echo</code> command to check that the environmental variable has been set correctly, by typing:</p> <pre><code>echo $SAS_SUBSTRATE_URL\n</code></pre> <p>And it should display the network endpoint you have just set.</p>"},{"location":"builders/substrate/libraries/sidecar/#generating-the-types-bundle","title":"Generating the Types Bundle","text":"<p>Moonbeam introduces custom types that differ from the standard Substrate types. For API clients like Substrate API Sidecar to properly understand and decode these custom types, you must provide Substrate API Sidecar with the corresponding custom types bundle for the respective network you're interacting with. Generating and associating the custom types bundle with Substrate API Sidecar is quick. </p> <p>First, ensure that you installed Parity's <code>generate-types-bundle</code> package:</p> <pre><code>npm install -g @substrate/generate-type-bundle\n</code></pre> <p>Then, navigate to the following directory within your project:</p> <pre><code>cd ./node_modules/@substrate/api-sidecar/build/src/\n</code></pre> <p>Then, run the following command to generate the types bundle for the respective network:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>generate-type-bundle -p . -s moonbeam\n</code></pre> <pre><code>generate-type-bundle -p . -s moonriver\n</code></pre> <pre><code>generate-type-bundle -p . -s moonbase\n</code></pre> <p>Note that running subsequent commands will overwrite the existing <code>typesBundle.json.</code> You'll then need to set the <code>SAS_SUBSTRATE_TYPES_BUNDLE</code> environment variable as shown below. If you've renamed the <code>typesBundle.json,</code> ensure you use the correct file name. </p> <pre><code>export SAS_SUBSTRATE_TYPES_BUNDLE=\"./typesBundle.json\"\n</code></pre> <p>After setting the environment variable, you can verify that you set it correctly by using the following <code>echo</code> command:</p> <pre><code>echo $SAS_SUBSTRATE_TYPES_BUNDLE\n</code></pre>"},{"location":"builders/substrate/libraries/sidecar/#running-substrate-api-sidecar","title":"Running Substrate API Sidecar","text":"<p>Navigate back to the root directory of the project: </p> <pre><code>cd ../../../../..\n</code></pre> <p>With the network endpoint environmental variable set, and from the installation directory root, run:</p> <pre><code>node_modules/.bin/substrate-api-sidecar \n</code></pre> <p>If the installation and configuration are successful, you should see this output in the console:</p> node_modules/.bin/substrate-api-sidecar v0.42.1: Pulling from moonbeamfoundation/moonbeam     SAS:         \ud83d\udce6 LOG:             \u2705 LEVEL: \"info\"             \u2705 JSON: false             \u2705 FILTER_RPC: false             \u2705 STRIP_ANSI: false             \u2705 WRITE: false             \u2705 WRITE_PATH: \"/temp/node_modules/@substrate/api-sidecar/build/src/logs\"             \u2705 WRITE_MAX_FILE_SIZE: 5242880             \u2705 WRITE_MAX_FILES: 5         \ud83d\udce6 SUBSTRATE:             \u2705 URL: \"wss://wss.api.moonbeam.network\"             \u2705 TYPES_BUNDLE: undefined             \u2705 TYPES_CHAIN: undefined             \u2705 TYPES_SPEC: undefined             \u2705 TYPES: undefined         \ud83d\udce6 EXPRESS:             \u2705 BIND_HOST: \"127.0.0.1\"             \u2705 PORT: 8080             \u2705 KEEP_ALIVE_TIMEOUT: 5000     2024-05-07 11:29:54 info: Version: 18.0.0     2024-05-07 11:29:55 warn: API/INIT: RPC methods not decorated: eth_getBlockReceipts, moon_isBlockFinalized, moon_isTxFinalized     2024-05-07 11:29:55 warn: API/INIT: moonbeam/3300: Not decorating unknown runtime apis: 0xd0399cd053adda2b/1, 0xa33d43f58731ad84/2, 0xba8173bf23b2e6f8/1     2024-05-07 11:29:55 info: Connected to chain Moonbeam on the moonbeam client at wss://wss.api.moonbeam.network     2024-05-07 11:29:55 info: Listening on http://127.0.0.1:8080/     2024-05-07 11:29:55 info: Check the root endpoint (http://127.0.0.1:8080) to see the available endpoints for the current node"},{"location":"builders/substrate/libraries/sidecar/#substrate-api-sidecar-endpoints","title":"Substrate API Sidecar Endpoints","text":"<p>Some of the commonly used Substrate API Sidecar endpoints include:</p> <ul> <li>GET /blocks\u200b/head \u2014 Get the most recently finalized block. The optional parameter <code>finalized</code> can be set to <code>false</code> to the get the newest known block, which may not be finalized</li> <li>GET /blocks/head/header \u2014 Get the most recently finalized block header. The optional parameter <code>finalized</code> can be set to <code>false</code> to the get the newest known block header, which may not be finalized</li> <li>GET /blocks/{blockId} \u2014 Get a block by its height or hash</li> <li>GET /accounts/{accountId}/balance-info \u2014 Get balance information for an account</li> <li>GET /node/version \u2014 Get information about the Substrates node's implementation and versioning</li> <li>GET /runtime/metadata \u2014 Get the runtime metadata in decoded, JSON form.</li> </ul> <p>For a full list of API endpoints available on Substrate API Sidecar, please refer to the official documentation.</p>"},{"location":"builders/substrate/libraries/sidecar/#evm-fields-mapping-in-block-json-object","title":"EVM Field Mapping in Block JSON Object","text":"<p>Substrate API Sidecar returns Moonbeam blocks as a JSON object. Information related to EVM execution of Moonbeam transactions is under the <code>extrinsics</code> top level field, where individual extrinsics are organized numerically as nested JSON objects. The nesting structure is as following:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"ethereum\"\n                |--method: \"transact\"\n            |--signature\n            |--nonce \n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"ethereum\"\n                        |--method: \"Executed\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n                        |--3\n    ...\n</code></pre> <p>Moonbeam EVM transactions can be identify by the <code>method</code> field under the current extrinsic object, where it is set to:</p> <pre><code>{extrinsic_number}.method.pallet = \"ethereum\"\n{extrinsic_number}.method.method = \"transact\"\n</code></pre>"},{"location":"builders/substrate/libraries/sidecar/#transaction-types-and-payload","title":"Transaction Types and Payload","text":"<p>The Moonbeam EVM currently supports three transaction standards: <code>legacy</code>, <code>eip1559</code>, and <code>eip2930</code>. These correspond to the <code>transaction type</code> field in the above JSON object diagram. For each transaction type, the transaction payload contains the following fields:</p> EIP1559LegacyEIP2930 <pre><code>    ...\n    |--eip1559\n        |--chainId\n        |--nonce\n        |--maxPriorityFeePerGas\n        |--maxFeePerGas\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--accessList\n        |--oddYParity\n        |--r\n        |--s\n    ...\n</code></pre> <pre><code>    ...\n    |--legacy\n        |--nonce\n        |--gasPrice\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--signature\n    ...\n</code></pre> <pre><code>    ...\n    |--eip2930\n        |--chainId\n        |--nonce\n        |--gasPrice\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--accessList\n        |--oddYParity\n        |--r\n        |--s\n    ...\n</code></pre> <p>For more information on the new EIP1559 and EIP2930 transaction types and what each field means, please refer to the respective official Ethereum proposal specs.</p>"},{"location":"builders/substrate/libraries/sidecar/#transaction-field-mappings","title":"Transaction Field Mappings","text":"<p>To obtain the EVM sender address, recipient address, and EVM hash of any EVM transaction type, check the <code>events</code> field under the current extrinsic object, and identify the event where the <code>method</code> field is set to:</p> <pre><code>{event_number}.method.pallet: \"ethereum\"\n{event_number}.method.method: \"Executed\" \n</code></pre> <p>The EVM field mappings are then summarized as the following:</p> EIP1559LegacyEIP2930 EVM Field Block JSON Field Chain ID <code>extrinsics[extrinsic_number].args.transaction.eip1559.chainId</code> Nonce <code>extrinsics[extrinsic_number].args.transaction.eip1559.nonce</code> Max priority fee per gas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas</code> Max fee per gas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.eip1559.gasLimit</code> Access list <code>extrinsics[extrinsic_number].args.transaction.eip1559.accessList</code> Signature <code>extrinsics[extrinsic_number].args.transaction.eip1559.oddYParity/r/s</code> Sender address <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Recipient address <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> EVM hash <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> EVM execution status <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> EVM Field Block JSON Field Nonce <code>extrinsics[extrinsic_number].args.transaction.legacy.nonce</code> Gas price <code>extrinsics[extrinsic_number].args.transaction.legacy.gasPrice</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.legacy.gasLimit</code> Value <code>extrinsics[extrinsic_number].args.transaction.legacy.value</code> Signature <code>extrinsics[extrinsic_number].args.transaction.legacy.signature</code> Sender address <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Recipient address <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> EVM hash <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> EVM execution status <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> EVM Field Block JSON Field Chain ID <code>extrinsics[extrinsic_number].args.transaction.eip2930.chainId</code> Nonce <code>extrinsics[extrinsic_number].args.transaction.eip2930.nonce</code> Gas price <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasLimit</code> Value <code>extrinsics[extrinsic_number].args.transaction.eip2930.value</code> Access list <code>extrinsics[extrinsic_number].args.transaction.eip2930.accessList</code> Signature <code>extrinsics[extrinsic_number].args.transaction.eip2930.oddYParity/r/s</code> Sender address <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Recipient address <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> EVM hash <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> EVM execution status <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> <p>Note</p> <p>For Substrate transactions, the \"Nonce\" and \"Signature\" fields are under <code>extrinsics[extrinsic_number]</code>. For EVM transactions, the \"Nonce\" and \"Signature\" fields are under <code>extrinsics[extrinsic_number].args.transaction[transaction_type]</code>, leaving the \"Nonce\" and \"Signature\" under <code>extrinsics[extrinsic_number]</code> to be <code>null</code>.</p> <p>A successfully executed EVM transaction will return either <code>succeed: \"Stopped\"</code> or <code>succeed: \"Returned\"</code> under the \"EVM Execution Status\" field.</p>"},{"location":"builders/substrate/libraries/sidecar/#erc-20-token-transfers","title":"ERC-20 Token Transfers","text":"<p>Events emitted by smart contracts such as an ERC-20 token contract deployed on Moonbeam can be decoded from Sidecar block JSON objects. The nesting structure is as following:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"ethereum\"\n                |--method: \"transact\"\n            |--signature:\n            |--nonce: \n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"evm\"\n                        |--method: \"Log\"\n                    |--data\n                        |--0\n                            |-- address\n                            |-- topics\n                                |--0\n                                |--1\n                                |--2\n                            |-- data\n            ...\n    ...\n</code></pre> <p>Moonbeam ERC-20 token transfers will emit the <code>Transfer</code> event which can be decoded as the following:</p> Tx Information Block JSON Field ERC-20 contract address <code>extrinsics[extrinsic_number].events[event_number].data[0].address</code> Event signature hash <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[0]</code> Sender address <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[1]</code> Recipient address <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[2]</code> Amount <code>extrinsics[extrinsic_number].events[event_number].data[0].data</code> <p>Other events emitted by EVM smart contracts can be decoded in a similar fashion, but the content of the topics and data fields will change depending on the definition of the specific event.</p> <p>Note</p> <p>The amount transferred is given in Wei and in hexadecimal format.</p>"},{"location":"builders/substrate/libraries/sidecar/#sample-code-for-monitoring-native-token-transfers","title":"Sample Code for Monitoring Native Token Transfers","text":"<p>The Transfers API page has a code snippet demonstrating how to use Substrate API Sidecar to retrieve and decode native token transfers sent with both Substrate and Ethereum APIs on Moonbeam networks. You can reference that as a starting point to build out backends that utilize Sidecar to listen to transfers on Moonbeam networks.</p>"},{"location":"builders/substrate/libraries/sidecar/#calculating-transaction-fees","title":"Calculating Transaction Fees","text":"<p>For more detailed information and sample code on how to calculate the transaction fees of Moonbeam transactions using Substrate Sidecar API, please check the Calculating Transaction Fees on Moonbeam page.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"learn/dapp-directory/","title":"How to List your Project on the Moonbeam DApp Directory","text":""},{"location":"learn/dapp-directory/#introduction-to-state-of-the-dapps","title":"Introduction to the Moonbeam DApp Directory","text":"<p>The Moonbeam ecosystem comprises two distinct production networks: Moonbeam and Moonriver. Each network has its own dedicated DApp Directory, maintained by the Moonbeam Foundation: Moonbeam and Moonriver. These directories categorize projects spanning from DeFi to NFTs to gaming, providing users with comprehensive access to diverse applications.</p> <p>You'll supply core project details like name, description, and relevant links when adding your project. Depending on your project type, you may include additional data such as on-chain stats and token information.</p> <p>Despite the distinction between the Moonbeam and Moonriver DApp directories, the submission process remains the same. To list your project on the DApp Directory, you must submit a pull request to the Moonbeam Foundation's App Directory Data repository on GitHub. This guide outlines the necessary data and formatting specifics for your submission.</p> <p></p>"},{"location":"learn/dapp-directory/#overview-project-data","title":"Overview of the Project Data","text":"<p>There are four main sources of data that are used for a project's listing in the Moonbeam DApp Directory:</p> <ul> <li>Core Project Data - core project data such as descriptions, logos, and screenshots. This data also includes IDs used to query data from external platforms</li> <li>Active Users and Transaction Volume - on-chain data based on smart contract activity for all of the contracts associated with the project. Data is discovered via the use of contract labeling in Moonscan and is indexed and consumed by the DApp Directory</li> <li>TVL Data - TVL data for the protocol, sourced from the project's listing on DefiLlama</li> <li>Project Token Information - token information, which is sourced from the project's listing on CoinGecko</li> </ul>"},{"location":"learn/dapp-directory/#configuring-external-data-sources","title":"Prerequisites for Using External Data Sources","text":"<p>Before pulling data from the mentioned sources, certain prerequisites must be fulfilled. However, it's worth noting that these steps may not apply to all project types. For instance, in the case of wallets, where there are no smart contracts, the DApp Directory is currently unable to display user and transaction activity data.</p>"},{"location":"learn/dapp-directory/#configure-active-users","title":"Configure the Data Source for Active Users and Transaction Volume","text":"<p>For projects that have smart contracts deployed on Moonbeam or Moonriver, it is important that those contracts can be linked to the DApp Directory project data.</p> <p>The end-to-end flow for linking smart contract activity to the DApp Directory is as follows:</p> <ol> <li>The smart contract owner fills in the form to label contracts on Moonscan</li> <li>The contracts become labeled in Moonscan</li> <li>Labeled contracts can then be ingested by ecosystem analytics providers to index activity for your project</li> <li>(Recommended) Register your project with FiDi so your activity can be indexed and publicly viewable. See the FiDi registration section below</li> </ol> <p>To get your project's smart contracts properly labeled on Moonscan, submit the Moonscan contract labeling form with your project and contract details.</p>"},{"location":"learn/dapp-directory/#register-with-fidi","title":"Register with FiDi for Analytics (Recommended)","text":"<p>New and existing projects are encouraged to register with FiDi so your project's activity can be indexed and surfaced in public analytics. Submit your project using the FiDi Project Listing Form.</p> <p>After submission, Moonbeam FiDi analytics can be viewed on the Moonbeam FiDi Dashboard.</p> <p>Required Project Information:</p> <p>Where possible, include a short purpose description for each contract to improve completeness.</p> <ul> <li>Core Smart Contracts - addresses of main contracts that define core functionality and interact significantly with the network. Optionally, include a brief description of each contract's purpose</li> <li>Factory Contracts - if applicable, addresses of any contracts that deploy other contracts as part of your dApp. Please also provide the creation topic (hash of the creation event) for each factory contract</li> <li>Deployer Wallets - if applicable, addresses of wallets used to deploy your project's contracts</li> </ul> <p>Additional Project-Specific Information (Optional):</p> <ul> <li>Treasury/Admin Wallets - addresses of wallets with administrative control or funds. Optionally, include a brief description of each wallet's function</li> <li>Oracle Contracts - addresses of any oracle contracts. Optionally, include a brief description of what data these oracles provide</li> <li>Bridge Contracts - addresses of any bridge contracts and the list of connected chains</li> <li>Governance Contracts - addresses of any contracts related to on-chain governance. Optionally, include a brief explanation of your governance model</li> </ul> <p>Additional considerations:</p> <ul> <li>If your project batches transactions, consider using the Batch Precompile</li> <li>Factory contracts should derive from or mimic the standard Uniswap factory</li> <li>Diamond (multi-facet proxy) contracts are supported and will be indexed correctly</li> <li>Typical listing time is 1\u20132 weeks; FiDi may reach out for clarifications</li> </ul> <p>Once you've labeled your smart contracts and are ready to submit your project to the DApp Directory, configuring the Directory to utilize your smart contract data becomes straightforward. You'll only need the Project component of your labeled contracts.</p> <p>Consider the following example project with two smart contracts: a Comptroller and a Router recently updated to a new version.</p> Project Contract Name Contract Version Resulting Label My Project Comptroller V1 My Project: Comptroller V1 My Project Router V2 My Project: Router V2 <p>To submit your project to the Moonbeam DApp Directory, ensure you have your Project name ready, identified here as <code>My Project</code>.</p> <p>If you're ready to add your project to the DApp Directory, skip to the How to Submit Your Project Listing section.</p>"},{"location":"learn/dapp-directory/#configure-tvl","title":"Configure the Data Source for TVL","text":"<p>If the project represents a DeFi protocol with TVL (whereby value is locked in the protocol's smart contract), it is possible to display TVL in the Moonbeam DApp Directory.</p> <p>TVL data is pulled from DefiLlama, so you must list your project there. To get your project listed, please refer to DefiLlama's documentation on How to list a DeFi project.</p> <p>After listing your project, you can easily configure the DApp Directory to pull data from DefiLlama. To do so, you'll need the DefiLlama identifier, which you can find in the URL for your protocol's page. For example, the URL for Moonwell's page is <code>https://defillama.com/protocol/moonwell</code>, so the identifier is <code>moonwell</code>.</p> <p>If you have the identifier and are ready to submit your project to the Moonbeam DApp Directory, skip to the How to Submit Your Project Listing section.</p>"},{"location":"learn/dapp-directory/#project-token-information","title":"Configure the Data Source for Project Token Information","text":"<p>If a project has a token, it is possible to display the name of the token, current price, and contract in the DApp Directory.</p> <p>However, the data is pulled from CoinGecko, so the project's token must be listed there. If your token is not listed there, you can complete CoinGecko's Request Form to initiate the listing process.</p> <p>Assuming your project's token is listed there, you must obtain the CoinGecko API ID value. You can find the API ID value in the Information section of the token's page on CoinGecko. For example, the API ID on Moonwell's token page is <code>moonwell-artemis</code>.</p> <p>If you have the CoinGecko ID and are ready to submit your project to the Moonbeam DApp Directory, you can continue to the next section.</p>"},{"location":"learn/dapp-directory/#how-to-submit-your-project-listing","title":"How to Submit Your Project Listing","text":"<p>As mentioned, you must submit a pull request to the Moonbeam Foundation's GitHub repository that holds the DApp Directory's data. Before getting started, it's worth noting that to expedite the review process, the GitHub user who submits the pull request is recommended to be a major contributor to the project's GitHub so that the Moonbeam Foundation can quickly verify that they represent the project. You can check out the Review Process section for more information.</p> <p>To begin, you have two options for adding your project information to the <code>app-directory-data</code> repository on GitHub. You can utilize GitHub's browser-based editor, which offers a user-friendly interface.</p> <p></p> <p>Or you can clone the repository locally and make modifications using your preferred code editor, in which you can use the following command to clone the repository:</p> <pre><code>git clone https://github.com/moonbeam-foundation/app-directory-data.git\n</code></pre> <p>Once you've cloned the project, you can create a new branch to which you will add all of your changes. To do this on the browser-based editor, take the following steps:</p> <ol> <li>Click on the current branch name in the bottom left corner</li> <li>A menu will appear at the top of the page. Enter the name of your branch</li> <li>Click Create new branch...</li> </ol> <p></p> <p>The page will reload, and your branch name will now be displayed in the bottom left corner.</p>"},{"location":"learn/dapp-directory/#projects-with-deployments","title":"Projects with Deployments on Moonbeam and Moonriver","text":"<p>If a project is deployed to both Moonbeam and Moonriver, there are two different options available:</p> <ul> <li>Create a separate project structure for each deployment</li> <li>Use a single project structure and modify the project data file for both projects</li> </ul> <p>Separate project structures should be used if:</p> <ul> <li>The two deployments have distinct representations in DefiLlama (i.e., two distinct identifiers)</li> <li>The project has two different tokens, one native to Moonbeam and one native to Moonriver</li> </ul> <p>Otherwise, either option may be used.</p>"},{"location":"learn/dapp-directory/#set-up-the-file-structure","title":"Set Up the Folder Structure for Your Project","text":"<p>All configurations for each project listed in the DApp Directory are stored in the <code>projects</code> folder.</p> <p>To get started, you must have a name that uniquely and properly identifies your project. Using your project name, you can take the following steps:</p> <ol> <li>Create a new directory for your project using your unique project name</li> <li>In your project directory, you'll need to create:<ol> <li>A project data file is a JSON file that defines all your project data and contains references to the images stored in the <code>logos</code> and <code>screenshots</code> folders. The list of fields you can use to define your data, with descriptions, is outlined in the next section. The file must be named using your unique project name</li> <li>A <code>logos</code> folder where your project logo images are stored</li> <li>(Optional) A <code>screenshots</code> folder where screenshots for the project are stored</li> </ol> </li> </ol> Example folder structure <pre><code>my-project\n\u251c\u2500\u2500 my-project.json\n\u251c\u2500\u2500 logos\n\u2502   \u251c\u2500\u2500 my-project-logo-small.jpeg\n\u2502   \u2514\u2500\u2500 my-project-logo-full.jpeg\n\u2514\u2500\u2500 screenshots\n    \u251c\u2500\u2500 my-project-screenshot1-small.jpeg\n    \u251c\u2500\u2500 my-project-screenshot1-full.jpeg\n    \u251c\u2500\u2500 my-project-screenshot2-small.jpeg\n    \u2514\u2500\u2500 my-project-screenshot2-full.jpeg\n</code></pre> <p></p> <p>With the foundational file structure in place, you're ready to populate the necessary information for your project submission.</p>"},{"location":"learn/dapp-directory/#add-information","title":"Add Information to the Project Data File","text":"<p>Your project's data file is where you'll add all the information for your project. The file permits the following top-level properties:</p> Property Type Description <code>id</code> String Unique identifier for the dApp in the Moonbeam DApp Directory. It should be a unique, human-readable string representing this project. E.g., <code>my-project</code> <code>slug</code> String Identifier used in certain third-party sources. In particular, if the project is listed in DefiLlama, this value should be set to the DefiLlama identifier. See the Configure the Data Source for TVL section for more information <code>name</code> String The project name as it will appear in the DApp Directory. E.g., <code>My Project</code> <code>category</code> String The category the project should be associated with. A project can only have one category, and it corresponds to the category list in the left-hand nav of the DApp Directory. See the Category and Tags section for the accepted list of values <code>coinGeckoId</code> String If the project has a token listed on CoinGecko, this property should have the API ID value corresponding to the given token. See the Configure the Data Source for Project Token Information section for more information <code>chains</code> Array of Strings List of Moonbeam ecosystem chains on which the project is deployed. Valid values are currently <code>moonbeam</code> and <code>moonriver</code> <code>logo</code> Map of Strings to JSON objects Map of logo image files associated with this project and stored in the <code>logos</code> directory. See the Logos section for more information <code>shortDescription</code> String A short description of the project used in the display card when browsing dapps in the directory. This should be kept to under 80 characters <code>description</code> String A longer description used in the project detail page. Markdown or similar formatting cannot be used. Line breaks can be used using <code>\\r\\n</code>. The text should be limited to a few paragraphs <code>tags</code> Array of Strings A list of applicable tags for this project. Tag values will show up in the project details. See the Category and Tags section for the accepted list of values <code>contracts</code> Array of contract JSON objects List of contracts for the project. Currently, this is used only for token contracts. The list of smart contracts which make up the protocol is externally sourced from Moonscan. See the Contracts section for more information <code>urls</code> Map of Strings (names) to Strings (URLs) Mapping of URLs for websites and socials associated with the project. See the URLs section for the accepted list of properties <code>screenshots</code> Array of Maps of Strings (size) to image JSON objects List of screenshot image files associated with this project and stored in the <code>screenshots</code> directory. See the Screenshots section for more information <code>projectCreationDate</code> int The date the project was created. Used for sorting purposes in the DApp Directory Example project data file <pre><code>{\n    \"id\": \"moonwell\",\n    \"slug\": \"moonwell\",\n    \"name\": \"Moonwell\",\n    \"category\": \"lending\",\n    \"coinGeckoId\": \"moonwell-artemis\",\n    \"chains\": [\n        \"moonbeam\"\n    ],\n    \"logo\": {\n        \"small\": {\n            \"fileName\": \"moonwell-logo-small.jpeg\",\n            \"width\": 40,\n            \"height\": 40,\n            \"mimeType\": \"image/jpeg\"\n        },\n        \"large\": {\n            \"fileName\": \"moonwell-logo-large.jpeg\",\n            \"width\": 400,\n            \"height\": 400,\n            \"mimeType\": \"image/jpeg\"\n        },\n        \"full\": {\n            \"fileName\": \"moonwell-logo-full.jpeg\",\n            \"width\": 3000,\n            \"height\": 3000,\n            \"mimeType\": \"image/jpeg\"\n        }\n    },\n    \"shortDescription\": \"Lending, borrowing, and DeFi protocol built on Moonbeam and Moonriver\",\n    \"description\": \"Moonwell is an open lending, borrowing, and decentralized finance protocol built on Moonbeam and Moonriver. Moonwell\u2019s composable design can accommodate a full range of DeFi applications in the greater Polkadot and Kusama (DotSama) ecosystem.\\r\\n\\r\\nOur first deployment will be on Kusama\u2019s Moonriver, the sister network of Polkadot\u2019s Moonbeam. Moonriver is where new products are expected to be incubated and developed prior to being deployed on Moonbeam.\",\n    \"tags\": [\n        \"Lending\",\n        \"DeFi\"\n    ],\n    \"contracts\": [\n        {\n            \"contract\": \"0x511ab53f793683763e5a8829738301368a2411e3\",\n            \"chain\": \"moonbeam\",\n            \"name\": \"WELL Token\"\n        }\n    ],\n    \"urls\": {\n        \"website\": \"https://moonwell.fi/\",\n        \"try\": \"https://moonwell.fi/\",\n        \"twitter\": \"https://twitter.com/MoonwellDeFi\",\n        \"medium\": \"https://moonwell.medium.com/\",\n        \"telegram\": \"https://t.me/moonwellfichat\",\n        \"github\": \"https://github.com/moonwell-open-source\",\n        \"discord\": \"https://discord.gg/moonwellfi\"\n    },\n    \"screenshots\": [\n        {\n            \"small\": {\n                \"fileName\": \"moonwell-screenshot-small1.png\",\n                \"width\": 429,\n                \"height\": 200,\n                \"mimeType\": \"image/png\"\n            },\n            \"full\": {\n                \"fileName\": \"moonwell-screenshot-full1.png\",\n                \"width\": 514,\n                \"height\": 300,\n                \"mimeType\": \"image/png\"\n            }\n        },\n        {\n            \"small\": {\n                \"fileName\": \"moonwell-screenshot-small2.png\",\n                \"width\": 429,\n                \"height\": 200,\n                \"mimeType\": \"image/png\"\n            },\n            \"full\": {\n                \"fileName\": \"moonwell-screenshot-full2.png\",\n                \"width\": 1716,\n                \"height\": 800,\n                \"mimeType\": \"image/png\"\n            }\n        },\n        {\n            \"small\": {\n                \"fileName\": \"moonwell-screenshot-small3.png\",\n                \"width\": 429,\n                \"height\": 200,\n                \"mimeType\": \"image/png\"\n            },\n            \"full\": {\n                \"fileName\": \"moonwell-screenshot-full3.png\",\n                \"width\": 1054,\n                \"height\": 637,\n                \"mimeType\": \"image/png\"\n            }\n        },\n        {\n            \"small\": {\n                \"fileName\": \"moonwell-screenshot-small4.png\",\n                \"width\": 429,\n                \"height\": 200,\n                \"mimeType\": \"image/png\"\n            },\n            \"full\": {\n                \"fileName\": \"moonwell-screenshot-full4.png\",\n                \"width\": 1365,\n                \"height\": 436,\n                \"mimeType\": \"image/png\"\n            }\n        }\n    ],\n    \"projectCreationDate\": 1644828523000\n}\n</code></pre>"},{"location":"learn/dapp-directory/#category-and-tags","title":"Category and Tags","text":"<p>A category is the primary classification for a project. A project can be categorized under only one category, but it can have multiple tags. Ensure you carefully select the most applicable category for your project to ensure it is easily found. Any secondary classifications can be included as a tag. </p> <p>The currently supported values for <code>category</code> are:</p> <pre><code>- Bridges\n- DAO\n- DEX\n- DeFi\n- Gaming\n- Lending\n- NFTs\n- Other\n- Social\n- Wallets\n</code></pre> <p>The currently supported values for <code>tag</code> are:</p> <pre><code>- Bridges\n- DAO\n- DEX\n- DeFi\n- DePIN\n- Developer Tools\n- Explorers\n- Files\n- GLMR Grants\n- Gaming\n- Infrastructure\n- IoT\n- Lending\n- MOVR Grants\n- Messaging\n- NFT\n- NFT Marketplaces\n- On-ramp\n- Other\n- Social\n- Tool\n- VPN\n- Wallets\n- ZeroTrust\n</code></pre>"},{"location":"learn/dapp-directory/#urls","title":"URLs","text":"<p>The <code>urls</code> property name/value pairs are used so a project can provide links to their website, socials, etc.</p> <p>The following table lists the supported <code>urls</code> properties:</p> Property Name Description Example <code>website</code> The main website for the project https://moonbeam.network/ <code>try</code> URL a user should visit if they want to try out the dApp. Typically, this page will have a link to launch the dApp https://moonbeam.network/ <code>twitter</code> The project's X (Twitter) profile https://twitter.com/MoonbeamNetwork <code>medium</code> The project's Medium site https://medium.com/moonbeam-network <code>telegram</code> The project's Telegram https://t.me/Moonbeam_Official <code>github</code> The project's GitHub repository https://github.com/moonbeam-foundation/moonbeam <code>discord</code> The project's Discord https://discord.com/invite/PfpUATX <p>The format of the property name/value pairs should follow the JSON standard, for example:</p> <pre><code>\"urls\": {\n    \"website\": \"https://moonbeam.network/\",\n    \"try\": \"https://docs.moonbeam.network/\",\n    \"twitter\": \"https://twitter.com/MoonbeamNetwork\"\n}\n</code></pre>"},{"location":"learn/dapp-directory/#logos","title":"Logos","text":"<p>The <code>logos</code> property of the main project data file is a map of image sizes (i.e., <code>small</code>, <code>large</code>, <code>full</code>) to corresponding image JSON objects. The image JSON object contains the display properties for the given image.</p> <p>The following table lists the properties of the image JSON object:</p> Property Type Description <code>fileName</code> String The name of the image file (unqualified) stored in the <code>logos</code> directory <code>width</code> int The width of the logo image in pixels <code>height</code> int The height of the logo image in pixels <code>mimeType</code> String The standard MIME type of the file. E.g., <code>\"image/jpeg\"</code> <p>Currently, only the <code>small</code> size is utilized, and the dimensions for small logos should be 40x40 pixels.</p> <p>Here is an example showing the structure of the <code>logo</code> property that supplies <code>small</code> and <code>full</code> logos:</p> <pre><code>\"logo\": {\n    \"small\": {\n        \"fileName\": \"my-project-logo-small.jpeg\",\n        \"width\": 40,\n        \"height\": 40,\n        \"mimeType\": \"image/jpeg\"\n    },\n    \"full\": {\n        \"fileName\": \"my-project-logo-full.jpeg\",\n        \"width\": 3000,\n        \"height\": 3000,\n        \"mimeType\": \"image/jpeg\"\n    }\n}\n</code></pre>"},{"location":"learn/dapp-directory/#screenshots","title":"Screenshots","text":"<p>The <code>screenshots</code> property of the main project data file is an array of maps. Each map in the array is for a specific screenshot.</p> <p>However, different-sized images for each screenshot should be supplied so that different sizes can be used in different contexts (e.g., thumbnails vs full-sized images). Thus, for each screenshot, there is a map of image sizes (i.e., <code>small</code>, <code>large</code>, <code>full</code>) to corresponding image JSON objects. The image JSON object contains the display properties for the given image.</p> <p>The following table lists the properties of the image JSON object:</p> Property Type Description <code>fileName</code> String The name of the image file (unqualified) stored in the <code>screenshots</code> directory <code>width</code> int The width of the logo image in pixels <code>height</code> int The height of the logo image in pixels <code>mimeType</code> String The standard MIME type of the file. E.g., <code>\"image/jpeg\"</code> <p>Here is an example showing the structure of the <code>screenshot</code> property for two screenshots (<code>screenshot1</code> and <code>screenshot2</code>):</p> <pre><code>\"screenshots\": [\n    {\n        \"small\": {\n            \"fileName\": \"my-project-screenshot1-small.png\",\n            \"width\": 429,\n            \"height\": 200,\n            \"mimeType\": \"image/png\"\n        },\n        \"full\": {\n            \"fileName\": \"my-project-screenshot1-full.png\",\n            \"width\": 514,\n            \"height\": 300,\n            \"mimeType\": \"image/png\"\n        }\n    },\n    {\n        \"small\": {\n            \"fileName\": \"my-project-screenshot2-small.png\",\n            \"width\": 429,\n            \"height\": 200,\n            \"mimeType\": \"image/png\"\n        },\n        \"full\": {\n            \"fileName\": \"my-project-screenshot2-full.png\",\n            \"width\": 1716,\n            \"height\": 800,\n            \"mimeType\": \"image/png\"\n        }\n    }\n]\n</code></pre>"},{"location":"learn/dapp-directory/#contracts","title":"Contracts","text":"<p>A list of contracts for the project. Currently, this is used only for token contracts.</p> <p>The smart contracts that make up the protocol are sourced from Moonscan based on tagging, so they do not need to be listed here. If you have not properly labeled your contracts or are unsure if they are labeled according to the Moonbeam community standard, please refer to the Configure the Data Source for Active Users and Transaction Volume section.</p> <p>The following table lists the properties found in the contract JSON object:</p> Property Type Description <code>contract</code> String The address for the smart contract <code>chain</code> String The chain on which the contract is deployed (i.e., <code>moonbeam</code> or <code>moonriver</code>) <code>name</code> String The name of the contract <p>Here is a <code>contracts</code> array with a single smart contract for the WGLMR token:</p> <pre><code>\"contracts\": [\n    {\n        \"contract\": \"0xAcc15dC74880C9944775448304B263D191c6077F\",\n        \"chain\": \"moonbeam\",\n        \"name\": \"Wrapped GLMR Token\"\n    }\n]\n</code></pre>"},{"location":"learn/dapp-directory/#submit-a-pull-request","title":"Submit a Pull Request","text":"<p>After you've populated the project data file and added your logos and screenshots, you should be ready to submit your pull request.</p> <p></p> <p>From the web-based editor, take the following steps to commit your changes to the <code>app-directory-data</code> repository:</p> <ol> <li>Click on the Source Control tab, which should show you how many pages have been added or changed</li> <li>Review the files under the Changes section. Click the + button next to Changes, or as you review each file, click the + button next to the file name to add them to the list of Staged Changes</li> </ol> <p></p> <p>All of your files should now be under the Staged Changes section. All you have to commit and push the changes are:</p> <ol> <li>Enter a descriptive commit message, such as \"Add My Project\", making sure to use your actual project name</li> <li>Click Commit &amp; Push</li> </ol> <p></p> <p>Now that you've committed the changes, you'll need to head over to the <code>app-directory-data</code> repository and open a pull request against the <code>develop</code> branch:</p> <ol> <li>At the top of the repository page, click Compare and Pull button displayed on the banner, or</li> <li>If the banner is not there anymore, you'll need to select your branch from the branches dropdown</li> <li>Click the Contribute dropdown</li> <li>Click the Open pull request button</li> </ol> <p></p> <p>You'll be taken to the Comparing changes page, where you'll need to:</p> <ol> <li>Make sure that you are merging your branch into the <code>develop</code> branch, which is the base branch</li> <li>Add a title</li> <li>Add a description of the changes</li> <li>Click Create pull request</li> </ol> <p></p>"},{"location":"learn/dapp-directory/#review-process","title":"The Review Process","text":"<p>Submitted pull requests will be reviewed bi-weekly by the Moonbeam Foundation. During the review, and especially for new projects, the Foundation may have to verify that the GitHub user who created the pull request is a contributor and/or represents the specific project. One way projects can expedite this process is if the submitter's GitHub account is also a major contributor to the project itself on GitHub. Alternatively, teams should leave a note in the pull request comments indicating how we can get in touch with project team members to verify.</p> <p>A comment will be added to the pull request if any changes are requested. After your pull request has been approved, it will be merged, and your project will be added to the Moonbeam DApp Directory!</p>"},{"location":"learn/dapp-directory/#how-to-update-your-project-listing","title":"How to Update Your Project Listing","text":"<p>As your project evolves, you may need to update your project's listing or images related to your listing. You can create a new branch for your changes, find and modify your existing project's data from the root <code>projects</code> directory, and make the desired changes.</p> <p>If you are no longer using a logo or screenshot, please remember to remove it from the <code>logos</code> or <code>screenshots</code> directory.</p> <p>Once your changes have been made, you must follow the same instructions in the Submit a Pull Request section so the changes can be reviewed by the Moonbeam Foundation. Please note that pull requests are reviewed on a bi-weekly basis, so if the update is urgent, you can create a forum post asking for assistance.</p>"},{"location":"learn/dapp-directory/#dapp-directory-api","title":"DApp Directory API","text":"<p>The DApp Directory also features a queryable API that you can use to integrate data from Moonbeam's DApp Directory into your application. The API is public and currently does not require authentication. The base URL for the API is as follows:</p> <pre><code>https://apps.moonbeam.network/api/ds/v1/app-dir/\n</code></pre>"},{"location":"learn/dapp-directory/#query-a-project","title":"Query a Project","text":"<p>You can retrieve all the information for a particular project by appending <code>/projects/INSERT_PROJECT_NAME</code> to the base URL. If you need clarification on the project name, you can omit the project name as shown below to retrieve data for every listed project and find the project in the response. </p> <pre><code>https://apps.moonbeam.network/api/ds/v1/app-dir/projects\n</code></pre> <p>Here's an example of querying the API for StellaSwap, which returns the project description, social media information, user counts, relevant smart contract addresses, market data, images, and more. </p> <pre><code>https://apps.moonbeam.network/api/ds/v1/app-dir/projects/stellaswap\n</code></pre> <p>You can visit the query URL directory in the browser, using a tool like Postman, or directly from the command line with Curl as follows: </p> <pre><code>curl -H \"Content-Type: application/json\" -X GET 'https://apps.moonbeam.network/api/ds/v1/app-dir/projects/stellaswap'\n</code></pre> API Response to Querying StellaSwap <pre><code>{\n    \"project\":{\n        \"currentTx\":{\n            \"moonbeam\":2883079\n        },\n        \"web3goIDs\":[\n            \"StellaSwap\"\n        ],\n        \"name\":\"StellaSwap\",\n        \"currentTVL\":{\n            \"moonbeam\":5046832.23328\n        },\n        \"currentUsers\":{\n            \"moonbeam\":52455\n        },\n        \"coinGeckoId\":\"stellaswap\",\n        \"shortDescription\":\"The leading DEX and DeFi gateway on Moonbeam\",\n        \"id\":\"stellaswap\",\n        \"featured\":true,\n        \"tags\":[\n            \"DEX\",\n            \"DeFi\"\n        ],\n        \"tvlChange7d\":{\n            \"moonbeam\":-1.61482567543498\n        },\n        \"urls\":{\n            \"telegram\":\"https://t.me/stellaswap\",\n            \"website\":\"https://stellaswap.com/\",\n            \"try\":\"https://stellaswap.com/\",\n            \"twitter\":\"https://twitter.com/StellaSwap\",\n            \"github\":\"https://github.com/stellaswap\",\n            \"medium\":\"https://stellaswap.medium.com/\"\n        },\n        \"web3goContracts\":[\n            {\n                \"name\":\"StellaSwap: stDOT Oracle Master\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x3b23f0675ffc45153eca239664ccaefc5e816b9c\"\n            },\n            {\n                \"name\":\"StellaSwap: stDOT Token\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xbc7e02c4178a7df7d3e564323a5c359dc96c4db4\"\n            },\n            {\n                \"name\":\"StellaSwap: stDOT Controller\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x002d34d6a1b4a8e665fec43fd5d923f4d7cd254f\"\n            },\n            {\n                \"name\":\"StellaSwap: stDOT Proxy Admin\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xe8a5c0039226269313c89c093a6c3524c4d39fa4\"\n            },\n            {\n                \"name\":\"StellaSwap: madUSDC GLMR V2\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x2ad0e92461df950e2b1c72e2f7a865c81eaa3ce6\"\n            },\n            {\n                \"name\":\"StellaSwap: Dual ETH - GLMR Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x2ba130297d1966e077c2fb5e4b434e8802925277\"\n            },\n            {\n                \"name\":\"StellaSwap: BCMC Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x18e75887aa81e113636e18d5a78e3ff93787ec88\"\n            },\n            {\n                \"name\":\"StellaSwap: Pulsar Position Manager V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x1ff2adaa387dd27c22b31086e658108588eda03a\"\n            },\n            {\n                \"name\":\"StellaSwap: DualETH Pool LP Token V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xa3ee3a0a36dc915fdc93062e4b386df37d00217e\"\n            },\n            {\n                \"name\":\"StellaSwap: Interlay Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x3a7572220afaddc31a72a520642111776d92b2d2\"\n            },\n            {\n                \"name\":\"StellaSwap: Router V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xd0a01ec574d1fc6652edf79cb2f880fd47d34ab1\"\n            },\n            {\n                \"name\":\"StellaSwap: xStella - GLMR Rewarder 2nd V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb4dba7fe6fcc613963d64204fcf789e9e376679a\"\n            },\n            {\n                \"name\":\"StellaSwap: GLMR Rewarder First V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x69f9d134991e141c4244f397514ba05d67861cc0\"\n            },\n            {\n                \"name\":\"StellaSwap: CELER Rewarder 0 V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xbebd88782a1145b71df3f4986ef7686154ce01d9\"\n            },\n            {\n                \"name\":\"StellaSwap: MATICILO V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xfffa340944ff32f50c7935e2b5d22a7c3393b313\"\n            },\n            {\n                \"name\":\"StellaSwap: ETHmad - GLMR V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x9fe074a56ffa7f4079c6190be6e8452911b7e349\"\n            },\n            {\n                \"name\":\"StellaSwap: STELLA Token\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x0e358838ce72d5e61e0018a2ffac4bec5f4c88d2\"\n            },\n            {\n                \"name\":\"StellaSwap: SFL - 4pool Wormhole V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb1bc9f56103175193519ae1540a0a4572b1566f6\"\n            },\n            {\n                \"name\":\"StellaSwap: BICO Trusted Forwarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x3d08ce1f9609bb02f47192ff620634d9eb0e7b56\"\n            },\n            {\n                \"name\":\"StellaSwap: Gass Refund V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xee42d4861b56b32776e6fe9a2fe122af0e3f4a33\"\n            },\n            {\n                \"name\":\"StellaSwap: xcDOT - GLMR V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xe76215efea540ea87a2e1a4bf63b1af6942481f3\"\n            },\n            {\n                \"name\":\"StellaSwap: 4pool LP V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xda782836b65edc4e6811c7702c5e21786203ba9d\"\n            },\n            {\n                \"name\":\"StellaSwap: SFL LP V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xa0aa99f71033378864ed6e499eb03612264e319a\"\n            },\n            {\n                \"name\":\"StellaSwap: SFL - 4pool V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x422b5b7a15fb12c518aa29f9def640b4773427f8\"\n            },\n            {\n                \"name\":\"StellaSwap: Acala - GLMR Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x9de8171bebfa577d6663b594c60841fe096eff97\"\n            },\n            {\n                \"name\":\"StellaSwap: Zap V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x01834cf26717f0351d9762cc9cca7dc059d140df\"\n            },\n            {\n                \"name\":\"StellaSwap: GLMR Rewarder for UST - GLMR V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xc85ddcff71200f9673137e2f93ce504bdbf7db4e\"\n            },\n            {\n                \"name\":\"StellaSwap: xStella Token\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x06a3b410b681c82417a906993acefb91bab6a080\"\n            },\n            {\n                \"name\":\"StellaSwap: ETHmad - GLMR V2\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xa6ec79c97e533e7bddb00898e22c6908742e039b\"\n            },\n            {\n                \"name\":\"StellaSwap: WBTC - USDT Contract V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xcae51da6dceacd84f79df4b88d9f92035d1479e9\"\n            },\n            {\n                \"name\":\"StellaSwap: AVAXILO V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x96bef4719ae7c053113292e6aa7fc36e62b243e8\"\n            },\n            {\n                \"name\":\"StellaSwap: Swap For Gas V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb64dee2d182fed3dd6c273303fb08f11808c9c23\"\n            },\n            {\n                \"name\":\"StellaSwap: Farming Centre V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x0d4f8a55a5b2583189468ca3b0a32d972f90e6e5\"\n            },\n            {\n                \"name\":\"StellaSwap: FTMILO V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x096352f7ea415a336b41fc48b33142eff19a8ad8\"\n            },\n            {\n                \"name\":\"StellaSwap: Acala Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb7b5d3659ad213478bc8bfb94d064d0efdda8f7c\"\n            },\n            {\n                \"name\":\"StellaSwap: USDC Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xa52123adc0bc5c4c030d1ff4f5dad966366a646c\"\n            },\n            {\n                \"name\":\"StellaSwap: Vault V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x54e2d14df9348b3fba7e372328595b9f3ae243fe\"\n            },\n            {\n                \"name\":\"StellaSwap: CELER Rewarder 1 V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x70cbd76ed57393e0cd81e796de850080c775d24f\"\n            },\n            {\n                \"name\":\"StellaSwap: Stella Timelock V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xc6f73b028cd3154a5bb87f49aa43aa259a6522fb\"\n            },\n            {\n                \"name\":\"StellaSwap: GLMR - MAI Vault V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x3a82f4da24f93a32dc3c2a28cfa9d6e63ec28531\"\n            },\n            {\n                \"name\":\"StellaSwap: UST - GLMR V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x556d9c067e7a0534564d55f394be0064993d2d3c\"\n            },\n            {\n                \"name\":\"StellaSwap: SFL - axlUSDC - 4pool V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xa1ffdc79f998e7fa91ba3a6f098b84c9275b0483\"\n            },\n            {\n                \"name\":\"StellaSwap: Stable Router V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb0dfd6f3fddb219e60fcdc1ea3d04b22f2ffa9cc\"\n            },\n            {\n                \"name\":\"StellaSwap: ATOM - GLMR Rewarder New V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x5aa224966e302424ec13a4f51b80bcfc205984b6\"\n            },\n            {\n                \"name\":\"StellaSwap: CELR Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x05ad30253f0b20be35d84253d6aca8bd7ec0c66c\"\n            },\n            {\n                \"name\":\"StellaSwap: Router V3\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xe6d0ed3759709b743707dcfecae39bc180c981fe\"\n            },\n            {\n                \"name\":\"StellaSwap: xStella - GLMR Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x896135ff51debe8083a2e03f9d44b1d3c77a0324\"\n            },\n            {\n                \"name\":\"StellaSwap: XStella - MAI Vault V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x3756465c5b1c1c4cee473880c9726e20875284f1\"\n            },\n            {\n                \"name\":\"StellaSwap: ATOM - USDC Rewarder New V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x5546e272c67fac10719f1223b1c0212fa3e41a8f\"\n            },\n            {\n                \"name\":\"StellaSwap: SFL - athUSDC - 4pool V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x715d7721fa7e8616ae9d274704af77857779f6f0\"\n            },\n            {\n                \"name\":\"StellaSwap: IDO Locker V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x4b1381b5b959a8ba7f44414c7d758e53d500a8a9\"\n            },\n            {\n                \"name\":\"StellaSwap: Locker V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x8995066b7f1fb3abe3c88040b677d03d607a0b58\"\n            },\n            {\n                \"name\":\"StellaSwap: ATOM - USDC - GLMR Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xe06e720aaed5f5b817cb3743108ae0a12fe69e9b\"\n            },\n            {\n                \"name\":\"StellaSwap: Mistake in Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x168ceb7e49c21e3f37820a34590171214a765f5f\"\n            },\n            {\n                \"name\":\"StellaSwap: LP 4pool - Wormhole V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb326b5189aa42acaa3c649b120f084ed8f4dcaa6\"\n            },\n            {\n                \"name\":\"StellaSwap: Farms V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xedfb330f5fa216c9d2039b99c8ce9da85ea91c1e\"\n            },\n            {\n                \"name\":\"StellaSwap: Factory V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x68a384d826d3678f78bb9fb1533c7e9577dacc0e\"\n            },\n            {\n                \"name\":\"StellaSwap: anyETH-madETH Pool\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb86271571c90ad4e0c9776228437340b42623402\"\n            },\n            {\n                \"name\":\"StellaSwap: Dual Farms V2\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xf3a5454496e26ac57da879bf3285fa85debf0388\"\n            },\n            {\n                \"name\":\"StellaSwap: CELER Rewarder 01 - 02 V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x713f76076283fcd81babe06c76ff51485edf9d5e\"\n            },\n            {\n                \"name\":\"StellaSwap: SCNFT Token\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x5f23a6a0b6b90fdeeb4816afbfb2ec0408fda59e\"\n            },\n            {\n                \"name\":\"StellaSwap: ATOM - GLMR - GLMR Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xe60c41de5537418fde05b804df077397dfa84d75\"\n            },\n            {\n                \"name\":\"StellaSwap: Timelock Main V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x9a8693c6f7bf0f44e885118f3f83e2cdb4e611b8\"\n            },\n            {\n                \"name\":\"StellaSwap: MAI - B4P - Wormhole V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xf0a2ae65342f143fc09c83e5f19b706abb37414d\"\n            },\n            {\n                \"name\":\"StellaSwap: LP Token V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x7b17122b941d2173192c7d8d68faabdc88421326\"\n            },\n            {\n                \"name\":\"StellaSwap: Multisig V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x4300e09284e3bb4d9044ddab31efaf5f3301daba\"\n            },\n            {\n                \"name\":\"StellaSwap: Router V2\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x70085a09d30d6f8c4ecf6ee10120d1847383bb57\"\n            },\n            {\n                \"name\":\"StellaSwap: DOTxc - GLMR V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x505b0a5458dd12605b84bb2928dd2bc5b44993b9\"\n            },\n            {\n                \"name\":\"StellaSwap: SFL - MAI - 4pool V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x7fbe3126c03444d43fc403626ec81e3e809e6b46\"\n            },\n            {\n                \"name\":\"StellaSwap: xStella - USDC Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xfa16d5b8bf03677945f0a750c8d2a30001b2fa93\"\n            },\n            {\n                \"name\":\"StellaSwap: madUSDC - GLMR V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x9200cb047a9c4b34a17ccf86334e3f434f948301\"\n            }\n        ],\n        \"slug\":\"stellaswap\",\n        \"createdAt\":1699292612617,\n        \"tvlChange1d\":{\n            \"moonbeam\":-0.748278690902012\n        },\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"stellaswap-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":510,\n                \"fileName\":\"stellaswap-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":510\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"stellaswap-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"usersChange7d\":{\n            \"moonbeam\":-17.2727272727273\n        },\n        \"marketData\":{\n            \"symbol\":\"stella\",\n            \"marketCap\":808908,\n            \"marketCapRank\":2865,\n            \"priceChangePercentage1y\":-43.01356,\n            \"currentPrice\":0.01729378,\n            \"priceChangePercentage14d\":-17.23772,\n            \"contracts\":{\n                \"moonbeam\":\"0x0e358838ce72d5e61e0018a2ffac4bec5f4c88d2\"\n            },\n            \"priceChangePercentage60d\":-39.75633,\n            \"priceChangePercentage30d\":-26.13934,\n            \"priceChangePercentage24h\":-4.63782,\n            \"priceChangePercentage200d\":-74.57003,\n            \"marketCapChangePercentage24h\":-4.62971,\n            \"priceChange24h\":-0.0008410608839097,\n            \"marketCapChange24h\":-39268.122562502,\n            \"priceChangePercentage7d\":-7.91278\n        },\n        \"projectCreationDate\":1644828523000,\n        \"contracts\":[\n            {\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x0e358838ce72d5e61e0018a2ffac4bec5f4c88d2\"\n            }\n        ],\n        \"updatedAt\":1722544694830,\n        \"category\":\"dex\",\n        \"description\":\"StellaSwap is one of the first automated market-making (AMM), decentralized exchange (DEX) for the Moonbeam parachain network. The unique value proposition of StellaSwap is that we're committed in establishing a strong foundation with our native token, STELLA, as a governance token, diverse farms, a built in bridge and user-centered service. \\r\\n\\r\\nStellaSwap's main objective is to create a broader range of network effects to address the issues of liquidity in the DeFi space, instead of limiting ourselves to a single solution like many DEXs are doing now. This manifests itself in the diverse product suite of StellaSwap that will be explained in more details. Our products are structured in such a way that facilitates decentralized governance of STELLA holders, while continuing to innovate on the collective foundations by design.\",\n        \"usersChange1d\":{\n            \"moonbeam\":-6.18556701030928\n        }\n    }\n}\n</code></pre>"},{"location":"learn/dapp-directory/#query-a-category","title":"Query a Category","text":"<p>You can also query the API by category. For example, you can retrieve information about all NFT projects with the following query:</p> <pre><code>https://apps.moonbeam.network/api/ds/v1/app-dir/projects?category=nfts\n</code></pre> API Response to Querying NFT projects <pre><code>{\n    \"projects\":[\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/nfts2me\",\n                \"website\":\"https://nfts2me.com/\",\n                \"try\":\"https://nfts2me.com/\",\n                \"twitter\":\"https://twitter.com/nfts2me\",\n                \"medium\":\"https://nfts2me.medium.com/\",\n                \"discord\":\"https://nfts2me.com/discord/\"\n            },\n            \"slug\":\"nfts2me\",\n            \"createdAt\":1699292617117,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"nfts2me-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"nfts2me-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"nfts2me-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"NFTs2Me\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1673608509000,\n            \"shortDescription\":\"NFTs2Me is a toolkit for creating and managing NFT projects.\",\n            \"contracts\":[\n                {\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x2269bCeB3f4e0AA53D2FC43B1B7C5C5D13B119a5\"\n                }\n            ],\n            \"updatedAt\":1722498896566,\n            \"category\":\"nfts\",\n            \"description\":\"NFTs2Me is a tool for creating and managing NFT projects. It includes features such as an art generator, delayed reveal, minting widget, token gating, and support for multiple blockchain platforms. It also offers customization options, an affiliate system, automatic logo and banner generation, and support for redeemable NFTs. It is user-friendly and suitable for those new to the world of NFTs.\\n\\nIn addition to these features, NFTs2Me also offers a minting widget and free IPFS hosting to make it simple to mint and store your NFTs securely and efficiently. The minting widget allows you to easily create and mint new NFTs, while the free IPFS hosting provides a secure and decentralized way to store your NFTs.\",\n            \"id\":\"nfts2me\",\n            \"tags\":[\n                \"NFT\",\n                \"Tool\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/rmrkapp\",\n                \"website\":\"https://singular.app/\",\n                \"try\":\"https://singular.app/\",\n                \"twitter\":\"https://twitter.com/RmrkSingular\",\n                \"discord\":\"https://discord.gg/TjB6v5AGZz\"\n            },\n            \"slug\":\"singular-app\",\n            \"createdAt\":1699292616171,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"singular-app-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"singular-app-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"singular-app-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Singular App\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1686240710000,\n            \"shortDescription\":\"The home of NFTs by @RmrkApp. Create and trade your nestable, equippable, soulbound, and multi-asset NFTs with us - no coding required.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498914806,\n            \"category\":\"nfts\",\n            \"description\":\"Singular is an NFT 2.0 marketplace that allows users to buy, sell, and trade both regular and advanced NFTs. Users can create and/or connect a wallet, browse digital items, and securely conduct transactions using blockchain technology.\",\n            \"id\":\"singular-app\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https:/t.me/metacourtgg\",\n                \"website\":\"https://www.metacourt.gg/\",\n                \"try\":\"https://www.metacourt.gg/\",\n                \"twitter\":\"https://twitter.com/metacourtgg\",\n                \"medium\":\"https://metacourtgg.medium.com/\",\n                \"discord\":\"https://discord.gg/9AnnfKCb39\"\n            },\n            \"slug\":\"metacourt\",\n            \"createdAt\":1699292616238,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"metacourt-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"metacourt-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"metacourt-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Metacourt\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1663756794000,\n            \"shortDescription\":\"Metacourt created NFTdeals for anyone who wants to become an influencer and trade their social media\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498888422,\n            \"category\":\"nfts\",\n            \"description\":\"Influencer accelerator for anyone who wants to become an influencer in the space. We allow selling your social media through NFTs and joining influencer marketing campaigns.\",\n            \"id\":\"metacourt\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/tofuNFT\",\n                \"website\":\"https://tofunft.com/\",\n                \"try\":\"https://tofunft.com/\",\n                \"twitter\":\"https://twitter.com/tofuNFT\",\n                \"medium\":\"https://medium.com/tofunftofficial\",\n                \"discord\":\"https://discord.com/invite/3wFUTZmTm7\"\n            },\n            \"slug\":\"tofunft\",\n            \"createdAt\":1699292615874,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"tofunft-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"tofunft-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"tofunft-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"tofuNFT\",\n            \"chains\":[\n                \"moonbeam\",\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"The largest multichain NFT marketplace\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498924881,\n            \"category\":\"nfts\",\n            \"description\":\"tofuNFT.com is an NFT marketplace focused on GameFi and collectibles, rebranded from SCV\u2019s NFT market. Enjoy exploring &amp; trading with your buddies!\",\n            \"id\":\"tofunft\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://d-book.io\",\n                \"try\":\"https://d-book.io\",\n                \"twitter\":\"https://twitter.com/dbook_io\"\n            },\n            \"slug\":\"d-book.io\",\n            \"createdAt\":1699292617021,\n            \"logo\":{\n                \"small\":{\n                    \"width\":129,\n                    \"fileName\":\"d-book.io-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":129,\n                    \"fileName\":\"d-book.io-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"d-book.io-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"D-book.io\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1682016612000,\n            \"shortDescription\":\"Bu\u011fra Ayan is a speaker,and university lecturer in Turkey who founded the Web3 Association Turkey.\",\n            \"contracts\":[\n                {\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x8d4BA02D0973749ad7c646DcaAa60BDC66F6F6D2\"\n                }\n            ],\n            \"updatedAt\":1722498866417,\n            \"category\":\"nfts\",\n            \"description\":\"We are an NFT Book Platform that connects authors and the decentralized world, aiming for a transformation ecosystem.\",\n            \"id\":\"d-book.io\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/BcmHuntGroup\",\n                \"website\":\"https://bcmhunt.com/\",\n                \"try\":\"https://bcmhunt.com/\",\n                \"twitter\":\"https://twitter.com/bcmhunt\",\n                \"medium\":\"https://medium.com/bcmhunt\",\n                \"discord\":\"https://discord.com/invite/Ee9aJ287J2\"\n            },\n            \"slug\":\"blockchain-monster-hunt\",\n            \"createdAt\":1699292616780,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"blockchain-monster-hunt-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":510,\n                    \"fileName\":\"blockchain-monster-hunt-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":510\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"blockchain-monster-hunt-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Blockchain Monster Hunt\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"The First Multichain NFT Monster Hunt\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498855937,\n            \"category\":\"nfts\",\n            \"description\":\"Blockchain Monster Hunt (BCMH) is the world\u2019s first multi-chain game that runs entirely on the blockchain itself. Inspired by Pok\u00e9mon-GO,BCMH allows players  to continuously explore brand new places on the blockchain to hunt and battle monsters. Each block on the blockchain is a unique digital space where a limited number of monsters (of the same DNA gene and rarity) may exist.  Players and collectors can hunt or battle for a chance to capture these unique monsters and to earn coins.\",\n            \"id\":\"blockchain-monster-hunt\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\",\n                \"GLMR Grants\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://speedboat.studio/\",\n                \"try\":\"https://speedboat.studio/\",\n                \"twitter\":\"https://twitter.com/Speedboat_STDO\",\n                \"medium\":\"https://medium.com/@speedboat_studio\",\n                \"discord\":\"https://discord.gg/y7TQbtEWSV\"\n            },\n            \"slug\":\"speedboat.studio\",\n            \"createdAt\":1699292616328,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"speedboat.studio-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":190,\n                    \"fileName\":\"speedboat.studio-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":190\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"speedboat.studio-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Speedboat\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1657584952000,\n            \"shortDescription\":\"Your no-code Web3 toolkit\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498916466,\n            \"category\":\"nfts\",\n            \"description\":\"Speedboat is a Web3 toolkit for everyone. Built on the idea that NFTs are not just expensive JPEGs, but programmable experiences.\",\n            \"id\":\"speedboat.studio\",\n            \"tags\":[\n                \"NFT\",\n                \"Tool\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/+qGh0InPSPc1iMTNk\",\n                \"website\":\"https://www.glmrapes.com/\",\n                \"try\":\"https://www.glmrapes.com/\",\n                \"twitter\":\"https://twitter.com/GLMRApes\",\n                \"discord\":\"https://discord.com/invite/glmrapes\"\n            },\n            \"web3goContracts\":[\n                {\n                    \"name\":\"GLMR Apes: GLMR Ape\",\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x8fbe243d898e7c88a6724bb9eb13d746614d23d6\"\n                },\n                {\n                    \"name\":\"GLMR Apes: GLMR Jungle\",\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0xcb13945ca8104f813992e4315f8ffefe64ac49ca\"\n                }\n            ],\n            \"currentTx\":{\n                \"moonbeam\":7830\n            },\n            \"slug\":\"glmr-apes\",\n            \"web3goIDs\":[\n                \"GLMR Apes\"\n            ],\n            \"createdAt\":1699292616827,\n            \"logo\":{\n                \"small\":{\n                    \"width\":47,\n                    \"fileName\":\"glmr-apes-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":528,\n                    \"fileName\":\"glmr-apes-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":408\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"glmr-apes-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"GLMR APES\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"usersChange7d\":{\n                \"moonbeam\":-66.6666666666667\n            },\n            \"currentUsers\":{\n                \"moonbeam\":1531\n            },\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"The first NFT collection on GLMR by &amp; for the community\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722547408370,\n            \"category\":\"nfts\",\n            \"description\":\"GLIMMER APES is the first NFT collection on GLMR by &amp; for the community. The longer you\u2019re bonding with GLMR Apes and the friendlier their behavior. Join the troops as soon as possible to become an EARLY APE, take part in our giveaways and games and land in the GLMR APE VIP CLUB.\",\n            \"id\":\"glmr-apes\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\"\n            ],\n            \"usersChange1d\":{\n                \"moonbeam\":0\n            }\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://snakesoldiers.com\",\n                \"try\":\"https://snakesoldiers.com\",\n                \"twitter\":\"https://twitter.com/snakesoldiers\",\n                \"github\":\"https://github.com/steven2308/snake-soldiers-contracts\",\n                \"medium\":\"https://medium.com/@snakesoldiers/emoting-to-influence-the-hatch-df3eab7e45b8\",\n                \"discord\":\"http://discord.gg/A6zQSz4YU4\"\n            },\n            \"slug\":\"snake-soldiers\",\n            \"createdAt\":1699292616971,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"snake-soldiers-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"snake-soldiers-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"snake-soldiers-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Snake Soldiers\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1691439275000,\n            \"shortDescription\":\"NFT game collection divided in 3 categories: Generals, Commanders and Soldiers\ud83d\udc0d. Built on Moonbeam\",\n            \"contracts\":[\n                {\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x3ab955216BdD76f51fbe02A3fe237D6612BBD09F\"\n                }\n            ],\n            \"updatedAt\":1722498915320,\n            \"category\":\"nfts\",\n            \"description\":\"Snake Soldiers is an NFT collection with a supply of at most 5k units, all unique and distributed among 3 ranks. Each snake will be usable inside a play to own game, where snakes will be the main characters, necessary to interact with the SerpenTerra ecosystem. This metaverse will be based on the RMRK 2.0 standard, making forward compatible and giving super powers to the NFTs.\",\n            \"id\":\"snake-soldiers\",\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/+LqmDOeGUQdRmYjVh%60%60\",\n                \"website\":\"https://omni-x.io\",\n                \"try\":\"https://omni-x.io\",\n                \"twitter\":\"https://twitter.com/omnix_nft\",\n                \"github\":\"https://github.com/Omni-X-NFT\",\n                \"discord\":\"https://discord.gg/omni-x\"\n            },\n            \"slug\":\"omni-x\",\n            \"createdAt\":1699292617077,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"omni-x-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":107,\n                    \"fileName\":\"omni-x-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":108\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"omni-x-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Omni-X\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1673811786000,\n            \"shortDescription\":\"The first natively omnichain NFT platform\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498898538,\n            \"category\":\"nfts\",\n            \"description\":\"Omni X is an omnichain NFT protocol and marketplace that connects communities, creators, and enthusiasts across multiple blockchains. \\n\\nWe provide tooling for creating ONFT collections, bridging regular NFTs to ONFTs and grant access to unparalleled liquidity that allows users to buy and sell NFTs from any blockchain to any other blockchain.\",\n            \"id\":\"omni-x\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"Infrastructure\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://www.publicpressure.io/\",\n                \"try\":\"https://www.publicpressure.io/\",\n                \"twitter\":\"https://twitter.com/jointhepressure\",\n                \"discord\":\"https://discord.gg/publicpressure\"\n            },\n            \"slug\":\"publicpressure\",\n            \"createdAt\":1702283744356,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"publicpressure-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"publicpressure-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"publicpressure-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Public Pressure\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1651597275000,\n            \"shortDescription\":\"Support your favorite artists, own their music, get rewarded.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498907699,\n            \"category\":\"nfts\",\n            \"description\":\"We are the web3 music platform powered by artists, labels and fans\",\n            \"id\":\"publicpressure\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ]\n        },\n        {\n            \"currentTx\":{\n                \"moonbeam\":8409\n            },\n            \"web3goIDs\":[\n                \"Moonbeans\"\n            ],\n            \"name\":\"Moonbeans\",\n            \"currentUsers\":{\n                \"moonbeam\":1134\n            },\n            \"coinGeckoId\":\"moonbeans\",\n            \"shortDescription\":\"Galactic Co-Op &amp; Profit sharing NFT platform and soon to be Metaverse\",\n            \"id\":\"moonbeans\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ],\n            \"urls\":{\n                \"website\":\"https://moonbeans.io/\",\n                \"twitter\":\"https://twitter.com/moonbeansio\",\n                \"github\":\"https://github.com/m00nbeans\",\n                \"discord\":\"https://discord.com/invite/qqE9aBPzQ9\",\n                \"telegram\":\"https://t.me/moonbeansio\",\n                \"try\":\"https://moonbeans.io/\",\n                \"medium\":\"https://medium.com/@MoonBeans\"\n            },\n            \"web3goContracts\":[\n                {\n                    \"name\":\"Moonbeans: Beanie Distributor V2\",\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0xda6367c6510d8f2d20a345888f9dff3eb3226b02\"\n                },\n                {\n                    \"name\":\"Moonbeans: Marketplace V9\",\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x683724817a7d526d6256aec0d6f8ddf541b924de\"\n                },\n                {\n                    \"name\":\"Moonbeans: Storefront Ownership V1\",\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x971dfedd548f2269e515957404cbbee1f507cd01\"\n                }\n            ],\n            \"slug\":\"moonbeans\",\n            \"createdAt\":1699292615978,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"moonbeans-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"moonbeans-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"moonbeans-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"chains\":[\n                \"moonbeam\",\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"usersChange7d\":{\n                \"moonbeam\":0\n            },\n            \"marketData\":{\n                \"symbol\":\"beans\",\n                \"marketCap\":0,\n                \"priceChangePercentage1y\":-62.22489,\n                \"currentPrice\":0.062264,\n                \"priceChangePercentage14d\":-13.93552,\n                \"contracts\":{\n\n                },\n                \"priceChangePercentage60d\":-44.93764,\n                \"priceChangePercentage30d\":-33.587,\n                \"priceChangePercentage24h\":-0.05451,\n                \"priceChangePercentage200d\":-83.0363,\n                \"marketCapChangePercentage24h\":0,\n                \"priceChange24h\":-0.0000339560550113,\n                \"marketCapChange24h\":0,\n                \"priceChangePercentage7d\":-5.36696\n            },\n            \"projectCreationDate\":1644828523000,\n            \"contracts\":[\n                {\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x65b09ef8c5a096c5fd3a80f1f7369e56eb932412\"\n                },\n                {\n                    \"chain\":\"moonriver\",\n                    \"contract\":\"0xC2392DD3e3fED2c8Ed9f7f0bDf6026fcd1348453\"\n                }\n            ],\n            \"updatedAt\":1722548296818,\n            \"category\":\"nfts\",\n            \"description\":\"Moonbeans is a fully functional NFT marketplace launched on October 8th 2021, after releasing 465 Beanies into the Moonriver network to wreak havoc. The platform is still in beta, but has been performing incredibly well. With minimal fees for artists, traders, and project developers, Moonbeans aims to grow and aid the Moonrver network as a whole to develop, learn, and earn. With multiple collections now live (Beanies, Damned Pirates Society), minting (RivrMaids), Moonbeans is the heart of the Moonriver NFT ecosystem.\",\n            \"usersChange1d\":{\n                \"moonbeam\":0\n            }\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/blocsport\",\n                \"website\":\"https://blocsport.one/\",\n                \"try\":\"https://blocsport.one/\",\n                \"twitter\":\"https://twitter.com/blocsport1\",\n                \"medium\":\"https://blocsport1.medium.com/\"\n            },\n            \"slug\":\"blocsport-one\",\n            \"createdAt\":1699292616637,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"blocsport-one-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"blocsport-one-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"blocsport-one-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Blocsport.one\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"Web 3.0 metaverse, smart sports money, athlete NFT launchpad &amp; assets tokenization\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498857332,\n            \"category\":\"nfts\",\n            \"description\":\"Blocsport.one is a Swiss sports tech company founded in 2019 that is transforming the sports business by building a transparent and reliable sports ecosystem uniting athletes, clubs, and fans based on blockchain. Company owns NFTdeals.io exclusive marketplace and has the biometric-enabled football scouting DApp live. Blocsport.one helps the young promising athletes get the money and exposure for their career development, which is nobody else doing in the world.\",\n            \"id\":\"blocsport-one\",\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/mintverse\",\n                \"website\":\"https://www.mintverse.com/\",\n                \"try\":\"https://www.mintverse.com/\",\n                \"twitter\":\"https://twitter.com/mintverse_\",\n                \"medium\":\"https://medium.com/mintverse\",\n                \"discord\":\"https://discord.com/invite/mhhnbvAaq9\"\n            },\n            \"slug\":\"mintverse\",\n            \"createdAt\":1702283733666,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"mintverse-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"mintverse-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"mintverse-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Mintverse\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1651597514000,\n            \"shortDescription\":\"Mint, Explore &amp; Trade Liquid NFT Assets Across Multiple Chains\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498889300,\n            \"category\":\"nfts\",\n            \"description\":\"Comprehensive NFT Aggregation Marketplace with a 0% trading fee\",\n            \"id\":\"mintverse\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/rmrkapp\",\n                \"website\":\"https://upgradooor.app\",\n                \"try\":\"https://upgradooor.app\",\n                \"twitter\":\"https://x.com/rmrkapp\",\n                \"github\":\"https://github.com/rmrk-team\",\n                \"medium\":\"https://medium.com/rmrkapp\"\n            },\n            \"slug\":\"upgradooor\",\n            \"createdAt\":1699292616895,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"upgradooor-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"upgradooor-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"upgradooor-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Upgradooor\",\n            \"chains\":[\n                \"moonbeam\",\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1692259742000,\n            \"shortDescription\":\"Upgrade your NFT 1.0 collections to NFT 2.0 by wrapping them into advanced functionality\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498927244,\n            \"category\":\"nfts\",\n            \"description\":\"As a collection issuer, use Upgradooor to initialize the process of upgrading your collection to NFT 2.0 if you are currently using ERC721.\\n\\nAs a holder, once the collection owner initiates the process, you can wrap any NFT you hold in that collection and instantly turn it into an equippable, multi-asset, composable NFT with no added risk.\\n\\nYou can always unwrap at will, and all the changes will still wait for you when you decide to re-claim the 2.0 wrapper again.\\n\\nUpgrading allows you to:\\n\\n- add more assets (outputs) to a legacy NFT, preventing needless airdrop spam\\n- airdrop NFTs into the NFT itself, preventing detachment of context, and saving tremendous amounts of gas by letting people transfer just the parent NFT\\n- define equippable settings and even achieve compatibility with other collections, for cross collection equippables and thus cross collection royalties and commissions\\n- see your NFTs on Singular, and use GBM auctions as a unique and novel listing mechanic\",\n            \"id\":\"upgradooor\",\n            \"tags\":[\n                \"NFT\",\n                \"Tool\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/moonfit_official_community\",\n                \"website\":\"https://moonfit.xyz/\",\n                \"try\":\"https://moonfit.xyz/\",\n                \"twitter\":\"https://twitter.com/MoonFitOfficial\",\n                \"discord\":\"https://discord.gg/hStdUVtHXp\"\n            },\n            \"slug\":\"moonfit\",\n            \"createdAt\":1702283734897,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"moonfit-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"moonfit-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"moonfit-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"MoonFit\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1654692249000,\n            \"shortDescription\":\"Web3 &amp; NFT Lifestyle App That Pays You Anytime You Burn Calories\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498891201,\n            \"category\":\"nfts\",\n            \"description\":\"MoonFit is a Web3 Lifestyle App that promotes active living by rewarding users with tokens and NFTs anytime they burn calories through physical activities.\",\n            \"id\":\"moonfit\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/rmrkapp\",\n                \"website\":\"https://rmrk.app/\",\n                \"try\":\"https://rmrk.app/\",\n                \"twitter\":\"https://twitter.com/rmrkapp\",\n                \"discord\":\"https://discord.com/invite/bV9kQbVC99\"\n            },\n            \"slug\":\"rmrk\",\n            \"createdAt\":1699292615938,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"rmrk-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"rmrk-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"rmrk-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"RMRK\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"marketData\":{\n                \"symbol\":\"rmrk\",\n                \"marketCap\":5985029,\n                \"marketCapRank\":1602,\n                \"priceChangePercentage1y\":-64.99216,\n                \"currentPrice\":0.62974,\n                \"priceChangePercentage14d\":-24.26661,\n                \"contracts\":{\n                    \"moonbeam\":\"0x524d524b4c9366be706d3a90dcf70076ca037ae3\"\n                },\n                \"priceChangePercentage60d\":-51.72181,\n                \"priceChangePercentage30d\":-30.11256,\n                \"priceChangePercentage24h\":-2.58554,\n                \"priceChangePercentage200d\":-75.55551,\n                \"marketCapChangePercentage24h\":-2.50147,\n                \"priceChange24h\":-0.01671434617594,\n                \"marketCapChange24h\":-153554.8536219,\n                \"priceChangePercentage7d\":-1.5052\n            },\n            \"coinGeckoId\":\"rmrk\",\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"Creators of NFTs 2.0 via ERC6059, ERC6220, ERC5773, EIP6381, and EIP6454.\\nNFT equippables, future compatibility, reputation, and token balances.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722548302467,\n            \"category\":\"nfts\",\n            \"description\":\"With the RMRK NFT Building Block System\\nOur ERC NFT standards allow you to unlock the true potential of NFTs.\\nTailored to work with each other, these EVM smart contracts will help you create your NFT projects of varying complexity.\",\n            \"id\":\"rmrk\",\n            \"tags\":[\n                \"NFT\",\n                \"Infrastructure\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://www.mynft.com/\",\n                \"try\":\"https://bridge.mynft.com/home\",\n                \"twitter\":\"https://twitter.com/mynft\"\n            },\n            \"slug\":\"mynft\",\n            \"createdAt\":1699292616578,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"mynft-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"mynft-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"mynft-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"myNFT\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"The marketplace that puts the power back in your hands\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498895020,\n            \"category\":\"nfts\",\n            \"description\":\"myNFT is the marketplace that puts the power back in your hands. It is a creative workshop, a trading platform and a discovery engine, helping you tell your story and share your passions, on your own terms. myNFT is built on decentralized technologies empowering you to create, trade, and discover. myNFT is built by Perpetual Altruism, a leader in the NFT space and the creator of charitable NFT publisher Cryptograph and the GBM auction system. Perpetual Altruism is backed by prominent investors and creators and is also the recipient of grants from the Web3 Foundation and the Moonbeam network for their work on the decentralized internet, which powers myNFT.\",\n            \"id\":\"mynft\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"GLMR Grants\",\n                \"MOVR Grants\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://readl.co/\",\n                \"try\":\"https://readl.co/\",\n                \"twitter\":\"https://twitter.com/readl_co\",\n                \"medium\":\"https://medium.com/@readlnetwork\",\n                \"discord\":\"https://discord.gg/XPTENepHqY\"\n            },\n            \"slug\":\"readl\",\n            \"createdAt\":1702283745749,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"readl-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"readl-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"readl-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Readl\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1655885161000,\n            \"shortDescription\":\"Bringing the publishing industry to web3\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498910044,\n            \"category\":\"nfts\",\n            \"description\":\"Readl is the protocol that provides publishers and storytellers with the infrastructure to publish their content on the blockchain, while providing a user-friendly platform to enjoy any story, in any format.\",\n            \"id\":\"readl\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"MOVR Grants\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/rmrkapp\",\n                \"website\":\"https://emotes.app\",\n                \"try\":\"https://emotes.app\",\n                \"twitter\":\"https://x.com/rmrkapp\",\n                \"github\":\"https://github.com/rmrk-team\",\n                \"medium\":\"https://medium.com/rmrkapp\"\n            },\n            \"slug\":\"emotes.app\",\n            \"createdAt\":1699292616951,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"emotes.app-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"emotes.app-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"emotes.app-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Emotes.app\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1692254489000,\n            \"shortDescription\":\"React on anyone's NFT - throw \ud83d\udca9 at those apes, give a \ud83e\udd17 to those Pudgies!\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498871347,\n            \"category\":\"nfts\",\n            \"description\":\"Emotes.app is a RMRK mini-app which allows you to send emotes / reactions to anyone's NFT. It utilizes RMRK's ERC7009 and is trivial to integrate into any project wanting to take advantage of the community's reactions to their NFTs.\\n\\nUse it to direct storylines, affect NFT egg hatching, or just do relative price comparison when influencers like one NFTs and dislike another!\",\n            \"id\":\"emotes.app\",\n            \"tags\":[\n                \"NFT\",\n                \"Social\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://twitter.com/PolkaPets\",\n                \"website\":\"https://www.polkapet.world/\",\n                \"try\":\"https://www.polkapet.world/\",\n                \"twitter\":\"https://twitter.com/PolkaPets\",\n                \"medium\":\"https://polkapetworld.medium.com/\"\n            },\n            \"slug\":\"polkapet-world\",\n            \"createdAt\":1702283743596,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"polkapet-world-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"polkapet-world-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"polkapet-world-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"PolkaPets\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"marketData\":{\n                \"priceChangePercentage60d\":1206.42918,\n                \"symbol\":\"pets\",\n                \"marketCap\":0,\n                \"priceChangePercentage30d\":619.39533,\n                \"priceChangePercentage200d\":135.91624,\n                \"priceChangePercentage1y\":355.00061,\n                \"currentPrice\":0.00515699,\n                \"priceChangePercentage14d\":-15.30948,\n                \"contracts\":{\n                    \"moonriver\":\"0x1e0f2a75be02c025bd84177765f89200c04337da\"\n                },\n                \"priceChangePercentage7d\":749.62625\n            },\n            \"coinGeckoId\":\"polkapet-world\",\n            \"projectCreationDate\":1651157216000,\n            \"shortDescription\":\"Welcome to PolkaPet World\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722548303208,\n            \"category\":\"nfts\",\n            \"description\":\"An immersive NFT collection created in partnership with the biggest and best PolkaDot projects \",\n            \"id\":\"polkapet-world\",\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://www.moonarines.com/\",\n                \"try\":\"https://www.moonarines.com/\",\n                \"discord\":\"https://discord.gg/bXhSyW8htW\"\n            },\n            \"slug\":\"moonarines\",\n            \"createdAt\":1702283733870,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"moonarines-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"moonarines-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"moonarines-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Moonarines\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1654792422000,\n            \"shortDescription\":\"Be part of the conquest of the digital space\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498889804,\n            \"category\":\"nfts\",\n            \"description\":\"The Moonarines are unique NFT characters starting soon on the Moonriver Network!\\nWith the Moonarines, the NFT owners will be taken to an unforgettable adventure to explore the Cryptoverse!\",\n            \"id\":\"moonarines\",\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/NFTrade\",\n                \"website\":\"https://nftrade.com/\",\n                \"try\":\"https://nftrade.com/\",\n                \"twitter\":\"https://twitter.com/NFTradeOfficial\",\n                \"medium\":\"https://medium.com/@NFTrade\",\n                \"discord\":\"https://discord.com/invite/SESqfsyw8k\"\n            },\n            \"slug\":\"nftrade\",\n            \"createdAt\":1699292616005,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"nftrade-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"nftrade-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"nftrade-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"NFTrade\",\n            \"chains\":[\n                \"moonbeam\",\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"marketData\":{\n                \"symbol\":\"nftd\",\n                \"marketCap\":234018,\n                \"marketCapRank\":3653,\n                \"priceChangePercentage1y\":-65.38449,\n                \"currentPrice\":0.00502075,\n                \"priceChangePercentage14d\":-7.09922,\n                \"contracts\":{\n\n                },\n                \"priceChangePercentage60d\":-27.37596,\n                \"priceChangePercentage30d\":-14.12267,\n                \"priceChangePercentage24h\":-2.22137,\n                \"priceChangePercentage200d\":-56.66993,\n                \"marketCapChangePercentage24h\":-2.16658,\n                \"priceChange24h\":-0.00011406326237191,\n                \"marketCapChange24h\":-5182.473845666,\n                \"priceChangePercentage7d\":-6.88049\n            },\n            \"coinGeckoId\":\"nftrade\",\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"Create, Buy, Sell, Swap and Farm NFTs\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722548304198,\n            \"category\":\"nfts\",\n            \"description\":\"NFTrade is a multi-chain platform for NFT creation and trading. Seamlessly launch, mint, and swap non-fungible tokens. Earn digital collectibles. NFTrade places you at the heart of the NFT economy. Create, Buy, Sell, Swap and Farm NFTs. All chains, All NFTs, One Platform.\",\n            \"id\":\"nftrade\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"MOVR Grants\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://www.pipcards.com/\",\n                \"try\":\"https://www.pipcards.com/\",\n                \"twitter\":\"https://twitter.com/pipcards\",\n                \"discord\":\"https://discord.com/invite/hnSC7QjTHj\"\n            },\n            \"slug\":\"pipcards\",\n            \"createdAt\":1699292616371,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"pipcards-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"pipcards-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"pipcards-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"PIP Cards\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1651149583000,\n            \"shortDescription\":\"Post-generated NFT playing card decks\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498904704,\n            \"category\":\"nfts\",\n            \"description\":\"PIPS is a first-of-its-kind NFT generative playing card project that will enable NFT holders to generate an entire deck of custom cards to be used cross-chain.\",\n            \"id\":\"pipcards\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://bithotel.io/\",\n                \"twitter\":\"https://twitter.com/playbithotel\",\n                \"github\":\"https://github.com/BitHotelOrg/bithotel-token-contracts\",\n                \"discord\":\"https://discord.gg/RFFZNwxY9n\",\n                \"telegram\":\"https://t.me/bithotelcommunity\",\n                \"try\":\"https://bithotel.io/\",\n                \"medium\":\"https://medium.com/@bithotelnftgame\"\n            },\n            \"slug\":\"bit-hotel\",\n            \"createdAt\":1702283710425,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"bit-hotel-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":500,\n                    \"fileName\":\"bit-hotel-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":500\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"bit-hotel-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Bit Hotel\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1658743551000,\n            \"shortDescription\":\"Bit Hotel is a Social-first Play 2 Earn NFT Gaming Metaverse set in a Pixel-art Hotel.\",\n            \"contracts\":[\n                {\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"Not deployed yet\"\n                },\n                {\n                    \"chain\":\"moonriver\",\n                    \"contract\":\"Not deployed yet\"\n                }\n            ],\n            \"updatedAt\":1722498854706,\n            \"category\":\"nfts\",\n            \"description\":\"In Bit Hotel users can compete to earn Bit Hotel tokens and acquire native NFTs. These NFTs have in-game utilities and consist of characters, hotel rooms, furniture and other assets that have their own unique perks. With over 250k Hotel Guests cross-channel, this nostalgic Hotel metaverse is taking people back to their 8bit upbringing.\",\n            \"id\":\"bit-hotel\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\"\n            ]\n        },\n        {\n            \"tvlChange7d\":{\n                \"moonriver\":0.00190215150271202\n            },\n            \"urls\":{\n                \"website\":\"https://www.moonbeamdao.com/\",\n                \"try\":\"https://www.moonbeamdao.com/\",\n                \"twitter\":\"https://twitter.com/moonbeam_dao\",\n                \"medium\":\"https://medium.com/@moonbeamdao\",\n                \"discord\":\"https://discord.gg/AevrFzwZjk\"\n            },\n            \"web3goContracts\":[\n                {\n                    \"name\":\"MoonDAO: MDAO Token\",\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0xc6342eab8b7cc405fc35eba7f7401fc400ac0709\"\n                }\n            ],\n            \"currentTx\":{\n                \"moonbeam\":972\n            },\n            \"slug\":\"moondao\",\n            \"web3goIDs\":[\n                \"MoonDAO\"\n            ],\n            \"createdAt\":1699292616416,\n            \"tvlChange1d\":{\n                \"moonriver\":-0.0349944884006391\n            },\n            \"logo\":{\n                \"small\":{\n                    \"width\":25,\n                    \"fileName\":\"moondao-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":330,\n                    \"fileName\":\"moondao-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":475\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"moondao-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"MoonDAO\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"currentTVL\":{\n                \"moonriver\":76.75665\n            },\n            \"currentUsers\":{\n                \"moonbeam\":229\n            },\n            \"projectCreationDate\":1648347145000,\n            \"shortDescription\":\"The first &amp; only community art dao on moonbeam\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722547637377,\n            \"category\":\"nfts\",\n            \"description\":\"MoonDao is the first community Art Collection DAO on the Moonbeam network!\\n\\nWe aim to utilize input from our community to select high-end NFT\u2019s. These NFT\u2019s will be acquired with the MoonDao treasury and stored in the MoonDao Vault.\\n\\nMoon ownership grants access to DAO voting rights, future events, and additional holder perks outlined below. Welcome to the moon, we hope you stay.\\n\\n\",\n            \"id\":\"moondao\",\n            \"tags\":[\n                \"NFT\",\n                \"DAO\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/raresama\",\n                \"website\":\"https://raresama.com/\",\n                \"try\":\"https://raresama.com/\",\n                \"twitter\":\"https://twitter.com/RaresamaNFT\",\n                \"discord\":\"https://discord.com/channels/938592318380982303/1010237900685840405\"\n            },\n            \"slug\":\"raresama\",\n            \"createdAt\":1699292615958,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"raresama-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"raresama-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"raresama-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Raresama\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1662528828000,\n            \"shortDescription\":\"Discover amazing Rare digital artwork\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498909462,\n            \"category\":\"nfts\",\n            \"description\":\"Raresama brings the magic of owning a piece of artwork to your fingertips. Create or browse NFT art collections and enjoy a diverse mix of artists, genres, styles and movements.\",\n            \"id\":\"raresama\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://gal.xyz/telegram\",\n                \"website\":\"https://galxe.com/\",\n                \"try\":\"https://galxe.com/\",\n                \"twitter\":\"https://twitter.com/Galxe\",\n                \"medium\":\"https://blog.galxe.com/\",\n                \"discord\":\"https://gal.xyz/discord\"\n            },\n            \"slug\":\"galxe\",\n            \"createdAt\":1699292616277,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"galxe-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"galxe-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"galxe-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Galxe\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1659868871000,\n            \"shortDescription\":\"Create Impactful Experiences With #Web3 Credentials. (Formerly Project Galaxy) \",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498876438,\n            \"category\":\"nfts\",\n            \"description\":\"Galxe is the leading Web3 credential data network in the world. A collaborative credential infrastructure enabling brands and developers to engage communities and build robust products in Web3.\",\n            \"id\":\"galxe\",\n            \"tags\":[\n                \"NFT\",\n                \"Social\",\n                \"Tool\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"http://t.me/MoonsamaNFT\",\n                \"website\":\"https://moonsama.com/\",\n                \"try\":\"https://moonsama.com/\",\n                \"twitter\":\"https://twitter.com/MoonsamaNFT\",\n                \"discord\":\"discord.gg/moonsama\"\n            },\n            \"slug\":\"moonsama\",\n            \"createdAt\":1702283735408,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"moonsama-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"moonsama-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"moonsama-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Moonsama\",\n            \"chains\":[\n                \"moonriver\",\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1651156798000,\n            \"shortDescription\":\"Let's build the multiverse\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498892389,\n            \"category\":\"nfts\",\n            \"description\":\"Moonsama\u2019s protocol for bi-directional bridging of on-chain digital assets and off-chain applications. This is how we connect web2.0 games, metaverses and blockchains. It enables new games, development and community fun from across the Kusamaverse and beyond!\",\n            \"id\":\"moonsama\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://smartstamp.com/\",\n                \"try\":\"https://smartstamp.com/\",\n                \"discord\":\"https://discord.gg/kajPqvZY\"\n            },\n            \"slug\":\"smartstamp\",\n            \"createdAt\":1699292617058,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"smartstamp-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":436,\n                    \"fileName\":\"smartstamp-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":436\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"smartstamp-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"SmartStamp\",\n            \"chains\":[\n                \"moonbeam\",\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1675081766000,\n            \"shortDescription\":\"SmartStamp is the pioneering new standard in identification and authentication for the art world.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498915044,\n            \"category\":\"nfts\",\n            \"description\":\"Developed over more than a decade, SmartStamp\u2019s app uses patented AI technology that is designed to read and record artworks\u2019 surface characteristics\u2013 offering artists, collectors, institutions, and all arts and culture stakeholders a way to securely and immutably link physical objects to their digital fingerprints on the blockchain. Using the SmartStamp app is as simple as taking a picture, making the groundbreaking security and timestamping power of blockchain technology accessible to anyone who can use a smartphone.\",\n            \"id\":\"smartstamp\",\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/yusernetwork\",\n                \"website\":\"https://yuser.network/\",\n                \"try\":\"https://yuser.network/\",\n                \"twitter\":\"https://twitter.com/yuser\",\n                \"medium\":\"https://medium.com/yuser\",\n                \"discord\":\"https://discord.com/invite/uRRxnfAjhY\"\n            },\n            \"slug\":\"yuser\",\n            \"createdAt\":1699292616605,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"yuser-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"yuser-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"yuser-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Yuser\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"The first NFT social networking app- by creators, for creators\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498932483,\n            \"category\":\"nfts\",\n            \"description\":\"Yuser\u2019s mission is to build an ecosystem of interconnected applications that put power back into the hands of users by giving them full control over their content, data, and personal networks. Developers can connect via an API to instantly gain access to millions of users and incentivize them to try their product by paying them with a token.\",\n            \"id\":\"yuser\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"GLMR Grants\",\n                \"MOVR Grants\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/cryptosoots\",\n                \"website\":\"https://raregems.io/my#\",\n                \"try\":\"https://raregems.io/my#\",\n                \"twitter\":\"https://twitter.com/RareGems_io\"\n            },\n            \"slug\":\"rare-gems\",\n            \"createdAt\":1702283745336,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"rare-gems-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":360,\n                    \"fileName\":\"rare-gems-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":360\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"rare-gems-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Rare Gems\",\n            \"chains\":[\n                \"moonriver\",\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1652705611000,\n            \"shortDescription\":\"Multichain NFT marketplace.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498909205,\n            \"category\":\"nfts\",\n            \"description\":\"Multichain NFT marketplace\\nCreated by \\n@cryptosoots\",\n            \"id\":\"rare-gems\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/rmrkapp\",\n                \"website\":\"https://wizard.rmrk.dev\",\n                \"try\":\"https://wizard.rmrk.dev\",\n                \"twitter\":\"https://x.com/rmrkapp\",\n                \"github\":\"https://github.com/rmrk-team\",\n                \"medium\":\"https://medium.com/rmrkapp\"\n            },\n            \"slug\":\"rmrk-wizard\",\n            \"createdAt\":1699292616919,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"rmrk-wizard-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"rmrk-wizard-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"rmrk-wizard-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"RMRK Wizard\",\n            \"chains\":[\n                \"moonbeam\",\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1692255253000,\n            \"shortDescription\":\"A no-code-but-code wizard UI for building NFTs 2.0\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498911520,\n            \"category\":\"nfts\",\n            \"description\":\"A simple UI to put together NFT 2.0 legos created by the RMRK.app team. Use this tool to get started developing advanced NFT collections by picking from a set of functions you need, and the tool will compose code for you which only needs final tweaks before being deployed!\",\n            \"id\":\"rmrk-wizard\",\n            \"tags\":[\n                \"NFT\",\n                \"Tool\",\n                \"Developer Tools\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/evelonapp\",\n                \"website\":\"https://platform.evelon.app/\",\n                \"try\":\"https://www.evelon.app/\",\n                \"twitter\":\"https://twitter.com/EvelonApp\"\n            },\n            \"slug\":\"evelon-app\",\n            \"createdAt\":1699292616145,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"evelon-app-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"evelon-app-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"evelon-app-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Evelon.App\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1690486894000,\n            \"shortDescription\":\"Transform the way you create and bring to life your own unique DNFTs, with the revolutionary platform that combines cutting-edge AI technology.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498873048,\n            \"category\":\"nfts\",\n            \"description\":\"Evelon is a no code platform that allows you to create and deploy dynamic NFTs with ease. This project is a game changer in the world of NFTs and image generation. Evelon uses AI to generate high-quality images, making it possible to create NFTs with unique visuals that are both dynamic and engaging.\",\n            \"id\":\"evelon-app\",\n            \"tags\":[\n                \"NFT\",\n                \"Tool\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://mintlabz.io/\",\n                \"try\":\"https://app.mintlabz.io/\",\n                \"twitter\":\"https://twitter.com/mintlabz\",\n                \"medium\":\"https://blog.mintlabz.io/\",\n                \"discord\":\"https://discord.com/invite/BRF2PEetea\"\n            },\n            \"slug\":\"mintlabz\",\n            \"createdAt\":1712311518649,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"mintlabz-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"mintlabz-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"mintlabz-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Mintlabz\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1712189524,\n            \"shortDescription\":\"MintLabz is a complete crosschain NFT solution at zero cost.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498889042,\n            \"category\":\"nfts\",\n            \"description\":\"MintLabz aims to establish a digital NFT minting platform for third party projects to create NFT collections with utilities to reward the NFT holder. Our mission is to become the number one choice for providing complete cross-chain NFT solutions to B2B customers.\",\n            \"id\":\"mintlabz\",\n            \"tags\":[\n                \"nfts\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/golempark\",\n                \"website\":\"https://golempark.com\",\n                \"try\":\"https://golempark.com\",\n                \"twitter\":\"https://twitter.com/golempark\",\n                \"discord\":\"https://discord.gg/rNvtdHN8q7\"\n            },\n            \"slug\":\"golem-park\",\n            \"createdAt\":1699292617039,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"golem-park-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"golem-park-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"golem-park-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Golem Park\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1676839105000,\n            \"shortDescription\":\"Golem Park is holders friendly NFT collection. P2E blockchain game, $GP Token, Staking Pools &amp; more\",\n            \"contracts\":[\n                {\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x74746524f5A31F08e0528FaA704C2c5d8d116506\"\n                }\n            ],\n            \"updatedAt\":1722498878088,\n            \"category\":\"nfts\",\n            \"description\":\"First Time In Crypto History Token Burning Campaign!\\n30% Of Total Token Supply Will Be Burned In 30 Days.\\n\\nAfter Minting We Are Going To Release Deflationary $GP Token &amp; 50% Of Total Supply Will Be Distributed To All $GP NFT Holders, 1 NFT = 5 000 000 Tokens. Then 30 Days Each Day We'll Burn 1% Of Total Token Supply To Ensure Token Price Will Go UP!\\n\\nWorld Of Golems is a decentralized Play-To-Earn blockchain game.\\nOnce You Become Golem Park NFT Holder You Will Be Able To Participate in the WoG Game, Own Countries And Display Your Message On Them.\\n\\nThe Leaderboard Shows Of TOP 5 Wealthiest Countries &amp; Every Month Owners Of These Countries Will Be Rewarded With $GLMR.\",\n            \"id\":\"golem-park\",\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/rarible\",\n                \"website\":\"https://rarible.com/\",\n                \"try\":\"https://rarible.com/\",\n                \"twitter\":\"https://x.com/rarible\",\n                \"discord\":\"https://discord.com/invite/rarible\"\n            },\n            \"slug\":\"rarible\",\n            \"createdAt\":1722498909701,\n            \"logo\":{\n                \"small\":{\n                    \"width\":429,\n                    \"fileName\":\"rarible-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":121\n                },\n                \"large\":{\n                    \"width\":858,\n                    \"fileName\":\"rarible-medium.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":242\n                },\n                \"full\":{\n                    \"width\":1716,\n                    \"fileName\":\"rarible-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":485\n                }\n            },\n            \"name\":\"Rarible\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"shortDescription\":\"Rarible - NFT Marketplace for Brands, Communities and Traders\",\n            \"projectCreationDate\":1721872843,\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498909701,\n            \"category\":\"nfts\",\n            \"description\":\"Discover, sell and buy NFTs on Rarible! Our aggregated NFT marketplace for Ethereum NFTs and Polygon NFTs powers brands, collections and creator marketplaces.\",\n            \"id\":\"rarible\",\n            \"featured\":false,\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://neoncrisis.io/\",\n                \"try\":\"https://neoncrisis.io/\",\n                \"twitter\":\"https://twitter.com/NeonCrisisNFT\",\n                \"discord\":\"https://discord.gg/MVVjT9k9eD\"\n            },\n            \"slug\":\"neoncrisis-io\",\n            \"createdAt\":1702283737907,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"neoncrisis-io-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":319,\n                    \"fileName\":\"neoncrisis-io-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":319\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"neoncrisis-io-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Neon Crisis\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1654792548000,\n            \"shortDescription\":\"6,008 heroes on the $MOVR network. A $RMRK powered metaverse featuring battle simulations, equipables, and more!\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498896060,\n            \"category\":\"nfts\",\n            \"description\":\"\",\n            \"id\":\"neoncrisis-io\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/xp_network\",\n                \"website\":\"https://xp.network/\",\n                \"try\":\"https://xp.network/\",\n                \"twitter\":\"https://twitter.com/xpnetwork_\",\n                \"discord\":\"https://discord.com/invite/g3vkcsmd38\"\n            },\n            \"slug\":\"xp-network\",\n            \"createdAt\":1699292615205,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"xp-network-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"xp-network-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"xp-network-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"XP Network\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1673327644000,\n            \"shortDescription\":\"A powerful NFT bridge trusted by all major blockchains \",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498932103,\n            \"category\":\"nfts\",\n            \"description\":\"We build software tools that enable experienced developers and non-coding blockchain community members to move their assets seamlessly and intuitively between versatile distributed ledgers. By doing so, we encourage unlimited growth of exchange and trade between otherwise isolated ecosystems. We enable them to enrich each other technologically with insights and discoveries. To gain access to new, previously inaccessible markets with users hungry for fresh ideas and technologies to invest in.\",\n            \"id\":\"xp-network\",\n            \"tags\":[\n                \"NFT\",\n                \"Bridges\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://www.damnedpiratessociety.io/\",\n                \"try\":\"https://www.damnedpiratessociety.io/\",\n                \"twitter\":\"https://twitter.com/TheDPSproject\",\n                \"discord\":\"https://discord.com/invite/TheDamnedPiratesSociety\"\n            },\n            \"web3goContracts\":[\n                {\n                    \"name\":\"Damned Pirates Society: DPSArtifact Token\",\n                    \"chain\":\"moonriver\",\n                    \"contract\":\"0xcd84ddadc45a25b02e1a6a5520171487a98e6155\"\n                },\n                {\n                    \"name\":\"Damned Pirates Society: DPS Token\",\n                    \"chain\":\"moonriver\",\n                    \"contract\":\"0xb6e9e605aa159017173caa6181c522db455f6661\"\n                },\n                {\n                    \"name\":\"Damned Pirates Society: DSPFlagship Token\",\n                    \"chain\":\"moonriver\",\n                    \"contract\":\"0x3822063a3f1aad3fd0b894e2a8f238ccca7c2d00\"\n                },\n                {\n                    \"name\":\"Damned Pirates Society: DSPVoyage Token\",\n                    \"chain\":\"moonriver\",\n                    \"contract\":\"0x7b2e778453ab3a0d946c4620fb38a0530a434e15\"\n                },\n                {\n                    \"name\":\"Damned Pirates Society: DOUBLOON Token\",\n                    \"chain\":\"moonriver\",\n                    \"contract\":\"0xe413a631e8a9a10958d9b7c64157449eae7c2064\"\n                }\n            ],\n            \"currentTx\":{\n                \"moonriver\":20402\n            },\n            \"slug\":\"damned-pirates-society\",\n            \"web3goIDs\":[\n                \"Damned Pirates Society\"\n            ],\n            \"createdAt\":1699292616058,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"damned-pirates-society-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"damned-pirates-society-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"damned-pirates-society-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Damned Pirates Society\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"currentUsers\":{\n                \"moonriver\":2000\n            },\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"Eclectic pirate-based NFT project with utility\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722547421801,\n            \"category\":\"nfts\",\n            \"description\":\"A long time ago the Fortune\u2019s Grasp was carrying families to settle on The Islands and start a new life. In the middle of their voyage they encountered a fearsome maelstrom. The Captain and his crew worked tirelessly to keep the ship afloat. Badly damaged, the Ship limped to the edges of the storm. It was taking on water and the cries of terrified children could be heard above the crashing waves. Another ship appeared on the horizon, it\u2019s light glowing brightly against the dark night. The Captain of the Fortune\u2019s Grasp ordered his crew to evacuate the families, but the fifty crew members ignored the Captain, abandoning ship, taking all means of escape with them. The Captain, left on the sinking ship, cursed the cowardly crew for damning those innocent souls to the watery depths. Those Forsaken Fifty were marked with The Black Spot, doomed to row the high seas until the Reaper came to claim his mutinous crew to serve on the Ship Of The Damned. However, if they could convince another soul to take their place at the oars, protection would be offered by those Pirates who\u2019ve cheated the Reaper before. Those who\u2019ve served and survived are welcome in the Damned Pirates Society.\\r\\n\\r\\nThe Damned Pirate Society is an Profile Picture NFT with inbuilt utility. Stake your Pirate for Treasure Maps(TMAP) and save these for your Doubloon farming voyages on our upcoming, skill based gamified contracts.\",\n            \"id\":\"damned-pirates-society\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\",\n                \"GLMR Grants\"\n            ]\n        }\n    ],\n    \"count\":40\n}\n</code></pre> <p>Below are all possible categories and their respective parameters for querying the API. Ensure you query the API with the parameter formatted exactly as shown in lowercase.</p> Category API Parameter Bridges <code>bridges</code> DAO <code>dao</code> DEX <code>dex</code> DeFi <code>defi</code> Gaming <code>gaming</code> Lending <code>lending</code> NFTs <code>nfts</code> Other <code>other</code> Social <code>social</code> Wallets <code>wallets</code>"},{"location":"learn/dapp-directory/#query-a-chain","title":"Query a Chain","text":"<p>The following queries can be used to query all of the listed projects on Moonbeam or Moonriver. Note that Moonbase Alpha is not a supported network in the DApp Directory.</p> MoonbeamMoonriver <pre><code>https://apps.moonbeam.network/api/ds/v1/app-dir/projects?chain=moonbeam\n</code></pre> <pre><code>https://apps.moonbeam.network/api/ds/v1/app-dir/projects?chain=moonriver\n</code></pre>      You are responsible for checking and validating the accuracy and truthfulness of all content. You are also responsible for doing your own diligence to understand the applicable risks present, including selection, performance, security, accuracy, or use of any third-party information.  All information contained herein is subject to modification without notice."},{"location":"learn/core-concepts/balances/","title":"Moonbeam Account Balances","text":""},{"location":"learn/core-concepts/balances/#introduction","title":"Introduction","text":"<p>While Moonbeam strives to be compatible with Ethereum's Web3 API and EVM, there are some important Moonbeam differences that developers should know and understand in terms of account balances.</p> <p>One of the design goals of Moonbeam is to create an environment that is as close as possible to Ethereum, and to offer a set of Web3 RPC endpoints that are compatible with Ethereum. However, Moonbeam is also a Substrate based chain, which means that it exposes Substrate RPCs, and that it has integral functionality that is powered by Substrate such as Staking, Governance, and other features which are not part of the Ethereum API.</p> <p>Moonbeam unified accounts are one way that Moonbeam achieves Ethereum compatibility, by changing the underlying account type in the protocol to be Ethereum-like (H160 or 20 byte addresses starting with <code>0x</code>). Unified accounts are used by both the Substrate and Ethereum APIs, and map to the same underlying data storage on the blockchain. Nevertheless, there are important differences that users coming from Ethereum should understand when using Moonbeam accounts via the Ethereum API.</p> <p>This guide will outline some of these main differences and what to expect when using Moonbeam for the first time.</p>"},{"location":"learn/core-concepts/balances/#ethereum-account-balances","title":"Ethereum Account Balances","text":"<p>An account on Ethereum is an entity with a token balance (Ether or ETH in this case). Account-holders can send Ether transactions on Ethereum and accounts can be controlled by either users (with the private key for signing) or smart contracts.</p> <p>Therefore, Ethereum has two main types of accounts: user-owned and contract-owned. No matter the type, an Ethereum account has a single balance field that represents the number of Wei owned by this address, where Wei is a denomination of ETH (1 x 10^18 Wei per ETH).</p> <p></p>"},{"location":"learn/core-concepts/balances/#moonbeam-account-balances","title":"Moonbeam Account Balances","text":"<p>An account on Moonbeam is also an entity with a token balance (the token will depend on the network). Like on Ethereum, account holders can send token transactions on the Moonbeam Network they are connected to. In addition, accounts can be controlled by users (with the private key for signing) or smart contracts.</p> <p>As with Ethereum, there are two main types of accounts: user-owned and contract owned. However, on Moonbeam, within both account types, there are also proxy accounts, which can perform a limited number of actions on behalf of another account. In terms of balances, all of Moonbeam account types have five (5) different balance types:</p> <ul> <li>Free \u2014 refers to the balance that can be used (not locked/frozen) from the Substrate API. The concept of <code>free</code> balance depends on the action to be executed. For example, voting in democracy will not subtract the allocated balance to the vote from <code>free</code> balance, but token holders won't be able to transfer that balance</li> <li>Reducible \u2014 refers to the balance that can be used (not locked/frozen) through the Ethereum API on Moonbeam. For example, this is the balance displayed by MetaMask. It is the real spendable balance, accounting for all democracy locks (displayed as transferable in Polkadot.js Apps)</li> <li>Reserved \u2014 refers to the balance held due to on-chain requirements, and that can be freed by performing some on-chain action.  For example, bonds for creating a proxy account or setting an on-chain identity are shown as <code>reserved balance</code>. These funds are not transferable or accessible via the Ethereum API until they are freed</li> <li>Misc frozen \u2014 represents a balance that the <code>free</code> balance may not drop below when withdrawing funds, except for transaction fee payment. For example, funds being used to vote on a governance proposal are shown as <code>misc frozen</code>. These funds are not transferable or accessible via the Ethereum API until they are freed</li> <li>Fee frozen \u2014 represents a balance that the <code>free</code> balance may not drop below when specifically paying for transaction fees. These funds are not transferable or accessible via the Ethereum API until they are freed</li> </ul> <p></p>"},{"location":"learn/core-concepts/balances/#calculating-your-transferable-balance","title":"Calculating Your Transferable Balance","text":"<p>An account's transferable or spendable balance can be calculated as the free balance minus the maximum of <code>0</code> or the difference between frozen and reserved tokens: </p> <pre><code>Transferable = free - max(0, frozen - reserved )\n</code></pre> <p>Here are two examples of calculating transferable balances:</p> <p>An account has <code>1000</code> free tokens, <code>200</code> frozen tokens, and <code>50</code> reserved tokens. The transferable balance is calculated as:</p> <pre><code>Transferable = 1000 - max(0, 200 - 50) = 1000 - 150 = 850\n</code></pre> <p>If the frozen tokens are less than the reserved tokens, with <code>1000</code> free tokens, <code>100</code> frozen tokens, and <code>150</code> reserved tokens, the transferable balance would be:</p> <pre><code>Transferable = 1000 - max(0, 100 - 150) = 1000 - 0 = 1000\n</code></pre>"},{"location":"learn/core-concepts/balances/#retrieve-your-balance","title":"Retrieve Your Balance","text":"<p>You can check on your balances, including your free (or transferable) and reserved balances (if exists), using the Polkadot.js API.</p> <p>Note</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n\nconst main = async () =&gt; {\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n  });\n\n  const balances = await polkadotApi.query.system.account('INSERT_ADDRESS');\n  console.log(balances.toHuman());\n};\n\nmain();\n</code></pre> <p>You can also retrieve your balance locks using the Polkadot.js API.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n\nconst main = async () =&gt; {\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n  });\n\n  const locks = await polkadotApi.query.balances.locks('INSERT_ADDRESS');\n  console.log(locks.toHuman());\n};\n\nmain();\n</code></pre>"},{"location":"learn/core-concepts/balances/#main-differences","title":"Main Differences","text":"<p>The main difference between account balances on Ethereum and Moonbeam lies in the concept of locked and reserved balance on Moonbeam. These are tokens that are still owned by that account, but they are not spendable (yet).</p> <p>From the Ethereum's API perspective, an account might show that it has a certain balance (called <code>reducible</code> balance). However, after an on-chain action, this value might increase (or decrease) without an actual balance transfer.</p> <p>It is important to note that the account and behavior differences described here apply to account balances with the base asset (GLMR, MOVR) only and the balances of that asset that aren't interacting with smart contracts. As soon as a Moonbeam account balance is interacting with smart contracts, the behavior will be the same as Ethereum behavior. For example, if you wrap MOVR on Moonriver there is no way for the underlying balance to change via staking or governance actions, because that is part of the storage of the contract. In this case the reducible balance of that account has been committed to the wrapped MOVR smart contract and can't be modified by Substrate actions.</p>"},{"location":"learn/core-concepts/consensus-finality/","title":"Moonbeam Consensus &amp; Finality","text":""},{"location":"learn/core-concepts/consensus-finality/#introduction","title":"Introduction","text":"<p>While Moonbeam strives to be compatible with Ethereum's Web3 API and EVM, there are some important Moonbeam differences that developers should know and understand in terms of consensus and finality.</p> <p>In short, consensus is a way for different parties to agree on a shared state. As blocks are created, nodes in the network must decide which block will represent the next valid state. Finality defines when that valid state cannot be altered or reversed.</p> <p>Ethereum began by using a consensus protocol based on Proof-of-Work (PoW), which provides probabilistic finality. However, in 2022, Ethereum switched to Proof-of-Stake (PoS), which provides deterministic finality, and no longer uses PoW. In contrast, Moonbeam uses a hybrid consensus protocol based on Delegated Proof-of-Stake (DPoS), which also provides deterministic finality. DPoS is an evolution of Polkadot's Nominated Proof of Stake (NPoS) concept, that puts more power into the hands of token holders by allowing delegators to choose which collator candidate they want to support and in what magnitude.</p> <p>This guide will outline some of these main differences around consensus and finality, and what to expect when using Moonbeam for the first time.</p>"},{"location":"learn/core-concepts/consensus-finality/#ethereum-consensus-and-finality","title":"Ethereum Consensus and Finality","text":"<p>Ethereum currently uses a PoS consensus protocol, in which validators stake ETH in the network and are responsible for producing blocks and checking the validity of new blocks. The timing of block production is fixed and is divided into 12 second slots and 32 slot epochs. One validator per slot is randomly selected to produce a block and broadcast it to the network. There is a randomly selected committee of validators per slot that is responsible for determining the validity of the block. The greater the stake in the network, the greater the chance the validator will be chosen to produce or validate a block.</p> <p>Finality is deterministic in Ethereum's PoS consensus protocol and is achieved through \"checkpoint\" blocks. Validators agree on the state of a block at particular checkpoint blocks, which are always the first block in an epoch, and if two-thirds of the validators agree, the block is finalized. Block finality can be reverted; however, there are strong economic incentives in place so validators do not attempt to collude to revert a block. You can find out more information in Vitalik's On Settlement Finality blog, under the Finality in Casper section.</p>"},{"location":"learn/core-concepts/consensus-finality/#moonbeam-consensus-and-finality","title":"Moonbeam Consensus and Finality","text":"<p>In Polkadot, there are collators and validators. Collators maintain parachains (in this case, Moonbeam) by collecting transactions from users and producing state transition proofs for the relay chain validators. The collator set (nodes that produce blocks) is selected based on the stake they have in the network.</p> <p>For finality, Polkadot and Kusama rely on GRANDPA. GRANDPA provides deterministic finality for any given transaction (block). In other words, when a block or transaction is marked as final, it can't be reverted except via on-chain governance or forking. Moonbeam follows this deterministic finality.</p>"},{"location":"learn/core-concepts/consensus-finality/#main-differences","title":"Main Differences Between PoS and DPoS","text":"<p>In terms of consensus, Moonbeam is based on Delegated Proof-of-Stake, while Ethereum relies on a standard Proof-of-Stake system, which is slightly different. Although both mechanisms rely on the use of stake to validate and create new blocks, there are some key differences.</p> <p>With PoS on Ethereum, validators are selected to produce and validate blocks based on their own stake in the network. As long as a validator has placed a validator deposit, they can be selected to produce and validate blocks. However, as previously mentioned, the greater the stake in the network, the higher the chances a validator has to be selected to produce and validate blocks.</p> <p>On the other hand, with DPoS on Moonbeam, collators become eligible to produce blocks based on their own stake plus their delegated stake in the network. Any token holder can choose to delegate their stake to a collator candidate. The top collator candidates by stake, including delegations, join the active set. The number of candidates in the active set is subject to governance. Once in the active set, collators are randomly selected to produce blocks using the Nimbus Consensus Framework. It is important to note that once a collator is in the active set, their total stake does not impact their chances of being selected to produce blocks.</p> <p>In terms of finality, blocks on Ethereum can take quite a bit longer to finalize than on Moonbeam due to the checkpoint finality system it uses. In Ethereum, validators determine finality at checkpoint blocks, which are always the first block in an epoch. Since an epoch has 32 slots and each slot is 12 seconds, it'll take at least 384 seconds, or 6.4 minutes for a block to be finalized.</p> <p>Moonbeam does not use checkpoint blocks and instead relies on Polkadot's GRANDPA finality gadget, where the finality process is completed in parallel to block production. In addition, the finality process incorporates the blockchain's structure, which allows the relay chain validators to vote on the highest block that they think is valid. In this scenario, the vote would apply to all of the blocks leading up to the one that is finalized, which speeds up the finalization process. After a block has been included in the relay chain, a block can be finalized within one block on Moonbeam.</p>"},{"location":"learn/core-concepts/consensus-finality/#check-tx-finality-with-ethereum-rpc-endpoints","title":"Check Transaction Finality with Ethereum RPC Endpoints","text":"<p>Although the finality gadgets differ, you can use the same, fairly simple strategy to check for transaction finality on both Ethereum and Moonbeam:</p> <ol> <li>You ask the network for the hash of the latest finalized block</li> <li>You retrieve the block number using the hash</li> <li>You compare it with the block number of your transaction. If your transaction was included in a previous block, it is finalized</li> <li>As a safety check, retrieve the block by number and verify that the given transaction hash is in the block</li> </ol> <p>The snippets below follow this strategy to check transaction finality. It uses the <code>finalized</code> option for the default block parameter to get the latest finalized block.</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>Note</p> <p>The code snippets presented in the following sections are not meant for production environments. Please make sure you adapt it for each use-case.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TX_HASH';\n\n// Define the RPC of the provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT',\n    chainId: 1284,\n  }\n};\n\n// Define the Web3 provider\nconst web3Provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n\nconst main = async () =&gt; {\n  // Get the last finalized block\n  const finalizedBlockHeader = await web3Provider.getBlock('finalized');\n  const finalizedBlockNumber = finalizedBlockHeader.number;\n\n  // Get the transaction receipt of the given transaction hash\n  const txReceipt = await web3Provider.getTransactionReceipt(txHash);\n\n  // If block number of receipt is not null, compare it against finalized head\n  if (txReceipt) {\n    const txBlockNumber = txReceipt.blockNumber;\n\n    // As a safety check, get given block to check if transaction is included\n    const txBlock = await web3Provider.getBlock(txBlockNumber);\n\n    console.log(`Current finalized block number is ${finalizedBlockNumber}`);\n    console.log(\n      `Your transaction in block ${txBlockNumber} is finalized? ${\n        finalizedBlockNumber &gt;= txBlockNumber\n      }`\n    );\n    console.log(\n      `Your transaction is indeed in block ${txBlockNumber}? ${txBlock.transactions.includes(\n        txHash\n      )}`\n    );\n  } else {\n    console.log(\n      'Your transaction has not been included in the canonical chain'\n    );\n  }\n};\n\nmain();\n</code></pre> <pre><code>import { Web3 } from 'web3';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TX_HASH';\n\n// Define the Web3 provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst web3Provider = new Web3('INSERT_RPC_API_ENDPOINT');\n\nconst main = async () =&gt; {\n  // Get the last finalized block\n  const finalizedBlockHeader = await web3Provider.eth.getBlock('finalized');\n  const finalizedBlockNumber = finalizedBlockHeader.number;\n\n  // Get the transaction receipt of the given transaction hash\n  const txReceipt = await web3Provider.eth.getTransactionReceipt(txHash);\n\n  // If block number of receipt is not null, compare it against finalized head\n  if (txReceipt) {\n    const txBlockNumber = txReceipt.blockNumber;\n\n    // As a safety check, get given block to check if transaction is included\n    const txBlock = await web3Provider.eth.getBlock(txBlockNumber);\n\n    console.log(`Current finalized block number is ${finalizedBlockNumber}`);\n    console.log(\n      `Your transaction in block ${txBlockNumber} is finalized? ${\n        finalizedBlockNumber &gt;= txBlockNumber\n      }`\n    );\n    console.log(\n      `Your transaction is indeed in block ${txBlockNumber}? ${txBlock.transactions.includes(\n        txHash\n      )}`\n    );\n  } else {\n    console.log(\n      'Your transaction has not been included in the canonical chain'\n    );\n  }\n};\n\nmain();\n</code></pre> <pre><code>from web3 import Web3\n\n# Define the transaction hash to check finality\ntx_hash = \"INSERT_TX_HASH\"\n\n# Define the Web3 provider for Moonbeam\n# This can be adapted for Moonriver or Moonbase Alpha\nweb3_provider = Web3(Web3.HTTPProvider(\"INSERT_RPC_API_ENDPOINT\"))\n\nif __name__ == \"__main__\":\n    # Get the latest finalized block\n    finalized_block_header = web3_provider.eth.get_block(\"finalized\")\n    finalized_block_number = finalized_block_header.number\n\n    # Get the transaction receipt of the given transaction hash\n    tx_receipt = web3_provider.eth.get_transaction_receipt(tx_hash)\n\n    # If block number of receipt is not null, compare it against finalized head\n    if tx_receipt is not None:\n        tx_block_number = tx_receipt.blockNumber\n\n        # As a safety check, get given block to check if transaction is included\n        tx_block = web3_provider.eth.get_block(tx_block_number)\n        is_in_block = False\n        for tx in tx_block.transactions:\n            if tx_hash == web3_provider.to_hex(tx):\n                is_in_block = True\n\n        print(f\"Current finalized block number is { str(finalized_block_number) }\")\n        print(\n            f\"Your transaction in block { str(tx_block_number) } is finalized? { str(finalized_block_number &gt;= tx_block_number) }\"\n        )\n        print(\n            f\"Your transaction is indeed in block { str(tx_block_number) }? { is_in_block }\"\n        )\n    else:\n        print(\"Your transaction has not been included in the canonical chain\")\n</code></pre>"},{"location":"learn/core-concepts/consensus-finality/#check-tx-finality-with-moonbeam-rpc-endpoints","title":"Check Transaction Finality with Moonbeam RPC Endpoints","text":"<p>Moonbeam has added support for two custom RPC endpoints, <code>moon_isBlockFinalized</code> and <code>moon_isTxFinalized</code>, that can be used to check whether an on-chain event is finalized. These methods are a bit more straightforward, as you don't need to compare block numbers to ensure your transaction is finalized.</p> <p>For more information, you can go to the Finality RPC Endpoints section of the Moonbeam Custom API page.</p> <p>You can modify the scripts from the Ethereum RPC section above to use <code>moon_isBlockFinalized</code> and <code>moon_isTxFinalized</code>. To do this, you can make custom calls to the Substrate JSON-RPC using the <code>send</code> method of both Web3.js and Ethers.js. Custom RPC requests are also possible using Web3.py with the <code>make_request</code> method. You'll need to pass in the method name and the parameters to the custom request, which you can find on the Moonbeam Custom API page.</p> moon_isBlockFinalized Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers';\n\n// Define the block hash to check finality\nconst blockHash = 'INSERT_BLOCK_HASH';\n\n// Define the RPC of the provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT',\n    chainId: 1284,\n  },\n};\n\n// Define the Web3 provider\nconst web3Provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n\n// Define the function for the custom web3 request\nconst customWeb3Request = async (web3Provider, method, params) =&gt; {\n  try {\n    return await web3Provider.send(method, params);\n  } catch (error) {\n    throw new Error(error.body);\n  }\n};\n\nconst main = async () =&gt; {\n  // Check if the block has been finalized\n  const isFinalized = await customWeb3Request(\n    web3Provider,\n    'moon_isBlockFinalized',\n    [blockHash]\n  );\n  console.log(`Block is finalized? ${isFinalized}`);\n};\n\nmain();\n</code></pre> <pre><code>import { Web3 } from 'web3';\n\n// Define the block hash to check finality\nconst blockHash = 'INSERT_BLOCK_HASH';\n\n// Define the Web3 provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst web3Provider = new Web3('INSERT_RPC_API_ENDPOINT');\n\n// Define the function for the custom Web3 request\nconst customWeb3Request = async (web3Provider, method, params) =&gt; {\n  try {\n    return await requestPromise(web3Provider, method, params);\n  } catch (error) {\n    throw new Error(error);\n  }\n};\n\n// In Web3.js you need to return a promise\nconst requestPromise = async (web3Provider, method, params) =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    web3Provider.send(\n      {\n        jsonrpc: '2.0',\n        id: 1,\n        method,\n        params,\n      },\n      (error, result) =&gt; {\n        if (error) {\n          reject(error.message);\n        } else {\n          if (result.error) {\n            reject(result.error.message);\n          }\n          resolve(result);\n        }\n      }\n    );\n  });\n};\n\nconst main = async () =&gt; {\n  // Check if the block has been finalized\n  const isFinalized = await customWeb3Request(\n    web3Provider.currentProvider,\n    'moon_isBlockFinalized',\n    [blockHash]\n  );\n\n  console.log(JSON.stringify(isFinalized));\n  console.log(`Block is finalized? ${isFinalized.result}`);\n};\n\nmain();\n</code></pre> <pre><code>from web3 import Web3\n\n# Define the block hash to check finality\nblock_hash = 'INSERT_BLOCK_HASH'\n\n# Set the RPC_address for Moonbeam\n# This can also be adapted for Moonriver or Moonbase Alpha\nRPC_address = 'INSERT_RPC_API_ENDPOINT'\n\n# Define the Web3 provider\nweb3_provider = Web3(Web3.HTTPProvider(RPC_address))\n\n# Asynchronous JSON-RPC API request\ndef custom_web3_request(method, params):\n    response = web3_provider.provider.make_request(method, params)\n    return response\n\nif __name__ == \"__main__\":\n    # Check if the block has been finalized\n    is_finalized = custom_web3_request(\n       'moon_isBlockFinalized', [block_hash])\n    print(\n        f'Block is finalized? { is_finalized[\"result\"] }')\n</code></pre> moon_isTxFinalized Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TRANSACTION_HASH';\n\n// Define the RPC of the provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT',\n    chainId: 1284,\n  },\n};\n\n// Define the Web3 provider\nconst web3Provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n\n// Define the function for the custom web3 request\nconst customWeb3Request = async (web3Provider, method, params) =&gt; {\n  try {\n    return await web3Provider.send(method, params);\n  } catch (error) {\n    throw new Error(error.body);\n  }\n};\n\nconst main = async () =&gt; {\n  // Check if the transaction has been finalized\n  const isFinalized = await customWeb3Request(\n    web3Provider,\n    'moon_isTxFinalized',\n    [txHash]\n  );\n  console.log(`Transaction is finalized? ${isFinalized}`);\n};\n\nmain();\n</code></pre> <pre><code>import Web3 from 'web3';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TRANSACTION_HASH';\n\n// Define the Web3 provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst web3Provider = new Web3('INSERT_RPC_API_ENDPOINT');\n\n// Define the function for the custom Web3 request\nconst customWeb3Request = async (web3Provider, method, params) =&gt; {\n  try {\n    return await requestPromise(web3Provider, method, params);\n  } catch (error) {\n    throw new Error(error);\n  }\n};\n\n// In Web3.js you need to return a promise\nconst requestPromise = async (web3Provider, method, params) =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    web3Provider.send(\n      {\n        jsonrpc: '2.0',\n        id: 1,\n        method,\n        params,\n      },\n      (error, result) =&gt; {\n        if (error) {\n          reject(error.message);\n        } else {\n          if (result.error) {\n            reject(result.error.message);\n          }\n          resolve(result);\n        }\n      }\n    );\n  });\n};\n\nconst main = async () =&gt; {\n  // Check if the transaction has been finalized\n  const isFinalized = await customWeb3Request(\n    web3Provider.currentProvider,\n    'moon_isTxFinalized',\n    [txHash]\n  );\n\n  console.log(JSON.stringify(isFinalized));\n  console.log(`Transaction is finalized? ${isFinalized}`);\n};\n\nmain();\n</code></pre> <pre><code>from web3 import Web3\n\n# Define the transaction hash to check finality\ntx_hash = 'INSERT_BLOCK_HASH'\n\n# Set the RPC_address for Moonbeam\n# This can also be adapted for Moonriver or Moonbase Alpha\nRPC_address = 'INSERT_RPC_API_ENDPOINT'\n\n# Define the Web3 provider\nweb3_provider = Web3(Web3.HTTPProvider(RPC_address))\n\n# Asynchronous JSON-RPC API request\ndef custom_web3_request(method, params):\n    response = web3_provider.provider.make_request(method, params)\n    return response\n\nif __name__ == \"__main__\":\n    # Check if the transaction has been finalized\n    is_finalized = custom_web3_request(\n       'moon_isTxFinalized', [tx_hash])\n    print(\n        f'Transaction is finalized? { is_finalized[\"result\"] }')\n</code></pre>"},{"location":"learn/core-concepts/consensus-finality/#check-tx-finality-with-substrate-rpc-endpoints","title":"Check Transaction Finality with Substrate RPC Endpoints","text":"<p>Using the following three RPC requests from the Substrate JSON-RPC, you can fetch the current finalized block and compare it with the block number of the transaction you want to check finality for:</p> <ul> <li><code>chain_getFinalizedHead</code> - the first request gets the block hash of the last finalized block</li> <li><code>chain_getHeader</code> - the second request gets the block header for a given block hash</li> <li><code>eth_getTransactionReceipt</code> - this retrieves the transaction receipt given the transaction hash</li> </ul> <p>The Polkadot.js API package and Python Substrate Interface package provide developers with a way to interact with Substrate chains using JavaScript and Python.</p> <p>You can find more information about Polkadot.js and the Substrate JSON-RPC in the official Polkadot.js documentation site, and more about Python Substrate Interface in the official PySubstrate documentation site.</p> Polkadot.jspy-substrate-interface <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { types } from 'moonbeam-types-bundle';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TX_HASH';\n\n// Define the provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst wsProvider = new WsProvider('INSERT_WSS_API_ENDPOINT');\n\nconst main = async () =&gt; {\n  // Create the provider using Moonbeam types\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n    typesBundle: types,\n  });\n  await polkadotApi.isReady;\n\n  // Get the latest finalized block of the Substrate chain\n  const finalizedHeadHash = (\n    await polkadotApi.rpc.chain.getFinalizedHead()\n  ).toJSON();\n\n  // Get finalized block header to retrieve number\n  const finalizedBlockHeader = (\n    await polkadotApi.rpc.chain.getHeader(finalizedHeadHash)\n  ).toJSON();\n\n  // Get the transaction receipt of the given tx hash\n  const txReceipt = (\n    await polkadotApi.rpc.eth.getTransactionReceipt(txHash)\n  ).toJSON();\n\n  // You can not verify if the tx is in the block because polkadotApi.rpc.eth.getBlockByNumber\n  // does not return the list of tx hashes\n\n  // If block number of receipt is not null, compare it against finalized head\n  if (txReceipt) {\n    console.log(\n      `Current finalized block number is ${finalizedBlockHeader.number}`\n    );\n    console.log(\n      `Your transaction in block ${txReceipt.blockNumber} is finalized? ${\n        finalizedBlockHeader.number &gt;= txReceipt.blockNumber\n      }`\n    );\n  } else {\n    console.log(\n      'Your transaction has not been included in the canonical chain'\n    );\n  }\n\n  polkadotApi.disconnect();\n};\n\nmain();\n</code></pre> <pre><code>from substrateinterface import SubstrateInterface\n\n# Define the Ethereum transaction hash to check finality\ntx_hash = \"INSERT_TX_HASH\"\n\n# Point API provider to Moonbeam\n# This can be adapted for Moonriver or Moonbase Alpha\nmoonbeam_API_provider = SubstrateInterface(\n    url=\"INSERT_WSS_API_ENDPOINT\",\n)\n\nif __name__ == \"__main__\":\n    # Get the latest finalized block header of the chain\n    finalized_block_header = moonbeam_API_provider.get_block_header(finalized_only=True)\n    # Get the finalized block number from the block header\n    finalized_block_number = finalized_block_header[\"header\"][\"number\"]\n    # Get the transaction receipt of the given transaction hash through a\n    # custom RPC request\n    tx_receipt = moonbeam_API_provider.rpc_request(\n        \"eth_getTransactionReceipt\", [tx_hash]\n    )\n\n    # Check if tx_receipt is null\n    if tx_receipt is None:\n        print(\"The transaction hash cannot be found in the canonical chain.\")\n    else:\n        # Get the block number of the transaction\n        tx_block_number = int(tx_receipt[\"result\"][\"blockNumber\"], 16)\n        # Get the transaction block through a custom RPC request\n        tx_block = moonbeam_API_provider.rpc_request(\n            \"eth_getBlockByNumber\", [tx_block_number, False]\n        )\n\n        print(f\"Current finalized block number is { str(finalized_block_number) }\")\n        print(\n            f\"Your transaction in block { str(tx_block_number) } is finalized? { str(finalized_block_number &gt;= tx_block_number) }\"\n        )\n        print(\n            f'Your transaction is indeed in block { str(tx_block_number) }? { str(tx_hash in tx_block[\"result\"][\"transactions\"]) }'\n        )\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"learn/core-concepts/security/","title":"Security Considerations","text":""},{"location":"learn/core-concepts/security/#introduction","title":"Introduction","text":"<p>When developing smart contracts on Moonbeam, there are some security considerations to be aware of that do not apply when developing on Ethereum. Moonbeam has several precompiled contracts, which are Solidity interfaces that enable developers to access Substrate-based functionality through the Ethereum API, but circumventing the EVM. Although the precompiled contracts are designed to improve the developer experience, there can be some unintended consequences that must be considered.</p> <p>This guide will outline and provide examples of some security considerations to be cognizant of when developing on Moonbeam.</p>"},{"location":"learn/core-concepts/security/#arbitrary-code-execution","title":"Arbitrary Code Execution","text":"<p>Arbitrary code execution in Solidity is the ability to execute code and call functions of other contracts using an arbitrary number of arguments of any type.</p> <p>A smart contract allows arbitrary execution of another contract when it allows a user to influence its own <code>call()</code> and pass in arbitrary call data and/or the <code>call()</code>s target. The <code>call()</code> function is made available through the address data type in Solidity. When the <code>call()</code> function is invoked, the target contract is called using the arbitrary call data.</p> <p>Arbitrary code execution follows the pattern in the diagram below when Contract A allows a user to influence its call to Contract B.</p> <p></p> <p>As previously mentioned, one major concern of arbitrarily executing code on Moonbeam is that Moonbeam has precompile contracts that can be called, which can be used to get around some protections that are typically available on Ethereum. To safely use arbitrary code execution on Moonbeam, you should consider the following, which only applies to contracts that allow arbitrary code execution:</p> <ul> <li>Moonbeam precompiled contracts such as the Native ERC-20 precompile, XC-20 precompiles, and XCM-related precompiles allow users to manage and transfer assets without requiring access to the EVM. Instead, these actions are done using native Substrate code. So, if your contract holds native tokens or XC-20s and allows arbitrary code execution, these precompiles can be used to drain the balance of the contract, bypassing any security checks that are normally enforced by the EVM</li> <li>Setting the value attribute of the transaction object to a fixed amount when using the <code>call()</code> function (for example, <code>call{value: 0}(...)</code>) can be bypassed by calling the native asset precompile and specifying an amount to transfer in the encoded call data</li> <li>Allowing users that consume your contract to pass in arbitrary call data that will execute any function on the target contract, especially if the contract being targeted is a precompile, is not safe. To be safe, you can hard code the function selector for a safe function that you want to allow to be executed</li> <li>Blacklisting target contracts (including precompiles) in the function that executes arbitrary call data is not considered safe, as other precompiles might be added in the future. Providing whitelisted target contracts in the function that executes the arbitrary call data is considered safe, assuming that the contracts being called are not precompiles, or that in the case they are, the contract making the call does not hold the native token or any XC-20</li> </ul> <p>In the following sections, you'll learn about each of these security considerations through examples.</p>"},{"location":"learn/core-concepts/security/#setting-a-value","title":"Precompiles Can Override a Set Value","text":"<p>On Ethereum, a smart contract that allows for arbitrary code execution could force the value of a call to be a specific amount (for example, <code>{value: 0}</code>), guaranteeing that only that amount of native currency would be sent with the transaction. Whereas on Moonbeam, the native ERC-20 precompile contract enables you to interact with the native currency on Moonbeam as an ERC-20 through the Substrate API. As a result, you can transfer the Moonbeam native asset from a smart contract by setting the <code>value</code> of a call, as well as through the native ERC-20 precompile. If you set the <code>value</code> of an arbitrary call, it can be overridden by targeting the native ERC-20 precompile contract and passing in call data to transfer the native asset. Since ERC-20s and XC-20s are not native assets, setting the value attribute doesn't provide any protection for these types of assets on Ethereum or Moonbeam.</p> <p>For example, if you have a contract that allows arbitrary code execution and you pass it encoded call data that transfers the balance of a contract to another address, you could essentially drain the given contract of its balance.</p> <p>To get the encoded call data, you can use any of the ABI encoding functions outlined in the Solidity docs, including <code>abi.encodeWithSelector</code> as seen in the following function:</p> <pre><code>function getBytes(address _erc20Contract, address _arbitraryCallContract, address _to) public view returns (bytes memory) {\n    // Load ERC-20 interface of contract\n    IERC20 erc20 = IERC20(_erc20Contract);\n    // Get amount to transfer\n    uint256 amount = erc20.balanceOf(_arbitraryCallContract);\n    // Build the encoded call data\n    return abi.encodeWithSelector(IERC20.transfer.selector, _to, amount);\n}\n</code></pre> <p>Once you have the encoded call data, you could make an arbitrary call to the native ERC-20 precompile contract, set the value of the call to <code>0</code>, and pass in the call data in bytes:</p> <pre><code>function makeArbitraryCall(address _target, bytes calldata _bytes) public {\n    // Value: 0 does not protect against native ERC-20 precompile calls or XCM precompiles\n    (bool success,) = _target.call{value: 0}(_bytes);\n    require(success);\n}\n</code></pre> <p>The value of <code>0</code> will be overridden by the amount to be transferred as specified in the encoded call data, which in this example is the balance of the contract.</p>"},{"location":"learn/core-concepts/security/#whitelisting-function-selectors","title":"Whitelisting Safe Function Selectors","text":"<p>By whitelisting a specific function selector, you can control what functions can be executed and ensure only functions that are considered safe and do not call precompiles are allowed to be called.</p> <p>To get the function selector to whitelist, you can keccack256 hash the signature of the function.</p> <p>Once you have the whitelisted function selector, you can use inline assembly to get the function selector from the encoded call data and compare the two selectors using the require function. If the function selector from the encoded call data matches the whitelisted function selector, you can make the call. Otherwise, an exception will be thrown.</p> <pre><code>function makeArbitraryCall(address _target, bytes calldata _bytes) public {\n    // Get the function selector from the encoded call data\n    bytes4 selector;\n    assembly {\n        selector := calldataload(_bytes.offset)\n    }\n\n    // Ensure the call data calls an approved and safe function\n    require(selector == INSERT_WHITELISTED_FUNCTION_SELECTOR);\n\n    // Arbitrary call\n    (bool success,) = _target.call(_bytes);\n    require(success);\n}\n</code></pre>"},{"location":"learn/core-concepts/security/#whitelisting-safe-contracts","title":"Whitelisting Safe Contracts","text":"<p>By whitelisting a specific target contract address in the function that can execute arbitrary call data, you can ensure that the call is considered safe, as the EVM will enforce that only whitelisted contracts can be called. This assumes that the contracts being called are not precompiles. If they are precompiles, you'll want to make sure that the contract making the call does not hold the native token or any XC-20.</p> <p>Blacklisting contracts from arbitrary code execution is not considered safe, as other precompiles might be added in the future.</p> <p>To whitelist a given contract, you can use the require function, which will compare the target contract address to the whitelisted contract address. If the addresses match, the call can be executed. Otherwise, an exception will be thrown.</p> <pre><code>function makeArbitraryCall(address _target, bytes calldata _bytes) public {\n    // Ensure the contract address is safe\n    require(_target == INSERT_CONTRACT_ADDRESS);\n\n    // Arbitrary call\n    (bool success,) = _target.call(_bytes);\n    require(success);\n}\n</code></pre>"},{"location":"learn/core-concepts/security/#bypass-sender-origin-checks","title":"Precompiles Can Bypass Sender vs Origin Checks","text":"<p>The transaction origin, or <code>tx.origin</code>, is the address of the externally owned account (EOA) the transaction originated from. Whereas the <code>msg.sender</code> is the address that has initiated the current call. The <code>msg.sender</code> can be an EOA or a contract. The two can be different values if one contract calls another contract, as opposed to directly calling a contract from an EOA. In this case, the <code>msg.sender</code> will be the calling contract and the <code>tx.origin</code> will be the EOA that initially called the calling contract.</p> <p>For example, if Alice calls a function in contract A that then calls a function in contract B, when looking at the call to contract B, the <code>tx.origin</code> is Alice and the <code>msg.sender</code> is contract A.</p> <p>Note</p> <p>As a best practice, <code>tx.origin</code> should not be used for authorization. Instead, you should use <code>msg.sender</code>.</p> <p>You can use the require function to compare the <code>tx.origin</code> and <code>msg.sender</code>. If they are the same address, you're ensuring that only EOAs can call the function. If the <code>msg.sender</code> is a contract address, an exception will be thrown.</p> <pre><code>function transferFunds(address payable _target) payable public {\n    require(tx.origin == msg.sender);\n    _target.call{value: msg.value};\n}\n</code></pre> <p>On Ethereum, you can use this check to ensure that a given contract function can only be called once by an EOA. This is because on Ethereum, EOAs can only interact with a contract once per transaction. However, this is not the case on Moonbeam, as EOAs can interact with a contract multiple times at once by using precompiled contracts, such as the batch and call permit precompiles.</p> <p>With the batch precompile, users can perform multiple calls to a contract atomically. The caller of the batch function will be the <code>msg.sender</code> and <code>tx.origin</code>, enabling multiple contract interactions at once.</p> <p>With the call permit precompile, if a user wants to interact with a contract multiple times in one transaction, they can do so by signing a permit for each contract interaction and dispatching all of the permits in a single function call. This will only bypass the <code>tx.origin == msg.sender</code> check if the dispatcher is the same account as the permit signer. Otherwise, the <code>msg.sender</code> will be the permit signer and the <code>tx.origin</code> will be the dispatcher, causing an exception to be thrown.</p>"},{"location":"learn/core-concepts/transfers-api/","title":"Balance Transfers on Moonbeam","text":""},{"location":"learn/core-concepts/transfers-api/#introduction","title":"Introduction","text":"<p>While Moonbeam strives to be compatible with Ethereum's Web3 API and EVM, there are some important Moonbeam differences that developers should know and understand in terms of balance transfers of the base network token (for example, GLMR and MOVR).</p> <p>Token holders have two ways of initiating a balance transfer on Moonbeam. On the one hand, users can use the Ethereum API via apps like MetaMask, MathWallet, or any other tools that use the Ethereum JSON-RPC. On the other hand, users can use the Substrate API via the Polkadot.js Apps website or directly using the Substrate RPC.</p> <p>Developers need to be aware that token holders can leverage both APIs to transfer the base-layer network token. Note that these comments do not apply to transfers of other assets, like ERC-20 based assets in the Moonriver or Moonbeam EVMs. Transfers of these assets are only done via the Ethereum APIs since these are smart contract interactions.</p> <p>This guide will outline some of the main differences between both APIs for base-layer network token balance transfers and what to expect when using Moonbeam for the first time.</p>"},{"location":"learn/core-concepts/transfers-api/#ethereum-transfers","title":"Ethereum Transfers","text":"<p>A simple balance transfer using the Ethereum API relies on the <code>eth_sendRawTransaction</code> JSON-RPC. This can be done directly from one account to another or via a smart contract.</p> <p>There are different strategies to listen for transfers or balance changes on Ethereum, which are not covered in this documentation. But they are all focused on different strategies using the Ethereum JSON-RPC.</p>"},{"location":"learn/core-concepts/transfers-api/#moonbeam-transfers","title":"Moonbeam Transfers","text":"<p>As stated before, Moonbeam enables token holders to execute base-layer network token transfers via both the Ethereum and Substrate API. There are multiple scenarios to trigger token transfers on Moonbeam. Consequently, to monitor all transfers, you should use the Polkadot.js SDK (Substrate API).</p> <p>Before going over the different scenarios, there are two different elements associated with a block:</p> <ul> <li>Extrinsic \u2014 refers to state changes that originated outside of the system itself. The most common form of extrinsic is a transaction. They are ordered by execution</li> <li>Events \u2014 refers to logs generated from the extrinsic. There can be multiple events per extrinsic. They are ordered by execution</li> </ul> <p>The different transfer scenarios are:</p> <ul> <li>Substrate transfer \u2014 it will create an extrinsic, either <code>balances.transferAllowDeath</code> or <code>balances.transferKeepAlive</code>. It will trigger one <code>balances.Transfer</code> event</li> <li>Substrate feature \u2014 some native Substrate features can create extrinsic that would send tokens to an address. For example, Treasury can create an extrinsic such as <code>treasury.proposeSend</code>, which will trigger one or multiple <code>balances.Transfer</code> events</li> <li>Ethereum transfer \u2014 it will create an <code>ethereum.transact</code> extrinsic with an empty input. It will trigger one <code>balances.Transfer</code> event</li> <li>Ethereum transfers via smart contracts \u2014 it will create an <code>ethereum.transact</code> extrinsic with some data as input. It will trigger one or multiple <code>balances.Transfer</code> events</li> </ul> <p>All the scenarios described above will effectively transfer base-layer network tokens. The easiest way to monitor them all is to rely on the <code>balances.Transfer</code> event.</p>"},{"location":"learn/core-concepts/transfers-api/#monitor-transfers","title":"Monitor Native Token Balance Transfers","text":"<p>The following code samples will demonstrate how to listen to both types of native token transfers, sent via the Substrate or Ethereum API, using either the Polkadot.js API library or Substrate API Sidecar. The following code snippets are for demo purposes only and should not be used without modification and further testing in a production environment.</p>"},{"location":"learn/core-concepts/transfers-api/#using-polkadotjs-api","title":"Using Polkadot.js API","text":"<p>The Polkadot.js API package provides developers a way to interact with Substrate chains using JavaScript.</p> <p>The following code snippet uses <code>subscribeFinalizedHeads</code> to subscribe to new finalized block headers, loops through extrinsics fetched from the block, and retrieves the events of each extrinsic. Then, it checks if any event corresponds to a <code>balances.Transfer</code> event. If so, it will extract the <code>from</code>, <code>to</code>, <code>amount</code>, and the <code>tx hash</code> of the transfer and display it on the console. Note that the <code>amount</code> is shown in the smallest unit (Wei).  You can find all the available information about Polkadot.js and the Substrate JSON-RPC on their official documentation site.</p> <pre><code>import { typesBundlePre900 } from 'moonbeam-types-bundle';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\n// This script will listen to all GLMR transfers (Substrate &amp; Ethereum) and extract the tx hash\n// It can be adapted for Moonriver or Moonbase Alpha\n\nconst main = async () =&gt; {\n  // Define the provider for Moonbeam\n  const wsProvider = new WsProvider('wss://wss.api.moonbeam.network');\n  // Create the provider using Moonbeam types\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n    typesBundle: typesBundlePre900 as any,\n  });\n\n  // Subscribe to finalized blocks\n  await polkadotApi.rpc.chain.subscribeFinalizedHeads(\n    async (lastFinalizedHeader) =&gt; {\n      const [{ block }, records] = await Promise.all([\n        polkadotApi.rpc.chain.getBlock(lastFinalizedHeader.hash),\n        polkadotApi.query.system.events.at(lastFinalizedHeader.hash),\n      ]);\n\n      block.extrinsics.forEach((extrinsic, index) =&gt; {\n        const {\n          method: { args, method, section },\n        } = extrinsic;\n\n        const isEthereum = section == 'ethereum' &amp;&amp; method == 'transact';\n\n        // Gets the transaction object\n        const tx = args[0] as any;\n\n        // Convert to the correct Ethereum Transaction format\n        const ethereumTx =\n          isEthereum &amp;&amp;\n          ((tx.isLegacy &amp;&amp; tx.asLegacy) ||\n            (tx.isEip1559 &amp;&amp; tx.asEip1559) ||\n            (tx.isEip2930 &amp;&amp; tx.asEip2930));\n\n        // Check if the transaction is a transfer\n        const isEthereumTransfer =\n          ethereumTx &amp;&amp;\n          ethereumTx.input.length === 0 &amp;&amp;\n          ethereumTx.action.isCall;\n\n        // Retrieve all events for this extrinsic\n        const events = records.filter(\n          ({ phase }) =&gt;\n            phase.isApplyExtrinsic &amp;&amp; phase.asApplyExtrinsic.eq(index)\n        );\n\n        // This hash will only exist if the transaction was executed through Ethereum.\n        let ethereumHash = '';\n\n        if (isEthereum) {\n          // Search for Ethereum execution\n          events.forEach(({ event }) =&gt; {\n            if (event.section == 'ethereum' &amp;&amp; event.method == 'Executed') {\n              ethereumHash = event.data[2].toString();\n            }\n          });\n        }\n\n        // Search if it is a transfer\n        events.forEach(({ event }) =&gt; {\n          if (event.section == 'balances' &amp;&amp; event.method == 'Transfer') {\n            const from = event.data[0].toString();\n            const to = event.data[1].toString();\n            const balance = (event.data[2] as any).toBigInt();\n\n            const substrateHash = extrinsic.hash.toString();\n\n            console.log(\n              `Transfer from ${from} to ${to} of ${balance} (block #${lastFinalizedHeader.number})`\n            );\n            console.log(`  - Triggered by extrinsic: ${substrateHash}`);\n            if (isEthereum) {\n              console.log(\n                `  - Ethereum (isTransfer: ${isEthereumTransfer}) hash: ${ethereumHash}`\n              );\n            }\n          }\n        });\n      });\n    }\n  );\n};\n\nmain();\n</code></pre> <p>In addition, you can find more sample code snippets related to more specific cases around balance transfers on this GitHub page.</p>"},{"location":"learn/core-concepts/transfers-api/#using-substrate-api-sidecar","title":"Using Substrate API Sidecar","text":"<p>Developers can also retrieve Moonbeam blocks and monitor transactions sent via both the Substrate and Ethereum APIs using Substrate API Sidecar, a REST API service for interacting with blockchains built with the Substrate framework.</p> <p>The following code snippet uses the Axios HTTP client to query the Sidecar endpoint <code>/blocks/head</code> for the latest finalized block and then decodes the block for the <code>from</code>, <code>to</code>, <code>value</code>, <code>tx hash</code>, and <code>transaction status</code> of native token transfers at both the EVM and Substrate API level.</p> <pre><code>import axios from 'axios';\n\n// This script will decode all native token transfers (Substrate &amp; Ethereum) in a given Sidecar block, and extract the tx hash. It can be adapted for any Moonbeam network.\n\n// Endpoint to retrieve the latest block\nconst endpoint = 'http://127.0.0.1:8080/blocks/head';\n\nasync function main() {\n  try {\n    // Retrieve the block from the Sidecar endpoint\n    const response = await axios.get(endpoint);\n    // Retrieve the block height of the current block\n    console.log('Block Height: ' + response.data.number);\n\n    // Iterate through all extrinsics in the block\n    response.data.extrinsics.forEach((extrinsic) =&gt; {\n      // Retrieve Ethereum Transfers\n      if (\n        extrinsic.method.pallet === 'ethereum' &amp;&amp;\n        extrinsic.method.method === 'transact'\n      ) {\n        // Get the value for any of the three EIP transaction standards supported\n        const value =\n          (extrinsic.args.transaction.legacy &amp;&amp;\n            extrinsic.args.transaction.legacy.value) ||\n          (extrinsic.args.transaction.eip1559 &amp;&amp;\n            extrinsic.args.transaction.eip1559.value) ||\n          (extrinsic.args.transaction.eip2930 &amp;&amp;\n            extrinsic.args.transaction.eip2930.value);\n\n        // Iterate through the events to get transaction details\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'ethereum' &amp;&amp;\n            event.method.method === 'Executed'\n          ) {\n            console.log('From: ' + event.data[0]);\n            console.log('To: ' + event.data[1]);\n            console.log('Tx Hash: ' + event.data[2]);\n            console.log('Value: ' + value);\n            // Check the execution status\n            if (event.data[3].succeed) {\n              console.log('Status: Success');\n            } else {\n              console.log('Status: Failed');\n            }\n          }\n        });\n      }\n\n      // Retrieve Substrate Transfers\n      if (\n        extrinsic.method.pallet === 'balances' &amp;&amp;\n        (extrinsic.method.method === 'transferKeepAlive' ||\n          extrinsic.method.method === 'transferAllowDeath')\n      ) {\n        // Iterate through the events to get transaction details\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'balances' &amp;&amp;\n            event.method.method === 'Transfer'\n          ) {\n            console.log('From: ' + event.data[0]);\n            console.log('To: ' + event.data[1]);\n            console.log('Tx Hash: ' + extrinsic.hash);\n            console.log('Value: ' + event.data[2]);\n            // Check the execution status\n            if (extrinsic.success) {\n              console.log('Status: Success');\n            } else {\n              console.log('Status: Failed');\n            }\n          }\n        });\n      }\n    });\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nmain();\n</code></pre> <p>You can reference the Substrate API Sidecar page for information on installing and running your own Sidecar service instance, as well as more details on how to decode Sidecar blocks for Moonbeam transactions.</p>"},{"location":"learn/core-concepts/tx-fees/","title":"Calculating Transaction Fees on Moonbeam","text":""},{"location":"learn/core-concepts/tx-fees/#introduction","title":"Introduction","text":"<p>Similar to the Ethereum and Substrate APIs for sending transfers on Moonbeam, the Substrate and EVM layers on Moonbeam also have distinct transaction fee models that developers should be aware of when they need to calculate and keep track of transaction fees for their transactions.</p> <p>For starters, Ethereum transactions consume gas units based on their computational complexity and data storage requirements. On the other hand, Substrate transactions use the concept of \"weight\" to determine fees. In this guide, you'll learn how to calculate the transaction fees for both Substrate and Ethereum transactions. In terms of Ethereum transactions, you'll also learn about the key differences between how transaction fees are calculated on Moonbeam and Ethereum.</p>"},{"location":"learn/core-concepts/tx-fees/#key-differences-with-ethereum","title":"Key Differences with Ethereum","text":"<p>There are some key differences between the transaction fee model on Moonbeam and the one on Ethereum that developers should be mindful of when developing on Moonbeam:</p> <ul> <li> <p>The dynamic fee mechanism resembles that of EIP-1559 but the implementation is different</p> </li> <li> <p>The amount of gas used in Moonbeam's transaction fee model is mapped from the transaction's Substrate extrinsic <code>refTime</code> component of the transaction weight via a fixed factor of <code>25000</code> and <code>proofSize</code> component of the transaction weight via a fixed factor of <code>8</code>. The transaction weight vector is then multiplied with the unit gas price to calculate the transaction fee. This fee model means it can potentially be significantly cheaper to send transactions such as basic balance transfers via the Ethereum API than the Substrate API.</p> </li> <li> <p>The EVM is designed to solely have capacity for gas and Moonbeam requires additional metrics outside of gas. In particular, Moonbeam needs the ability to record proof size, which is the amount of storage required on Moonbeam for a relay chain validator to verify a state transition. When the capacity limit for proof size has been reached for the current block, which is 25% of the block limit, an \"Out of Gas\" error will be thrown. This can happen even if there is remaining legacy gas in the gasometer. This additional metric also impacts refunds. Refunds are based on the more consumed resource after the execution. In other words, if more proof size has been consumed proportionally than legacy gas, the refund will be calculated using proof size</p> </li> <li> <p>Moonbeam has implemented a new mechanism defined in MBIP-5 that limits block storage and increases gas usage for transactions that result in an increase in storage</p> </li> </ul>"},{"location":"learn/core-concepts/tx-fees/#overview-of-mbip-5","title":"Overview of MBIP-5","text":"<p>MBIP-5 introduced changes to Moonbeam's fee mechanism that account for storage growth on the network, which deviates from the way Ethereum handles fees. By raising the gas needed to execute transactions that increase chain state and by establishing a block storage limit, it controls storage growth.</p> <p>This impacts contract deployments that add to the chain state, transactions that create new storage entries, and precompiled contract calls that result in the creation of new accounts.</p> <p>The block storage limit prevents transactions in a single block from collectively increasing the storage state by more than the limit. The limit for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>160KB\n</code></pre> <pre><code>160KB\n</code></pre> <pre><code>160KB\n</code></pre> <p>To determine the amount of gas for storage in bytes, there is a ratio that is defined as:</p> <pre><code>Ratio = Block Gas Limit / (Block Storage Limit * 1024 Bytes)\n</code></pre> <p>The block gas limit for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>60,000,000\n</code></pre> <pre><code>60,000,000\n</code></pre> <pre><code>60,000,000\n</code></pre> <p>Knowing the block gas and storage limits, the ratio of gas to storage is computed as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>Ratio = 60000000 / (160 * 1024)\nRatio = 366 \n</code></pre> <pre><code>Ratio = 60000000 / (160 * 1024)\nRatio = 366 \n</code></pre> <pre><code>Ratio = 60000000 / (160 * 1024)\nRatio = 366 \n</code></pre> <p>Then, you can take the storage growth in bytes for a given transaction and multiply it by the gas-to-storage growth ratio to determine how many units of gas to add to the transaction. For example, if you execute a transaction that increases the storage by 500 bytes, the following calculation is used to determine the units of gas to add:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>Additional Gas = 500 * 366\nAdditional Gas = 183000\n</code></pre> <pre><code>Additional Gas = 500 * 366\nAdditional Gas = 183000\n</code></pre> <pre><code>Additional Gas = 500 * 366\nAdditional Gas = 183000\n</code></pre> <p>To see how this MBIP differentiates Moonbeam from Ethereum firsthand, you can estimate the gas for two different contract interactions on both networks: one that modifies an item in the chain state and one that doesn't. For example, you can use a greeting contract that allows you to store a name and then use the name to say \"Hello\".</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SayHello {\n    mapping(address =&gt; string) public addressToName;\n\n    constructor(string memory _name) {\n        addressToName[msg.sender] = _name;\n    }\n\n    // Store a name associated to the address of the sender\n    function setName(string memory _name) public {\n        addressToName[msg.sender] = _name;\n    } \n\n    // Use the name in storage associated to the sender\n    function sayHello() external view returns (string memory) {\n        return string(abi.encodePacked(\"Hello \", addressToName[msg.sender]));\n    }\n}\n</code></pre> <p>You can deploy this contract on both Moonriver and Ethereum, or on Moonbeam's TestNet, Moonbase Alpha, and Ethereum's TestNet, Sepolia. The above contract has already been deployed to Moonbase Alpha and Sepolia. You can feel free to access these contracts at the following addresses:</p> Moonbase AlphaSepolia <pre><code>0xDFF8E772A9B212dc4FbA19fa650B440C5c7fd7fd\n</code></pre> <pre><code>0x8D0C059d191011E90b963156569A8299d7fE777d\n</code></pre> <p>Next, you can use the <code>eth_estimateGas</code> method to check the gas estimate for calling the <code>setName</code> and <code>sayHello</code> functions on each network. To do so, you'll need the bytecode for each transaction, which includes the function selector, and for the <code>setName</code> function, the name to be set. This example bytecode sets the name to \"Chloe\":</p> Set NameSay Hello <pre><code>0xc47f00270000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000543686c6f65000000000000000000000000000000000000000000000000000000\n</code></pre> <pre><code>0xef5fb05b\n</code></pre> <p>Now, you can use the following curl commands on Moonbase Alpha to return the gas estimate:</p> Set NameSay Hello <pre><code>curl https://rpc.api.moonbase.moonbeam.network -H \"Content-Type:application/json;charset=utf-8\" -d \\\n'{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"eth_estimateGas\",\n    \"params\":[{\n        \"to\": \"0xDFF8E772A9B212dc4FbA19fa650B440C5c7fd7fd\",\n        \"data\": \"0xc47f00270000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000543686c6f65000000000000000000000000000000000000000000000000000000\"\n    }]\n}'\n</code></pre> <pre><code>curl https://rpc.api.moonbase.moonbeam.network -H \"Content-Type:application/json;charset=utf-8\" -d \\\n'{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"eth_estimateGas\",\n    \"params\":[{\n        \"to\": \"0xDFF8E772A9B212dc4FbA19fa650B440C5c7fd7fd\",\n        \"data\": \"0xef5fb05b\"\n    }]\n}'\n</code></pre> <p>Then on Sepolia, you can use the same bytecode for the <code>data</code> and modify the RPC URL and contract address to target the contract deployed to Sepolia:</p> Set NameSay Hello <pre><code>curl https://sepolia.publicgoods.network -H \"Content-Type:application/json;charset=utf-8\" -d \\\n'{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"eth_estimateGas\",\n    \"params\":[{\n        \"to\": \"0x8D0C059d191011E90b963156569A8299d7fE777d\",\n        \"data\": \"0xc47f00270000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000543686c6f65000000000000000000000000000000000000000000000000000000\"\n    }]\n}'\n</code></pre> <pre><code>curl https://sepolia.publicgoods.network -H \"Content-Type:application/json;charset=utf-8\" -d \\\n'{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"eth_estimateGas\",\n    \"params\":[{\n        \"to\": \"0x8D0C059d191011E90b963156569A8299d7fE777d\",\n        \"data\": \"0xef5fb05b\"\n    }]\n}'\n</code></pre> <p>At the time of writing, the gas estimates for both networks are as follows:</p> Moonbase AlphaSepolia Method Gas Estimate <code>setName</code> 45977 <code>sayHello</code> 25938 Method Gas Estimate <code>setName</code> 21520 <code>sayHello</code> 21064 <p>You'll see that on Sepolia, the gas estimates for both calls are very similar, whereas on Moonbase Alpha, there is a noticeable difference between the calls and that the <code>setName</code> call, which modifies the storage, uses more gas than the <code>sayHello</code> call.</p>"},{"location":"learn/core-concepts/tx-fees/#ethereum-api-transaction-fees","title":"Ethereum API Transaction Fees","text":"<p>To calculate the fee incurred on a Moonbeam transaction sent via the Ethereum API, the following formula can be used:</p> EIP-1559LegacyEIP-2930 <pre><code>GasPrice = BaseFee + MaxPriorityFeePerGas &lt; MaxFeePerGas ? \n            BaseFee + MaxPriorityFeePerGas : \n            MaxFeePerGas;\nTransaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <pre><code>Transaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <pre><code>Transaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <p>Note</p> <p>EIP-1559 transaction fees on Moonbeam are calculated using the previous block's base fee.</p> <p>The following sections describe in more detail each of the components needed to calculate the transaction fee.</p>"},{"location":"learn/core-concepts/tx-fees/#base-fee","title":"Base Fee","text":"<p>The <code>BaseFee</code> is the minimum amount charged to send a transaction and is a value set by the network itself. It was introduced in EIP-1559. Moonbeam has its own dynamic fee mechanism for calculating the base fee, which is adjusted based on block congestion. As of runtime 2300, the dynamic fee mechanism has been rolled out to all of the Moonbeam-based networks.</p> <p>The minimum gas price for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Minimum Gas Price 31.25 Gwei Variable Value Minimum Gas Price 0.3125 Gwei Variable Value Minimum Gas Price 0.03125 Gwei <p>To calculate the dynamic base fee, the following calculation is used:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>BaseFee = NextFeeMultiplier * 31250000000 / 10^18\n</code></pre> <pre><code>BaseFee = NextFeeMultiplier * 312500000 / 10^18\n</code></pre> <pre><code>BaseFee = NextFeeMultiplier * 31250000 / 10^18\n</code></pre> <p>The value of <code>NextFeeMultiplier</code> can be retrieved from the Substrate Sidecar API, via the following endpoint:</p> <pre><code>GET /pallets/transaction-payment/storage/nextFeeMultiplier?at={blockId}\n</code></pre> <p>The pallets endpoints for Sidecar returns data relevant to a pallet, such as data in a pallet's storage. You can read more about the pallets endpoint in the official Sidecar documentation. The data at hand that's required from storage is the <code>nextFeeMultiplier</code>, which can be found in the <code>transaction-payment</code> pallet. The stored <code>nextFeeMultiplier</code> value can be read directly from the Sidecar storage schema. Read as a JSON object, the relevant nesting structure is as follows:</p> <pre><code>RESPONSE JSON Storage Object:\n    |--at\n        |--hash\n        |--height\n    |--pallet\n    |--palletIndex\n    |--storageItem\n    |--keys\n    |--value\n</code></pre> <p>The relevant data will be stored in the <code>value</code> key of the JSON object. This value is a fixed point data type, hence the real value is found by dividing the <code>value</code> by <code>10^18</code>. This is why the calculation of <code>BaseFee</code> includes such an operation.</p>"},{"location":"learn/core-concepts/tx-fees/#gasprice-maxfeepergas-maxpriorityfeepergas","title":"GasPrice, MaxFeePerGas, and MaxPriorityFeePerGas","text":"<p>The <code>GasPrice</code> is used to specify the gas price of legacy transactions prior to EIP-1559. The <code>MaxFeePerGas</code> and <code>MaxPriorityFeePerGas</code> were both introduced in EIP-1559 alongside the <code>BaseFee</code>. The <code>MaxFeePerGas</code> defines the maximum fee permitted to be paid per unit of gas and is the sum of the <code>BaseFee</code> and the <code>MaxPriorityFeePerGas</code>. The <code>MaxPriorityFeePerGas</code> is the maximum priority fee configured by the sender of a transaction that is used to incentivize the prioritization of a transaction in a block.</p> <p>Although Moonbeam is Ethereum-compatible, it is also a Substrate-based chain at its core, and priorities work differently in Substrate than in Ethereum. In Substrate, transactions are not prioritized by gas price. To address this, Moonbeam uses a modified prioritization system that reprioritizes Substrate transactions using an Ethereum-first solution. A Substrate transaction still goes through the validity process, where it is assigned transaction tags, longevity, and a priority. The original priority is then overwritten with a new priority based on the transaction's fee per gas, which is derived from the transaction's tip and weight. If the transaction is an Ethereum transaction, the priority is set according to the priority fee.</p> <p>It's important to note that priority is not the sole component responsible for determining the order of transactions in a block. Other components, such as the longevity of a transaction, also play a role in the sorting process.</p> <p>The values of <code>GasPrice</code>, <code>MaxFeePerGas</code> and <code>MaxPriorityFeePerGas</code> for the applicable transaction types can be read from the block JSON object according to the structure described in the Sidecar API page.</p> <p>The data for an Ethereum transaction in a particular block can be extracted from the following block endpoint:</p> <pre><code>GET /blocks/{blockId}\n</code></pre> <p>The paths to the relevant values have also been truncated and reproduced below:</p> EIP1559LegacyEIP2930 EVM Field Block JSON Field MaxFeePerGas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas</code> MaxPriorityFeePerGas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas</code> EVM Field Block JSON Field GasPrice <code>extrinsics[extrinsic_number].args.transaction.legacy.gasPrice</code> EVM Field Block JSON Field GasPrice <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice</code>"},{"location":"learn/core-concepts/tx-fees/#transaction-weight","title":"Transaction Weight","text":"<p><code>TransactionWeight</code> is a Substrate mechanism used to measure the execution time a given transaction takes to be executed within a block. A transaction's weight is a vector of two components: <code>refTime</code> and <code>proofSize</code>. <code>refTime</code> refers to the amount of computational time that can be used for execution. <code>proofSize</code> refers to the size of the PoV (Proof of Validity) of the Moonbeam block that gets submitted to the Polkadot Relay Chain for validation. Since both <code>refTime</code> and <code>proofSize</code> are integral components of determining a weight, it is impossible to obtain an accurate weight value with just one of these values.</p> <p>For all transactions types, <code>TransactionWeight</code> can be retrieved under the event of the relevant extrinsic where the <code>method</code> field is set to:</p> <pre><code>pallet: \"system\", method: \"ExtrinsicSuccess\" \n</code></pre> <p>And then <code>TransactionWeight</code> is mapped to the following two fields of the block JSON object. <code>proofSize</code> is mapped as follows:</p> <pre><code>extrinsics[extrinsic_number].events[event_number].data[0].weight.proof_size \n</code></pre> <p>And <code>refTime</code> is mapped as follows:</p> <pre><code>extrinsics[extrinsic_number].events[event_number].data[0].weight.ref_time \n</code></pre>"},{"location":"learn/core-concepts/tx-fees/#eth-feehistory-endpoint","title":"Fee History Endpoint","text":"<p>Moonbeam networks implement the <code>eth_feeHistory</code> JSON-RPC endpoint as a part of the support for EIP-1559.</p> <p><code>eth_feeHistory</code> returns a collection of historical gas information from which you can reference and calculate what to set for the <code>MaxFeePerGas</code> and <code>MaxPriorityFeePerGas</code> fields when submitting EIP-1559 transactions.</p> <p>The following curl example will return the gas information of the last 10 blocks starting from the latest block on the respective Moonbeam network using <code>eth_feeHistory</code>:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>curl --location \\\n     --request POST 'INSERT_RPC_API_ENDPOINT' \\\n     --header 'Content-Type: application/json' \\\n     --data-raw '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"eth_feeHistory\",\n        \"params\": [\"0xa\", \"latest\"]\n     }'\n</code></pre> <pre><code>curl --location \\\n     --request POST 'INSERT_RPC_API_ENDPOINT' \\\n     --header 'Content-Type: application/json' \\\n     --data-raw '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"eth_feeHistory\",\n        \"params\": [\"0xa\", \"latest\"]\n     }'\n</code></pre> <pre><code>curl --location \\\n     --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n     --header 'Content-Type: application/json' \\\n     --data-raw '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"eth_feeHistory\",\n        \"params\": [\"0xa\", \"latest\"]\n     }'\n</code></pre> <pre><code>curl --location \\\n     --request POST 'http://127.0.0.1:9944' \\\n     --header 'Content-Type: application/json' \\\n     --data-raw '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"eth_feeHistory\",\n        \"params\": [\"0xa\", \"latest\"]\n     }'\n</code></pre>"},{"location":"learn/core-concepts/tx-fees/#sample-code","title":"Sample Code for Calculating Transaction Fees","text":"<p>The following code snippet uses the Axios HTTP client to query the Sidecar endpoint <code>/blocks/head</code> for the latest finalized block. It then calculates the transaction fees of all transactions in the block according to the transaction type (for Ethereum API: legacy, EIP-1559 or EIP-2930 standards, and for Substrate API), as well as calculating the total transaction fees in the block.</p> <p>Note</p> <p>EIP-1559 transaction fees on Moonbeam are calculated using the previous block's base fee.</p> <p>The following code sample is for demo purposes only and should not be used without modification and further testing in a production environment.</p> <p>You can use the following snippet for any Moonbeam-based network, but you'll need to modify the <code>baseFee</code> accordingly. You can refer back to the Base Fee section to get the calculation for each network.</p> <pre><code>import axios from 'axios';\n\n// This script calculates the transaction fees of all transactions in a block\n// according to the transaction type (for Ethereum API: legacy, EIP-1559 or\n// EIP-2930 standards, and Substrate API) using the dynamic fee mechanism.\n// It also calculates the total fees in the block\n\n// Endpoint to retrieve the latest block\nconst endpointBlock = 'http://127.0.0.1:8080/blocks/head';\n// Endpoint to retrieve the latest nextFeeMultiplier\nconst endpointPallet =\n  'http://127.0.0.1:8080/pallets/transaction-payment/storage/nextFeeMultiplier?at=';\n// Endpoint to retrieve the node client's information\nconst endpointNodeVersion = 'http://127.0.0.1:8080/node/version';\n\n// Define the minimum base fee for each network\nconst baseFee = {\n  moonbeam: 31250000000n,\n  moonriver: 312500000n,\n  moonbase: 31250000n,\n};\n\nasync function main() {\n  try {\n    // Create a variable to sum the transaction fees in the whole block\n    let totalFees = 0n;\n\n    // Find which Moonbeam network the Sidecar is pointing to\n    const responseClient = await axios.get(endpointNodeVersion);\n    const network = responseClient.data.clientImplName;\n\n    // Retrieve the block from the Sidecar endpoint\n    const responseBlock = await axios.get(endpointBlock);\n    // Retrieve the block height of the current block\n    console.log('Block Height: ' + responseBlock.data.number);\n\n    // Use the previous block's base fee to match the on-chain data\n    // Find the block's nextFeeMultiplier\n    const prevBlock = Number(responseBlock.data.number) - 1;\n    const responsePallet = await axios.get(endpointPallet + prevBlock);\n\n    // Iterate through all extrinsics in the block\n    responseBlock.data.extrinsics.forEach((extrinsic) =&gt; {\n      // Create an object to store transaction information\n      let transactionData = new Object();\n      // Set the network field\n      transactionData['network'] = network;\n\n      // Filter for Ethereum Transfers\n      if (\n        extrinsic.method.pallet === 'ethereum' &amp;&amp;\n        extrinsic.method.method === 'transact'\n      ) {\n        // Iterate through the events to get non type specific parameters\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'ethereum' &amp;&amp;\n            event.method.method === 'Executed'\n          ) {\n            // Get Transaction Hash\n            transactionData['hash'] = event.data[2];\n          }\n          if (\n            event.method.pallet === 'system' &amp;&amp;\n            event.method.method === 'ExtrinsicSuccess'\n          ) {\n            // Add correction weight if needed to Transaction Weight!\n            transactionData['weight'] = BigInt(event.data[0].weight.refTime);\n          }\n        });\n\n        // Get the transaction type and type specific parameters and compute the\n        // transaction fee\n        if (extrinsic.args.transaction.legacy) {\n          transactionData['txType'] = 'legacy';\n          transactionData['gasPrice'] = BigInt(\n            extrinsic.args.transaction.legacy.gasPrice\n          );\n          transactionData['txFee'] =\n            (transactionData['gasPrice'] * transactionData['weight']) / 25000n;\n        } else if (extrinsic.args.transaction.eip1559) {\n          transactionData['txType'] = 'eip1599';\n          transactionData['maxFeePerGas'] = BigInt(\n            extrinsic.args.transaction.eip1559.maxFeePerGas\n          );\n          transactionData['maxPriorityFeePerGas'] = BigInt(\n            extrinsic.args.transaction.eip1559.maxPriorityFeePerGas\n          );\n          // Update based on the network you're getting tx fees for\n          transactionData['baseFee'] =\n            (BigInt(responsePallet.data.value) * baseFee.moonbeam) /\n            BigInt('1000000000000000000');\n\n          // Gas price dependes on the MaxFeePerGas and MaxPriorityFeePerGas set\n          transactionData['gasPrice'] =\n            transactionData['baseFee'] +\n              transactionData['maxPriorityFeePerGas'] &lt;\n            transactionData['maxFeePerGas']\n              ? transactionData['baseFee'] +\n                transactionData['maxPriorityFeePerGas']\n              : transactionData['maxFeePerGas'];\n\n          transactionData['txFee'] =\n            (transactionData['gasPrice'] * transactionData['weight']) / 25000n;\n        } else if (extrinsic.args.transaction.eip2930) {\n          transactionData['txType'] = 'eip2930';\n          transactionData['gasPrice'] = BigInt(\n            extrinsic.args.transaction.eip2930.gasPrice\n          );\n          transactionData['txFee'] =\n            (transactionData['gasPrice'] * transactionData['weight']) / 25000n;\n        }\n\n        // Increment totalFees\n        totalFees += transactionData['txFee'];\n\n        // Display the tx information to console\n        console.log(transactionData);\n      }\n      // Filter for Substrate transactions, check if the extrinsic has a\n      // 'TransactionFeePaid' event\n      else {\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'transactionPayment' &amp;&amp;\n            event.method.method === 'TransactionFeePaid'\n          ) {\n            transactionData['txType'] = 'substrate';\n            transactionData['txFee'] = event.data[1];\n            transactionData['tip'] = event.data[1];\n          }\n          if (\n            event.method.pallet === 'system' &amp;&amp;\n            event.method.method === 'ExtrinsicSuccess'\n          ) {\n            transactionData['weight'] = event.data[0].weight.refTime;\n          }\n        });\n      }\n    });\n\n    // Output the total amount of fees in the block\n    console.log('Total fees in block: ' + totalFees);\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nmain();\n</code></pre>"},{"location":"learn/core-concepts/tx-fees/#substrate-api-transaction-fees","title":"Substrate API Transaction Fees","text":"<p>This section of the guide assumes you are interacting with Moonbeam blocks via the Substrate API Sidecar service. There are other ways of interacting with Moonbeam blocks, such as using the Polkadot.js API library. The logic is identical once the blocks are retrieved.</p> <p>You can reference the Substrate API Sidecar page for information on installing and running your own Sidecar service instance, as well as more details on how to decode Sidecar blocks for Moonbeam transactions.</p> <p>Note that the information in this section assumes you are running version 20.2.0 of the Substrate Sidecar REST API.</p> <p>All the information around fee data for transactions sent via the Substrate API can be extracted from the following block endpoint:</p> <pre><code>GET /blocks/{blockId}\n</code></pre> <p>The block endpoints will return data relevant to one or more blocks. You can read more about the block endpoints on the official Sidecar documentation. Read as a JSON object, the relevant nesting structure is as follows:  </p> <pre><code>RESPONSE JSON Block Object:\n    ...\n    |--number\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n            |--signature\n            |--nonce\n            |--args\n            |--tip           \n            |--hash\n            |--info\n            |--era\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"transactionPayment\"\n                        |--method: \"TransactionFeePaid\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n    ...\n</code></pre> <p>The object mappings are summarized as follows:</p> Tx Information Block JSON Field Fee paying account <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Total fees paid <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> Tip <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> <p>The transaction fee related information can be retrieved under the event of the relevant extrinsic where the <code>method</code> field is set to:</p> <pre><code>pallet: \"transactionPayment\", method: \"TransactionFeePaid\" \n</code></pre> <p>And then the total transaction fee paid for this extrinsic is mapped to the following field of the block JSON object:</p> <pre><code>extrinsics[extrinsic_number].events[event_number].data[1]\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"learn/core-concepts/unified-accounts/","title":"Unified Accounts","text":""},{"location":"learn/core-concepts/unified-accounts/#introduction","title":"Introduction","text":"<p>As Moonbeam is designed to be an Ethereum-compatible parachain on Polkadot, the underlying account system replaces the default Substrate-style accounts and keys with Ethereum-style accounts and keys. As a result, you can interact with your Moonbeam account using MetaMask and Ethereum tools you may already be familiar with, such as Remix and Hardhat.</p> <p>You can also interact with your Moonbeam account using Polkadot.js Apps as it natively supports H160 addresses and ECDSA keys. For more information on this integration, you can check out the Interacting with Moonbeam Using Polkadot.js Apps guide.</p>"},{"location":"learn/core-concepts/unified-accounts/#substrate-evm-compatible-blockchain","title":"Substrate EVM Compatible Blockchain","text":"<p>Any parachain in the Polkadot ecosystem can offer a full EVM implementation, which provides the possibility of executing Solidity-based smart contracts with minimal to no changes. Substrate makes this integration possible - just plug the EVM pallet into your runtime for EVM support, and the Ethereum Pallet with Frontier to have Ethereum RPC compatibility. The availability of these open-source modules that Moonbeam has developed with Parity has led multiple parachains to offer Ethereum compatibility on their chains.</p> <p>But there is an important catch. With the configuration described above, a user, for example, Alice, can have an Ethereum-style address (H160 format), which is 40+2 hex-characters long, in a Substrate based chain. This address matches a private key, which can be used to sign transactions in the Ethereum side of the chain. Furthermore, the address is mapped into a storage slot inside the Substrate Balance pallet to a Substrate-style address (H256 format).</p> <p>However, Alice only knows the private key of the H160 address, and not of the mapped version. Therefore, she is unable to send transactions with her H256 address and is limited only to do read-only operations through Substrate\u2019s API. As a consequence, Alice needs another H256 address matching a different private key to be able to operate in the Substrate side of the chain, which include, among others, staking, balances, and governance.</p> <p>The following diagram illustrates this configuration.</p> <p></p> <p>This can creates friction and a poor user experience for Alice. First, she has to move tokens to her H160 mapped H256 address to be able to make transactions and deploy contracts through the EVM. Second, she also needs to hold a balance in her other H256 address (which she has a different private key for) to use Substrate-based features. So in short, Alice needs a minimum of two private keys to have the best of both worlds.</p>"},{"location":"learn/core-concepts/unified-accounts/#moonbeam-unified-accounts","title":"Moonbeam Unified Accounts","text":"<p>Moonbeam\u2019s focus is to create a fully Ethereum-compatible environment on Polkadot with the best user experience possible. This extends beyond the base Ethereum feature set, with additional features such as on-chain governance, staking, and cross-chain integrations.</p> <p>With unified accounts, a user, for example, Bob, will only need a single H160 address, with its corresponding private key, to do everything we mentioned above, including both EVM and Substrate functions.</p> <p>The diagram for this new configuration looks as follows.</p> <p></p> <p>That is it, Bob only holds one private key that matches one address. He does not need to move balances between 2 different accounts and is able to access all the features with a single account and private key. We have standardized this single account to conform to the Ethereum-style H160 address and ECDSA key standards.</p>"},{"location":"learn/features/consensus/","title":"Nimbus Parachain Consensus Framework","text":""},{"location":"learn/features/consensus/#introduction","title":"Introduction","text":"<p>Polkadot relies on a hybrid consensus model. In such a scheme, the block finality gadget and the block production mechanism are separate. Consequently, parachains only have to worry about producing blocks and rely on the relay chain to validate the state transitions.</p> <p>At a parachain level, block producers are called collators. They maintain parachains (such as Moonbeam) by collecting transactions from users and offering blocks to the relay chain validators.</p> <p>However, parachains might find the following problems they need to solve in a trustless and decentralized matter (if applicable):</p> <ul> <li>Amongst all of the nodes in the network, which ones are allowed to author blocks?</li> <li>If multiple nodes are allowed, will they be eligible at the same time? Only one? Maybe a few?</li> </ul> <p>Enter Nimbus. Nimbus is a framework for building slot-based consensus algorithms on Cumulus-based parachains. It strives to provide standard implementations for the logistical parts of such consensus engines and helpful traits for implementing the elements (filters) that researchers and developers want to customize. These filters can be customizable to define what a block authorship slot is and can be composed, so block authorship is restricted to a subset of collators in multiple steps.</p> <p>For example, Moonbeam uses a two-layer approach. The first layer comprises the parachain staking filter, which helps select an active collator pool among all collator candidates using a staked-based ranking. The second layer adds another filter which narrows down the number of collators to a subset for each slot.</p> <p>Notice that Nimbus can only answer which collator(s) are eligible to produce a parachain block in the next available slot. It is the Cumulus consensus mechanism that marks this parachain block as best, and ultimately the BABE and GRANDPA hybrid consensus model (of the relay chain) that will include this parachain block in the relay chain and finalize it. Once any relay chain forks are resolved at a relay chain level, that parachain block is deterministically finalized.</p> <p>The following two sections go over the filtering strategy currently used on Moonbeam.</p>"},{"location":"learn/features/consensus/#parachain-staking-filtering","title":"Parachain Staking Filtering","text":"<p>Collators can join the candidate pool by simply bonding some tokens via an extrinsic. Once in the pool, token holders can add to the candidate's stake via delegation (also referred to as staking), that is, at a parachain level.</p> <p>Parachain staking is the first of the two Nimbus filters applied to the candidate pool. It selects the top 11 candidates in terms of tokens staked in the network, which includes the candidate's bond and delegations from token holders. This filtered pool is called selected candidates, and selected candidates are renewed every round (which lasts 1200 blocks). For a given round, the following diagram describes the parachain staking filtering:</p> <p></p> <p>From this pool, another filter is applied to retrieve a subset of eligible candidates for the next block authoring slot.</p> <p>If you want to learn more about staking, visit our staking documentation.</p>"},{"location":"learn/features/consensus/#fixed-size-subset-filtering","title":"Fixed Size Subset Filtering","text":"<p>Once the parachain staking filter is applied and the selected candidates are retrieved, a second filter is applied on a block by block basis and helps narrow down the selected candidates to a smaller number of eligible collators for the next block authoring slot.</p> <p>In broad terms, this second filter picks a pseudo-random subset of the previously selected candidates. The eligibility ratio, a tunable parameter, defines the size of this subset.</p> <p>A high eligibility ratio results in fewer chances for the network to skip a block production slot, as more collators will be eligible to propose a block for a specific slot. However, only a certain number of validators are assigned to a parachain, meaning that most of these blocks will not be backed by a validator. For those that are, a higher number of backed blocks means that it might take longer for the relay chain to solve any possible forks and return a finalized block. Moreover, this might create an unfair advantage for certain collators that might be able to get their proposed block faster to relay chain validators, securing a higher portion of block rewards (if any).</p> <p>A lower eligibility ratio might provide faster block finalization times and a fairer block production distribution amongst collators. However, if the eligible collators are not able to propose a block (for whatever reason), the network will skip a block, affecting its stability.</p> <p>Once the size of the subset is defined, collators are randomly selected using a source of entropy. Currently, an internal coin-flipping algorithm is implemented, but this will later be migrated to use Verifiable random function. Consequently, a new subset of eligible collators is selected for every relay chain block. For a given round and a given block <code>XYZ</code>, the following diagram describes the fixed-size subset filtering:</p> <p></p>"},{"location":"learn/features/consensus/#why-nimbus","title":"Why Nimbus?","text":"<p>You might ask yourself: but why Nimbus? Initially, it was not envisioned when Moonbeam was being developed. As Moonbeam progressed, the necessity for a more customizable but straightforward parachain consensus mechanism became clear, as the available methods presented some drawbacks or technical limitations.</p> <p>With Nimbus, writing a parachain consensus engine is as easy as writing a pallet! This simplicity and flexibility is the main value it adds.</p> <p>Some technical benefits of Nimbus are considered in the following sections.</p>"},{"location":"learn/features/consensus/#weight-and-extra-execution","title":"Weight and Extra Execution","text":"<p>Nimbus puts the author-checking execution in a Substrate pallet. At first glance, you might think this adds a higher execution load to a single block compared to doing this check off-chain. But consider this from a validator\u2019s perspective</p> <p>The validators will also have to check the author. By putting the author-checking execution logic in a pallet, the execution time can be benchmarked and quantified with weights. If this execution time is not accounted for, there is the risk of a block exceeding the relay chain Wasm execution limit (currently 0.5 seconds).</p> <p>In practice, this check will be fast and will most likely not push execution time over the limit. But from a theoretical perspective, accounting for its weight is better for implementation purposes.</p>"},{"location":"learn/features/consensus/#reusability","title":"Reusability","text":"<p>Another benefit of moving the author-checking execution to a pallet, rather than a custom executor, is that one single executor can be reused for any consensus that can be expressed in the Nimbus framework. That is slot-based, signature-sealed algorithms.</p> <p>For example, the relay-chain provided consensus, AuRa and BABE each have their own custom executor. With Nimbus, these consensus mechanisms can reuse the same executor. The power of reusability is evidenced by the Nimbus implementation of AuRa in less than 100 lines of code.</p>"},{"location":"learn/features/consensus/#hot-swapping-consensus","title":"Hot-Swapping Consensus","text":"<p>Teams building parachains may want to change, tune, or adjust their consensus algorithm from time to time. Without nimbus, swapping consensus would require a client upgrade and hard fork.</p> <p>With the Nimbus framework, writing a consensus engine is as easy as writing a Substrate pallet. Consequently, swapping consensus is as easy as upgrading a pallet.</p> <p>Nonetheless, hot swapping is still bounded by consensus engines (filters) that fit within Nimbus, but it might be helpful for teams that are yet confident on what consensus they want to implement in the long run.</p>"},{"location":"learn/features/eth-compatibility/","title":"Ethereum Compatibility","text":"<p>Moonbeam bridges the Ethereum and Polkadot ecosystems, offering developers the familiarity of Ethereum's tooling and infrastructure while leveraging Polkadot's scalability and interoperability.</p> <p>This documentation overviews Moonbeam's Ethereum compatibility features and highlights its key components. It also covers some critical differences between Moonbeam and Ethereum so Ethereum developers know what to expect.</p>"},{"location":"learn/features/eth-compatibility/#key-components","title":"Key Components","text":""},{"location":"learn/features/eth-compatibility/#evm","title":"EVM Compatibility","text":"<p>Moonbeam incorporates a fully compatible EVM to execute smart contracts in Solidity or other EVM-compatible languages. This enables developers to deploy existing Ethereum smart contracts on Moonbeam with minimal modifications.</p> <p>Learn more:</p> <ul> <li>Moonbeam's Ethereum-compatibility architecture</li> </ul>"},{"location":"learn/features/eth-compatibility/#ethereum-style-accounts","title":"Ethereum-style Accounts","text":"<p>Moonbeam employs H160 Ethereum-style accounts and ECDSA keys, ensuring compatibility with existing Ethereum wallets and facilitating a smooth end-user experience. This is possible due to Moonbeam's unified accounts system, which modifies the underlying Substrate account system to use Ethereum accounts by default.</p> <p>Learn more:</p> <ul> <li>Moonbeam's unified accounts system</li> </ul>"},{"location":"learn/features/eth-compatibility/#json-rpc-support","title":"JSON-RPC Support","text":"<p>Moonbeam offers full JSON-RPC compatibility with Ethereum, allowing developers to interact with Moonbeam nodes using familiar Ethereum tools and libraries. This compatibility extends to methods for account management, transaction submission, smart contract deployment, and event monitoring.</p> <p>In addition to standard Ethereum RPC methods, Moonbeam supports non-standard Debug and Trace modules, providing developers with enhanced debugging and tracing capabilities for smart contract execution. The Debug module allows developers to inspect internal state transitions and execution traces, enabling efficient debugging of complex smart contracts. The Trace module provides detailed transaction traces, including opcode-level execution information and gas consumption, facilitating performance analysis and optimization.</p> <p>Learn more:</p> <ul> <li>Supported Ethereum RPC methods</li> <li>Subscribe to events with Ethereum JSON-RPC methods</li> <li>Debug and trace transactions with non-standard RPC methods</li> </ul>"},{"location":"learn/features/eth-compatibility/#ethereum-dev-tools","title":"Ethereum Developer Tools and Libraries","text":"<p>With the underlying support for Ethereum JSON-RPC methods, Moonbeam leverages Ethereum's rich ecosystem of developer libraries and environments. With seamless integration of popular Ethereum libraries and development environments, developers can leverage their existing knowledge and tooling to build and deploy decentralized applications (DApps) on Moonbeam.</p> <p>Learn more:</p> <ul> <li>Ethereum libraries</li> <li>Ethereum development environments</li> </ul>"},{"location":"learn/features/eth-compatibility/#precompiled-contracts","title":"Precompiled Contracts","text":"<p>Moonbeam provides precompiled contracts that allow Ethereum smart contracts to seamlessly access Substrate functionality. These precompiled contracts expose Substrate features such as on-chain governance, staking, and identity management to Ethereum-based DApps on Moonbeam. This integration ensures that Ethereum developers can harness the full potential of Moonbeam's features, expanding the possibilities for dApp development on Moonbeam.</p> <p>In addition, developers can leverage Ethereum MainNet precompiles seamlessly within their smart contracts on Moonbeam. These precompiled contracts, widely used on the Ethereum network, offer optimized and efficient execution of common cryptographic operations and complex computations. By supporting Ethereum MainNet precompiles, Moonbeam ensures compatibility with Ethereum-based dApps while enabling developers to utilize familiar tools and libraries to build on its platform.</p> <p>Learn more:</p> <ul> <li>Overview of the precompiled contracts on Moonbeam</li> </ul>"},{"location":"learn/features/eth-compatibility/#ethereum-token-standards","title":"Ethereum Token Standards","text":"<p>Moonbeam supports Ethereum token standards, allowing developers to deploy and interact with tokens that adhere to popular standards such as ERC-20, ERC-721, and ERC-1155. By supporting these standards, Moonbeam enables developers to deploy existing Ethereum tokens without modification.</p> <p>Due to Moonbeam's native interoperability, ERC-20s can be sent cross-chain to other chains within the Polkadot ecosystem via Cross-Consensus Messaging (XCM).</p> <p>Learn more:</p> <ul> <li>Create common OpenZeppelin contracts such as ERC-20, ERC-721, and ERC-1155 tokens</li> <li>XCM-enabled ERC-20s (also referred to as local XC-20s)</li> </ul>"},{"location":"learn/features/eth-compatibility/#key-differences","title":"Key Differences","text":""},{"location":"learn/features/eth-compatibility/#consensus-mechanisms","title":"Consensus Mechanisms","text":"<p>Moonbeam uses a Delegated Proof-of-Stake (DPoS) consensus mechanism, where token holders in the network can delegate candidates to become block producers, known as collators. On the other hand, Ethereum uses a Proof-of-Stake (PoS) system in which validators are selected based on their stake in the network to produce and validate blocks.</p> <p>Learn more:</p> <ul> <li>Differences between PoS and DPoS</li> </ul>"},{"location":"learn/features/eth-compatibility/#finality","title":"Finality","text":"<p>Moonbeam and Ethereum have different finality processes. On Ethereum, there is a checkpoint system where validators determine finality at checkpoint blocks, which takes at least 6.4 minutes for a block to be finalized. Moonbeam relies on Polkadot's GRANDPA finality gadget, which expedites finality by completing the process parallel to block production and allowing relay chain validators to vote on the highest block, finalizing all blocks leading up to that block.</p> <p>Learn more:</p> <ul> <li>Consensus and finality on Moonbeam</li> </ul>"},{"location":"learn/features/eth-compatibility/#proxy-accounts","title":"Proxy Accounts","text":"<p>On both Moonbeam and Ethereum, accounts can be controlled by two main types of accounts: Externally Owned Accounts (EOA) or smart contracts. However, on Moonbeam, within both account types, there are also proxy accounts, which can perform a limited number of actions on behalf of another account.</p> <p>Learn more:</p> <ul> <li>An overview of proxy accounts</li> <li>How to set up a proxy account</li> </ul>"},{"location":"learn/features/eth-compatibility/#account-balances","title":"Account Balances","text":"<p>Balances on Ethereum are fairly straightforward; if an account holds tokens, that account has a token balance. On Moonbeam, different balance types exist to support various Substrate functionality. There are five types: free, reducible, reserved, miscellaneous frozen, and fee frozen. When using Ethereum tools, accounts show the reducible balance and don't include locked or frozen balances.</p> <p>Learn more:</p> <ul> <li>Moonbeam account balances</li> </ul>"},{"location":"learn/features/eth-compatibility/#balance-transfers","title":"Balance Transfers","text":"<p>Since Moonbeam is a Substrate-based chain, balance transfers of the native asset (GLMR, MOVR, and DEV) can occur through the Ethereum and Substrate APIs. Like Ethereum, transfers sent through the Ethereum API rely on the <code>eth_sendRawTransaction</code>. Transfers sent through the Substrate API are done using the Balances Pallet, a built-in module in the Substrate framework that provides functionality for managing accounts and balances.</p> <p>Learn more:</p> <ul> <li>Balance transfers on Moonbeam</li> </ul>"},{"location":"learn/features/eth-compatibility/#transaction-fees","title":"Transaction Fees","text":"<p>Moonbeam and Ethereum calculate transaction fees differently due to variations in their underlying architectures and consensus mechanisms. The fundamental difference in how transaction fees are calculated is that Ethereum uses a gas-based fee system, and Moonbeam uses a weight-based system that maps to the gas used. Moonbeam also implements additional metrics in the underlying gas calculations, including proof size and storage costs.</p> <p>Learn more:</p> <ul> <li>Calculating transaction fees on Moonbeam</li> </ul>"},{"location":"learn/features/governance/","title":"Governance on Moonbeam","text":""},{"location":"learn/features/governance/#introduction","title":"Introduction","text":"<p>The goal of Moonbeam\u2019s governance mechanism is to advance the protocol according to the desires of the community. In that shared mission, the governance process seeks to include all token holders. Any and all changes to the protocol must go through a referendum so that all token holders, weighted by stake, can have input on the decision.</p> <p>Governance forums like the Moonbeam Community Forum and Polkassembly enable open discussion and allow proposals to be refined based on community input. Autonomous enactments and forkless upgrades unite the community towards a shared mission to advance the protocol.</p> <p>With the rollout of OpenGov (originally referred to as Gov2), the second phase of governance in Polkadot, several modifications have been introduced to the governance process. You can read the OpenGov: What is Polkadot Gov2 blog post, which provides an overview of all of the changes made in OpenGov.</p> <p>As of runtime 2400, all Moonbeam networks use OpenGov as their governance system.</p>"},{"location":"learn/features/governance/#principles","title":"Principles","text":"<p>Guiding \"soft\" principles for engagement with Moonbeam's governance process include:</p> <ul> <li>Being inclusive to token holders that want to engage with Moonbeam and that are affected by governance decisions</li> <li>Favoring token holder engagement, even with views contrary to our own, versus a lack of engagement</li> <li>A commitment to openness and transparency in the decision-making process</li> <li>Working to keep the greater good of the network above personal gain</li> <li>Acting at all times as a moral agent that considers the consequences of action (or inaction) from a moral standpoint</li> <li>Being patient and generous in our interactions with other token holders, but not tolerating abusive or destructive language, actions, and behavior, and abiding by Moonbeam\u2019s Code of Conduct</li> </ul> <p>These points were heavily inspired by Vlad Zamfir\u2019s writings on governance. Refer to his articles, especially the How to Participate in Blockchain Governance in Good Faith (and with Good Manners) Medium article.</p>"},{"location":"learn/features/governance/#on-chain-governance-mechanics","title":"On-Chain Governance Mechanics","text":"<p>The \"hard\" governance process for Moonbeam will be driven by an on-chain process that allows the majority of tokens on the network to determine the outcomes of key decisions around the network. These decision points come in the form of stake-weighted voting on proposed referenda.</p> <p>Some of the main components of this governance model include:</p> <ul> <li>Referenda \u2014 a stake-based voting scheme where each referendum is tied to a specific proposal for a change to the Moonbeam system including values for key parameters, code upgrades, or changes to the governance system itself</li> <li>Voting \u2014 referenda will be voted on by token holders on a stake-weighted basis. Referenda which pass are subject to delayed enactment so that people who disagree with the direction of the decision have time to exit the network</li> <li>Council &amp; Technical Committee Governance V1 \u2014 a group of community members who have special voting rights within the system. With the deprecation and removal of Governance v1, both of these committees were dissolved as of the runtime 2800 release</li> <li>OpenGov Technical Committee \u2014 a group of community members who can add certain proposals to the Whitelisted Track</li> </ul> <p>For more details on how these Substrate frame pallets implement on-chain governance, you can checkout the Walkthrough of Polkadot\u2019s Governance blog post and the Polkadot Governance Wiki.</p>"},{"location":"learn/features/governance/#opengov","title":"Governance v2: OpenGov","text":"<p>This section will cover everything you need to know about OpenGov on Moonbeam.</p>"},{"location":"learn/features/governance/#general-definitions-gov2","title":"General Definitions","text":"<ul> <li>Proposal \u2014 an action or item, defined by the preimage hash, being proposed by a token holder and open for consideration and discussion by token holders</li> <li> <p>Referendum \u2014 a proposal that is up for token-holder voting. Each referendum is tied to a specific proposal for a change to the Moonbeam system including values for key parameters, code upgrades, or changes to the governance system itself</p> </li> <li> <p>Preimage hash \u2014 hash of the proposal to be enacted. The first step to make a proposal is to submit a preimage. The hash is just its identifier. The proposer of the preimage can be different than the user that proposes that preimage as a formal proposal</p> </li> <li> <p>Preimage deposit \u2014 amount of tokens that the proposer needs to bond when submitting a preimage. It is calculated as the sum of a base deposit per network plus a fee per byte of the preimage being proposed</p> </li> <li> <p>Origin - an authorization-based dispatch source for an operation, which is used to determine the Track that a referendum is posted under</p> </li> <li> <p>Track - an Origin-specific pipeline that outlines the life cycle of proposals. Currently, there are five Tracks:</p> Origin Track Description Referendum Examples Root Highest privilege Runtime upgrades, Technical Committee management Whitelisted Proposals to be whitelisted by the Technical Committee before being dispatched Fast-tracked operations General Admin For general on-chain decisions Changes to XCM fees, Orbiter program, Staking parameters, Registrars Emergency Canceller For cancellation of a referendum. Decision Deposit is refunded Wrongly constructed referendum Emergency Killer For killing of bad/malicious referendum. Decision Deposit is slashed Malicious referendum Fast General Admin For faster general on-chain decisions HRMP channel management </li> </ul> <p>Tracks have different criteria parameters that are proportional to their level of Origin class. For example, more dangerous and privileged referenda will have more safeguards, higher thresholds, and longer consideration periods for approval. Please refer to the Governance Parameters section for more information.</p> <ul> <li> <p>Voting \u2014 a mechanism for token holders to support (Aye), oppose (Nay), or remain neutral (Abstain) on a proposal. For Aye and Nay, the voting weight is determined by both the number of tokens locked and the lock duration (Conviction). Abstain votes do not receive additional weighting</p> <ul> <li>Conviction \u2014 the time that token holders voluntarily lock their tokens when voting; the longer they are locked, the more weight their vote has</li> <li>Lock balance \u2014 the number of tokens that a user commits to a vote (note, this is not the same as a user's total account balance) Moonbeam uses the concept of voluntary locking, which allows token holders to increase their voting power by locking tokens for a longer period of time. Specifying no Lock Period means a user's vote is valued at 10% of their lock balance. Specifying a greater Conviction increases voting power. For each increase in Conviction (vote multiplier), the Lock Periods double</li> </ul> </li> <li> <p>Approval \u2014 minimum \"Aye\" votes as a percentage of overall Conviction-weighted votes needed for approval</p> </li> <li> <p>Support \u2014 the minimum portion of Aye and Abstain votes (ignoring conviction) needed as a percentage of the total active supply for a proposal to pass. Nay votes do not count toward Support</p> </li> <li> <p>Lead-in Period \u2014 the initial proposal voting and discussion period. At this stage, proposals are in an undecided state until they pass some criteria for the given Track. The criteria include:</p> <ul> <li>Prepare Period \u2014 the minimum time the referendum needs to wait before it can progress to the next phase after submission</li> <li>Capacity \u2014 limit for the number of referenda on a given Track that can be decided at once</li> <li>Decision Deposit \u2014 the minimum deposit amount required for a referendum to progress to the decision phase after the end of the Lead-in Period. Since each Track has a defined Capacity, this deposit is larger than the submission deposit, and its goal is to mitigate spam </li> </ul> </li> <li> <p>Decide Period - token holders continue to vote on the referendum. If a referendum does not pass by the end of the period, it will be rejected, and the Decision Deposit will be refunded</p> </li> <li>Confirm Period - a period of time within the Decide Period where the referendum needs to have maintained enough Approval and Support to be approved and move to the Enactment Period</li> <li> <p>Enactment Period - a specified time, which is defined at the time the proposal was created, that an approved referendum waits before it can be dispatched. There is a minimum amount of time for each Track</p> </li> <li> <p>Vote Delegation \u2014 a voter can give their voting power, including Conviction voting, to another token holder (delegate), who may be more knowledgeable and able to make specific decisions</p> </li> <li>Multirole Delegation \u2014 the ability to delegate voting power on a Track-by-Track basis, where a token holder can specify different delegates for each Track</li> </ul>"},{"location":"learn/features/governance/#governance-parameters-v2","title":"Governance Parameters","text":"MoonbeamMoonriverMoonbase Alpha Variable Value Preimage base deposit 500 GLMR Preimage deposit per byte 0.01 GLMR Proposal Submission Deposit 1000 GLMR Variable Value Preimage base deposit 5 MOVR Preimage deposit per byte 0.0001 MOVR Proposal Submission Deposit 10 MOVR Variable Value Preimage base deposit 5 DEV Preimage deposit per byte 0.0001 DEV Proposal Submission Deposit 10 DEV"},{"location":"learn/features/governance/#general-parameters-by-track","title":"General Parameters by Track","text":"MoonbeamMoonriverMoonbase Alpha Track Track ID Capacity DecisionDeposit Root 0 5 proposals 2000000 GLMR Whitelisted 1 100 proposals 200000 GLMR General Admin 2 10 proposals 10000 GLMR EmergencyCanceller 3 20 proposals 200000 GLMR EmergencyKiller 4 100 proposals 400000 GLMR Fast General Admin 5 10 proposals 10000 GLMR Track Track ID Capacity DecisionDeposit Root 0 5 proposals 100000 MOVR Whitelisted 1 100 proposals 10000 MOVR General Admin 2 10 proposals 500 MOVR EmergencyCanceller 3 20 proposals 10000 MOVR EmergencyKiller 4 100 proposals 20000 MOVR Fast General Admin 5 10 proposals 500 MOVR Track Track ID Capacity DecisionDeposit Root 0 5 proposals 100000 DEV Whitelisted 1 100 proposals 10000 DEV General Admin 2 10 proposals 500 DEV EmergencyCanceller 3 20 proposals 10000 DEV EmergencyKiller 4 100 proposals 20000 DEV Fast General Admin 5 10 proposals 500 DEV"},{"location":"learn/features/governance/#period-parameters-by-track","title":"Period Parameters by Track","text":"MoonbeamMoonriverMoonbase Alpha Track PreparePeriod DecidePeriod ConfirmPeriod MinimumEnactment Period Root 14400 blocks (1 day) 201600 blocks (14 days) 14400 blocks (1 day) 14400 blocks (1 day) Whitelisted 100 blocks (10 minutes) 201600 blocks (14 days) 100 blocks (10 minutes) 300 blocks (30 minutes) General Admin 600 blocks (1 hour) 201600 blocks (14 days) 14400 blocks (1 day) 14400 blocks (1 day) EmergencyCanceller 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) EmergencyKiller 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) Fast General Admin 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) Track PreparePeriod DecidePeriod ConfirmPeriod MinimumEnactment Period Root 14400 blocks (1 day) 201600 blocks (14 days) 14400 blocks (1 day) 14400 blocks (1 day) Whitelisted 100 blocks (10 minutes) 201600 blocks (14 days) 100 blocks (10 minutes) 300 blocks (30 minutes) General Admin 600 blocks (1 hour) 201600 blocks (14 days) 14400 blocks (1 day) 14400 blocks (1 day) EmergencyCanceller 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) EmergencyKiller 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) Fast General Admin 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) Track PreparePeriod DecidePeriod ConfirmPeriod MinimumEnactment Period Root 14400 blocks (1 day) 201600 blocks (14 days) 14400 blocks (1 day) 14400 blocks (1 day) Whitelisted 100 blocks (10 minutes) 201600 blocks (14 days) 100 blocks (10 minutes) 300 blocks (30 minutes) General Admin 600 blocks (1 hour) 201600 blocks (14 days) 14400 blocks (1 day) 14400 blocks (1 day) EmergencyCanceller 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) EmergencyKiller 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) Fast General Admin 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) <p>Note</p> <p>As of runtime 3000, asynchronous backing has been enabled on all Moonbeam networks. As a result, the target block time was reduced from 12 seconds to 6 seconds, which may break some timing-based assumptions.</p>"},{"location":"learn/features/governance/#support-and-approval-parameters-by-track","title":"Support and Approval Parameters by Track","text":"MoonbeamMoonriverMoonbase Alpha Track Approval Curve Approval Parameters Support Curve Support Parameters Root Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Linear Day 0: 25%Day 14: 0.5% Whitelisted Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 2%Hour 1: 1%Day 14: 0% General Admin Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Reciprocal Day 0: 50%Day 7: 10%Day 14: 0% EmergencyCanceller Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 10%Day 1: 1%Day 14: 0% EmergencyKiller Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 10%Day 1: 1%Day 14: 0% Fast General Admin Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Reciprocal Day 0: 50%Day 5: 1%Day 14: 0% Track Approval Curve Approval Parameters Support Curve Support Parameters Root Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Linear Day 0: 25%Day 14: 0.5% Whitelisted Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 2%Hour 1: 1%Day 14: 0% General Admin Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Reciprocal Day 0: 50%Day 7: 10%Day 14: 0% EmergencyCanceller Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 10%Day 1: 1%Day 14: 0% EmergencyKiller Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 10%Day 1: 1%Day 14: 0% Fast General Admin Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Reciprocal Day 0: 50%Day 5: 1%Day 14: 0% Track Approval Curve Approval Parameters Support Curve Support Parameters Root Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Linear Day 0: 25%Day 14: 0.5% Whitelisted Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 2%Hour 1: 1%Day 14: 0% General Admin Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Reciprocal Day 0: 50%Day 7: 10%Day 14: 0% EmergencyCanceller Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 50%Day 1: 1%Day 14: 0% EmergencyKiller Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 10%Day 1: 1%Day 14: 0% Fast General Admin Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Reciprocal Day 0: 50%Day 5: 1%Day 14: 0%"},{"location":"learn/features/governance/#conviction-multiplier-v2","title":"Conviction Multiplier","text":"<p>The Conviction multiplier is related to the number of Enactment Periods the tokens will be locked for after the referenda is enacted (if approved). Consequently, the longer you are willing to lock your tokens, the stronger your vote will be weighted. You also have the option of not locking tokens at all, but vote weight is drastically reduced (tokens are still locked during the duration of the referendum).</p> <p>If you were to vote 1000 tokens with a 6x Conviction, your weighted vote would be 6000 units. That is, 1000 locked tokens multiplied by the Conviction, which in this scenario would be 6. On the other hand, if you decided you didn't want to have your tokens locked after enactment, you could vote your 1000 tokens with a 0.1x Conviction. In this case, your weighted vote would only be 100 units.</p> <p>The Conviction multiplier values for each network are:</p> MoonbeamMoonriverMoonbase Alpha Lock Periods After Enactment Conviction Multiplier Approx. Lock Time 0 0.1 None 1 1 1 day 2 2 2 days 4 3 4 days 8 4 8 days 16 5 16 days 32 6 32 days Lock Periods After Enactment Conviction Multiplier Approx. Lock Time 0 0.1 None 1 1 1 day 2 2 2 days 4 3 4 days 8 4 8 days 16 5 16 days 32 6 32 days Lock Periods After Enactment Conviction Multiplier Approx. Lock Time 0 0.1 None 1 1 1 day 2 2 2 days 4 3 4 days 8 4 8 days 16 5 16 days 32 6 32 days <p>Note</p> <p>The lock time approximations are based upon regular 6-second block times. Block production may vary and thus the displayed lock times should not be deemed exact.</p>"},{"location":"learn/features/governance/#roadmap-of-a-proposal-v2","title":"Roadmap of a Proposal","text":"<p>Before a proposal is submitted, the author of the proposal can submit their proposal idea to the designated Democracy Proposals section of the Moonbeam Governance discussion forum for feedback from the community for at least five days. From there, the author can make adjustments to the proposal based on the feedback they've collected.</p> <p>Once the author is ready, they can submit their proposal on-chain. To do so, first, they need to submit the preimage of the proposal. The submitter needs to bond a fee to store the preimage on-chain. The bond is returned once the submitter unnotes the preimage. Next, they can submit the actual proposal and pay the Submission Deposit, which is enough to cover the on-chain storage cost of the proposal. Then the Lead-in Period begins and the community can begin voting \"Aye\" or \"Nay\" on the proposal by locking tokens. In order for the referendum to advance and move out of the Lead-in Period to the Decide period, the following criteria must be met:</p> <ul> <li>The referendum must wait the duration of the Prepare Period, which allows for adequate time to discuss the proposal before it progresses to the next phase</li> <li>There is enough Capacity in the chosen Track</li> <li>A Decision Deposit has been made that meets the minimum requirements for the Track</li> </ul> <p>If a referendum meets the above criteria, it moves to the Decide Period and takes up one of the spots in its designated Track. In the Decide Period, voting continues and the referendum has a set amount of days to reach the Approval and Support requirements needed for it to progress to the Confirm Period.</p> <p>Once in the Confirm Period, a referendum must continuously meet the Approval and Support requirements for the duration of the period. If a referendum fails to meet the requirements at any point, it is returned to the Decide Period. If the referendum meets the Approval and Support requirements again, it can progress to the Confirm Period again and the Decide Period will be delayed until the end of the Confirm Period. If the Decide Period ends and not enough Approval and Support was received, the referendum will be rejected and the Decision Deposit will be returned. The proposal can be proposed again at any time.</p> <p>If a referendum continuously receives enough Approval and Support during the Confirm Period, it will be approved and move to the Enactment Period. It will wait the duration of the Enactment Period before it gets dispatched.</p> <p>The happy path for a proposal is shown in the following diagram:</p> <p></p>"},{"location":"learn/features/governance/#proposal-example-walkthrough","title":"Proposal Example Walkthrough","text":"<p>A proposal (with its preimage) is submitted for the General Admin Track on Moonriver would have the following characteristics:</p> <ul> <li>The Approval curve starts at 100% on Day 0, goes to 80% on Day 4</li> <li>The Support curve starts at 50% on Day 0, goes to 10% on Day 7</li> <li>A referendum starts the Decide Period with 0% \"Aye\" votes (nobody voted in the Lead-in Period)</li> <li>Token holders begin to vote and the Approval increases to a value above 80% by Day 4</li> <li>If the Approval and Support thresholds are met for the duration of the Confirm Period (14400 blocks, approximately 1 day), the referendum is approved</li> <li>If the Approval and Support thresholds are not met during the Decision Period, the proposal is rejected. Note that the thresholds need to be met for the duration of the Confirm Period. Consequently, if they are met but the Decision Period expires before the completion of the Confirm Period, the proposal is rejected</li> </ul> <p>The Approval and Support percentages can be calculated using the following:</p> ApprovalSupport <pre><code>Approval = 100 * ( Total Conviction-weighted \"Aye\" votes / Total Conviction-weighted votes ) \n</code></pre> <pre><code>Support = 100 * ( Total Aye + Abstain votes, ignoring conviction / Total supply )\n</code></pre>"},{"location":"learn/features/governance/#proposal-cancellations","title":"Proposal Cancellations","text":"<p>In the event that a proposal already in the voting stage is found to have an issue, it may be necessary to prevent its approval. These instances may involve malicious activity or technical issues that make the changes impossible to implement due to recent upgrades to the network.</p> <p>Cancellations must be voted on by the network to be executed. Cancellation proposals are faster than a typical proposal because they must be decided before the enactment of the proposal they seek to cancel, but they follow the same process as other referenda.</p> <p>There is a cancellation Origin for use against referenda that contain an unforeseen problem, called the Emergency Canceller. The Emergency Canceller Origin and the Root Origin are allowed to cancel referenda. Regardless of the Origin, if a proposal is cancelled, it gets rejected and the Decision Deposit gets refunded.</p> <p>In addition, there is a Kill Origin, which is for bad referenda intending to harm the network, called Emergency Killer. The Emergency Killer Origin and the Root Origin have the ability to kill referenda. In this case, a proposal is cancelled and the Decision Deposit is slashed, meaning the deposit amount is burned regardless of the Origin.</p>"},{"location":"learn/features/governance/#rights-of-the-opengov-technical-committee","title":"Rights of the OpenGov Technical Committee","text":"<p>On Polkadot, the Technical Committee from Governance v1 was replaced with the Fellowship, which is a \"mostly self-governing expert body with a primary goal of representing humans who embody and contain the technical knowledge base of the Kusama and/or Polkadot networks and protocol,\" according to Polkadot's wiki.</p> <p>For Moonbeam's implementation of OpenGov, instead of the Fellowship, there is a community OpenGov Technical Committee that has very similar power to that of the Fellowship. Their power in governance resides in their ability to whitelist a proposal. OpenGov Technical Committee members may only vote to whitelist a proposal if whitelisting that proposal would protect against a security vulnerability to the network. The passing threshold of the OpenGov Technical Committee members on whether to whitelist a proposal is determined by governance. As such, the OpenGov Technical Committee has very limited power over the network. Its purpose is to provide technical review of urgent security issues that are proposed by token holders.</p> <p>While still subject to governance, the idea behind the Whitelist track is that it will have different parameters to make it faster for proposals to pass. The Whitelist Track parameters, including approval, support, and voting, are determined by the Moonriver or Moonbeam token holders through governance and cannot be changed by the OpenGov Technical Committee.</p> <p>The OpenGov Technical Committee is made up of members of the community who have technical knowledge and expertise in Moonbeam-based networks.</p>"},{"location":"learn/features/governance/#try-it-out","title":"Related Guides on OpenGov","text":"<p>For related guides on submitting and voting on referenda on Moonbeam with OpenGov, please check the following guides:</p> <ul> <li>How to Submit a Proposal</li> <li>How to Vote on a Proposal</li> <li>Interact with the Preimages Precompiled Contract (Solidity Interface)</li> <li>Interact with the Referenda Precompiled Contract (Solidity Interface)</li> <li>Interact with the Conviction Voting Precompiled Contract (Solidity Interface)</li> </ul>"},{"location":"learn/features/randomness/","title":"Randomness on Moonbeam","text":""},{"location":"learn/features/randomness/#introduction","title":"Introduction","text":"<p>Randomness is necessary for a variety of blockchain applications to create unbiased, unpredictable, and unique outcomes. However, obtaining a reliable source of randomness is a challenge. Computers are deterministic, meaning given the same input, the same output will always be produced. Therefore, random values generated by computers are referred to as pseudo-random as they appear to be statistically random, but given the same input, the output can easily be repeated.</p> <p>Moonbeam utilizes verifiable random functions (VRF) to generate randomness that can be verified on-chain. A VRF is a cryptographic function that takes some input and produces random values, along with a proof of authenticity that they were generated by the submitter. The proof can be verified by anyone to ensure that the random values were generated correctly.</p> <p>There are two available sources of randomness that provide random inputs based on block producers' VRF keys and past randomness results: local VRF and BABE epoch randomness. Local VRF is determined directly within Moonbeam using the collator of the block's VRF key and the last block's VRF output. On the other hand, BABE epoch randomness is based on all the VRF produced by the relay chain validators during a complete epoch.</p> <p>You can interact with and request on-chain randomness using the Randomness Precompile contract, a Solidity interface that enables smart contract developers to access the randomness functionality through the Ethereum API. For more information, please check out the Interacting with the Randomness Precompile guide. You can also take a look at the Randomness Pallet, which can be used to obtain current randomness requests and results.</p>"},{"location":"learn/features/randomness/#general-definitions","title":"General Definitions","text":"<ul> <li>Epoch - a time duration in the BABE protocol that is broken into smaller time slots. Slots are discrete units of time six seconds in length. On Polkadot, one epoch lasts approximately 2,400 slots or 4 hours. On Kusama, one epoch lasts approximately 600 slots or 1 hour.</li> <li>Deposit - an amount of funds required to request random words. There is one deposit per request. Once the request has been fulfilled, the deposit will be returned to the account that requested the randomness</li> <li>Block expiration delay - the number of blocks that must pass before a local VRF request expires and can be purged</li> <li>Epoch expiration delay - the number of epochs that must pass before a BABE request expires and can be purged</li> <li>Minimum block delay - the minimum number of blocks before a request can be fulfilled for local VRF requests</li> <li>Maximum block delay - the maximum number of blocks before a request can be fulfilled for local VRF requests</li> <li>Maximum random words - the maximum number of random words being requested</li> <li>Epoch fulfillment delay - the delay in epochs before a request can be fulfilled for a BABE request</li> </ul>"},{"location":"learn/features/randomness/#quick-reference","title":"Quick Reference","text":"MoonbeamMoonriverMoonbase Alpha Variable Value Deposit 100 GLMR Block expiration delay 10000 blocks Epoch expiration delay 10000 epochs Minimum block delay 2 blocks Maximum block delay 2000 blocks Maximum random words 100 words Epoch fulfillment delay 2 epochs (following the current one) Variable Value Deposit 1 MOVR Block expiration delay 10000 blocks Epoch expiration delay 10000 epochs Minimum block delay 2 blocks Maximum block delay 2000 blocks Maximum random words 100 words Epoch fulfillment delay 2 epochs (following the current one) Variable Value Deposit 1 DEV Block expiration delay 10000 blocks Epoch expiration delay 10000 epochs Minimum block delay 2 blocks Maximum block delay 2000 blocks Maximum random words 100 words Epoch fulfillment delay 2 epochs (following the current one)"},{"location":"learn/features/randomness/#local-vrf","title":"Local VRF","text":"<p>Local VRF randomness is generated on a block-by-block basis at the beginning of the block using the previous block's VRF output along with the public key of the current block author's VRF key. The generated randomness result is stored and used to fulfill all randomness requests for the current block.</p> <p>You can request local VRF randomness using the <code>requestLocalVRFRandomWords</code> method of the Randomness Precompile.</p> <p>If your contract could have concurrent requests open, you can use the <code>requestId</code> returned from the <code>requestLocalVRFRandomWords</code> method to track which response is associated with which randomness request.</p>"},{"location":"learn/features/randomness/#babe-epoch-randomness","title":"BABE Epoch Randomness","text":"<p>BABE epoch randomness is based on a hash of the VRF values from the blocks produced in the relay chain epoch before last. On Polkadot, an epoch lasts for roughly 4 hours, and on Kusama, an epoch lasts for roughly 1 hour. The hashing is completed on the relay chain, and as such, it is not possible for a collator on Moonbeam to influence the randomness value unless they are also a validator on the relay chain and were responsible for producing the last output included in an epoch.</p> <p>The randomness remains constant during an epoch. If a collator skips block production, the next eligible collator can fulfill the request using the same random value.</p> <p>You can request BABE epoch randomness using the <code>requestRelayBabeEpochRandomWords</code> method of the Randomness Precompile. In order to generate unique randomness, a different salt must be provided to the <code>requestRelayBabeEpochRandomWords</code> function.</p> <p>At the beginning of each relay chain epoch change, the randomness from one epoch ago is read from the relay chain state proof and used to fulfill all randomness requests that are due in the current block.</p>"},{"location":"learn/features/randomness/#request-and-fulfill-process","title":"Request &amp; Fulfill Process","text":"<p>In general, the request and fulfill process for randomness is as follows:</p> <ol> <li>Pay the deposit required to request random words</li> <li> <p>Request the randomness either using the local VRF or BABE epoch source of randomness. When requesting randomness you'll need to specify a few things:</p> <ul> <li>a refund address where any excess fees will be sent to</li> <li>the amount of fees which will be set aside to pay for fulfillment. If the specified amount is not enough you can always increase the request fees later, or if it's more than enough you'll be refunded the excess fees to the specified address after fulfillment</li> <li>a unique salt that will be used to generate different random words</li> <li>the number of random words you would like to request</li> <li>for local VRF, the delay period in blocks, which is used to increase unpredictability. It must be between the minimum and maximum number of blocks as listed above. For BABE epoch randomness, you do not need to specify a delay but can fulfill the request after the epoch delay has passed</li> </ul> </li> <li> <p>Wait for the delay period to pass</p> </li> <li>Fulfill the randomness request, which triggers the random words to be computed using the current block's randomness result and the given salt. This can manually be done by anyone using the fee that was initially set aside for the request</li> <li>For fulfilled requests, the random words are returned and the cost of execution will be refunded from the request fee to the address that initiated the fulfillment. Then any excess fees and the request deposit are transferred to the specified refund address</li> </ol> <p>If a request expires it can be purged by anyone. When this happens, the request fee is paid out to the address that initiated the purge and the deposit is returned to the original requester.</p> <p>The happy path for a randomness request is shown in the following diagram:</p> <p></p>"},{"location":"learn/features/randomness/#security-considerations","title":"Security Considerations","text":"<p>A method with the ability to call your <code>fulfillRandomness</code> method directly could spoof a VRF response with any random value, so it's critical that it can only be directly called by the <code>RandomnessConsumer.sol</code> contract's <code>rawFulfillRandomness</code> method.</p> <p>For your users to trust that your contract's random behavior is free from malicious interference, it's best if you can write it so that all behaviors implied by a VRF response are executed during your <code>fulfillRandomness</code> method. If your contract must store the response (or anything derived from it) and use it later, you must ensure that any user-significant behavior which depends on that stored value cannot be manipulated by a subsequent VRF request.</p> <p>Similarly, the collators have some influence over the order in which VRF responses appear on the blockchain, so if your contract could have multiple VRF requests in flight simultaneously, you must ensure that the order in which the VRF responses arrive cannot be used to manipulate your contract's user-significant behavior.</p> <p>Since the output of the random words generated for <code>requestLocalVRFRandomWords</code> is dependent on the collator producing the block at fulfillment, the collator could skip its block, forcing the fulfillment to be executed by a different collator and therefore generating a different VRF. However, such an attack would incur the cost of losing the block reward to the collator. It is also possible for a collator to be able to predict some of the possible outcome of the VRF if the delay between the request and the fulfillment is too short. It is for this reason that you can choose to provide a higher delay.</p> <p>Since the output of the random words generated for <code>requestRelayBabeEpochRandomWords</code> is dependent on the relay chain validator producing the blocks during an epoch, it is possible for the last validator of an epoch to choose between two possible VRF outputs by skipping the production of a block. However, such an attack would incur the cost of losing the block reward to the validator. It is not possible for a parachain collator to predict or influence the output of the relay chain VRF, not to censor the fulfillment, as long as there is one honest collator.</p>"},{"location":"learn/features/staking/","title":"Staking on Moonbeam","text":""},{"location":"learn/features/staking/#introduction","title":"Introduction","text":"<p>Moonbeam uses a block production mechanism based on Polkadot's Proof-of-Stake model, where there are collators and validators. Collators maintain parachains (in this case, Moonbeam) by collecting transactions from users and producing state transition proofs for the relay chain validators.</p> <p>The candidates in the active set of collators (nodes that produce blocks) are selected based on their stake in the network. And here is where staking comes in.</p> <p>Collator candidates (and token holders if they delegate) have a stake in the network. The top N candidates by staked amount are chosen to produce blocks with a valid set of transactions, where N is a configurable parameter. Part of each block reward goes to the collators that produced the block, who then share it with the delegators considering their percental contributions towards the collator's stake. In such a way, network members are incentivized to stake tokens to improve the overall security. Since staking is done at a protocol level through the staking interface, if you choose to delegate, the collators you delegate to do not have access to your tokens.</p> <p>To easily manage staking related actions, you can visit the Moonbeam Network DApp and use the network tabs at the top of the page to easily switch between Moonbeam networks. To learn how to use the DApp, you can check out the How to Stake MOVR Tokens guide or video tutorial, both of which can be adapted for the Moonbeam and the Moonbase Alpha TestNet.</p>"},{"location":"learn/features/staking/#general-definitions","title":"General Definitions","text":"<p>Some important parameters to understand in relation to the staking system on Moonbeam include:</p> <ul> <li>Round \u2014 a specific number of blocks around which staking actions are enforced. For example, new delegations are enacted when the next round starts. When bonding less or revoking delegations, funds are returned after a specified number of rounds</li> <li>Candidates - node operators that are eligible to become block producers if they can acquire enough stake to be in the active set</li> <li>Collators \u2014 active set of candidates that are selected to be block producers. They collect transactions from users and produce state transition proofs for the relay chain to validate</li> <li>Delegators \u2014 token holders who stake tokens, vouching for specific collator candidates. Any user that holds a minimum amount of tokens as free balance can become a delegator</li> <li>Minimum delegation per candidate \u2014 minimum amount of tokens to delegate candidates once a user is in the set of delegators</li> <li>Maximum delegators per candidate \u2014 maximum number of delegators, by staked amount, that a candidate can have which are eligible to receive staking rewards</li> <li>Maximum delegations \u2014 maximum number of candidates a delegator can delegate</li> <li>Exit delay - an exit delay is the amount of rounds before a candidate or delegator can execute a scheduled request to decrease or revoke a bond, or leave the set of candidates or delegators</li> <li>Reward payout delay - a certain amount of rounds must pass before staking rewards are distributed automatically to the free balance</li> <li>Reward pool - a portion of the annual inflation that is set aside for collators and delegators</li> <li>Collator commission - default fixed percent a collator takes off the top of the due staking rewards. Not related to the reward pool</li> <li>Delegator rewards \u2014 the aggregate delegator rewards distributed over all eligible delegators, taking into account the relative size of stakes (read more)</li> <li>Auto-compounding - a setting that automatically applies a percentage of a delegator's rewards to their total amount delegated</li> <li>Slashing \u2014 a mechanism to discourage collator misbehavior, where typically the collator and their delegators get slashed by losing a percentage of their stake. Currently, there is no slashing but this can be changed through governance. Collators who produce blocks that are not finalized by the relay chain won't receive rewards</li> </ul>"},{"location":"learn/features/staking/#quick-reference","title":"Quick Reference","text":"MoonbeamMoonriverMoonbase Alpha Variable Value Round duration 1800 blocks (6 hours) Minimum delegation per candidate 50 GLMR Maximum delegators per candidate 300 Maximum delegations 100 Reward payout delay 2 rounds (12 hours) Add or increase delegation takes effect in the next round (funds are withdrawn immediately) Decrease delegation delay 28 rounds (168 hours) Revoke delegations delay 28 rounds (168 hours) Leave delegators delay 28 rounds (168 hours) Variable Value Round duration 600 blocks (2 hours) Minimum delegation per candidate 5 MOVR Maximum delegators per candidate 300 Maximum delegations 100 Reward payout delay 2 rounds (4 hours) Add or increase delegation takes effect in the next round (funds are withdrawn immediately) Decrease delegation delay 24 rounds (48 hours) Revoke delegations delay 24 rounds (48 hours) Leave delegators delay 24 rounds (48 hours) Variable Value Round duration 1200 blocks (2 hours) Minimum delegation per candidate 1 DEV Maximum delegators per candidate 300 Maximum delegations 100 Reward payout delay 2 rounds (4 hours) Add or increase delegation takes effect in the next round (funds are withdrawn immediately) Decrease delegation delay 2 rounds (4 hours) Revoke delegations delay 2 rounds (4 hours) Leave delegators delay 2 rounds (4 hours) <p>Note</p> <p>As of runtime 3000, asynchronous backing has been enabled on all Moonbeam networks. As a result, the target block time was reduced from 12 seconds to 6 seconds, which may break some timing-based assumptions.</p> <p>To learn how to get the current value of any of the parameters around staking, check out the Retrieving Staking Parameters section of the How to Stake your Tokens guide.</p> <p>If you're looking for candidate or collator-specific requirements and information, you can take a look at the Collators guide.</p>"},{"location":"learn/features/staking/#resources-for-selecting-a-collator","title":"Resources for Selecting a Collator","text":"<p>There are a few resources you can check out to help you select a collator to delegate:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Stake GLMR Dashboard Stake GLMR Collators Leaderboard Moonscan Collator Dashboard DappLooker Variable Value Stake MOVR Dashboard Stake MOVR Collators Leaderboard Moonscan Collator Dashboard DappLooker Variable Value List of candidates Moonbase Alpha Subscan <p>Note</p> <p>The DappLooker Collator dashboard for Moonriver is experimental beta software and may not accurately reflect collator performance. Be sure to do your own research before delegating to a collator.</p>"},{"location":"learn/features/staking/#general-tips","title":"General Tips","text":"<ul> <li>To optimize your staking rewards, you should generally choose a collator with a lower total amount bonded. In that case, your delegation amount will represent a larger portion of the collator\u2019s total stake and you will earn proportionally higher rewards. However, there is a higher risk of the collator being kicked out of the active set and not earning rewards at all</li> <li>The minimum bond for each collator tends to increase over time, so if your delegation is close to the minimum, there is a higher chance you might fall below the minimum and not receive rewards</li> <li>Spreading delegations between multiple collators is more efficient in terms of rewards, but only recommended if you have enough to stay above the minimum bond of each collator</li> <li>You can consider collator performance by reviewing the number of blocks each collator has produced recently</li> <li>You can set up auto-compounding which will automatically restake a specified percentage of your delegation rewards</li> </ul>"},{"location":"learn/features/staking/#reward-distribution","title":"Reward Distribution","text":"<p>Rewards for collators and their delegators are calculated at the start of every round for their work prior to the reward payout delay. For example, on Moonriver the rewards are calculated for the collators work from 2 rounds ago.</p> <p>The calculated rewards are then paid out on a block-by-block basis starting at the second block of the round. For every block, one collator will be chosen to receive their entire reward payout from the prior round, along with their delegators, until all rewards have been paid out for that round. For example, if there are 72 collators who produced blocks in the prior round, all of the collators and their delegators will be paid by block 73 of the new round.</p> <p>You can choose to auto-compound your delegation rewards so you no longer have to manually delegate rewards. If you choose to set up auto-compounding, you can specify the percentage of rewards to be auto-compounded. These rewards will then be automatically added to your delegation.</p>"},{"location":"learn/features/staking/#annual-inflation","title":"Annual Inflation","text":"<p>The distribution of the annual inflation goes as follows:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Annual inflation 5% Rewards pool for collators and delegators 50% of the annual inflation Collator commission 20% of the annual inflation Parachain bond reserve 30% of the annual inflation Variable Value Annual inflation 5% Rewards pool for collators and delegators 50% of the annual inflation Collator commission 20% of the annual inflation Parachain bond reserve 30% of the annual inflation Variable Value Annual inflation 5% Rewards pool for collators and delegators 50% of the annual inflation Collator commission 20% of the annual inflation Parachain bond reserve 30% of the annual inflation <p>From the rewards pool, collators get the rewards corresponding to their stake in the network. The rest are distributed among delegators by stake.</p>"},{"location":"learn/features/staking/#calculating-rewards","title":"Calculating Rewards","text":"<p>Mathematically speaking, for collators, the reward distribution per block proposed and finalized would look like this:</p> <p></p> <p>Where <code>amount_due</code> is the corresponding inflation being distributed in a specific block, the <code>stake</code> corresponds to the number of tokens bonded by the collator in respect to the total stake of that collator (accounting delegations).</p> <p>For each delegator, the reward distribution (per block proposed and finalized by the delegated collator) would look like this:</p> <p></p> <p>Where <code>amount_due</code> is the corresponding inflation being distributed in a specific block, the <code>stake</code> corresponds to the amount of tokens bonded by each delegator in respect to the total stake of that collator.</p>"},{"location":"learn/features/staking/#risks","title":"Risks","text":"<p>Holders of MOVR/GLMR tokens should perform careful due diligence on collators before delegating. Being listed as a collator is not an endorsement or recommendation from the Moonbeam Network, the Moonriver Network, or Moonbeam Foundation. Neither the Moonbeam Network, Moonriver Network, nor Moonbeam Foundation has vetted the list collators and assumes no responsibility with regard to the selection, performance, security, accuracy, or use of any third-party offerings.  You alone are responsible for doing your own diligence to understand the applicable fees and all risks present, including actively monitoring the activity of your collators.</p> <p>You agree and understand that neither the Moonbeam Network, the Moonriver Network, nor Moonbeam Foundation guarantees that you will receive staking rewards and any applicable percentage provided (i) is an estimate only and not guaranteed, (ii) may change at any time and (iii) may be more or less than the actual staking rewards you receive. The Moonbeam Foundation makes no representations as to the monetary value of any rewards at any time.</p> <p>Staking MOVR/GLMR tokens is not free of risk. Staked MOVR/GLMR tokens are locked up, and retrieving them requires a 2 day/7 day waiting period . Additionally, if a collator fails to perform required functions or acts in bad faith, a portion of their total stake can be slashed (i.e. destroyed). This includes the stake of their delegators. If a collators behaves suspiciously or is too often offline, delegators can choose to unbond from them or switch to another collator. Delegators can also mitigate risk by electing to distribute their stake across multiple collators.</p>"},{"location":"learn/features/treasury/","title":"Treasury on Moonbeam","text":""},{"location":"learn/features/treasury/#introduction","title":"Introduction","text":"<p>The Moonbeam Treasury is an on-chain collection of funds launched at the network's genesis. Initially pre-funded with 0.5% of the token supply, the Treasury continues to accumulate GLMR as 80% of the parachain bond reserve inflation goes to the Treasury. For more information about Moonbeam inflation figures, see GLMR Tokenomics.</p> <p>The Moonbeam Treasury funds initiatives that support and grow the network. Stakeholders can propose spending requests for Treasury Council review, focusing on efforts like integrations, collaborations, community events, and outreach. Treasury spend proposers must submit their proposals to the Moonbeam Forum. For submission details, see How to Propose a Treasury Spend.</p> <p>The Treasury Council oversees the spending of the Moonbeam Treasury and votes on funding proposals. It comprises two members from the Moonbeam Foundation and three external community members. The three external members are elected to terms of 6 months. The same Treasury Council oversees Treasury requests for both Moonbeam and Moonriver. The Council meets monthly to review proposals submitted on the Moonbeam Forum. Once a proposal is agreed upon, the Council members must complete the on-chain approval process.</p>"},{"location":"learn/features/treasury/#general-definitions","title":"General Definitions","text":"<p>Some important terminology to understand regarding treasuries:</p> <ul> <li>Treasury Council \u2014 a group of Moonbeam Foundation representatives and external community members. The Council reviews funding proposals, ensures alignment with the community, and ultimately authorizes Treasury spending</li> <li>Proposal \u2014 a plan or suggestion submitted by stakeholders to further the network to be approved by the Treasury Council</li> </ul>"},{"location":"learn/features/treasury/#treasury-addresses","title":"Treasury Addresses","text":"<p>The Treasury address for each respective network can be found below:</p> MoonbeamMoonriverMoonbase Alpha <p>0x6d6F646c70632f74727372790000000000000000</p> <p>0x6d6f646C70792f74727372790000000000000000</p> <p>0x6d6F646c70632f74727372790000000000000000</p>"},{"location":"learn/features/treasury/#roadmap-of-a-treasury-proposal","title":"Roadmap of a Treasury Proposal","text":"<p>The happy path of a Treasury spend request is as follows:</p> <ol> <li> <p>Proposal submission - the user submits a proposal to the Moonbeam Forum</p> </li> <li> <p>Forum discussion - the proposal is discussed by the community on the Forum. The ultimate Aye/Nay decision is determined by the Treasury council</p> </li> <li> <p>Treasury approval and action - if the Treasury Council agrees, it authorizes the Treasury spending and moves the process forward</p> </li> </ol>"},{"location":"learn/features/treasury/#treasury-council-voting-process","title":"Treasury Council Voting Process","text":"<p>A member of the Treasury Council will submit a <code>treasury.spend</code> call. This call requires specifying the amount, the asset type, and the beneficiary account to receive the funds. The Treasury supports spending various token types beyond GLMR, including native USDT/USDC. Once this extrinsic is submitted, a new Treasury Council collective proposal will be created and made available for council members to vote on. Once approved through the Treasury Council's internal voting process, the funds will be released automatically to the beneficiary account through the <code>treasury.payout</code> extrinsic.</p> <p>Note</p> <p>There is no on-chain action for the proposer or beneficiary of the Treasury spend request. All Treasury spend actions will be completed by members of the Treasury Council.</p> <p>Note that this process has changed significantly from prior Treasury processes, where tokenholders could submit Treasury proposals with bonds attached. Now, no on-chain action is necessary to submit a Treasury proposal. Rather, all that is needed is to raise a Treasury Council request on the Moonbeam Forum and the Treasury Council will take care of the on-chain components. </p> <p>For more information, see How to Propose a Treasury Spend</p>"},{"location":"learn/features/xchain-plans/","title":"Cross-Chain Communication Methods","text":"<p>Moonbeam makes it easy for developers to build smart contracts that connect across chains, both within the Polkadot ecosystem and outside the Polkadot ecosystem. This page will provide an overview of the underlying protocols that enable cross-chain communication and how you can leverage them to build connected contracts. For step-by-step guides of how to put these principles into practice, be sure to check out the interoperability tutorials.</p> <p>Two key terms that will come up frequently in this guide are XCM and GMP. XCM refers to cross-consensus messaging, and it's Polkadot's native interoperability language that facilitates communication between Polkadot blockchains. You can read more about the standardized XCM message format and How to Get Started Building with XCM.</p> <p>GMP, or general message passing, refers to the sending and receiving of messages within decentralized blockchain networks. While XCM is a type of general message passing, GMP colloquially refers to cross-chain communication between Moonbeam and blockchains outside of Polkadot. Similarly, in this guide, XCM refers to cross-chain messaging within Polkadot, and GMP refers to cross-chain messaging between Moonbeam and other ecosystems outside of Polkadot.</p>"},{"location":"learn/features/xchain-plans/#quick-reference","title":"Quick Reference","text":"Comparison of XCM vs GMP Specification XCM GMP Scope Polkadot and its connected parachains Any blockchain supported by a GMP provider Provider Polkadot Axelar, Wormhole, LayerZero, Hyperlane, etc. Implementation XCM Virtual Machine Smart contracts Security Polkadot's shared security Proprietary consensus determined by GMP provider Fees Purchased with <code>BuyExecution</code> XCM instruction with supported asset User sends value with transaction to pay for gas on the destination chain Adding New Chains Requires creation of XCM channels by both connected chains Requires GMP provider to add support"},{"location":"learn/features/xchain-plans/#xcm-transport-methods","title":"XCM Transport Methods","text":"<p>XCMP is the protocol that carries messages conforming to the XCM standard. The difference between the two is easy to remember with the added letter \"P\" for protocol. While XCM is the language that defines the format of the message to send, XCMP can be thought of as the pipes that enable the delivery of said messages.</p> <p>XCMP is comprised of channels that enable communication between connected blockchains. When a parachain launches on Polkadot, two XCM channels are established automatically to allow for communication between the Polkadot relay chain and the parachain itself. XCM channels are omnidirectional, so two channels must be established for bidirectional communication. </p> <p>Polkadot parachains can optionally choose to establish additional XCM channels with other parachains. Establishing XCM channels with other chains is a double opt-in process, so the receiving chain must also agree to have the channel established. Establishing XCM channels with another parachain allows for the exchange of XCM messages, enabling the flow of cross-chain assets and remote contract calls, to name a few examples. </p> <p>There are several different subcategories of XCM transport methods, including:</p>"},{"location":"learn/features/xchain-plans/#vmp","title":"VMP","text":"<p>VMP, or Vertical Message Passing, refers to message passing between the relay chain and a parachain. Given that XCM channels are one-way, there are two types of message passing that comprise VMP, namely:  </p> <ul> <li>UMP - Upward Message Passing refers to message passing from a parachain to the relay chain</li> <li>DMP - Downward Message Passing refers to message passing from the relay chain to a parachain</li> </ul>"},{"location":"learn/features/xchain-plans/#HRMP","title":"HRMP","text":"<p>Horizontal Relay-routed Message Passing (HRMP) is a temporary protocol that is currently being used while XCMP (Cross-Chain Message Passing) is still under development. HRMP serves as a placeholder and provides the same functionality and interface as XCMP. However, HRMP is more resource-intensive because it stores all messages within the Relay Chain's storage. </p> <p>When opening XCM channels with other parachains today, those channels are using HRMP in place of the aforementioned XCMP. Once the implementation of XCMP is complete, the plan is to phase out HRMP and replace it with XCMP gradually. For more information about each one, be sure to check out Polkadot's Guide to XCM Transport.</p>"},{"location":"learn/features/xchain-plans/#general-message-passing","title":"General Message Passing","text":"<p>As you know, GMP colloquially refers to cross-chain communication between Moonbeam and other blockchains outside of Polkadot. General message passing is enabled by cross-chain protocols that specialize in cross-chain communication. Each GMP provider takes a slightly different approach, but conceptually, they are quite similar. There are different contracts and functions for each provider, but each GMP provider has the same end goal: to provide secure and reliable cross-chain communication.  </p>"},{"location":"learn/features/xchain-plans/#happy-path-of-a-cross-chain-message","title":"Happy Path of a Cross-Chain Message","text":"<p>At a high level, the happy path of a message sent via GMP is as follows. A user or developer will call a contract specific to the GMP protocol, sometimes referred to as a mailbox contract or a gateway contract. This call typically includes parameters like the destination chain, the destination contract address, and includes sufficient value to pay for the transaction on the destination chain. A GMP provider listens for specific events on the origin blockchain pertaining to their gateway or mailbox contracts that indicate that a user wants to send a cross-chain message using their protocol. The GMP provider will validate certain parameters, including whether or not sufficient value was provided to pay for gas on the destination chain. In fact, the GMP provider may have a decentralized network of many nodes checking the authenticity of the message and verifying parameters. The GMP provider will not validate the integrity of the contract call to be delivered on the destination chain. E.g., the GMP provider will happily deliver a valid, paid-for message that contains a smart contract call that reverts on arrival. Finally, if everything checks out according to the consensus mechanism of the GMP provider, the message will be delivered to the destination chain, triggering the respective contract call at the destination.</p> <p> </p>"},{"location":"learn/features/xchain-plans/#gmp-providers-integrated-with-moonbeam","title":"GMP Providers Integrated with Moonbeam","text":"<p>A large number of GMP providers have integrated with Moonbeam, which is beneficial for several reasons. For one, it enables you to work with whichever GMP provider you prefer. Second, it means that Moonbeam is connected to a rapidly growing number of chains. Whenever a GMP provider integrated with Moonbeam adds support for another chain, Moonbeam is automatically now connected with that chain. GMP providers are constantly adding support for new chains, and it's exciting to see those new integrations benefit the Moonbeam community. Additionally, having a variety of GMP providers allows for redundancy and backup. GMP providers have occasional maintenance windows or downtime; thus, it may make sense to add support for multiple GMP providers to ensure consistent uptime. </p> <p>A significant number of GMP providers have integrated with Moonbeam, offering multiple benefits. Firstly, this integration allows users the flexibility to choose their preferred GMP provider. Secondly, Moonbeam's connectivity is enhanced as it automatically links with any new chains that its GMP providers support. Given that GMP providers frequently expand their support to new chains, the continuous roll out of new chains is a promising ongoing benefit for the Moonbeam community. Additionally, the diversity of GMP providers ensures better reliability and backup options. Since GMP providers can occasionally experience downtime or scheduled maintenance, the ability to integrate with multiple GMP providers is an important benefit.</p> <p>The following GMP providers have integrated with Moonbeam: </p> <ul> <li>Axelar</li> <li>Hyperlane</li> <li>LayerZero </li> <li>Wormhole</li> </ul>"},{"location":"learn/features/xchain-plans/#implementing-both-xcm-and-gmp","title":"Implementing Both XCM and GMP","text":"<p>Building with XCM or GMP does not preclude building with the other. As they suit different use cases, a team may seek to utilize XCM to handle interoperability needs within Polkadot, and GMP to deliver cross-chain messages to and from blockchains outside of Polkadot. As an example, several DEXes on Moonbeam support the trading of tokens migrated to Moonbeam via XCM, such as xcDOT, and assets bridged from ecosystems outside of Polkadot, such as USDC via Wormhole. </p>"},{"location":"learn/features/xchain-plans/#moonbeam-routed-liquidity","title":"Moonbeam Routed Liquidity","text":"<p>Moonbeam Routed Liquidity (MRL) enables seamless liquidity between external blockchains connected to Moonbeam via Wormhole to Polkadot parachains connected to Moonbeam via XCM. This combination of GMP and XCM means that any ERC-20 token on a chain that Wormhole has integrated with can be routed through Moonbeam to a destination parachain (and back). A diagram of the happy path of a token transfer to a parachain via MRL is shown below, and you can find more information at the MRL docs. </p> <p> </p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"learn/platform/code/","title":"Moonbeam Source Code","text":"<p>Moonbeam is an open source project.  The main Moonbeam repo can be found here:</p> <p> https://github.com/moonbeam-foundation/moonbeam</p> <p>Moonbeam is implemented using the Substrate framework. The source code for Substrate can be found here:</p> <p> https://github.com/paritytech/substrate</p> <p>We also work on Ethereum compatibility features along with engineers from Parity as part of the Frontier project. Source code for Frontier can be found here:</p> <p> https://github.com/polkadot-evm/frontier</p> <p>If you are interested in contributing code to Moonbeam, please raise an issue or PR on the Moonbeam GitHub repository</p>"},{"location":"learn/platform/glossary/","title":"Glossary","text":"<p>There's a great deal of terminology that's specific to Polkadot, Substrate, and the emerging Parity/Web3 ecosystem. We've compiled a list of terms we think you'll want to know as you review the Moonbeam documentation, plans, and tutorials.</p>"},{"location":"learn/platform/glossary/#collators","title":"Collators","text":"<p>One of the key network participants needed to support parachains within the Polkadot Network.  In Moonbeam, collators are the nodes that are responsible for block production and for submitting produced blocks up to the Polkadot relay chain for finalization.</p>"},{"location":"learn/platform/glossary/#delegators","title":"Delegators","text":"<p>Moonbeam token holders who stake tokens, vouching for specific collator candidates on the parachain. Any user that holds a minimum amount of tokens as free balance can become a delegator by staking their tokens.</p>"},{"location":"learn/platform/glossary/#nominators","title":"Nominators","text":"<p>Relay chain token holders who select to \"back\" a validator. They can receive part of the validator's reward, but are subject to slashing of their staked tokens in case the validator misbehaves. A nominator can back up to 16 validators, and their bond is fully distributed between the backed validators that were selected for the validator set.</p>"},{"location":"learn/platform/glossary/#nominated-proof-of-stake","title":"Nominated Proof of Stake","text":"<p>The mechanism used by Polkadot for selecting its block validator set to maximize chain security. At its core, it is a Proof-of-Stake system (PoS) in which nominators back validators. The latter with the highest backing are selected to be part of the validator set for a session. The stake of a validator is slashed in case of misbehavior. Thus, nominators are expected to do due diligence on the validators they nominate.</p>"},{"location":"learn/platform/glossary/#parachains","title":"Parachains","text":"<p>A blockchain which has a slot and is connected to Polkadot. Parachains receive shared security from Polkadot and the ability to interact with other parachains on the Polkadot network. They must lock DOT, the native relay chain token, to secure a slot for a specific period (up two years).</p>"},{"location":"learn/platform/glossary/#parathreads","title":"Parathreads","text":"<p>A blockchain which can connect to Polkadot.  Parathreads are able to interact with other members of the Polkadot network, but they bid for block finalization (in DOT) on a block-to-block basis. They compete with other parathreads for block finalization, meaning that the block with the highest bid is selected to be finalize in that round.</p>"},{"location":"learn/platform/glossary/#polkadot","title":"Polkadot","text":"<p>A network of connected blockchains that provides shared security and the ability to interact between chains.  Polkadot is built using the Substrate development framework.  Chains that connect to Polkadot are called parachains.</p>"},{"location":"learn/platform/glossary/#relay-chain","title":"Relay Chain","text":"<p>The backbone blockchain supporting the Polkadot network.  Parachains connect to the relay chain and use it for shared security and message passing.  Validators on the relay chain help secure the parachains.</p>"},{"location":"learn/platform/glossary/#smart-contract","title":"Smart Contract","text":"<p>A smart contract is a computer program or a transaction protocol that is intended to automatically execute, control, or document legally relevant events and actions according to the terms of a contract or an agreement. Smart contracts intend to reduce the need for trusted intermediators, arbitrations, and enforcement costs, as well as reduce fraud losses and malicious and accidental exceptions.</p>"},{"location":"learn/platform/glossary/#substrate","title":"Substrate","text":"<p>A Rust-based blockchain development framework created by Parity Technologies based on their experience implementing multiple blockchain clients.  Substrate comes with many modules and functionalities that are needed when building a blockchain, including P2P networking, consensus mechanisms, staking, cryptocurrency, on-chain governance modules, and more.  It dramatically reduces the time and engineering effort required to implement a blockchain. Substrate is now part of the Polkadot SDK.</p>"},{"location":"learn/platform/glossary/#substrate-frame-pallets","title":"Substrate Frame Pallets","text":"<p>Substrate Frame Pallets are a collection of Rust-based modules, providing the functionality required for building a blockchain.  </p>"},{"location":"learn/platform/glossary/#validators","title":"Validators","text":"<p>A node that secures the Polkadot relay chain by staking DOT in the network, which is slashed if they misbehave. They finalize blocks from collators on parachains and also participate on consensus for the next relay chain block with other validators.</p>"},{"location":"learn/platform/glossary/#webassemblywasm","title":"WebAssembly/Wasm","text":"<p>WebAssembly is an open standard that defines a portable binary code format. It is supported by different programming languages, compilers, and browsers.</p>"},{"location":"learn/platform/links/","title":"Links","text":"<ul> <li>Polkadot Docs - starting point for learning about the Polkadot SDK, a Rust-based framework for developing blockchains. Moonbeam is developed using Substrate and uses many of the modules that come with it</li> <li>Polkadot.com - learn about Polkadot, including the vision behind the network and how the system works, i.e., staking, governance, etc.</li> <li>Polkadot-JS Apps - a web-based interface for interacting with Substrate based nodes, including Moonbeam</li> <li>Solidity Docs - Solidity is the main smart contract programming language supported by Ethereum and Moonbeam.  The Solidity docs site is very comprehensive</li> <li>Remix - web-based IDE for Solidity smart contract development that is compatible with Moonbeam</li> <li>Hardhat - development tools for Solidity, including debugging, testing, and automated deployment that is compatible with Moonbeam</li> </ul>"},{"location":"learn/platform/technology/","title":"Technology &amp; Architecture","text":""},{"location":"learn/platform/technology/#the-moonbeam-development-stack","title":"The Moonbeam Development Stack","text":"<p>Moonbeam is a smart contract blockchain platform built in the Rust programming language using the Substrate framework. Substrate, developed by Parity Technologies (the original founding contributors of Polkadot), is an open-source, modular SDK for creating blockchains. Substrate allows developers to customize their blockchains while still benefiting from features such as forkless upgrades, shared security (when connected as a parachain to Polkadot or Kusama), and an extensive library of pre-built runtime modules known as pallets.</p>"},{"location":"learn/platform/technology/#rust-programming-language","title":"Rust Programming Language","text":"<p>Rust is a good language for implementing a blockchain. It is highly performant like C and C++ but has built-in memory safety features enforced at compile time, preventing many common bugs and security issues arising from C and C++ implementations.</p>"},{"location":"learn/platform/technology/#substrate-framework","title":"Substrate Framework","text":"<p>Substrate provides a rich set of tools for creating blockchains, including a runtime execution environment that enables a generic state transition function and a pluggable set of modules (pallets) that implement various blockchain subsystems. By using Substrate, Moonbeam can leverage several key features offered to parachains launched on the Polkadot relay chain, including:</p> <ul> <li>Shared security \u2014 Polkadot's validators secure all parachains  </li> <li>Cross-Consensus Messaging (XCM) \u2014 native interoperability with other parachains  </li> <li>Flexible upgrades \u2014 Substrate\u2019s forkless upgrade mechanism</li> </ul> <p>Pallets are at the heart of Substrate-based chains, providing specific functionality in modular form. Examples include:</p> <ul> <li>Balances pallet \u2014 manages account balances and transfers  </li> <li>Assets pallet \u2014 handles the creation and management of on-chain fungible assets  </li> <li>Consensus pallets \u2014 provide mechanisms like AURA or BABE for block production  </li> <li>Governance pallets \u2014 facilitate on-chain governance  </li> <li>Frontier pallets \u2014 the Ethereum compatibility layer pioneered by the Moonbeam team  </li> <li>Parachain Staking pallet \u2014 enables Delegated Proof of Stake (DPoS)  </li> </ul> <p>In addition to these pallets provided by Polkadot's Substrate, developers can create their own pallets to add custom functionality. Moonbeam leverages multiple existing Substrate frame pallets as well as several custom pallets for features such as cross-chain token integration, the Orbiter Program, and more. You can find the Moonbeam runtime (built using Substrate) and related pallets in the Moonbeam GitHub repository.</p> <p>Moonbeam also uses the Cumulus library to facilitate integration with the Polkadot relay chain.</p>"},{"location":"learn/platform/technology/#frontier","title":"Frontier: Substrate's Ethereum Compatibility Layer","text":"<p>Frontier serves as Substrate's Ethereum compatibility layer, facilitating the seamless operation of standard Ethereum DApps on Substrate-based chains without requiring modifications. This compatibility is achieved by integrating specialized Substrate pallets into the Substrate runtime. These pallets include:</p> <ul> <li>EVM pallet \u2014 responsible for executing EVM operations  </li> <li>Ethereum pallet \u2014 manages block data storage and offers RPC compatibility  </li> <li>Base Fee pallet and Dynamic Fee pallet \u2014 provide EIP-1559 functionality (not used in Moonbeam)</li> </ul> <p>Moonbeam uses the EVM and Ethereum pallets to achieve full Ethereum compatibility. Instead of the Base Fee or Dynamic Fee pallets, Moonbeam has its own dynamic fee mechanism for base fee calculations. Basing the EVM implementation on the Substrate EVM Pallet provides a Rust-based EVM engine and support from the Parity engineering team.</p>"},{"location":"learn/platform/technology/#blockchain-runtime","title":"Blockchain Runtime","text":"<p>The core Moonbeam runtime specifies the state transition function and behavior of the Moonbeam blockchain. The runtime is built using FRAME, compiled to a WebAssembly (Wasm) binary as well as a native binary. These compiled versions are executed in the Polkadot relay chain and Moonbeam node environments.</p> <p>Note</p> <p>Substrate FRAME pallets are a collection of Rust-based modules that provide the functionality required when building a blockchain. WebAssembly is an open standard that defines a portable binary code format. Different programming languages, compilers, and browsers support it. Find more definitions in our glossary.</p> <p>Some of the key Substrate FRAME pallets used in the Moonbeam runtime include:</p> <ul> <li>Balances \u2014 support for accounts, balances, and transfers  </li> <li>EVM \u2014 a full Rust-based EVM implementation based on SputnikVM (part of Frontier)  </li> <li>Ethereum \u2014 provides emulation of Ethereum block processing for the EVM (part of Frontier)  </li> <li>Executive \u2014 orchestration layer that dispatches calls to other runtime modules  </li> <li>Identity \u2014 support for setting on-chain identities for account addresses  </li> <li>System \u2014 provides low-level types, storage, and blockchain functions  </li> <li>Treasury \u2014 on-chain treasury that can be used to fund public goods such as a parachain slot  </li> </ul> <p>In addition to these Substrate FRAME Pallets, Moonbeam implements custom pallets to achieve additional functionality, such as:</p> <ul> <li>Parachain Staking \u2014 enables a Delegated Proof of Stake (DPoS) system  </li> <li>Moonbeam Orbiters \u2014 supports the Orbiter Program, which diversifies the collator pool  </li> <li>XCM Transactor \u2014 simplifies remote cross-chain calls via Cross-Consensus Messaging (XCM) </li> <li>Asset Manager \u2014 registers XCM assets  </li> </ul>"},{"location":"learn/platform/technology/#forkless-upgrades","title":"Forkless Upgrades","text":"<p>One of the best things about developing on Polkadot with Substrate is the ability to introduce forkless upgrades to blockchain runtimes. In traditional blockchain architectures, substantial changes to the blockchain's rules often require a hard fork, which can be disruptive and contentious.  </p> <p>Substrate takes a different approach by separating the blockchain's state (data) from its logic (rules). Logic lives in the runtime, which is itself stored on-chain. Whenever a new runtime is uploaded (via FRAME's <code>set_code</code> call) and approved through on-chain governance, all nodes automatically switch to the new runtime at a specified block. This process is seamless and does not split the network.  </p> <p>Moonbeam regularly uses forkless upgrades to add features or fixes without requiring node operators to upgrade their software manually. You can keep track of and discuss upcoming Moonbeam upgrades on the Moonbeam forum.</p>"},{"location":"learn/platform/technology/#ethereum-compatibility-architecture","title":"Ethereum Compatibility Architecture","text":"<p>Smart contracts on Moonbeam can be implemented using Solidity, Vyper, and any other language that compiles smart contracts to EVM-compatible bytecode. Moonbeam aims to provide a low-friction and secure environment for the development, testing, and execution of smart contracts while remaining compatible with the existing Ethereum developer toolchain.</p> <p>The execution behavior and semantics of Moonbeam-based smart contracts strive to be as close as possible to Ethereum Layer 1. Moonbeam is a single shard, so cross-contract calls have the same synchronous execution semantics as on Ethereum Layer 1.</p> <p></p> <p>A high-level interaction flow is shown above. A Web3 RPC call from a DApp or existing Ethereum developer tool, such as Hardhat, is received by a Moonbeam node. The node has both Web3 RPCs and Substrate RPCs available, meaning you can use Ethereum or Substrate tools when interacting with a Moonbeam node. Associated Substrate runtime functions handle these RPC calls. The Substrate runtime checks signatures and handles any extrinsics. Smart contract calls are ultimately passed to the EVM to execute the state transitions.</p>"},{"location":"learn/platform/technology/#ethereum-pallet","title":"Ethereum Pallet","text":"<p>The Ethereum pallet is responsible for handling blocks and transaction receipts and statuses. It enables sending and receiving Ethereum-formatted data to and from Moonbeam by storing an Ethereum-style block and its associated transaction hashes in the Substrate runtime.</p> <p>When a user submits a raw Ethereum transaction, it converts into a Substrate transaction through the Ethereum pallet's <code>transact</code> extrinsic\u2014using the Ethereum pallet as the sole executor of the EVM pallet forces all of the data to be stored and transacted in an Ethereum-compatible way, which is how explorers like Moonscan (built by Etherscan) can index block data.</p>"},{"location":"learn/platform/technology/#evm-pallet","title":"EVM Pallet","text":"<p>The EVM pallet implements a sandboxed virtual stack machine and uses the SputnikVM as the underlying EVM engine. It executes Ethereum smart contract bytecode in a manner similar to Ethereum mainnet, including gas metering and state changes.</p> <p>Moonbeam uses unified accounts, meaning an H160 (Ethereum-style) address is also a valid Substrate address, so you only need a single account to interact with the Substrate runtime and the EVM. Once a balance exists in the EVM, smart contracts can be created and interacted with through standard Ethereum RPC calls.  </p> <p>The EVM pallet should produce nearly identical execution results to Ethereum, such as gas cost and balance changes. However, there are some differences. Although the EVM pallet aims for near-identical behavior to Ethereum, some differences exist, for example, Moonbeam's dynamic fee mechanism. For more information, refer to the Frontier EVM Pallet documentation.</p> <p>Moonbeam includes additional EVM precompiles for functionalities like cryptographic operations (ECRecover, SHA256, BLAKE2, BN128) and dispatching Substrate calls directly from within the EVM. Moonbeam uses the following EVM precompiles:</p> <ul> <li>pallet-evm-precompile-simple - includes five basic precompiles: ECRecover, ECRecoverPublicKey, Identity, RIPEMD160, SHA256</li> <li>pallet-evm-precompile-blake2 - includes the BLAKE2 precompile</li> <li>pallet-evm-precompile-bn128 - includes three BN128 precompiles: BN128Add, BN128Mul, and BN128Pairing</li> <li>pallet-evm-precompile-modexp - includes the modular exponentiation precompile</li> <li>pallet-evm-precompile-sha3fips -includes the standard SHA3 precompile</li> <li>pallet-evm-precompile-dispatch - includes the dispatch precompile</li> </ul> <p>You can find an overview of most of these precompiles on the Ethereum MainNet Precompiled Contracts page.</p>"},{"location":"learn/platform/technology/#native-interoperability","title":"Native Interoperability","text":"<p>While Substrate allows developers to create blockchains, one of its most significant advantages is that it supports integration for native interoperability through relay chains like Polkadot and Kusama.  </p> <p>A relay chain is a central chain that connects several blockchains, known as parachains. Each parachain is a distinct blockchain with its runtime and state, but all are connected to and secured by the relay chain. Once connected, parachains can communicate via Cross-Consensus Messaging (XCM) to exchange information and conduct transactions in the same language, enabling a wide range of interoperable applications.  </p> <p>Moonbeam and Moonriver have established XCM connections with a large number of parachains. You can see a visualization of all XCM integrations in this XCM Channel Viewer.</p>"},{"location":"learn/platform/tokens/","title":"Introduction","text":"<p>As a decentralized smart contract platform, Moonbeam requires a utility token to function.  </p> <p>This token is central to the design of Moonbeam and cannot be removed without sacrificing essential functionality. The Moonbeam token uses include:</p> <ul> <li>Supporting the gas metering of smart contract execution</li> <li>Incentivizing collators and powering the mechanics around the creation of a decentralized node infrastructure on which the platform can run</li> <li>Facilitating the on-chain governance mechanism, including proposing referenda, electing council members, voting, etc.</li> <li>Paying for network transaction fees</li> </ul>"},{"location":"learn/platform/tokens/#glimmer-token","title":"Glimmer Token","text":"<p>In the Moonbeam deployment on Polkadot MainNet, this token is called Glimmer, as in, \u201cthat smart contract call will cost 0.3 Glimmer.\u201d  The token symbol is GLMR.</p> <p>You can find more information about Glimmer on the Moonbeam Foundation website.</p>"},{"location":"learn/platform/tokens/#moonriver-token","title":"Moonriver Token","text":"<p>In the Moonbeam deployment on Kusama (called Moonriver), this token is called Moonriver, as in, \u201cthat smart contract call will cost 0.003 Moonriver.\u201d  The token symbol will be MOVR.</p> <p>You can find more information about Moonriver on the Moonbeam Foundation website.</p>"},{"location":"learn/platform/tokens/#dev-token","title":"DEV Token","text":"<p>In the Moonbeam TestNet (called Moonbase Alpha), the token is called DEV. This token can be acquired freely, as its only purpose is to drive development and testing on Moonbase Alpha.</p> <p>You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet.</p>"},{"location":"learn/platform/vision/","title":"Our Vision for Moonbeam","text":"<p>We believe in a multi-chain future with many chains, and many users and assets on those chains. In this context, we have created Moonbeam: a smart contract platform that provides an Ethereum-compatible environment for building decentralized applications. Moonbeam was designed to serve these new kinds of assets and users that exist across two or more chains.</p> <p>Existing smart contract platforms are designed to service the users and assets on a single, specific chain.  By providing cross-chain smart contract functionality, Moonbeam allows developers to shift existing workloads and logic to Moonbeam and extend the reach of their applications to new users and assets on other chains.</p> <p>Moonbeam's cross-chain integration is accomplished by becoming a parachain on the Polkadot network.  The Polkadot network provides integration and connectivity between parachains that are connected to the network and to other non-Polkadot-based chains, such as Ethereum and Bitcoin, via bridges.</p>"},{"location":"learn/platform/vision/#who-benefits-from-moonbeam","title":"Who Benefits From Moonbeam","text":"<p>There are three main audiences who can most benefit from Moonbeam's cross-chain functionality:</p>"},{"location":"learn/platform/vision/#existing-ethereum-based-projects","title":"Existing Ethereum-Based Projects","text":"<p>Projects that are struggling with cost and scalability challenges on Ethereum can use Moonbeam to:</p> <ul> <li>Move portions of their existing workloads and state off of Ethereum Layer 1 with minimal required changes.  </li> <li>Implement a hybrid approach, where applications live on both Ethereum and Moonbeam simultaneously.  </li> <li>Extend their reach to the Polkadot network and other chains that are connected to Polkadot.  </li> </ul>"},{"location":"learn/platform/vision/#polkadot-ecosystem-projects","title":"Polkadot Ecosystem Projects","text":"<p>Ecosystem projects that need smart contract functionality can use Moonbeam to:  </p> <ul> <li>Augment their existing parachains and parathreads.  </li> <li>Add new functionality that is needed but not included on the main Polkadot relay chain. For example, they could create a place where teams can crowdfund their projects, implement lockdrops, and process other, more complex financial transactions than are provided by base Substrate functionality.  </li> <li>Leverage the mature and extensive Ethereum development toolchain.  </li> </ul>"},{"location":"learn/platform/vision/#developers-of-new-dapps","title":"Developers of New DApps","text":"<p>Individuals and teams that want to try building on Polkadot can use Moonbeam to:</p> <ul> <li>Leverage the specialized functionality from Polkadot parachains while reaching users and assets on other chains.  </li> <li>Compose functionality from Polkadot parachains by using Moonbeam as a lightweight integration layer that aggregates network services before presenting them to end users. Implementing a composed service using pre-built integrations on a smart contract platform will be a lot faster and easier (in many cases) than building a full Substrate runtime and performing the integrations yourself in the runtime.  </li> </ul>"},{"location":"learn/platform/vision/#key-features-and-functionality","title":"Key Features and Functionality","text":"<p>Moonbeam achieves these goals with the following key features:  </p> <ul> <li>Decentralized and Permissionless , providing a base requirement for censorship resistance and support for many existing and future DApp use cases.  </li> <li>Contains a Full EVM Implementation , enabling Solidity-based smart contracts to be migrated with minimal change and with expected execution results.  </li> <li>Implements the Web3 RPC API so that existing DApp front-ends can be migrated with minimal change required, and so existing Ethereum-based tools, such as Hardhat, Remix, and MetaMask, can be used without modification against Moonbeam.  </li> <li>Compatible with the Substrate Ecosystem Toolset , including block explorers, front-end development libraries, and wallets, allowing developers and users to use the right tool for what they are trying to accomplish.  </li> <li>Native Cross-Chain Integration via the Polkadot network and via token bridges, which allows for token movement, state visibility, and message passing with Ethereum and other chains.  </li> <li>On-Chain Governance to allow stakeholders to quickly and forklessly evolve the base protocol according to developer and community needs.  </li> </ul> <p>This unique combination of elements fills a strategic market gap, while allowing Moonbeam to address future developer needs as the Polkadot network grows over time.  Building your own chain with Substrate is powerful, but also comes with a number of additional responsibilities, such as learning and implementing the chain\u2019s runtime in Rust, creating a token economy, and incentivizing a community of node operators.</p> <p>For many developers and projects, an Ethereum-compatible smart contract approach will be much simpler and faster to implement.  And by building these smart contracts on Moonbeam, developers can still integrate with other chains and get value from Polkadot-based network effects.</p>"},{"location":"learn/platform/why-polkadot/","title":"Why We're Building on Polkadot","text":"<p>After extensive research, we decided to build Moonbeam using the Substrate development framework and to deploy Moonbeam as a parachain on the Polkadot network.</p>"},{"location":"learn/platform/why-polkadot/#substrate-blockchain-framework","title":"Substrate Blockchain Framework","text":"<p>Substrate is a good technical fit for Moonbeam. By building on top of this framework, we can leverage the extensive functionality that Substrate includes out-of-the-box, rather than building it ourselves. This includes peer-to-peer networking, consensus mechanisms, governance functionality, an EVM implementation, and more.</p> <p>Overall, using Substrate will dramatically reduce the time and implementation effort needed to implement Moonbeam. Substrate allows a great degree of customization, which is necessary in order to achieve our Ethereum compatibility goals. And, by using Rust, we benefit from both safety guarantees and performance gains.</p>"},{"location":"learn/platform/why-polkadot/#polkadot-network-and-ecosystem","title":"Polkadot Network and Ecosystem","text":"<p>The Polkadot network is also a good fit for Moonbeam. As a parachain on Polkadot, Moonbeam will be able to directly integrate with \u2014 and move tokens between \u2014 any other parachains and parathreads on the network.</p> <p>We can also leverage any of the bridges that are independently built to connect non-Polkadot chains to Polkadot, including bridges to Ethereum. Polkadot\u2019s interoperability model uniquely supports Moonbeam\u2019s cross-chain integration goals and is a key enabling technology to support the Moonbeam vision.</p> <p>But perhaps just as important as the technical criteria above, we are impressed with the people in the Polkadot ecosystem. This includes individuals at Parity, the Web3 Foundation, and other projects in the ecosystem. We have built many valuable relationships and find the people to be both extremely talented and the kind of people we want to be around.</p>"},{"location":"learn/platform/networks/moonbase/","title":"The Moonbase Alpha TestNet","text":""},{"location":"learn/platform/networks/moonbase/#goal","title":"Goal","text":"<p>The first Moonbeam TestNet, named Moonbase Alpha, aims to provide developers with a place to start experimenting and building on Moonbeam in a shared environment. Since Moonbeam is deployed as a parachain on Kusama and Polkadot, the goal of the TestNet is to reflect the production configurations. For this reason, it was decided that it needed to be a parachain-based configuration rather than a Substrate development setup.</p> <p>In order to collect as much feedback as possible and provide fast issue resolution, please join the Moonbeam Discord.</p>"},{"location":"learn/platform/networks/moonbase/#initial-configuration","title":"Initial Configuration","text":"<p>Moonbase Alpha has the following configuration:</p> <ul> <li>Runs as a parachain connected to a relay chain</li> <li>Has an active set of 11 collator nodes run by the community</li> <li>The relay chain hosts validators to finalize relay chain blocks. One of them is selected to finalize each block collated by Moonbeam's collators. This setup provides room to expand to a two-parachain configuration in the future</li> <li>Has infrastructure providers that provide API endpoints to connect to the network. Projects can also run their own node to have access to their own private endpoints</li> </ul> <p></p> <p>Some important variables/configurations to note include:</p> GeneralStaking Variable Value Minimum gas price 0.03125 Gwei Target block time 6 seconds Block gas limit 60,000,000 Transaction gas limit 52,000,000 Variable Value Minimum delegation stake 1 DEV Maximum delegators per candidates 300 Maximum delegations per account 100 Round 1200 blocks (2 hour) Bond duration Delegations take effect in the next round; funds are withdrawn immediately Unbond duration 2 rounds (4 hours) <p>Note</p> <p>As of runtime 3000, asynchronous backing has been enabled on all Moonbeam networks. As a result, the target block time was reduced from 12 seconds to 6 seconds, which may break some timing-based assumptions.</p> <p>Additionally, as of runtime 2900, the block and transaction gas limits increased by 4x on Moonbase Alpha.</p>"},{"location":"learn/platform/networks/moonbase/#network-endpoints","title":"Network Endpoints","text":"<p>Moonbase Alpha has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.</p> <p>If you're looking for your own endpoints suitable for production use, you can check out the Endpoint Providers section of our documentation. Otherwise, to get started quickly you can use one of the following public HTTPS or WSS endpoints.</p> HTTPSWSS Provider RPC URL Limits Dwellir <pre><code>https://moonbase-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>https://moonbeam-alpha.api.onfinality.io/public</code></pre> 40 req/sec Moonbeam Foundation <pre><code>https://rpc.api.moonbase.moonbeam.network</code></pre> 25 req/sec UnitedBloc <pre><code>https://moonbase.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonbase.public.curie.radiumblock.co/http</code></pre> 200 req/sec Provider RPC URL Limits Dwellir <pre><code>wss://moonbase-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>wss://moonbeam-alpha.api.onfinality.io/public-ws</code></pre> 40 req/sec Moonbeam Foundation <pre><code>wss://wss.api.moonbase.moonbeam.network</code></pre> 25 req/sec UnitedBloc <pre><code>wss://moonbase.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonbase.public.curie.radiumblock.co/ws</code></pre> 200 req/sec"},{"location":"learn/platform/networks/moonbase/#relay-chain","title":"Relay Chain","text":"<p>To connect to the Moonbase Alpha relay chain, you can use the following WS Endpoint:</p> Provider RPC URL OpsLayer <pre><code>wss://relay.api.moonbase.moonbeam.network</code></pre>"},{"location":"learn/platform/networks/moonbase/#quick-start","title":"Quick Start","text":"<p>For the Web3.js library, you can create a local Web3 instance and set the provider to connect to Moonbase Alpha (both HTTP and WS are supported):</p> <pre><code>const { Web3 } = require('web3'); // Load Web3 library\n.\n.\n.\n// Create local Web3 instance - set Moonbase Alpha as provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); \n</code></pre> <p>For the Ethers.js library, define the provider by using <code>ethers.JsonRpcProvider(providerURL, {object})</code> and setting the provider URL to Moonbase Alpha:</p> <pre><code>const ethers = require('ethers'); // Load Ethers library\n\nconst providerURL = 'https://rpc.api.moonbase.moonbeam.network';\n// Define provider\nconst provider = new ethers.JsonRpcProvider(providerURL, {\n    chainId: 1287,\n    name: 'moonbase-alphanet'\n});\n</code></pre> <p>Any Ethereum wallet should be able to generate a valid address for Moonbeam (for example, MetaMask).</p>"},{"location":"learn/platform/networks/moonbase/#chain-id","title":"Chain ID","text":"<p>Moonbase Alpha TestNet chain ID is: <code>1287</code>, which is <code>0x507</code> in hex.</p>"},{"location":"learn/platform/networks/moonbase/#relay-chain","title":"Alphanet Relay Chain","text":"<p>The Alphanet relay chain is connected to Moonbase Alpha and is Westend-based but unique to the Moonbeam ecosystem. It resembles how you would interact with Kusama or Polkadot. The native tokens of the Alphanet relay chain are UNIT tokens, which are for testing purposes only and have no real value.</p>"},{"location":"learn/platform/networks/moonbase/#telemetry","title":"Telemetry","text":"<p>You can see current Moonbase Alpha telemetry information by visiting Polkadot's Telemetry dashboard.</p>"},{"location":"learn/platform/networks/moonbase/#tokens","title":"Tokens","text":"<p>Tokens on Moonbase Alpha, named DEV, will be issued on demand. DEV tokens hold no value and can be freely acquired.</p> <p>You can enter your address to automatically request DEV tokens from the Moonbase Alpha Faucet website. The faucet dispenses 1.1 DEV tokens every 24 hours.</p> <p>For token requests of more than the limited amount allowed by the faucet, contact a moderator directly via the Moonbeam Discord server. We are happy to provide the tokens needed to test your applications.</p>"},{"location":"learn/platform/networks/moonbase/#proof-of-stake","title":"Proof of Stake","text":"<p>The Moonbase Alpha TestNet is a fully decentralized Delegated Proof of Stake network where users of the network can delegate collator candidates to produce blocks and \"earn rewards\" for testing purposes. Please note, that the Moonbase Alpha DEV tokens have no real value. The number of candidates in the active set will be subject to governance. The active set will consist of the top candidates by stake, including delegations.</p>"},{"location":"learn/platform/networks/moonbase/#limitations","title":"Limitations","text":"<p>This is the first TestNet for Moonbeam, so there are some limitations.</p> <p>Some precompiles are yet to be included. You can check out the list of supported precompiles on the Canonical Contract page. However, all built-in functions are available.</p> <p>Since the release of Moonbase Alpha v6, the maximum gas limit per block has been set to 60,000,000, with a maximum gas limit per transaction of 52,000,000.</p>"},{"location":"learn/platform/networks/moonbeam/","title":"Moonbeam","text":""},{"location":"learn/platform/networks/moonbeam/#goal","title":"Goal","text":"<p>Moonbeam was onboarded as a parachain to Polkadot on December 17th 2021. Moonbeam is the most Ethereum compatible smart-contract parachain in the Polkadot ecosystem. It allows developers to port their projects with minimal to no code changes, enabling them to tap into the Polkadot ecosystem and all its assets.</p> <p>In order to collect as much feedback as possible and provide fast issue resolution, you can check out the dedicated Moonbeam Network section on Discord.</p>"},{"location":"learn/platform/networks/moonbeam/#initial-configurations","title":"Initial Configurations","text":"<p>Currently, Moonbeam has the following configurations:</p> <ul> <li>Runs as a parachain connected to the Polkadot relay chain</li> <li>Has an active set of 75 collators</li> <li>Has infrastructure providers that provide API endpoints to connect to the network. Projects can also run their own node to have access to their own private endpoints</li> </ul> <p></p> <p>Some important variables/configurations to note include (still subject to change):</p> GeneralStaking Variable Value Minimum gas price 31.25 Gwei* Target block time 6 seconds Block gas limit 60,000,000 Transaction gas limit 52,000,000 Variable Value Minimum delegation stake 50 GLMR Maximum delegators per candidates 300 Maximum delegations per account 100 Round 1800 blocks (6 hours) Bond duration delegation takes effect in the next round (funds are withdrawn immediately) Unbond duration 28 rounds <p>*Read more about token denominations</p>"},{"location":"learn/platform/networks/moonbeam/#network-endpoints","title":"Network Endpoints","text":"<p>Moonbeam has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.</p> <p>If you're looking for your own endpoints suitable for production use, you can check out the Endpoint Providers section of our documentation. Otherwise, to get started quickly you can use one of the following public HTTPS or WSS endpoints:</p> HTTPSWSS Provider RPC URL Limits Dwellir <pre><code>https://moonbeam-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>https://moonbeam.api.onfinality.io/public</code></pre> 40 req/sec UnitedBloc <pre><code>https://moonbeam.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonbeam.public.curie.radiumblock.co/http</code></pre> 200 req/sec 1RPC <pre><code>https://1rpc.io/glmr</code></pre> 10k req/day Grove <pre><code>https://moonbeam.rpc.grove.city/v1/01fdb492</code></pre> 5k req/day Provider RPC URL Limits Dwellir <pre><code>wss://moonbeam-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>wss://moonbeam.api.onfinality.io/public-ws</code></pre> 40 req/sec UnitedBloc <pre><code>wss://moonbeam.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonbeam.public.curie.radiumblock.co/ws</code></pre> 200 req/sec 1RPC <pre><code>wss://1rpc.io/glmr</code></pre> 10k req/day"},{"location":"learn/platform/networks/moonbeam/#quick-start","title":"Quick Start","text":"<p>Before getting started, make sure you've retrieved your own endpoint and API key from one of the custom Endpoint Providers. Then for the Web3.js library, you can create a local Web3 instance and set the provider to connect to Moonbeam (both HTTP and WS are supported):</p> <pre><code>const { Web3 } = require('web3'); // Load Web3 library\n.\n.\n.\n// Create local Web3 instance - set Moonbeam as provider\nconst web3 = new Web3('INSERT_RPC_API_ENDPOINT'); // Insert your RPC URL here\n</code></pre> <p>For the Ethers.js library, define the provider by using <code>ethers.JsonRpcProvider(providerURL, {object})</code> and setting the provider URL to Moonbeam:</p> <pre><code>const ethers = require('ethers'); // Load Ethers library\n\nconst providerURL = 'INSERT_RPC_API_ENDPOINT'; // Insert your RPC URL here\n\n// Define provider\nconst provider = new ethers.JsonRpcProvider(providerURL, {\n    chainId: 1284,\n    name: 'moonbeam'\n});\n</code></pre> <p>Any Ethereum wallet should be able to generate a valid address for Moonbeam (for example, MetaMask).</p>"},{"location":"learn/platform/networks/moonbeam/#chain-id","title":"Chain ID","text":"<p>Moonbeam chain ID is: <code>1284</code>, or <code>0x504</code> in hex.</p>"},{"location":"learn/platform/networks/moonbeam/#telemetry","title":"Telemetry","text":"<p>You can see current Moonbeam telemetry information by visiting Polkadot's Telemetry dashboard.</p>"},{"location":"learn/platform/networks/moonbeam/#tokens","title":"Tokens","text":"<p>The tokens on Moonbeam are called Glimmer (GLMR). Check out the Moonbeam Foundation site for more information on the Glimmer token.</p>"},{"location":"learn/platform/networks/moonbeam/#token-denominations","title":"Token Denominations","text":"<p>The smallest unit of Glimmer (GMLR), similarly to Ethereum, is a Wei. It takes 10^18 Wei to make one Glimmer. The denominations are as follows:</p> Unit Glimmer (GLMR) Wei Wei 0.000000000000000001 1 Kilowei 0.000000000000001 1,000 Megawei 0.000000000001 1,000,000 Gigawei 0.000000001 1,000,000,000 Microglmr 0.000001 1,000,000,000,000 Milliglmr 0.001 1,000,000,000,000,000 GLMR 1 1,000,000,000,000,000,000 Kiloglmr 1,000 1,000,000,000,000,000,000,000"},{"location":"learn/platform/networks/moonbeam/#proof-of-stake","title":"Proof of Stake","text":"<p>The Moonriver network is a fully decentralized Delegated Proof of Stake network where users of the network can delegate collator candidates to produce blocks and earn rewards. It uses the Nimbus framework framework for parachain consensus. The number of candidates in the active set will be subject to governance. The active set will consist of the top candidates by stake, including delegations.</p>"},{"location":"learn/platform/networks/moonbeam/#limitations","title":"Limitations","text":"<p>Some precompiles are yet to be included. You can check a list of supported precompiles on the Solidity Precompiles page. However, all built-in functions are available.</p>"},{"location":"learn/platform/networks/moonriver/","title":"Moonriver","text":""},{"location":"learn/platform/networks/moonriver/#goal","title":"Goal","text":"<p>In June 2021, Moonriver was first launched as a parachain on the Kusama network. Moonriver is a sister network of Moonbeam, and provides an environment to test new code under real economic conditions. Developers now have access to start building on an incentivized canary network connected to Kusama.</p> <p>In order to collect as much feedback as possible and provide fast issue resolution, you can check out the dedicated Moonriver section on Discord.</p>"},{"location":"learn/platform/networks/moonriver/#initial-configurations","title":"Initial Configurations","text":"<p>Currently, Moonriver has the following configurations:</p> <ul> <li>Runs as a parachain connected to the Kusama relay chain</li> <li>Has an active set of 72 collators</li> <li>Has infrastructure providers that provide API endpoints to connect to the network. Projects can also run their own node to have access to their own private endpoints</li> </ul> <p></p> <p>Some important variables/configurations to note include:</p> GeneralStaking Variable Value Minimum gas price 0.3125 Gwei* Target block time 6 seconds Block gas limit 60,000,000 Transaction gas limit 52,000,000 Variable Value Minimum delegation stake 5 MOVR Maximum delegators per candidates 300 Maximum delegations per account 100 Round 600 blocks (2 hours) Bond duration delegation takes effect in the next round (funds are withdrawn immediately) Unbond duration 24 rounds <p>*Read more about token denominations</p> <p>Note</p> <p>As of runtime 3000, asynchronous backing has been enabled on all Moonbeam networks. As a result, the target block time was reduced from 12 seconds to 6 seconds, which may break some timing-based assumptions.</p> <p>Additionally, the block and transaction gas limits increased by 4x on Moonriver.</p>"},{"location":"learn/platform/networks/moonriver/#network-endpoints","title":"Network Endpoints","text":"<p>Moonriver has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.</p> <p>If you're looking for your own endpoints suitable for production use, you can check out the Endpoint Providers section of our documentation. Otherwise, to get started quickly you can use one of the following public HTTPS or WSS endpoints:</p> HTTPSWSS Provider RPC URL Limits Dwellir <pre><code>https://moonriver-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>https://moonriver.api.onfinality.io/public</code></pre> 40 req/sec UnitedBloc <pre><code>https://moonriver.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonriver.public.curie.radiumblock.co/http</code></pre> 200 req/sec Grove <pre><code>https://moonriver.rpc.grove.city/v1/01fdb492</code></pre> 5k req/day Provider RPC URL Limits Dwellir <pre><code>wss://moonriver-rpc.dwellir.com</code></pre> 20 req/sec OnFinality <pre><code>wss://moonriver.api.onfinality.io/public-ws</code></pre> 40 req/sec UnitedBloc <pre><code>wss://moonriver.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonriver.public.curie.radiumblock.co/ws</code></pre> 200 req/sec"},{"location":"learn/platform/networks/moonriver/#quick-start","title":"Quick Start","text":"<p>Before getting started, make sure you've retrieved your own endpoint and API key from one of the custom Endpoint Providers. Then for the Web3.js library, you can create a local Web3 instance and set the provider to connect to Moonriver (both HTTP and WS are supported):</p> <pre><code>const { Web3 } = require('web3'); // Load Web3 library\n.\n.\n.\n// Create local Web3 instance - set Moonriver as provider\nconst web3 = new Web3('INSERT_RPC_API_ENDPOINT'); // Insert your RPC URL here\n</code></pre> <p>For the Ethers.js library, define the provider by using <code>ethers.JsonRpcProvider(providerURL, {object})</code> and setting the provider URL to Moonriver:</p> <pre><code>const ethers = require('ethers'); // Load Ethers library\n\nconst providerURL = 'INSERT_RPC_API_ENDPOINT'; // Insert your RPC URL here\n\n// Define provider\nconst provider = new ethers.JsonRpcProvider(providerURL, {\n    chainId: 1285,\n    name: 'moonriver'\n});\n</code></pre> <p>Any Ethereum wallet should be able to generate a valid address for Moonbeam (for example, MetaMask).</p>"},{"location":"learn/platform/networks/moonriver/#chain-id","title":"Chain ID","text":"<p>Moonriver chain ID is: <code>1285</code>, or <code>0x505</code> in hex.</p>"},{"location":"learn/platform/networks/moonriver/#telemetry","title":"Telemetry","text":"<p>You can see current Moonriver telemetry information by visiting Polkadot's Telemetry dashboard.</p>"},{"location":"learn/platform/networks/moonriver/#tokens","title":"Tokens","text":"<p>The tokens on Moonriver will also be called Moonriver (MOVR). Check out the Moonbeam Foundation site for more information on the Moonriver token.</p>"},{"location":"learn/platform/networks/moonriver/#token-denominations","title":"Token Denominations","text":"<p>The smallest unit of Moonriver, similarly to Ethereum, is a Wei. It takes 10^18 Wei to make one Moonriver. The denominations are as follows:</p> Unit Moonriver (MOVR) Wei Wei 0.000000000000000001 1 Kilowei 0.000000000000001 1,000 Megawei 0.000000000001 1,000,000 Gigawei 0.000000001 1,000,000,000 Micromoonriver 0.000001 1,000,000,000,000 Millimoonriver 0.001 1,000,000,000,000,000 Moonriver 1 1,000,000,000,000,000,000 Kilomoonriver 1,000 1,000,000,000,000,000,000,000"},{"location":"learn/platform/networks/moonriver/#proof-of-stake","title":"Proof of Stake","text":"<p>The Moonriver network is a fully decentralized Delegated Proof of Stake network where users of the network can delegate collator candidates to produce blocks and earn rewards. It uses the Nimbus framework framework for parachain consensus. The number of candidates in the active set will be subject to governance. The active set will consist of the top candidates by stake, including delegations.</p>"},{"location":"learn/platform/networks/moonriver/#limitations","title":"Limitations","text":"<p>Some precompiles are yet to be included. You can check a list of supported precompiles on the Canonical Contract page. However, all built-in functions are available.</p>"},{"location":"learn/platform/networks/overview/","title":"Networks","text":"<p>There are multiple long-lived Moonbeam-based networks. Most significantly, there is the Moonbeam deployment on Polkadot and Kusama.</p> <p>An overview of our parachain deployments is as follows:</p> <ul> <li>Moonbeam: deployment on Polkadot (December 2021)</li> <li>Moonriver: deployment on Kusama (June 2021)</li> <li>Moonbase Alpha: Parachain TestNet for Moonbeam and Moonriver (September 2020)</li> </ul> <p>This strategy allows us to de-risk software upgrades to Moonbeam on the Polkadot MainNet while still maintaining a reasonable update velocity.</p>"},{"location":"learn/platform/networks/overview/#moonbeam","title":"Moonbeam","text":"<p>The Moonbeam production MainNet is a parachain on Polkadot and has been since December 17th, 2021. Moonbeam features the highest levels of security and availability. Code running on the MainNet has generally been vetted through one or more of the other networks listed above.</p> <p>Moonbeam will offer parachain-related functionalities such as XCMP and SPREE as these features become available.</p> <p>Learn more about Moonbeam.</p>"},{"location":"learn/platform/networks/overview/#moonriver","title":"Moonriver","text":"<p>In advance of deploying to the Polkadot MainNet, Moonbeam launched Moonriver as a parachain on the Kusama network. The parachain functionality is live on Kusama.</p> <p>Moonriver will offer parachain-related functionalities such as XCMP and SPREE as these features become available.</p> <p>Learn more about Moonriver.</p>"},{"location":"learn/platform/networks/overview/#moonbase-alpha","title":"Moonbase Alpha","text":"<p>This TestNet is a network hosted by OpsLayer. It features a parachain/relay chain scheme. The goal is to allow developers to test the Ethereum compatibility features of Moonbeam in a shared parachain environment without needing to run their own nodes or network.</p> <p>Learn more about Moonbase Alpha.</p>"},{"location":"node-operators/networks/tracing-node/","title":"Run a Tracing Node","text":""},{"location":"node-operators/networks/tracing-node/#introduction","title":"Introduction","text":"<p>Geth's <code>debug</code> and <code>txpool</code> APIs and OpenEthereum's <code>trace</code> module provide non-standard RPC methods for getting a deeper insight into transaction processing. As part of Moonbeam's goal of providing a seamless Ethereum experience for developers, there is support for some of these non-standard RPC methods. Supporting these RPC methods is an important milestone because many projects, such as The Graph, rely on them to index blockchain data.</p> <p>To use the supported RPC methods, you need to run a tracing node, which is slightly different than running a full node. There is a different Docker image, called <code>moonbeamfoundation/moonbeam-tracing</code> that needs to be used for tracing. Additional flags will also need to be used to tell the node which of the non-standard features to support.</p> <p>This guide will show you how to get started running a tracing node on Moonbeam with the <code>debug</code>, <code>txpool</code>, and <code>tracing</code> flags enabled.</p>"},{"location":"node-operators/networks/tracing-node/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Similarly to running a regular node, you can spin up a tracing node using Docker or Systemd. If you choose to use Docker, you must install Docker if you haven't already. At the time of writing, the Docker version used was 19.03.6.</p>"},{"location":"node-operators/networks/tracing-node/#tracing-node-flags","title":"Tracing Node Flags","text":"<p>Spinning up a <code>debug</code>, <code>txpool</code>, or <code>tracing</code> node is similar to running a full node. However, there are some additional flags that you may want to enable specific tracing features:</p> <ul> <li><code>--ethapi debug</code> - optional flag that enables <code>debug_traceTransaction</code>, <code>debug_traceBlockByNumber</code>, <code>debug_traceBlockByHash</code>, and <code>debug_traceCall</code></li> <li><code>--ethapi trace</code> - optional flag that enables <code>trace_filter</code></li> <li><code>--ethapi txpool</code> - optional flag that enables <code>txpool_content</code>, <code>txpool_inspect</code>, and <code>txpool_status</code></li> <li><code>--wasm-runtime-overrides &lt;path/to/overrides&gt;</code> - required flag for tracing that specifies the path where the local Wasm runtimes are stored. If you're using Docker, the path is as follows: <code>/moonbeam/&lt;network&gt;-substitutes-tracing</code>. Accepts the network as a parameter: <code>moonbeam</code>, <code>moonriver</code>, or <code>moonbase</code> (for development nodes and Moonbase Alpha)</li> <li><code>--runtime-cache-size 64</code> - required flag that configures the number of different runtime versions preserved in the in-memory cache to 64</li> <li><code>--ethapi-trace-max-count &lt;uint&gt;</code> \u2014 sets the maximum number of trace entries to be returned by the node. The default maximum number of trace entries a single request of <code>trace_filter</code> returns is <code>500</code></li> <li><code>-ethapi-trace-cache-duration &lt;uint&gt;</code> \u2014 sets the duration (in seconds) after which the cache of <code>trace_filter,</code> for a given block, is discarded. The default amount of time blocks are stored in the cache is <code>300</code> seconds</li> </ul> <p>Note</p> <p>If you want to run an RPC endpoint, to connect to Polkadot.js Apps, or to run your own application, use the <code>--unsafe-rpc-external</code> flag to run the full node with external access to the RPC ports.  More details are available by running <code>moonbeam --help</code>.  </p>"},{"location":"node-operators/networks/tracing-node/#run-a-tracing-node-with-docker","title":"Run a Tracing Node with Docker","text":"<p>If you haven't previously run a standard full Moonbeam node, you will need to setup a directory to store chain data:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>mkdir /var/lib/moonbeam-data\n</code></pre> <pre><code>mkdir /var/lib/moonriver-data\n</code></pre> <pre><code>mkdir /var/lib/alphanet-data\n</code></pre> <p>Before getting started, you'll need to set the necessary permissions either for a specific or current user (replace <code>INSERT_DOCKER_USER</code> for the actual user that will run the <code>docker</code> command):</p> MoonbeamMoonriverMoonbase Alpha <pre><code># chown to a specific user\nchown INSERT_DOCKER_USER /var/lib/moonbeam-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/moonbeam-data\n</code></pre> <pre><code># chown to a specific user\nchown INSERT_DOCKER_USER /var/lib/moonriver-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/moonriver-data\n</code></pre> <pre><code># chown to a specific user\nchown INSERT_DOCKER_USER /var/lib/alphanet-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/alphanet-data\n</code></pre> <p>Instead of the standard <code>moonbeamfoundation/moonbeam</code> docker image, you will need to use <code>moonbeamfoundation/moonbeam-tracing</code> image. The latest supported version can be found on the Docker Hub for the <code>moonbeam-tracing</code> image.</p> <p>Now, execute the docker run command. Note that you have to:</p> <ul> <li>Replace <code>INSERT_YOUR_NODE_NAME</code> in two different places</li> <li>Replace <code>INSERT_RAM_IN_MB</code> for 50% of the actual RAM your server has. For example, for 32 GB RAM, the value must be set to <code>16000</code>. The minimum value is <code>2000</code>, but it is below the recommended specs</li> </ul> <p>Note</p> <p>As of client v0.33.0, the <code>--ws-port</code> and <code>--ws-max-connections</code> flags have been deprecated and removed in favor of the <code>--rpc-port</code> and <code>--rpc-max-connections</code> flags for both RPC and WSS connections. The default port is <code>9944</code>, and the default maximum number of connections is set to 100.</p> <p>The complete command for running a tracing node is as follows:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam-tracing:v0.47.0-3900-b897 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--ethapi debug,trace,txpool \\\n--wasm-runtime-overrides /moonbeam/moonbeam-substitutes-tracing \\\n--runtime-cache-size 64 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam-tracing:v0.47.0-3900-b897 \\\n--base-path /data \\\n--chain moonriver \\\n--name INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--ethapi debug,trace,txpool \\\n--wasm-runtime-overrides /moonbeam/moonriver-substitutes-tracing \\\n--runtime-cache-size 64 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam-tracing:v0.47.0-3900-b897 \\\n--base-path /data \\\n--chain alphanet \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--ethapi debug,trace,txpool \\\n--wasm-runtime-overrides /moonbeam/moonbase-substitutes-tracing \\\n--runtime-cache-size 64 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n</code></pre> <pre><code>docker run --network=\"host\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam-tracing:v0.47.0-3900-b897 \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--ethapi debug,trace,txpool \\\n--wasm-runtime-overrides /moonbeam/moonbase-substitutes-tracing \\\n--runtime-cache-size 64 \\\n--dev\n</code></pre> <p>You should see a terminal log similar to the following if you spun up a Moonbase Alpha tracing node:</p> docker run --network host  \\     -u $(id -u ${USER}):$(id -g ${USER}) \\         moonbeamfoundation/moonbeam-tracing:v0.47.0-3900-b897 \\     --name=\"Moonbean-Tracing-Tutorial\" \\     --unsafe-rpc-external \\     --ethapi=debug,trace,txpool \\     --wasm-runtime-overrides=/moonbeam/moonbase-substitutes-tracing \\     --runtime-cache-size 64 \\     --dev     2025-07-10 09:04:26 Moonbeam Parachain Collator      2025-07-10 09:04:26 \u270c\ufe0f  version 0.47.0-d7df89e7161      2025-07-10 09:04:26 \u2764\ufe0f  by PureStake, 2019-2025      2025-07-10 09:04:26 \ud83d\udccb Chain specification: Moonbase Development Testnet      2025-07-10 09:04:26 \ud83c\udff7  Node name: Moonbean-Tracing-Tutorial      2025-07-10 09:04:26 \ud83d\udc64 Role: AUTHORITY      2025-07-10 09:04:26 \ud83d\udcbe Database: RocksDb at /tmp/substrateO3YeRz/chains/moonbase_dev/db/full      2025-07-10 09:04:26 Found wasm override. version=moonbase-300 (moonbase-0.tx2.au3) file=/moonbeam/moonbase-substitutes-tracing/moonbase-runtime-300-substitute-tracing.wasm      ...      2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0x18e6\u20262eb1), finalized #0 (0x18e6\u20262eb1), \u2b07 0 \u2b06 0"},{"location":"node-operators/networks/tracing-node/#run-a-tracing-node-with-systemd","title":"Run a Tracing Node with Systemd","text":"<p>When you run a node using Systemd, you'll need to start off by setting up the Moonbeam binary. To do so you'll need to follow the instructions on the Run a Node on Moonbeam Using Systemd page. In general, you'll need to:</p> <ol> <li>Setup the Moonbeam binary by following the Release Binary instructions. Or if you want to compile the binary yourself, you can follow the Compile the Binary instructions</li> <li>Follow the instructions in the Setup the Service instructions</li> </ol> <p>Once you've finished going through the instructions in those specific sections, you can continue on to the below instructions.</p>"},{"location":"node-operators/networks/tracing-node/#setup-the-wasm-overrides","title":"Setup the Wasm Overrides","text":"<p>You'll need to create a directory for the Wasm runtime overrides and obtain them from the Moonbeam Runtime Overrides repository on GitHub.</p> <p>You can clone the repository to any location on your local machine. For simplicity, you can use the directory where you're storing on-chain data. To set up the Wasm override files, you can take the following steps:</p> <ol> <li> <p>Clone the Moonbeam Runtime Overrides repository</p> <pre><code>git clone https://github.com/moonbeam-foundation/moonbeam-runtime-overrides.git\n</code></pre> </li> <li> <p>Move the Wasm overrides into your on-chain data directory:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>mv moonbeam-runtime-overrides/wasm /var/lib/moonbeam-data\n</code></pre> <pre><code>mv moonbeam-runtime-overrides/wasm /var/lib/moonriver-data\n</code></pre> <pre><code>mv moonbeam-runtime-overrides/wasm /var/lib/alphanet-data\n</code></pre> </li> <li> <p>Delete the override files for the networks that you aren't running</p> MoonbeamMoonriverMoonbase Alpha <pre><code>rm /var/lib/moonbeam-data/wasm/moonriver-runtime-* &amp;&amp;  rm /var/lib/moonbeam-data/wasm/moonbase-runtime-*\n</code></pre> <pre><code>rm /var/lib/moonriver-data/wasm/moonbeam-runtime-* &amp;&amp;  rm /var/lib/moonriver-data/wasm/moonbase-runtime-*\n</code></pre> <pre><code>rm /var/lib/alphanet-data/wasm/moonbeam-runtime-* &amp;&amp;  rm /var/lib/alphanet-data/wasm/moonriver-runtime-*\n</code></pre> </li> <li> <p>Set user permissions for the overrides:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>chmod +x /var/lib/moonbeam-data/wasm/*\nchown moonbeam_service /var/lib/moonbeam-data/wasm/*\n</code></pre> <pre><code>chmod +x /var/lib/moonriver-data/wasm/*\nchown moonriver_service /var/lib/moonriver-data/wasm/*\n</code></pre> <pre><code>chmod +x /var/lib/alphanet-data/wasm/*\nchown moonbase_service /var/lib/alphanet-data/wasm/*\n</code></pre> </li> </ol>"},{"location":"node-operators/networks/tracing-node/#create-the-configuration-file","title":"Create the Configuration File","text":"<p>The next step is to create the systemd configuration file, you'll need to:</p> <ul> <li>Replace <code>INSERT_YOUR_NODE_NAME</code> in two different places</li> <li>Replace <code>INSERT_RAM_IN_MB</code> for 50% of the actual RAM your server has. For example, for 32 GB RAM, the value must be set to <code>16000</code>. The minimum value is <code>2000</code>, but it is below the recommended specs</li> <li>Double-check that the binary is in the proper path as described below (ExecStart)</li> <li>Double-check the base path if you've used a different directory</li> <li>Name the file <code>/etc/systemd/system/moonbeam.service</code></li> </ul> <p>Note</p> <p>As of client v0.33.0, the <code>--ws-port</code> and <code>--ws-max-connections</code> flags have been deprecated and removed in favor of the <code>--rpc-port</code> and <code>--rpc-max-connections</code> flags for both RPC and WSS connections. The default port is <code>9944</code>, and the default maximum number of connections is set to 100.</p> MoonbeamMoonriverMoonbase Alpha <pre><code>[Unit]\nDescription=\"Moonbeam systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbeam_service\nSyslogIdentifier=moonbeam\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonbeam-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonbeam-data \\\n     --ethapi debug,trace,txpool \\\n     --wasm-runtime-overrides /var/lib/moonbeam-data/wasm \\\n     --runtime-cache-size 64 \\\n     --chain moonbeam \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Moonriver systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonriver_service\nSyslogIdentifier=moonriver\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonriver-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonriver-data \\\n     --ethapi debug,trace,txpool \\\n     --wasm-runtime-overrides /var/lib/moonriver-data/wasm \\\n     --runtime-cache-size 64 \\\n     --chain moonriver \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Moonbase Alpha systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbase_service\nSyslogIdentifier=moonbase\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/alphanet-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/alphanet-data \\\n     --ethapi debug,trace,txpool \\\n     --wasm-runtime-overrides /var/lib/alphanet-data/wasm \\\n     --runtime-cache-size 64 \\\n     --chain alphanet \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Note</p> <p>If you want to run an RPC endpoint, to connect polkadot.js.org, or to run your own application, use the <code>--unsafe-rpc-external</code> flag to run the full node with external access to the RPC ports. More details are available by running <code>moonbeam --help</code>.</p>"},{"location":"node-operators/networks/tracing-node/#run-the-service","title":"Run the Service","text":"<p>Register and start the service by running:</p> <pre><code>systemctl enable moonbeam.service\nsystemctl start moonbeam.service\n</code></pre> <p>And lastly, verify that the service is running:</p> <pre><code>systemctl status moonbeam.service\n</code></pre> systemctl status moonbeam.service \u25cf moonbeam.service - \"Moonbase Alpha systemd service\"     Loaded: loaded (/etc/systemd/system/moonbeam.service; enabled; vendor preset: enabled)     Active: active (running) since Fri 2022-06-03 12:45:08 EDT; 10min ago     Main PID: 2115 (moonbeam)     Tasks: 43 (limit: 19141)     Memory: 9.5G     CGroup:/system.slice/moonbeam.service     --2115 /var/lib/alphanet-data/moonbeam --port 30334 --rpc-port 9944    Jun 03 12:55:07 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:07 [\ud83c\udf17] &gt;     Jun 03 12:55:08 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:08 [Rela&gt;     Jun 03 12:55:12 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:12 [\ud83c\udf17] &gt;     Jun 03 12:55:13 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:13 [Rela&gt;     Jun 03 12:55:17 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:17 [\ud83c\udf17] &gt;     Jun 03 12:55:18 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:18 [Rela&gt;     Jun 03 12:55:19 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:19 [Rela&gt;     Jun 03 12:55:19 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:19 [Rela&gt;     Jun 03 12:55:19 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:19 [Rela&gt;     Jun 03 12:55:19 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:19 [Rela&gt;    <p>You can also run the following command to see logs of the tracing node spinning up:</p> <pre><code>journalctl -f -u moonbeam.service\n</code></pre> <p>Your terminal should display logs similar to the following:</p> asm override. version=moonbase-400 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/moo nbase-runtime-400-substitute-tracing.wasm     Jun 03 12:45:55 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:45:55 [\ud83c\udf17] Found w asm override. version-moonbase-155 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/moo     nbase-runtime-155-substitute-tracing. wasm     Jun 03 12:45:56 vmi719182. contaboserver.net moonbase [2115]: 2022-06-03 12:45:56 [\ud83c\udf17] Found w asm override. version-moonbase-501 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/moo nbase-runtime-501-substitute-tracing.wasm     Jun 03 12:45:57 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:45:57 [\ud83c\udf17] Found w asm override. version-moonbase-1200 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/mo onbase-runtime-1200-substitute-tracing.wasm     Jun 03 12:45:58 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:45:58 [\ud83c\udf17] Found w asm override. version-moonbase-47 (moonbase-1.tx2.au3) file=/var/lib/alphanet-data/wasm/moon base-runtime-47-substitute-tracing.wasm     Jun 03 12:46:00 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:46:00 [\ud83c\udf17] Found w asm override. version=moonbase-1501 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/mo onbase-runtime-1501-substitute-tracing.wasm     Jun 03 12:46:01 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:46:01 [\ud83c\udf17] Found w asm override. version-moonbase-900 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/moo nbase-runtime-900-substitute-tracing.wasm     Jun 03 12:46:04 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:46:04 [\ud83c\udf17] Found w asm override. version-moonbase-1504 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/mo onbase-runtime-1504-substitute-tracing.wasm     Jun 03 12:46:05 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:46:05 [\ud83c\udf17] Found w asm override. version-moonbase-1101 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/mo onbase-runtime-1101-substitute-tracing.wasm     Jun 03 12:46:07 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:46:07 [\ud83c\udf17] Found w asm override. version-moonbase-800 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/moo nbase-runtime-800-substitute-tracing.wasm"},{"location":"node-operators/networks/tracing-node/#using-a-tracing-node","title":"Using a Tracing Node","text":"<p>To explore the different non-standard RPC methods available on Moonbeam, and how to use these methods with a tracing node, check out the Debug &amp; Trace guide.</p>"},{"location":"node-operators/networks/collators/account-management/","title":"Collator Account Management","text":""},{"location":"node-operators/networks/collators/account-management/#introduction","title":"Introduction","text":"<p>When running a collator node on Moonbeam-based networks, there are some account management activities that you will need to be aware of. First and foremost you will need to create session keys for your primary and backup servers which will be used to determine block production and sign blocks.</p> <p>In addition, there are some optional account management activities that you can consider such as setting an on-chain identity or setting up proxy accounts.</p> <p>This guide will cover how to manage your collator account including generating and rotating your session keys, registering and updating your session keys, setting an identity, and creating proxy accounts.</p>"},{"location":"node-operators/networks/collators/account-management/#process","title":"Process to Add and Update Session Keys","text":"<p>The process for adding your session keys for the first time is the same as it would be for rotating your session keys. The process to create/rotate session keys is as follows:</p> <ol> <li>Generate session keys using the <code>author_rotateKeys</code> RPC method. The response to calling this method will be a 128 hexadecimal character string containing a Nimbus ID and the public key of a VRF session key</li> <li>Join the candidate pool if you haven't already</li> <li>Map the session keys to your candidate account using the Author Mapping Pallet's <code>setKeys(keys)</code> extrinsic, which accepts the entire 128 hexadecimal character string as the input. When you call <code>setKeys</code> for the first time, you'll be required to submit a mapping bond. If you're rotating your keys and you've previously submitted a mapping bond, no new bond is required</li> </ol> <p>Each step of the process is outlined in the following sections.</p>"},{"location":"node-operators/networks/collators/account-management/#session-keys","title":"Generate Session Keys","text":"<p>To match the Substrate standard, Moonbeam collator's session keys are SR25519. This guide will show you how you can create/rotate your session keys associated with your collator node.</p> <p>First, make sure you're running a collator node. Once you have your collator node running, your terminal should print similar logs:</p> 2025-02-25 20:00:52 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12706 (0x1d51.3042), finalized #12704 (0xf74b.aa44), 1 0.4kiB/s 1 0.6kiB/s 2025-02-25 20:00:52 \ud83d\udca4 Idle (6 peers), best: #5751 (Oxc5alesb5), finalized #5750 (0x9dc..e bad), 1 9.6kiB/s 1 3.5kiB/s 2025-02-25 20:00:53 [Relaychain] \u2728 Imported #12707 (0x77ea.4299) 2025-02-25 20:00:57 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12707 (0x77ea..4299), finalized #12704 (0xf74b..aa44), | 16.4kiB/s 1 12.2kiB/s 2025-02-25 20:00:57 \ud83d\udca4 Idle (6 peers), best: #5751 (0xc5a1e8b5), finalized #5750 (0x9fdc...e bad), 1 1.6kiB/s 1 0.4kiB/s 2025-02-25 20:00:59 [Relaychain] \u2728 Imported #12708 (0x009f...3bbf) 2025-02-25 20:01:00 \u2728 Imported #5753 (0x8981.6c81) 2025-02-25 20:01:00 \u2728 Imported #5753 (0x33a...b5e3) 2025-02-25 20:01:02 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12708 (0x009f...3bbf), finalized #12706 (0x1d51.3042), 1 1.5kiB/s 1 1.3kiB/s 2025-02-25 20:01:02 \ud83d\udca4 Idle (6 peers), best: #5752 (0x7036.569e), finalized #5751 (0xc5a1..e8b5), 1 3.3kiB/s 1 5.8kiB/s 2025-02-25 20:01:05 [Relaychain] \u2728 Imported #12709 (0x76b9...bf65) 2025-02-25 20:01:07 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12709 (0x76b9..bf65), finalized #12706 (0x1d51.3042), | 2.0kiB/s | 0.9kiB/s 2025-02-25 20:01:07 \ud83d\udca4 Idle (6 peers), best: #5752 (0x7036.569e), finalized #5751 (0xc5a1..e8b5), 1 0 1 0 <p>Next, session keys can be created/rotated by sending an RPC call to the HTTP endpoint with the <code>author_rotateKeys</code> method. When you call <code>author_rotateKeys</code>, the result is the size of two keys. The response will contain a concatenated Nimbus ID and VRF key. The Nimbus ID will be used to sign blocks and the VRF key is required for block production. The concatenated keys will be used to create an association to your H160 account for block rewards to be paid out.</p> <p>For reference, if your collator's HTTP endpoint is at port <code>9944</code>, the JSON-RPC call might look like this:</p> <pre><code>curl http://127.0.0.1:9944 -H \\\n\"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n  }'\n</code></pre> <p>The collator node should respond with the concatenated public keys of your new session keys. The first 64 hexadecimal characters after the <code>0x</code> prefix represent your Nimbus ID and the last 64 hexadecimal characters are the public key of your VRF session key. You'll use the concatenated public keys when mapping your Nimbus ID and setting the session keys in the next section.</p> curl http://127.0.0.1:9933-H\\ \"Content-Type: application/json;charset=utf-8\" -d \\ '{ \"jsonrpc\": \"2.0\", \"id\" :1, \"method\": \"author_rotatekeys\", \"params\": [] }' {\"jsonrpc\": \"2.0\", \"result\":\"0x72c7ca7ef0794103caeb520806576b52cb085f7577cc12cd36c2d64dbf73757a789407ec0f401a8792ac57c4fb7dabd4da6cc74d9ac9b8dd8c4faf770255403f\", \"id\" :1} <p>Make sure you write down the concatenated public keys. Each of your servers, your primary and backup, should have their own unique keys. Since the keys never leave your servers, you can consider them a unique ID for that server.</p> <p>Next, you'll need to register your session keys and map them to an H160 Ethereum-styled address to which the block rewards are paid.</p>"},{"location":"node-operators/networks/collators/account-management/#manage-session-keys","title":"Manage Session Keys","text":"<p>Once you've created or rotated your session keys, you'll be able to manage your session keys using the extrinsics in the Author Mapping Pallet. You can map your session keys, verify the on-chain mappings, and remove session keys.</p>"},{"location":"node-operators/networks/collators/account-management/#author-mapping-interface","title":"Author Mapping Pallet Interface","text":"<p>The <code>authorMapping</code> module has the following extrinsics:</p> <ul> <li>setKeys(keys) \u2014 accepts the result of calling <code>author_rotateKeys</code>, which is the concatenated public keys of your Nimbus and VRF keys, and sets the session keys at once. Useful after a key rotation or migration. Calling <code>setKeys</code> requires a bond. Replaces the deprecated <code>addAssociation</code> and <code>updateAssociation</code> extrinsics</li> <li>removeKeys() - removes the session keys. This is only required if you intend to stop collating and leave the candidate pool. Replaces the deprecated <code>clearAssociation</code> extrinsic</li> </ul> <p>The module also adds the following RPC calls (chain state):</p> <ul> <li>mappingWithDeposit(NimbusPrimitivesNimbusCryptoPublic | string | Uint8Array) \u2014 displays all mappings stored on-chain, or only that related to the Nimbus ID if provided</li> <li>nimbusLookup(AccountId20) - displays a reverse mapping of account IDs to Nimbus IDs for all collators or for a given collator address</li> </ul>"},{"location":"node-operators/networks/collators/account-management/#mapping-extrinsic","title":"Map Session Keys","text":"<p>With your newly generated session keys in hand, the next step is to map your session keys to your H160 account (an Ethereum-style address). Make sure you hold the private keys to this account, as this is where the block rewards are paid out to.</p> <p>To map your session keys to your account, you need to be inside the candidate pool. Once you are a candidate, you need to send a mapping extrinsic, which requires a mapping bond.</p>"},{"location":"node-operators/networks/collators/account-management/#mapping-bonds","title":"Mapping Bonds","text":"<p>The mapping bond is per session keys registered. The bond for mapping your session keys to your account is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>10000 GLMR\n</code></pre> <pre><code>100 MOVR\n</code></pre> <pre><code>100 DEV\n</code></pre>"},{"location":"node-operators/networks/collators/account-management/#use-polkadotjs-apps","title":"Use Polkadot.js Apps to Map Session Keys","text":"<p>In this section, you'll learn how to map session keys from Polkadot.js Apps. To learn how to create the mapping through the author mapping precompiled contract, you can refer to the page on Interacting with the Author Mapping Precompile.</p> <p>To create the mapping from Polkadot.js Apps (make sure you're connected to the correct network), click on Developer at the top of the page, choose the Extrinsics option from the dropdown, and take the following steps:</p> <ol> <li>Choose the account that you want to map your author ID to be associated with, from which you'll sign this transaction</li> <li>Select the authorMapping extrinsic</li> <li>Set the method to setKeys()</li> <li>Enter the keys. It is the response obtained via the RPC call <code>author_rotateKeys</code> in the previous section, which is the concatenated public keys of your Nimbus ID and VRF key</li> <li>Click on Submit Transaction</li> </ol> <p></p> <p>Note</p> <p>If you receive the following error, you may need to try rotating and mapping your keys again: <code>VRF PreDigest was not included in the digests (check rand key is in keystore)</code>.</p> <p>If the transaction is successful, you will see a confirmation notification on your screen. If not, make sure you've joined the candidate pool.</p>"},{"location":"node-operators/networks/collators/account-management/#checking-the-mappings","title":"Check Mappings","text":"<p>You can check the current on-chain mappings by verifying the chain state. You can do this one of two ways: via the <code>mappingWithDeposit</code> method or the <code>nimbusLookup</code> method. Both methods can be used to query the on-chain data for all of the collators or for a specific collator.</p> <p>You can check the current on-chain mappings for a specific collator or you can also check all of the mappings stored on-chain.</p>"},{"location":"node-operators/networks/collators/account-management/#using-mapping-with-deposit","title":"Using the Mapping with Deposit Method","text":"<p>To use the <code>mappingWithDeposit</code> method to check the mapping for a specific collator, you'll need to get the Nimbus ID. To do so, you can take the first 64 hexadecimal characters of the concatenated public keys to get the Nimbus ID. To verify that the Nimbus ID is correct, you can run the following command with the first 64 characters passed into the <code>params</code> array:</p> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d   '{\n  \"jsonrpc\":\"2.0\",\n  \"id\":1,\n  \"method\":\"author_hasKey\",\n  \"params\": [\"72c7ca7ef07941a3caeb520806576b52cb085f7577cc12cd36c2d64dbf73757a\", \"nmbs\"]\n}'\n</code></pre> <p>If it's correct the response should return <code>\"result\": true</code>.</p> curl http://127.0.0.1:9933 -H \"Content-Type:application/json;char set=utf-8\" -d '{ \"jsonrpc\":\"2.0\" \"id\" :1, \"method\": \"author_hasKey\", \"params\": [\"72c7ca7ef07941a3caeb520806576b52cb085f7577c12c36c2d64dbf73757a\", \"nmbs\"] }' {\"jsonrpc\":\"2.0\", \"result\" :true, \"id\" :1} <p>From Polkadot.js Apps, click on Developer at the top of the page, then choose Chain State from the dropdown, and take the following steps:</p> <ol> <li>Choose authorMapping as the state to query</li> <li>Select the mappingWithDeposit method</li> <li>Provide a Nimbus ID to query. Optionally, you can disable the slider to retrieve all mappings </li> <li>Click on the + button to send the RPC call</li> </ol> <p></p> <p>You should be able to see the H160 account associated with the Nimbus ID provided and the deposit paid. If no Nimbus ID was included, this would return all the mappings stored on-chain.</p>"},{"location":"node-operators/networks/collators/account-management/#using-nimbus-lookup","title":"Using the Nimbus Lookup Method","text":"<p>To use the <code>nimbusLookup</code> method to check the mapping for a specific collator, you'll need the collator's address. If you do not pass an argument to the method, you can retrieve all of the on-chain mappings.</p> <p>From Polkadot.js Apps, click on Developer at the top of the page, then choose Chain State from the dropdown, and take the following steps:</p> <ol> <li>Choose authorMapping as the state to query</li> <li>Select the nimbusLookup method</li> <li>Provide a collator's address to query. Optionally, you can disable the slider to retrieve all mappings</li> <li>Click on the + button to send the RPC call</li> </ol> <p></p> <p>You should be able to see the nimbus ID associated with the H160 account provided. If no account was provided, this would return all the mappings stored on-chain.</p>"},{"location":"node-operators/networks/collators/account-management/#removing-session-keys","title":"Remove Session Keys","text":"<p>Before removing your session keys, you'll want to make sure that you've stopped collating and left the candidate pool. To stop collating, you'll need to schedule a request to leave the candidate pool, wait a delay period, and then execute the request. For step-by-step instructions, please refer to the Stop Collating section of the Moonbeam Collator Activities page.</p> <p>Once you have left the candidate pool, you can remove your session keys. After which, the mapping bond you deposited will be returned to your account.</p> <p>From Polkadot.js Apps, click on Developer at the top of the page, then choose Extrinsics from the dropdown, and take the following steps:</p> <ol> <li>Select your account</li> <li>Choose the authorMapping pallet and the removeKeys extrinsic</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>Once the transaction goes through, the mapping bond will be returned to you. To make sure that the keys were removed, you can follow the steps in the Check Mappings section.</p>"},{"location":"node-operators/networks/collators/account-management/#setting-an-identity","title":"Setting an Identity","text":"<p>Setting an on-chain identity enables your collator node to be easily identifiable. As opposed to showing your account address, your chosen display name will be displayed instead.</p> <p>There are a couple of ways you can set your identity, to learn how to set an identity for your collator node please check out the Managing your Account Identity page of our documentation.</p>"},{"location":"node-operators/networks/collators/account-management/#proxy-accounts","title":"Proxy Accounts","text":"<p>Proxy accounts are accounts that can be enabled to perform a limited number of actions on your behalf. Proxies allow users to keep a primary account securely in cold storage while using the proxy to actively participate in the network on behalf of the primary account. You can remove authorization of the proxy account at any time. As an additional layer of security, you can setup your proxy with a delay period. This delay period would provide you time to review the transaction, and cancel if needed, before it automatically gets executed.</p> <p>To learn how to setup a proxy account, please refer to the Setting up a Proxy Account page of our documentation.</p>"},{"location":"node-operators/networks/collators/activities/","title":"Collator Activities","text":""},{"location":"node-operators/networks/collators/activities/#introduction","title":"Introduction","text":"<p>Becoming a collator on Moonbeam-based networks requires you to meet bonding requirements and join the candidate pool. Once you're in the candidate pool, you can adjust your self-bond amount or decide to leave the pool at any time.</p> <p>If you wish to reduce your self-bond amount or leave the candidate pool, it requires you to first schedule a request to leave and then execute upon the request after a delay period has passed.</p> <p>This guide will take you through important timings to be aware of when leaving or reducing your self-bond amount, how to join and leave the candidate pool, and how to adjust your self-bond.</p>"},{"location":"node-operators/networks/collators/activities/#collator-timings","title":"Collator Timings","text":"<p>Before getting started, it's important to note some of the timing of different actions related to collator activities:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Round duration 1800 blocks (6 hours) Leave candidates 28 rounds (168 hours) Revoke delegation 28 rounds (168 hours) Reduce self-delegation 28 rounds (168 hours) Rewards payouts (after current round) 2 rounds (12 hours) Maximum offline rounds 1 rounds (6 hours) Variable Value Round duration 600 blocks (2 hours) Leave candidates 24 rounds (48 hours) Revoke delegation 24 rounds (48 hours) Reduce self-delegation 24 rounds (48 hours) Rewards payouts (after current round) 2 rounds (4 hours) Maximum offline rounds 2 rounds (4 hours) Variable Value Round duration 1200 blocks (2 hours) Leave candidates 2 rounds (4 hours) Revoke delegation 2 rounds (4 hours) Reduce self-delegation 2 rounds (4 hours) Rewards payouts (after current round) 2 rounds (4 hours) Maximum offline rounds 2 rounds (4 hours) <p>Note</p> <p>The values presented in the previous table are subject to change in future releases.</p> <p>Note</p> <p>As of runtime 3000, asynchronous backing has been enabled on all Moonbeam networks. As a result, the target block time was reduced from 12 seconds to 6 seconds, which may break some timing-based assumptions.</p>"},{"location":"node-operators/networks/collators/activities/#become-a-candidate","title":"Become a Candidate","text":""},{"location":"node-operators/networks/collators/activities/#get-the-size-of-the-candidate-pool","title":"Get the Size of the Candidate Pool","text":"<p>First, you need to get the <code>candidatePool</code> size (this can change through governance), as you'll need to submit this parameter in a later transaction. To do so, you'll have to run the following JavaScript code snippet from within Polkadot.js:</p> <pre><code>// Simple script to get candidate pool size\nconst candidatePool = await api.query.parachainStaking.candidatePool();\nconsole.log(`Candidate pool size is: ${candidatePool.length}`);\n</code></pre> <p>Head to the Developer tab, select JavaScript from the dropdown, and take the following steps:</p> <ol> <li>Copy the code from the previous snippet and paste it inside the code editor box. (Optional) Click the save icon and set a name for the code snippet, for example, \"Get candidatePool size\". This will save the code snippet locally</li> <li>To execute the code, click on the run button</li> <li>Copy the result, as you'll need it when joining the candidate pool</li> </ol> <p></p>"},{"location":"node-operators/networks/collators/activities/#join-the-candidate-pool","title":"Join the Candidate Pool","text":"<p>Once your node is running and in sync with the network, you become a candidate and join the candidate pool. Depending on which network you are connected to, head to Polkadot.js, click on the Developer tab, select Extrinsics from the dropdown, and take the following steps:</p> <ol> <li>Select the account you want to become a collator. Confirm your account is funded with at least the minimum stake required plus some extra for transaction fees</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Open the drop-down menu, which lists all the possible extrinsics related to staking, and select the joinCandidates function</li> <li>Set the bond to at least the minimum amount to be considered a candidate. You'll need to enter this amount in <code>Wei</code>. As an example, the minimum bond of 500 DEV on Moonbase Alpha would be <code>500000000000000000000</code> in Wei (500 + 18 extra zeros). Only the candidate bond counts for this check. Additional delegations do not count</li> <li>Set the candidate count as the candidate pool size. To learn how to retrieve this value, check the Get the Size of the Candidate Pool section</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p> <p>Note</p> <p>Function names and the minimum bond requirement are subject to change in future releases.</p> <p>As mentioned before, only the top candidates by delegated stake will be in the active set of collators. The exact number of candidates in the top for each network and the minimum bond amount can be found in the Minimum Collator Bond section.</p>"},{"location":"node-operators/networks/collators/activities/#stop-collating","title":"Stop Collating","text":"<p>To stop collating and leave the candidate pool, you must first schedule a request to leave the pool. Scheduling a request automatically removes you from the active set, so you will no longer be eligible to produce blocks or earn rewards. You must wait for the duration of the exit delay before you can execute the request to leave. After the request has been executed, you will be removed from the candidate pool.</p> <p>Similar to Polkadot's <code>chill()</code> functionality, you can temporarily leave the candidate pool without unbonding your tokens.</p>"},{"location":"node-operators/networks/collators/activities/#schedule-request-to-leave-candidates","title":"Schedule Request to Leave Candidates","text":"<p>To get started and schedule a request, navigate to the Developer tab, click on Extrinsics, and take the following steps:</p> <ol> <li>Select your candidate account</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the scheduleLeaveCandidates extrinsic</li> <li>Enter the <code>candidateCount</code> which you should have retrieved in the Get the Size of the Candidate Pool section</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p>"},{"location":"node-operators/networks/collators/activities/#execute-request-to-leave-candidates","title":"Execute Request to Leave Candidates","text":"<p>After the waiting period has passed, you'll be able to execute the request. To execute the request to leave the candidate pool, you'll first need to obtain the number of delegations the candidate has. To do so, you can query the candidate information, which will include the delegation count. To get started, click on the Developer tab, select Chain state, and take the following steps:</p> <ol> <li>From the selected state query dropdown, choose parachainStaking</li> <li>Select the candidateInfo extrinsic</li> <li>Choose the candidate account to get the information for</li> <li>Click the + button to submit the extrinsic</li> <li>Copy the <code>delegationCount</code> to be used for executing the leave candidates request</li> </ol> <p></p> <p>Now that you have the delegation count, you can execute the request. Switch back to the Extrinsics tab and follow these steps:</p> <ol> <li>Select your candidate account</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the executeLeaveCandidates extrinsic</li> <li>Select the target candidate account (anyone can execute the request after the exit delay has passed after submitting the <code>scheduleLeaveCandidates</code> extrinsic)</li> <li>Enter the candidate's delegation count</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p>"},{"location":"node-operators/networks/collators/activities/#cancel-request-to-leave-candidates","title":"Cancel Request to Leave Candidates","text":"<p>If you scheduled a request to leave the candidate pool but changed your mind, as long as the request has not been executed, you can cancel the request and remain in the candidate pool. To cancel the request, make sure you've clicked on  Extrinsics from the Developer tab, and then follow these steps:</p> <ol> <li>Select your candidate account</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the cancelLeaveCandidates extrinsic</li> <li>Provide the <code>candidateCount</code> which you should have retrieved in the Get the Size of the Candidate Pool section</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p>"},{"location":"node-operators/networks/collators/activities/#temporarily-leave-the-candidate-pool","title":"Temporarily Leave the Candidate Pool","text":"<p>If you want to temporarily leave the candidate pool, you can easily do so using the <code>goOffline</code> method. This can be useful, for example, if you need to temporarily leave to perform maintenance operations. Once you're done, you can then rejoin the pool using the <code>goOnline</code> method.</p> <p>To temporarily leave, you can take the following steps:</p> <ol> <li>Navigate to the Developer tab</li> <li>Click on Extrinsics</li> <li>Select your candidate account</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the goOffline extrinsic</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p> <p>Then, whenever you wish to rejoin, you can use the <code>goOnline</code> method by following the same steps outlined above, and then in step 5, choose the <code>goOnline</code> extrinsic. Please note that you can only call <code>goOnline</code> if you have previously called <code>goOffline</code>.</p>"},{"location":"node-operators/networks/collators/activities/#change-self-bond-amount","title":"Change Self-Bond Amount","text":"<p>As a candidate, changing your self-bond amount varies slightly depending on whether you're bonding more or less. If you're bonding more, it is a straightforward process where you can increase your stake via the <code>candidateBondMore()</code> extrinsic. You do not have to wait for any delays, and you do not need to schedule a request and then execute it; instead, your request will be executed instantly and automatically.</p> <p>If you wish to bond less, you have to schedule a request, wait for an exit delay, and then you will be able to execute the request and get a specified amount of tokens back into your free balance. In other words, scheduling the request doesn't decrease the bond instantly or automatically; it will only decrease once the request has been executed.</p>"},{"location":"node-operators/networks/collators/activities/#bond-more","title":"Bond More","text":"<p>As a candidate, there are two options for increasing one's stake. The first and recommended option is to send the funds to be staked to another owned address and delegate to your collator. Alternatively, collators that already have at least the minimum self-bond amount staked can increase their bond from Polkadot.js Apps. Navigate to the Developer tab, click on Extrinsics, and follow these steps:</p> <ol> <li>Select your collator account (and verify it contains the additional funds to be bonded)</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Open the drop-down menu, which lists all the possible extrinsics related to staking, and select the candidateBondMore function</li> <li>Specify the additional amount to be bonded in the more: BalanceOf field</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p>"},{"location":"node-operators/networks/collators/activities/#bond-less","title":"Bond Less","text":"<p>As a collator or collator candidate, you may decrease your amount bonded as long as you have more than the minimum self-bond amount after the decrease.</p> <p>In order to bond less, you have to first schedule a request, wait for the duration of the exit delay, and then execute the request. You can cancel a request at any time, as long as the request hasn't been executed yet.</p>"},{"location":"node-operators/networks/collators/activities/#schedule-bond-less","title":"Schedule Bond Less Request","text":"<p>To schedule a request to bond less, make sure you've clicked on the Developer tab and clicked on Extrinsics, then you can follow these steps:</p> <ol> <li>Select your candidate account</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Open the drop-down menu and select the scheduleCandidateBondLess function</li> <li>Specify the amount to decrease the bond by in the  less: BalanceOf field</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p> <p>Once the transaction is confirmed, you must wait the duration of the exit delay and then you will be able to execute and decrease the bond amount. If you try to execute the request before the exit delay, your extrinsic will fail, and you'll see an error in Polkadot.js for <code>parachainStaking.PendingDelegationRequest</code>.</p>"},{"location":"node-operators/networks/collators/activities/#execute-bond-less-request","title":"Execute Bond Less Request","text":"<p>After the exit delay has passed from scheduling a request to decrease your bond, you can execute the request to actually decrease the bond amount. Head to the Developer tab, select Extrinsics, and follow these steps:</p> <ol> <li>Select an account to execute the request with</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the executeCandidateBondLess extrinsic</li> <li>Select the target candidate account (anyone can execute the request after the exit delay has passed since the <code>scheduleCandidateBondLess</code> was submitted)</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p> <p>Once the transaction has been confirmed, you can check your free and reserved balances from the Accounts tab and notice that, now that the execution has gone through, your balances have been updated.</p>"},{"location":"node-operators/networks/collators/activities/#cancel-bond-less-request","title":"Cancel Bond Less Request","text":"<p>If you scheduled a request to bond more or less but changed your mind, as long as the request has not been executed, you can cancel the request at any time and keep your bond amount as is. To cancel the request, head to the Developer tab, select Extrinsics, and follow these steps:</p> <ol> <li>Select your candidate account (and verify it contains the additional funds to be bonded)</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the cancelCandidateBondRequest extrinsic</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p>"},{"location":"node-operators/networks/collators/activities/#mark-collator-as-inactive","title":"Mark a Collator as Inactive","text":"<p>If there is an inactive collator that has not produced blocks for a consecutive number of rounds, you can mark a collator as inactive. The maximum number of rounds a collator can be offline before they can be marked as inactive is as follows:</p> MoonbeamMoonriverMoonbase Alpha <p>1 round (6 hours)</p> <p>2 rounds (4 hours)</p> <p>2 rounds (4 hours)</p> <p>To mark a collator as inactive, you can use the <code>notifyInactiveCollator</code> extrinsic, which will notify the runtime when a collator is inactive and, by default, mark the collator as offline. To do so, you can head to  Polkadot.js Apps, make sure that you are connected to the correct network, then click on the Developer tab, select Extrinsics from the dropdown, and take the following steps:</p> <ol> <li>Select your account</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the notifyInactiveCollator extrinsic</li> <li>Specify the collator to mark as inactive</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p> <p>The collator will temporarily be removed from the candidate pool, and they can rejoin at any time by calling the <code>goOnline</code> extrinsic.</p>"},{"location":"node-operators/networks/collators/author-mapping/","title":"Interacting with the Author Mapping Precompile","text":""},{"location":"node-operators/networks/collators/author-mapping/#introduction","title":"Introduction","text":"<p>The author mapping precompiled contract on Moonbeam allows collator candidates to map session keys to a Moonbeam address where block rewards are paid out, through a familiar and easy-to-use Solidity interface. This enables candidates to complete author mapping with a Ledger or any other Ethereum wallet compatible with Moonbeam. However, it is recommended to generate your keys on an air-gapped machine. You can find out more information by referring to the account requirements section of the Collator Requirements page.</p> <p>To become a collator candidate, you must be running a collator node. You'll also need to join the candidate pool fully sync your node and submit the required bonds before generating your session keys and mapping them to your account. There is an additional bond that must be paid when mapping your session keys.</p> <p>The precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000807\n</code></pre> <pre><code>0x0000000000000000000000000000000000000807\n</code></pre> <pre><code>0x0000000000000000000000000000000000000807\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"node-operators/networks/collators/author-mapping/#the-solidity-interface","title":"The Author Mapping Solidity Interface","text":"<p><code>AuthorMappingInterface.sol</code> is a Solidity interface that allows developers to interact with the precompile's methods.</p> <ul> <li>removeKeys() - removes the author ID and session keys. Replaces the deprecated <code>clearAssociation</code> extrinsic</li> <li>setKeys(bytes memory keys) \u2014 accepts the result of calling <code>author_rotateKeys</code>, which is the concatenated public keys of your Nimbus and VRF keys, and sets the author ID and the session keys at once. Useful after a key rotation or migration. Calling <code>setKeys</code> requires a bond. Replaces the deprecated <code>addAssociation</code> and <code>updateAssociation</code> extrinsics</li> <li>nimbusIdOf(address who) - retrieves the Nimbus ID of the given address. If no Nimbus ID exists for the given address, it returns <code>0</code></li> <li>addressOf(bytes32 nimbusId) - retrieves the address associated to a given Nimbus ID. If the Nimbus ID is unknown, it returns <code>0</code></li> <li>keysOf(bytes32 nimbusId) - retrieves the keys associated to the given Nimbus ID. If the Nimbus ID is unknown, it returns empty bytes</li> </ul>"},{"location":"node-operators/networks/collators/author-mapping/#bonds","title":"Required Bonds","text":"<p>To follow along with this tutorial, you'll need to join the candidate pool and map your session keys to your H160 Ethereum-style account. Two bonds are required to perform both of these actions.</p> <p>The minimum bond to join the candidate pool is set as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>500000 GLMR\n</code></pre> <pre><code>500 MOVR\n</code></pre> <pre><code>500 DEV\n</code></pre> <p>There is a bond that is sent when mapping your session keys with your account. This bond is per session keys registered. The bond set is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>10000 GLMR\n</code></pre> <pre><code>100 MOVR\n</code></pre> <pre><code>100 DEV\n</code></pre>"},{"location":"node-operators/networks/collators/author-mapping/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"node-operators/networks/collators/author-mapping/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The below example is demonstrated on Moonbase Alpha, however, similar steps can be taken for Moonbeam and Moonriver. You should:  </p> <ul> <li>Have MetaMask installed and connected to Moonbase Alpha</li> <li>Have an account with DEV tokens. You should have enough to cover the candidate and mapping bonds plus gas fees to send the transaction and map your session keys to your account. To get enough DEV tokens to follow along with this guide, you can contact a moderator directly via the Moonbeam Discord server</li> <li>Make sure you're running a collator node and it's fully synced</li> <li>Make sure you've joined the candidate pool</li> </ul> <p>As previously mentioned, you can use a Ledger by connecting it to MetaMask, please refer to the Ledger guides on how to import your Ledger to MetaMask. Please note that it is not recommended to use Ledger for production purposes. You can find out more information by referring to the account requirements section of the Collator Requirements page.</p>"},{"location":"node-operators/networks/collators/author-mapping/#generate-session-keys","title":"Generate Session Keys","text":"<p>To match the Substrate standard, Moonbeam collator's session keys are SR25519. This guide will show you how you can create/rotate your session keys associated with your collator node.</p> <p>First, make sure you're running a collator node. Once you have your collator node running, your terminal should print similar logs:</p> 2025-02-25 20:00:52 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12706 (0x1d51.3042), finalized #12704 (0xf74b.aa44), 1 0.4kiB/s 1 0.6kiB/s 2025-02-25 20:00:52 \ud83d\udca4 Idle (6 peers), best: #5751 (Oxc5alesb5), finalized #5750 (0x9dc..e bad), 1 9.6kiB/s 1 3.5kiB/s 2025-02-25 20:00:53 [Relaychain] \u2728 Imported #12707 (0x77ea.4299) 2025-02-25 20:00:57 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12707 (0x77ea..4299), finalized #12704 (0xf74b..aa44), | 16.4kiB/s 1 12.2kiB/s 2025-02-25 20:00:57 \ud83d\udca4 Idle (6 peers), best: #5751 (0xc5a1e8b5), finalized #5750 (0x9fdc...e bad), 1 1.6kiB/s 1 0.4kiB/s 2025-02-25 20:00:59 [Relaychain] \u2728 Imported #12708 (0x009f...3bbf) 2025-02-25 20:01:00 \u2728 Imported #5753 (0x8981.6c81) 2025-02-25 20:01:00 \u2728 Imported #5753 (0x33a...b5e3) 2025-02-25 20:01:02 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12708 (0x009f...3bbf), finalized #12706 (0x1d51.3042), 1 1.5kiB/s 1 1.3kiB/s 2025-02-25 20:01:02 \ud83d\udca4 Idle (6 peers), best: #5752 (0x7036.569e), finalized #5751 (0xc5a1..e8b5), 1 3.3kiB/s 1 5.8kiB/s 2025-02-25 20:01:05 [Relaychain] \u2728 Imported #12709 (0x76b9...bf65) 2025-02-25 20:01:07 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12709 (0x76b9..bf65), finalized #12706 (0x1d51.3042), | 2.0kiB/s | 0.9kiB/s 2025-02-25 20:01:07 \ud83d\udca4 Idle (6 peers), best: #5752 (0x7036.569e), finalized #5751 (0xc5a1..e8b5), 1 0 1 0 <p>Next, session keys can be created/rotated by sending an RPC call to the HTTP endpoint with the <code>author_rotateKeys</code> method. When you call <code>author_rotateKeys</code>, the result is the size of two keys. The response will contain a concatenated Nimbus ID and VRF key. The Nimbus ID will be used to sign blocks and the VRF key is required for block production. The concatenated keys will be used to create an association to your H160 account for block rewards to be paid out.</p> <p>For reference, if your collator's HTTP endpoint is at port <code>9944</code>, the JSON-RPC call might look like this:</p> <pre><code>curl http://127.0.0.1:9944 -H \\\n\"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n  }'\n</code></pre> <p>The collator node should respond with the concatenated public keys of your new session keys. The first 64 hexadecimal characters after the <code>0x</code> prefix represent your Nimbus ID and the last 64 hexadecimal characters are the public key of your VRF session key. You'll use the concatenated public keys when mapping your Nimbus ID and setting the session keys in the next section.</p> curl http://127.0.0.1:9933-H\\ \"Content-Type: application/json;charset=utf-8\" -d \\ '{ \"jsonrpc\": \"2.0\", \"id\" :1, \"method\": \"author_rotatekeys\", \"params\": [] }' {\"jsonrpc\": \"2.0\", \"result\":\"0x72c7ca7ef0794103caeb520806576b52cb085f7577cc12cd36c2d64dbf73757a789407ec0f401a8792ac57c4fb7dabd4da6cc74d9ac9b8dd8c4faf770255403f\", \"id\" :1} <p>Make sure you write down the concatenated public keys. Each of your servers, your primary and backup, should have their own unique keys. Since the keys never leave your servers, you can consider them a unique ID for that server.</p> <p>Next, you'll need to register your session keys and map them to an H160 Ethereum-styled address to which the block rewards are paid.</p>"},{"location":"node-operators/networks/collators/author-mapping/#remix-set-up","title":"Remix Set Up","text":"<p>To get started, get a copy of <code>AuthorMappingInterface.sol</code> and take the following steps:</p> <ol> <li>Click on the File explorer tab</li> <li>Copy and paste the file contents into a Remix file named <code>AuthorMappingInterface.sol</code></li> </ol> <p></p>"},{"location":"node-operators/networks/collators/author-mapping/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile AuthorMappingInterface.sol</li> </ol>"},{"location":"node-operators/networks/collators/author-mapping/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure AuthorMappingInterface.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the author mapping precompile for Moonbase Alpha: <code>0x0000000000000000000000000000000000000807</code> and click At Address</li> </ol> <p>The author mapping precompile will appear in the list of Deployed Contracts.</p>"},{"location":"node-operators/networks/collators/author-mapping/#map-session-keys","title":"Map Session Keys","text":"<p>The next step is to map your session keys to your H160 account (an Ethereum-style address). Make sure you hold the private keys to this account, as this is where the block rewards are paid out to.</p> <p>To map your session keys to your account, you need to be inside the candidate pool. Once you are a candidate, you need to send a mapping extrinsic. Note that this will bond tokens per author ID registered.</p> <p>Before getting started, ensure you're connected to the account that you want to map your session keys to. This will be the account where you will receive block rewards.</p> <ol> <li>Expand the AUTHORMAPPING contract</li> <li>Expand the setKeys method</li> <li>Enter your session keys</li> <li>Click transact</li> <li>Confirm the MetaMask transaction that appears by clicking Confirm</li> </ol> <p></p> <p>To verify you have mapped your session keys successfully, you can use either the <code>mappingWithDeposit</code> method or the <code>nimbusLookup</code> method of the author mapping pallet. To do so, please refer to the Check Mappings section of the Collator Account Management guide.</p>"},{"location":"node-operators/networks/collators/faq/","title":"Frequently Asked Questions","text":""},{"location":"node-operators/networks/collators/faq/#introduction","title":"Introduction","text":"<p>Collators are an integral part of the parachains they take part in. They receive transactions and create state transition proofs for the relay chain validators.</p> <p>Running a Moonbeam collator requires Linux systems administration skills, careful monitoring, and an attention to detail. Below are some tips and tricks that have been accumulated which should help you get up and running quickly.</p>"},{"location":"node-operators/networks/collators/faq/#q-a","title":"Q &amp; A","text":"<p>Q: Where can I get help?</p> <p>A: There is an active and friendly Discord community for collators. Join the server and introduce yourself even before you need help. Send gilmouta or artkaseman a DM and let them know who you are, and they can reach out to you if they see any issues with your node.</p> <p>Q: How do I stay up to date?</p> <p>A: All upgrades and important technical information are announced on Discord, in the #tech-upgrades-announcements channel. Join and follow this channel. You can set up integrations to Slack or Telegram if those are your preferred communication channels.</p> <p>Q: How do I register my node?</p> <p>A: There is a questionnaire, in which you will be able to provide your contact information as well as some basic hardware specs. You must be running a collator node on Moonbase Alpha to fill out the questionnaire.</p> <p>Q: What are the hardware requirements?</p> <p>A: Running a collator requires top of the line hardware to be able to process transactions and maximize your rewards. This is a very important factor in block production and rewards.</p> <p>Run a systemd service on a top of the line bare-metal machine (i.e. run a physical server, not a cloud VM, or a docker container). You can run your own, or select a provider to manage the server for you.</p> <p>Run only one service at a time per bare-metal machine. Do not run multiple instances.</p> <p>Q: What is the recommended hardware to run a collator?</p> <p>A:</p> <p>Hardware recommendations:</p> <ul> <li>Top of the line CPU:<ul> <li>Ryzen 9 5950x or 5900x</li> <li>Intel Xeon E-2386 or E-2388</li> </ul> </li> <li>Primary and backup bare metal servers in different data centers and countries (Hetzner is OK for one of them)</li> <li>Dedicated server for Moonbeam that isn't shared with any other apps</li> <li>1 TB NVMe SSD</li> <li>32 GB RAM</li> </ul> <p>Q: What about backup nodes?</p> <p>A: Run two bare-metal machines of the same specifications, in different countries and service providers. If your primary fails you can quickly resume services on your backup and continue to produce blocks and earn rewards. Please refer to the Q&amp;A on failovers below.</p> <p>Q: What are the different networks?</p> <p>A: There are three networks, and each requires dedicated hardware. The Moonbase Alpha TestNet is free and should be used to familiarize yourself with the setup.</p> <ul> <li>Moonbeam - production network on Polkadot</li> <li>Moonriver - production network on Kusama</li> <li>Moonbase Alpha TestNet - development network</li> </ul> <p>Q: What ports do I allow on my firewall?</p> <p>A:</p> <ul> <li>Allow all incoming requests on TCP ports 30333 and 30334</li> <li>Allow requests from your management IPs on TCP port 22</li> <li>Drop all other ports</li> </ul> <p>Q: Is there a CPU optimized binary?</p> <p>A: On each release page are CPU optimized binaries. Select the binary for your CPU architecture.</p> <ul> <li>Moonbeam-znver3 - Ryzen 9</li> <li>Moonbeam-skylake - Intel</li> <li>Moonbeam - generic can be used for all others</li> </ul> <p>Q: What are the recommendations on monitoring my node?</p> <p>A: Monitoring is very important for the health of the network and to maximize your rewards. We recommend using Grafana Labs. They have a free tier which should handle 6+ moonbeam servers.</p> <p>Q: What are the KPIs I should be monitoring?</p> <p>A: The main key performance indicator is blocks produced. The prometheus metric for this is called <code>substrate_proposer_block_constructed_count</code>.  </p> <p>Q: How should I setup alerting?</p> <p>A: Alerting is critical to keeping your moonbeam node producing blocks and earning rewards. We recommend pagerduty.com, which is supported by Grafana Labs. Use the KPI query above and set an alert when this drops below 1. The alert should page the person on-call 24/7.  </p> <p>Q: What are Nimbus keys?</p> <p>A: Nimbus keys are just like session keys in Polkadot. You should have unique keys on your primary and backup servers. Save the key output somewhere safe where you can access it in the middle of the night if you receive an alert. To create your keys, please refer to the Session Keys section of the documentation.</p> <p>Q: What is the failover process if my primary node is down?</p> <p>A: When the primary server is down, the best way to perform a failover to the backup server is to perform a key association update. Each server should have a unique set of keys already. Run the <code>setKeys</code> author mapping extrinsic. You can follow the Mapping Extrinsic instructions and modify the instructions to use the <code>setKeys</code> extrinsic.</p> <p>Q: Should I set up centralized logging?</p> <p>A: Grafana Labs can also be configured for centralized logging and is recommended. You can see all your nodes in one place. Kibana has a more robust centralized logging offering, but Grafana is simple and good enough to start.</p> <p>Q: What should I look for in the logs?</p> <p>A: Logs are very useful to determine if you are in sync and ready to join the collators pool. Look at the tail end of the logs to determine if: </p> <ol> <li>Your Relay chain is in sync</li> <li>Your parachain is in sync</li> </ol> <p>You should see Idle in your logs when your node is in sync.</p> <p></p> <p>A common issue is joining the pool before your node is in sync. You will be unable to produce any blocks or receive any rewards. Wait until you are in sync and idle before joining the candidate pool.</p> moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f 10 Syncing 137.9 bps, target=#12325010 (8 peers), best: #21001 (0x25d9...57d8), finalized #20992 (0x1ebb..fd23), # 214.4kiB/s 11.7kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f * Syncing 182.7 bps, target=#5219905 (8 peers), best: #22472 (0x875f..aed7), finalized #9625 (0x601b...e64f), # 371.0kiB/s 113.3kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f I Syncing 186.6 bps, target=#12325011 (8 peers), best: #21935 (0x58f8...d312), finalized #21585 (0x1d73...13c8), #271.9kiB/s T1.3kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f @ Syncing 193.4 bps, target=#5219905 (8 peers), best: #23440 (0xdce6...8ea6), finalized #9922 (0x07c9...1fdf), # 383.3kiB/s 17.5kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f \u00d6 Syncing 189.5 bps, target=#12325012 (8 peers), best: #22883 (0x6531.2281), finalized #22528 (0x0f21.0855), # 290.8kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f @ Syncing 206.4 bps, target=#5219905 (8 peers), best: #24474 (0x09dd...6700), finalized #10393 (0x3efc...8a40), #428.7kiB/s 12.4kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f . Syncing 171.6 bps, target=#12325013 (8 peers), best: #23744 (0x4ced...cdae), finalized #23552 (0x1773..09d9), # 252.4kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f Syncing 212.3 bps, target=#5219905 (8 peers), best: #25536 (0x7bc0...e9b7), finalized #10905 (0x5c70...3063), 1427.1kiB/s 11.4kiB/s <p>The relay chain takes much longer to sync than the parachain. You will not see any finalized blocks until the relay chain has synced.</p> <p>Q: How much is the bond to become a collator?</p> <p>A: There are two bonds you need to be aware of. Make sure your node is configured and in sync before proceeding with these steps.</p> <p>The first is the bond to join the collators pool:</p> <ul> <li>Moonbeam - minimum of 500000 GLMR</li> <li>Moonriver - minimum of 500 MOVR</li> <li>Moonbase Alpha - minimum of 500 DEV</li> </ul> <p>The second is the bond for key association:</p> <ul> <li>Moonbeam - minimum of 10000 GLMR</li> <li>Moonriver - minimum of 100 MOVR</li> <li>Moonbase Alpha - minimum of 100 DEV</li> </ul> <p>Q: How do I set an identity on my collator account? </p> <p>A: Setting an identity on chain will help to identify your node and attract delegations. You can set an identity by following the instructions on the Managing an Identity page of our documentation.</p>"},{"location":"node-operators/networks/collators/orbiter/","title":"Moonbeam Orbiter Program","text":""},{"location":"node-operators/networks/collators/orbiter/#introduction","title":"Introduction","text":"<p>The Moonbeam Foundation is announcing a limited trial of the orbiter program. Similar to Decentralized Nodes, this program allows collators to participate in the diversity and security of the network even if they do not have enough funds or backing to otherwise be in the active set. This program was developed with the input from the community.</p> <p>The Moonbeam Foundation will maintain orbiter pools in the active set, and will assign authority to produce blocks to each of the members in the program, who are called orbiters. </p> <p>The active orbiter will rotate on a regular fixed basis to maintain a fair distribution of active rounds. The orbiters\u2019 performance will be monitored and payouts for each round will be redirected to each orbiter based on their blocks produced that round. Rewards overall will be shared with all other orbiters assigned to each specific collator account. </p> <p>As long as an orbiter\u2019s performance is within a range of their peers, they will maintain their position in the rotation. If they fall below this threshold, they will be removed from the pool and demoted to the back of the waiting list for Moonbase Alpha. A new orbiter from the waiting list will take their slot. </p>"},{"location":"node-operators/networks/collators/orbiter/#duration","title":"Duration","text":"<p>As the program progresses, the Moonbeam Foundation will assess the results and make adjustments. There is no specific end date, but the program may come to an end or materially change. Participants are both encouraged to give feedback throughout the program as well as be aware that it may change from the concept explained here.</p>"},{"location":"node-operators/networks/collators/orbiter/#eligibility","title":"Eligibility","text":"<p>To participate in the orbiter program, you must meet the following eligibility criteria:</p> <ul> <li>Due to the nature of the program, each orbiter must pass an identity verification check, and cannot be a resident of certain jurisdictions</li> <li>Each orbiter must post a bond. This bond is posted to protect against bad behavior and will be subject to slashing</li> <li>Each entity (person or group) may only run one orbiter per network (i.e., one on Moonriver and one on Moonbeam)</li> <li>Orbiters cannot run another active collator on the same network as their orbiter. They can, however, run an active collator on Moonbeam and an orbiter on Moonriver, or vice versa, as long as they do not also have both on the same network</li> </ul>"},{"location":"node-operators/networks/collators/orbiter/#communication","title":"Communication","text":"<p>A private discord group will be created for this program, and most communication will happen over this channel or through DM. Once you've filled out your application, you'll be added to the group.</p>"},{"location":"node-operators/networks/collators/orbiter/#configuration","title":"Orbiters and Orbiter Pool Configurations","text":"<p>Orbiter pools are maintained by the Moonbeam Foundation, and will assign block production authority to each orbiter. The maximum number of orbiters per orbiter pool for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>6 orbiters per pool\n</code></pre> <pre><code>3 orbiters per pool\n</code></pre> <pre><code>8 orbiters per pool\n</code></pre> <p>For Moonbeam and Moonriver there is also a maximum number of orbiter pools that will be allowed in the active set. For Moonbase Alpha, there will be as many orbiter pools as needed. The maximum is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>5 orbiter pools\n</code></pre> <pre><code>8 orbiter pools\n</code></pre> <pre><code>Unlimited orbiter pools\n</code></pre> <p>Each orbiter will be active for a certain number of rounds before the next orbiter will take over. The number of active rounds for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>1 round (~6 hours)\n</code></pre> <pre><code>3 rounds (~6 hours)\n</code></pre> <pre><code>3 rounds (~6 hours)\n</code></pre>"},{"location":"node-operators/networks/collators/orbiter/#application-and-onboarding-process","title":"Application and Onboarding Process","text":"<p>To join the orbiter program, you'll need to start by filling out an application where you'll need to submit contact information, social media handles, and collator and node details. At the end of the form, you'll also need to follow the instructions to complete identity verification.</p> Moonbeam Orbiter Program Application <p>Once you've passed identity verification and have been accepted into the program, you'll be notified and then the onboarding process will begin. New orbiters must run a Moonbase Alpha node for two weeks to be eligible to run a Moonriver node. Orbiters then must run a Moonriver node for four weeks to be eligible to run a Moonbeam node. Once you are eligible, you are not required to run orbiters on any network. You can leave other networks at any time by unregistering and you will receive your bond back. To join again on that network you will need to re-register and will be at the end of the queue.</p> <p>An outline of the onboarding process is as follows:</p> <ul> <li>Prepare your node by syncing it</li> <li>Once fully synced, you can generate your session keys</li> <li>Register your session keys and post the associated mapping bond</li> <li>Once you are ready, register as an orbiter via the <code>moonbeamOrbiters.orbiterRegister()</code> extrinsic and post the associated orbiter bond</li> <li>Orbiters will be placed in a waiting list for each network until a slot is available</li> <li>Once a slot opens up, you'll begin producing blocks and receiving rewards on the respective network</li> </ul>"},{"location":"node-operators/networks/collators/orbiter/#bond","title":"Bonds","text":""},{"location":"node-operators/networks/collators/orbiter/#mapping-bond","title":"Mapping Bond","text":"<p>There is a bond that is sent when mapping your author ID with your account. This bond is per author ID registered. The bond set is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>10000 GLMR\n</code></pre> <pre><code>100 MOVR\n</code></pre> <pre><code>100 DEV\n</code></pre>"},{"location":"node-operators/networks/collators/orbiter/#orbiter-bond","title":"Orbiter Bond","text":"<p>As previously mentioned, each orbiter must submit a bond to join the program. This bond differs from the one for the active set as it does not earn any delegation rewards while bonded. The current bonds are as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>30000 GLMR\n</code></pre> <pre><code>400 MOVR\n</code></pre> <pre><code>100 DEV\n</code></pre>"},{"location":"node-operators/networks/collators/orbiter/#rewards","title":"Rewards","text":"<p>Rewards for orbiters will be split between the other orbiters assigned to the same orbiter pool. The maximum orbiters per orbiter pool is described in the configuration section. In the case of Moonriver it\u2019s 3, so the rewards will be approximately 1/3 of a collator\u2019s rewards. The blocks produced by each orbiter while active are tracked, and rewards are proportionally distributed.</p>"},{"location":"node-operators/networks/collators/orbiter/#performance-metrics","title":"Performance Metrics","text":"<p>Each orbiter\u2019s performance will be assessed over a period of time to determine they are active and producing blocks, and if their performance is within a range of all other orbiter pool collators. Orbiters are expected to run top tier hardware to stay within range. For more information on hardware requirements, please check out the Collator Requirements page. </p> <p>Metrics will be assessed over seven day periods. The performance metrics are as follows:</p> <ul> <li>Orbiter has produced a block within the last three rounds they were active </li> <li>Orbiter\u2019s block production is within two standard deviation of the seven day program mean</li> <li>Orbiter\u2019s transactions per block is within two standard deviation of the seven day program mean </li> <li>Orbiter\u2019s block weight is within two standard deviation of the seven day program mean</li> </ul> <p>Note</p> <p>These factors are subject to change as the program progresses.</p>"},{"location":"node-operators/networks/collators/orbiter/#leaving-the-program","title":"Leaving the Program","text":"<p>An orbiter may leave the program and receive their bond back without any delay. The only limitation on this is if the orbiter is currently active they cannot leave; once they are no longer active they can leave at any time by issuing the <code>moonbeamOrbiters.orbiterUnregister()</code> extrinsic. </p>"},{"location":"node-operators/networks/collators/overview/","title":"Run a Collator on Moonbeam","text":""},{"location":"node-operators/networks/collators/overview/#introduction","title":"Introduction","text":"<p>Collators are members of the network that maintain the parachains they take part in. They run a full node (for both their particular parachain and the relay chain), and they produce the state transition proof for relay chain validators.</p> <p>There are some requirements that need to be considered prior to becoming a collator candidate including machine, bonding, account, and community requirements.</p> <p>Candidates will need a minimum amount of tokens bonded (self-bonded) to be considered eligible. Only a certain number of the top collator candidates by total stake, including self-bonded and delegated stake, will be in the active set of collators. Otherwise, the collator will remain in the candidate pool.</p> <p>Once a candidate is selected to be in the active set of collators, they are eligible to produce blocks.</p> <p>Moonbeam uses the Nimbus Parachain Consensus Framework. This provides a two-step filter to allocate candidates to the active set of collators, then assign collators to a block production slot:</p> <ul> <li>The parachain staking filter selects the top candidates in terms of tokens staked in each network. For the exact number of top candidates per each network and the minimum bond amount, you can check out the Minimum Collator Bond section of our documentation. This filtered pool is called selected candidates (also known as the active set), which are rotated every round</li> <li>The fixed size subset filter picks a pseudo-random subset of the previously selected candidates for each block production slot</li> </ul> <p>Users can spin up full nodes on Moonbeam, Moonriver, and Moonbase Alpha and activate the <code>collate</code> feature to participate in the ecosystem as collator candidates. To do this, you can checkout the Run a Node section of the documentation and spin up a node using either Docker or Systemd.</p>"},{"location":"node-operators/networks/collators/overview/#join-discord","title":"Join the Discord","text":"<p>As a collator, it is important to keep track of updates and changes to configuration. It is also important to be able to easily contact us and vice versa in case there is any issue with your node, as that will not only negatively affect collator and delegator rewards, it will also negatively affect the network.</p> <p>For this purpose, we use Discord. The most relevant Discord channels for collators are the following:</p> <ul> <li>tech-upgrades-announcements \u2014 here we will publish any updates or changes in configuration changes collators will be required to follow. We will also announce any technical issues to monitor, such as network stalls</li> <li>collators \u2014 this is the general collator discussion channel. We are proud of having an active and friendly collator community so if you have any questions, this is the place to ask. We will also ping collators here for any issues that require their attention.</li> <li>meet-the-collators \u2014 in this channel you can introduce yourself to potential delegators</li> </ul> <p>After you join our Discord, feel free to DM gilmouta or artkaseman and introduce yourself. This will let us know who to contact if we see an issue with your node, and will also let us assign the relevant Discord collator role, enabling you to post in meet-the-collators.</p>"},{"location":"node-operators/networks/collators/requirements/","title":"Collator Requirements","text":""},{"location":"node-operators/networks/collators/requirements/#introduction","title":"Introduction","text":"<p>There are some requirements to keep in mind before diving into running a collator node. Primarily, you need to follow the community guidelines and meet the technical requirements. You should have top of the line hardware, securely created and stored accounts, meet bonding requirements, and fill out a collator questionnaire.</p> <p>It is recommended to go through all of the necessary requirements on the Moonbase Alpha TestNet before collating on a production network like Moonbeam or Moonriver.</p> <p>This guide will help you to get started fulfilling the collator requirements so you can get your node up and running in no time.</p>"},{"location":"node-operators/networks/collators/requirements/#community-guidelines","title":"Community Guidelines","text":"<p>Collators have a responsibility to the network to act honorably. If any of the following forbidden offenses occur, action may be taken via on-chain governance:</p> <ul> <li>An entity is running more than four collators in either network</li> <li>A collator is running multiple nodes using the same Nimbus key causing equivocation. Equivocation is the action of submitting multiple blocks at the same block height, which forks the network. It is strictly forbidden due to the network degradation that it implies. This can be done by a malicious actor (trying to get more blocks included/produced) or by mistake (having a backup node running with the same key). Each node needs to have its own unique keys and any backup solutions need to ensure there can be no possibility of equivocation</li> <li>A collator acts in a nefarious manner that is uncharitable to the community or other collators</li> </ul> <p>There is a level of commitment to the community and the network that is necessary to gain trust from the community of delegators and attract more delegations. The following contains some suggestions for contributing to the community:</p> <ul> <li>Be active in the community<ul> <li>Join the Discord and introduce yourself, provide updates as needed, and help support community members or other collators</li> </ul> </li> <li>Create tutorials and educational content</li> <li>Become a Moonbeam Ambassador</li> <li>Contribute to open-source software relating to the ecosystem</li> <li>Actively participate in governance and vote on proposals</li> </ul>"},{"location":"node-operators/networks/collators/requirements/#hardware-requirements","title":"Hardware Requirements","text":"<p>Collators must have a full node running with the collation options. To do so, follow the Run a Node tutorial and installation steps for Using Systemd. Make sure you use the specific code snippets for collators.</p> <p>Note</p> <p>Running a collator node has higher CPU requirements than the ones provided in the above tutorial. In order for your collator node to be able to keep up with a high transaction throughput a CPU with high clock speed and single-core performance is important, as the block production/import process is almost entirely single-threaded. Running your collator node in Docker is also not recommended, as it will have a significant impact in performance.</p> <p>From a hardware perspective, it is important to have top of the line hardware to maximize block production and rewards. The following are some hardware recommendations that have performed well and provided the best results:</p> <ul> <li>Recommended CPUs - Intel Xeon E-2386/2388 or Ryzen 9 5950x/5900x</li> <li>Recommended NVMe - 1 TB NVMe</li> <li>Recommended RAM - 32 GB RAM</li> </ul> <p>In addition, you should take into account the following considerations:</p> <ul> <li>As most cloud providers focus on multi-thread rather than single-thread performance, using a bare-metal provider is recommended</li> <li>You should have primary and backup bare metal servers in different data centers and countries. Hetzner is OK for one of these servers, but shouldn't be used for both</li> <li>Your Moonbeam server should be dedicated for Moonbeam only, please do not use the same server for other apps</li> </ul>"},{"location":"node-operators/networks/collators/requirements/#account-requirements","title":"Account Requirements","text":"<p>Similar to Polkadot validators, you need to create an account. For Moonbeam, this is an H160 account or an Ethereum-style account from which you hold the private keys. As a collator, you are responsible for correctly managing your own keys. Incorrectly doing so can result in a loss of funds.</p> <p>There are many Ethereum wallets that can be used, but for production purposes it is recommended to generate keys as securely as possible. It is also recommended to generate backup keys. You can actually generate keys using the Moonbeam binary through a tool called Moonkey. It can be used to generate both Ethereum-style accounts and Substrate-style accounts.</p> <p>To generate keys securely it is recommended to do so on an air-gapped machine. Once you generate your keys, make sure you store them safely. To securely store your keys, here are some recommendations, from least to most secure:</p> <ul> <li>Write down and laminate your keys</li> <li>Engrave your keys into a metal plate</li> <li>Shard your keys using a tool like Horcrux</li> </ul> <p>As always, it is recommended to do your own research and use tools that you vet as trustworthy.</p>"},{"location":"node-operators/networks/collators/requirements/#getting-started-with-moonkey","title":"Getting Started with Moonkey","text":"<p>The first step is to fetch the moonkey binary file hosted on GitHub. To do so, you can download a binary file (tested on Linux/Ubuntu):</p> <p><code>https://github.com/moonbeam-foundation/moonbeam/releases/download/v0.8.0/moonkey</code></p> <p>Once you\u2019ve downloaded the tool, ensure you have the correct access permissions to execute the binary file. Next, check that you have the right version by checking the downloaded file hash.</p> <p>For Linux-based systems such as Ubuntu, open the terminal and head to the folder where the moonkey binary file is located. Once there, you can use the sha256sum tool to calculate the SHA256 hash:</p> <pre><code>019c3de832ded3fccffae950835bb455482fca92714448cc0086a7c5f3d48d3e\n</code></pre> <p>After you\u2019ve verified the hash, it is recommended to move the binary file to an air-gapped machine (no network interfaces). You can also check the hash of the file in the air-gapped device directly.</p>"},{"location":"node-operators/networks/collators/requirements/#generating-an-account-with-moonkey","title":"Generating an Account with Moonkey","text":"<p>Using the moonkey binary file is very straightforward. Every time you execute the binary, the information related to a newly created account is displayed.</p> <p>This information includes:</p> <ul> <li>Mnemonic seed - a 24-word mnemonic that represents your account in readable words. This gives direct access to your funds, so you need to store these words securely</li> <li>Private key - the private key associated with your account, used for signing. This is derived from the mnemonic seed. This gives direct access to your funds, so you need to store it securely</li> <li>Public address - your account\u2019s address</li> <li>Derivation path - tells the Hierarchical Deterministic (HD) wallet how to derive the specific key</li> </ul> <p>Note</p> <p>Please safely store the private key/mnemonic and do not share it with anyone. Private keys/mnemonics provide direct access to your funds.</p> <p>It is recommended that you use the binary file in an air-gapped machine.</p>"},{"location":"node-operators/networks/collators/requirements/#other-moonkey-features","title":"Other Moonkey Features","text":"<p>Moonkey provides some additional functionalities. The following flags can be provided:</p> <ul> <li><code>-help</code> \u2013 prints help information</li> <li><code>-version</code> \u2013 prints version of moonkey you are running</li> <li><code>-w12</code> \u2013 generates a 12 words mnemonic seed (default is 24)</li> </ul> <p>The following options are available:</p> <ul> <li><code>-account-index</code> \u2013 provide as input the account index to use in the derivation path</li> <li><code>-mnemonic</code> \u2013 provide as input the mnemonic</li> </ul>"},{"location":"node-operators/networks/collators/requirements/#bonding-requirements","title":"Bonding Requirements","text":"<p>There are two bonds for you to be aware of: a bond to join the collator pool and a bond for key association.</p>"},{"location":"node-operators/networks/collators/requirements/#minimum-collator-bond","title":"Minimum Collator Bond","text":"<p>First, you will need a minimum amount of tokens staked (self-bonded) to be considered eligible and become a candidate. Only a certain number of the top collator candidates by total stake, including self-bonded and delegated stake (total bonded), will be in the active set of collators.</p> MoonbeamMoonriverMoonbase Alpha Variable Value Minimum self-bond amount 500000 GLMR Active set size 75 collators Variable Value Minimum self-bond amount 500 MOVR Active set size 72 collators Variable Value Minimum self-bond amount 500 DEV Active set size 11 collators"},{"location":"node-operators/networks/collators/requirements/#key-association-bond","title":"Key Association Bond","text":"<p>Secondly, you will need a bond for key association. This bond is required when mapping your author ID (session keys) with your account for block rewards, and is per author ID registered.</p> MoonbeamMoonriverMoonbase Alpha Variable Value Minimum bond 10000 GLMR Variable Value Minimum bond 100 MOVR Variable Value Minimum bond 100 DEV"},{"location":"node-operators/networks/collators/requirements/#collator-questionnaire","title":"Collator Questionnaire","text":"<p>There is a Collator Questionnaire, that aims to assess the state of all collators on Moonbase Alpha. You should be running a collator node on Moonbase Alpha before filling out this form. You will be able to provide your contact information as well as some basic hardware specs. It provides a way to open the lines of communication between you and the Moonbeam team in case any problems with your node arise.</p>"},{"location":"node-operators/networks/run-a-node/compile-binary/","title":"Manually Compile the Moonbeam Binary","text":""},{"location":"node-operators/networks/run-a-node/compile-binary/#introduction","title":"Introduction","text":"<p>Running a full node on a Moonbeam-based network allows you to connect to the network, sync with a boot node, obtain local access to RPC endpoints, author blocks on the parachain, and more.</p> <p>This guide is meant for people with experience compiling Substrate-based blockchain nodes. A parachain node is similar to a typical Substrate node, but there are some differences. A Substrate parachain node will be a bigger build because it contains code to run the parachain itself as well as code to sync the relay chain and facilitate communication between the two. This build is quite large, may take over 30 minutes, and requires at least 32 GB of memory.</p> <p>To get started quickly without the hassle of compiling the binary yourself, you can use The Release Binary.</p>"},{"location":"node-operators/networks/run-a-node/compile-binary/#compile-the-binary","title":"Compile the Binary","text":"<p>Manually compiling the binary can take around 30 minutes and requires 32GB of memory.</p> <p>The following commands will build the latest release of the Moonbeam parachain.</p> <ol> <li> <p>Clone the Moonbeam repo</p> <pre><code>git clone https://github.com/moonbeam-foundation/moonbeam\ncd moonbeam\n</code></pre> </li> <li> <p>Check out the latest release</p> <pre><code>git checkout tags/$(git describe --tags)\n</code></pre> </li> <li> <p>If you already have Rust installed, you can skip the next two steps. Otherwise, install Rust and its prerequisites via Rust's recommended method</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> </li> <li> <p>Update your <code>PATH</code> environment variable</p> <pre><code>source $HOME/.cargo/env\n</code></pre> </li> <li> <p>Build the parachain binary</p> <p>Note</p> <p>If you are using Ubuntu 20.04 or 22.04, then you will need to install these additional dependencies before building the binary:</p> <pre><code>apt install clang protobuf-compiler libprotobuf-dev pkg-config libssl-dev -y \n</code></pre> <pre><code>cargo build --release\n</code></pre> </li> </ol> <p></p> <p>If a cargo not found error shows up in the terminal, manually add Rust to your system path or restart your system:</p> <pre><code>source $HOME/.cargo/env\n</code></pre> <p>Now you can use the Moonbeam binary to run a Systemd service. To set up the service and run it, please refer to the Run a Node on Moonbeam Using Systemd guide.</p>"},{"location":"node-operators/networks/run-a-node/docker/","title":"Run a Node on Moonbeam Using Docker","text":""},{"location":"node-operators/networks/run-a-node/docker/#introduction","title":"Introduction","text":"<p>Running a full node on a Moonbeam-based network allows you to connect to the network, sync with a bootnode, obtain local access to RPC endpoints, author blocks on the parachain, and more.</p> <p>In this guide, you'll learn how to quickly spin up a Moonbeam node using Docker and how to maintain and purge your node.</p>"},{"location":"node-operators/networks/run-a-node/docker/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you'll need to:</p> <ul> <li>Install Docker. At the time of writing, the Docker version used was 24.0.6</li> <li>Make sure that your system meets the requirements. When connecting to Moonriver on Kusama or Moonbeam on Polkadot, it will take a few days to completely sync the embedded relay chain</li> </ul>"},{"location":"node-operators/networks/run-a-node/docker/#storage-chain-data","title":"Set up Storage for Chain Data","text":"<p>To set up the directory for storing chain data, you'll need to:</p> <ol> <li> <p>Create a local directory</p> MoonbeamMoonriverMoonbase Alpha <pre><code>mkdir /var/lib/moonbeam-data\n</code></pre> <pre><code>mkdir /var/lib/moonriver-data\n</code></pre> <pre><code>mkdir /var/lib/alphanet-data\n</code></pre> </li> <li> <p>Set the ownership and permissions for the local directory that stores the chain data. You can set the permissions either for a specific or current user (replace <code>INSERT_DOCKER_USER</code> for the actual user that will run the <code>docker</code> command)</p> MoonbeamMoonriverMoonbase Alpha <pre><code># chown to a specific user\nchown INSERT_DOCKER_USER /var/lib/moonbeam-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/moonbeam-data\n</code></pre> <pre><code># chown to a specific user\nchown INSERT_DOCKER_USER /var/lib/moonriver-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/moonriver-data\n</code></pre> <pre><code># chown to a specific user\nchown INSERT_DOCKER_USER /var/lib/alphanet-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/alphanet-data\n</code></pre> </li> </ol>"},{"location":"node-operators/networks/run-a-node/docker/#start-up-commands","title":"Start-up Commands","text":"<p>To spin up your node, you'll need to execute the <code>docker run</code> command. If you're setting up a collator node, make sure to follow the code snippets for collators.</p> <p>Note that in the following start-up command, you have to:</p> <ul> <li>Replace <code>INSERT_YOUR_NODE_NAME</code> with your node name of choice. You'll have to do this in two places: one for the parachain and one for the relay chain</li> <li>Replace <code>INSERT_RAM_IN_MB</code> for 50% of the actual RAM your server has. For example, for 32GB of RAM, the value must be set to <code>16000</code>. The minimum value is <code>2000</code>, but it is below the recommended specs</li> </ul> <p>For an overview of the flags used in the following start-up commands, plus additional commonly used flags, please refer to the Flags page of our documentation.</p> <p>For Apple Silicon users</p> <p>If Docker commands fail or behave unexpectedly on Apple Silicon, enable Use Rosetta for x86_64/amd64 emulation on Apple Silicon in Docker Desktop settings and use the <code>amd64</code> platform for both pull and run commands. For example:</p> <pre><code>docker pull --platform=linux/amd64 moonbeamfoundation/moonbeam:v0.47.0\n</code></pre> <pre><code>docker run --platform=linux/amd64 ...\n</code></pre>"},{"location":"node-operators/networks/run-a-node/docker/#full-node","title":"Full Node","text":"Linux snippets MoonbeamMoonriverMoonbase Alpha <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain moonriver \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain alphanet \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> MacOS snippets MoonbeamMoonriverMoonbase Alpha <pre><code>docker run -p 9944:9944 -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run -p 9944:9944 -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain moonriver \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run -p 9944:9944 -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain alphanet \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre>"},{"location":"node-operators/networks/run-a-node/docker/#allow-external-access","title":"Allow External Access to Your Node","text":"<p>If you want to run an RPC endpoint, connect to Polkadot.js Apps, or run your own application, you can use the <code>--unsafe-rpc-external</code> flag to run the full node with external access to the RPC ports.</p> Example start-up command for Moonbeam LinuxMacOS <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--unsafe-rpc-external \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run -p 9944:9944 -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--unsafe-rpc-external \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre>"},{"location":"node-operators/networks/run-a-node/docker/#use-sql","title":"Use a SQL Backend for Frontier","text":"<p>The default Frontier database, which comes standard with Moonbeam nodes and contains all of the Ethereum-related elements, such as transactions, blocks, and logs, can be modified to use a SQL backend. Since <code>eth_getLogs</code> is a very resource-intensive method, the SQL backend aims to provide a more performant alternative for indexing and querying Ethereum logs in comparison to the default RocksDB database.</p> <p>To spin up a node with a Frontier SQL backend, you'll need to add the <code>--frontier-backend-type sql</code> flag to your start-up command.</p> <p>There are additional flags you can use to configure the pool size, query timeouts, and more for your SQL backend; please refer to the Flags page for more information.</p> Example start-up command for Moonbeam LinuxMacOS <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n# This is a comment\n--db-cache INSERT_RAM_IN_MB \\\n--frontier-backend-type sql \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run -p 9944:9944 -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--frontier-backend-type sql \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre>"},{"location":"node-operators/networks/run-a-node/docker/#collator-node","title":"Collator Node","text":"<p>Beginning with v0.39.0, new Moonbeam collator nodes will no longer generate session keys automatically on start-up. Nodes in existence prior to v0.39.0 do not need to make changes to how they handle session keys. </p> <p>When setting up a new node, run the following command to generate and store on disk the session keys that will be referenced in the start-up command: </p> MoonbeamMoonriverMoonbase Alpha <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n moonbeamfoundation/moonbeam:v0.47.0 key generate-node-key --base-path /var/lib/moonbeam-data --chain moonbeam \n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n moonbeamfoundation/moonbeam:v0.47.0 key generate-node-key --base-path /var/lib/moonriver-data --chain moonriver \n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n moonbeamfoundation/moonbeam:v0.47.0 key generate-node-key --base-path /var/lib/alphanet-data --chain alphanet &amp;&amp; sudo chown -R moonbase_service  /var/lib/alphanet-data\n</code></pre> <p>Note</p> <p>You need to change ownership of the newly created folder to the specific user or current user for Docker. Node key generation steps can be bypassed using the <code>--unsafe-force-node-key-generation</code> parameter in the start-up command, although this is not the recommended practice.</p> <p>Now you can run your Docker start up commands:</p> Linux snippets MoonbeamMoonriverMoonbase Alpha <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--collator \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain moonriver \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--collator \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain alphanet \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--collator \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> MacOS snippets MoonbeamMoonriverMoonbase Alpha <pre><code>docker run -p 9944:9944 -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--collator \\\n--trie-cache-size 1073741824 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run -p 9944:9944 -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain moonriver \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--collator \\\n--trie-cache-size 1073741824 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run -p 9944:9944 -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--base-path /data \\\n--chain alphanet \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--collator \\\n--trie-cache-size 1073741824 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre>"},{"location":"node-operators/networks/run-a-node/docker/#syncing-your-node","title":"Syncing Your Node","text":"<p>Once Docker pulls the necessary images, your full node will start, displaying lots of information, such as the chain specification, node name, role, genesis state, and more.</p> docker run --network=\"host\" -v \"/var/lib/alphanet-data:/d ata\" -u $(id-u ${USER}):$(id -g #{USER}) moonbeam-foundation/moonbeam:v0.47.0 --base-path=/d ata --chain alphanet --name=\"TestNode\" --state-pruning archive --trie-cache-size 1073741824 --db-cache 8000 ----name=\"TestNode (Embedded Relay)\" 2025-07-10 09:04:26 Moonbeam Parachain Collator  2025-07-10 09:04:26 \u270c\ufe0f  version 0.47.0-d7df89e7161  2025-07-10 09:04:26 \u2764\ufe0f  by PureStake, 2019-2025  2025-07-10 09:04:26 \ud83d\udccb Chain specification: Moonbase Development Testnet  2025-07-10 09:04:26 \ud83c\udff7  Node name: TestNode  2025-07-10 09:04:26 \ud83d\udc64 Role: FULL  2025-07-10 09:04:26 \ud83d\udcbe Database: RocksDb at /data/chains/moonbase_alpha/db/full  2025-07-10 09:04:26 Database: RocksDb at  2025-07-10 09:04:26 &amp; Native runtime: moonbase-3501 (moonbase-0.tx2.au4) 2025-07-10 09:04:26 Parachain id: Id(1000) 2025-07-10 09:04:26 Parachain Account: 5Ec4AhPZk8STuex8Wsi9TwDtJQxKqzPJRCH7348Xtcs9vZLJ 2025-07-10 09:04:26 Parachain genesis state: 0x0000000000000000000000000000000000000000000000000000000000000000006505bc9a20d69f14620b2417b6d777c398ceb3e32119b9a53507111d1880927c03170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131400 2025-07-10 09:04:26 Is collating: no 2025-07-10 09:04:26 [ 1 ^ Initializing Genesis block/state (state: 0xb505..927c, header-hash: 0x91bc...9527) 2025-07-10 09:04:26 \uff3bRelaychain\uff3d ^ Initializing Genesis block/state (state: 0x96a6..9426, header-hash: 0xelea..9443) <p>During the syncing process, you will see logs from both the embedded relay chain ([Relaychain]) and the parachain ([\ud83c\udf17]). These logs display a target block (live network state) and a best block (local node synced state).</p> moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f 10 Syncing 137.9 bps, target=#12325010 (8 peers), best: #21001 (0x25d9...57d8), finalized #20992 (0x1ebb..fd23), # 214.4kiB/s 11.7kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f * Syncing 182.7 bps, target=#5219905 (8 peers), best: #22472 (0x875f..aed7), finalized #9625 (0x601b...e64f), # 371.0kiB/s 113.3kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f I Syncing 186.6 bps, target=#12325011 (8 peers), best: #21935 (0x58f8...d312), finalized #21585 (0x1d73...13c8), #271.9kiB/s T1.3kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f @ Syncing 193.4 bps, target=#5219905 (8 peers), best: #23440 (0xdce6...8ea6), finalized #9922 (0x07c9...1fdf), # 383.3kiB/s 17.5kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f \u00d6 Syncing 189.5 bps, target=#12325012 (8 peers), best: #22883 (0x6531.2281), finalized #22528 (0x0f21.0855), # 290.8kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f @ Syncing 206.4 bps, target=#5219905 (8 peers), best: #24474 (0x09dd...6700), finalized #10393 (0x3efc...8a40), #428.7kiB/s 12.4kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f . Syncing 171.6 bps, target=#12325013 (8 peers), best: #23744 (0x4ced...cdae), finalized #23552 (0x1773..09d9), # 252.4kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f Syncing 212.3 bps, target=#5219905 (8 peers), best: #25536 (0x7bc0...e9b7), finalized #10905 (0x5c70...3063), 1427.1kiB/s 11.4kiB/s <p>If you followed the installation instructions for Moonbase Alpha, once synced, you will have a node of the Moonbase Alpha TestNet running locally! For Moonbeam or Moonriver, once synced, you will be connected to peers and see blocks being produced on the network!</p> <p>Note</p> <p>It may take a few days to completely sync the embedded relay chain. Make sure that your system meets the requirements.</p>"},{"location":"node-operators/networks/run-a-node/docker/#maintain-your-node","title":"Maintain Your Node","text":"<p>As Moonbeam development continues, it will sometimes be necessary to upgrade your node software. Node operators will be notified on our Discord channel when upgrades are available and whether they are necessary (some client upgrades are optional). The upgrade process is straightforward and is the same for a full node or collator.</p> <ol> <li> <p>Stop the Docker container:</p> <pre><code>sudo docker stop INSERT_CONTAINER_ID\n</code></pre> </li> <li> <p>Get the latest version of Moonbeam from the Moonbeam GitHub Release page</p> </li> <li>Use the latest version to spin up your node. To do so, replace the version in the start-up command with the latest and run it</li> </ol> <p>Once your node is running again, you should see logs in your terminal.</p>"},{"location":"node-operators/networks/run-a-node/docker/#purge-your-node","title":"Purge Your Node","text":"<p>If you need a fresh instance of your Moonbeam node, you can purge your node by removing the associated data directory.</p> <p>You'll first need to stop the Docker container:</p> <pre><code>  sudo docker stop INSERT_CONTAINER_ID\n</code></pre> <p>If you did not use the <code>-v</code> flag to specify a local directory for storing your chain data when you spun up your node, then the data folder is related to the Docker container itself. Therefore, removing the Docker container will remove the chain data.</p> <p>If you did spin up your node with the <code>-v</code> flag, you will need to purge the specified directory. For example, for the suggested data directly, you can run the following command to purge your parachain and relay chain data:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/*\n</code></pre> <p>To only remove the parachain data for a specific chain, you can run:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/chains/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/chains/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/chains/*\n</code></pre> <p>Similarly, to only remove the relay chain data, you can run:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/polkadot/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/polkadot/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/polkadot/*\n</code></pre> <p>Now that your chain data has been purged, you can start a new node with a fresh data directory. You can install the newest version by repeating the instructions in this guide. Make sure you are using the latest tag available, which you can find on the Moonbeam GitHub Release page.</p> <p>Note</p> <p>On an as-needed basis, Moonbase Alpha might be purged and reset. In these instances, you will need to purge both the parachain data and the relay chain data. If a purge is required, node operators will be notified in advance (via our Discord channel).</p>"},{"location":"node-operators/networks/run-a-node/flags/","title":"Helpful Flags for Running a Node on Moonbeam","text":""},{"location":"node-operators/networks/run-a-node/flags/#introduction","title":"Introduction","text":"<p>When spinning up your own Moonbeam node, there are some required and optional flags that can be used. This guide will cover some of the most common flags and show you how to access all of the available flags.</p>"},{"location":"node-operators/networks/run-a-node/flags/#common-flags","title":"Common Flags","text":"<ul> <li><code>--collator</code> - enables collator mode for collator candidates and, if eligible, allows the node to actively participate in block production</li> <li><code>--port</code> - specifies the peer-to-peer protocol TCP port. The default port for parachains is <code>30333</code> and <code>30334</code> for the embedded relay chain</li> <li><code>--rpc-port</code> - sets the unified port for both HTTP and WS connections. The default port for parachains is <code>9944</code> and <code>9945</code> for the embedded relay chain</li> <li><code>--ws-port</code> - - deprecated as of client v0.33.0, use <code>--rpc-port</code> for HTTP and WS connections instead - sets the unified port for both HTTP and WS connections. The default port for parachains is <code>9944</code>  and <code>9945</code> for the embedded relay chain</li> <li><code>--rpc-max-connections</code> - specifies the maximum number of HTTP and WS server connections. The default is 100</li> <li><code>--ws-max-connections</code> - deprecated as of client v0.33.0, use <code>--rpc-max-connections</code> to adjust the combined HTTP and WS connection limit instead - specifies the maximum number of HTTP and WS server connections. The default is 100</li> <li><code>--wasm-execution</code> - specifies the method for executing Wasm runtime code. The available options are:<ul> <li><code>compiled</code> - this is the default and uses the Wasmtime compiled runtime</li> <li><code>interpreted-i-know-what-i-do</code> - uses the wasmi interpreter</li> </ul> </li> <li><code>--state-pruning</code> - specifies the state pruning mode. For client versions prior to v0.27.0, the <code>--state-pruning</code> flag was named <code>--pruning</code>. If running a node with the <code>--collator</code> flag, the default is to keep the full state of all blocks. Otherwise, the state is only kept for the last 256 blocks. The available options are:<ul> <li><code>archive</code> - keeps the full state of all blocks</li> <li><code>&lt;number-of-blocks&gt;</code> - specifies a custom number of blocks to keep the state for</li> </ul> </li> <li><code>--trie-cache-size</code> - specifies the size of the internal state cache. The default is <code>67108864</code>. You can try setting this value to <code>1073741824</code> (1GB) to improve collator performance. However, this value may be too low and need to be adjusted. For client versions prior to v0.27.0, the <code>--trie-cache-size</code> flag was named <code>--state-cache-size</code></li> <li><code>--db-cache</code> - specifies the memory the database cache is limited to use. It is recommended to set it to 50% of the actual RAM your server has. For example, for 32 GB RAM, the value should be set to <code>16000</code>. The minimum value is <code>2000</code>, but it is below the recommended specs</li> <li><code>--base-path</code> - specifies the base path where your chain data is stored</li> <li><code>--chain</code> - specifies the chain specification to use. It can be a predefined chainspec such as <code>moonbeam</code>, <code>moonriver</code>, or <code>alphanet</code>. Or it can be a path to a file with the chainspec (such as the one exported by the <code>build-spec</code> command)</li> <li><code>--name</code> - specifies a human-readable name for the node, which can be seen on telemetry, if enabled</li> <li><code>--telemetry-url</code> - specifies the URL of the telemetry server to connect to. This flag can be passed multiple times as a means to specify multiple telemetry endpoints. This flag takes two parameters: the URL and the verbosity level. Verbosity levels range from 0-9, with 0 denoting the least verbosity. Expected format is '', e.g. <code>--telemetry-url 'wss://foo/bar 0'</code>. <li><code>--in-peers</code> - specifies the maximum amount of accepted incoming connections. The default is <code>25</code></li> <li><code>--out-peers</code> - specifies the maximum amount of outgoing connections to maintain. The default is <code>25</code></li> <li><code>--runtime-cache-size 64</code> - configures the number of different runtime versions preserved in the in-memory cache to 64</li> <li><code>--eth-log-block-cache</code> - size in bytes the LRU cache for block data is limited to use. This flag mostly pertains to RPC providers. The default is <code>300000000</code></li> <li><code>--eth-statuses-cache</code> - size in bytes the LRU cache for transaction statuses data is limited to use. This flag mostly pertains to RPC providers. The default is <code>300000000</code></li> <li><code>--sync</code> - sets the blockchain syncing mode, which can allow for the blockchain to be synced faster. The available options are:<ul> <li><code>full</code> - downloads and validates the full blockchain history</li> <li><code>fast</code> - downloads blocks without executing them and downloads the latest state with proofs</li> <li><code>fast-unsafe</code> - same as <code>fast</code>, but skips downloading the state proofs</li> <li><code>warp</code> - downloads the latest state and proof</li> </ul> </li> <li><code>--prometheus-port</code> - specifies a custom Prometheus port</li> <li><code>--lazy-loading-remote-rpc</code> - allows lazy loading by relying on a specified RPC endpoint for network state until the node is fully synchronized e.g. <code>--lazy-loading-remote-rpc 'https://moonbeam.unitedbloc.com'</code>, as long as the specified RPC endpoint has sufficient rate limits to handle the expected load. Private (API key) endpoints are strongly recommended over public endpoints</li> <li><code>--lazy-loading-block</code> - optional parameter to specify the block hash for lazy loading. This parameter allows you to specify a block hash from which to start loading data. If not provided, the latest block will be used</li> <li><code>--lazy-loading-state-overrides</code> - optional parameter to specify state overrides during lazy loading. This parameter allows you to provide a path to a file containing state overrides. The file can contain any custom state modifications that should be applied</li> <li><code>--lazy-loading-runtime-override</code> - optional parameter to specify a runtime override when starting the lazy loading. If not provided, it will fetch the runtime from the block being forked</li> <li><code>--lazy-loading-delay-between-requests</code> - the delay (in milliseconds) between RPC requests when using lazy loading. This parameter controls the amount of time to wait between consecutive RPC requests. This can help manage request rate and avoid overwhelming the server. Default value is <code>100</code> milliseconds</li> <li><code>--lazy-loading-max-retries-per-request</code> - the maximum number of retries for an RPC request when using lazy loading. Default value is <code>10</code> retries</li>"},{"location":"node-operators/networks/run-a-node/flags/#flags-for-sql-backend","title":"Flags for Configuring a SQL Backend","text":"<ul> <li><code>--frontier-backend-type</code> - sets the Frontier backend type to one of the following options:<ul> <li><code>key-value</code> - uses either RocksDB or ParityDB as per inherited from the global backend settings. This is the default option and RocksDB is the default backend</li> <li><code>sql</code> - uses a SQL database with custom log indexing</li> </ul> </li> <li><code>frontier-sql-backend-pool-size</code> - sets the Frontier SQL backend's maximum number of database connections that a connection pool can simultaneously handle. The default is <code>100</code></li> <li><code>frontier-sql-backend-num-ops-timeout</code> - sets the Frontier SQL backend's query timeout in number of VM operations. The default is <code>10000000</code></li> <li><code>frontier-sql-backend-thread-count</code> - sets the Frontier SQL backend's auxiliary thread limit. The default is <code>4</code></li> <li><code>frontier-sql-backend-cache-size</code> - sets the Frontier SQL backend's cache size in bytes. The default value is 200MB, which is <code>209715200</code> bytes</li> </ul>"},{"location":"node-operators/networks/run-a-node/flags/#how-to-access-all-of-the-available-flags","title":"How to Access All of the Available Flags","text":"<p>For a complete list of the available flags, you can spin up your Moonbeam node with <code>--help</code> added to the end of the command. The command will vary depending on how you choose to spin up your node, and if you're using Docker or Systemd.</p>"},{"location":"node-operators/networks/run-a-node/flags/#docker","title":"Docker","text":"MoonbeamMoonriverMoonbase Alpha <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--help\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--help\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--help\n</code></pre>"},{"location":"node-operators/networks/run-a-node/flags/#systemd","title":"Systemd","text":"MoonbeamMoonriverMoonbase Alpha <pre><code># If you used the release binary\n./moonbeam --help\n\n# Or if you compiled the binary\n./target/release/moonbeam --help\n</code></pre> <pre><code># If you used the release binary\n./moonbeam --help\n\n# Or if you compiled the binary\n./target/release/moonbeam --help\n</code></pre> <pre><code># If you used the release binary\n./moonbeam --help\n\n# Or if you compiled the binary\n./target/release/moonbeam --help\n</code></pre>"},{"location":"node-operators/networks/run-a-node/overview/","title":"Run a Node on Moonbeam","text":""},{"location":"node-operators/networks/run-a-node/overview/#introduction","title":"Introduction","text":"<p>Running a full node on a Moonbeam-based network allows you to connect to the network, sync with a bootnode, obtain local access to RPC endpoints, author blocks on the parachain, and more.</p> <p>There are multiple deployments of Moonbeam, including the Moonbase Alpha TestNet, Moonriver on Kusama, and Moonbeam on Polkadot. Here's how these environments are named and their corresponding chain specification file names:</p> Network Hosted By Chain Name Moonbase Alpha Moonbeam Foundation alphanet Moonriver Kusama moonriver Moonbeam Polkadot moonbeam <p>Note</p> <p>Moonbase Alpha is still considered an Alphanet, and as such will not have 100% uptime. The parachain might be purged as needed. During the development of your application, make sure you implement a method to redeploy your contracts and accounts to a fresh parachain quickly. If a chain purge is required, it will be announced via our Discord channel at least 24 hours in advance.</p>"},{"location":"node-operators/networks/run-a-node/overview/#requirements","title":"Requirements","text":"<p>Running a parachain node is similar to a typical Substrate node, but there are some differences. A Substrate parachain node is a bigger build because it contains code to run the parachain itself, as well as code to sync the relay chain and facilitate communication between the two. As such, this build is quite large and may take over 30 min and require 32GB of memory.</p> <p>The minimum specs recommended to run a node are shown in the following table. For our Kusama and Polkadot MainNet deployments, disk requirements will be higher as the network grows.</p> MoonbeamMoonriverMoonbase Alpha Component Requirement CPU 8 Cores (Fastest per core speed) RAM 16 GB SSD 3 TB (recommended) Firewall P2P port must be open to incoming traffic:\u00a0 \u00a0 - Source: Any\u00a0 \u00a0 - Destination: 30333, 30334 TCP Component Requirement CPU 8 Cores (Fastest per core speed) RAM 16 GB SSD 2 TB (recommended) Firewall P2P port must be open to incoming traffic:\u00a0 \u00a0 - Source: Any\u00a0 \u00a0 - Destination: 30333, 30334 TCP Component Requirement CPU 8 Cores (Fastest per core speed) RAM 16 GB SSD 2 TB (recommended) Firewall P2P port must be open to incoming traffic:\u00a0 \u00a0 - Source: Any\u00a0 \u00a0 - Destination: 30333, 30334 TCP <p>Note</p> <p>If you don't see an <code>Imported</code> message (without the <code>[Relaychain]</code> tag) when running a node, you might need to double-check your port configuration.</p>"},{"location":"node-operators/networks/run-a-node/overview/#running-ports","title":"Running Ports","text":"<p>As stated before, the relay/parachain nodes will listen on multiple ports. The default Substrate ports are used in the parachain, while the relay chain will listen on the next higher port.</p> <p>The only ports that need to be open for incoming traffic are those designated for P2P. Collators must not have RPC or WS ports opened.</p> <p>Note</p> <p>As of client v0.33.0, the <code>--ws-port</code> and <code>--ws-max-connections</code> flags have been deprecated and removed in favor of the <code>--rpc-port</code> and <code>--rpc-max-connections</code> flags for both RPC and WSS connections. The default port is <code>9944</code>, and the default maximum number of connections is set to 100.</p>"},{"location":"node-operators/networks/run-a-node/overview/#default-ports-for-a-parachain-full-node","title":"Default Ports for a Parachain Full-Node","text":"Description Port P2P 30333 (TCP) RPC &amp; WS 9944 Prometheus 9615"},{"location":"node-operators/networks/run-a-node/overview/#default-ports-of-embedded-relay-chain","title":"Default Ports of Embedded Relay Chain","text":"Description Port P2P 30334 (TCP) RPC &amp; WS 9945 Prometheus 9616"},{"location":"node-operators/networks/run-a-node/overview/#installation","title":"Installation","text":"<p>There are a couple different guides to help you get started running a Moonbeam-based node:</p> <ul> <li>Using Docker - this method provides a quick and easy way to get started with a Docker container</li> <li>Using Systemd - this method is recommended for those with experience compiling a Substrate node</li> </ul>"},{"location":"node-operators/networks/run-a-node/overview/#debug-trace-txpool-apis","title":"Debug, Trace and TxPool APIs","text":"<p>You can also gain access to some non-standard RPC methods by running a tracing node, which allow developers to inspect and debug transactions during runtime. Tracing nodes use a different Docker image than a standard Moonbase Alpha, Moonriver, or Moonbeam node. Check out the Run a Tracing Node guide and be sure to switch to the right network tab throughout the instructions. Then to interact with your tracing node, check out the Debug &amp; Trace guide.</p>"},{"location":"node-operators/networks/run-a-node/overview/#lazy-loading","title":"Lazy Loading","text":"<p>Lazy loading lets a Moonbeam node operate while downloading network state in the background, eliminating the need to wait for full synchronization before use. You can activate lazy loading with the following flag:</p> <ul> <li><code>--lazy-loading-remote-rpc</code> - allows lazy loading by relying on a specified RPC for network state until the node is fully synchronized e.g. <code>--lazy-loading-remote-rpc 'INSERT-RPC-URL'</code></li> </ul> <p>Upon spooling up a node with this feature, you'll see output like the following:</p> [Lazy loading \ud83c\udf17]     You are now running the Moonbeam client in lazy loading mode, where data is retrieved     from a live RPC node on demand.     Using remote state from: https://moonbeam.unitedbloc.com     Forking from block: 8482853     To ensure the client works properly, please note the following:         1. *Avoid Throttling*: Ensure that the backing RPC node is not limiting the number of         requests, as this can prevent the lazy loading client from functioning correctly;         2. *Be Patient*: As the client may take approximately 20 times longer than normal to         retrieve and process the necessary data for the requested operation.     The service will start in 10 seconds... <p>Note</p> <p>Lazy loading a Moonbeam requires a large number of RPC requests. To avoid being rate-limited by a public endpoint, it's highly recommended to use a dedicated endpoint.  </p> <p>You can further customize your use of the lazy loading functionality with the following optional parameters:</p> <ul> <li><code>--lazy-loading-block</code> - specifies a block hash from which to start loading data. If not provided, the latest block will be used</li> <li><code>--lazy-loading-delay-between-requests</code> - the delay (in milliseconds) between RPC requests when using lazy loading. This parameter controls the amount of time to wait between consecutive RPC requests. This can help manage request rate and avoid overwhelming the server. Default value is <code>100</code> milliseconds</li> <li><code>--lazy-loading-max-retries-per-request</code> - the maximum number of retries for an RPC request when using lazy loading. Default value is <code>10</code> retries</li> <li><code>--lazy-loading-runtime-override</code> - path to a WASM file to override the runtime when forking. If not provided, it will fetch the runtime from the block being forked</li> <li><code>--lazy-loading-state-overrides</code> - path to a JSON file containing state overrides to be applied when forking </li> </ul> <p>The state overrides file should define the respective pallet, storage item, and value that you seek to override as follows:</p> <pre><code>[\n {\n     \"pallet\": \"System\",\n     \"storage\": \"SelectedCandidates\",\n     \"value\": \"0x04f24ff3a9cf04c71dbc94d0b566f7a27b94566cac\"\n }\n]\n</code></pre>"},{"location":"node-operators/networks/run-a-node/overview/#logs-and-troubleshooting","title":"Logs and Troubleshooting","text":"<p>You will see logs from both the relay chain and the parachain. The relay chain will be prefixed by <code>[Relaychain]</code>, while the parachain has no prefix.</p>"},{"location":"node-operators/networks/run-a-node/overview/#p2p-ports-not-open","title":"P2P Ports Not Open","text":"<p>If you don't see an <code>Imported</code> message (without the <code>[Relaychain]</code> tag), you need to check the P2P port configuration. P2P port must be open to incoming traffic.</p>"},{"location":"node-operators/networks/run-a-node/overview/#in-sync","title":"In Sync","text":"<p>Both chains must be in sync at all times, and you should see either <code>Imported</code> or <code>Idle</code> messages and have connected peers.</p>"},{"location":"node-operators/networks/run-a-node/overview/#genesis-mismatching","title":"Genesis Mismatching","text":"<p>The Moonbase Alpha TestNet may need to be purged and upgraded once in a while. Consequently, you may see the following message:</p> <pre><code>DATE [Relaychain] Bootnode with peer id `ID` is on a different\nchain (our genesis: GENESIS_ID theirs: OTHER_GENESIS_ID)\n</code></pre> <p>This typically means that you are running an older version and will need to upgrade.</p> <p>We announce the upgrades (and corresponding chain purge) via our Discord channel at least 24 hours in advance.</p> <p>Instructions for purging chain data will vary slightly depending on how you spun up your node:</p> <ul> <li>For Docker, you can check out the Purge Your Node section of the Using Docker page</li> <li>For Systemd, you can take a look at the Purge Your Node section of the Using Systemd page</li> </ul>"},{"location":"node-operators/networks/run-a-node/systemd/","title":"Run a Node on Moonbeam Using Systemd","text":""},{"location":"node-operators/networks/run-a-node/systemd/#introduction","title":"Introduction","text":"<p>Running a full node on a Moonbeam-based network allows you to connect to the network, sync with a bootnode, obtain local access to RPC endpoints, author blocks on the parachain, and more.</p> <p>In this guide, you'll learn how to spin up a Moonbeam node using Systemd and how to maintain and purge your node.</p> <p>If you're interested in compiling the binary yourself, which may take over 30 min and require 32GB of memory, you can check out the Manually Compile the Moonbeam Binary guide.</p>"},{"location":"node-operators/networks/run-a-node/systemd/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The following sections go through the process of using the binary and running a Moonbeam full node as a systemd service. To get started, you'll need to:</p> <ul> <li>Make sure you're running Ubuntu 18.04, 20.04, or 22.04. Moonbeam may work with other Linux flavors, but Ubuntu is currently the only tested version</li> <li>Make sure that your system meets the requirements. When connecting to Moonriver on Kusama or Moonbeam on Polkadot, it will take a few days to completely sync the embedded relay chain</li> </ul>"},{"location":"node-operators/networks/run-a-node/systemd/#the-release-binary","title":"Download the Latest Release Binary","text":"<p>To download the latest release binary, take the following steps:</p> <ol> <li> <p>Create a directory to store the binary and chain data (you might need <code>sudo</code>)</p> MoonbeamMoonriverMoonbase Alpha <pre><code>mkdir /var/lib/moonbeam-data\n</code></pre> <pre><code>mkdir /var/lib/moonriver-data\n</code></pre> <pre><code>mkdir /var/lib/alphanet-data\n</code></pre> </li> <li> <p>Use <code>wget</code> to grab the latest release binary and output it to the directory created in the previous step</p> MoonbeamMoonriverMoonbase Alpha <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/v0.47.0/moonbeam \\\n-O /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/v0.47.0/moonbeam \\\n-O /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/v0.47.0/moonbeam \\\n-O /var/lib/alphanet-data/moonbeam\n</code></pre> </li> <li> <p>To verify that you have downloaded the correct version, you can run the following command in your terminal</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sha256sum /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>sha256sum /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>sha256sum /var/lib/alphanet-data/moonbeam\n</code></pre> <p>You should receive the following output:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>ca2c664c2bc9d5221130a412313aa05bac907c15c911fb09cdc9a0551893fa2e\n</code></pre> <pre><code>ca2c664c2bc9d5221130a412313aa05bac907c15c911fb09cdc9a0551893fa2e\n</code></pre> <pre><code>ca2c664c2bc9d5221130a412313aa05bac907c15c911fb09cdc9a0551893fa2e\n</code></pre> </li> </ol>"},{"location":"node-operators/networks/run-a-node/systemd/#set-up-the-service","title":"Set Up the Service","text":"<p>The following commands will set up everything regarding running the service:</p> <ol> <li> <p>Create a service account to run the service</p> MoonbeamMoonriverMoonbase Alpha <pre><code>adduser moonbeam_service --system --no-create-home\n</code></pre> <pre><code>adduser moonriver_service --system --no-create-home\n</code></pre> <pre><code>adduser moonbase_service --system --no-create-home\n</code></pre> </li> <li> <p>Ensure that you properly configure the ownership and permissions for the local directory housing the chain data, and also remember to grant execute permission to the binary file</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo chown -R moonbeam_service /var/lib/moonbeam-data\nsudo chmod +x /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>sudo chown -R moonriver_service /var/lib/moonriver-data\nsudo chmod +x /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>sudo chown -R moonbase_service /var/lib/alphanet-data\nsudo chmod +x /var/lib/alphanet-data/moonbeam\n</code></pre> </li> </ol>"},{"location":"node-operators/networks/run-a-node/systemd/#create-the-configuration-file","title":"Create the Configuration File","text":"<p>Next, create the systemd service file. If you're configuring a collator node, use the collator-specific configuration snippets below.</p> <p>First, you'll need to create a file named <code>/etc/systemd/system/moonbeam.service</code> to store the configurations.</p> <p>Note that in the following start-up configurations, you have to:</p> <ul> <li>Replace <code>INSERT_YOUR_NODE_NAME</code> with your node name of choice. You'll have to do this in two places: one for the parachain and one for the relay chain</li> <li>Replace <code>INSERT_RAM_IN_MB</code> for 50% of the actual RAM your server has. For example, for 32GB of RAM, the value must be set to <code>16000</code>. The minimum value is <code>2000</code>, but it is below the recommended specs</li> <li>Double-check that the binary is in the proper path as described below (ExecStart)</li> <li>Double-check the base path if you've used a different directory</li> </ul> <p>For an overview of the flags used in the following start-up commands, plus additional commonly used flags, please refer to the Flags page of our documentation.</p>"},{"location":"node-operators/networks/run-a-node/systemd/#full-node","title":"Full Node","text":"MoonbeamMoonriverMoonbase Alpha <pre><code>[Unit]\nDescription=\"Moonbeam systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbeam_service\nSyslogIdentifier=moonbeam\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonbeam-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonbeam-data \\\n     --chain moonbeam \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Moonriver systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonriver_service\nSyslogIdentifier=moonriver\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonriver-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonriver-data \\\n     --chain moonriver \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Moonbase Alpha systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbase_service\nSyslogIdentifier=moonbase\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/alphanet-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/alphanet-data \\\n     --chain alphanet \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/networks/run-a-node/systemd/#allow-external-access","title":"Allow External Access to Your Node","text":"<p>If you want to run an RPC endpoint, connect to Polkadot.js Apps, or run your own application, you can use the <code>--unsafe-rpc-external</code> flag to run the full node with external access to the RPC ports.</p> Example start-up command for Moonbeam <pre><code>[Unit]\nDescription=\"Moonbeam systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbeam_service\nSyslogIdentifier=moonbeam\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonbeam-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonbeam-data \\\n     --chain moonbeam \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     --unsafe-rpc-external \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/networks/run-a-node/systemd/#use-sql","title":"Use a SQL Backend for Frontier","text":"<p>The default Frontier database, which comes standard with Moonbeam nodes and contains all of the Ethereum-related elements, such as transactions, blocks, and logs, can be modified to use a SQL backend. Since <code>eth_getLogs</code> is a very resource-intensive method, the SQL backend aims to provide a more performant alternative for indexing and querying Ethereum logs in comparison to the default RocksDB database.</p> <p>To spin up a node with a Frontier SQL backend, you'll need to add the <code>--frontier-backend-type sql</code> flag to your start-up command.</p> <p>There are additional flags you can use to configure the pool size, query timeouts, and more for your SQL backend; please refer to the Flags page for more information.</p> Example start-up command for Moonbeam <pre><code>[Unit]\nDescription=\"Moonbeam systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbeam_service\nSyslogIdentifier=moonbeam\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonbeam-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonbeam-data \\\n     --chain moonbeam \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     --frontier-backend-type sql \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/networks/run-a-node/systemd/#collator","title":"Collator","text":"<p>Beginning with v0.39.0, new Moonbeam collator nodes will no longer generate session keys automatically on start-up. Nodes in existence prior to v0.39.0 do not need to make changes to how they handle session keys.</p> <p>When setting up a new node, run the following command to generate and store on disk the session keys that will be referenced in the start-up command:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>/var/lib/moonbeam-data/moonbeam key generate-node-key --base-path /var/lib/moonbeam-data --chain moonbeam &amp;&amp; sudo chown -R moonbeam_service /var/lib/moonbeam-data\n</code></pre> <pre><code>/var/lib/moonriver-data/moonbeam key generate-node-key --base-path /var/lib/moonriver-data --chain moonriver &amp;&amp; sudo chown -R moonriver_service /var/lib/moonriver-data\n</code></pre> <pre><code>/var/lib/alphanet-data/moonbeam key generate-node-key --base-path /var/lib/alphanet-data --chain alphanet  &amp;&amp; sudo chown -R moonbase_service  /var/lib/alphanet-data\n</code></pre> <p>Note</p> <p>This step can be bypassed using the <code>--unsafe-force-node-key-generation</code> parameter in the start-up command, although this is not the recommended practice.</p> <p>Now you can create the systemd configuration file:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>[Unit]\nDescription=\"Moonbeam systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbeam_service\nSyslogIdentifier=moonbeam\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonbeam-data/moonbeam \\\n     --collator \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonbeam-data \\\n     --chain moonbeam \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Moonriver systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonriver_service\nSyslogIdentifier=moonriver\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonriver-data/moonbeam \\\n     --collator \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonriver-data \\\n     --chain moonriver \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Moonbase Alpha systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbase_service\nSyslogIdentifier=moonbase\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/alphanet-data/moonbeam \\\n     --collator \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/alphanet-data \\\n     --chain alphanet \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/networks/run-a-node/systemd/#run-the-service","title":"Run the Service","text":"<p>Register and start the service by running:</p> <pre><code>systemctl enable moonbeam.service\nsystemctl start moonbeam.service\n</code></pre> <p>And lastly, verify that the service is running:</p> <pre><code>systemctl status moonbeam.service\n</code></pre>  systemctl status moonbeam.service \u2022 moonbeam.service - \"Moonbase Alpha systemd service\"    Loaded: loaded (/etc/systemd/system/moonbeam.service; enabled; vendor preset:&gt;    Active: active (running) since Tue 2025-07-10 09:04:26 UTC; 45 ago    Main PID: 52847 (moonbeam)    Tasks: 13 (limit: 4662)    Memory: 113.7M    CPU: 6.9995    CGroup: /system.slice/moonbeam.service        \u2514\u250052847 /var/lib/alphanet-data/moonbeam --state-pruning=archive --tri&gt; lines 1-9/9 (END) <p>You can also check the logs by executing:</p> <pre><code>journalctl -f -u moonbeam.service\n</code></pre> moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f @ Syncing 158.7 bps, target=#12361301 (9 peers), best: #35487 (0x527e...c72b), finalized #35328 (0xfcd2...828), # 239.9kiB/s 15.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 Syncing 150.7 bps, target=#5236155 (9 peers), best: #40870 (0x3659...c530), finalized #16793 (0x815...578), # 299.7kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f Syncing 162.5 bps, target=#12361302 (9 peers), best: #36300 (0x9edb..b2c2), finalized #35985 (0x7345..e874), +256.6kiB/s 19.6kiB/s moonbase[52847]: 2025-07-10 09:04:26  Syncing 168.8 bps, target=#5236155 (9 peers), best: #41714 (0x2feb...3f10), finalized #17122 (0x4954...8161), +353.2kiB/s 11.4kB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f @ Syncing 181.3 bps, target=#12361303 (9 peers), best: #37208 (0xbad2...6c2d), finalized #36864 (0x3015..bd42), # 288.4kiB/s 14.8kiB/s moonbase[52847]: 2025-07-10 09:04:26 Syncing 161.9 bps, target=#5236155 (9 peers), best: #42525 (0x9711...0de7), finalized #17561 (0x56f4...ad20), # 310.0kiB/s 11.0kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f @ Syncing 166.0 bps, target=#12361303 (9 peers), best: #38039 (0xb19f445c), finalized #37888 (0x68bb...6900), +176.9kiB/s 13.1kiB/s moonbase[52847]: 2025-07-10 09:04:26 Syncing 183.7 bps, target=#5236155 (9 peers), best: #43444 (0xccd0...a18f), finalized #18073 (0xe474...2032), #357.3kiB/s 10.3kiB/s <p>During the syncing process, you will see logs from both the embedded relay chain ([Relaychain]) and the parachain ([\ud83c\udf17]). These logs display a target block (live network state) and a best block (local node synced state).</p> <p>Note</p> <p>It may take a few days to completely sync the embedded relay chain. Make sure that your system meets the requirements.</p> <p>If you need to stop the service for any reason, you can run:</p> <pre><code>systemctl stop moonbeam.service\n</code></pre>"},{"location":"node-operators/networks/run-a-node/systemd/#maintain-your-node","title":"Maintain Your Node","text":"<p>As Moonbeam development continues, it will sometimes be necessary to upgrade your node software. Node operators will be notified on our Discord channel when upgrades are available and whether they are necessary (some client upgrades are optional). The upgrade process is straightforward and is the same for a full node or collator.</p> <p>If you want to update your client, you can keep your existing chain data in tact, and only update the binary by following these steps:</p> <ol> <li> <p>Stop the systemd service</p> <pre><code>sudo systemctl stop moonbeam.service\n</code></pre> </li> <li> <p>Remove the old binary file</p> MoonbeamMoonriverMoonbase Alpha <pre><code>rm /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>rm /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>rm /var/lib/alphanet-data/moonbeam\n</code></pre> </li> <li> <p>Get the latest version of the Moonbeam release binary on GitHub and run the following command to update to that version</p> MoonbeamMoonriverMoonbase Alpha <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/INSERT_NEW_VERSION_TAG/moonbeam \\\n-O /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/INSERT_NEW_VERSION_TAG/moonbeam \\\n-O /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/INSERT_NEW_VERSION_TAG/moonbeam \\\n-O /var/lib/alphanet-data/moonbeam\n</code></pre> <p>Note</p> <p>If you compiled the binary manually, you'll need to move the binary from <code>./target/release/moonbeam</code> to the data directory.</p> </li> <li> <p>Update permissions</p> MoonbeamMoonriverMoonbase Alpha <pre><code>chmod +x /var/lib/moonbeam-data/moonbeam\nchown moonbeam_service /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>chmod +x /var/lib/moonriver-data/moonbeam\nchown moonriver_service /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>chmod +x /var/lib/alphanet-data/moonbeam\nchown moonbase_service /var/lib/alphanet-data/moonbeam\n</code></pre> </li> <li> <p>Start your service</p> <pre><code>systemctl start moonbeam.service\n</code></pre> </li> </ol> <p>To check the status of the service and/or logs, you can refer to the commands from before.</p>"},{"location":"node-operators/networks/run-a-node/systemd/#purge-your-node","title":"Purge Your Node","text":"<p>If you need a fresh instance of your Moonbeam node, you can purge your node by removing the associated data directory.</p> <p>You'll first need to stop the systemd service:</p> <pre><code>sudo systemctl stop moonbeam\n</code></pre> <p>To purge your parachain and relay chain data, you can run the following command:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/*\n</code></pre> <p>To only remove the parachain data for a specific chain, you can run:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/chains/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/chains/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/chains/*\n</code></pre> <p>Similarly, to only remove the relay chain data, you can run:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/polkadot/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/polkadot/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/polkadot/*\n</code></pre> <p>Now that your chain data has been purged, you can start a new node with a fresh data directory. You can install the newest version by repeating the instructions in this guide. Make sure you are using the latest tag available, which you can find on the Moonbeam GitHub Release page.</p> <p>Note</p> <p>On an as-needed basis, Moonbase Alpha might be purged and reset. In these instances, you will need to purge both the parachain data and the relay chain data. If a purge is required, node operators will be notified in advance (via our Discord channel).</p>"},{"location":"tokens/connect/coinbase-wallet/","title":"Interacting with Moonbeam Using Coinbase Wallet","text":""},{"location":"tokens/connect/coinbase-wallet/#introduction","title":"Introduction","text":"<p>Coinbase Wallet is a self-custody (non-custodial) wallet, like MetaMask, available as a mobile application for iOS and Android and a browser extension. You can use Coinbase Wallet to interact with Moonbeam, Moonriver, and the Moonbase Alpha TestNet after adding them as custom networks.</p> <p>Please note that Coinbase Wallet is an entirely different product from Coinbase Exchange, a custodial platform for buying and selling cryptocurrency. Holding a token in your Coinbase Wallet does not imply it is supported on Coinbase Exchange. If you send a token from your Coinbase Wallet to Coinbase Exchange that is not supported by the exchange, you will lose those funds forever.</p> <p>In this guide, you'll go through the process of setting up the Coinbase Wallet mobile application and browser extension and configuring it for the Moonbeam network.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/coinbase-wallet/#install-coinbase-wallet","title":"Install Coinbase Wallet","text":"<p>You can download Coinbase Wallet as a mobile app from the iOS App Store or Google Play Store, or as a desktop browser extension from the Chrome Store.</p> <p>The interfaces for the mobile app and browser extension are quite similar, so you can adapt the following instructions for the browser extension. The one major difference between the two is that when you add Moonbase Alpha as a custom network, you can interact with the network on the browser extension but not from the mobile app. This difference only applies to Moonbase Alpha. If you're connecting to Moonbeam or Moonriver, you'll be able to interact with either network from both the browser extension and mobile app.</p>"},{"location":"tokens/connect/coinbase-wallet/#create-a-wallet","title":"Create a Wallet","text":"<p>After installing and opening the app, you'll be greeted with the option to create a new wallet or import an existing one. For this exercise, set up a new wallet by tapping Create a new wallet.</p> <p>You'll be prompted to create a passcode, and once you've entered in your passcode, you'll need to verify it by entering it again a second time.</p> <p></p> <p>Once you've created your passcode, your wallet will be created. The last step to take is to secure your account by backing up your wallet's recovery phrase. To back up your wallet, you can take the following steps:</p> <ol> <li>Navigate to the Settings screen</li> <li>Choose Security from the menu</li> <li>Tap on your wallet that you want to back up; it should say Not backed up next to it</li> <li>Enter your passcode</li> <li>Select how you want to back up your recovery phrase: make an encrypted backup of the seed phrase to iCloud (iOS) or Google Drive (Android), save the phrase manually, or do both. If you are backing up your phrase to the iCloud or Google Drive, you'll have to create a password that will secure your phrase in the cloud. This password cannot be reset, so you'll need to keep it safe. If you are manually saving your phrase, make sure you store it exactly as displayed and save it in a secure location</li> <li>When you're done, click Complete backup</li> </ol> <p></p> <p>Note</p> <p>If you're using the browser extension, you'll follow a slightly different flow, as you'll be prompted to back up your wallet right away, and you'll only have the option to manually do this.</p> <p>Congratulations! You've completed the setup steps, and your wallet is now fully initialized. In the next step, you'll see how you can connect Coinbase Wallet to the Moonbeam network.</p>"},{"location":"tokens/connect/coinbase-wallet/#connect-coinbase-to-moonbeam","title":"Connect Coinbase Wallet to Moonbeam","text":"<p>Although Coinbase Wallet has a built-in browser, it doesn't currently support automatically adding custom networks, so you'll have to add the network details manually. To do so, perform the following steps:</p> <ol> <li>Navigate to the Settings tab</li> <li>Tap on Networks</li> <li>Tap on the + icon in the upper right corner</li> <li> <p>Here, you can fill in the network details for Moonbeam, Moonriver, or the Moonbase Alpha TestNet</p> MoonbeamMoonriverMoonbase Alpha Variable Value Network Name <code>Moonbeam</code> RPC URL <code>https://rpc.api.moonbeam.network</code> ChainID <code>1284</code> (hex: <code>0x504</code>) Symbol (Optional) <code>GLMR</code> Block Explorer (Optional) <code>https://moonscan.io</code> Variable Value Network Name <code>Moonriver</code> RPC URL <code>https://rpc.api.moonriver.moonbeam.network</code> ChainID <code>1285</code> (hex: <code>0x505</code>) Symbol (Optional) <code>MOVR</code> Block Explorer (Optional) <code>https://moonriver.moonscan.io/</code> Variable Value Network Name <code>Moonbase Alpha</code> RPC URL <code>https://rpc.api.moonbase.moonbeam.network</code> ChainID <code>1287</code> (hex: <code>0x507</code>) Symbol (Optional) <code>DEV</code> Block Explorer (Optional) <code>https://moonbase.moonscan.io/</code> </li> <li> <p>Press Add Network once finished</p> </li> </ol> <p></p> <p>After returning to the Networks screen, you can view the newly added network from the Custom tab. To interact with Moonbeam, you'll need to mark the network as Active by taking the following steps:</p> <ol> <li>Tap on Moonbeam</li> <li>Scroll down to the bottom of the screen and toggle the Active network switch to on</li> <li>Tap Save</li> </ol> <p></p>"},{"location":"tokens/connect/coinbase-wallet/#receiving-funds","title":"Receiving Funds","text":"<p>To view and manage your assets, you can click on Assets from the bottom navigation menu.</p> <p>Since you created a new wallet in this demo, the app displays a balance of <code>$0.00</code> and doesn't list any assets in the Crypto tab. You can change this by sending some GLMR to this account. To send funds to your Coinbase Wallet account, take the following steps:</p> <ol> <li>Tap on Receive</li> <li>Tap on the QR code icon or the copy icon next to Ethereum address. Since Moonbeam is Ethereum-compatible, you can use the Ethereum account it provides you with on Moonbeam</li> </ol> <p></p> <p>Now that you have your receiving address, you can send assets to it. To view your assets once they arrive, you'll need to make sure that you've activated the correct network from the network's configuration screen in the Networks settings, as outlined in the previous section.</p>"},{"location":"tokens/connect/coinbase-wallet/#sending-funds","title":"Sending Funds","text":"<p>To send funds from your Coinbase Wallet, navigate to the Assets tab, then take the following steps:</p> <ol> <li>Tap Send</li> <li>On the next screen, enter the amount of the asset you'd like to send</li> <li>Tap Next</li> <li>Enter the address you'd like to send it to</li> <li>Tap Confirm to continue</li> <li>Review the transaction details to ensure accuracy, then press Send</li> <li>Upon successfully sending the transaction, you can tap Done</li> </ol> <p></p> <p>From the Transactions tab, you'll be able to see your outgoing transactions, including the address you sent the transaction to, the status of the transaction, and the amount you sent. You can tap on each transaction to find out more information.</p> <p></p> <p>And that's it! You've successfully set up your Coinbase Wallet app, connected it to the Moonbeam network, and learned how to send and receive funds.</p>"},{"location":"tokens/connect/coinbase-wallet/#subscribe-to-updates-from-moonbeam","title":"Subscribe to Updates from Moonbeam","text":"<p>Coinbase Wallet has a messaging and subscription feature that uses XMTP, an on-chain messaging network designed to deliver fully encrypted messages between wallet addresses. In addition to messaging other Coinbase Wallet users who have enabled this feature, you can subscribe to updates from the Moonbeam Foundation. These updates are designed to provide timely and essential information from the Moonbeam Foundation, such as governance and protocol upgrade notifications. </p>"},{"location":"tokens/connect/coinbase-wallet/#setting-up-coinbase-wallet-on-mobile","title":"Setting up Coinbase Wallet on Mobile","text":"<p>To enable XMTP in your Coinbase Wallet App and subscribe to Moonbeam, you must have both the browser extension and the wallet dApp. The Coinbase Wallet download page has links to both. After installation, ensure you have the same seed in both (e.g., don't create separate seed phrases for each). To get started with XMTP, from the first tab of the Coinbase Wallet App (the Assets tab), take the following steps:</p> <ol> <li>Click the messaging icon in the upper right corner</li> <li>Press Start Messaging</li> </ol> <p></p> <p>Next, you'll be prompted to configure your notification settings to allow push notifications. Take the following steps:</p> <ol> <li>Press Enable Push Notifications</li> <li>Press Allow in the resulting prompt</li> </ol> <p></p>"},{"location":"tokens/connect/coinbase-wallet/#subscribing-in-the-moonbeam-dapp","title":"Subscribing in the Moonbeam dApp","text":"<p>As a quick reminder, you'll need to have the Coinbase Wallet extension installed on your computer's browser loaded with the same seed as the one used on your phone. To minimize the risk of errors, ensure that the Coinbase Wallet extension is the only cryptocurrency wallet extension active in your browser. You can temporarily disable other wallet apps as follows:</p> <ol> <li>Click the Extensions Icon in the upper right corner</li> <li>Click Manage Extensions</li> <li>Disable any other active wallet extensions </li> </ol> <p>Note</p> <p>Disabling MetaMask keeps your keys intact, but removing MetaMask could result in losing your private keys. Be careful not to accidentally remove a wallet entirely.</p> <p></p> <p>Then, head to the Moonbeam dApp, and take the following steps to connect the Coinbase Wallet extension:</p> <ol> <li>Press Connect wallet </li> <li>Select Coinbase Wallet from the list of options</li> <li>Press Connect when Coinbase Wallet pops up</li> </ol> <p></p> <p>To subscribe, take the following steps:</p> <ol> <li>Press the Mailbox icon in the upper right</li> <li>Press Subscribe in the pop-up</li> </ol> <p></p> <ol> <li>Press Connect your wallet in the resulting Coinbase pop up</li> <li>Next, you'll have two signature requests in your Coinbase Wallet. The first one asks you to enable XTMP Identity. Press Sign</li> <li>The next signature request is to enable the subscription to messages from the Moonbeam Foundation. Press Sign</li> </ol> <p>Note</p> <p>You may receive three signature requests in the prior step if you didn't enable XMTP on your phone. The third signature request will take care of that, however, you may still need to enable notifications for the Coinbase Wallet app on your phone to ensure you receive them. </p> <p></p> <p>And that's it! Once done, you'll see the below confirmation screen. For questions about Coinbase Wallet, please refer to the Coinbase Wallet Help.</p> <p></p>"},{"location":"tokens/connect/coinbase-wallet/#limitations","title":"Limitations","text":"<ul> <li>At this time, Coinbase Wallet displays only outgoing transactions in your transaction history in the app. You can see your full transaction history, including incoming transactions, by looking up your address on a blockchain explorer such as Moonscan</li> <li>On the Coinbase Wallet mobile app, you can add Moonbase Alpha as a custom network; however, you won't be able to see your balances or send transactions from the app. You'll need to use the browser extension instead</li> </ul>"},{"location":"tokens/connect/coinbase-wallet/#additional-resources","title":"Additional Resources","text":"<ul> <li>Coinbase Wallet FAQ</li> <li>Coinbase Wallet Getting Started Guide</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/mathwallet/","title":"Interacting with Moonbeam Using MathWallet","text":""},{"location":"tokens/connect/mathwallet/#introduction","title":"Introduction","text":"<p>MathWallet announced that it is now natively supporting each of the Moonbeam-based networks. This means that you are now able to interact with any of the networks using another wallet besides MetaMask.</p> <p>In this tutorial, we'll go through how to setup MathWallet to connect to each of the networks: Moonbeam, Moonriver, and Moonbase Alpha. We'll also present a brief example of using MathWallet as a Web3 provider for other tools such as Remix.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/mathwallet/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>First, you need to install the MathWallet browser extension, which you can get from their website.</p> <p>With the browser extension installed, please open it and set a password.</p> <p></p>"},{"location":"tokens/connect/mathwallet/#connect-to-moonbeam","title":"Connect to Moonbeam","text":"<p>To get started with Moonbeam, all you have to do is click Switch Network and select Moonbeam.</p> <p></p> <p>And that is it, you now have MathWallet connected to Moonbeam! Your wallet should look like this:</p> <p></p> <p>Now that you've successfully connected to Moonbeam, you can skip ahead to the Adding a Wallet section to get started creating or importing a wallet.</p>"},{"location":"tokens/connect/mathwallet/#connect-to-moonriver","title":"Connect to Moonriver","text":"<p>Getting started with Moonriver is a straightforward process. All you have to do is click Switch Network and select Moonriver.</p> <p></p> <p>And that is it, you now have MathWallet connected to Moonriver! Your wallet should look like this:</p> <p></p> <p>Now that you've successfully connected to Moonriver, you can skip ahead to the Adding a Wallet section to get started creating or importing a wallet.</p>"},{"location":"tokens/connect/mathwallet/#connect-to-moonbase-alpha","title":"Connect to Moonbase Alpha","text":"<p>In this part, we'll go through the process of connecting MathWallet to Moonbase Alpha. First you'll need to enable Moonbase Alpha. To do so, go to the settings by clicking on the gear icon. Then click on Networks and scroll down through the Ethereum section until you find Moonbase Alpha and toggle the switch.</p> <p></p> <p>Lastly you'll need to switch to Moonbase Alpha. From the main screen, click Switch Network and select Moonbase Alpha.</p> <p></p> <p>And that is it, you now have MathWallet connected to the Moonbase Alpha TestNet! Your wallet should look like this:</p> <p></p> <p>Now that you've successfully connected to Moonbase Alpha, you can move on to the Adding a Wallet section to get started creating or importing a wallet.</p>"},{"location":"tokens/connect/mathwallet/#adding-a-wallet","title":"Adding a Wallet","text":"<p>The following steps will show you how to interact with the Moonbase Alpha TestNet, but can also be used to interact with Moonbeam and Moonriver.</p> <p>After you are connected to Moonbase Alpha, you can now create a wallet to get an account and start interacting with the TestNet. Currently, there are three ways to add a wallet:</p> <ul> <li>Create a wallet</li> <li>Import an existing wallet using a mnemonic or private key</li> <li>Connect hardware wallet (not supported for now)</li> </ul>"},{"location":"tokens/connect/mathwallet/#create-a-wallet","title":"Create a Wallet","text":"<p>The following steps for creating a wallet can be modified for Moonbeam and Moonriver.</p> <p>To create a new wallet, click the  sign next to Moonbase Alpha and select Create Wallet.</p> <p></p> <p>Set and confirm a wallet name. Next, make sure you safely store the mnemonic, as it provides direct access to your funds. Once you have completed the process, you should see your newly created wallet with its associated public address.</p> <p></p>"},{"location":"tokens/connect/mathwallet/#import-a-wallet","title":"Import a Wallet","text":"<p>To create a new wallet, click the  sign next to Moonbase Alpha and select Import Wallet.</p> <p></p> <p>Next, select between importing using a mnemonic or a private key. For the first option, enter the mnemonic word by word, separated by spaces. For the second option, enter the private key (either with the <code>0x</code> prefix or not, it works both ways).</p> <p></p> <p>After clicking next, set a wallet name, and that is it! You should see your imported wallet with its associated public address.</p> <p></p>"},{"location":"tokens/connect/mathwallet/#using-mathwallet","title":"Using MathWallet","text":"<p>MathWallet serves as a Web3 provider in tools such as Remix. By having MathWallet connected to Moonbase Alpha or Moonriver, you can deploy contracts as you would like using MetaMask, signing the transactions with MathWallet instead.</p> <p>For example, in Remix, when deploying a smart contract to Moonbase Alpha, make sure you select the Injected Web3 option in the ENVIRONMENT menu. If you have MathWallet connected, you will see the TestNet chain ID just below the box (1287) and your MathWallet account injected into Remix as well. When sending a transaction, you should see a similar pop-up from MathWallet:</p> <p></p> <p>By clicking on Accept you are signing this transaction, and the contract will be deployed to the Moonbase Alpha TestNet.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/metamask/","title":"Interacting with Moonbeam Using MetaMask","text":""},{"location":"tokens/connect/metamask/#introduction","title":"Introduction","text":"<p>Developers can leverage Moonbeam's Ethereum compatibility features to integrate tools, such as MetaMask, into their dApps. By doing so, they can use the injected library MetaMask provides to interact with the blockchain.</p> <p>Currently, MetaMask can be configured to connect to a few networks: Moonbeam, Moonriver, the Moonbase Alpha TestNet, and a Moonbeam development node.</p> <p>If you already have MetaMask installed, you can easily connect MetaMask to the network of your choice:</p> Connect to Moonbeam Connect to Moonriver Connect to Moonbase Alpha <p>Note</p> <p>MetaMask will pop up asking for permission to add a custom network. Once you approve permissions, MetaMask will switch your current network.</p> <p>Learn how to integrate a Connect MetaMask button into your dApp, so that users can connect to Moonbase Alpha with a simple click of a button. The guide can also be adapted for the other Moonbeam-based networks.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/metamask/#install-the-metamask-extension","title":"Install the MetaMask Extension","text":"<p>First, you'll start with a fresh and default MetaMask installation from the Chrome store. After downloading, installing, and initializing the extension, follow the Get Started guide. In there, you need to create a wallet, set a password, and store your secret backup phrase (this gives direct access to your funds, so make sure to store these in a secure place).</p>"},{"location":"tokens/connect/metamask/#setup-a-wallet","title":"Setup a Wallet","text":"<p>After installing MetaMask, the setup will automatically open a new task with a welcome screen. Here, you are offered two options:</p> <ul> <li>Create a new wallet - you'll go through some steps to get a new seed phrase. Ensure you store this phrase securely and you don't share it publicly</li> <li>Import an existing wallet - you already have a seed phrase stored, and you want to restore an account from that recovery phrase</li> </ul> <p></p> <p>Once you've selected the option that fits your needs, follow the steps, and you should be all set.</p> <p>Note</p> <p>Multiple accounts can be derived from a seed phrase by changing what is known as the address index. By default, when creating or importing an account from the seed phrase, you get the account with the address index 0. You can get the other indexes by just adding new accounts in the main Metamask screen.</p>"},{"location":"tokens/connect/metamask/#import-accounts","title":"Import Accounts","text":"<p>Once you've created a wallet or imported an existing one, you can also import any account into MetaMask if you hold the private keys.</p> <p>For this example, you'll use private keys from the development account. Click the account switcher button to import an account using its private keys. That is where it says Account 1.</p> <p></p> <p>Next, click on Import Account.</p> <p></p> <p>Finally, enter the private keys of the account you are trying to import. For example, you can use one of the accounts prefunded in the Moonbeam development node. This guide uses Gerald's key. Once you've entered the private key, click on Import.</p> Development account addresses and private keys <ul> <li> <p>Alith:</p> <ul> <li>Public Address: <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>Private Key: <code>0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133</code></li> </ul> </li> <li> <p>Baltathar:</p> <ul> <li>Public Address: <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>Private Key: <code>0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b</code></li> </ul> </li> <li> <p>Charleth:</p> <ul> <li>Public Address: <code>0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</code></li> <li>Private Key: <code>0x0b6e18cafb6ed99687ec547bd28139cafdd2bffe70e6b688025de6b445aa5c5b</code></li> </ul> </li> <li> <p>Dorothy:</p> <ul> <li>Public Address: <code>0x773539d4Ac0e786233D90A233654ccEE26a613D9</code></li> <li>Private Key: <code>0x39539ab1876910bbf3a223d84a29e28f1cb4e2e456503e7e91ed39b2e7223d68</code></li> </ul> </li> <li> <p>Ethan:</p> <ul> <li>Public Address: <code>0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB</code></li> <li>Private Key: <code>0x7dce9bc8babb68fec1409be38c8e1a52650206a7ed90ff956ae8a6d15eeaaef4</code></li> </ul> </li> <li> <p>Faith:</p> <ul> <li>Public Address: <code>0xC0F0f4ab324C46e55D02D0033343B4Be8A55532d</code></li> <li>Private Key: <code>0xb9d2ea9a615f3165812e8d44de0d24da9bbd164b65c4f0573e1ce2c8dbd9c8df</code></li> </ul> </li> <li> <p>Goliath:</p> <ul> <li>Public Address: <code>0x7BF369283338E12C90514468aa3868A551AB2929</code></li> <li>Private Key: <code>0x96b8a38e12e1a31dee1eab2fffdf9d9990045f5b37e44d8cc27766ef294acf18</code></li> </ul> </li> <li> <p>Heath: </p> <ul> <li>Public Address: <code>0x931f3600a299fd9B24cEfB3BfF79388D19804BeA</code></li> <li>Private Key: <code>0x0d6dcaaef49272a5411896be8ad16c01c35d6f8c18873387b71fbc734759b0ab</code></li> </ul> </li> <li> <p>Ida: </p> <ul> <li>Public Address: <code>0xC41C5F1123ECCd5ce233578B2e7ebd5693869d73</code></li> <li>Private Key: <code>0x4c42532034540267bf568198ccec4cb822a025da542861fcb146a5fab6433ff8</code></li> </ul> </li> <li> <p>Judith: </p> <ul> <li>Public Address: <code>0x2898FE7a42Be376C8BC7AF536A940F7Fd5aDd423</code></li> <li>Private Key: <code>0x94c49300a58d576011096bcb006aa06f5a91b34b4383891e8029c21dc39fbb8b</code></li> </ul> </li> <li>Gerald:<ul> <li>Public Address: <code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code></li> <li>Private Key: <code>0x99b3c12287537e38c90a9219d4cb074a89a16e9cdb20bf85728ebd97c343e342</code></li> </ul> </li> </ul> <p></p> <p>You should end up with an imported Account 2 that looks like this:</p> <p></p>"},{"location":"tokens/connect/metamask/#connect-metamask-to-moonbeam","title":"Connect MetaMask to Moonbeam","text":"<p>Once you have MetaMask installed and have created or imported an account, you can connect it to any Moonbeam-based network. To do so, take the following steps:</p> <ol> <li>Click in the upper left network selector menu</li> <li>Select Add Network</li> </ol> <p></p> <p>Next, go to the bottom of the page and click on Add a network manually:</p> <p></p> <p>Here, you can configure MetaMask for the following networks:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node Variable Value Network Name <code>Moonbeam</code> RPC URL <code>https://rpc.api.moonbeam.network</code> Chain ID <code>1284</code> (hex: <code>0x504</code>) Symbol (Optional) <code>GLMR</code> Block Explorer (Optional) <code>https://moonscan.io</code> Variable Value Network Name <code>Moonriver</code> RPC URL <code>https://rpc.api.moonriver.moonbeam.network</code> Chain ID <code>1285</code> (hex: <code>0x505</code>) Symbol (Optional) <code>MOVR</code> Block Explorer (Optional) <code>https://moonriver.moonscan.io/</code> Variable Value Network Name <code>Moonbase Alpha</code> RPC URL <code>https://rpc.api.moonbase.moonbeam.network</code> Chain ID <code>1287</code> (hex: <code>0x507</code>) Symbol (Optional) <code>DEV</code> Block Explorer (Optional) <code>https://moonbase.moonscan.io/</code> Variable Value Network Name <code>Moonbeam Dev</code> RPC URL <code>http://127.0.0.1:9944</code> Chain ID <code>1281</code> (hex: <code>0x501</code>) Symbol (Optional) <code>DEV</code> Block Explorer (Optional) <code>https://moonbeam-explorer.netlify.app/</code> <p>To do so, fill in the following information:</p> <ol> <li>Network name - name that represents the network you are connecting to</li> <li>RPC URL - RPC endpoint of the network</li> <li>Chain ID - chain ID of the Ethereum compatible network</li> <li>Symbol - (optional) symbol of the native token of the network. For example, for Moonbeam, the value would be GLMR</li> <li>Block Explorer - (optional) URL of the block explorer</li> <li>Once you've verified all the information, click on Save</li> </ol> <p></p> <p>Once you've added the network, you'll be redirected to a screen stating that you've successfully added a network. Furthermore, you'll be prompted to Switch to Moonbase Alpha, the network added in this example.</p> <p></p>"},{"location":"tokens/connect/metamask/#interact-with-the-network","title":"Interact with the Network","text":"<p>Once you've connected Metamask to any Moonbeam-based network, you can start using your wallet by:</p> <ul> <li>Sending a token transfer to another address</li> <li>Adding ERC-20s to Metamask and interacting with them</li> <li>Adding ERC-721s to Metamask and interacting with them</li> </ul>"},{"location":"tokens/connect/metamask/#initiate-a-transfer","title":"Initiate a Transfer","text":"<p>This section showcases how to do a simple token transfer to another address as an example of using Metamask with Moonbeam.</p> <p>To do so, take the following steps:</p> <ol> <li>Ensure you are connected to the correct network</li> <li>Ensure you have selected the account you want to use for the transfer</li> <li>On the main screen of your Metamask wallet, click on Send</li> </ol> <p></p> <p>Next, you can enter the address to which you want to send the tokens. For this example, a wallet that has already been imported to Metamask is selected, known as Bob.</p> <p></p> <p>On the next screen, take the following steps:</p> <ol> <li>Enter the number of tokens you want to send</li> <li>Verify that all the information is correct, and click on Next</li> </ol> <p></p> <p>Lastly, confirm that all the gas-related parameters and fees are correct. After you've verified that everything is OK, click Confirm. At this point, your transaction has been sent to the network!</p> <p></p> <p>Once you've confirmed your transaction, you are taken back to the main screen of your wallet, where you'll see the transaction as Pending. After less than a minute, the transaction should be Confirmed. If you click on your transaction, you can check more details and view it in a block explorer.</p> <p></p>"},{"location":"tokens/connect/metamask/#add-an-erc20-token","title":"Add an ERC-20 Token","text":"<p>To add an ERC-20 to your MetaMask wallet, you'll need to import the token using its address:</p> <ol> <li>Make sure you've switched to the Tokens tab in MetaMask</li> <li>Click Import tokens</li> <li>Enter the contract address of the token you want to import. The Token symbol and Token decimal fields will automatically be populated, but you can edit the Token symbol if needed</li> <li>Click Next</li> </ol> <p></p> <p>Next, you'll be able to review the token import details. To finalize the import, you can click Import.</p> <p></p> <p>Under the Tokens tab, you'll be able to see the token and the account balance for the token.</p> <p></p>"},{"location":"tokens/connect/metamask/#add-an-erc721-token","title":"Add an ERC-721 Token","text":"<p>To add an ERC-721 to your MetaMask wallet, you'll need the token's address:</p> <ol> <li>Make sure you've switched to the NFTs tab in MetaMask</li> <li>Click Import NFT</li> <li>Enter the Address of the NFT you want to import and the Token ID</li> <li>Click Import</li> </ol> <p></p> <p>Once you've imported your NFT, you'll be able to see a preview of your NFT in the NFTs tab. You can click on the NFT to see more details.</p> <p></p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/on-ramps/","title":"Fiat On-Ramp Services to Acquire GLMR for Moonbeam","text":""},{"location":"tokens/connect/on-ramps/#introduction","title":"Introduction","text":"<p>Interacting with dApps or deploying smart contracts on Moonbeam requires users to hold GLMR tokens, which are used to pay for network transaction fees (gas), except when using gasless transactions. To help users acquire GLMR, there are several reliable on-ramp services available to convert local currency (fiat) into GLMR. This guide covers two popular options - Transak and Onramp - each offering different payment methods and features to suit individual needs. Supporting bank transfers, credit cards, and mobile payment solutions, these platforms provide secure and regulated ways to acquire GLMR tokens. </p> <p>You can find a current list of supported on-ramps on the Moonbeam dApp. Please be aware that the availability of these services may vary by jurisdiction. For more information, please visit the website of the respective on-ramp. </p>"},{"location":"tokens/connect/on-ramps/#transak","title":"Transak","text":"<p>Using Transak is a straightforward way to purchase GLMR tokens for the Moonbeam network. The process begins at Transak with selecting GLMR as the desired cryptocurrency. Users select their local currency and purchase amount, then review the associated fees and processing time details. The next step requires entering the destination Moonbeam wallet address. For bank transfers and other fiat payment methods, a one-time KYC verification process must be completed by providing valid identification documents. After payment completion through the selected method (bank transfer, credit card, or other supported options), Transak processes the transaction and sends the GLMR tokens directly to the specified wallet address. Delivery time varies depending on the payment method selected, ranging from near-instant for card payments to up to 2 business days for bank transfers.</p>"},{"location":"tokens/connect/on-ramps/#onramp","title":"Onramp","text":"<p>Onramp offers a seamless fiat-to-crypto gateway for purchasing GLMR tokens, supporting over 400 different cryptocurrencies through their platform. The process begins with a straightforward phone-based OTP login system for verification. After login, the platform displays transaction details, including the GLMR amount and current market rates, for confirmation. Based on geographical location, Onramp displays relevant bank account details and available payment methods. Once payment is completed through the selected method, Onramp handles all aspects of the conversion - from payment processing to regulatory compliance and wallet management. Upon confirmation of the deposit, the platform automatically purchases GLMR at the current market price and then initiates an automatic withdrawal to the specified Moonbeam wallet address. Additional KYC verification may be required for larger transactions, but the platform manages all compliance requirements internally to ensure a smooth experience.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/polkadotjs/","title":"How to use Polkadot.js Apps to Interact with Moonbeam","text":""},{"location":"tokens/connect/polkadotjs/#introduction","title":"Introduction","text":"<p>As a Polkadot parachain, Moonbeam uses a unified account structure that allows you to interact with Substrate (Polkadot) functionality and Moonbeam's EVM, all from a single Ethereum-style address. This unified account structure means that you don't need to maintain both a Substrate and an Ethereum account to interact with Moonbeam - instead, you can do it all with a single Ethereum private key.</p> <p>The Polkadot.js Apps interface natively supports H160 addresses and ECDSA keys. So, in this tutorial, you can check out this integration of Ethereum-based accounts on Polkadot.js Apps.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/).  <p>Note</p> <p>Polkadot.js Apps is phasing out support for accounts stored locally in the browser's cache. Instead, it is recommended that you use a browser extension like Talisman to inject your accounts into Polkadot.js Apps.</p>"},{"location":"tokens/connect/polkadotjs/#connect-polkadotjs-apps","title":"Connect Polkadot.js Apps to Moonbeam","text":"<p>When launching Polkadot.js Apps for the first time, you may or may not be connected to the desired network.</p> <p>You can change the selected network by clicking the logo in the top left corner, where you'll find a list of networks organized by MainNets, TestNets, and local networks. Each network can be found under the following sections:</p> Network Section Moonbeam Polkadot &amp; Parachains Moonriver Kusama &amp; Parachains Moonbase Alpha Test Networks Moonbeam Development Node Development <p>Once you've selected the correct network, you can scroll back to the top and click Switch.</p> <p></p> <p>After switching, the Polkadot.js site will not only connect to the chosen network, but the logo and styling will change for each network.</p> <p></p>"},{"location":"tokens/connect/polkadotjs/#creating-or-importing-an-h160-account","title":"Create or Import an H160 Account into Polkadot.js Apps","text":"<p>Note</p> <p>For security purposes, it is recommended that you do not store accounts locally in the browser. A more secure method is using a browser extension like Talisman to inject your accounts into Polkadot.js Apps.</p> <p>In this section, you'll learn how you can create a new account or import a preexisting MetaMask account to Polkadot.js Apps. First, there is one prerequisite step. As part of the process of phasing out support for accounts stored locally in the browser's cache, you'll need to enable support for local storage of accounts in the Settings tab. To do so, take the following steps:</p> <ol> <li>Navigate to the Settings tab</li> <li>Select Allow local in-browser account storage under the in-browser account creation heading</li> <li>Press Save</li> </ol> <p></p> <p>You can now head back to the Accounts page of Polkadot.js Apps and proceed with the next steps:</p> <ol> <li>Navigate to the Accounts section</li> <li>Click on the Add account button</li> </ol> <p></p> <p>This will open a wizard pop-up that will guide you through the process of adding an account to the Polkadot.js Apps interface:</p> <ol> <li>Click on the drop-down menu</li> <li>Change the selection from Mnemonic to Private Key, this allows you to add an account through a private key</li> </ol> <p>Note</p> <p>Currently, you can only create or import accounts in Polkadot.js via a private key. Doing so with the mnemonic will result in a different public address if you later try to import this account to an Ethereum wallet such as MetaMask. This is because Polkadot.js uses BIP39, whereas Ethereum uses BIP32 or BIP44.</p> <p></p> <p>Next, if you want to create a new account, make sure you store the private key displayed by the wizard. If you want to import an existing account, enter your private key that you can export from MetaMask.</p> <p>Note</p> <p>Never reveal your private keys as they give direct access to your funds. The steps in this guide are for demonstration purposes only.</p> <p>Make sure to include the prefix in the private key, i.e., <code>0x</code>. If you entered the information correctly, the corresponding public address should appear in the upper left corner of the window, and then click Next.</p> <p></p> <p>To finish the wizard, you can set an account name and password. After a confirmation message, you should see in the main Accounts tab the address with the corresponding balance: in this case, Bob's address. Moreover, you can overlay the MetaMask extension to see that both balances are the same.</p> <p></p>"},{"location":"tokens/connect/polkadotjs/#sending-a-transaction-through-substrates-api","title":"Send a Transaction Through Substrate's API","text":"<p>Now, to demonstrate the potential of Moonbeam's unified accounts scheme, you can make a transfer through the Substrate API using Polkadot.js Apps. Remember that you are interacting with Substrate using an Ethereum-style H160 address. To do so, you can import another account.</p> <p>Next, click on Bob's send button, which opens another wizard that guides you through the process of sending a transaction.</p> <ol> <li>Set the send to address</li> <li>Enter the amount to send, which for this example is 1 DEV token</li> <li>When ready, click on the Make Transfer button</li> </ol> <p></p> <p>Then you'll be prompted to enter your password and sign and submit the transaction. Once the transaction is confirmed, you should see the balances updated for each account.</p> <p></p> <p>And that is it! We are excited about being able to support H160 accounts in Polkadot.js Apps, as we believe this will greatly enhance the user experience on the Moonbeam Network and its Ethereum compatibility features.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/subwallet/","title":"Interacting with Moonbeam Using SubWallet","text":""},{"location":"tokens/connect/subwallet/#introduction","title":"Introduction","text":"<p>Developers and users of Moonbeam have a variety of options when it comes to wallets. Thanks to Moonbeam's seamless Ethereum compatibility, Moonbeam supports a great variety of popular wallets, including SubWallet.</p> <p>SubWallet is a comprehensive Web3 wallet that natively supports Substrate and Ethereum accounts. Although Moonbeam is a Substrate-based blockchain, it has a unified account system that replaces the default Substrate-style accounts and keys with Ethereum-style accounts and keys. Since SubWallet supports Ethereum-style accounts, you can interact with your Moonbeam account using SubWallet.</p> <p>This guide takes you through all the necessary steps, from installing SubWallet to setting up a wallet, connecting it to Moonbeam, and sending funds.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/subwallet/#install-subwallet","title":"Install SubWallet","text":"<p>There are several ways you can interact with SubWallet: they have a browser extension, a mobile app, and a web-accessible dashboard.</p> <p>You can get started by heading to SubWallet's download page and downloading SubWallet for the platform of your choice.</p> <p>If you choose to use the web-accessible dashboard, you won't need to download anything. You can access the dashboard at web.subwallet.app.</p> <p>The interfaces for the mobile app, browser extension, and web dashboard are quite similar, so you can adapt the following instructions, which focus on the browser extension, for the mobile app and web dashboard.</p>"},{"location":"tokens/connect/subwallet/#setup-a-wallet","title":"Setup a Wallet","text":"<p>Once you've downloaded the SubWallet Browser Extension, you'll be prompted to set up your wallet. You'll be able to choose from the following options:</p> <ul> <li>Create a new account - allows you to create an entirely new account by creating a password and generating a seed phrase</li> <li>Import an account - allows you to import an existing account using the seed phrase, JSON file, private key, or by QR code</li> <li> <p>Attach an account - allows you to connect to an account without the private key. You can use this method to connect to a cold storage wallet, like Keystone, or a watch-only account. With a watch-only account, you will not be able to transfer funds or interact with your account; you'll only be able to view account balances</p> <p>Note</p> <p>Ledger is supported on the browser extension but is not yet available on the mobile app. Support for Ledger on the mobile app is coming soon!</p> </li> <li> <p>Connect wallet - only available on the web dashboard - allows you to connect to a browser extension wallet. You can use this method to easily connect to an account you've created using the SubWallet browser extension or another wallet, such as MetaMask</p> </li> </ul> <p>The following sections will provide step-by-step instructions for creating a new account and importing an existing account with SubWallet.</p> <p>If you're attaching an account, you can find step-by-step instructions on SubWallet's Account management documentation. Similarly, if you're connecting a wallet on the web dashboard, you can find instructions on SubWallet's Connect extension documentation.</p>"},{"location":"tokens/connect/subwallet/#create-a-new-account","title":"Create a New Account","text":"<p>Creating a new account will generate a seed phrase that can derive multiple Ethereum and Substrate accounts. By default, SubWallet will generate a single Ethereum and a single Substrate account, but you can easily derive more from the same seed phrase. To interact with Moonbeam, you will need to use an Ethereum account. Click Create a new account to get started.</p> <p></p> <p>On the following screen, you'll be prompted to create a password to secure your new wallet:</p> <ol> <li>Enter a password that has at least 8 characters</li> <li>Confirm the password by entering it again</li> <li>Click Continue</li> </ol> <p></p> <p>You'll then be prompted to back up your seed phrase. This is an important step, especially because you have the option to later derive additional accounts from this seed phrase.</p> <ol> <li> <p>View your seed phrase and save it in a safe place</p> <p>Remember</p> <p>You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.</p> </li> <li> <p>Once you've safely stored your seed phrase, click I have kept it somewhere safe</p> </li> </ol> <p></p> <p>Note</p> <p>If you're creating a new account on the mobile app, you'll have to re-enter your seed phrase to verify that you have stored it. The words have to be entered in the correct order.</p> <p>After you've created a password and saved your seed phrase, you'll be connected to your account. You can add additional accounts at any time.</p>"},{"location":"tokens/connect/subwallet/#import-an-account","title":"Import an Account","text":"<p>To import an existing account into SubWallet, you can select Import an account.</p> <p></p> <p>On the following screen, select the method by which you would like to import the existing account. You can choose from Import from seed phrase, Import from Polkadot.{js}, Import by MetaMask private key, and Import by QR code.</p> <p>If you select Import from seed phrase, there are some incompatibility issues that can arise when importing an account from seed phrase. For example, Trust Wallet and SafePal are among the wallets not compatible with SubWallet. If you run into incompatibility issues, SubWallet recommends creating a new wallet.</p> <p>If you select Import from Polkadot.{js}, you'll need to make sure that the account was created in Polkadot.js via private key. If it was created with a seed phrase and you attempt to import it to SubWallet, a different public address will be used. This is because Polkadot.js uses BIP39, whereas Ethereum uses BIP32 or BIP44.</p> <p></p> <p>If you import your account via seed phrase, you can select your account type as either Substrate (Polkadot) or EVM (Ethereum), or both. Moonbeam uses Ethereum-style accounts, so you'll need to select Ethereum to import an account for Moonbeam-based networks.</p> <p></p> <p>Once you've completed the import process, you'll be prompted to enter a password to secure your new wallet:</p> <ol> <li>Enter a password that has at least 8 characters</li> <li>Confirm the password by entering it again</li> <li>Click Continue</li> </ol> <p></p> <p>Next, you'll be able to provide the relevant seed phrase, private key, JSON file, or QR code, and you can begin using your new account right away. You can add additional accounts at any time.</p>"},{"location":"tokens/connect/subwallet/#add-additional-accounts","title":"Add Additional Accounts","text":"<p>After you have created a new account or imported an existing account to SubWallet, you can add additional accounts by taking the following steps:</p> <ol> <li>Click on the account dropdown</li> <li>Select one of the options from the bottom of the screen. You can click Create a new account, the import button to import an existing account, or the attach button to attach to an existing cold storage wallet or watch-only account</li> </ol> <p></p> <p>If you're creating a new account, you can then choose Create with new seed phrase or Derive from an existing account. If you're creating a new account with a new seed phrase, you'll need to select the account type and back up the account, similar to the instructions in the Create a New Account section. If you choose to derive a new account, you'll be prompted to select the existing account that you want to derive the account from.</p> <p>If you're importing a new account, you'll need to choose whether to import using a seed phrase, JSON file, MetaMask private key or QR code, then repeat the process outlined in the Import an Account section.</p> <p>If you're attaching an account, you can find out step-by-step instructions on SubWallet's Account management documentation.</p>"},{"location":"tokens/connect/subwallet/#connect-subwallet-to-moonbeam","title":"Connect SubWallet to Moonbeam","text":"<p>To configure SubWallet for Moonbeam, select the Customize your asset display icon next to the Search a token icon.</p> <p></p> <p>To add Moonbeam, you can:</p> <ol> <li>Search for \"Moon\" to view all Moonbeam-based networks, or search for a specific network</li> <li>Toggle the switch to connect to the network</li> </ol> <p></p> <p>If you're trying to connect to a local Moonbeam development node, you can select the hamburger menu from the top left corner, which will take you to the settings page.</p> <p></p> <p>From the settings menu, click Manage networks.</p> <p></p> <p>Click the + icon in the top right corner and enter in the network configurations. You can also manage and connect to other networks from this menu.</p> <p></p> <p>By default, all balances are hidden in SubWallet, but if you press the Show balance icon, you can toggle balance visibility.</p> <p></p>"},{"location":"tokens/connect/subwallet/#interact-with-the-network","title":"Interact with the Network","text":"<p>Once you've connected SubWallet to any Moonbeam-based network, you can start using your wallet by:</p> <ul> <li>Receiving a token from another address</li> <li>Sending a token to another address</li> <li>Adding tokens to SubWallet and interacting with them</li> </ul>"},{"location":"tokens/connect/subwallet/#receive-a-token","title":"Receive a Token","text":"<p>To receive a token from another account, you would need to show your wallet address to your counterparty, and they can send their assets to such address.</p> <p>To copy your address, click on the Get address icon.</p> <p></p> <p>If you have multiple accounts and have selected All accounts from the account dropdown menu, you'll need to select the receiving account you want to send the assets to. Otherwise, make sure that the account you're connected to (which is displayed at the top of the screen) is the account you want to send the assets to. This should be your Moonbeam account, which is an Ethereum-style address.</p> <p></p> <p>Next, you can search for and choose the token that you would like to receive. For this example, DEV is chosen.</p> <p></p> <p>Note</p> <p>SubWallet supports receiving cross-chain tokens, so please be sure to check that the chain logo under the token name matches your desired chain.</p> <p>You will be shown the QR code and the address linked to your account. Double-check that the address shown is an Ethereum-style account.</p> <p></p> <p>Now you just need to show the QR code or address to the sender.</p>"},{"location":"tokens/connect/subwallet/#send-a-transaction","title":"Send a Transaction","text":"<p>To get started with a simple token transfer to another address on Moonbeam, you can click the Send icon.</p> <p></p> <p>Next, you can take the following steps:</p> <ol> <li> <p>Specify the asset to send and the destination chain</p> <p>Note</p> <p>Some tokens are allowed to be transferred cross-chain, so when choosing the destination network, you can choose the dropdown menu to see the available options.</p> </li> <li> <p>Enter the destination address, which can also be done using the address book or by scanning the recipient's QR code</p> <p>Note</p> <p>If you're using the mobile app, click Next to proceed.</p> </li> <li> <p>Enter the amount of tokens to send</p> </li> <li>Look over the transaction details, then press Transfer</li> </ol> <p></p> <p>On the next screen, you'll be able to review the transaction details and submit the transaction. If the transaction details look good, you can click Approve to send the transaction.</p> <p></p> <p>After you send the transaction, you'll be able to review the transaction details.</p> <p>And that's it! For more information on how to use SubWallet, please refer to SubWallet's documentation.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/talisman/","title":"Interacting with Moonbeam Using Talisman","text":""},{"location":"tokens/connect/talisman/#introduction","title":"Introduction","text":"<p>As a Polkadot parachain, Moonbeam uses a unified account structure that allows you to interact with Substrate (Polkadot) functionality and Moonbeam's EVM, all from a single Ethereum-style address. This unified account structure means that you don't need to maintain both a Substrate and an Ethereum account to interact with Moonbeam - instead, you can do it all with a single Ethereum private key.</p> <p>Polkadot.js Apps supports H160 accounts injected into the browser via an extension like Talisman. Note, Polkadot.js Apps is phasing out support for accounts stored locally in the browser's cache. While you can continue to use any accounts that you've imported and stored in your browser locally via Polkadot.js Apps, you won't be able to add any new ones. This means that you'll need to use an extension like Talisman. Furthermore, injecting your account from an extension like Talisman is generally regarded to be safer than storing the account directly in the browser.</p> <p>This guide will include all of the steps for setting up an account in Talisman and using it to interact with Moonbeam through Polkadot.js Apps.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/talisman/#setting-up-talisman","title":"Setting up Talisman","text":"<p>Talisman is a crypto-wallet that natively supports Substrate (Polkadot) and Ethereum accounts. The Talisman wallet browser extension is available on Google Chrome and Brave, and a corresponding asset dashboard is accessible at app.talisman.xyz</p> <p>First, download and install the Talisman extension. Once the extension opens up, you'll be prompted to either create a new wallet or import an existing one. For the purposes of this demo, you'll create a new wallet. On the following screen you'll be prompted to create a password to secure the new wallet.  </p> <p></p> <p>Remember</p> <p>Talisman does not require you to back up your seed phrase but will nudge you with a reminder at the bottom of the screen. If you don't back up your seed phrase, you could lose all of your assets.</p> <p>To back up your newly created wallet, take the following steps:</p> <ol> <li>Press Backup Now</li> <li>Enter the password to your Talisman wallet</li> <li>Press View Recovery Phrase and store it in a secure place</li> </ol> <p></p>"},{"location":"tokens/connect/talisman/#setting-up-talisman-to-connect-to-testnets","title":"Setting up Talisman to Connect to Testnets","text":"<p>Talisman works with all Moonbeam networks after you enable Ethereum accounts. You can also see your balances across all networks in the Portfolio tab by clicking on the extension's Talisman logo in the upper left-hand corner. By default, Talisman hides your testnet account balances. However, you can change this by taking the following steps:</p> <ol> <li>Open the Talisman extension and click on the Talisman logo</li> <li>Select Settings</li> <li>Select Ethereum Networks</li> <li>Click Enable Testnets</li> </ol> <p></p>"},{"location":"tokens/connect/talisman/#connecting-talisman-to-moonbase-alpha-polkadot.js-apps","title":"Connecting Talisman to Moonbeam and Polkadot.js Apps","text":"<p>Connecting Talisman to a Moonbeam-based network in Polkadot.js Apps is straightforward. Remember that you need to enable testnets if you want to connect to Moonbase Alpha.</p> <p>To connect to a Moonbeam-based network, the Moonbase Alpha testnet in this example, head to Moonbase Alpha Polkadot.js Apps. The Talisman extension will prompt you to select the accounts you'd like to use with Polkadot.js Apps. If it doesn't automatically pop up, you can open the Talisman extension and press the Connected / Not Connected button at the top. To configure Talisman to correctly interface with Moonbeam networks on Polkadot.js Apps, you should take the following steps:</p> <ol> <li>Check the box next to Show Ethereum Accounts</li> <li>Select the accounts you want to connect to Polkadot.js Apps. In this example, it is only My Ethereum Account. This is the default name assigned by Talisman which you can rename if you'd like</li> <li>Press Connect 1. The value will change depending on the number of accounts you are connecting</li> </ol> <p></p> <p>Your Talisman wallet is now connected to Polkadot.js Apps. After refreshing Polkadot.js Apps, you should see your Talisman account in the Accounts page of Polkadot.js Apps. When launching Polkadot.js Apps for the first time, you may or may not be connected to the desired network. You can change your selected network to the Moonbase Alpha TestNet by clicking the logo in the top left corner, then scroll down to the Test Networks section, select Moonbase Alpha, and scroll back to the top and click Switch.</p> <p></p> <p>After switching, the Polkadot.js site will not only connect to Moonbase Alpha, but also change its styling to make a perfect match.</p> <p></p>"},{"location":"tokens/connect/talisman/#adding-a-new-account-to-talisman","title":"Adding a New Account to Talisman","text":"<p>In this section, you'll learn how you can create a new account, or import an already existing MetaMask account to Polkadot.js Apps.</p> <ol> <li>Open the Talisman extension and click on the Talisman logo in the upper left hand corner</li> <li>Select Add Account</li> <li>Select New Account</li> <li>Select Ethereum as the account type</li> <li>Give your new account a name</li> <li>Press Create</li> </ol> <p></p> <p>Although our new account has been successfully created, Polkadot.js Apps isn't aware of it yet. To connect the new account to Polkadot.js Apps, take the following steps from Polkadot.js Apps:</p> <ol> <li>Open the Talisman extension and Press the Connected / Not-connected button</li> <li>Ensure Show Eth accounts is checked</li> <li>Click on the account you'd like to connect. The green dot next to the account will light up if it is selected</li> </ol> <p></p>"},{"location":"tokens/connect/talisman/#sending-a-transaction-through-substrates-api","title":"Sending a Transaction Through Substrate's API","text":"<p>Now, to demonstrate the potential of Moonbeam's unified accounts scheme you can make a transfer through the Substrate API using Polkadot.js Apps. Remember that you are interacting with Substrate using an Ethereum-style H160 address. To do so, you can add another account. The accounts in Talisman have been renamed to the familiar Alice and Bob accounts. To send some DEV funds from Alice to Bob, take the following steps:</p> <p>Click on Alice's send button, which opens another wizard that guides you through the process of sending a transaction.</p> <ol> <li>Set the send to address</li> <li>Enter the amount to send, which is 4 DEV tokens in this example</li> <li>When ready, click on the Make Transfer button</li> <li>Approve the transaction in the Talisman pop up</li> </ol> <p></p> <p>After the transaction is confirmed, you should see the balances updated for each account.</p> <p></p> <p>And that is it! These steps have demonstrated the ease coupled with the robust security of interacting with injected H160 accounts in Polkadot.js Apps with Talisman. All of this is possible because of Moonbeam's unified account structure, a great example of Moonbeam's commitment to providing the best user experience.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/trezor/","title":"Interacting with Moonbeam Using Trezor Hardware Wallet","text":""},{"location":"tokens/connect/trezor/#introduction","title":"Introduction","text":"<p>Hardware wallets provide a safer way to store crypto funds because the private key (used for signing transactions) is stored offline. Trezor offers two hardware wallet solutions at the time of writing: Trezor One and Trezor Model T.</p> <p>Because Moonbeam is fully Ethereum compatible, you can use your Trezor device to sign transactions on Moonbeam!</p> <p>This tutorial shows you how to get started with your Trezor hardware wallet on Moonbase Alpha. The guide only illustrates the steps for a Trezor Model T device, but you can follow along with a Trezor One as well.</p> <p>Please note that your Trezor device will sign transactions in whichever MetaMask network is connected to.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/trezor/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before you get started, update Trezor Suite to the latest version available. Also, make sure your Trezor hardware wallet is running the latest firmware. The Trezor wiki offers tutorials on how to update the firmware of both Trezor One and Trezor Model T devices.</p> <p>At the time of writing, the following versions were used:</p> <ul> <li>Trezor Suite 21.5.1</li> <li>Trezor One firmware v1.10.0</li> <li>Trezor Model T firmware v2.4.0</li> </ul> <p>In addition, you'll need MetaMask as an intermediary between your Trezor device and Moonbase Alpha. Make sure that your MetaMask is connected to Moonbase Alpha. Please note that your Trezor device will sign transactions in whichever MetaMask network is connected to.</p>"},{"location":"tokens/connect/trezor/#importing-your-trezor-account-to-metamask","title":"Importing your Trezor Account to MetaMask","text":"<p>To get started, you need to have set up a wallet (either standard or a hidden wallet). Once you've connected your Trezor device, unlocked it, and set up a wallet in Trezor Suite. Next, to import your Trezor Ethereum account to MetaMask, take the following steps:</p> <ol> <li>Click on the top-right logo to expand the menu</li> <li>Select Connect Hardware Wallet</li> </ol> <p></p> <p>Right after, you are prompted to select which hardware wallet you'll like to use in MetaMask. At the moment of writing, only Ledger and Trezor hardware wallets are supported. If you have your Trezor device ready to go, take the following steps:</p> <ol> <li>Select the Trezor logo</li> <li>Click on Continue</li> </ol> <p></p> <p>After clicking the button, a new tab named TrezorConnect should show up, where you'll need to pair your device. This is not required if you've Trezor Suite opened and your device is connected. Here, click on Pair devices.</p> <p></p> <p>On the next screen, take the following steps:</p> <ol> <li>Click on Check for devices. This will open a menu showing which Trezor device (if available) you want to connect to</li> <li>Select the Trezor device you want to use</li> <li>Click on Connect</li> </ol> <p></p> <p>Once your device is connected, you need to allow MetaMask to read its public keys. Therefore, click on Allow once for this session. Optionally, you can also check the Don't ask me again box.</p> <p></p> <p>Next, you are asked if you want to export the public key of your Ethereum account (tab was cropped and labeled as 1 in the following image). Right after, you are prompted with an option to use [Trezor's passphrase option (tab cropped and labeled as 2 in the image). If you want to use the default wallet, just click on Enter. If not, please follow Trezor's wiki article for passphrase wallets.</p> <p></p> <p>If MetaMask was able to connect successfully to your Trezor device, you should see a list of five Ethereum-styled accounts. If not, please double-check that you've properly connected your Trezor device to the computer and it is unlocked. You can also repeat the process with the Trezor Suite app opened.</p> <p>From this list of five Ethereum accounts, take the following steps:</p> <ol> <li>Select the accounts you would like to import from your Trezor device</li> <li>Click on Unlock</li> </ol> <p></p> <p>If you've imported your Trezor Ethereum-styled account successfully, you should see it displayed in the main MetaMask screen like shown in the following image:</p> <p></p> <p>You've now successfully imported a Moonbeam compatible account from your Trezor device and are now ready to start signing transactions using your hardware wallet.</p>"},{"location":"tokens/connect/trezor/#signing-a-transaction-using-your-trezor","title":"Signing a Transaction Using your Trezor","text":"<p>If you've successfully imported your Trezor account to MetaMask, you are ready to sign transactions on Moonbeam using your Trezor device. This tutorial will show you how to send a simple transaction on the Moonbase Alpha TestNet, but it applies to other Moonbeam ecosystem networks.</p> <p>First, make sure your Trezor account is funded with DEV tokens. Next, click on the Send button.</p> <p></p> <p>A <code>TrezorConnect</code> tab should pop up, asking permission to read public keys from your device and prepare your Trezor for transaction and data signing. Once you are ready, click on Allow once for this session. Optionally, you can also check the Don't ask me again box.</p> <p></p> <p>As you would in a standard transaction, set the recipient address, enter the number of tokens to send, review transaction details and confirm it. This will initiate the transaction signature wizard in your Trezor device. Here, take the following steps:</p> <ol> <li>Review all transaction details. Please note that the token corresponds to the network MetaMask is connected to. In this case, it is DEV tokens and not UNKN!</li> <li>Once all details have been checked, hold the button to confirm</li> </ol> <p>Note</p> <p>At the time of writing, the token name for all Moonbeam-related networks is always shown as <code>UNKN</code>. Please note that the token being handled is the one corresponding to the network MetaMask is connected to.</p> <p></p> <p>Right after you've approved the transaction, MetaMask sends it to the network. Once the transaction is confirmed, it will be displayed as Send on MetaMask's main screen.</p> <p></p> <p>And that is it! You've signed a transaction on Moonbase Alpha using your Trezor hardware wallet.</p> <p>The process of interacting with smart contracts using your Trezor device is similar. Make sure to double-check the data being signed on your Trezor device before confirming the transaction.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/ledger/ethereum/","title":"Interacting with Moonbeam Using Ledger and the Ethereum App","text":""},{"location":"tokens/connect/ledger/ethereum/#introduction","title":"Introduction","text":"<p>Hardware wallets provide a safer way to store crypto funds because the private key (used for signing transactions) is stored offline. Ledger offers two hardware wallet solutions at the time of writing: Ledger Nano S and Ledger Nano X.</p> <p>For Moonbeam, Moonriver, and the Moonbase Alpha TestNet, you can use the Ethereum app on Ledger Live by setting the chain ID. For Moonbeam, the chain ID is 1284, for Moonriver it's 1285, and for Moonbase Alpha it's 1287.</p> <p>For Moonbeam and Moonriver you also have the option of using the dedicated Moonbeam app or Moonriver app on Ledger Live, this way you do not have to worry about setting the chain ID and you know you are connected to the right network. Please note that you can only use the Moonbeam app to connect to the Moonbeam network, and the Moonriver app can only be used to connect to the Moonriver network. These dedicated apps will not work for other Moonbeam-based networks.</p> <p>In this tutorial, you will learn how to get started with your Ledger hardware wallet on Moonbeam using the Ethereum app. This guide only illustrates the steps for a Ledger Nano X device, but you can follow along with a Ledger Nano S as well. </p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/ledger/ethereum/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before you get started, update Ledger Live to the latest version available. Also, make sure you've your Ledger hardware wallet device running the latest firmware. The Ledger support website offers tutorials on how to update the firmware.</p> <p>At the time of writing, the following versions were used:</p> <ul> <li>Ledger Live 2.35.1</li> <li>Ledger Nano S firmware v2.0.0</li> <li>Ledger Nano X firmware v2.0.1</li> </ul> <p>As of November 29, 2022, the Moonbeam and Ledger Live integration was released, allowing you to send and receive GLMR tokens with your Ledger device directly in Ledger Live. With this integration, you'll no longer need to connect your Ledger to MetaMask. If you prefer this method, please skip ahead to the Use Ledger Live to Send &amp; Receive GLMR section of this guide.</p> <p>If you prefer to use MetaMask as an intermediary between your Ledger device and Moonbeam, make sure that your MetaMask is connected to Moonbeam.</p> <p>As of MetaMask version 10.5.0, connecting your Ledger device with MetaMask on Chrome is easy again. You just need to have the latest version of MetaMask installed.</p>"},{"location":"tokens/connect/ledger/ethereum/#install-the-ledger-live-app","title":"Install the Ledger Live App","text":"<p>If you want to connect to Moonbeam, Moonriver, or the Moonbase Alpha TestNet you can do so by installing the Ethereum app, and later on you'll need to specify a chain ID.</p> <p>To get started, open up Ledger Live and:</p> <ol> <li>Select Manager from the menu</li> <li>Connect and unlock your device (this must be done before installation)</li> <li>In the App catalog search for Ethereum (ETH) and click Install. Your Ledger device will show Processing and once the installation is complete, the app will appear on your Ledger device</li> </ol> <p>In the Ledger Live app, depending on which app(s) you installed you should see them listed under the Apps installed tab on the Manager page. After the app(s) have been successfully installed, you can close out of Ledger Live. </p> <p></p>"},{"location":"tokens/connect/ledger/ethereum/#import-your-ledger-account-to-metamask","title":"Import your Ledger Account to MetaMask","text":"<p>Now that you've installed the app(s) on Ledger Live, you can connect your Ledger to the computer and unlock it, and open the Ethereum app. </p> <p>Then import your Ledger account to MetaMask using the following steps:</p> <ol> <li>Click on the top-right logo to expand the menu</li> <li>Select Connect Hardware Wallet</li> </ol> <p></p> <p>In the next screen, you are prompted to select which hardware wallet you'll like to use in MetaMask. At the moment of writing, only Ledger and Trezor hardware wallets are supported. Here, take the following steps:</p> <ol> <li>Select the Ledger logo</li> <li>Click on Continue</li> </ol> <p></p> <p>If you're using Chrome or a Chrome-based browser like Brave, you'll be prompted to select your Ledger device to connect via WebHID:</p> <ol> <li>Select your Ledger device from the pop-up</li> <li>Click Connect</li> </ol> <p></p> <p>If a pop-up doesn't appear, you may need to change your MetaMask settings to enable a WebHID connection. You can check and update your MetaMask settings by following these steps:</p> <ol> <li>Expand the top-right menu and go to Settings </li> <li>Navigate to Advanced</li> <li>Scroll down to Preferred Ledger Connection Type and select WebHID from the dropdown</li> </ol> <p>Note</p> <p>The Preferred Ledger Connection Type setting is only available on Chrome and Chrome-based browsers. This setting doesn't exist on other browsers such as Firefox.</p> <p>If MetaMask was able to connect successfully to your Ledger device, you should see a list of five Moonbeam/Ethereum-styled accounts. If not, double-check that Ledger Live is closed, you've connected your Ledger device to the computer, and unlocked it, and make sure the Ethereum app is open.</p>"},{"location":"tokens/connect/ledger/ethereum/#import-accounts-and-view-balances","title":"Import Accounts and View Balances","text":"<p>From the list of accounts, take the following steps:</p> <ol> <li>Select the accounts you would like to import from your Ledger device</li> <li>Click on Unlock</li> </ol> <p></p> <p>If you've imported your Ledger account successfully, you should see your account and balance displayed in the main MetaMask screen like shown in the following image:</p> <p></p> <p>You can switch accounts in MetaMask at any time to view the balance of your other imported Ledger accounts.</p> <p>You've now successfully imported a Moonbeam compatible account from your Ledger device and are now ready to start interacting with your Ledger device.</p>"},{"location":"tokens/connect/ledger/ethereum/#receive-tokens","title":"Receive Tokens","text":"<p>To get started interacting with your Ledger device, you will need to send some funds to it. Copy your address from MetaMask by clicking on your account name and address in MetaMask.</p> <p></p> <p>Next, you will need to obtain some GLMR, MOVR, or DEV tokens and using the address you just copied, send the tokens to your account. After the transaction has successfully gone through, you will see your balance update.</p> <p>You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet.</p>"},{"location":"tokens/connect/ledger/ethereum/#send-tokens","title":"Send Tokens","text":"<p>Next up is sending and signing transactions on Moonbeam using your Ledger device. To get started sending a transaction, click on the Send button:</p> <p></p> <p>As you would in a standard transaction, set the recipient address, enter the number of tokens to send, review transaction details and confirm it. This will initiate the transaction signature wizard in your Ledger device. Here, take the following steps:</p> <ol> <li>Click the button to proceed to the next screen. Your Ledger device is only warning you to review the transaction</li> <li>Check the number of tokens being sent then proceed to the next screen</li> <li>Check the recipient's address and proceed to the next screen</li> <li>Check the chain ID of the network. This information confirms which network MetaMask is connected to. For Moonbeam the chain ID is 1284 (hex: 0x504), Moonriver is 1285 (hex: 0x505), and Moonbase Alpha is 1287 (hex: 0x507). When ready, proceed to the next screen</li> <li>Check the max fees applicable to this transaction. This is the gas price multiplied by the gas limit you've set on MetaMask. When ready, proceed to the next screen</li> <li>If you agree with all the transaction details, approve it. This will sign the transaction and will trigger MetaMask to send it. If you don't agree with all the transaction details, reject it. This will cancel the transaction, and MetaMask will mark it as failed</li> </ol> <p></p> <p>Right after you've approved the transaction, MetaMask sends it to the network. Once the transaction is confirmed, it will be displayed as Send on the Activity tab in MetaMask.</p> <p></p> <p>And that is it! You've signed a transaction and sent some tokens on Moonbeam using your Ledger hardware wallet!</p>"},{"location":"tokens/connect/ledger/ethereum/#interact-with-contracts-using-your-ledger","title":"Interact with Contracts Using your Ledger","text":"<p>By default, Ledger devices don't admit a <code>data</code> field in the transaction object. Consequently, users can't deploy or interact with smart contracts.</p> <p>However, if you want to use your Ledger hardware wallet for transactions related to smart contracts, you need to change a configuration parameter inside the app on your device. To do so, take the following steps:</p> <ol> <li>On your Ledger, open the Moonriver or Ethereum app</li> <li>Navigate to Settings</li> <li>Find the Blind signing page. It should state NOT Enabled at the bottom</li> <li>Select/validate the option to change its value to Enabled</li> </ol> <p>Note</p> <p>This option is necessary to use your Ledger device to interact with ERC-20 token contracts that might live inside the Moonbeam ecosystem.</p> <p></p>"},{"location":"tokens/connect/ledger/ethereum/#use-ledger-live","title":"Use Ledger Live to Send &amp; Receive GLMR","text":"<p>You can also use your Ledger device to send and receive GLMR tokens securely from within Ledger Live. This enables you to manage your GLMR tokens without connecting your device to MetaMask.</p> <p>When you open up the Ledger Live app, make sure that you've installed the latest updates. If there are any pending updates that need to be installed, there will be a banner at the top of the screen that prompts you to install the updates.</p> <p>To get started, you'll need to login to your Ledger device to unlock it. From Ledger Live, click on My Ledger. On your device, you'll be prompted to allow Ledger manager; you can click both buttons on your device to allow it.</p> <p>Once on the Ledger manager, you'll need to make sure that your firmware is up to date, and if the Moonbeam and/or Ethereum apps need to be updated, go ahead and install the latest versions.</p> <p>Next, you'll need to add an account to your Ledger Live app. To do so, you can take the following steps:</p> <ol> <li>Click on Accounts from the left-side menu</li> <li>Select Add account</li> <li>A dropdown will appear. Search for GLMR and Moonbeam (GLMR) should appear for you to select</li> <li>Click Continue</li> </ol> <p></p> <p>Next, you'll be able to enter an account name and click Add account. If your account was successfully added, you can click Done and your account will appear in your list of accounts.</p>"},{"location":"tokens/connect/ledger/ethereum/#receive-tokens_1","title":"Receive Tokens","text":"<p>To receive GLMR to your Ledger device, you can take the following steps from Ledger Live:</p> <ol> <li>Click on Receive from the left-side menu</li> <li>A pop-up will appear. You can select your Moonbeam account where you want to receive tokens from the Account to credit dropdown</li> <li>Click Continue</li> </ol> <p></p> <p>Next, your address should appear on Ledger Live, and you'll be prompted to verify your address on your Ledger device. On your device, you can take the following steps:</p> <ol> <li>You should see Verify Address on your device's screen. Click the right button to start verifying your address</li> <li>On the next screen, you should see your address. Compare the address on your device to the one displayed on Ledger Live and verify it matches. At this time, you'll want to copy the address from Ledger Live so you can send a transaction to it. Click the right button to continue</li> <li>Now, you should see the Approve screen. If the addresses match, you can click both buttons on your device to approve the verification. Otherwise, click the right button again to get to the Reject screen where you can click both buttons to reject the verification</li> </ol> <p></p> <p>Over on Ledger Live, you'll see that your address has been shared securely, and you can click Done. Now, you can send some GLMR to your Ledger account.</p>"},{"location":"tokens/connect/ledger/ethereum/#send-tokens_1","title":"Send Tokens","text":"<p>To send GLMR from your Ledger device, you can take the following steps from Ledger Live:</p> <ol> <li>Click on Send from the left-side menu</li> <li>A pop-up will appear. From the Account to debit dropdown, you can select your Moonbeam account that you want to send tokens from</li> <li>Enter an address in the Receipient address field</li> <li>Click Continue</li> </ol> <p></p> <p>On the next screen, you can enter the amount of GLMR that you would like to send and click Continue.</p> <p></p> <p>The last step on Ledger Live is to verify that the transaction details are correct. If everything looks good, you can click Continue. Then you'll be prompted to confirm the transaction on your Ledger device:</p> <ol> <li>The first screen will be the Review transaction screen. Click the right button to proceed to the next screen</li> <li>Verify the amount of GLMR you're sending and click the right button to proceed</li> <li>Verify the address you're sending the GLMR to and click the right button to proceed</li> <li>The Network screen should show Moonbeam. Click the right button to proceed</li> <li>Review the Max Fees and click the right button to proceed</li> <li>If everything looks good, you can click both buttons to Accept and send the transaction. Otherwise, you can click the right button to get to the Reject screen where you can click both buttons to reject the transaction</li> </ol> <p></p> <p>On Ledger Live, you should see that your transaction was sent, and you can view the details of the transaction. Once the transaction has been confirmed, your GLMR balance will update.</p> <p>And that is it! You've successfully used the Moonbeam Ledger Live integration to receive and send tokens with your Ledger device directly from Ledger Live!</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/ledger/moonbeam/","title":"Interacting with Moonbeam Using Ledger and the Moonbeam App","text":""},{"location":"tokens/connect/ledger/moonbeam/#introduction","title":"Introduction","text":"<p>Hardware wallets provide a safer way to store crypto funds because the private key (used for signing transactions) is stored offline. Ledger offers two hardware wallet solutions at the time of writing: Ledger Nano S and Ledger Nano X.</p> <p>You can interact with Moonbeam using your Ledger hardware wallet through the Moonbeam Ledger Live app. With the dedicated Moonbeam app, you do not have to worry about setting the chain ID and you know you are connected to the right network. Please note that you can only use the Moonbeam app to connect to the Moonbeam network, it cannot be used to connect to other Moonbeam-based networks.</p> <p>You also have the option of using the Ethereum app to connect to Moonbeam. The main difference between using the Moonbeam and the Ethereum app is that you have to specify the chain ID when you use the Ethereum app, which is 1284 for Moonbeam. If you're interested in using the Ethereum app instead, you can check out the Interacting with Moonbeam Using Ledger and the Ethereum App guide.</p> <p>In this tutorial, you will learn how to get started with your Ledger hardware wallet on Moonbeam using the Moonbeam app. This guide only illustrates the steps for a Ledger Nano X device, but you can follow along with a Ledger Nano S as well. </p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/ledger/moonbeam/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before you get started, update Ledger Live to the latest version available. Also, make sure you've your Ledger hardware wallet device running the latest firmware. The Ledger support website offers tutorials on how to update the firmware.</p> <p>At the time of writing, the following versions were used:</p> <ul> <li>Ledger Live 2.35.1</li> <li>Ledger Nano S firmware v2.0.0</li> <li>Ledger Nano X firmware v2.0.1</li> </ul> <p>As of November 29, 2022, the Moonbeam and Ledger Live integration was released, allowing you to send and receive GLMR tokens with your Ledger device directly in Ledger Live. With this integration, you'll no longer need to connect your Ledger to MetaMask. If you prefer this method, please skip ahead to the Use Ledger Live to Send &amp; Receive GLMR section of this guide.</p> <p>If you prefer to use MetaMask as an intermediary between your Ledger device and Moonbeam, make sure that your MetaMask is connected to Moonbeam.</p> <p>As of MetaMask version 10.5.0, connecting your Ledger device with MetaMask on Chrome is easy again. You just need to have the latest version of MetaMask installed.</p>"},{"location":"tokens/connect/ledger/moonbeam/#install-the-moonbeam-ledger-live-app","title":"Install the Moonbeam Ledger Live App","text":"<p>The Moonbeam app is dependent on the Ethereum app, so first you will need to install the Ethereum app. Once the Ethereum app is installed you will be able to install the Moonbeam app without a problem. Please note that the Moonbeam app is only for the Moonbeam network, it will not work for Moonriver or Moonbase Alpha.</p> <p>To get started, open up Ledger Live and:</p> <ol> <li>Select Manager from the menu</li> <li>Connect and unlock your device (this must be done before installation)</li> <li>In the App catalog search for Ethereum (ETH) and click Install. Your Ledger device will show Processing and once the installation is complete, the app will appear on your Ledger device</li> <li>Search for Moonbeam (GLMR) in the App catalog and click Install. Again, your Ledger device will show Processing and once complete, the Moonbeam app will appear on your Ledger device</li> </ol> <p>In the Ledger Live app, you should see the Ethereum and Moonbeam app listed under the Apps installed tab on the Manager page. After the apps have been successfully installed, you can close out of Ledger Live. </p> <p></p>"},{"location":"tokens/connect/ledger/moonbeam/#import-your-ledger-account-to-metamask","title":"Import your Ledger Account to MetaMask","text":"<p>Now that you've installed the Ledger Live apps, you can connect your Ledger to the computer, unlock it, and open the Moonbeam app. </p> <p>Then import your Ledger account to MetaMask using the following steps:</p> <ol> <li>Click on the top-right logo to expand the menu</li> <li>Select Connect Hardware Wallet</li> </ol> <p></p> <p>In the next screen, you are prompted to select which hardware wallet you'll like to use in MetaMask. At the moment of writing, only Ledger and Trezor hardware wallets are supported. Here, take the following steps:</p> <ol> <li>Select the Ledger logo</li> <li>Click on Continue</li> </ol> <p></p> <p>If you're using Chrome or a Chrome-based browser like Brave, you'll be prompted to select your Ledger device to connect via WebHID:</p> <ol> <li>Select your Ledger device from the pop-up</li> <li>Click Connect</li> </ol> <p></p> <p>If a pop-up doesn't appear, you may need to change your MetaMask settings to enable a WebHID connection. You can check and update your MetaMask settings by following these steps:</p> <ol> <li>Expand the top-right menu and go to Settings </li> <li>Navigate to Advanced</li> <li>Scroll down to Preferred Ledger Connection Type and select WebHID from the dropdown</li> </ol> <p>Note</p> <p>The Preferred Ledger Connection Type setting is only available on Chrome and Chrome-based browsers. This setting doesn't exist on other browsers such as Firefox.</p> <p>If MetaMask was able to connect successfully to your Ledger device, you should see a list of five Moonbeam/Ethereum-styled accounts. If not, double-check that Ledger Live is closed, you've connected your Ledger device to the computer, unlocked it, and have the Moonbeam app open.</p>"},{"location":"tokens/connect/ledger/moonbeam/#import-accounts-and-view-balances","title":"Import Accounts and View Balances","text":"<p>From the list of accounts, take the following steps:</p> <ol> <li>Select the accounts you would like to import from your Ledger device</li> <li>Click on Unlock</li> </ol> <p></p> <p>If you've imported your Ledger account successfully, you should see your account and balance displayed in the main MetaMask screen like shown in the following image:</p> <p></p> <p>You can switch accounts in MetaMask at any time to view the balance of your other imported Ledger accounts.</p> <p>You've now successfully imported a Moonbeam compatible account from your Ledger device and are now ready to start interacting with your Ledger device.</p>"},{"location":"tokens/connect/ledger/moonbeam/#receive-tokens","title":"Receive Tokens","text":"<p>To get started interacting with your Ledger device, you will need to send some funds to it. Copy your address from MetaMask by clicking on your account name and address in MetaMask.</p> <p></p> <p>Next, you will need to obtain some GLMR tokens and using the address you just copied, send the tokens to your account. After the transaction has successfully gone through, you will see your balance update.</p>"},{"location":"tokens/connect/ledger/moonbeam/#send-tokens","title":"Send Tokens","text":"<p>Next up is sending and signing transactions on Moonbeam using your Ledger device. To get started sending a transaction, click on the Send button:</p> <p></p> <p>As you would in a standard transaction, set the recipient address, enter the number of tokens to send, review transaction details and confirm it. This will initiate the transaction signature wizard in your Ledger device. Here, take the following steps:</p> <ol> <li>Click the button to proceed to the next screen. Your Ledger device is only warning you to review the transaction</li> <li>Check the number of tokens being sent then proceed to the next screen</li> <li>Check the recipient's address and proceed to the next screen</li> <li>Check the max fees applicable to this transaction. This is the gas price multiplied by the gas limit you've set on MetaMask. When ready, proceed to the next screen</li> <li>If you agree with all the transaction details, approve it. This will sign the transaction and will trigger MetaMask to send it. If you don't agree with all the transaction details, reject it. This will cancel the transaction, and MetaMask will mark it as failed</li> </ol> <p></p> <p>Right after you've approved the transaction, MetaMask sends it to the network. Once the transaction is confirmed, it will be displayed as Send on the Activity tab in MetaMask.</p> <p></p> <p>And that is it! You've signed a transaction and sent some GLMR tokens using your Ledger hardware wallet!</p>"},{"location":"tokens/connect/ledger/moonbeam/#interact-with-contracts-using-your-ledger","title":"Interact with Contracts Using your Ledger","text":"<p>By default, Ledger devices don't admit a <code>data</code> field in the transaction object. Consequently, users can't deploy or interact with smart contracts.</p> <p>However, if you want to use your Ledger hardware wallet for transactions related to smart contracts, you need to change a configuration parameter inside the app on your device. To do so, take the following steps:</p> <ol> <li>On your Ledger, open the Moonriver or Ethereum app</li> <li>Navigate to Settings</li> <li>Find the Blind signing page. It should state NOT Enabled at the bottom</li> <li>Select/validate the option to change its value to Enabled</li> </ol> <p>Note</p> <p>This option is necessary to use your Ledger device to interact with ERC-20 token contracts that might live inside the Moonbeam ecosystem.</p> <p></p>"},{"location":"tokens/connect/ledger/moonbeam/#use-ledger-live","title":"Use Ledger Live to Send &amp; Receive GLMR","text":"<p>You can also use your Ledger device to send and receive GLMR tokens securely from within Ledger Live. This enables you to manage your GLMR tokens without connecting your device to MetaMask.</p> <p>When you open up the Ledger Live app, make sure that you've installed the latest updates. If there are any pending updates that need to be installed, there will be a banner at the top of the screen that prompts you to install the updates.</p> <p>To get started, you'll need to login to your Ledger device to unlock it. From Ledger Live, click on My Ledger. On your device, you'll be prompted to allow Ledger manager; you can click both buttons on your device to allow it.</p> <p>Once on the Ledger manager, you'll need to make sure that your firmware is up to date, and if the Moonbeam and/or Ethereum apps need to be updated, go ahead and install the latest versions.</p> <p>Next, you'll need to add an account to your Ledger Live app. To do so, you can take the following steps:</p> <ol> <li>Click on Accounts from the left-side menu</li> <li>Select Add account</li> <li>A dropdown will appear. Search for GLMR and Moonbeam (GLMR) should appear for you to select</li> <li>Click Continue</li> </ol> <p></p> <p>Next, you'll be able to enter an account name and click Add account. If your account was successfully added, you can click Done and your account will appear in your list of accounts.</p>"},{"location":"tokens/connect/ledger/moonbeam/#receive-tokens_1","title":"Receive Tokens","text":"<p>To receive GLMR to your Ledger device, you can take the following steps from Ledger Live:</p> <ol> <li>Click on Receive from the left-side menu</li> <li>A pop-up will appear. You can select your Moonbeam account where you want to receive tokens from the Account to credit dropdown</li> <li>Click Continue</li> </ol> <p></p> <p>Next, your address should appear on Ledger Live, and you'll be prompted to verify your address on your Ledger device. On your device, you can take the following steps:</p> <ol> <li>You should see Verify Address on your device's screen. Click the right button to start verifying your address</li> <li>On the next screen, you should see your address. Compare the address on your device to the one displayed on Ledger Live and verify it matches. At this time, you'll want to copy the address from Ledger Live so you can send a transaction to it. Click the right button to continue</li> <li>Now, you should see the Approve screen. If the addresses match, you can click both buttons on your device to approve the verification. Otherwise, click the right button again to get to the Reject screen where you can click both buttons to reject the verification</li> </ol> <p></p> <p>Over on Ledger Live, you'll see that your address has been shared securely, and you can click Done. Now, you can send some GLMR to your Ledger account.</p>"},{"location":"tokens/connect/ledger/moonbeam/#send-tokens_1","title":"Send Tokens","text":"<p>To send GLMR from your Ledger device, you can take the following steps from Ledger Live:</p> <ol> <li>Click on Send from the left-side menu</li> <li>A pop-up will appear. From the Account to debit dropdown, you can select your Moonbeam account that you want to send tokens from</li> <li>Enter an address in the Receipient address field</li> <li>Click Continue</li> </ol> <p></p> <p>On the next screen, you can enter the amount of GLMR that you would like to send and click Continue.</p> <p></p> <p>The last step on Ledger Live is to verify that the transaction details are correct. If everything looks good, you can click Continue. Then you'll be prompted to confirm the transaction on your Ledger device:</p> <ol> <li>The first screen will be the Review transaction screen. Click the right button to proceed to the next screen</li> <li>Verify the amount of GLMR you're sending and click the right button to proceed</li> <li>Verify the address you're sending the GLMR to and click the right button to proceed</li> <li>The Network screen should show Moonbeam. Click the right button to proceed</li> <li>Review the Max Fees and click the right button to proceed</li> <li>If everything looks good, you can click both buttons to Accept and send the transaction. Otherwise, you can click the right button to get to the Reject screen where you can click both buttons to reject the transaction</li> </ol> <p></p> <p>On Ledger Live, you should see that your transaction was sent, and you can view the details of the transaction. Once the transaction has been confirmed, your GLMR balance will update.</p> <p>And that is it! You've successfully used the Moonbeam Ledger Live integration to receive and send tokens with your Ledger device directly from Ledger Live!</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/ledger/moonriver/","title":"Interacting with Moonriver Using Ledger and the Moonriver App","text":""},{"location":"tokens/connect/ledger/moonriver/#introduction","title":"Introduction","text":"<p>Hardware wallets provide a safer way to store crypto funds because the private key (used for signing transactions) is stored offline. Ledger offers two hardware wallet solutions at the time of writing: Ledger Nano S and Ledger Nano X.</p> <p>You can interact with Moonriver using your Ledger hardware wallet through the Moonriver Ledger Live app. With the dedicated Moonriver app, you do not have to worry about setting the chain ID and you know you are connected to the right network. Please note that you can only use the Moonriver app to connect to the Moonriver network, it cannot be used to connect to other Moonbeam-based networks.</p> <p>You also have the option of using the Ethereum app to connect to Moonriver. The main difference between using the Moonriver and the Ethereum app is that you have to specify the chain ID when you use the Ethereum app, which is 1285 for Moonriver. If you're interested in using the Ethereum app on Moonriver instead, you can check out the Interacting with Moonbeam Using Ledger and the Ethereum App guide.</p> <p>In this tutorial, you will learn how to get started with your Ledger hardware wallet on Moonriver using the Moonriver app. This guide only illustrates the steps for a Ledger Nano X device, but you can follow along with a Ledger Nano S as well.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/ledger/moonriver/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before you get started, update Ledger Live to the latest version available. Also, make sure you've your Ledger hardware wallet device running the latest firmware. The Ledger support website offers tutorials on how to update the firmware.</p> <p>At the time of writing, the following versions were used:</p> <ul> <li>Ledger Live 2.35.1</li> <li>Ledger Nano S firmware v2.0.0</li> <li>Ledger Nano X firmware v2.0.1</li> </ul> <p>In addition, you'll need MetaMask as an intermediary between your Ledger device and Moonbeam. Make sure that your MetaMask is connected to Moonbeam.</p> <p>As of MetaMask version 10.5.0, connecting your Ledger device with MetaMask on Chrome is easy again. You just need to have the latest version of MetaMask installed.</p>"},{"location":"tokens/connect/ledger/moonriver/#install-the-moonriver-ledger-live-app","title":"Install the Moonriver Ledger Live App","text":"<p>The Moonriver app is dependent on the Ethereum app, so first you will need to install the Ethereum app. Once the Ethereum app is installed you will be able to install the Moonriver app without a problem. Please note that the Moonriver app is only for the Moonriver network, it will not work for Moonbeam or Moonbase Alpha.</p> <p>To get started, open up Ledger Live and:</p> <ol> <li>Select Manager from the menu</li> <li>Connect and unlock your device (this must be done before installation)</li> <li>In the App catalog search for Ethereum (ETH) and click Install. Your Ledger device will show Processing and once the installation is complete, the app will appear on your Ledger device</li> <li>Search for Moonriver (MOVR) in the App catalog and click Install. Again, your Ledger device will show Processing and once complete, the Moonriver app will appear on your Ledger device</li> </ol> <p>In the Ledger Live app, you should see the Ethereum and Moonriver app listed under the Apps installed tab on the Manager page. After the apps have been successfully installed, you can close out of Ledger Live.</p> <p></p>"},{"location":"tokens/connect/ledger/moonriver/#import-your-ledger-account-to-metamask","title":"Import your Ledger Account to MetaMask","text":"<p>Now that you've installed the Ledger Live apps, you can connect your Ledger to the computer, unlock it, and open the Moonriver app.</p> <p>Then import your Ledger account to MetaMask using the following steps:</p> <ol> <li>Click on the top-right logo to expand the menu</li> <li>Select Connect Hardware Wallet</li> </ol> <p></p> <p>In the next screen, you are prompted to select which hardware wallet you'll like to use in MetaMask. At the moment of writing, only Ledger and Trezor hardware wallets are supported. Here, take the following steps:</p> <ol> <li>Select the Ledger logo</li> <li>Click on Continue</li> </ol> <p></p> <p>If you're using Chrome or a Chrome-based browser like Brave, you'll be prompted to select your Ledger device to connect via WebHID:</p> <ol> <li>Select your Ledger device from the pop-up</li> <li>Click Connect</li> </ol> <p></p> <p>If a pop-up doesn't appear, you may need to change your MetaMask settings to enable a WebHID connection. You can check and update your MetaMask settings by following these steps:</p> <ol> <li>Expand the top-right menu and go to Settings </li> <li>Navigate to Advanced</li> <li>Scroll down to Preferred Ledger Connection Type and select WebHID from the dropdown</li> </ol> <p>Note</p> <p>The Preferred Ledger Connection Type setting is only available on Chrome and Chrome-based browsers. This setting doesn't exist on other browsers such as Firefox.</p> <p>If MetaMask was able to connect successfully to your Ledger device, you should see a list of five Moonriver/Ethereum-styled accounts. If not, double-check that Ledger Live is closed, you've connected your Ledger device to the computer, unlocked it, and have the Moonriver app open.</p>"},{"location":"tokens/connect/ledger/moonriver/#import-accounts-and-view-balances","title":"Import Accounts and View Balances","text":"<p>From the list of accounts, take the following steps:</p> <ol> <li>Select the accounts you would like to import from your Ledger device</li> <li>Click on Unlock</li> </ol> <p></p> <p>If you've imported your Ledger account successfully, you should see your account and balance displayed in the main MetaMask screen like shown in the following image:</p> <p></p> <p>You can switch accounts in MetaMask at any time to view the balance of your other imported Ledger accounts.</p> <p>You've now successfully imported a Moonriver compatible account from your Ledger device and are now ready to start interacting with your Ledger device.</p>"},{"location":"tokens/connect/ledger/moonriver/#receive-tokens","title":"Receive Tokens","text":"<p>To get started interacting with your Ledger device, you will need to send some funds to it. Copy your address from MetaMask by clicking on your account name and address in MetaMask.</p> <p></p> <p>Next, you will need to obtain some MOVR tokens and using the address you just copied, send the tokens to your account. After the transaction has successfully gone through, you will see your balance update.</p>"},{"location":"tokens/connect/ledger/moonriver/#send-tokens","title":"Send Tokens","text":"<p>Next up is sending and signing transactions on Moonriver using your Ledger device. To get started sending a transaction, click on the Send button:</p> <p></p> <p>As you would in a standard transaction, set the recipient address, enter the number of tokens to send, review transaction details and confirm it. This will initiate the transaction signature wizard in your Ledger device. Here, take the following steps:</p> <ol> <li>Click the button to proceed to the next screen. Your Ledger device is only warning you to review the transaction</li> <li>Check the number of tokens being sent then proceed to the next screen</li> <li>Check the recipient's address and proceed to the next screen</li> <li>Check the max fees applicable to this transaction. This is the gas price multiplied by the gas limit you've set on MetaMask. When ready, proceed to the next screen</li> <li>If you agree with all the transaction details, approve it. This will sign the transaction and will trigger MetaMask to send it. If you don't agree with all the transaction details, reject it. This will cancel the transaction, and MetaMask will mark it as failed</li> </ol> <p></p> <p>Right after you've approved the transaction, MetaMask sends it to the network. Once the transaction is confirmed, it will be displayed as Send on the Activity tab in MetaMask.</p> <p></p> <p>And that is it! You've signed a transaction and sent some MOVR tokens using your Ledger hardware wallet!</p>"},{"location":"tokens/connect/ledger/moonriver/#interact-with-contracts-using-your-ledger","title":"Interact with Contracts Using your Ledger","text":"<p>By default, Ledger devices don't admit a <code>data</code> field in the transaction object. Consequently, users can't deploy or interact with smart contracts.</p> <p>However, if you want to use your Ledger hardware wallet for transactions related to smart contracts, you need to change a configuration parameter inside the app on your device. To do so, take the following steps:</p> <ol> <li>On your Ledger, open the Moonriver or Ethereum app</li> <li>Navigate to Settings</li> <li>Find the Blind signing page. It should state NOT Enabled at the bottom</li> <li>Select/validate the option to change its value to Enabled</li> </ol> <p>Note</p> <p>This option is necessary to use your Ledger device to interact with ERC-20 token contracts that might live inside the Moonbeam ecosystem.</p> <p></p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/governance/proposals/","title":"How to Propose an Action in OpenGov (Governance v2)","text":""},{"location":"tokens/governance/proposals/#introduction","title":"Introduction","text":"<p>A proposal is a submission to the chain in which a token holder suggests for an action to be enacted by the system. Proposals are one of the core elements of the governance system because they are the main tool for community members to propose actions/changes, which other token holders then vote on.</p> <p>In Moonbeam, users are able to create and vote on proposals using their H160 address and private key, that is, their regular Ethereum account!</p> <p>This guide will outline the process, with step-by-step instructions, of how to submit a proposal for other token holders to vote on in OpenGov (Governance v2). This guide will show you how to submit the proposal on Moonbase Alpha, but it can be easily adapted for Moonbeam and Moonriver. There is a separate guide on How to Vote on a Proposal in OpenGov.</p> <p>For more information on Moonbeam's governance system, please refer to the Governance on Moonbeam overview page.</p>"},{"location":"tokens/governance/proposals/#definitions","title":"Definitions","text":"<p>Some of the key parameters for this guide are the following:</p> <ul> <li>Proposal \u2014 an action or item, defined by the preimage hash, being proposed by a token holder and open for consideration and discussion by token holders</li> <li> <p>Referendum \u2014 a proposal that is up for token-holder voting. Each referendum is tied to a specific proposal for a change to the Moonbeam system including values for key parameters, code upgrades, or changes to the governance system itself</p> </li> <li> <p>Preimage hash \u2014 hash of the proposal to be enacted. The first step to make a proposal is to submit a preimage. The hash is just its identifier. The proposer of the preimage can be different than the user that proposes that preimage as a formal proposal</p> </li> <li> <p>Preimage deposit \u2014 amount of tokens that the proposer needs to bond when submitting a preimage. It is calculated as the sum of a base deposit per network plus a fee per byte of the preimage being proposed</p> </li> <li> <p>Submission Deposit - the minimum deposit amount for submitting a public referendum proposal</p> </li> <li> <p>Lead-in Period \u2014 the initial proposal voting and discussion period. At this stage, proposals are in an undecided state until they pass some criteria for the given Track. The criteria include:</p> <ul> <li>Prepare Period \u2014 the minimum time the referendum needs to wait before it can progress to the next phase after submission</li> <li>Capacity \u2014 limit for the number of referenda on a given Track that can be decided at once</li> <li>Decision Deposit \u2014 the minimum deposit amount required for a referendum to progress to the decision phase after the end of the Lead-in Period. Since each Track has a defined Capacity, this deposit is larger than the submission deposit, and its goal is to mitigate spam </li> </ul> </li> </ul> <p>Make sure you check the Governance Parameters for each network and track.</p>"},{"location":"tokens/governance/proposals/#roadmap-of-a-proposal","title":"Roadmap of a Proposal","text":"<p>This guide will cover the first few steps outlined in the proposal roadmap, as highlighted in the diagram below. You'll learn how to submit your proposal idea to the Moonbeam Community Forum, submit a preimage, and submit your proposal on-chain using the preimage hash.</p> <p>You can find a full explanation in the Roadmap of a Proposal section on the Governance overview page.</p> <p></p>"},{"location":"tokens/governance/proposals/#submitting-your-idea-to-the-forum","title":"Submit your Idea to the Community Forum","text":"<p>Before diving into the steps for submitting a proposal, you'll want to get familiar with Moonbeam's Community Forum. It's highly recommended that you preface any proposal with a post on the forum to solicit feedback. You should allow a period of five days for the community to discuss and provide feedback on the Moonbeam Forum post before proceeding to submit the preimage and proposal.</p> <p>To access the Moonbeam Community Forum, you must be a member of the Moonbeam Discord community. You can then sign up to get access to the forum using your Discord credentials.</p> <p>Once you\u2019re logged in, you can explore the latest discussions, join conversations, and create your own discussion for a proposal idea you may have. Before posting or commenting for the first time, be sure to familiarize yourself with the FAQ to learn about the community guidelines.</p> <p></p> <p>When you're ready to create a post with the details of your proposal, you can head to the Governance page and click on Democracy Proposals.</p> <p></p> <p>From there, you can click on Open Draft and begin to draft your proposal using the template provided. Make sure to update the title of the post and add any of the optional tags, such as Moonbeam if the proposal is for the Moonbeam network. The title should follow the format as the pre-populated title: [Proposal: XX][Status: Idea] proposal title. For example, [Proposal: XX][Status: Idea] Register XC-20 xcMYTOK. The XX will need to be updated with the proposal ID once the proposal has been formally submitted on-chain.</p> <p></p> <p>After you've filled out your proposal details, you can click Create Topic to save it to the forum and open the discussion on your idea. Based on the feedback you receive, you can update the proposal before proceeding to submit it.</p>"},{"location":"tokens/governance/proposals/#proposing-an-action","title":"Proposing an Action","text":"<p>This section goes over the process of creating a proposal with OpenGov (Governance v2) on Moonbase Alpha. These steps can be adapted for Moonbeam and Moonriver.</p> <p>To make a proposal in the network, you can use the Polkadot.js Apps interface. To do so, you need to import an Ethereum-style account first (H160 address), which you can do following the Creating or Importing an H160 Account guide. For this example, three accounts were imported and named with super original names: Alice, Bob, and Charlie.</p> <p></p> <p>For the proposal, you can choose anything you would like to propose, just make sure that you assign it to the right Origin and Track, so that it has the right privileges to execute the action.</p> <p>For the purposes of this guide, the action will be to set an on-chain remark using the General Admin Origin and Track.</p>"},{"location":"tokens/governance/proposals/#submitting-a-preimage-of-the-proposal","title":"Submitting a Preimage of the Proposal","text":"<p>The first step is to submit a preimage of the proposal. This is because the storage cost of large preimages can be pretty hefty, as the preimage contains all the information regarding the proposal itself. With this configuration, one account with more funds can submit a preimage and another account can submit the proposal.</p> <p>First, navigate to Moonbase Alpha's Polkadot.js Apps interface. Everything related to governance lives under the Governance tab, including preimages. So, from the Governance dropdown, you can select Preimages. Once there, click on the Add preimage button.</p> <p></p> <p>Here, you need to provide the following information:</p> <ol> <li>Select the account from which you want to submit the preimage</li> <li>Choose the pallet you want to interact with and the dispatchable function (or action) to propose. The action you choose will determine the fields that need to fill in the following steps. In this case, it is the system pallet and the remark extrinsic</li> <li>Enter any additional fields required for the extrinsic to be dispatched. For this example, you can enter the remark in hex or ascii format</li> <li>Copy the preimage hash. This represents the proposal. You will use this hash when submitting the actual proposal</li> <li>Click the Submit preimage button and sign the transaction</li> </ol> <p></p> <p>Note</p> <p>Make sure you copy the preimage hash, as it is necessary to submit the proposal.</p> <p>Note that the storage cost of the preimage can be calculated as the base fee (per network) plus the fee per byte of the preimage being proposed.</p> <p>After the transaction is submitted, you will see some confirmations on the top right corner of the Polkadot.js Apps interface and the preimage will be added to the list of preimages.</p>"},{"location":"tokens/governance/proposals/#submitting-a-proposal-v2","title":"Submitting a Proposal","text":"<p>Once you have committed the preimage (check the previous section), the roadmap's next major milestone is to submit the proposal related to it. To do so, select Referenda from the Governance dropdown, and click on Submit proposal.</p> <p>In order to submit a proposal, you'll need to choose which Origin class you want your proposal to be executed with. Choosing the wrong Track/Origin might result in your proposal failing at execution. For more information on each Origin class, please refer to the General Definitions section on the Governance on Moonbeam overview page.</p> <p></p> <p>Here, you need to provide the following information:</p> <ol> <li>Select the account from which you want to submit the proposal (in this case, Alice)</li> <li>Choose the Track to submit the proposal to. The Origin associated with the Track will need to have enough authority to execute the proposed action. For this example, to add an on-chain remark, you can select 2 / General Admin from the submission track dropdown</li> <li>In the origin dropdown, choose Origins</li> <li>In the Origins dropdown, select the Origin, which in this case is GeneralAdmin</li> <li>Enter the preimage hash related to the proposal. In this example, it is the hash of the <code>system.remark</code> preimage from the previous section</li> <li>Choose the moment of enactment, either after a specific number of blocks, or at a specific block. It must meet the minimum Enactment Period, which you can find in OpenGov's Governance Parameters</li> <li>Enter the number of blocks or the specific block to enact the proposal at</li> <li>Click Submit proposal and sign the transaction</li> </ol> <p></p> <p>Note</p> <p>Tokens might be locked for an indeterminate amount of time because it is unknown when a proposal may become a referendum (if ever).</p> <p>After the transaction is submitted, you will see some confirmations on the top right corner of the Polkadot.js Apps interface. You should also see the proposal listed in the associated Origin section, displaying the proposed action, proposer, and more.</p> <p>If you login to Polkassembly with the same account that you used to create the proposal, you'll be able to edit the description of the proposal to include a link to the proposal discussion on the Moonbeam Community Forum. This is a helpful step because while Polkassembly auto-generates a post for each proposal, it doesn't provide context information on the contents of the proposal.</p> <p>The proposal is now in the Lead-in Period and is ready to be voted on! In order for your proposal to progress out of the Lead-in Period to the next phase, at a minimum the Prepare Period will need to pass so there is enough time for the proposal to be discussed, there will need to be enough Capacity in the chosen Track, and the Decision Deposit will need to be submitted. The deposit can be paid by any token holder. If there isn't enough Capacity or the Decision Deposit hasn't been submitted, but the Prepare Period has passed, the proposal will remain in the Lead-in Period until all of the criteria is met.</p> <p>To learn how to vote on a proposal, please refer to the How to Vote on a Proposal in OpenGov guide.</p>"},{"location":"tokens/governance/treasury-spend/","title":"How to Propose a Treasury Spend","text":""},{"location":"tokens/governance/treasury-spend/#introduction","title":"Introduction","text":"<p>Treasury spending proposals enable community members to request funding for projects that benefit the Moonbeam network, such as infrastructure improvements, resources, events, and ecosystem tools. The Treasury Council reviews proposals and weighs community feedback received in the Moonbeam Forum. However, the ultimate Aye/Nay decision rests with the Council. For more information about the structure of the Treasury Council, see the Treasury page.</p> <p>In this guide, you'll learn how to prepare and submit a Treasury spending proposal and understand the full lifecycle of a Treasury proposal. </p>"},{"location":"tokens/governance/treasury-spend/#definitions","title":"Definitions","text":"<p>Some of the key parameters for this guide are the following:</p> <ul> <li>Treasury address \u2014 the address where Treasury funds accrue and are disbursed from</li> <li>Beneficiary \u2014 the address, such as a Moonbeam Safe multisig, that will receive the funds of the Treasury proposal if enacted</li> <li>Value \u2014 the amount that is being asked for and will be allocated to the beneficiary address if the Treasury proposal is passed</li> </ul>"},{"location":"tokens/governance/treasury-spend/#treasury-addresses","title":"Treasury Addresses","text":"<p>The Treasury address for each respective network can be found below:</p> MoonbeamMoonriverMoonbase Alpha <p>0x6d6F646c70632f74727372790000000000000000</p> <p>0x6d6f646C70792f74727372790000000000000000</p> <p>0x6d6F646c70632f74727372790000000000000000</p>"},{"location":"tokens/governance/treasury-spend/#roadmap-of-a-treasury-proposal","title":"Roadmap of a Treasury Proposal","text":"<p>The happy path of a Treasury spend request is as follows:</p> <ol> <li> <p>Proposal submission - the user submits a proposal to the Moonbeam Forum</p> </li> <li> <p>Forum discussion - the proposal is discussed by the community on the Forum. The ultimate Aye/Nay decision is determined by the Treasury council</p> </li> <li> <p>Treasury approval and action - if the Treasury Council agrees, it authorizes the Treasury spending and moves the process forward</p> </li> </ol> <p></p>"},{"location":"tokens/governance/treasury-spend/#submitting-your-idea-to-the-forum","title":"Submit Your Idea to the Forum","text":"<p>As mentioned in the happy path above, the first step of a Treasury proposal is to submit the proposal to the Moonbeam Forum. You'll need to have an account on the Moonbeam Forum and be logged in before submitting a Treasury spend proposal. To submit a Treasury spend proposal, follow these steps:</p> <ol> <li>From the Governance section, click New Topic. By starting the topic in the Governance section, the proposal will come pre-filled with a template to ensure you cover all the necessary points </li> <li>Provide a title for the proposal</li> <li>Enter the contents of the proposal, covering: the Title and Proposal Status, a brief Abstract, the Motivation, a Project Overview and Team Experience, the Rationale, any Key Terms, the Overall Cost, the Use of Treasury Funds, the Technical Specifications, and the Steps to Implement</li> <li>Choose either Moonbeam or Moonriver as a tag to indicate which network your Treasury proposal applies to</li> <li>Press Create Topic</li> </ol> <p></p>"},{"location":"tokens/governance/treasury-spend/#next-steps","title":"Next Steps","text":"<p>No further steps are required after proposing the spend. Members of the Treasury Council will complete all on-chain actions. If approved by the Treasury Council, the delivery of the Treasury payment to the designated beneficiary will happen automatically. For more information about the Treasury Council voting process, see the Treasury page.</p>"},{"location":"tokens/governance/voting/","title":"How to Vote on a Proposal in Governance v2: OpenGov","text":""},{"location":"tokens/governance/voting/#introduction","title":"Introduction","text":"<p>Referenda are simple, inclusive, and stake-based voting schemes. Each referendum has a proposal associated with it that suggests an action to take place. In OpenGov, each referendum will have a specified Origin class that the proposal will be executed with, and each Origin has its own Track that proposals will process through. Although referenda are completed by a common process, the requirements for approval are Track-specific.</p> <p>Token holders can vote on referenda using their own tokens, including those that are locked in staking. The weight of a vote is defined by two factors: the number of tokens locked and the lock duration (called Conviction). This is to ensure that there is an economic buy-in to prevent vote-selling. Consequently, the longer you are willing to lock your tokens, the stronger your vote will be weighted. You also have the option of not locking tokens at all, but the vote weight is drastically reduced.</p> <p>In Moonbeam, users are able to create and vote on proposals using their H160 address and private key, that is, their regular Ethereum account!</p> <p>This guide will outline the process, with step-by-step instructions, of how to vote on referenda in Governance v2: OpenGov. This guide will show you how to vote on Moonbase Alpha, but it can be easily adapted for Moonbeam and Moonriver.</p> <p>Note</p> <p>This page goes through the mechanics of how to vote at a more technical level. Token holders can leverage platforms such as Polkassembly to vote using a more friendly user interface.</p>"},{"location":"tokens/governance/voting/#definitions","title":"Definitions","text":"<p>Some of the key parameters for this guide are the following:</p> <ul> <li> <p>Voting \u2014 a mechanism for token holders to support (Aye), oppose (Nay), or remain neutral (Abstain) on a proposal. For Aye and Nay, the voting weight is determined by both the number of tokens locked and the lock duration (Conviction). Abstain votes do not receive additional weighting</p> <ul> <li>Conviction \u2014 the time that token holders voluntarily lock their tokens when voting; the longer they are locked, the more weight their vote has</li> <li>Lock balance \u2014 the number of tokens that a user commits to a vote (note, this is not the same as a user's total account balance) Moonbeam uses the concept of voluntary locking, which allows token holders to increase their voting power by locking tokens for a longer period of time. Specifying no Lock Period means a user's vote is valued at 10% of their lock balance. Specifying a greater Conviction increases voting power. For each increase in Conviction (vote multiplier), the Lock Periods double</li> </ul> </li> <li> <p>Maximum number of votes \u2014 the maximum number of concurrent votes per account</p> MoonbeamMoonriverMoonbase Alpha <pre><code>512 votes\n</code></pre> <pre><code>512 votes\n</code></pre> <pre><code>512 votes\n</code></pre> </li> <li> <p>Approval \u2014 minimum \"Aye\" votes as a percentage of overall Conviction-weighted votes needed for approval</p> </li> <li> <p>Support \u2014 the minimum portion of Aye and Abstain votes (ignoring conviction) needed as a percentage of the total active supply for a proposal to pass. Nay votes do not count toward Support</p> </li> <li> <p>Lead-in Period \u2014 the initial proposal voting and discussion period. At this stage, proposals are in an undecided state until they pass some criteria for the given Track. The criteria include:</p> <ul> <li>Prepare Period \u2014 the minimum time the referendum needs to wait before it can progress to the next phase after submission</li> <li>Capacity \u2014 limit for the number of referenda on a given Track that can be decided at once</li> <li>Decision Deposit \u2014 the minimum deposit amount required for a referendum to progress to the decision phase after the end of the Lead-in Period. Since each Track has a defined Capacity, this deposit is larger than the submission deposit, and its goal is to mitigate spam </li> </ul> </li> <li> <p>Decide Period - token holders continue to vote on the referendum. If a referendum does not pass by the end of the period, it will be rejected, and the Decision Deposit will be refunded</p> </li> <li>Confirm Period - a period of time within the Decide Period where the referendum needs to have maintained enough Approval and Support to be approved and move to the Enactment Period</li> <li> <p>Enactment Period - a specified time, which is defined at the time the proposal was created, that meets at least the minimum amount of time that an approved referendum waits before it can be dispatched</p> </li> <li> <p>Vote Delegation \u2014 a voter can give their voting power, including Conviction voting, to another token holder (delegate), who may be more knowledgeable and able to make specific decisions</p> </li> <li>Multirole Delegation \u2014 the ability to delegate voting power on a Track-by-Track basis, where a token holder can specify different delegates for each Track</li> </ul> <p>For an overview of the Track-specific parameters such as the length of the Decide, Confirm, and Enactment Period, the Approval and Support requirements, and more, please refer to the Governance Parameters for OpenGov (Governance v2) section of the governance overview page.</p>"},{"location":"tokens/governance/voting/#roadmap-of-a-proposal","title":"Roadmap of a Proposal","text":"<p>This guide will cover how to vote on public referenda, as seen in the steps highlighted in the proposal roadmap diagram below. In addition to learning how to vote on referenda, you'll also learn how the proposal progresses through the Lead-in Period, the Decide and Confirm Period, and the Enactment Period.</p> <p>You can find a full explanation of the happy path for an OpenGov proposal on the Governance overview page.</p> <p></p>"},{"location":"tokens/governance/voting/#forum-discussion","title":"Forum Discussion","text":"<p>A vote on a democracy referendum is a binary outcome. However, a token holder's opinion is often more nuanced than yes or no, which is why it's strongly recommended that you preface any proposal with a post on Moonbeam's Community Forum.</p> <p>The forum serves the critical role of providing a platform for discussion and allowing proposers to receive feedback from the community prior to an on-chain action. Creating a post on the forum is quick and easy, as shown in the Using the Moonbeam Community Forum guide. There are categories corresponding to each type of proposal, including democracy, treasury, and grant proposals. While this step is optional, explaining the details of the proposal and following up with any questions raised may increase the chances of the initiative being accepted and subsequently passed by the community.</p> <p></p>"},{"location":"tokens/governance/voting/#voting-on-a-referendum","title":"Voting on a Referendum","text":"<p>This section goes over the process of voting on a public referendum in OpenGov (Governance v2) on Moonbase Alpha. These steps can be adapted for Moonbeam and Moonriver. The guide assumes that there is one already taking place. If there is an open referendum that you want to vote on, you can adapt these instructions to learn how to vote on it.</p> <p>To vote on a proposal on the network, you need to use the Polkadot.js Apps interface. To do so, you need to import an Ethereum-style account first (H160 address), which you can do by following the Creating or Importing an H160 Account guide. For this example, three accounts were imported and named with super original names: Alice, Bob, and Charlie.</p> <p></p> <p>To get started, you'll need to navigate to Moonbase Alpha's Polkadot.js Apps interface. Everything related to governance lives under the Governance tab. To view all of the referenda, you can choose Referenda from the Governance dropdown. On the Referenda page, you'll see a list of referenda organized by Track. To view the details of a specific referendum, you can click on the arrow next to the description. The number next to the action and description is called the referendum index.</p>"},{"location":"tokens/governance/voting/#submit-decision-deposit","title":"How to Support a Proposal by Contributing to the Decision Deposit","text":"<p>In order for a referendum to move out of the Lead-in Period into the Decide Period, the Decision Deposit must be submitted. This deposit can be submitted by the author of the proposal or any other token holder. The deposit varies depending on the Track of the proposal.</p> <p>For example, a referendum that is in the General Admin Track has a Decision Deposit of 500 on Moonbase Alpha.</p> <p>From the list of referenda on Polkadot.js Apps, you may notice that some proposals are in the Preparing state. If a referendum requires the Decision Deposit to be submitted, you'll see a Decision deposit button. To submit the deposit, you can go ahead and click on this button.</p> <p></p> <p>Then take the following steps to submit the deposit from a specific account:</p> <ol> <li>Select the deposit from account. This account does not need to be the author of the proposal; it can be from any token holder. However, if the proposal is deemed malicious, the Decision Deposit will be burned. So, before placing the deposit, it is advised to do your due diligence to ensure the proposal is not malicious</li> <li>The referendum id and decision deposit fields will automatically be populated for you based on the referendum and Track it belongs to</li> <li>Click Place deposit and sign the transaction</li> </ol> <p></p> <p>Once the deposit has been placed, Polkadot.js Apps will update and display the account that paid the Decision Deposit along with the amount of the deposit. Now this referendum is one step closer to meeting the criteria of the Lead-in Period.</p> <p>If the Prepare Period has passed and there is enough space for a referendum in the General Admin Track, this proposal will move on to the Decide Period.</p>"},{"location":"tokens/governance/voting/#how-to-vote","title":"How to Vote","text":"<p>As you may have noticed, voting is not required in the Lead-in Period. However, it is essential in the Decide Period. The steps in this section will apply to referenda in both the Lead-in Period and the Decide Period.</p> <p>To vote and lock tokens either in favor of or against a referendum, you can get started by clicking on the Vote button next to the referendum you want to vote on.</p> <p></p> <p>Then you can take the following steps to fill in the details of the vote:</p> <ol> <li>Select the vote with account</li> <li>Choose how you would like to vote on the referendum. You can choose Aye in favor of the referendum, Nay in opposition to it, or Split if you want to specify an \"Aye\" vote value and a \"Nay\" vote value</li> <li>Enter the vote value</li> <li>Set the vote conviction, which determines the weight of your vote (<code>vote_weight = tokens * conviction_multiplier</code>). Please refer to the Conviction multiplier docs for more information</li> <li>Click Vote and sign the transaction</li> </ol> <p></p> <p>Note</p> <p>The lockup periods shown in the previous image are not to be taken as references as they are subject to change.</p> <p>To see how your vote and all of the other votes for a referendum impacted the Approval and Support curves, you can click on the arrow next to the Vote button. You'll notice there are two charts, one for each curve. If you hover over the charts, you can see the minimum Approval or Support required for a specific block along with the current Approval or Support.</p> <p></p> <p>A proposal in the General Admin Track on Moonbase Alpha would have the following characteristics:</p> <ul> <li>The Approval curve starts at 100% on Day 0 and goes to 80% on Day 4</li> <li>The Support curve starts at 50% on Day 0 and goes to 10% on Day 7</li> <li>A referendum starts the Decide Period with 0% \"Aye\" votes (nobody voted in the Lead-in Period)</li> <li>Token holders begin to vote, and the Approval increases to a value above 80% by Day 4</li> <li>If the Approval and Support thresholds are met for the duration of the Confirm Period (14400 blocks, approximately 1 day), the referendum is approved</li> <li>If the Approval and Support thresholds are not met during the Decision Period, the proposal is rejected. Note that the thresholds need to be met for the duration of the Confirm Period. Consequently, if they are met but the Decision Period expires before the completion of the Confirm Period, the proposal is rejected</li> </ul> <p>In the following image, you'll notice enough Approval and Support have been received, so the Confirm Period is underway. If the referendum maintains the Approval and Support levels, at block 124,962, the Confirm Period will end, and then the Enactment Period will begin. You can hover over the charts to find out more information on each of these periods. Assuming this referendum maintains the levels of Approval and Support it has received, the Enactment Period will end at block 132,262, and the proposal action will be dispatched.</p> <p></p> <p>If the referendum doesn't continuously receive enough Approval and Support during the Confirm Period, it still has a chance to pass as long as the Approval and Support requirements are met again and continuously for the duration of the Confirm Period. If a referendum enters the Confirm Period but the Decide Period is set to end before the Confirm Period is over, the Decide Period will actually be extended until the end of the Confirm Period. If the Decide Period ends and the referendum still hasn't received enough Approval and Support, the referendum will be rejected, and the Decision Deposit can be refunded.</p> <p>The Enactment Period is defined by the author of the proposal at the time it was initially submitted, but it needs to be at least the minimum Enactment Period.</p>"},{"location":"tokens/governance/voting/#delegate-voting","title":"Delegate Voting","text":"<p>Token holders have the option to delegate their vote to another account whose opinion they trust. The account being delegated does not need to take any particular action. When they vote, the vote weight (that is, tokens times the Conviction multiplier chosen by the delegator) is added to their vote.</p> <p>With the introduction of OpenGov (Governance v2), token holders can even delegate their vote on a Track-by-Track basis and specify different delegates for each Track, which is referred to as Multirole Delegation.</p> <p>From the referenda page on Polkadot.js Apps, you can click Delegate to get started.</p> <p></p> <p>Then you can take the following steps to fill in the details of the delegation:</p> <ol> <li>Enter the delegate from account, which should be the account that you wish to delegate your vote from</li> <li>Select the submission track or switch the apply delegation to all tracks slider to on if you want the other account to vote on your behalf on any of the Tracks</li> <li>Enter the delegated vote value</li> <li>Set the vote conviction, which determines the weight of your vote (<code>vote_weight = tokens * conviction_multiplier</code>). Please refer to the Conviction Multiplier docs for more information</li> <li>Click Next</li> <li>On the next screen, select the delegate to address, which should be the account that you wish to delegate your vote to</li> <li>Click Delegate and sign the transaction</li> </ol> <p></p> <p>Now the account you selected to delegate your vote to will be able to vote on your behalf. Once this account votes, the total vote weight delegated will be allocated to the option that the account selected. For this example, Baltahar can vote in favor of a referendum with a total weight of 20000 (10000 tokens with an x2 Conviction factor) using the vote weight that Charleth delegated to him.</p> <p>You can continue the above process for each Track and delegate a different account with varying vote weights.</p> <p>To undelegate a delegation, you'll need to head to the Developer tab and click on Extrinsics. From there, you can take the following steps:</p> <ol> <li>Select the account you have delegated from</li> <li>Choose the convictionVoting pallet and the undelegate extrinsic</li> <li>Enter the class of the Origin. For the General Admin Track, it is <code>2</code>. For a complete list of Track IDs, refer to the OpenGov section of the governance overview page</li> <li>Click Submit transaction and sign the transaction</li> </ol> <p></p>"},{"location":"tokens/governance/voting/#refund-the-decision-deposit","title":"Refunding the Decision Deposit","text":"<p>If a referendum has been approved or rejected, the Decision Deposit will be eligible to be refunded, as long as it was not rejected due to it being a malicious proposal. Malicious proposals will result in the Decision Deposit being slashed. Any token holder can trigger the refund of the deposit back to the original account that placed the deposit. To refund the deposit, you can take the following steps on the referenda page on Polkadot.js Apps. If the referendum is eligible and the deposit hasn't already been refunded, you'll see a Refund deposit button. So, you can go ahead and click that button to get started.</p> <p></p> <p>Then, to submit the refund transaction, you can:</p> <ol> <li>Choose the account for which you want to trigger the refund. This does not need to be the account that initially placed the deposit</li> <li>Click Refund deposit and sign the transaction</li> </ol> <p></p>"},{"location":"tokens/governance/voting/#unlocking-locked-tokens","title":"Unlocking Locked Tokens","text":"<p>When token holders vote, the tokens used are locked and cannot be transferred. You can verify if you have any locked tokens in the Accounts tab by expanding the address's account details. There, you will see different types of balances. If you have any tokens locked in referenda, you'll see referenda listed in your balance details, and you can hover over it to find out details about which referendum your tokens are locked for. Different lock statuses include:</p> <ul> <li>Locked because of an ongoing referendum, meaning that you've used your tokens and have to wait until the referendum finishes, even if you've voted with a no-lock Conviction factor</li> <li>Locked because of the Conviction multiplier selected, displaying the number of blocks and time left</li> <li>Lock expired, meaning that you can now get your tokens back</li> </ul> <p></p> <p>Once the lock has expired, you can request your tokens back. To do so, navigate to the Extrinsics menu under the Developers tab. Here, two different extrinsics need to be sent. First, you need to provide the following information:</p> <ol> <li>Select the account from which you want to recover your tokens</li> <li>Choose the pallet you want to interact with. In this case, it is the <code>convictionVoting</code> pallet and the extrinsic to use for the transaction. This will determine the fields that you need to fill in the following steps. In this case, it is <code>removeVote</code> extrinsic. This step is necessary to unlock the tokens. This extrinsic can also be used to remove your vote from a referendum</li> <li>Optionally, you can specify the Track ID to remove votes for. To do so, simply toggle the include option slider and enter the Track ID in the class u16 field</li> <li>Enter the referendum index. This is the number that appeared on the left-hand side of the Referenda tab</li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p> <p>For the next extrinsic, you need to provide the following information:</p> <ol> <li>Select the account from which you want to recover your tokens</li> <li>Choose the pallet you want to interact with. In this case, it is the <code>convictionVoting</code> pallet</li> <li>Choose the extrinsic method to use for the transaction. This will determine the fields that need to be filled out in the following steps. In this case, it is the <code>unlock</code> extrinsic</li> <li>Enter the Track ID to remove the voting lock for</li> <li>Enter the target account that will receive the unlocked tokens. In this case, the tokens will be returned to Alice</li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p> <p>Once the transaction goes through, the locked tokens should be unlocked. To double-check, you can go back to the Accounts tab and see that your full balance is now transferable.</p>"},{"location":"tokens/manage/identity/","title":"Managing your Account Identity","text":""},{"location":"tokens/manage/identity/#introduction","title":"Introduction","text":"<p>The Substrate Identity pallet is an out-of-the-box solution for adding personal information to your on-chain account. Personal information can include default fields such as your legal name, display name, website, Twitter handle, Riot (now known as Element) name. You can also take advantage of custom fields to include any other relevant information.</p> <p>Once your identity information is on-chain, you can request verification of your identity from a registrar. A registrar will perform proper due diligence to verify the submitted identity information and based on their findings will provide their judgement on-chain and a green check mark will appear next to your account.</p> <p>This guide will show you how to set an identity, clear it, and request judgement on the Moonbase Alpha TestNet. This guide can also be adapted to be used on Moonbeam and Moonriver.</p>"},{"location":"tokens/manage/identity/#general-definitions","title":"General Definitions","text":"<p>To store your information on-chain, you must bond some funds, which eventually will be returned once the identity has been cleared. There are two categories of fields: default and custom. If custom fields are used, you will be required to submit an additional deposit for each field.</p> <ul> <li> <p>Default fields include - your legal name, display name, website, Twitter handle, Riot (now known as Element) name</p> </li> <li> <p>Custom fields include - any other relevant information. For example, you could include your Discord handle</p> </li> </ul> MoonbeamMoonriverMoonbase Alpha Variable Definition Value Basic deposit The amount held on deposit for setting an identity 1.0258 GLMR Field deposit The amount held on deposit per additional field for setting an identity 0.0066 GLMR Max additional fields Maximum number of additional fields that may be stored in an ID 100 Variable Definition Value Basic deposit The amount held on deposit for setting an identity 1.0258 MOVR Field deposit The amount held on deposit per additional field for setting an identity 0.0066 MOVR Max additional fields Maximum number of additional fields that may be stored in an ID 100 Variable Definition Value Basic deposit The amount held on deposit for setting an identity 1.0258 DEV Field deposit The amount held on deposit per additional field for setting an identity 0.0066 DEV Max additional fields Maximum number of additional fields that may be stored in an ID 100"},{"location":"tokens/manage/identity/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For this guide, you will need the following:</p> <ul> <li>To connect to the Moonbase Alpha TestNet on the Polkadot.js Apps explorer. You can also follow along and adapt the instructions for Moonbeam or Moonriver.</li> <li>To create or import an account into Polkadot.js Apps</li> <li>Make sure you have funded your account.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"tokens/manage/identity/#get-started","title":"Get Started","text":"<p>There are a couple different ways to set and clear an identity using the Polkadot.js Apps, depending on the information to be included. If you intend to register your identity using only the default fields, you can follow the instructions for Managing an Identity via the Accounts UI. This is the recommended way to set and manage your identity.</p> <p>If you are looking for a more customizable experience and want to add custom fields beyond the default fields, you can follow the instructions for Managing an Identity via the Extrinsics UI.</p> <p>Note</p> <p>Please note that it is recommended to use the Accounts UI on Polkadot.js Apps to manage your identity as it provides an easy-to-use interface that enforces character limits. If you use the Extrinsics UI, please be aware that your input for each field (i.e, name, email, etc.) must be 32 characters or less, otherwise, your information will be cut off.</p>"},{"location":"tokens/manage/identity/#manage-via-accounts","title":"Manage an Identity via Accounts","text":""},{"location":"tokens/manage/identity/#set-identity-accounts","title":"Set an Identity","text":"<p>To get started with setting an identity using the Accounts UI, head to the Accounts tab on the Polkadot.js Apps explorer.</p> <p>You should already have an account connected, so you can go ahead and click on your account name to verify and take note of your balances. After you send the transaction to set an identity, the deposit(s) you submitted will be moved from your transferable balance to your reserved balance.</p> <p></p> <p>To set your identity, you'll need to:</p> <ol> <li>Click on the 3 vertical dots next to the account you would like to set an identity for</li> <li>A menu will pop up. Click Set on-chain identity</li> </ol> <p></p> <p>Next, the menu to register and set your identity will pop-up and you can start filling in your information. You are not required to enter information for every single field, you can choose to fill in just one field or all of them, it's up to you. For this example:</p> <ol> <li>Set your display name</li> <li>Click on the include field toggle for email and then enter in your email</li> <li>Click on the include field toggle for Twitter and then enter in your Twitter handle</li> <li>After you're done filling in your information and the deposit amount looks alright to you, click Set Identity</li> </ol> <p></p> <p>You will then be prompted to sign the transaction. If everything looks good, you can enter your password and click Sign and Submit to sign and send the transaction.</p> <p>You should see status notifications pop-up in the top right hand corner. Once the transaction has been confirmed, you can click on your account name again and the panel will slide out on the right side of the page. Your balances will have changed, and you\u2019ll also see your new identity information.</p> <p></p> <p>If the identity information matches what you entered, you\u2019ve successfully set an identity!</p> <p>Once you clear your identity, the deposit in your reserved balance will get transferred back to your transferable balance. If you need to make changes to your identity, you can go through the process of setting your identity again. Please note that you will need to ensure all fields are re-entered, even if only one field needs to be changed, or they will be overwritten. You will not need to pay another deposit, unless custom fields are used, but you will need to pay gas fees.</p>"},{"location":"tokens/manage/identity/#clear-identity-accounts","title":"Clear an Identity","text":"<p>To clear your identity from the Accounts tab of the Polkadot.js Apps UI, you'll need to:</p> <ol> <li>Click on the 3 vertical dots next to the account you would like to add identity information for</li> <li>A menu will pop up. Click Set on-chain identity</li> </ol> <p></p> <p>The identity menu will pop-up with your information already filled out. You'll need to click Clear Identity.</p> <p></p> <p>You will then be prompted to sign the transaction. If everything looks good, you can enter your password and click Sign and Submit to sign and send the transaction.</p> <p>You should see status notifications pop-up in the top right hand corner. Once the transaction has been confirmed, you can click on your account name again and the panel will slide out on the right side of the page. You can see your reserved balance was transferred back to your transferable balance, and your identity information has been removed.</p> <p>That\u2019s it! You\u2019ve successfully cleared your identity. If you want to add a new identity, you can do so at any time.</p>"},{"location":"tokens/manage/identity/#manage-via-extrinsics","title":"Manage an Identity via Extrinsics","text":""},{"location":"tokens/manage/identity/#set-identity-extrinsics","title":"Set an Identity","text":"<p>To register an identity using the extrinsics UI, navigate to the Extrinsics page on Polkadot.js Apps. Then, you'll need to:</p> <ol> <li>Select your account</li> <li>Select identity from the submit the following extrinsic dropdown</li> <li>Then select the setIdentity(info) function</li> <li>Start filling in your identity information. Please make sure that for each field, your input does not exceed 32 characters<ol> <li>Select the format of the data. For this example, you can use Raw data but you also have the option of entering your data in BlackTwo256, Sha256, Keccak256, and ShaThree256 hashed format</li> <li>Enter the data in that format</li> </ol> </li> </ol> <p></p> <p>Optionally, if you would like to enter custom fields, you can do so by:</p> <ol> <li>Scrolling to the top and clicking on Add item</li> <li>Two fields will appear: the first for the field name and the second for the value. Please make sure that for each field and value, your input does not exceed 32 characters. Fill in the field name<ol> <li>Select the format of the data for the field name. Again, you can use Raw data</li> <li>Enter the field name in the selected format</li> </ol> </li> <li>Fill in the value<ol> <li>Select the format of the data for the value. Again, you can use Raw data</li> <li>Enter the value in the selected format</li> </ol> </li> </ol> <p></p> <p>Finally, once all of your identity information has been added, you can scroll to the bottom of the page and click Submit Transaction.</p> <p></p> <p>You will then be prompted to sign the transaction. Remember, there is an additional deposit required for each additional custom field. If everything looks good, you can enter your password and click Sign and Submit to sign and send the transaction.</p> <p>You should see status notifications pop-up in the top right hand corner confirming the transaction. If successful, you\u2019ve set an identity! Congratulations! To make sure everything went through and your identity information looks good, next you can confirm your identity.</p>"},{"location":"tokens/manage/identity/#confirm-identity-extrinsics","title":"Confirm an Identity","text":"<p>To verify the addition of your identity information, you can click on the Developer tab and then navigate to Chain state.</p> <p>On the Chain State UI, make sure Storage is selected. Then you can start to request your identity information:</p> <ol> <li>Set selected state query to identity</li> <li>Select the identityOf(AccountId) function</li> <li>Select your account</li> <li>Click the + button to get your identity information</li> </ol> <p></p> <p>You can see now that you\u2019ve successfully set an identity! Once you clear your identity, the deposit in your reserved balance will get transferred back to your transferable balance. If you need to make changes to your identity, you can go through the process of setting your identity again. Please note that you will need to ensure all fields are re-entered, even if only one field needs to be changed, or they will be overwritten. You will not need to pay another deposit, unless custom fields are used, but you will need to pay gas fees.</p>"},{"location":"tokens/manage/identity/#clear-identity-extrinsics","title":"Clear an Identity","text":"<p>To clear your identity from the Extrinsics tab of the Polkadot.js Apps UI, you'll need to:</p> <ol> <li>Select your account from the using the selected account dropdown</li> <li>Select identity from the submit the following extrinsic dropdown</li> <li>Then select the clearIdentity() function</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>You will then be prompted to sign the transaction. If everything looks good, you can enter your password and click Sign and Submit to sign and send the transaction.</p> <p>You should see status notifications pop-up in the top right hand corner confirming the transaction.</p> <p>To verify the removal of your identity information, you can follow the steps in the Confirm an Identity section again. Instead of seeing your identity information, this time you'll get a response of none. Meaning, you no longer have any identity information associated with your account. If you check your balances, you should see that the initial deposit for setting your identity has been returned to your transferable balance. That\u2019s it! Your identity has been cleared.</p>"},{"location":"tokens/manage/identity/#identity-judgement","title":"Identity Judgement","text":"<p>After submitting your identity information, you can request verification of your identity from a registrar. Registrars are tasked with verifying the submitted identity information and can set a fee for their services. When you request judgement, you'll need to specify the registrar you want to verify your information and the maximum fee that you're willing to pay them for providing judgement. The request will only be processed if the selected registrar charges less than the maximum fee that you specified, otherwise the transaction will fail. The fee will be locked until the registrar completes the judgement process and only then will the fee be transferred to the registrar. The registrar fee is in addition to the deposit paid when you initially created your identity.</p> <p>Registrar applicants are appointed via on-chain democracy. If an appointed registrar issues incorrect judgements or proves to be untrustworthy, they can be removed through democracy.</p> <p>A registrar will perform proper due diligence to verify the submitted identity information and based on their findings will provide judgement and assign up to seven levels of confidence:</p> <ul> <li>Unknown - no judgement made yet. This is the default value</li> <li>Fee Paid - indicates a user has requested judgement and it is in progress</li> <li>Reasonable - the information appears reasonable, but no in-depth checks were performed using legal identity documents</li> <li>Known Good - the information is correct and is based upon review of legal identity documents</li> <li>Out of Date - the information used to be good, but is now out of date</li> <li>Low Quality - the information is low quality or imprecise, but can be updated as needed</li> <li>Erroneous - the information is erroneous and may indicate malicious intent. This state cannot be modified and can only be removed if the entire identity has been removed</li> </ul>"},{"location":"tokens/manage/identity/#current-registrars","title":"Current Registrars","text":"<p>When requesting identity judgement, you'll need to provide the index of the registrar you want to complete your request.</p> <p>The current registrars are as follows:</p> MoonbeamMoonriverMoonbase Alpha Registrar Operator Address Index Registrar #0 Moonbeam Foundation 0xbE6E642b25Fa7925AFA1600C48Ab9aA3461DC7f1 0 Registrar #1 Chevdor 0xeaB597B91b66d9C3EA5E3a39e22C524c287d61a5 1 Registrar Operator Address Index Registrar #0 Moonbeam Foundation 0x031590D13434CC554f7257A89B2E0B10d67CCCBa 0 Registrar #1 Chevdor 0x2d18250E01312A155E81381F938B8bA8bb4d97B3 1 Registrar Operator Address Index Registrar #1 Chevdor 0x4aD549e07E96BaD335A8b99C8fd32e95EE538904 1 <p>You can get a complete list of the current registrars, including the fees that each registrar charges, by heading to Polkadot.js Apps, selecting the Developer tab, choosing Chain State from the dropdown, and taking the following steps:</p> <ol> <li>Select the identity pallet</li> <li>Choose the registrars extrinsic</li> <li>Click the + button</li> </ol> <p></p>"},{"location":"tokens/manage/identity/#request-judgement","title":"Request Identity Judgement","text":"<p>To request identity judgement, from the Extrinsics page, you can take the following steps:</p> <ol> <li>Select your account from the using the selected account dropdown</li> <li>Select identity from the submit the following extrinsic dropdown</li> <li>Then select the requestJudgement() function</li> <li>Enter the index of the registrar you want to review and provide judgement on your identity information</li> <li>Enter the maximum fee you're willing to pay in Wei. This must be higher than the fee set by the registrar, otherwise the transaction will fail</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>Once the transaction goes through, the fee will be taken from your free balance and locked until the judgement is complete.</p> <p>After the judgement is complete and you've been successfully verified, a green check mark will appear next to your account. If successful, your identity will be assigned one of these three levels of confidence: low quality, reasonable, or known good. From the Accounts page, you can click on your account name to review your identity information and your identity judgement results.</p> <p></p>"},{"location":"tokens/manage/identity/#cancel-judgement-request","title":"Cancel Identity Judgement Request","text":"<p>If the registrar hasn't completed your judgement, you can cancel the request and receive the locked fee back. To do so, from the Extrinsics page, take the following steps:</p> <ol> <li>Select your account from the using the selected account dropdown</li> <li>Select identity from the submit the following extrinsic dropdown</li> <li>Then select the cancelRequest() function</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>You'll then be prompted to sign and send the transaction. Once it goes through, your locked funds will be returned to you.</p>"},{"location":"tokens/manage/multisig-safe/","title":"Interacting with Moonbeam Safe","text":""},{"location":"tokens/manage/multisig-safe/#introduction","title":"Introduction","text":"<p>A single-signature wallet, or singlesig for short, is a wallet in which only one owner holds the private key, and therefore has control over all the assets that account holds. Moreover, if the private key is lost, then access to the wallet and the funds are lost forever. </p> <p>To solve this problem, multi-signature wallets, or multisig for short, have been introduced. With a multisig wallet there is more than one owner, so one owner could lose their keys and the others would still have access to the wallet and funds. In addition, multisig wallets can require threshold signing, where a proposal is only executed as a transaction if a certain amount of approvals are attained. Therefore creating an extra layer of security.</p> <p>To help manage singlesig and multisig wallets, Gnosis Safe was forked to create Moonbeam Safe. The Safe can be configured as a multisig contract that allows two or more owners to hold and transfer funds to and from the Safe. You can also configure the Safe to be a singlesig contract with only one owner. </p> <p>This guide will show you how to create a multisig Safe on the Moonbase Alpha TestNet. You will also learn how to send DEV and ERC-20 tokens to and from the Safe, and how to interact with smart contracts using the Safe. This guide can be adapted for Moonbeam and Moonriver.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/manage/multisig-safe/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before diving into the guide, you'll need to have a few MetaMask accounts loaded up with funds, some ERC-20 tokens on hand to send to the Safe, and a deployed smart contract to interact with.</p>"},{"location":"tokens/manage/multisig-safe/#metamask-accounts","title":"MetaMask Accounts","text":"<p>For this guide, you will be creating a Safe on Moonbase Alpha to interact and manage your funds with. To connect to the Safe, you will need to have:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>At least two accounts each loaded with funds.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul> <p>You will need at least two accounts because you will be setting up a multisig Safe with 3 owners, and 2/3 confirmations for any transaction to get executed. Therefore, throughout this guide you will need to switch back and forth between at least two of the accounts to be able to confirm and send transactions. </p> <p>This guide will use the following accounts:</p> <ul> <li>Alice \u2014 0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</li> <li>Bob \u2014 0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</li> <li>Charlie \u2014 0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</li> </ul>"},{"location":"tokens/manage/multisig-safe/#erc20-tokens","title":"ERC-20 Tokens","text":"<p>Later on in this guide, you will be learning how to send and receive ERC-20 tokens to and from the Safe. So you will need to have deployed some ERC-20 tokens and added them to your MetaMask account. To do so, you can check out the Using Remix to Deploy to Moonbeam guide, in particular the Deploying a Contract to Moonbeam and Interact with a Moonbeam-based ERC-20 sections will show you how to deploy an ERC-20 token and import it into MetaMask.</p>"},{"location":"tokens/manage/multisig-safe/#deployed-smart-contract","title":"Deployed Smart Contract","text":"<p>Towards the end of this guide, you will be learning how to interact with a smart contract using the Safe. So you will need to have a smart contract deployed to interact with. If you would like detailed instructions, you can refer to the Deploying a Contract to Moonbeam using Remix guide.</p> <p>You can head to Remix and create a new file for the following <code>SetText.sol</code> contract:</p> <pre><code>pragma solidity ^0.8.0;\n\ncontract SetText {\n    string public text;\n\n    function setTextData(string calldata _text) public {\n        text = _text;\n    }\n}\n</code></pre> <p>This is a simple contract with a single function, <code>setTextData</code>, that accepts a string and uses it to set the <code>text</code> variable.</p> <p>You will need the contract address and the ABI, so make sure you have copied those somewhere or have access to them for later on.</p>"},{"location":"tokens/manage/multisig-safe/#create-a-safe","title":"Create a Safe","text":"<p>To get started creating a Safe, navigate to the Moonbeam Safe. For the purpose of this guide, you'll create a Safe on Moonbase Alpha, but you can also adapt the instructions to create a Safe on Moonbeam or Moonriver. To switch networks, simply click the network dropdown in the top right hand corner of the page. </p>"},{"location":"tokens/manage/multisig-safe/#connect-metamask","title":"Connect MetaMask","text":"<p>Once on the Moonbase Alpha page, you can begin to create a Safe by first connecting your wallet:</p> <ol> <li>Click Connect Wallet</li> <li>Select a wallet to connect to Moonbeam Safe. For this example you can use MetaMask. If MetaMask doesn't appear in the list of options, click Show More and select MetaMask</li> </ol> <p></p> <p>If you're not already signed into MetaMask, you will be prompted to sign in. You will then be guided through adding and connecting your accounts, and adding and switching to the Moonbase Alpha network:</p> <ol> <li>Select an account and connect to the Safe. You'll want to select at least 2 of the 3 owner accounts and then click Next. For this example, Alice, Bob, and Charlie's accounts have all been selected </li> <li>Connect to the selected accounts by clicking Connect</li> <li>If you are not connected to Moonbase Alpha, nor do you have the network added to your MetaMask, add Moonbase Alpha as a custom network by clicking Approve</li> <li>Switch the network to Moonbase Alpha by click Switch Network</li> </ol> <p></p> <p>Now, in the top right hand corner, you can confirm you are connected to your MetaMask account on the Moonbase Alpha network. If you're using the development accounts, you should see Alice's account address. If not, double check your MetaMask and switch to Alice's account.</p>"},{"location":"tokens/manage/multisig-safe/#create-new-safe","title":"Create New Safe","text":"<p>To create a new Safe on Moonbase Alpha, click Create new Safe. You will be taken to a wizard that will walk you through creating your new Safe. By going through these steps and creating your Safe, you are consenting to the terms of use and the privacy policy. So, feel free to look those over before getting started.</p> <p></p> <p>You will need to give your Safe a name:</p> <ol> <li>Enter the name of your new Safe, you can use <code>moonbeam-tutorial</code></li> <li>Click Start</li> </ol> <p></p> <p>Next up is the owners and confirmations section of the wizard. In this section, you will add the owners of the Safe and specify the threshold. The threshold determines how many of the owners are required to confirm a transaction before the transaction gets executed. </p> <p>There are many different setups that can be used when creating a Safe. There can be 1 or more owners of the Safe as well as varying threshold levels. Please note that it is not advised to create a Safe with just 1 owner as it creates the possibility of a single point of failure.</p> <p>For this guide, you will create a multisig setup that has 3 owners and requires a threshold of 2, so at least 2 out of the 3 owners keys are required to execute transactions through the Safe.</p> <p>Your account will automatically be prefilled in as the first owner, however this can be changed if you would like to use different accounts. For this example, Alice's account has been prefilled. In addition to Alice, you can also add Bob and Charlie as owners:</p> <ol> <li>Click Add another owner</li> <li>Enter Bob as the second owner, along with his address: <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>Enter Charlie as the third owner, along with his address: <code>0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</code></li> <li>Set the confirmation threshold to 2 out of 3 owners</li> <li>Click Review to go to the last step in the wizard</li> </ol> <p></p> <p>Finally, you can review all of the Safe and owner details and if everything looks ok:</p> <ol> <li>Click Submit to create your new Safe. The creation of the Safe will cost approximately less than .001 DEV tokens on Moonbase Alpha. MetaMask will pop-up and prompt you to confirm the transaction</li> <li>Click Confirm to send the transaction and create the Safe</li> </ol> <p></p> <p>It could take a few minutes to process the transaction and create the Safe, but once it has been created you should see a message saying \"Your Safe was created successfully\". From there, you can click Get Started to load your Safe and start interacting with it.</p> <p></p>"},{"location":"tokens/manage/multisig-safe/#configure-safe","title":"Configure Safe","text":"<p>You can always manage your Safe and change some of the parameters set when creating it. To do so, you can click on the Settings option on the left-hand side menu. </p> <p></p> <p>In there you have the following options:</p> <ul> <li>Safe Details \u2014 allows you to change the Safe name. This is a local action that requires no on-chain interaction</li> <li>Owners \u2014 allows you to initiate a on-chain proposal to add/remove owners to the Safe</li> <li>Policies \u2014 allows you to initiate a on-chain proposal to change the multisig threshold to execute the proposal as a transaction</li> <li>Advanced \u2014 allows you to check other parameters from the Safe, such as the nonce, modules, and transaction guard</li> </ul>"},{"location":"tokens/manage/multisig-safe/#receive-and-send-tokens","title":"Receive and Send Tokens","text":""},{"location":"tokens/manage/multisig-safe/#receive-tokens","title":"Receive Tokens","text":"<p>Now that you have created your Safe, you can start interacting with it. First, load up the Safe by sending some DEV tokens to it. You can send funds to the Safe from any account with DEV tokens. For this example, you can use Alice's account. Hover over DEV in the list of assets to reveal the Send and Receive buttons. Then click Receive.</p> <p></p> <p>A pop-up will appear with the address of the Safe. Copy the address and click Done. </p> <p></p> <p>Next, open up your MetaMask to initiate a transaction:</p> <ol> <li>Click Send to send a transaction</li> <li>Paste in the address of the Safe</li> <li>Enter the amount of DEV tokens you would like to send to the Safe. For this example, you can use 2 DEV tokens</li> <li>Click Next</li> <li>Review the details of the transaction and click Confirm</li> </ol> <p></p> <p>The transaction will be sent and your balance for DEV tokens will be updated on the Safe. </p>"},{"location":"tokens/manage/multisig-safe/#send-tokens","title":"Send Tokens","text":"<p>Now that you have funds in the Safe, you can send funds from the Safe to another account. For this example, you can send 1 DEV token to Bob's address. Hover over DEV in the list of assets, and this time click on Send.</p> <p></p> <p>A pop-up will appear where you can enter the recipient and the amount of DEV tokens to send:</p> <ol> <li>Enter Bob's Address</li> <li>Select DEV from the list of assets</li> <li>Enter 1 DEV token</li> <li>Click Review</li> </ol> <p></p> <ol> <li>Review the details and click Submit. MetaMask will pop-up and you'll notice that instead of sending a transaction, you're sending a message</li> <li>Click Sign to sign the message</li> </ol> <p></p> <p>Now, if you go back to the Safe, under the Transactions tab, you should be able to see that there has been a transaction proposal initiated to send 1 DEV tokens to Bob's address. However, you should also see that only 1 out of 2 confirmations have been received and that 1 more owner is required to confirm the transaction before it gets executed. </p> <p></p>"},{"location":"tokens/manage/multisig-safe/#transaction-confirmation","title":"Transaction Confirmation","text":"<p>The process of confirming (or rejecting) a transaction proposal is similar for all the use cases of a multisig Safe. One of the owners initiates the proposal to execute an action. The other owners can approve or reject the proposal. Once the signature threshold is reached, any owner can execute the transaction proposal if approved, or discard the transaction proposal if rejected.</p> <p>In this example, if 2 of the 3 owners decided to reject the proposal, then the assets would remain in the Safe. However, in this case, you can confirm the transaction from either Bob's or Charlie's account.</p> <p>Switch accounts in MetaMask to Bob's account (or Charlie's). Then go back to the Safe connected as Bob. The Confirm button should now be enabled. As Bob, go ahead and click Confirm to meet the threshold and send the transaction. A pop-up will appear for you to approve the transaction:</p> <ol> <li>Check the Execute transaction box to execute the transaction immediately after confirmation. You can un-check it for the transaction to be executed manually at a later time</li> <li>Click Submit</li> <li>MetaMask will pop-up and ask you to confirm the transaction, if everything looks good, you can click Confirm</li> </ol> <p>Note</p> <p>If you receive an error stating the transaction might fail, you may need to increase the gas limit. You can do so either in the Advanced options or in MetaMask. </p> <p></p> <p>The transaction will be removed from the QUEUE tab and a record of the transaction can now be found under the HISTORY tab. In addition, Bob's balance has now increased by 1 DEV token, and the Safe's balance for DEV tokens has decreased.</p> <p></p> <p>Congratulations, you've successfully received and sent DEV tokens to and from the Safe!</p>"},{"location":"tokens/manage/multisig-safe/#receive-and-send-erc20-tokens","title":"Receive and Send ERC-20 Tokens","text":""},{"location":"tokens/manage/multisig-safe/#receive-erc20-tokens","title":"Receive ERC-20 Tokens","text":"<p>Next up is to receive and send ERC-20s to and from the Safe. You should already have loaded up your MetaMask with MYTOK ERC-20 tokens. If not, please refer back to the ERC-20 Tokens section of the prerequisites.</p> <p>You should still be connected to Bob's account for this example. So, you'll be sending MYTOK tokens from Bob's account to the Safe.</p> <p>You'll need to get the Safe's address again, you can do so by clicking on the Copy to clipboard icon in the top left hand corner. Once you've got your Safe's address copied, open up MetaMask:</p> <ol> <li>Switch to the Assets tab and select MYTOK from the list</li> <li>Click Send </li> <li>Paste in the Safe's address</li> <li>Enter amount of MYTOKs to send. You should have minted 8M MYTOK tokens in the Using Remix to Deploy to Moonbeam guide. So for this example, you can enter 1000 MYTOKs for the amount to send</li> <li>Click Next</li> <li>Review the transaction details and then click Confirm to send the transaction.</li> </ol> <p></p> <p>If you navigate back to the Safe, in the list of Assets you should now see MyToken and a balance of 1000 MYTOKs. It could take a few minutes for MyToken to appear, but there is nothing for you to do to add the asset, it will appear on it's own.</p>"},{"location":"tokens/manage/multisig-safe/#send-erc20-tokens","title":"Send ERC-20 Tokens","text":"<p>Now that you have loaded your Safe with MYTOKs, you can send some from the Safe to another account. For this example, you can send 10 MYTOKs to Charlie.  </p> <p>Hover over MyToken in the list of assets, and this time click on Send.</p> <p></p> <p>A pop-up will appear where you can enter the recipient and the amount of MYTOK tokens to send:</p> <ol> <li>Enter Charlies's Address</li> <li>Select MyToken from the list of assets</li> <li>Enter 10 MYTOK tokens</li> <li>Click Review and review the details</li> </ol> <p></p> <p>If everything looks ok, you can: </p> <ol> <li>Click Submit. MetaMask will pop-up and you'll notice that instead of sending a transaction, you're sending a message</li> <li>Click Sign to sign the message</li> </ol> <p></p> <p>Now, if you go back to the Safe, under the Transactions tab, you should be able to see that there has been a transaction proposal initiated to send 10 MYTOK tokens to Charlie's address. However, you should also see that only 1 out of 2 confirmations have been received and that 1 more owner is required to confirm the transaction before it gets executed.</p> <p></p> <p>You will need to switch accounts to Alice or Charlie and confirm the transaction to execute it. You can follow the same steps outlined in the above Transaction Confirmation section.</p> <p>Once the transaction has been confirmed from one of the other two accounts, the transaction will be moved to the HISTORY tab. </p> <p></p> <p>Congratulations! You've successfully received and sent ERC-20 tokens to and from the Safe!</p>"},{"location":"tokens/manage/multisig-safe/#interact-with-a-smart-contract","title":"Interact with a Smart Contract","text":"<p>For this section, you will be interacting with a smart contract using the Safe. You should have already deployed the <code>SetText.sol</code> contract using Remix, if not please refer back to the Deployed Smart Contract section of the prerequisites.</p> <p>You should still be connected to Alice's account for this section of the guide.</p> <p>From the Safe:</p> <ol> <li>On the left hand side click on New Transaction</li> <li>Then select Contract interaction</li> </ol> <p></p> <p>The Contract interaction pop-up will appear and you can fill in the contract details:</p> <ol> <li>Enter the contract address into the Contract address field</li> <li>In the ABI text box, paste the ABI</li> <li>A Method dropdown will appear. Select the <code>setTextData</code> function</li> <li>Then a <code>_text</code> input field will appear. You can enter anything you would like, for this example, you can use <code>polkadots and moonbeams</code></li> <li>Click Review</li> </ol> <p></p> <p>If the details look ok, go ahead and:</p> <ol> <li>Click Submit. MetaMask will pop-up and you'll notice that instead of sending a transaction, you're sending a message</li> <li>Click Sign to sign the message</li> </ol> <p></p> <p>Now, if you go back to the Safe, under the Transactions tab, you should be able to see that there has been a transaction proposal initiated for a Contract interaction. However, you should also see that only 1 out of 2 confirmations have been received and that 1 more owner is required to confirm the transaction before it gets executed.</p> <p></p> <p>You will need to switch accounts to Bob or Charlie and confirm the transaction to execute it. You can follow the same steps outlined in the above Transaction Confirmation section.</p> <p>Once the transaction has been confirmed from one of the other two accounts, the transaction will be moved to the HISTORY tab.</p> <p></p> <p>To double check that the correct text was set, you can go through the process again except instead of selecting setTextData from the Method dropdown, you can select text to read the <code>text</code> value. This will be a call instead of a transaction, so a Call button will appear. Click on it and directly within the pop-up, you should see the result of the call, <code>polkadots and moonbeams</code>.</p> <p></p> <p>Congratulations, you've successfully interacted with a smart contract using the Safe!</p>"},{"location":"tokens/manage/multisig-safe/#using-moonbeam-safe-apis","title":"Using Moonbeam Safe APIs","text":"<p>There are APIs available to read from and interact with Moonbeam Safes for Moonbeam, Moonriver, and Moonbase Alpha.</p> MoonbeamMoonriverMoonbase Alpha <pre><code>https://transaction.multisig.moonbeam.network/\n</code></pre> <pre><code>https://transaction.moonriver.multisig.moonbeam.network/\n</code></pre> <pre><code>https://transaction.moonbase.multisig.moonbeam.network/\n</code></pre> <p>As an example of using the API, try retrieving information about Safes from the Moonbeam Safe API. From the Safe page, copy the address of your Safe:</p> <p></p> <p>Now you can use the API:</p> <ol> <li>Open the API page for the corresponding network</li> <li>Scroll down to the safes section and click on the /safes/{address}/ endpoint section to expand its panel</li> <li>Click the Try it out button on the right</li> </ol> <p></p> <p>A large Execute button should appear in the panel.</p> <ol> <li>Paste the address of your Safe into the address input</li> <li>Press Execute</li> <li>Information about your safe will appear below</li> </ol> <p></p> <p>Congratulations! You have successfully used the API for Moonbeam Safes. There are still many other endpoints to use, either for convenience or to add into your own app.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/manage/proxy-accounts/","title":"Setting up a Proxy Account","text":""},{"location":"tokens/manage/proxy-accounts/#introduction","title":"Introduction","text":"<p>Proxy accounts can be set up to perform a limited number of actions on behalf of users and are useful for keeping the underlying accounts safe. They allow users to keep their primary account secured safely in cold storage while enabling the proxy to actively perform functions and participate in the network with the weight of the tokens in the primary account.</p> <p>Proxy accounts can be set up to perform specific Substrate functions such as author mapping, staking, balances, and more. This can allow you to, for example, grant a trusted individual access to perform collator or delegator functions on your behalf. A proxy could also be used to keep a staking account safe in cold storage.</p> <p>This guide will show you how to set up a proxy account on the Moonbase Alpha TestNet for balance transfers and how to execute a proxy transaction.</p>"},{"location":"tokens/manage/proxy-accounts/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>Polkadot.js Apps open and connected to Moonbase Alpha</li> <li>Create or have two accounts on Moonbase Alpha</li> <li>At least one of the accounts must be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul> <p>If you need help importing your accounts into Polkadot.js Apps, please check out the Interacting with Moonbeam using Polkadot.js Apps guide.</p>"},{"location":"tokens/manage/proxy-accounts/#general-definitions","title":"General Definitions","text":"<p>When setting up a proxy account, a bond for the proxy is taken out of your free balance and moved to your reserved balance. The bond is required as adding a proxy requires on-chain storage space, and it is recalculated for each proxy you add or remove. After all proxies are removed from your account, the bond is returned to your free balance.</p> <p>The deposit is calculated based on a deposit base and a deposit factor:</p> <ul> <li>Deposit base - the amount to be reserved for an account to have a proxy list</li> <li>Deposit factor - the additional amount to be reserved for every proxy the primary account has</li> </ul> <p>The equation for calculating the deposit is:</p> <pre><code>deposit base + deposit factor * number of proxies\n</code></pre> MoonbeamMoonriverMoonbase Alpha Variable Value Deposit base 10.08 GLMR Deposit factor 0.21 GLMR Max proxies 32 proxies Variable Value Deposit base 1.0008 MOVR Deposit factor 0.0021 MOVR Max proxies 32 proxies Variable Value Deposit base 1.0008 DEV Deposit factor 0.0021 DEV Max proxies 32 proxies"},{"location":"tokens/manage/proxy-accounts/#proxy-types","title":"Proxy Types","text":"<p>When creating a proxy account, you must choose a type of proxy which will define how the proxy can be used. The available options are:</p> <ul> <li><code>AuthorMapping</code> - this type of proxy account is used by collators to migrate services from one server to another</li> <li><code>CancelProxy</code> - allows the proxy account to reject and remove any announced proxy calls</li> <li><code>Staking</code> - allows the proxy account to perform staking-related transactions, such as collator or delegator functions, including <code>authorMapping()</code></li> <li><code>Governance</code> - allows the proxy account to make transactions related to governance, such as voting or proposing democracy proposals</li> <li><code>NonTransfer</code> - this type of proxy account is allowed to submit any type of transaction with the exception of balance transfers</li> <li><code>Balances</code> - allows the proxy account to only make transactions related to sending funds</li> <li><code>IdentityJudgement</code> - allows the proxy account to request judgement on an account's identity from a registrar. The following judgements can be issued:<ul> <li>unknown - (default) no judgement has been made yet</li> <li>fee paid - to indicate a user has requested judgement and it is in progress</li> <li>reasonable - the information appears reasonable, but no in-depth checks (i.e. formal KYC process) were performed</li> <li>known good - the information has been certified as correct</li> <li>out of date - the information used to be good, but is now out of date</li> <li>low quality - the information is low quality or imprecise, but can be fixed with an update</li> <li>erroneous - the information is erroneous and may indicate malicious intent</li> </ul> </li> <li><code>Any</code> - allows the proxy account to use any function supported by the proxy pallet</li> </ul> <p>For the purposes of this guide, you will be setting up a proxy account using the balances proxy type. Since this type enables the proxy to spend funds on behalf of the primary account, you should exercise caution and only provide access to accounts you trust. The proxy will have access to transfer all of the funds within the primary account, and if not trusted, the proxy could drain the primary account. Also make sure not to forget to remove the proxy as needed.</p>"},{"location":"tokens/manage/proxy-accounts/#creating-a-proxy-account","title":"Creating a Proxy Account","text":""},{"location":"tokens/manage/proxy-accounts/#create-via-the-moonbeam-dapp","title":"Via the Moonbeam DApp","text":"<p>It's easy to create a proxy account on the Moonbeam dApp. To do so, take the following steps:</p> <ol> <li>Toggle the network switcher button to select your desired network</li> <li>Navigate to the Proxy page</li> <li>Ensure you're connected with the primary account that you wish to add a proxy of  </li> <li>Enter the address you want to delegate proxy control to</li> <li>From the proxyType dropdown, choose the desired proxy type, such as a balances proxy</li> <li>Optionally, you can add a time delay using a specified number of blocks, which could allow time for the primary account to review the pending transaction</li> <li>Click Add Proxy and confirm the transaction in your wallet</li> </ol> <p></p>"},{"location":"tokens/manage/proxy-accounts/#create-via-polkadot-js-apps","title":"Via Polkadot.js Apps","text":"<p>There are a couple of ways you can create proxy accounts in Polkadot.js Apps, either from the Extrinsics page or the Accounts page. However, to create a time-delayed proxy, you will need to use the Extrinsics page. A time delay provides an additional layer of security to proxies by specifying a delay period based on a number of blocks. This will prevent the proxy account from executing a transaction until the delay period ends. The delay allows time for the primary account that controls the proxy to review pending transactions, potentially for malicious actions, and cancel if necessary before execution.</p> <p>To get started creating your proxy account, head to the Developer tab and select Extrinsics from the dropdown. Next, you will need to take the following steps:</p> <ol> <li>Select the primary account</li> <li>From the submit the following extrinsic dropdown, select proxy</li> <li>Choose the addProxy extrinsic</li> <li>Select the delegate account for the proxy</li> <li>From the proxyType dropdown, choose Balances</li> <li>Optionally, you can add a time delay using a specified number of blocks, which could allow time for the primary account to review the pending transaction</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>You will then be prompted to authorize and sign the transaction. Go ahead and click Sign and Submit to create the proxy relationship.</p> <p>Once the transaction has been successfully submitted, you will receive some notifications confirming the transaction.</p> <p>As previously mentioned, you can also create a proxy from the Accounts page. To do so, navigate to the Accounts page, and take the following steps:</p> <ol> <li>Select the 3 vertical dots next to the primary account</li> <li>Select Add proxy</li> </ol> <p></p> <p>Note</p> <p>If the account already has a proxy, Manage proxies will be displayed as an option instead of Add proxy.</p> <p>A pop-up will appear and you will be able to enter in the required information, such as the proxied/primary account, the proxy account, and type of proxy in order to create a proxy account. First click Add Proxy.</p> <p></p> <p>Then take the following steps:</p> <ol> <li>Select the account you would like to set as a proxy</li> <li>Select the proxy type</li> <li>Click Submit and sign the transaction</li> </ol> <p></p> <p>In the next section, you will learn how to verify that your proxy account was set up successfully.</p>"},{"location":"tokens/manage/proxy-accounts/#verifying-your-proxy-account","title":"Verifying your Proxy Account","text":""},{"location":"tokens/manage/proxy-accounts/#verify-via-the-moonbeam-dapp","title":"Via the Moonbeam DApp","text":"<p>When connected to the Moonbeam dApp with your primary account, you can see a list of accounts with proxy control over your connected primary account in the Your Proxies section.</p> <p></p> <p>Alternatively, by connecting the proxy account to the Moonbeam dApp, you can see a list of accounts over which the connected account has proxy control in the Proxied accounts to you section.</p> <p></p>"},{"location":"tokens/manage/proxy-accounts/#verify-via-polkadot-js-apps","title":"Via Polkadot.js Apps","text":"<p>There are a couple of ways that you can verify your proxy account has been successfully set up. Either through the Accounts page or via the Chain state page.</p> <p>To check your proxy accounts from the Chain state page, you can take the following steps:</p> <ol> <li>From the selected state query dropdown, select proxy</li> <li>Choose the proxies extrinsic</li> <li>Select your primary (proxied) account</li> <li>Click on the + button to send the query</li> </ol> <p></p> <p>The result will appear on the page showing you information about all of your proxies, including the delegate/proxy account address, the proxy type, the delay period if one was specified, and the total bond amount for all of your proxies in Wei.</p> <p>As previously mentioned, you can also check your proxy accounts from the Accounts page. To do so, you can navigate to the Accounts page and there should be a Proxy symbol next to the primary account. Hover over the icon and click on Manage proxies to review your proxies.</p> <p></p> <p>A pop-up will appear where you can view an overview of all of your proxy accounts.</p> <p></p>"},{"location":"tokens/manage/proxy-accounts/#executing-a-proxy-transaction","title":"Executing a Proxy Transaction","text":"<p>Now that you have created a proxy account and verified that it was successfully set up, you can execute a transaction using the proxy account on behalf of the primary account.</p> <p>To execute a transaction, navigate back to the Extrinsics page and take the following steps:</p> <ol> <li>Select the proxy account to submit the transaction from the using the select account dropdown</li> <li>From the submit the following extrinsic menu, select proxy</li> <li>Choose the proxy extrinsic</li> <li>Select the primary account from the real dropdown</li> <li>Select the balances call</li> <li>Choose the transfer extrinsic</li> <li>In the dest field, enter the address you would like to send funds to</li> <li>In the value field, enter the amount of funds to send in Wei. For this example, you can send 2 DEV tokens, which will be <code>2000000000000000000</code> in Wei</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>A pop-up will appear for you to authorize and sign the transaction. Enter your password for the proxy account and click Sign and Submit.</p> <p>If the transaction successfully went through, you should see a couple of notifications pop-up and if you head over to the Accounts page, you'll see that the balance of your primary account has decreased. If you check the balance of the account where you sent the funds to, you'll notice the balance there has increased.</p> <p>That's it! You've successfully executed a transaction using a proxy account on behalf of your primary account.</p>"},{"location":"tokens/manage/proxy-accounts/#removing-a-proxy-account","title":"Removing a Proxy Account","text":""},{"location":"tokens/manage/proxy-accounts/#remove-via-the-moonbeam-dapp","title":"Via the Moonbeam DApp","text":"<p>To remove a proxy account, connect your primary account to the Moonbeam dApp and press Remove next to the proxy account that you want to remove. Alternatively, you can remove all proxy accounts of the primary account with Remove All Proxies. In either case, you must confirm the transaction in your wallet. </p> <p></p>"},{"location":"tokens/manage/proxy-accounts/#remove-via-polkadot-js-apps","title":"Via Polkadot.js Apps","text":"<p>Similarly to adding a proxy account, there are a couple of ways that you can remove a proxy account, either from the Extrinsics page or the Accounts page. Regardless of which page you use, you can elect to remove a single proxy account or all proxies associated with your primary account.</p> <p>To remove a proxy from the Extrinsics page, you can take the following steps:</p> <ol> <li>From the using the selected account dropdown, select your primary account</li> <li>Then select proxy</li> <li>Choose removeProxy to remove a single proxy or removeProxies to remove all associated proxies</li> <li>If removing a single proxy, enter the proxy account to remove in the delegate field</li> <li>Select the proxyType to remove, in this case choose Balances</li> <li>Optionally, select a delay period in block numbers</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>A pop-up will appear for you to authorize and sign the transaction. While either account can sign transactions generally, removing a proxy must be performed by the primary account. Enter your password and click Sign and Submit.</p> <p>You can follow the steps in the Verifying your Proxy Account section to check that the proxy or proxies have been removed.</p> <p>As previously mentioned, you can also remove a proxy from the Accounts page. To do so, on the Accounts page, select the 3 vertical dots next to the primary account and select Manage Proxies.</p> <p></p> <p>A pop-up will appear showing an overview of your proxy accounts. To remove a single proxy you can select the X button next to the proxy to remove. The proxy will disappear from the list, then you will need to click Submit. Next you will be able to enter your password and submit the transaction. Or to remove all proxies you can click on Clear all, then you will automatically be prompted to enter your password and submit the transaction.</p> <p></p> <p>Once the transaction has successfully been submitted, you can review your current proxies or if you removed all proxies you will notice the proxy icon is no longer being displayed next to the primary account.</p> <p>And that's it! You've successfully created a proxy, reviewed all proxy accounts associated with your primary account, executed a proxy transaction, and removed a proxy account!</p>"},{"location":"tokens/staking/stake/","title":"How to Stake your Tokens","text":""},{"location":"tokens/staking/stake/#introduction","title":"Introduction","text":"<p>Collator candidates with the highest stake in the network join the active pool of collators (block producers), from which they are selected to offer a block to the relay chain.</p> <p>Token holders can add to candidates' stake using their tokens, a process called delegation (also referred to as staking). When they do so, they are vouching for that specific candidate, and their delegation is a signal of trust. When delegating, tokens are deducted instantly and added to the total amount staked by the user. Exiting a position is divided into a two step operation: scheduling and execution. First, token holders must schedule a request to exit their position, and wait for a given delay or unbonding period, which depends on the network. Once the unbonding period has expired, users can execute their scheduled action.</p> <p>Once a candidate joins the active set of collators, they are eligible to produce blocks and receive partial block rewards as part of the token inflationary model. They share these as staking rewards with their delegators, considering their proportional contribution toward their stake in the network. Delegators can choose to auto-compound their rewards so that a set percentage of their rewards are automatically applied to their total delegation amount.</p> <p>This guide will show you how to stake on Moonbase Alpha via Polkadot.js Apps, but similar steps can be taken for any of the Moonbeam and Moonriver. Token holders that want to easily stake their tokens can use the Moonbeam dApp to do so.</p> <p>For more general information on staking, please check out the Staking on Moonbeam overview.</p>"},{"location":"tokens/staking/stake/#extrinsics-definitions","title":"Extrinsics Definitions","text":"<p>There are many extrinsics related to the staking pallet, you can check out a complete list of them on the Parachain Staking Pallet page.</p> <p>The following list covers the extrinsics that you'll use in this guide and are associated with the delegation process.</p> <p>Note</p> <p>Extrinsics might change in the future as the staking pallet is updated.</p>"},{"location":"tokens/staking/stake/#join-or-leave-the-delegator-set","title":"Join the Delegator Set","text":"<ul> <li>delegateWithAutoCompound(address candidate, uint256 amount, uint8 autoCompound, uint256 candidateDelegationCount, uint256 candidateAutoCompoundingDelegationCount, uint256 delegatorDelegationCount) - extrinsic to delegate a given amount to a collator. The amount needs to be greater than the minimum delegation stake. This also sets the percentage of rewards to be auto-compounded</li> </ul>"},{"location":"tokens/staking/stake/#bond-more-or-less","title":"Bond More or Less","text":"<ul> <li>delegatorBondMore(address candidate, uint256 more) - extrinsic to request to increase the amount of staked tokens for an already delegated collator</li> <li>scheduleDelegatorBondLess(address candidate, uint256 less) - extrinsic to request to reduce the amount of staked tokens for an already delegated collator. The amount must not decrease your overall total staked below the minimum delegation stake. There will be a bond less delay before you can execute the request via the <code>executeDelegationRequest</code> extrinsic</li> <li>executeDelegationRequest(address delegator, address candidate) - extrinsic to execute and pending delegation requests. This extrinsic should only be used after a request has been scheduled and the exit delay has passed</li> <li>scheduleCandidateBondLess(uint256 less) - extrinsic that allows a collator candidate to request to decrease their self bond by a given amount. There will be a bond less delay before you can execute the request via the <code>executeCandidateBondLess</code> extrinsic</li> <li>executeCandidateBondLess(address candidate) - extrinsic to execute a decrease a candidate's self bond amount. This extrinsic should only be used after a bond request has been scheduled and the exit delay has passed</li> <li>cancelCandidateBondLess() - extrinsic to cancel a scheduled request to increase or decrease the bond for a specific candidate</li> </ul>"},{"location":"tokens/staking/stake/#revoke-delegations","title":"Revoke Delegations","text":"<ul> <li>scheduleRevokeDelegation(address collator) - extrinsic to schedule to remove an existing delegation entirely. There will be a revoke delegation delay before you can execute the request via the <code>executeDelegationRequest</code> extrinsic</li> <li>cancelDelegationRequest(address candidate) - extrinsic to cancel a scheduled request to revoke a delegation</li> </ul>"},{"location":"tokens/staking/stake/#set-change-auto-compounding","title":"Set or Change Auto-Compounding Percentage","text":"<ul> <li>setAutoCompound(address candidate, uint8 value, uint256 candidateAutoCompoundingDelegationCount, uint256 delegatorDelegationCount) - sets an auto-compound value for an existing delegation</li> </ul>"},{"location":"tokens/staking/stake/#retrieving-staking-parameters","title":"Retrieve Staking Values","text":"<p>You can check out any of the constant staking values using Polkadot.js Apps, such as the maximum number of delegations, minimum stake requirements, exit delays for delegation requests, and more.</p> <p>To do so, you can navigate to Polkadot.js Apps Chain state UI, and for the purposes of this guide, connect to Moonbase Alpha. Alternatively, you can connect to Moonbeam or Moonriver.</p> <p>Then to retrieve the various staking parameters, select the Constants tab on the Chain state UI, and take the following steps:</p> <ol> <li>From the selected constant query dropdown, choose parachainStaking</li> <li>Choose any function you would like to get data for. For this example, you can use maxDelegationsPerDelegator. This will return the maximum number of candidates you can delegate</li> <li>Click + to return the current value</li> </ol> <p></p> <p>You should then see the maximum delegations per delegator, which can also be found in the Staking on Moonbeam overview.</p>"},{"location":"tokens/staking/stake/#how-to-delegate-a-candidate","title":"How to Stake &amp; Auto-Compound Rewards via Polkadot.js Apps","text":"<p>This section goes over the process of delegating collator candidates. The address of the collator candidate on Moonbase Alpha that is used throughout this guide is <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>.</p> <p>Before staking via Polkadot.js Apps, you need to retrieve some important parameters such as the list of candidates, the delegation count of the candidate you want to delegate, and your number of delegations. To auto-compound your delegation rewards, you'll also need the auto-compounding delegation count of the candidate you want to delegate.</p>"},{"location":"tokens/staking/stake/#retrieving-the-list-of-candidates","title":"Retrieve the List of Candidates","text":"<p>Before starting to stake tokens, it is important to retrieve the list of collator candidates available in the network. To do so, head to the Developer tab, click on Chain State, and take the following steps:</p> <ol> <li>Choose the pallet to interact with. In this case, it is the parachainStaking pallet</li> <li>Choose the state to query. In this case, it is the selectedCandidates or candidatePool state</li> <li>Send the state query by clicking on the + button</li> </ol> <p>Each extrinsic provides a different response:</p> <ul> <li>selectedCandidates \u2014 returns the current active set of collators, that is, the top collator candidates by total tokens staked (including delegations). For example, on Moonbase Alpha it is the top 11 candidates</li> <li>candidatePool \u2014 returns the current list of all the candidates, including those that are not in the active set</li> </ul> <p></p>"},{"location":"tokens/staking/stake/#get-the-candidate-delegation-count","title":"Get the Candidate Delegation Count","text":"<p>First, you need to get the <code>candidateInfo</code>, which will contain the delegator count, as you'll need to submit this parameter in a later transaction. To retrieve the parameter, make sure you're still on the Chain State tab of the Developer page, and then take the following steps:</p> <ol> <li>Choose the parachainStaking pallet to interact with</li> <li>Choose the candidateInfo state to query</li> <li>Make sure the include option slider is enabled</li> <li>Enter the collator candidate's address</li> <li>Send the state query by clicking on the + button</li> <li>Copy the result as you'll need it when initiating a delegation</li> </ol> <p></p>"},{"location":"tokens/staking/stake/#get-candidate-auto-compounding-count","title":"Get the Candidate Auto-Compounding Delegation Count","text":"<p>The auto-compounding delegation count is the amount of delegations that have auto-compounding configured. To determine the number of delegations that have auto-compounding set up, you can query the auto-compounding delegations for the candidate on Polkadot.js Apps using the following snippet:</p> <pre><code>// Simple script to get the number of auto-compounding delegations for a given candidate.\n// Remember to replace INSERT_CANDIDATE_ADDRESS with the candidate's address you want to delegate.\nconst candidateAccount = 'INSERT_CANDIDATE_ADDRESS';\nconst autoCompoundingDelegations =\n  await api.query.parachainStaking.autoCompoundingDelegations(candidateAccount);\nconsole.log(autoCompoundingDelegations.toHuman().length);\n</code></pre> <p>To run the snippet, make sure you're on the JavaScript page of Polkadot.js Apps (which can be selected from the Developer dropdown), and take the following steps:</p> <ol> <li>Copy the code from the previous snippet and paste it inside the code editor box</li> <li>(Optional) Click the save icon and set a name for the code snippet, for example, Get auto-compounding delegation count. This will save the code snippet locally</li> <li>To execute the code, click on the run button</li> <li>Copy the result as you'll need it when initiating a delegation</li> </ol> <p></p>"},{"location":"tokens/staking/stake/#get-your-number-of-existing-delegations","title":"Get your Number of Existing Delegations","text":"<p>If you've never made a delegation from your address you can skip this section. However, if you're unsure how many existing delegations you have, you'll want to run the following JavaScript code snippet to get <code>delegationCount</code> from within Polkadot.js:</p> <pre><code>// Simple script to get your number of existing delegations.\n// Remember to replace INSERT_YOUR_ADDRESS with your delegator address.\nconst yourDelegatorAccount = 'INSERT_YOUR_ADDRESS'; \nconst delegatorInfo = \n  await api.query.parachainStaking.delegatorState(yourDelegatorAccount);\n\nif (delegatorInfo.toHuman()) {\n  console.log(delegatorInfo.toHuman()['delegations'].length);\n} else {\n  console.log(0);\n}\n</code></pre> <p>Head to the Developer tab and click on JavaScript. Then take the following steps:</p> <ol> <li>Copy the code from the previous snippet and paste it inside the code editor box</li> <li>(Optional) Click the save icon and set a name for the code snippet, for example, Get delegation count. This will save the code snippet locally</li> <li>To execute the code, click on the run button</li> <li>Copy the result as you'll need it when initiating a delegation</li> </ol> <p></p>"},{"location":"tokens/staking/stake/#staking-your-tokens","title":"Stake your Tokens","text":"<p>To access staking features, you need to use the Polkadot.js Apps interface. To do so, you need to import/create an Ethereum-style account first (H160 address), which you can do by following the Creating or Importing an H160 Account section of the Polkadot.js guide.</p> <p>For this example, an account was imported and named with a super original name: Alice. Alice's address is <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code>.</p> <p>To delegate a candidate and set up auto-compounding for your staking rewards, take the following steps:</p> <ol> <li>Select the account from which you want to stake your tokens</li> <li>Choose the parachainStaking pallet</li> <li>Choose the delegateWithAutoCompound extrinsic</li> <li>Set the candidate's address to delegate. In this case, it is set to <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>Set the number of tokens you want to stake</li> <li>Set the percentage of rewards to auto-compound by entering a number 0-100</li> <li>Input the <code>candidateDelegationCount</code> you retrieved previously from querying <code>candidateInfo</code></li> <li>Input the <code>candidateAutoCompoundingDelegationCount</code> you retrieved previously from querying <code>autoCompoundingDelegations</code></li> <li>Input the <code>delegationCount</code> you retrieved from the JavaScript console. This is <code>0</code> if you haven't yet delegated a candidate</li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p> <p>Note</p> <p>The parameters used in steps 7-9 are for gas estimation purposes and do not need to be exact. However, they should not be lower than the actual values.</p>"},{"location":"tokens/staking/stake/#verifying-delegations","title":"Verify Delegations","text":"<p>Once the transaction is confirmed, you can verify your delegation by navigating to Chain state under the Developer tab. Here, provide the following information:</p> <ol> <li>Choose the pallet you want to interact with. In this case, it is the parachainStaking pallet</li> <li>Choose the state to query. In this case, it is the delegatorState</li> <li>Verify the selected address is correct. In this case, you are looking at Alice's account</li> <li>Make sure to enable the include option slider</li> <li>Send the state query by clicking on the + button</li> </ol> <p></p> <p>In the response, you should see your account (in this case, Alice's account) with a list of the delegations. Each delegation contains the target address of the candidate and the amount.</p> <p>You can follow the same steps as described to delegate other candidates in the network.</p>"},{"location":"tokens/staking/stake/#verifying-auto-compounding-percentage","title":"Verify Auto-Compounding Percentage","text":"<p>If you want to verify the percentage of rewards that are set to auto-compound for a specific delegation, you can use the following script that will query the <code>autoCompoundingDelegations</code> extrinsic and filter the results based on the delegator's address:</p> <pre><code>// Simple script to verify your auto-compounding percentage for a given candidate.\n// Remember to replace INSERT_CANDIDATE_ADDRESS with the candidate's address you\n// want to delegate and replace INSERT_DELEGATOR_ADDRESS with the address used to \n// delegate with\nconst candidateAccount = 'INSERT_CANDIDATE_ADDRESS';\nconst delegationAccount = 'INSERT_DELEGATOR_ADDRESS';\nconst autoCompoundingDelegations =\n  await api.query.parachainStaking.autoCompoundingDelegations(candidateAccount);\nconst delegation = autoCompoundingDelegations.find(\n  (del) =&gt; del.delegator == delegationAccount\n);\n\nconsole.log(`${delegation.value}%`);\n</code></pre> <p>In Polkadot.js Apps, you can head to the Developer tab and select JavaScript from the dropdown. Then you can take the following steps:</p> <ol> <li>Copy the code from the previous snippet and paste it inside the code editor box</li> <li>(Optional) Click the save icon and set a name for the code snippet, for example, Get auto-compounding percentage. This will save the code snippet locally</li> <li>To execute the code, click on the run button</li> <li>The result is returned in the terminal on the right side</li> </ol> <p></p>"},{"location":"tokens/staking/stake/#set-or-change-auto-compounding","title":"Set or Change the Auto-Compounding Percentage","text":"<p>If you initially set up your delegation without auto-compounding or if you want to update the percentage on an existing delegation with auto-compounding set up, you can use the <code>setAutoCompound</code> function of the Solidity interface.</p> <p>You'll need to get the number of delegations with auto-compounding set up for the candidate you want to set or update auto-compounding for. You'll also need to retrieve your own delegation count. Once you have the necessary information, you can click on the Developer tab, select Extrinsics from the dropdown, and take the following steps:</p> <ol> <li>Select the account from which you initially delegated from and want to set or update auto-compounding for</li> <li>Choose the parachainStaking pallet</li> <li>Choose the setAutoCompound extrinsic</li> <li>Set the candidate's address that you delegated. For this example, it is set to <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>Set the percentage of rewards to auto-compound by entering a number 0-100</li> <li>For the candidateAutoCompoundingDelegationHint field, enter the candidate's number of delegations with auto-compounding configured</li> <li>For the delegationCountHint field, enter your number of delegations</li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p>"},{"location":"tokens/staking/stake/#how-to-stop-delegations","title":"How to Stop Delegations","text":"<p>As of runtime version 1001, there have been significant changes to the way users can interact with various staking features. Including the way staking exits are handled.</p> <p>If you want to make an exit and stop a delegation, you have to first schedule it, wait an exit delay, and then execute the exit request. If you are already a delegator, you can request to stop your delegations using the <code>scheduleRevokeDelegation</code> extrinsic to request to unstake your tokens from a specific collator candidate. Scheduling a request does not automatically revoke your delegations, you must wait an exit delay and then execute the request by using the <code>executeDelegationRequest</code> method.</p>"},{"location":"tokens/staking/stake/#schedule-request-to-stop-delegations","title":"Schedule Request to Stop Delegations","text":"<p>To schedule a request to revoke your delegation from a specific candidate, navigate to the Extrinsics menu under the Developer tab. Here, provide the following information:</p> <ol> <li>Select the account from which you want to remove your delegation</li> <li>Choose the <code>parachainStaking</code> pallet</li> <li>Choose the <code>scheduleRevokeDelegation</code> extrinsic</li> <li>Set the candidate's address you want to remove your delegation from. In this case, it is set to <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p> <p>Note</p> <p>There can only be one pending scheduled request per candidate.</p> <p>Once you have scheduled an exit, you must wait an exit delay before you can then execute it. If you try to execute it before the exit delay is up the extrinsic will fail and you'll see an error from Polkadot.js Apps for <code>parachainStaking.PendingDelegationRequest</code>.</p>"},{"location":"tokens/staking/stake/#execute-request-to-stop-delegations","title":"Execute Request to Stop Delegations","text":"<p>After the exit delay has passed after initiating the scheduled request, you can go back to the Developer tab of the Extrinsics menu and follow these steps to execute the request:</p> <ol> <li>Select the account to execute the revocation</li> <li>Choose the parachainStaking pallet</li> <li>Choose the executeDelegationRequest extrinsic</li> <li>Set the delegator's address you want to remove the delegation for. For this example, it will be Alice's address <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>Set the candidate's address you want to remove your delegation from. In this case, it is set to <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p> <p>Once the transaction is confirmed, you can verify that your delegation was removed by going to the Chain state option under the Developer tab. Here, provide the following information:</p> <ol> <li>Choose the parachainStaking pallet</li> <li>Choose the delegatorState state to query</li> <li>Select your account</li> <li>Make sure to enable the include options slider</li> <li>Send the state query by clicking on the + button</li> </ol> <p></p> <p>In the response, you should see your account (in this case, Alice's account) with a list of the remaining delegations. Each delegation contains the target address of the candidate, and the amount. There should no longer be an entry for <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>. If you no longer have any delegations, <code>&lt;none&gt;</code> will be returned.</p> <p>To ensure the revocation went through as expected, you can follow the steps in the Verifying Delegations section above.</p>"},{"location":"tokens/staking/stake/#cancel-request-to-stop-delegations","title":"Cancel Request to Stop Delegations","text":"<p>If you scheduled a request to stop delegations but changed your mind, as long as the request has not been executed, you can cancel the request at any time and all of your delegations will remain as is. To cancel the request you can follow these steps:</p> <ol> <li>Select the account to cancel the scheduled request for</li> <li>Choose the parachainStaking pallet</li> <li>Choose the cancelDelegationRequest extrinsic</li> <li>Enter the candidates address that corresponds to the due request you would like to cancel</li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p>"},{"location":"tokens/staking/stake/#staking-rewards","title":"Staking Rewards","text":"<p>As candidates in the active set of collators receive rewards from block production, delegators get rewards as well. A brief overview on how the rewards are calculated can be found in the Reward Distribution section of the Staking on Moonbeam overview page.</p> <p>In summary, delegators will earn rewards based on their stake of the total delegations for the collator being rewarded (including the collator's stake as well).</p> <p>Delegators can choose to auto-compound their rewards so that their rewards are automatically applied to their total delegation amount. If a delegator has multiple delegations, auto-compounding will need to be set for each delegation.</p>"},{"location":"tokens/staking/stake/#risks","title":"Risks","text":"<p>Holders of MOVR/GLMR tokens should perform careful due diligence on collators before delegating. Being listed as a collator is not an endorsement or recommendation from the Moonbeam Network, the Moonriver Network, or Moonbeam Foundation. Neither the Moonbeam Network, Moonriver Network, nor Moonbeam Foundation has vetted the list collators and assumes no responsibility with regard to the selection, performance, security, accuracy, or use of any third-party offerings.  You alone are responsible for doing your own diligence to understand the applicable fees and all risks present, including actively monitoring the activity of your collators.</p> <p>You agree and understand that neither the Moonbeam Network, the Moonriver Network, nor Moonbeam Foundation guarantees that you will receive staking rewards and any applicable percentage provided (i) is an estimate only and not guaranteed, (ii) may change at any time and (iii) may be more or less than the actual staking rewards you receive. The Moonbeam Foundation makes no representations as to the monetary value of any rewards at any time.</p> <p>Staking MOVR/GLMR tokens is not free of risk. Staked MOVR/GLMR tokens are locked up, and retrieving them requires a 2 day/7 day waiting period . Additionally, if a collator fails to perform required functions or acts in bad faith, a portion of their total stake can be slashed (i.e. destroyed). This includes the stake of their delegators. If a collators behaves suspiciously or is too often offline, delegators can choose to unbond from them or switch to another collator. Delegators can also mitigate risk by electing to distribute their stake across multiple collators.</p>"},{"location":"tutorials/eth-api/batch-approve-swap/","title":"Use the Batch Precompile to Approve and Swap Tokens in a Single Transaction","text":"<p>by Erin Shaben</p>"},{"location":"tutorials/eth-api/batch-approve-swap/#introduction","title":"Introduction","text":"<p>Token approvals are critical for interacting with smart contracts securely, preventing smart contracts without permission from accessing a user's tokens. When a smart contract is given approval to access a user's tokens, the amount of tokens it has access to is often an unlimited amount, depending on the DApp.</p> <p>One of the reasons why many DApps use an unlimited amount is so that users don't need to continue to sign approval transactions every time they want to move their tokens. This is in addition to the second transaction required to actually swap the tokens. For networks like Ethereum, this can be expensive. However, if the approved smart contract has a vulnerability, it could be exploited and the users' tokens could be transferred at any time without requiring further approval. In addition, if a user no longer wants the DApp's contract to have access to their tokens, they have to revoke the token approval, which requires another transaction to be sent.</p> <p>As a DApp developer on Moonbeam, you can avoid this process entirely, providing users with more control over their assets. This can be done using the batch precompile to batch an approval and swap into a single transaction, instead of the typical two transaction process. This allows for the approval amount to be the exact swap amount instead of having unlimited access to your users' tokens.</p> <p>In this tutorial, we'll dive into the process of batching an approval and swap into one transaction using the <code>batchAll</code> function of the batch precompile contract. We'll create and deploy an ERC-20 contract and a simple DEX contract for the swap on the Moonbase Alpha TestNet using Hardhat and Ethers.</p>"},{"location":"tutorials/eth-api/batch-approve-swap/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For this tutorial, you'll need the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>An empty Hardhat project that is configured for the Moonbase Alpha TestNet. For step-by-step instructions, please refer to the Creating a Hardhat Project and the Hardhat Configuration File sections of our Hardhat documentation page</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul>"},{"location":"tutorials/eth-api/batch-approve-swap/#install-dependencies","title":"Install Dependencies","text":"<p>Once you have your Hardhat project, you can install the Ethers plugin. This provides a convenient way to use the Ethers.js library to interact with the network.</p> <p>You can also install the OpenZeppelin contracts library, as we'll be importing the <code>ERC20.sol</code> contract and <code>IERC20.sol</code> interface in our contracts.</p> <p>To install the necessary dependencies, run the following command:</p> <pre><code>npm install @nomicfoundation/hardhat-ethers ethers@6 @openzeppelin/contracts\n</code></pre>"},{"location":"tutorials/eth-api/batch-approve-swap/#contracts","title":"Contract Setup","text":"<p>The following are the contracts that we'll be working with today:</p> <ul> <li> <p><code>Batch.sol</code> - one of the precompile contracts on Moonbeam that allows you to combine multiple EVM calls into one. For more information on the available methods, please refer to the Batch Solidity Interface documentation</p> </li> <li> <p><code>DemoToken.sol</code> - an ERC-20 contract for the <code>DemoToken</code> (DTOK) token, which on deployment mints an initial supply and assigns them to the contract owner. It's a standard ERC-20 token, you can review the IERC20 interface for more information on the available methods</p> </li> <li> <p><code>SimpleDex.sol</code> - a simple example of a DEX that on deployment deploys the <code>DemoToken</code> contract, which mints 1000 DTOKs, and allows you to swap DEV token for DTOKs and vice versa. This contract is for demo purposes only. The <code>SimpleDex</code> contract contains the following methods:</p> <ul> <li>token() - a read-only method that returns the address of the <code>DemoToken</code> contract</li> <li>swapDevForDemoToken() - a payable function that accepts DEV tokens in exchange for DTOK tokens. The function checks to make sure there are enough DTOK tokens held in the contract before making the transfer. After the transfer is made, a <code>Bought</code> event is emitted</li> <li>swapDemoTokenForDev(uint256 amount) - accepts the amount of DTOKs to swap for DEV tokens. The function checks to make sure the caller of the function has approved the contract to transfer their DTOKs before swapping the DTOKs back to DEV. After the transfer is made, a <code>Sold</code> event is emitted</li> </ul> </li> </ul> <p>If you don't already have a <code>contracts</code> directory in your Hardhat project, you can create a new directory:</p> <pre><code>mkdir contracts &amp;&amp; cd contracts\n</code></pre> <p>Then, you can create a single file that we'll use to store the code for the <code>DemoToken</code> and <code>SimpleDex</code> contracts and another file for the batch precompile:</p> <pre><code>touch SimpleDex.sol Batch.sol\n</code></pre> <p>In the <code>SimpleDex.sol</code> file, you can paste in the following code for the <code>DemoToken</code> and <code>SimpleDex</code> contracts:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract DemoToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"DemoToken\", \"DTOK\") {\n        // Assign 500 DTOK tokens to the SimpleDex contract\n        _mint(msg.sender, initialSupply / 2);\n        // Assign 500 DTOK tokens to the EOA that deployed the SimpleDex contract\n        _mint(tx.origin, initialSupply / 2);\n    }\n}\n\ncontract SimpleDex {\n    IERC20 public token;\n\n    event Bought(uint256 amount);\n    event Sold(uint256 amount);\n\n    // Make constructor payable so that DEV liquidity exists for the contract\n    constructor() payable {\n        // Mint 1000 DTOK tokens. Half will be assigned to the SimpleDex contract \n        // and the other half will be assigned to the EOA that deployed the\n        // SimpleDex contract\n        token = new DemoToken(1000000000000000000000);\n    }\n\n    // Function to swap DEV for DTOK tokens\n    function swapDevForDemoToken() payable public {\n        // Verify the contract has enough tokens for the requested amount\n        uint256 amountTobuy = msg.value;\n        uint256 dexBalance = token.balanceOf(address(this));\n        require(amountTobuy &gt; 0, \"You need to send some DEV\");\n        require(amountTobuy &lt;= dexBalance, \"Not enough tokens in the reserve\");\n        // If enough, swap the DEV to DTOKs\n        token.transfer(msg.sender, amountTobuy);\n        emit Bought(amountTobuy);\n    }\n\n    // Function to swap DTOK for DEV tokens\n    function swapDemoTokenForDev(uint256 amount) public {\n        // Make sure the requested amount is greater than 0 and the caller\n        // has approved the requested amount of tokens to be transferred\n        require(amount &gt; 0, \"You need to sell at least some tokens\");\n        uint256 allowance = token.allowance(msg.sender, address(this));\n        require(allowance &gt;= amount, \"Check the token allowance\");\n        // Transfer the DTOKs to the contract\n        token.transferFrom(msg.sender, address(this), amount);\n        // Transfer the DEV tokens back to the caller\n        payable(msg.sender).transfer(amount);\n        emit Sold(amount);\n    }\n}\n</code></pre> <p>In the <code>Batch.sol</code> file, you can paste in the Batch Precompile contract.</p> Batch.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Batch contract's address.\naddress constant BATCH_ADDRESS = 0x0000000000000000000000000000000000000808;\n\n/// @dev The Batch contract's instance.\nBatch constant BATCH_CONTRACT = Batch(BATCH_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Batch precompile\n/// @dev Allows to perform multiple calls through one call to the precompile.\n/// Can be used by EOA to do multiple calls in a single transaction.\n/// @custom:address 0x0000000000000000000000000000000000000808\ninterface Batch {\n    /// @dev Batch multiple calls into a single transaction.\n    /// All calls are performed from the address calling this precompile.\n    ///\n    /// In case of one subcall reverting following subcalls will still be attempted.\n    ///\n    /// @param to List of addresses to call.\n    /// @param value List of values for each subcall. If array is shorter than \"to\" then additional\n    /// calls will be performed with a value of 0.\n    /// @param callData Call data for each `to` address. If array is shorter than \"to\" then\n    /// additional calls will be performed with an empty call data.\n    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.\n    /// If array is shorter than \"to\" then the remaining gas available will be used.\n    /// @custom:selector 79df4b9c\n    function batchSome(\n        address[] memory to,\n        uint256[] memory value,\n        bytes[] memory callData,\n        uint64[] memory gasLimit\n    ) external;\n\n    /// @dev Batch multiple calls into a single transaction.\n    /// All calls are performed from the address calling this precompile.\n    ///\n    /// In case of one subcall reverting, no more subcalls will be executed but\n    /// the batch transaction will succeed. Use batchAll to revert on any subcall revert.\n    ///\n    /// @param to List of addresses to call.\n    /// @param value List of values for each subcall. If array is shorter than \"to\" then additional\n    /// calls will be performed with a value of 0.\n    /// @param callData Call data for each `to` address. If array is shorter than \"to\" then\n    /// additional calls will be performed with an empty call data.\n    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.\n    /// If array is shorter than \"to\" then the remaining gas available will be used.\n    /// @custom:selector cf0491c7\n    function batchSomeUntilFailure(\n        address[] memory to,\n        uint256[] memory value,\n        bytes[] memory callData,\n        uint64[] memory gasLimit\n    ) external;\n\n    /// @dev Batch multiple calls into a single transaction.\n    /// All calls are performed from the address calling this precompile.\n    ///\n    /// In case of one subcall reverting, the entire batch will revert.\n    ///\n    /// @param to List of addresses to call.\n    /// @param value List of values for each subcall. If array is shorter than \"to\" then additional\n    /// calls will be performed with a value of 0.\n    /// @param callData Call data for each `to` address. If array is shorter than \"to\" then\n    /// additional calls will be performed with an empty call data.\n    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.\n    /// If array is shorter than \"to\" then the remaining gas available will be used.\n    /// @custom:selector 96e292b8\n    function batchAll(\n        address[] memory to,\n        uint256[] memory value,\n        bytes[] memory callData,\n        uint64[] memory gasLimit\n    ) external;\n\n    /// Emitted when a subcall succeeds.\n    event SubcallSucceeded(uint256 index);\n\n    /// Emitted when a subcall fails.\n    event SubcallFailed(uint256 index);\n}\n</code></pre>"},{"location":"tutorials/eth-api/batch-approve-swap/#compile-deploy-contracts","title":"Compile &amp; Deploy Contracts","text":"<p>To compile the contracts, we'll go ahead and run the following Hardhat command:</p> <pre><code>npx hardhat compile\n</code></pre> npx hardhat compile Compiled 6 Solidity files successfully (evm target: paris). <p>After compilation, an <code>artifacts</code> directory is created: it holds the bytecode and metadata of the contract, which are <code>.json</code> files. It\u2019s a good idea to add this directory to the <code>.gitignore</code> file.</p> <p>Next, we can deploy the <code>SimpleDex</code> contract, which upon deployment will automatically deploy the <code>DemoToken</code> contract and mint 1000 DTOKs and assign half of them to the <code>SimpleDex</code> contract and the other half to the address that you're initiating the deployment from.</p> <p>We'll also add some initial liquidity to the contract by passing in a <code>value</code> when calling <code>deploy</code>. Since the value needs to be in Wei, we can use <code>ethers.parseEther</code> to pass in a value such as <code>\"0.5\"</code> DEV and it will convert the value to Wei for us.</p> <p>Before deploying the contract, we'll need to create the deployment script. We'll create a new directory for the script and name it <code>scripts</code> and add a new file to it called <code>deploy.js</code>:</p> <pre><code>mkdir scripts &amp;&amp; touch scripts/deploy.js\n</code></pre> <p>In the <code>deploy.js</code> script, you can paste in the following code, which will deploy the <code>SimpleDex</code> contract and print the address of the contract to the terminal upon successful deployment:</p> <pre><code>async function main() {\n  // Liquidity to add in DEV (i.e., '.5') to be converted to Wei\n  const value = ethers.parseEther('INSERT_AMOUNT_OF_DEV');\n\n  // Deploy the SimpleDex contract, which will also automatically deploy\n  // the DemoToken contract and add liquidity to the contract\n  const SimpleDex = await ethers.getContractFactory('SimpleDex',);\n  const simpleDex = await SimpleDex.deploy({ value })\n\n  // Wait for the deployment transaction to be included in a block\n  await simpleDex.waitForDeployment();\n\n   // Get and print the contract address\n  const myContractDeployedAddress = await simpleDex.getAddress();\n  console.log(`SimpleDex deployed to ${myContractDeployedAddress}`);\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre> <p>Now we can deploy the <code>SimpleDex</code> contract using the <code>run</code> command and specifying <code>moonbase</code> as the network:</p> <pre><code>npx hardhat run --network moonbase scripts/deploy.js\n</code></pre> <p>Note</p> <p>If you want to run the script in a standalone fashion using <code>node &lt;script&gt;</code>, you'll need to require the Hardhat Runtime Environment explicitly using <code>const hre = require('hardhat');</code> in the <code>deploy.js</code> file.</p> npx hardhat run --network moonbase scripts/deploy.js SimpleDex deployed to 0xA467EB6C80D4Dae4c45C5d31Ead341c34cdD1b5e <p>After a few seconds, the contract will be deployed, and you should see the address in the terminal. We'll need to use the address in the following sections to interact with the contract, so make sure you save it.</p>"},{"location":"tutorials/eth-api/batch-approve-swap/#swapping-tokens","title":"Swap Tokens","text":"<p>With the contract deployed, now we can create a script that will enable us to get started by swapping DEV tokens for DTOK tokens. Once we have the DTOKs, we can get into the approval and swap. We'll take a quick look at how the approval and swap work normally before diving into using the batch precompile to batch these transactions.</p> <p>For simplicity, we'll create a single script to handle all of the logic needed to swap DEV to DTOKs and back, called <code>swap.js</code>. We'll add this file to the <code>scripts</code> directory:</p> <pre><code>touch scripts/swap.js\n</code></pre>"},{"location":"tutorials/eth-api/batch-approve-swap/#create-contract-instances","title":"Create Contract Instances","text":"<p>We'll need to create contract instances for each of our contracts so that we can access each contract's functions. For this, we're going to use the <code>getContractAt</code> helper function of the Hardhat plugin.</p> <p>For this step, we're going to need the contract address of the <code>SimpleDex</code> contract. Then we'll be able to use the <code>SimpleDex</code> contract instance to retrieve the <code>DemoToken</code> contract address through the <code>token</code> function.</p> <p>We'll also need to add a contract instance for the batch precompile, which is located at <code>0x0000000000000000000000000000000000000808</code>.</p> <p>You can add the following code to the <code>swap.js</code> file:</p> <pre><code>const simpleDexAddress = 'INSERT_ADDRESS_OF_DEX';\n\nasync function main() {\n  // Create instance of SimpleDex.sol\n  const simpleDex = await ethers.getContractAt(\n    'SimpleDex',\n    simpleDexAddress\n  );\n\n  // Create instance of DemoToken.sol\n  const demoTokenAddress = await simpleDex.token();\n  const demoToken = await ethers.getContractAt(\n    'DemoToken',\n    demoTokenAddress\n  );\n\n  // Create instance of Batch.sol\n  const batchAddress = '0x0000000000000000000000000000000000000808';\n  const batch = await ethers.getContractAt('Batch', batchAddress);\n}\nmain();\n</code></pre>"},{"location":"tutorials/eth-api/batch-approve-swap/#add-function-to-check-balances","title":"Add Check Balances Helper Function","text":"<p>Next, we're going to create a helper function that will be used to check the balance of DTOK tokens the DEX and the signer account has. This will be particularly useful to see balance changes after the swaps are complete.</p> <p>Since the <code>DemoToken</code> contract has an ERC-20 interface, you can check the balance of DTOKs an account has using the <code>balanceOf</code> function. So, we'll call the <code>balanceOf</code> function, passing in the address of the signer and the DEX, and then print the formatted results in DTOKs to the terminal:</p> <pre><code>async function checkBalances(demoToken) {\n  // Get the signer\n  const signers = await ethers.getSigners();\n  const signer = signers[0];\n  const signerAddress = signer.address;\n\n  // Get the balance of the DEX and print it\n  const dexBalance = ethers.formatEther(\n    await demoToken.balanceOf(simpleDexAddress)\n  );\n  console.log(`Dex ${simpleDexAddress} has a balance of: ${dexBalance} DTOKs`);\n\n  // Get the balance of the signer and print it\n  const signerBalance = ethers.formatEther(\n    await demoToken.balanceOf(signer)\n  );\n  console.log(\n    `Account ${signerAddress} has a balance of: ${signerBalance} DTOKs`\n  );\n}\n</code></pre>"},{"location":"tutorials/eth-api/batch-approve-swap/#add-logic-to-swap-dtoks","title":"Approve &amp; Swap Tokens for DEV using the Batch Precompile","text":"<p>At this point, you should already have some DTOKs in your signing account, and the <code>SimpleDex</code> contract should have some DEV liquidity. If not, you can use the <code>simpleDex.swapDevForDemoToken</code> function to acquire some DTOKs and add liquidity to the DEX.</p> <p>Now, we can approve the DEX to spend some DTOK tokens on our behalf so that we can swap the DTOKs for DEVs. On Ethereum, for example, we would need to send two transactions to be able to swap the DTOKs back to DEVs: an approval and a transfer. However, on Moonbeam, thanks to the batch precompile contract, you can batch these two transactions into a single one. This allows us to set the approval amount for the exact amount of the swap.</p> <p>So instead of calling <code>demoToken.approve(spender, amount)</code> and then <code>simpleDex.swapDemoTokenForDev(amount)</code>, we'll get the encoded call data for each of these transactions and pass them into the batch precompile's <code>batchAll</code> function. To get the encoded call data, we'll use Ether's <code>interface.encodeFunctionData</code> function and pass in the necessary parameters. For example, we'll swap .2 DTOK for .2 DEV. In this case, for the approval, we can pass in the DEX address as the <code>spender</code> and set the <code>amount</code> to .2 DTOK. We'll also set the <code>amount</code> to swap as .2 DTOK. Again, we can use the <code>ethers.parseEther</code> function to convert the amount in DTOK to Wei for us.</p> <p>Once we have the encoded call data, we can use it to call the <code>batchAll</code> function of the batch precompile. This function performs multiple calls atomically, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, all subcalls will revert. The following parameters are required by the <code>batchAll</code> function:</p> <ul> <li>address[] to - an array of addresses to direct subtransactions to, where each entry is a subtransaction</li> <li>uint256[] value - an array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all the following subtransactions will default to a value of 0</li> <li>bytes[] callData - an array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all of the following subtransactions will include no call data</li> <li>uint64[] gasLimit - an array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the to array, all of the following subtransactions will have all remaining gas forwarded</li> </ul> <p>So, the first index of each array will correspond to the approval and the second will correspond to the swap.</p> <p>After the swap, we'll check the balances using the <code>checkBalances</code> function to make sure the balances have changed as expected.</p> <p>We'll update the <code>main</code> function to include the following logic:</p> <pre><code>async function main() {\n  // ...\n\n  // Parse the value to swap to Wei\n  const amountDtok = ethers.parseEther('INSERT_AMOUNT_OF_DTOK_TO_SWAP');\n\n  // Get the encoded call data for the approval and swap\n  const approvalCallData = demoToken.interface.encodeFunctionData('approve', [\n    simpleDexAddress,\n    amountDtok,\n  ]);\n  const swapCallData = simpleDex.interface.encodeFunctionData(\n    'swapDemoTokenForDev',\n    [amountDtok]\n  );\n\n  // Assemble and send the batch transaction\n  const batchAll = await batch.batchAll(\n    [demoTokenAddress, simpleDexAddress], // to address\n    [], // value of the native token to send \n    [approvalCallData, swapCallData], // call data\n    [] // gas limit\n  );\n  await batchAll.wait();\n  console.log(`Approve and swap DTOK tokens for DEV tokens: ${batchAll.hash}`);\n\n  // Check balances after the swap\n  await checkBalances(demoToken);\n}\n</code></pre> <p>So, if you set the amount to swap to be .2 DTOK, the DEX balance will increase by .2 DTOK, and the signing account's balance will decrease by .2 DTOK. The transaction hash for the swap will also be printed to the terminal, so you can use Moonscan to view more information on the transaction.</p> View the complete script <pre><code>const simpleDexAddress = 'INSERT_ADDRESS_OF_DEX';\n\nasync function checkBalances(demoToken) {\n  // Get the signer\n  const signers = await ethers.getSigners();\n  const signer = signers[0];\n  const signerAddress = signer.address;\n\n  // Get the balance of the DEX and print it\n  const dexBalance = ethers.formatEther(\n    await demoToken.balanceOf(simpleDexAddress)\n  );\n  console.log(`Dex ${simpleDexAddress} has a balance of: ${dexBalance} DTOKs`);\n\n  // Get the balance of the signer and print it\n  const signerBalance = ethers.formatEther(\n    await demoToken.balanceOf(signer)\n  );\n  console.log(`Account ${signerAddress} has a balance of: ${signerBalance} DTOKs`);\n}\n\nasync function main() {\n  // Create instance of SimpleDex.sol\n  const simpleDex = await ethers.getContractAt('SimpleDex', simpleDexAddress);\n\n  // Create instance of DemoToken.sol\n  const demoTokenAddress = await simpleDex.token();\n  const demoToken = await ethers.getContractAt('DemoToken', demoTokenAddress);\n\n  // Create instance of Batch.sol\n  const batchAddress = '0x0000000000000000000000000000000000000808';\n  const batch = await ethers.getContractAt('Batch', batchAddress);\n\n  // Parse the value to swap to Wei\n  const amountDtok = ethers.parseEther('INSERT_AMOUNT_OF_DEV_TO_SWAP');\n\n  // Get the encoded call data for the approval and swap\n  const approvalCallData = demoToken.interface.encodeFunctionData('approve', [\n    simpleDexAddress,\n    amountDtok,\n  ]);\n  const swapCallData = simpleDex.interface.encodeFunctionData(\n    'swapDemoTokenForDev',\n    [amountDtok]\n  );\n\n  const batchAll = await batch.batchAll(\n    [demoTokenAddress, simpleDexAddress], // to address\n    [], // value of the native token to send\n    [approvalCallData, swapCallData], // call data\n    [] // gas limit\n  );\n  await batchAll.wait();\n  console.log(`Approve and swap demo tokens for dev tokens: ${batchAll.hash}`);\n\n  // Check balances after the swap\n  await checkBalances(demoToken);\n}\nmain();\n</code></pre> <p>To run the script, you can use the following command:</p> <pre><code>npx hardhat run --network moonbase scripts/swap.js\n</code></pre> <p>In the terminal, you should see the following items:</p> <ul> <li>The transaction hash for the batch approval and swap</li> <li>The DEX's DTOK balance after the batch approval and swap</li> <li>Your account's DTOK balance after the batch approval and swap</li> </ul> npx hardhat run --network moonbase scripts/swap.js Approve and swap demo tokens for dev tokens: 0x56cd9777f10e76b5b98a9ff57f7db44c5c847a615955202148e56aa6221168d6 Dex 0x462830eC426E617D8DB8e3c36de34d85A7b60a2 has a balance of: 500.2 DTOKS Account Oxf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac has a balance of: 499.8 DTOKs <p>And that's it! You've successfully used the batch precompile contract to batch an approval and swap into a single transaction, allowing for the approval amount to be the exact swap amount.</p>"},{"location":"tutorials/eth-api/batch-approve-swap/#uniswap-v2-implementation","title":"Uniswap V2 Implementation","text":"<p>If we had a Uniswap V2-style DEX, the typical process for a swap would involve the router, which provides methods to safely swap assets, including the <code>swapExactTokensForETH</code> function. This function can be compared to the <code>swapDemoTokenForDev</code> function of the SimpleDex contract in the example above, where it swaps tokens in exchange for the native asset.</p> <p>Before using the <code>swapExactTokensForETH</code> function, we would first need to approve the router as the spender and specify the approved amount to spend. Then, we could use the swap function once the router has been authorized to move our assets.</p> <p>Like our previous example, this two-transaction process can be modified to batch the approval and the <code>swapExactTokensForETH</code> function into a single transaction using the batch precompile.</p> <p>This example will be based off the Uniswap V2 deployment on Moonbase Alpha. We'll approve the router to spend ERTH tokens and then swap ERTH for DEV tokens. Before diving into this example, make sure you swap some DEV for ERTH tokens on the Moonbeam-swap DApp, so that you have some ERTH to approve and swap back to DEV.</p> <p>Again, we'll use the <code>batchAll</code> function of the batch precompile. So, we'll need to get the encoded call data for the approval and the swap. To get the encoded call data, we'll use Ether's <code>interface.encodeFunctionData</code> function and pass in the necessary parameters.</p> <p>For the <code>approve(spender, amount)</code> function, we'll need to pass in the Uniswap V2 router contract as the <code>spender</code>, as well as the amount of ERTH tokens approved to spend for the <code>amount</code>.</p> <p>For the <code>swapExactTokensForETH(amountIn, amountOutMin, path, to, deadline)</code> function, we'll need to specify the amount of tokens to send, the minimum amount of output tokens that must be received so the transaction won't revert, the token addresses for the swap, the recipient of the native asset, and the deadline after which the transaction will revert. To swap ERTH to DEV, the path will be ERTH to WETH, so the path array will need to include the ERTH token address and the WETH token address: <code>[0x08B40414525687731C23F430CEBb424b332b3d35, 0xD909178CC99d318e4D46e7E66a972955859670E1]</code>.</p> <p>In addition to the ERTH and WETH addresses, to create a contract instance of the router contract, you'll also need the router address, which is <code>0x8a1932D6E26433F3037bd6c3A40C816222a6Ccd4</code>.</p> <p>The code will resemble the following:</p> <pre><code>// Define contract addresses\nconst erthTokenAddress = '0x08B40414525687731C23F430CEBb424b332b3d35';\nconst routerAddress = '0x8a1932D6E26433F3037bd6c3A40C816222a6Ccd4';\nconst wethTokenAddress = '0xD909178CC99d318e4D46e7E66a972955859670E1';\n\nasync function main() {\n  // Create contract instances for the ERTH token, the Uniswap V2 router contract,\n  // and the batch precompile\n  // ...\n\n  // Access the interface of the ERTH contract instance to get the encoded \n  // call data for the approval\n  const amountErth = ethers.parseEther('INSERT_AMOUNT_OF_ERTH_TO_SWAP');\n  const approvalCallData = earth.interface.encodeFunctionData('approve', [\n    routerAddress,\n    amountErth,\n  ]);\n\n  // Access the interface of the Uniswap V2 router contract instance to get\n  // the encoded call data for the swap\n  const swapCallData = router.interface.encodeFunctionData(\n    'swapExactTokensForETH',\n    [\n      amountErth, // amountIn\n      'INSERT_AMOUNT_OUT_MIN', // amountOutMin\n     [\n      erthTokenAddress, // ERTH token address\n      wethTokenAddress // WETH token address\n      ], // path \n     'INSERT_YOUR_ADDRESS', // to\n     'INSERT_DEADLINE' // deadline\n    ]\n  );\n\n  // Assemble and send the batch transaction\n  const batchAll = await batch.batchAll(\n    [erthTokenAddress, routerAddress], // to address\n    [], // value of the native token to send \n    [approvalCallData, swapCallData], // call data\n    [] // gas limit\n  );\n  await batchAll.wait();\n  console.log(`Approve and swap ERTH tokens for DEV tokens: ${batchAll.hash}`);\n}\nmain();\n</code></pre> <p>Note</p> <p>If you need the ABI to create a contract instance for any of the contracts in this example, all of the contracts are verified on Moonscan. So, you can search for the contract addresses on Moonscan and head to the Contract tab to get the Contract ABI.</p> <p>This will result in the approval and swap being batched into a single transaction and the transaction hash will be printed to the console. You can now adapt and apply this logic to your Uniswap V2-style application!</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/eth-api/call-permit-gasless-txs/","title":"Use the Call Permit Precompile to Send Gasless Transactions","text":"<p>by Erin Shaben</p>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#introduction","title":"Introduction","text":"<p>To interact with dApps on Moonbeam, users typically need to hold GLMR, Moonbeam's native token, in order to pay for transaction fees. This requirement creates an obstacle for dApps in terms of user experience, as a user needs to ensure they keep a balance of the native token to interact with the dApp.</p> <p>One solution to this problem is gasless transactions, also known as meta transactions. Gasless transactions are a type of transaction that does not require the user to pay for the gas required to execute the transaction. The gas for these transactions can be covered by a third-party service or it can be deducted from the user's balance of a different token, depending on the implementation. For example, a user could simply sign a message that represents the transaction to be submitted to the network, and then a third-party could submit the transaction and pay the transaction fees for the user.</p> <p>A regular transaction may have the following flow:</p> <p></p> <p>Whereas a gasless transaction may look something like this:</p> <p></p> <p>Gasless transactions can be especially beneficial for users that make small transactions frequently, as is the case with gaming dApps like Damned Pirates Society (DPS). In DPS, users go on voyages in search of treasure and with the goal of growing their fleet. There are two in-game currencies that are used in DPS: Treasure Maps (TMAP) and Doubloons (DBL). TMAP are used to buy voyages, and DBL are used to maintain flagships and buy support ships and can be earned while on voyages. Currently, if a user wants to start a voyage, they'll need TMAP to buy the voyage and GLMR to pay for transaction fees. Wouldn't it be ideal to lower the barrier to entry by implementing gasless transactions so users wouldn't need to worry about keeping a GLMR balance on top of their TMAP and DBL balances? From a dApp's perspective, it would keep users on their platform, as their users wouldn't need to leave the dApp to fund their GLMR balance; they could keep on gaming.</p> <p>Gasless transactions can be implemented using Moonbeam's Call Permit Precompile, which is a Solidity interface that allows a user to sign a permit, an EIP-712 signed message, that can then be dispatched by your dApp. The Call Permit Precompile can be used to execute any EVM call. The best part is that you don't need to modify your existing contracts!</p> <p>In this tutorial, we'll walk through the process of implementing gasless transactions in a dApp. More specifically, we'll take a closer look at how we can implement gasless transactions to buy a voyage in DPS, as an example. We'll go over building an EIP-712 signed message, signing it, and dispatching it with the Call Permit Precompile.</p>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#eip-712-signed-messages","title":"What are EIP-712 Signed Messages?","text":"<p>An EIP-712 signed message is a message that is structured, hashed, and signed in a standardized way. The benefit of the EIP-712 standardization is that message data can be displayed in a much more human-readable way for users signing these messages, so they can better understand what exactly they're signing. Before this standardization existed, users had to sign off on unreadable and difficult-to-decode hexadecimal strings, which made it easy for users to misplace their trust and sign off on messages with malicious data.</p> <p>The EIP-712 standard specifies how the message data should be structured by requiring developers to define a JSON structure of the message data that users will sign off on and specifying a domain separator. The main goal of the domain separator is to prevent replay attacks. We'll cover both of these requirements in the following sections.</p>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For this tutorial, you'll need the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li> <p>A project with Ethers installed:</p> </li> </ul>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#npm-i-ethers","title":"<pre><code>npm i ethers\n</code></pre>","text":"<p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</p>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#configure-your-project","title":"Configure your Project","text":"<p>To get started, make sure you have a project with Ethers installed, as specified in the prerequisites. To configure Ethers for Moonbeam, you'll need to:</p> <ol> <li>Import <code>ethers</code></li> <li>Define the network configurations</li> <li>Create an <code>ethers</code> provider</li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>// 1. Import ethers\nimport { ethers } from 'ethers';\n\n// 2. Define network configurations\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT', // Insert your RPC URL here\n    chainId: 1284, // 0x504 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n</code></pre> <pre><code>// 1. Import ethers\nimport { ethers } from 'ethers';\n\n// 2. Define network configurations\nconst providerRPC = {\n  moonriver: {\n    name: 'moonriver',\n    rpc: 'INSERT_RPC_API_ENDPOINT', // Insert your RPC URL here\n    chainId: 1285, // 0x505 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonriver.rpc, {\n  chainId: providerRPC.moonriver.chainId,\n  name: providerRPC.moonriver.name,\n});\n</code></pre> <pre><code>// 1. Import ethers\nimport { ethers } from 'ethers';\n\n// 2. Define network configurations\nconst providerRPC = {\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287, // 0x507 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n});\n</code></pre> <pre><code>// 1. Import ethers\nimport { ethers } from 'ethers';\n\n// 2. Define network configurations\nconst providerRPC = {\n  dev: {\n    name: 'moonbeam-development',\n    rpc: 'http://127.0.0.1:9944',\n    chainId: 1281, // 0x501 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.dev.rpc, {\n  chainId: providerRPC.dev.chainId,\n  name: providerRPC.dev.name,\n});\n</code></pre> <p>As previously mentioned, there are several ways to set up gasless transactions. For the purposes of this tutorial, we'll assume that there is a third-party account that pays the fees. As such, you'll need to have a signer for the user of the dApp, which is connected to your user's wallet, and a signer for the third-party account paying for the transaction fees. This tutorial assumes that you already have these signers in place, but if needed, you can set up the following generic signers for testing purposes:</p> <pre><code>const userSigner = new ethers.Wallet('INSERT_PRIVATE_KEY', provider);\nconst thirdPartyGasSigner = new ethers.Wallet('INSERT_PRIVATE_KEY', provider);\n</code></pre> <p>Remember</p> <p>Never store your private keys in a JavaScript or TypeScript file.</p> <p>Now that we've set up the initial configurations, let's dive into building the EIP-712 signed message.</p>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#build-an-eip-712-signed-message","title":"Build an EIP-712 Typed Message","text":"<p>There are three components that we'll need to build an EIP-712 typed message: the domain separator, the typed data structure for the data that users will sign, and the actual message data.</p> <p>The domain separator and the typed data structure will be based on the Call Permit Precompile. The steps to build both of these components will always be the same, regardless of the data that is being signed. The actual message data will change depending on your individual use case.</p>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#define-domain-separator","title":"Define the Domain Separator","text":"<p>We'll first start off with the domain separator, which will define the Call Permit Precompile as the signing domain. Permits will get dispatched by calling the <code>dispatch</code> function of the Call Permit Precompile, which is why the Call Permit Precompile is always going to be the signing domain. As previously mentioned, the goal of the domain separator is to avoid replay attacks. </p> <p>The domain separator is defined in the EIP-712 standard and is calculated as:</p> <pre><code>keccak256(PERMIT_DOMAIN, name, version, chain_id, address)\n</code></pre> <p>The parameters of the hash can be broken down as follows:</p> <ul> <li>PERMIT_DOMAIN - is the <code>keccak256</code> of <code>EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)</code></li> <li>name - is the name of the signing domain and must be <code>'Call Permit Precompile'</code> exactly</li> <li>version - is the version of the signing domain. For this case version is set to <code>1</code></li> <li>chainId - is the chain ID of the network</li> <li>verifyingContract - is the address of the contract that will verify the signature. In this case, the Call Permit Precompile address</li> </ul> <p>We're using Ethers in this example, which requires the domain separator to be in the format specified by the <code>TypedDataDomain</code> interface, but if desired, you could generate the domain separator as a bytes32 representation using the <code>DOMAIN_SEPARATOR()</code> function of the Call Permit Precompile.</p> <p>The domain separator for each Moonbeam network is as follows:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>const domain = {\n  name: 'Call Permit Precompile',\n  version: '1',\n  chainId: 1284,\n  verifyingContract: '0x000000000000000000000000000000000000080a',\n};\n</code></pre> <pre><code>const domain = {\n  name: 'Call Permit Precompile',\n  version: '1',\n  chainId: 1285,\n  verifyingContract: '0x000000000000000000000000000000000000080a',\n};\n</code></pre> <pre><code>const domain = {\n  name: 'Call Permit Precompile',\n  version: '1',\n  chainId: 1287,\n  verifyingContract: '0x000000000000000000000000000000000000080a',\n};\n</code></pre> <pre><code>const domain = {\n  name: 'Call Permit Precompile',\n  version: '1',\n  chainId: 1281,\n  verifyingContract: '0x000000000000000000000000000000000000080a',\n};\n</code></pre>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#define-typed-data-structure","title":"Define the Typed Data Structure","text":"<p>Next, we'll need to define the typed data structure. The typed data structure defines the acceptable types of data that our users will be signing. We'll go into detail on the actual data in the following section.</p> <p>If you take a look at the <code>dispatch</code> function of the Call Permit Precompile, you'll see that the data that we need to send, along with the associated types, is as follows:</p> <pre><code>function dispatch(\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    uint64 gaslimit,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n) external returns (bytes memory output);\n</code></pre> <p>We'll need to add each of the above parameters to our typed data structure, with a couple of modifications. We don't need to include the signature-related parameters, but we do need to include a parameter for the <code>nonce</code> of the <code>from</code> account, which will be a uint256. The signature-related parameters aren't needed at this point because we're building the message data for the users to sign. We'll circle back to the signature-related parameters after we've finished building the message and requested the signature.</p> <p>So, if we grab the rest of the parameters, we can start to build our data structure. Some implementations of EIP-712 require a type for <code>EIP712Domain</code> to be specified, but this is not the case when using Ethers as it computes it for you! For our implementation, the only type we'll need is the <code>CallPermit</code> type. The <code>CallPermit</code> type will be an array of objects that correspond to each of the parameters and define the <code>name</code> and <code>type</code> for each one:</p> <pre><code>const types = {\n  CallPermit: [\n    { name: 'from', type: 'address' },\n    { name: 'to', type: 'address' },\n    { name: 'value', type: 'uint256' },\n    { name: 'data', type: 'bytes' },\n    { name: 'gaslimit', type: 'uint64' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'deadline', type: 'uint256' },\n  ],\n};\n</code></pre>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#define-message-data","title":"Define the Message Data","text":"<p>Since we are going to implement gasless transactions for buying a voyage, we're going to be interacting with the Cartographer V1 contract, which is located at this address: <code>0xD1A9bA3e61Ac676f58B29EA0a09Cf5D7f4f35138</code> on Moonbeam.</p> <p>So, let's start by going over the arguments required to build the message data:</p> <ul> <li><code>from</code> - your user's address, which you can easily get from your user's Ethers signer using <code>signer.address</code></li> <li><code>to</code> - the contract address that you want to interact with. For this example, we'll use the address of DPS's Cartographer V1 contract</li> <li><code>value</code> - the value to be transferred from the <code>from</code> account. This will be <code>0</code> as TMAP are used to buy voyages, not GLMR</li> <li><code>data</code> - the calldata to be executed, which we'll calculate in the following steps</li> <li><code>gaslimit</code>- the gas limit the call requires</li> <li><code>nonce</code> - the nonce of the <code>from</code> account. This isn't your standard nonce, but the nonce for permits dispatched through the Call Permit Precompile specifically. To get this nonce, you can call the Call Permit Precompile's <code>nonces</code> function and pass in the address of the <code>from</code> account</li> <li><code>deadline</code> - the deadline in UNIX seconds after which the permit will expire and no longer be valid</li> </ul> <p>The message will resemble the following:</p> <pre><code>const message = {\n  from: userSigner.address,\n  to: '0xD1A9bA3e61Ac676f58B29EA0a09Cf5D7f4f35138', // Cartographer V1 contract\n  value: 0,\n  data: 'TODO: Calculate the data that will buy a voyage',\n  gaslimit: 'TODO: Estimate the gas',\n  nonce: 'TODO: Use the Call Permit Precompile to get the nonce of the from account',\n  deadline: '1714762357000', // Randomly created deadline in the future\n};\n</code></pre> <p>Now, let's dig a little bit deeper and tackle the <code>TODO</code> items.</p>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#encoded-call-data-buying-voyage","title":"Get the Encoded Call Data for Buying a Voyage","text":"<p>We'll start off by calculating the <code>data</code> value. We can programmatically calculate the <code>data</code> value with Ethers by creating an interface of the Cartographer V1 contract and using the <code>interface.encodeFunctionData</code> function.</p> <p>If you take a look at the <code>DPSCartographer.sol</code> contract's code, you'll see the <code>buyVoyages</code> function. The <code>buyVoyages</code> function accepts three parameters:</p> <ul> <li>uint16 <code>_voyageType</code> - specifies the type of voyage to buy, i.e., easy, medium, hard, etc. This value corresponds to the index of the voyage in the <code>VOYAGE_TYPE</code> enum. For this example, we'll do an easy voyage, so we'll pass in <code>0</code> as the value</li> <li>uint256 <code>_amount</code> - corresponds to the number of voyages to buy. We'll buy one voyage</li> <li>DPSVoyageIV2 <code>_voyage</code> - represents the address of the <code>DPSVoyageV2.sol</code> contract, which is: <code>0x72A33394f0652e2Bf15d7901f3Cd46863d968424</code> on Moonbeam</li> </ul> <p>To create an interface using Ethers, we'll need to get the ABI of the Cartographer V1 contract. You can retrieve it in full from Moonscan, or for simplicity, you can use the following snippet, which is the part of the ABI we need for this example:</p> <pre><code>const cartographerAbi = [\n  {\n    inputs: [\n      { internalType: 'uint16', name: '_voyageType', type: 'uint16' },\n      { internalType: 'uint256', name: '_amount', type: 'uint256' },\n      {\n        internalType: 'contract DPSVoyageIV2',\n        name: '_voyage',\n        type: 'address',\n      },\n    ],\n    name: 'buyVoyages',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> <p>Then we can create the interface using the ABI and get the encoded data using the values we specified for each of the parameters of the <code>buyVoyages</code> function:</p> <pre><code>const cartographerInterface = new ethers.Interface(cartographerAbi);\nconst data = cartographerInterface.encodeFunctionData('buyVoyages', [\n  0n, // Voyage type: Easy\n  1n, // Number of voyages to buy\n  '0x72A33394f0652e2Bf15d7901f3Cd46863d968424', // Voyage V2 contract\n]);\n</code></pre> <p>This will provide us with the following value for <code>data</code>:</p> <pre><code>'0xdb76d5b30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000072a33394f0652e2bf15d7901f3cd46863d968424'\n</code></pre>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#estimate-gas-buy-voyage","title":"Estimate the Gas Required to Buy a Voyage","text":"<p>Now that we have the encoded call data for buying a voyage, we can use it to estimate the gas required for the transaction. We'll use the <code>estimateGas</code> method and pass in the user's address, the address of the Cartographer V1 contract, and the encoded call data:</p> <pre><code>const gasEstimate = await provider.estimateGas({\n  from: userSigner.address,\n  to: '0xD1A9bA3e61Ac676f58B29EA0a09Cf5D7f4f35138', // Cartographer V1 contract\n  data,\n})\n</code></pre> <p>Note</p> <p>For this example, you'll need to have a balance of at least 1 TMAP to be able to estimate the gas. Otherwise, you'll get a <code>'VM Exception while processing transaction: revert'</code> error.</p> <p>We'll add a little bit of a buffer to the <code>gasEstimate</code> value and set it as the <code>gaslimit</code>:</p> <pre><code>const message = {\n  ...\n  gaslimit: gasEstimate + 50000n,\n  ...\n}\n</code></pre> <p>We'll get the nonce in the next section, and then put all of the arguments together, and the message data will be complete.</p>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#get-signers-nonce","title":"Get the Signer's Nonce Using the Call Permit Precompile","text":"<p>Lastly, we'll need to get the <code>nonce</code> of the <code>from</code> account. As previously mentioned, we can use the <code>nonces</code> function of the Call Permit Precompile to get this value. To do so, you'll need to create a contract instance for the Call Permit Precompile:</p> <ol> <li>Create a new file in your project that contains the ABI of the Call Permit Precompile. You can find the ABI on GitHub</li> <li>Import the ABI into your Ethers file</li> <li>Create an instance of the Call Permit Precompile using the precompile's address and the ABI of the precompile. You can use either a provider or a signer. Since we are dispatching the permit later on in this tutorial, we'll use the signer associated with the third-party account for transaction fees, but if you only needed to access the <code>nonces</code> function, you could use a provider instead</li> <li>Call the <code>nonces</code> function and pass in the <code>signer.account</code> of the user, which is the same as the <code>from</code> account</li> </ol> <pre><code>...\nimport abi from './callPermitABI.js'\n\n...\n\nconst callPermit = new ethers.Contract(\n  '0x000000000000000000000000000000000000080a', \n  abi, \n  thirdPartyGasSigner,\n);\n\nconst nonce = await callPermit.nonces(userSigner.address);\n</code></pre> View the script so far <pre><code>import { ethers } from 'ethers';\nimport abi from './callPermitABI.js'\nimport cartographerAbi from './cartographerAbi.js'\n\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT', // Insert your RPC URL here\n    chainId: 1284, // 0x504 in hex,\n  },\n};\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n\n// Insert your own signer logic or use the following for testing purposes\nconst userSigner = new ethers.Wallet('INSERT_PRIVATE_KEY', provider);\nconst thirdPartyGasSigner = new ethers.Wallet('INSERT_PRIVATE_KEY', provider);\n\nconst domain = {\n  name: 'Call Permit Precompile',\n  version: '1',\n  chainId: 1284,\n  verifyingContract: '0x000000000000000000000000000000000000080a',\n};\n\nconst types = {\n  CallPermit: [\n    { name: 'from', type: 'address' },\n    { name: 'to', type: 'address' },\n    { name: 'value', type: 'uint256' },\n    { name: 'data', type: 'bytes' },\n    { name: 'gaslimit', type: 'uint64' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'deadline', type: 'uint256' },\n  ],\n};\n\nconst cartographerInterface = new ethers.Interface(cartographerAbi);\nconst data = cartographerInterface.encodeFunctionData('buyVoyages', [\n  0n, // Voyage type: Easy\n  1n, // Number of voyages to buy\n  '0x72A33394f0652e2Bf15d7901f3Cd46863d968424', // Voyage V2 contract\n]);\n\nconst gasEstimate = await provider.estimateGas({\n  from: userSigner.address,\n  to: '0xD1A9bA3e61Ac676f58B29EA0a09Cf5D7f4f35138', // Cartographer V1 contraact\n  data,\n})\n\nconst callPermit = new ethers.Contract(\n  '0x000000000000000000000000000000000000080a', \n  abi, \n  thirdPartyGasSigner,\n);\n\nconst nonce = await callPermit.nonces(userSigner.address);\n\nconst message = {\n  from: userSigner.address,\n  to: '0xD1A9bA3e61Ac676f58B29EA0a09Cf5D7f4f35138', // Cartographer V1 contract\n  value: 0,\n  data,\n  gaslimit: gasEstimate + 50000n,\n  nonce,\n  deadline: '1714762357000', // Randomly created deadline in the future\n};\n</code></pre> <p>Remember</p> <p>Never store your private keys in a JavaScript or TypeScript file.</p> <p>So far, we've created the domain separator, defined the data structure of our EIP-712 message, and assembled the data for the message. Next, we'll need to request the signature for our EIP-712 typed message!</p>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#use-ethers-to-sign-eip712-messages","title":"Get Signature for EIP-712 Typed Messages","text":"<p>For this next step, we're going to use our Ethers signer and the <code>signer.signTypedData</code> function to prompt our users to sign the EIP-712 typed message we've assembled. This signature will allow the third-party account for transaction fees to call the <code>dispatch</code> function of the Call Permit Precompile. The third-party account will pay the transaction fees for us, and a voyage will be bought on our behalf!</p> <p>The <code>signTypedData</code> function will calculate a signature for our data using the following calculation:</p> <pre><code>sign(keccak256(\"\\x19\\x01\" \u2016 domainSeparator \u2016 hashStruct(message)))\n</code></pre> <p>The components of the hash can be broken down as follows:</p> <ul> <li>\\x19 - makes the encoding deterministic</li> <li>\\x01 - the version byte, which makes the hash compliant with EIP-191</li> <li>domainSeparator - the 32-byte domain separator, which was previously covered and can be easily retrieved using the <code>DOMAIN_SEPARATOR</code> function of the Call Permit Precompile</li> <li>hashStruct(message) - the 32-byte data to sign, which is based on the typed data structure and the actual data. For more information, please refer to the EIP-712 specification</li> </ul> <p>Now that we have an understanding of what the <code>signTypedData</code> function does, we can go ahead and pass in the data we've assembled in the previous sections:</p> <pre><code>const signature = await signer.signTypedData(\n  domain, // The domain separator\n  types, // The typed data structure\n  message, // The message data\n);\nconsole.log(`Signature hash: ${signature}`);\n</code></pre> <p>A hash of the signature will print to the terminal. We'll use the user's signature to dispatch the permit from the third-party account using the Call Permit Precompile's <code>dispatch</code> function in the next section.</p>"},{"location":"tutorials/eth-api/call-permit-gasless-txs/#dispatch-eip712-message","title":"Dispatch a Signed EIP-712 Message","text":"<p>Before an EIP-712 signed message can be dispatched, we'll need to get the signature-related parameters, <code>v</code>, <code>r</code>, and <code>s</code>, from the signed message. The <code>signTypedData</code> function returned a hex string that contains each of these values, but to easily get these values individually, we're going to use Ethers' <code>Signature.from</code> function. This will create a new instance of Ether's Signature class, which will allow us to easily grab the <code>v</code>, <code>r</code>, and <code>s</code> values that we need in order to use the <code>dispatch</code> function.</p> <pre><code>const formattedSignature = ethers.Signature.from(signature);\n</code></pre> <p>Now that we can individually access the <code>v</code>, <code>r</code>, and <code>s</code> arguments needed to dispatch the permit, we can call the <code>dispatch</code> function of the Call Permit Precompile. The arguments passed to the <code>dispatch</code> function must be the exact same arguments that were passed in for the <code>value</code> parameter of the <code>signTypedData</code> function. You'll send the following function using an account associated with your dApp as the signer (not the signer associated with the user), and it will dispatch the permit that the user signed:</p> <pre><code>const dispatch = await callPermit.dispatch(\n  message.from,\n  message.to,\n  message.value,\n  message.data,\n  message.gaslimit,\n  message.deadline,\n  formattedSignature.v,\n  formattedSignature.r,\n  formattedSignature.s,\n);\n\nawait dispatch.wait();\nconsole.log(`Transaction hash: ${dispatch.hash}`);\n</code></pre> View the complete script <pre><code>import { ethers } from 'ethers';\nimport abi from './callPermitABI.js';\nimport cartographerAbi from './cartographerAbi.js';\n\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT', // Insert your RPC URL here\n    chainId: 1284, // 0x504 in hex,\n  },\n};\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n\n// Insert your own signer logic or use the following for testing purposes.\n// For demo purposes only. Never store your private keys in a JavaScript file\nconst userSigner = new ethers.Wallet('INSERT_PRIVATE_KEY', provider);\nconst thirdPartyGasSigner = new ethers.Wallet('INSERT_PRIVATE_KEY', provider);\n\nconst domain = {\n  name: 'Call Permit Precompile',\n  version: '1',\n  chainId: 1284,\n  verifyingContract: '0x000000000000000000000000000000000000080a',\n};\n\nconst types = {\n  CallPermit: [\n    { name: 'from', type: 'address' },\n    { name: 'to', type: 'address' },\n    { name: 'value', type: 'uint256' },\n    { name: 'data', type: 'bytes' },\n    { name: 'gaslimit', type: 'uint64' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'deadline', type: 'uint256' },\n  ],\n};\n\nconst cartographerInterface = new ethers.Interface(cartographerAbi);\nconst data = cartographerInterface.encodeFunctionData('buyVoyages', [\n  0n, // Voyage type: Easy\n  1n, // Number of voyages to buy\n  '0x72A33394f0652e2Bf15d7901f3Cd46863d968424', // Voyage V2 contract\n]);\n\nconst gasEstimate = await provider.estimateGas({\n  from: userSigner.address,\n  to: '0xD1A9bA3e61Ac676f58B29EA0a09Cf5D7f4f35138', // Cartographer V1 contract\n  data,\n});\n\nconst callPermit = new ethers.Contract(\n  '0x000000000000000000000000000000000000080a', // Call Permit contract\n  abi,\n  thirdPartyGasSigner\n);\n\nconst nonce = await callPermit.nonces(userSigner.address);\n\nconst message = {\n  from: userSigner.address,\n  to: '0xD1A9bA3e61Ac676f58B29EA0a09Cf5D7f4f35138', // Cartographer V1 contract\n  value: 0,\n  data,\n  gaslimit: gasEstimate + 50000n,\n  nonce,\n  deadline: '1714762357000', // Randomly created deadline in the future\n};\n\nconst signature = await userSigner.signTypedData(domain, types, message);\nconsole.log(`Signature hash: ${signature}`);\n\nconst formattedSignature = ethers.Signature.from(signature);\n\n// This gets dispatched using the dApps signer\nconst dispatch = await callPermit.dispatch(\n  message.from,\n  message.to,\n  message.value,\n  message.data,\n  message.gaslimit,\n  message.deadline,\n  formattedSignature.v,\n  formattedSignature.r,\n  formattedSignature.s\n);\n\nawait dispatch.wait();\nconsole.log(`Transaction hash: ${dispatch.hash}`);\n</code></pre> <p>Remember</p> <p>Never store your private keys in a JavaScript or TypeScript file.</p> <p>Once the transaction goes through, the gas fees will be deducted from the GLMR balance of the third-party account, 1 TMAP will be deducted from the user's balance, and a voyage will be purchased on behalf of the user. As you can see, the user doesn't need to worry about having a GLMR balance!</p> <p>You can view the transaction for the example that we covered in this guide on Moonscan. You'll notice the following:</p> <ul> <li>The <code>from</code> account is the third-party account: <code>0xd0ccb8d33530456f1d37e91a6ef5503b5dcd2ebc</code></li> <li>The contract interacted with is the Call Permit Precompile: <code>0x000000000000000000000000000000000000080a</code></li> <li>A TMAP has been deducted from the user's account: <code>0xa165c7970886d4064b6cec9ab1db9d03202bda37</code></li> <li>A voyage with ID 622646 has been sent to the user's account</li> </ul> <p></p> <p>And that's it! Congrats! You've learned how to implement gasless transactions using the Call Permit Precompile on Moonbeam. You can now adapt the logic in this tutorial for your own dApp!</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/eth-api/chat-gpt/","title":"Using GPT-4 to Write and Debug Solidity Smart Contracts","text":"<p>by Kevin Neilson</p>"},{"location":"tutorials/eth-api/chat-gpt/#introduction","title":"Introduction","text":"<p>Today, it's near impossible to walk down the street and not overhear a conversation about the transformative impact of generative AI. Of course, this applies to both the physical and virtual world (e.g., Twitter). You've probably heard by now that artificial intelligence tools like ChatGPT can plan your vacation, draft an essay, and tell you a joke. But did you know that ChatGPT can even write working Solidity code for you? And, it doesn't just return a <code>.sol</code> file to you without any context. It can actually explain to you how the code is structured, walk you through deployment steps, and, drumroll, even write your test files for you. Yup, that's right. No more excuses for a lack of test coverage when ChatGPT can take care of that for you.</p> <p>In this tutorial, we'll look at how ChatGPT can help you write, deploy, and debug Solidity smart contracts. But first, let's dive a bit more into what ChatGPT is exactly.</p>"},{"location":"tutorials/eth-api/chat-gpt/#an-overview-of-chatgpt","title":"An Overview of ChatGPT","text":""},{"location":"tutorials/eth-api/chat-gpt/#what-is-chatgpt","title":"What is ChatGPT?","text":"<p>ChatGPT is a text-based Large Language Model (LLM) created by the company OpenAI. According to OpenAI, \"The dialogue format makes it possible for ChatGPT to answer followup questions, admit its mistakes, challenge incorrect premises, and reject inappropriate requests.\" ChatGPT can hold a conversation with you and remember your chat history until a new session is started. To learn more about ChatGPT, check out this introduction to ChatGPT on the OpenAI Blog.</p>"},{"location":"tutorials/eth-api/chat-gpt/#gpt-4-vs-chatgpt","title":"GPT-4 vs. ChatGPT","text":"<p>As of the time of writing, GPT-4 was the latest version offered as part of the ChatGPT Plus subscription service, available at a cost of $20 USD per month. While GPT-4 is a paid service, you can follow this same tutorial using the free tiers of service available in earlier versions. GPT-4 is a significantly more advanced model, so you may notice differences in response quality from earlier versions, particularly in the model's reasoning at the debugging steps.</p>"},{"location":"tutorials/eth-api/chat-gpt/#limitations","title":"Limitations","text":"<ul> <li>At the time of writing, ChatGPT is in a research preview state</li> <li>ChatGPT can sometimes hallucinate, that is, output convincing and plausible-sounding answers that are factually incorrect. In such cases, it typically will not warn you of the inaccuracy</li> <li>ChatGPT's knowledge date cutoff is approximately September 2021. It does not have access to current events or other data after this date</li> <li>Code produced by ChatGPT is not audited, reviewed, or verified and may contain errors</li> <li>Prompting GPT-4 with the exact inputs specified in this tutorial will likely produce different outputs - that is expected due to ChatGPT's architecture as a language model</li> </ul> <p>Please note that the contracts we'll be creating today are for educational purposes only and should not be used in a production environment.</p>"},{"location":"tutorials/eth-api/chat-gpt/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For this tutorial, you'll need the following:</p> <ul> <li>A free OpenAI account to access ChatGPT</li> <li>An account funded with DEV tokens to be used on the Moonbase Alpha TestNet if you'd like to deploy any resulting contracts.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"tutorials/eth-api/chat-gpt/#sign-up-for-an-openai-account","title":"Sign up for an OpenAI Account","text":"<p>You can sign up for a free account to access ChatGPT by heading to OpenAI's website. You'll need to provide both an email address and a phone number. A subscription to ChatGPT Plus is not required to complete this tutorial.</p> <p></p>"},{"location":"tutorials/eth-api/chat-gpt/#create-an-erc-20-token-contract","title":"Create an ERC-20 Token Contract","text":"<p>To start interacting with ChatGPT, take the following steps:</p> <ol> <li>Press New Chat in the upper left hand corner</li> <li>Select the model you would like to use. Either model is suitable for this tutorial</li> <li>Enter your prompt and at the input box and press enter when ready</li> </ol> <p></p> <p>For our first prompt, we'll ask ChatGPT to create an ERC-20 token, specifying the name of the token, the token symbol, and an initial supply. Your prompt doesn't need to match the one below - feel free to tailor it to suit your preferences.</p> <pre><code>I would like to create an ERC-20 token called \"KevinToken\" \nwith the symbol \"KEV\" and an initial supply of 40000000.\n</code></pre> <p></p> <p>This is a great start. ChatGPT has produced for us a simple yet functional ERC-20 token that meets all of the parameters that we have specified. It also clarified how it created the ERC-20 token contract using the OpenZeppelin standard and where the initial token supply is directed. Finally, it reminds us that this is just a start, and there may be other considerations we wish to implement, like minting and burning.</p> <p>Note</p> <p>If you don't get the output you're expecting, you can always press Regenerate Response or re-phrase your request.</p> <p>ChatGPT is perfectly happy to revise and expand upon the contract that was created. As long as you stay within the same chat window (i.e., don't click new chat), ChatGPT will be aware of its prior output. As an example, let's now ask ChatGPT to revise our token to be both mintable and burnable:</p> <pre><code>This looks great, but I'd really like my ERC-20 to be both mintable and burnable. \n</code></pre> <p>ChatGPT is happy to oblige. Notice how it maintains the parameters we specified originally, namely the token name and symbol.</p> <p></p>"},{"location":"tutorials/eth-api/chat-gpt/#preparing-deployment-instructions","title":"Preparing Deployment Instructions","text":"<p>This section is named carefully to avoid implying that ChatGPT will be doing the deployment for us. ChatGPT does not have internet access and cannot interact with blockchain networks directly, but it can give us detailed instructions explaining how we can do so ourselves. Let's ask ChatGPT for instructions on deploying the recently created ERC20 contract. For this example, let's ask ChatGPT for Hardhat deployment instructions:</p> <pre><code>I would like to use Hardhat to compile and deploy\n this smart contract to the Moonbase Alpha network.  \n</code></pre> <p></p> <p>And to no surprise, ChatGPT provides us with a detailed series of deployment steps, from installation instructions to a full deployment script. Note that it even remembers a detail in our first prompt that wasn't important until now. In our initial prompt, we asked for our token to have an initial supply of <code>400000000</code>, and ChatGPT included this parameter in the deployment script it generated.</p> <p>Another observation is that the RPC URL it generated is outdated, although still functional. This oversight is due to ChatGPT's knowledge cutoff date of September 2021, before the updated RPC URL was published. The current RPC URL for Moonbase Alpha is:</p> <pre><code>https://rpc.api.moonbase.moonbeam.network\n</code></pre> <p>Note</p> <p>ChatGPT's knowledge date cutoff is approximately September 2021. It does not have access to current events or other data after this date.</p> <p>Code snippets of ChatGPT's output are intentionally omitted to encourage you to try this on your own! And remember, prompting it with the exact same instructions will yield at least slightly different results - this is an inherent quality of LLMs.</p>"},{"location":"tutorials/eth-api/chat-gpt/#writing-test-cases","title":"Writing Test Cases","text":"<p>By now, you're nearly a ChatGPT savant. So it should come as no surprise that ChatGPT's capabilities extend to writing test cases for your smart contracts, and all you need to do is ask:</p> <pre><code>Hey GPT4 can you help me write some tests for the smart contract above?  \n</code></pre> <p></p> <p>ChatGPT provides us with a slew of test cases, especially surrounding the mint and burn functionality. While it's busy writing test cases, it appears to trail off and stop without its typical summary remarks at the end. This interruption stems from ChatGPT's 500-word limit. Although the 500-word limit is a hard stop, ChatGPT's train of thought continues, so you can simply ask it to continue, and it will happily oblige. Note that for subscriptions with limited messages, this will count as an additional message from your allocation.</p> <p>Note</p> <p>ChatGPT has a response limit of approximately 500 words or 4,000 characters. However, you can simply ask it to continue in a follow up message.</p> <p></p> <p>And Voila! ChatGPT finishes writing its test cases for us and wraps up by telling us how we can run them.</p>"},{"location":"tutorials/eth-api/chat-gpt/#debugging","title":"Debugging","text":"<p>So far, we've covered that ChatGPT can write smart contracts for you AND help you deploy and test them. What's more, it can also help you debug your smart contracts. You can share your problems with ChatGPT, and it will help you find what's wrong.</p> <p>If the problem is clear, ChatGPT will typically tell you exactly what's wrong and how to fix it. In other cases, where there could be multiple underlying reasons for the issue you're facing, ChatGPT will suggest a list of potential fixes.</p> <p>If you try all of the steps it recommends and your issue persists, you can simply let ChatGPT know, and it will continue to help you troubleshoot. As a follow-up, it may ask you to provide code snippets or system configuration information to better help you solve the problem at hand.</p> <p>A reentrancy bug was the root of the flaw that brought down the original DAO on Ethereum in 2016. Let's prompt ChatGPT with a buggy function that includes a reentrancy vulnerability and see if ChatGPT is able to spot the problem. We'll go ahead and copy and paste the below insecure code snippet into ChatGPT and ask if there is anything wrong with it.</p> <pre><code>// INSECURE\nmapping (address =&gt; uint) private userBalances;\n\nfunction withdrawBalance() public {\n    uint amountToWithdraw = userBalances[msg.sender];\n    (bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\"); // At this point, the caller's code is executed, and can call withdrawBalance again\n    require(success);\n    userBalances[msg.sender] = 0;\n}\n</code></pre> <p></p> <p>ChatGPT spots the exact error, explains the source of the problem, and lets us know how to fix it.</p>"},{"location":"tutorials/eth-api/chat-gpt/#advanced-prompt-engineering","title":"Advanced Prompt Engineering","text":"<p>Prompt engineering is both an art and a science, and mastering it can help you get the most out of generative AI tools like ChatGPT. While not an exhaustive list, here are some general concepts that can help you write better prompts:</p> <ul> <li>Be specific and parameterize your request. The more detail you can provide to ChatGPT, the more closely the actual output will match what you desire</li> <li>Don't be afraid of revisions! You don't need to repeat the whole prompt, you can ask for just the change and ChatGPT will revise its prior output accordingly</li> <li>Consider repeating or rephrasing critical parts of the prompt. Some research has indicated that LLMs will emphasize components that you repeat. You can always finish a prompt by reiterating the most important concepts you'd like addressed</li> </ul> <p>For more information, be sure to check out this post on advanced prompt engineering from Microsoft.</p>"},{"location":"tutorials/eth-api/chat-gpt/#conclusion","title":"Conclusion","text":"<p>As you can see, ChatGPT can help you with just about every step of the smart contract development process. It can help you write, deploy, and debug your Solidity smart contracts for Moonbeam. Despite the powerful capabilities of LLMs like ChatGPT, it's clear that this is only the beginning of what the technology has to offer.</p> <p>It's important to remember that ChatGPT can only act as an aid to a developer and cannot fulfill any sort of audit or review. Developers must be aware that generative AI tools like ChatGPT can produce inaccurate, buggy, or non-working code. Any code produced in this tutorial is for demonstration purposes only and should not be used in a production environment.  </p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/eth-api/foundry-start-to-end/","title":"Using Foundry Start to End with Moonbeam","text":"<p>by Jeremy Boetticher</p>"},{"location":"tutorials/eth-api/foundry-start-to-end/#introduction","title":"Introduction","text":"<p>Foundry has become an increasingly popular development environment for smart contracts because it requires only one language: Solidity. Moonbeam offers introductory documentation on using Foundry with Moonbeam networks, which is recommended to read to get an introduction to using Foundry. In this tutorial, we will dip our toes deeper into the library to get a more cohesive look at properly developing, testing, and deploying with Foundry.  </p> <p>In this demonstration, we will deploy two smart contracts. One is a token, and the other will depend on that token. We will also write unit tests to ensure the contracts work as expected. To deploy them, we will write a script that Foundry will use to determine the deployment logic. Finally, we will verify the smart contracts on Moonbeam's blockchain explorer.</p>"},{"location":"tutorials/eth-api/foundry-start-to-end/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you will need the following:</p> <ul> <li>Have an account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> <li>Have Foundry installed</li> <li>Have an Etherscan API Key</li> </ul>"},{"location":"tutorials/eth-api/foundry-start-to-end/#create-a-foundry-project","title":"Create a Foundry Project","text":"<p>The first step to start a Foundry project is, of course, to create it. If you have Foundry installed, you can run:</p> <pre><code>forge init foundry &amp;&amp; cd foundry\n</code></pre> <p>This will have the <code>forge</code> utility initialize a new folder named <code>foundry</code> with a Foundry project initialized within it. The <code>script</code>, <code>src</code>, and <code>test</code> folders may have files in them already. Be sure to delete them, because we will be writing our own soon.  </p> <p>From here, there are a few things to do first before writing any code. First, we want to add a dependency to OpenZeppelin's smart contracts, because they include helpful contracts to use when writing token smart contracts. To do so, add them using their GitHub repository name:  </p> <pre><code>forge install OpenZeppelin/openzeppelin-contracts\n</code></pre> <p>This will add the OpenZeppelin git submodule to your <code>lib</code> folder. To be sure that this dependency is mapped, you can override the mappings in a special file, <code>remappings.txt</code>:  </p> <pre><code>forge remappings &gt; remappings.txt\n</code></pre> <p>Every line in this file is one of the dependencies that can be referenced in the project's smart contracts. Dependencies can be edited and renamed so that it's easier to reference different folders and files when working on smart contracts. It should look similar to this with OpenZeppelin installed properly:</p> <pre><code>ds-test/=lib/forge-std/lib/ds-test/src/\nforge-std/=lib/forge-std/src/\nopenzeppelin-contracts/=lib/openzeppelin-contracts/\n</code></pre> <p>Finally, let's open up the <code>foundry.toml</code> file. In preparation for Etherscan verification and deployment, add this to the file:</p> <pre><code>[profile.default]\nsrc = 'src'\nout = 'out'\nlibs = ['lib']\nsolc_version = '0.8.20'\n\n[rpc_endpoints]\nmoonbase = \"https://rpc.api.moonbase.moonbeam.network\"\nmoonbeam = \"INSERT_RPC_API_ENDPOINT\"\n\n[etherscan]\nmoonbase = { key = \"${MOONSCAN_API_KEY}\" }\nmoonbeam = { key = \"${MOONSCAN_API_KEY}\" }\n</code></pre> <p>The first addition is a specification of the <code>solc_version</code>, underneath <code>profile.default</code>. The <code>rpc_endpoints</code> tag allows you to define which RPC endpoints to use when deploying to a named network, in this case, Moonbase Alpha and Moonbeam. The <code>etherscan</code> tag allows you to add Etherscan API keys for smart contract verification, which we will review later.  </p>"},{"location":"tutorials/eth-api/foundry-start-to-end/#add-smart-contracts-in-foundry","title":"Add Smart Contracts","text":"<p>Smart contracts in Foundry destined for deployment by default belong in the <code>src</code> folder. In this tutorial, we'll write two smart contracts. Starting with the token:</p> <pre><code>touch src/MyToken.sol\n</code></pre> <p>Open the file and add the following to it:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Import OpenZeppelin Contract\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// This ERC-20 contract mints the specified amount of tokens to the contract creator\ncontract MyToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MYTOK\") {\n        _mint(msg.sender, initialSupply);\n    }\n\n    // An external minting function allows anyone to mint as many tokens as they want\n    function mint(uint256 toMint, address to) external {\n        require(toMint &lt;= 1 ether);\n        _mint(to, toMint);\n    }\n}\n</code></pre> <p>As you can see, the OpenZeppelin <code>ERC20</code> smart contract is imported by the mapping defined in <code>remappings.txt</code>.</p> <p>The second smart contract, which we'll name <code>Container.sol</code>, will depend on this token contract. It is a simple contract that holds the ERC-20 token we'll deploy. You can create the file by executing:  </p> <pre><code>touch src/Container.sol\n</code></pre> <p>Open the file and add the following to it:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Import OpenZeppelin Contract\nimport {MyToken} from \"./MyToken.sol\";\n\nenum ContainerStatus {\n    Unsatisfied,\n    Full,\n    Overflowing\n}\n\ncontract Container {\n    MyToken token;\n    uint256 capacity;\n    ContainerStatus public status;\n\n    constructor(MyToken _token, uint256 _capacity) {\n        token = _token;\n        capacity = _capacity;\n        status = ContainerStatus.Unsatisfied;\n    }\n\n    // Updates the status value based on the number of tokens that this contract has\n    function updateStatus() public {\n        address container = address(this);\n        uint256 balance = token.balanceOf(container);\n        if (balance &lt; capacity) {\n            status = ContainerStatus.Unsatisfied;\n        } else if (balance == capacity) {\n            status = ContainerStatus.Full;\n        } else if (_isOverflowing(balance)) {\n            status = ContainerStatus.Overflowing;\n        }\n    }\n\n    // Returns true if the contract should be in an overflowing state, false if otherwise\n    function _isOverflowing(uint256 balance) internal view returns (bool) {\n        return balance &gt; capacity;\n    }\n}\n</code></pre> <p>The <code>Container</code> smart contract can have its status updated based on how many tokens it holds and what its initial capacity value was set to. If the number of tokens it holds is above its capacity, its status can be updated to <code>Overflowing</code>. If it holds tokens equal to capacity, its status can be updated to <code>Full</code>. Otherwise, the contract will start and stay in the <code>Unsatisfied</code> state.  </p> <p><code>Container</code> requires a <code>MyToken</code> smart contract instance to function, so when we deploy it, we will need logic to ensure that it is deployed with a <code>MyToken</code> smart contract.  </p>"},{"location":"tutorials/eth-api/foundry-start-to-end/#write-tests","title":"Write Tests","text":"<p>Before we deploy anything to a TestNet or MainNet, however, it's good to test your smart contracts. There are many types of tests:</p> <ul> <li>Unit tests \u2014 allow you to test specific parts of a smart contract's functionality. When writing your own smart contracts, it can be a good idea to break functionality into different sections so that it is easier to unit test</li> <li>Fuzz tests \u2014 allow you to test a smart contract with a wide variety of inputs to check for edge cases</li> <li>Integration tests \u2014 allow you to test a smart contract when it works in conjunction with other smart contracts, so that you know it works as expected in a deployed environment<ul> <li>Forking tests - integration tests that allows you to make a fork (a carbon copy of a network), so that you can simulate a series of transactions on a preexisting network</li> </ul> </li> </ul>"},{"location":"tutorials/eth-api/foundry-start-to-end/#unit-tests-in-foundry","title":"Unit Tests in Foundry","text":"<p>To get started with writing tests for this tutorial, make a new file in the <code>test</code> folder:  </p> <pre><code>cd test\ntouch MyToken.t.sol\n</code></pre> <p>By convention, all of your tests should end with <code>.t.sol</code> and start with the name of the smart contract that it is testing. In practice, the test can be stored anywhere and is considered a test if it has a function that starts with the word \"test\".</p> <p>Let's start by writing a test for the token smart contract. Open up <code>MyToken.t.sol</code> and add:  </p> <pre><code>pragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/MyToken.sol\";\n\ncontract MyTokenTest is Test {\n    MyToken public token;\n\n    // Runs before each test\n    function setUp() public {\n        token = new MyToken(100);\n    }\n\n    // Tests if minting during the constructor happens properly\n    function testConstructorMint() public {\n        assertEq(token.balanceOf(address(this)), 100);\n    }\n}\n</code></pre> <p>Let's break down what's happening here. The first line is typical for a Solidity file: setting the Solidity version. The next two lines are imports. <code>forge-std/Test.sol</code> is the standard library that Forge (and thus Foundry) includes to help with testing. This includes the <code>Test</code> smart contract, certain assertions, and forge cheatcodes.  </p> <p>If you take a look at the <code>MyTokenTest</code> smart contract, you'll see two functions. The first is <code>setUp</code>, which is run before each test. So in this test contract, a new instance of <code>MyToken</code> is deployed every time a test function is run. You know if a function is a test function if it starts with the word \"test\", so the second function, <code>testConstructorMint</code> is a test function.  </p> <p>Great! Let's write some more tests, but for <code>Container</code>.  </p> <pre><code>touch Container.t.sol\n</code></pre> <p>And add the following:  </p> <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport {MyToken} from \"../src/MyToken.sol\";\nimport {Container, ContainerStatus} from \"../src/Container.sol\";\n\ncontract ContainerTest is Test {\n    MyToken public token;\n    Container public container;\n\n    uint256 constant CAPACITY = 100;\n\n    // Runs before each test\n    function setUp() public {\n        token = new MyToken(1000);\n        container = new Container(token, CAPACITY);\n    }\n\n    // Tests if the container is unsatisfied right after constructing\n    function testInitialUnsatisfied() public {\n        assertEq(token.balanceOf(address(container)), 0);\n        assertTrue(container.status() == ContainerStatus.Unsatisfied);\n    }\n\n    // Tests if the container will be \"full\" once it reaches its capacity\n    function testContainerFull() public {\n        token.transfer(address(container), CAPACITY);\n        container.updateStatus();\n\n        assertEq(token.balanceOf(address(container)), CAPACITY);\n        assertTrue(container.status() == ContainerStatus.Full);\n    }\n}\n</code></pre> <p>This test smart contract has two tests, so when running the tests, there will be two deployments of both <code>MyToken</code> and <code>Container</code>, for four smart contracts. You can run the following command to see the result of the test:  </p> <pre><code>forge test\n</code></pre> <p>When testing, you should see the following output:  </p> forge test [\u280a] Compiling... No files changed, compilation skipped Ran 1 test for test/MyToken.t.sol:MyTokenTest [PASS] testConstructorMint() (gas: 10651) Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 361.83\u00b5s (39.46\u00b5s CPU time) Ran 2 tests for test/Container.t.sol:ContainerTest [PASS] testContainerFull() (gas: 73204) [PASS] testInitialUnsatisfied() (gas: 18476) Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 422.00\u00b5s (128.67\u00b5s CPU time) Ran 2 test suites in 138.17ms (783.83\u00b5s CPU time): 3 tests passed, 0 failed, 0 skipped (3 total tests)"},{"location":"tutorials/eth-api/foundry-start-to-end/#test-harnesses-in-foundry","title":"Test Harnesses in Foundry","text":"<p>Sometimes you'll want to unit test an <code>internal</code> function in a smart contract. To do so, you'll have to write a test harness smart contract, which inherits from the smart contract and exposes the internal function as a public one.  </p> <p>For example, in <code>Container</code>, there is an internal function named <code>_isOverflowing</code>, which checks to see if the smart contract has more tokens than its capacity. To test this, add the following test harness smart contract to the <code>Container.t.sol</code> file:  </p> <pre><code>contract ContainerHarness is Container {\n    constructor(MyToken _token, uint256 _capacity) Container(_token, _capacity) {}\n\n    function exposed_isOverflowing(uint256 balance) external view returns(bool) {\n        return _isOverflowing(balance);\n    }\n}\n</code></pre> <p>Now, inside of the <code>ContainerTest</code> smart contract, you can add a new test that tests the previously unreachable <code>_isOverflowing</code> contract:  </p> <pre><code>// Tests for negative cases of the internal _isOverflowing function\nfunction testIsOverflowingFalse() public {\n    ContainerHarness harness = new ContainerHarness(token , CAPACITY);\n    assertFalse(harness.exposed_isOverflowing(CAPACITY - 1));\n    assertFalse(harness.exposed_isOverflowing(CAPACITY));\n    assertFalse(harness.exposed_isOverflowing(0));\n}\n</code></pre> <p>Now, when you run the test with <code>forge test</code>, you should see that <code>testIsOverflowingFalse</code> passes!  </p> forge test [\u280a] Compiling... [\u2812] Compiling 1 files with 0.8.20 [\u2822] Solc 0.8.20 finished in 1.06s Compiler run successful Ran 1 test for test/MyToken.t.sol:MyTokenTest [PASS] testConstructorMint() (gas: 10651) Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 498.00\u00b5s (48.96\u00b5s CPU time) Ran 3 tests for test/Container.t.sol:ContainerTest [PASS] testContainerFull() (gas: 73238) [PASS] testInitialUnsatisfied() (gas: 18510) [PASS] testIsOverflowingFalse() (gas: 192130) Suite result: ok. 3 passed; 0 failed; 0 skipped; finished in 606.17\u00b5s (183.54\u00b5s CPU time) Ran 2 test suites in 138.29ms (1.10ms CPU time): 4 tests passed, 0 failed, 0 skipped (4 total tests)"},{"location":"tutorials/eth-api/foundry-start-to-end/#fuzzing-tests-in-foundry","title":"Fuzzing Tests in Foundry","text":"<p>When you write a unit test, you can only use so many inputs to test. You can test edge cases, a few select values, and perhaps one or two random ones. But when working with inputs, there are nearly an infinite amount of different ones to test! How can you be sure that they work for every value? Wouldn't you feel safer if you could test 10000 different inputs instead of less than 10?  </p> <p>One of the best ways that developers can test many inputs is through fuzzing, or fuzz tests. Foundry automatically fuzz tests when an input in a test function is included. To illustrate this, add the following test to the <code>MyTokenTest</code> contract in <code>MyToken.t.sol</code>.  </p> <pre><code>// Fuzz tests for success upon minting tokens one ether or below\nfunction testMintOneEtherOrBelow(uint256 amountToMint) public {\n    vm.assume(amountToMint &lt;= 1 ether);\n\n    token.mint(amountToMint, msg.sender);\n    assertEq(token.balanceOf(msg.sender), amountToMint);\n}\n</code></pre> <p>This test includes <code>uint256 amountToMint</code> as input, which tells Foundry to fuzz with <code>uint256</code> inputs! By default, Foundry will input 256 different inputs, but this can be configured with the <code>FOUNDRY_FUZZ_RUNS</code> environment variable.  </p> <p>Additionally, the first line in the function uses <code>vm.assume</code> to only use inputs that are less than or equal to one ether since the <code>mint</code> function reverts if someone tries to mint more than one ether at a time. This cheatcode helps you direct the fuzzing into the right range.  </p> <p>Let's look at another fuzzing test to put in the <code>MyTokenTest</code> contract, but this time where we expect to fail:  </p> <pre><code>// Fuzz tests for failure upon minting tokens above one ether\nfunction testFailMintAboveOneEther(uint256 amountToMint) public {\n    vm.assume(amountToMint &gt; 1 ether);\n\n    token.mint(amountToMint, msg.sender);\n}\n</code></pre> <p>In Foundry, when you want to test for a failure, instead of just starting your test function with the world \"test\", you start it with \"testFail\". In this test, we assume that the <code>amountToMint</code> is above one ether, which should fail!  </p> <p>Now run the tests:  </p> <pre><code>forge test\n</code></pre> <p>You should see something similar to the following in the console:</p> forge test [\u280a] Compiling... [\u280a] Compiling 1 files with 0.8.20 [\u2812] Solc 0.8.20 finished in 982.65ms Compiler run successful Ran 3 tests for test/Container.t.sol:ContainerTest [PASS] testContainerFull() (gas: 73238) [PASS] testInitialUnsatisfied() (gas: 18510) [PASS] testIsOverflowingFalse() (gas: 192130) Suite result: ok. 3 passed; 0 failed; 0 skipped; finished in 446.25\u00b5s (223.67\u00b5s CPU time) Ran 3 tests for test/MyToken.t.sol:MyTokenTest [PASS] testConstructorMint() (gas: 10651) [PASS] testFailMintAboveOneEther(uint256) (runs: 256, \u03bc: 8462, ~: 8462) [PASS] testMintOneEtherOrBelow(uint256) (runs: 256, \u03bc: 37939, ~: 39270) Suite result: ok. 3 passed; 0 failed; 0 skipped; finished in 10.78ms (18.32ms CPU time) Ran 2 test suites in 138.88ms (11.23ms CPU time): 6 tests passed, 0 failed, 0 skipped (6 total tests)"},{"location":"tutorials/eth-api/foundry-start-to-end/#forking-tests-in-foundry","title":"Forking Tests in Foundry","text":"<p>In Foundry, you can locally fork a network so that you can test out how the contracts would work in an environment with already deployed smart contracts. For example, if someone deployed smart contract <code>A</code> on Moonbeam that required a token smart contract, you could fork the Moonbeam network and deploy your own token to test how smart contract <code>A</code> would react to it.  </p> <p>Note</p> <p>Moonbeam's custom precompile smart contracts currently do not work in Foundry forks because precompiles are Substrate-based whereas typical smart contracts are completely based on the EVM. Learn more about forking on Moonbeam and the differences between Moonbeam and Ethereum.</p> <p>In this tutorial, you will test how your <code>Container</code> smart contract interacts with an already deployed <code>MyToken</code> contract on Moonbase Alpha</p> <p>Let's add a new test function to the <code>ContainerTest</code> smart contract in <code>Container.t.sol</code> called <code>testAlternateTokenOnMoonbaseFork</code>:</p> <pre><code>// Fork tests in the Moonbase Alpha environment\nfunction testAlternateTokenOnMoonbaseFork() public {\n    // Creates and selects a fork, returns a fork ID\n    uint256 moonbaseFork = vm.createFork(\"moonbase\");\n    vm.selectFork(moonbaseFork);\n    assertEq(vm.activeFork(), moonbaseFork);\n\n    // Get token that's already deployed &amp; deploys a container instance\n    token = MyToken(0x359436610E917e477D73d8946C2A2505765ACe90);\n    container = new Container(token, CAPACITY);\n\n    // Mint tokens to the container &amp; update container status\n    token.mint(CAPACITY, address(container));\n    container.updateStatus();\n\n    // Assert that the capacity is full, just like the rest of the time\n    assertEq(token.balanceOf(address(container)), CAPACITY);\n    assertTrue(container.status() == ContainerStatus.Full);\n}\n</code></pre> <p>The first step (and thus first line) in this function is to have the test function fork a network with <code>vm.createFork</code>. Recall that <code>vm</code> is a cheat code provided by the Forge standard library. All that's necessary to create a fork is an RPC URL, or an alias for an RPC URL that's stored in the <code>foundry.toml</code> file. In this case, we added an RPC URL for \"moonbase\" in the setup step, so in the test function we will just pass the word <code>\"moonbase\"</code>. This cheat code function returns an ID for the fork created, which is stored in an <code>uint256</code> and is necessary for activating the fork.  </p> <p>On the second line, after the fork has been created, the environment will select and use the fork in the test environment with <code>vm.selectFork</code>. The third line just demonstrates that the current fork, retrieved with <code>vm.activeFork</code>, is the same as the Moonbase Alpha fork.  </p> <p>The fourth line of code retrieves an already deployed instance of <code>MyToken</code>, which is what's so useful about forking: you can use contracts that are already deployed.  </p> <p>The rest of the code tests capacity like you would expect a local test to. If you run the tests (with the <code>-vvvv</code> tag for extra logging), you'll see that it passes:  </p> <pre><code>forge test -vvvv\n</code></pre> forge test [PASS] testIsOverflowingFalse() (gas: 192130) Traces:   [192130] ContainerTest::testIsOverflowingFalse()     \u251c\u2500 [151256] \u2192 new ContainerHarness@0xF62849F9A0B5Bf2913b396098F7c7019b51A820a     \u2502   \u2514\u2500 \u2190 [Return] 522 bytes of code     \u251c\u2500 [421] ContainerHarness::exposed_isOverflowing(99) [staticcall]     \u2502   \u2514\u2500 \u2190 [Return] false     \u251c\u2500 [0] VM::assertFalse(false) [staticcall]     \u2502   \u2514\u2500 \u2190 [Return]     \u251c\u2500 [421] ContainerHarness::exposed_isOverflowing(100) [staticcall]     \u2502   \u2514\u2500 \u2190 [Return] false     \u251c\u2500 [0] VM::assertFalse(false) [staticcall]     \u2502   \u2514\u2500 \u2190 [Return]     \u251c\u2500 [421] ContainerHarness::exposed_isOverflowing(0) [staticcall]     \u2502   \u2514\u2500 \u2190 [Return] false     \u251c\u2500 [0] VM::assertFalse(false) [staticcall]     \u2502   \u2514\u2500 \u2190 [Return]     \u2514\u2500 \u2190 [Stop] Suite result: ok. 4 passed; 0 failed; 0 skipped; finished in 2.07s (2.07s CPU time) Ran 2 test suites in 2.44s (2.08s CPU time): 7 tests passed, 0 failed, 0 skipped (7 total tests) <p>That's it for testing! You can find the complete <code>Container.t.sol</code> and <code>MyToken.t.sol</code> files below:</p> Container.t.sol <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport {MyToken} from \"../src/MyToken.sol\";\nimport {Container, ContainerStatus} from \"../src/Container.sol\";\n\ncontract ContainerTest is Test {\n    MyToken public token;\n    Container public container;\n\n    uint256 constant CAPACITY = 100;\n\n    function setUp() public {\n        token = new MyToken(1000);\n        container = new Container(token, CAPACITY);\n    }\n\n    function testInitialUnsatisfied() public {\n        assertEq(token.balanceOf(address(container)), 0);\n        assertTrue(container.status() == ContainerStatus.Unsatisfied);\n    }\n\n    function testContainerFull() public {\n        token.transfer(address(container), CAPACITY);\n        container.updateStatus();\n\n        assertEq(token.balanceOf(address(container)), CAPACITY);\n        assertTrue(container.status() == ContainerStatus.Full);\n    }\n\n    function testIsOverflowingFalse() public {\n        ContainerHarness harness = new ContainerHarness(token , CAPACITY);\n        assertFalse(harness.exposed_isOverflowing(CAPACITY - 1));\n        assertFalse(harness.exposed_isOverflowing(CAPACITY));\n        assertFalse(harness.exposed_isOverflowing(0));\n    }\n\n    function testAlternateTokenOnMoonbaseFork() public {\n        // Creates and selects a fork\n        uint256 moonbaseFork = vm.createFork(\"moonbase\");\n        vm.selectFork(moonbaseFork);\n        assertEq(vm.activeFork(), moonbaseFork);\n\n        // Get token that's already deployed &amp; deploys a container instance\n        token = MyToken(0x93e1e9EC6c1A8736266A595EFe97B5673ea0fEAc);\n        container = new Container(token, CAPACITY);\n\n        // Mint tokens to the container &amp; update container status\n        token.mint(CAPACITY, address(container));\n        container.updateStatus();\n\n        // Assert that the capacity is full\n        assertEq(token.balanceOf(address(container)), CAPACITY);\n        assertTrue(container.status() == ContainerStatus.Full);\n    }\n}\n\ncontract ContainerHarness is Container {\n    constructor(MyToken _token, uint256 _capacity) Container(_token, _capacity) {}\n\n    function exposed_isOverflowing(uint256 balance) external view returns(bool) {\n        return _isOverflowing(balance);\n    }\n}\n</code></pre> MyToken.t.sol <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/MyToken.sol\";\n\ncontract MyTokenTest is Test {\n    MyToken public token;\n\n    function setUp() public {\n        token = new MyToken(100);\n    }\n\n    function testConstructorMint() public {\n        assertEq(token.balanceOf(address(this)), 100);\n    }\n\n    function testMintOneEtherOrBelow(uint256 amountToMint) public {\n        vm.assume(amountToMint &lt;= 1 ether);\n\n        token.mint(amountToMint, msg.sender);\n        assertEq(token.balanceOf(msg.sender), amountToMint);\n    }\n\n    function testFailMintAboveOneEther(uint256 amountToMint) public {\n        vm.assume(amountToMint &gt; 1 ether);\n\n        token.mint(amountToMint, msg.sender);\n    }\n}\n</code></pre>"},{"location":"tutorials/eth-api/foundry-start-to-end/#deploy-in-foundry-with-solidity-scripts","title":"Deploy in Foundry with Solidity Scripts","text":"<p>Not only are tests in Foundry written in Solidity, the scripts are too! Like other developer environments, scripts can be written to help interact with deployed smart contracts or can help along a complex deployment process that would be difficult to do manually. Even though scripts are written in Solidity, they are never deployed to a chain. Instead, much of the logic is actually run off-chain, so don't worry about any additional gas costs for using Foundry instead of a JavaScript environment like Hardhat.  </p>"},{"location":"tutorials/eth-api/foundry-start-to-end/#deploy-on-moonbase-alpha","title":"Deploy on Moonbase Alpha","text":"<p>In this tutorial, we will use Foundry's scripts to deploy the <code>MyToken</code> and <code>Container</code> smart contracts. To create the deployment scripts, create a new file in the <code>script</code> folder:  </p> <pre><code>cd script\ntouch Container.s.sol\n</code></pre> <p>By convention, scripts should end with <code>s.sol</code> and have a name similar to the script they relate to. In this case, we are deploying the <code>Container</code> smart contract, so we have named the script <code>Container.s.sol</code>, though it's not the end of the world if you use a more suitable or descriptive name.  </p> <p>In this script, add:  </p> <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Script.sol\";\nimport {MyToken} from \"../src/MyToken.sol\";\nimport {Container} from \"../src/Container.sol\";\n\ncontract ContainerDeployScript is Script {\n    // Runs the script; deploys MyToken and Container\n    function run() external {\n        vm.startBroadcast();\n\n        // Make a new token\n        MyToken token = new MyToken(1000);\n\n        // Make a new container\n        new Container(token, 500);\n\n        vm.stopBroadcast();\n    }\n}\n</code></pre> <p>Let's break this script down. The first line is standard: declaring the solidity version. The imports include the two smart contracts you previously added, which will be deployed. This includes additional functionality to use in a script, including the <code>Script</code> contract.  </p> <p>Now let's look at the logic in the contract. There is a single function, <code>run</code>, which is where the script logic is hosted. In this <code>run</code> function, the <code>vm</code> object is used often. This is where all of the Forge cheatcodes are stored, which determines the state of the virtual machine that the solidity is run in.  </p> <p>In the first line within the <code>run</code> function, <code>vm.startBroadcast</code> starts a broadcast, which indicates that the following logic should take place on-chain. So when the <code>MyToken</code> and the <code>Container</code> contracts are instantiated with the <code>new</code> keyword, they are instantiated on-chain. The final line, <code>vm.stopBroadcast</code> ends the broadcast.  </p> <p>Before we run this script, you'll need to set up your keystore by importing your private key. You can do this using the cast wallet import command as follows:</p> <pre><code>cast wallet import deployer --interactive\n</code></pre> <p>This will prompt you to:</p> <ol> <li>Enter your private key</li> <li>Enter a password to encrypt the keystore</li> </ol> <p>The account will be saved as \"deployer\" in your keystore. You can then use this account name in the deployment commands. You'll be prompted for your keystore password when deploying contracts or sending transactions.</p> <p>Now, your script and project should be ready for deployment! Use the following command to do so:  </p> <pre><code>forge script Container.s.sol:ContainerDeployScript --broadcast --verify -vvvv --legacy --rpc-url moonbase --account deployer\n</code></pre> <p>This command runs the <code>ContainerDeployScript</code> contract as a script. The <code>--broadcast</code> option tells Forge to allow broadcasting of transactions, the <code>--verify</code> option tells Forge to verify to Moonscan when deploying, <code>-vvvv</code> makes the command output verbose, and <code>--rpc-url moonbase</code> sets the network to what <code>moonbase</code> was set to in <code>foundry.toml</code>. The <code>--legacy</code> flag instructs Foundry to bypass EIP-1559. While all Moonbeam networks support EIP-1559, Foundry will refuse to submit the transaction to Moonbase and revert to a local simulation if you omit the <code>--legacy</code> flag. The <code>--account deployer</code> flag tells Foundry to use the \"deployer\" account from your keystore.</p> <p>You should see something like this as output:  </p> Script ran successfully. Setting up 1 EVM. Simulated On-chain Traces:   [488164] \u2192 new MyToken@0xAEe1a769b10d03a6CeB4D9DFd3aBB2EF807ee6aa     \u251c\u2500 emit Transfer(from: 0x0000000000000000000000000000000000000000, to: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e, value: 1000)     \u2514\u2500 \u2190 [Return] 1980 bytes of code   [133238] \u2192 new Container@0xeb1Ff38A645Eae4E64dFb93772D8129F88E11Ab1     \u2514\u2500 \u2190 [Return] 432 bytes of code Chain 1287 Estimated gas price: 0.03125 gwei Estimated total gas used for script: 1670737 Estimated amount required: 0.000208842125 ETH Sending transactions [0 - 0]. \u2801 [00:00:00] [#############################################################&gt;-------------------------------------------------------------] 1/2 txes (0.7s) Waiting for receipts. \u2809 [00:00:22] [#######################################################################################################################] 1/1 receipts (0.0s) moonbase \u2705  [Success]Hash: 0x2ad8994c12af74bdcb04873e13d97dc543a2fa7390c1e194732ab43ec828cb3b Contract Address: 0xAEe1a769b10d03a6CeB4D9DFd3aBB2EF807ee6aa Block: 6717135 Paid: 0.000116937 ETH (935496 gas * 0.03125 gwei) Sending transactions [1 - 1]. \u2809 [00:00:23] [###########################################################################################################################] 2/2 txes (0.0s) Waiting for receipts. \u2809 [00:00:21] [#######################################################################################################################] 1/1 receipts (0.0s) moonbase \u2705  [Success]Hash: 0x3bfb4cee2be4269badc57e0053d8b4d94d9d57d7936ecaa1e13ac1e2199f3b12 Contract Address: 0xeb1Ff38A645Eae4E64dFb93772D8129F88E11Ab1 Block: 6717137 Paid: 0.000035502 ETH (284016 gas * 0.03125 gwei) ONCHAIN EXECUTION COMPLETE &amp; SUCCESSFUL. Total Paid: 0.000152439 ETH (1219512 gas * avg 0.03125 gwei) <p>You should be able to see that your contracts were deployed, and are verified on Moonscan! For example, this is where my <code>Container.sol</code> contract was deployed.  </p> <p>The entire deployment script is available below:  </p> Container.s.sol <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Script.sol\";\nimport {MyToken} from \"../src/MyToken.sol\";\nimport {Container} from \"../src/Container.sol\";\n\ncontract ContainerDeployScript is Script {\n    // Runs the script; deploys MyToken and Container\n    function run() external {\n        vm.startBroadcast();\n\n        // Make a new token\n        MyToken token = new MyToken(1000);\n\n        // Make a new container\n        new Container(token, 500);\n\n        vm.stopBroadcast();\n    }\n}\n</code></pre>"},{"location":"tutorials/eth-api/foundry-start-to-end/#deploy-on-moonbeam-mainnet","title":"Deploy on Moonbeam MainNet","text":"<p>Let's say you're comfortable with your smart contracts and want to deploy on the Moonbeam MainNet! The process isn't too different from what was just done, you just have to change the command's rpc-url from <code>moonbase</code> to <code>moonbeam</code>, since you've already added Moonbeam MainNet's information in the <code>foundry.toml</code> file:</p> <pre><code>forge script Container.s.sol:ContainerDeployScript --broadcast --verify -vvvv --legacy --rpc-url moonbeam --account deployer\n</code></pre> <p>That's it! You've gone from nothing to a fully tested, deployed, and verified Foundry project. You can now adapt this so that you can use Foundry in your own projects!</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/eth-api/hardhat-start-to-end/","title":"Hardhat Developer Workflow","text":"<p>by Kevin Neilson &amp; Erin Shaben</p>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#introduction","title":"Introduction","text":"<p>In this tutorial, we'll walk through the Hardhat development environment in the context of launching a pooled staking DAO contract. We'll walk through the typical developer workflow in detail from start to finish.</p> <p>We'll assemble the components of the staking DAO and compile the necessary contracts. Then, we'll build a test suite with a variety of test cases relevant to our staking DAO, and run it against a local development node. Finally, we'll deploy the staking DAO to both Moonbase Alpha and Moonbeam and verify the contracts via the Hardhat Etherscan plugin. If this is your first time exploring Hardhat, you may wish to start with the introduction to Hardhat guide.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tutorials/eth-api/hardhat-start-to-end/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you will need the following:</p> <ul> <li>A Moonbase Alpha account funded with DEV.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>An Etherscan API Key</li> <li>For the Testing section, you'll need to have a local Moonbeam node up and running</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#creating-a-hardhat-project","title":"Creating a Hardhat Project","text":"<p>You will need to create a Hardhat project if you don't already have one. You can create one by completing the following steps:</p> <ol> <li> <p>Create a directory for your project</p> <pre><code>mkdir stakingDAO &amp;&amp; cd stakingDAO\n</code></pre> </li> <li> <p>Initialize the project which will create a <code>package.json</code> file</p> <pre><code>npm init -y\n</code></pre> </li> <li> <p>Install Hardhat</p> <pre><code>npm install hardhat\n</code></pre> </li> <li> <p>Create a project</p> <pre><code>npx hardhat --init\n</code></pre> <p>Note</p> <p><code>npx</code> is used to run executables installed locally in your project. Although Hardhat can be installed globally, installing it locally in each project is recommended so that you can control the version on a project-by-project basis.</p> </li> <li> <p>You'll be prompted with a series of questions to set up your project:</p> <ul> <li>Choose Hardhat 3 Beta (recommended for new projects) rather than Hardhat 2</li> <li>Choose where to initialize the project (default is current directory)</li> <li>Confirm converting to ESM (required for Hardhat v3)</li> <li>Select the type of project to initialize:<ul> <li>A TypeScript Hardhat project using Node Test Runner and Viem</li> <li>A TypeScript Hardhat project using Mocha and Ethers.js</li> </ul> </li> </ul> <p>For this example, you can choose either option based on your preference. If you choose the Mocha and Ethers.js option, you'll get a project structure with:</p> <ul> <li>A sample contract in <code>contracts/Counter.sol</code></li> <li>A test file in <code>test/Counter.ts</code></li> <li>TypeScript configuration</li> <li>Mocha and Ethers.js dependencies</li> </ul> <p>The project will be set up with all necessary dependencies and configurations for you to start developing.</p> </li> </ol> npx hardhat init 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 8888888888\u00a0\u00a08888b.\u00a0\u00a0888d888\u00a0.d88888\u00a088888b.\u00a0\u00a0\u00a08888b.\u00a0\u00a0888888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\"88b\u00a0888P\"\u00a0\u00a0d88\"\u00a0888\u00a0888\u00a0\"88b\u00a0\u00a0\u00a0\u00a0\u00a0\"88b\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0.d888888\u00a0888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0.d888888\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0Y88b\u00a0888\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0Y88b. 888\u00a0\u00a0\u00a0\u00a0888\u00a0\"Y888888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\"Y88888\u00a0888\u00a0\u00a0888\u00a0\"Y888888\u00a0\u00a0\"Y888 \ud83d\udc77 Welcome to Hardhat v3.0.4 \ud83d\udc77\u200d \u00a0Which version of Hardhat would you like to use? \u2026 \u00a0Hardhat 3 Beta (recommended for new projects) \u00a0\u00a0Hardhat 2 (older version) \u00a0Where would you like to initialize the project? \u00a0. \u00a0Hardhat only supports ESM projects. Would you like to change \"package.json\" to turn your project into ESM? (Y/n) \u00b7 true \u00a0What type of project would you like to initialize? \u2026 \u00a0\u00a0A TypeScript Hardhat project using Node Test Runner and Viem \u00a0A TypeScript Hardhat project using Mocha and Ethers.js"},{"location":"tutorials/eth-api/hardhat-start-to-end/#add-smart-contracts","title":"Add Smart Contracts","text":"<p>The smart contract featured in this tutorial is more complex than the one in the Introduction to Hardhat but the nature of the contract means it's perfect to demonstrate some of the advanced capabilities of Hardhat. <code>DelegationDAO.sol</code> is a pooled staking DAO that uses <code>StakingInterface.sol</code> to autonomously delegate to a collator when it reaches a determined threshold. Pooled staking contracts such as <code>DelegationDAO.sol</code> allow delegators with less than the protocol minimum bond to join together to delegate their pooled funds and earn a share of staking rewards.</p> <p>Note</p> <p><code>DelegationDAO.sol</code> is unreviewed and unaudited. It is designed only for demonstration purposes and not intended for production use. It may contain bugs or logic errors that could result in loss of funds.</p> <p>To get started, take the following steps:</p> <ol> <li> <p>Change to the contracts directory</p> <pre><code>cd contracts\n</code></pre> </li> <li> <p>Create a new file called <code>DelegationDAO.sol</code></p> <pre><code>touch DelegationDAO.sol\n</code></pre> </li> <li> <p>Copy and paste the contents of DelegationDAO.sol into <code>DelegationDAO.sol</code></p> DelegationDAO.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\n// This is a PoC to use the staking precompile wrapper as a Solidity developer.\npragma solidity &gt;=0.8.0;\n\nimport \"./StakingInterface.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n\ncontract DelegationDAO is AccessControl {\n\n    // Role definition for contract members\n    bytes32 public constant MEMBER = keccak256(\"MEMBER\");\n\n    // Auto-compounding percentage (100%)\n    uint8 public constant AUTOCOMPOUNDING_PERCENT = 100;\n\n    // Possible states for the DAO to be in:\n    // COLLECTING: the DAO is collecting funds before creating a delegation once the minimum delegation stake has been reached\n    // STAKING: the DAO has an active delegation\n    // REVOKING: the DAO has scheduled a delegation revoke\n    // REVOKED: the scheduled revoke has been executed\n    enum daoState {\n        COLLECTING,\n        STAKING,\n        REVOKING,\n        REVOKED\n    }\n\n    // Current state that the DAO is in\n    daoState public currentState;\n\n    // Member stakes (doesnt include rewards, represents member shares)\n    mapping(address =&gt; uint256) public memberStakes;\n\n    // Total Staking Pool (doesnt include rewards, represents total shares)\n    uint256 public totalStake;\n\n    // The ParachainStaking wrapper at the known pre-compile address. This will be used to make\n    // all calls to the underlying staking solution\n    ParachainStaking public staking;\n\n    // Minimum Delegation Amount\n    uint256 public constant minDelegationStk = 5 ether;\n\n    // Moonbeam Staking Precompile address\n    address public constant stakingPrecompileAddress =\n        0x0000000000000000000000000000000000000800;\n\n    // The collator that this DAO is currently nominating\n    address public target;\n\n    // Event for a member deposit\n    event deposit(address indexed _from, uint _value);\n\n    // Event for a member withdrawal\n    event withdrawal(address indexed _from, address indexed _to, uint _value);\n\n    // Initialize a new DelegationDao dedicated to delegating to the given collator target.\n    constructor(address _target, address admin) {\n        // Directly grant roles\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(MEMBER, admin);\n\n        //Sets the collator that this DAO nominating\n        target = _target;\n\n        // Initializes Moonbeam's parachain staking precompile\n        staking = ParachainStaking(stakingPrecompileAddress);\n\n        //Initialize the DAO state\n        currentState = daoState.COLLECTING;\n    }\n\n    // Simple getter to return the target collator of the DAO\n    function getTarget() public view returns (address) {\n        return target;\n    }\n\n    // Grant a user the role of admin\n    function grant_admin(\n        address newAdmin\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) onlyRole(MEMBER) {\n        grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\n        grantRole(MEMBER, newAdmin);\n    }\n\n    // Grant a user membership\n    function grant_member(\n        address newMember\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        grantRole(MEMBER, newMember);\n    }\n\n    // Revoke a user membership\n    function remove_member(\n        address payable exMember\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        revokeRole(MEMBER, exMember);\n    }\n\n    // Increase member stake via a payable function and automatically stake the added amount if possible\n    function add_stake() external payable onlyRole(MEMBER) {\n        if (currentState == daoState.STAKING) {\n            // Sanity check\n            if (!staking.isDelegator(address(this))) {\n                revert(\"The DAO is in an inconsistent state.\");\n            }\n            memberStakes[msg.sender] = memberStakes[msg.sender] + msg.value;\n            totalStake = totalStake + msg.value;\n            emit deposit(msg.sender, msg.value);\n            staking.delegatorBondMore(target, msg.value);\n        } else if (currentState == daoState.COLLECTING) {\n            memberStakes[msg.sender] = memberStakes[msg.sender] + msg.value;\n            totalStake = totalStake + msg.value;\n            emit deposit(msg.sender, msg.value);\n            if (totalStake &lt; minDelegationStk) {\n                return;\n            } else {\n                //initialiate the delegation and change the state\n                staking.delegateWithAutoCompound(\n                    target,\n                    address(this).balance,\n                    AUTOCOMPOUNDING_PERCENT,\n                    staking.candidateDelegationCount(target),\n                    staking.candidateAutoCompoundingDelegationCount(target),\n                    staking.delegatorDelegationCount(address(this))\n                );\n                currentState = daoState.STAKING;\n            }\n        } else {\n            revert(\"The DAO is not accepting new stakes in the current state.\");\n        }\n    }\n\n    // Function for a user to withdraw their stake\n    function withdraw(address payable account) public onlyRole(MEMBER) {\n        require(\n            currentState != daoState.STAKING,\n            \"The DAO is not in the correct state to withdraw.\"\n        );\n        if (currentState == daoState.REVOKING) {\n            bool result = execute_revoke();\n            require(result, \"Schedule revoke delay is not finished yet.\");\n        }\n        if (\n            currentState == daoState.REVOKED ||\n            currentState == daoState.COLLECTING\n        ) {\n            //Sanity checks\n            if (staking.isDelegator(address(this))) {\n                revert(\"The DAO is in an inconsistent state.\");\n            }\n            require(totalStake != 0, \"Cannot divide by zero.\");\n            //Calculate the withdrawal amount including staking rewards\n            uint amount = address(this).balance * memberStakes[msg.sender] / totalStake;\n            require(\n                check_free_balance() &gt;= amount,\n                \"Not enough free balance for withdrawal.\"\n            );\n            Address.sendValue(account, amount);\n            totalStake = totalStake - (memberStakes[msg.sender]);\n            memberStakes[msg.sender] = 0;\n            emit withdrawal(msg.sender, account, amount);\n        }\n    }\n\n    // Schedule revoke, admin only\n    function schedule_revoke() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(\n            currentState == daoState.STAKING,\n            \"The DAO is not in the correct state to schedule a revoke.\"\n        );\n        staking.scheduleRevokeDelegation(target);\n        currentState = daoState.REVOKING;\n    }\n\n    // Try to execute the revoke, returns true if it succeeds, false if it doesn't\n    function execute_revoke() internal onlyRole(MEMBER) returns (bool) {\n        require(\n            currentState == daoState.REVOKING,\n            \"The DAO is not in the correct state to execute a revoke.\"\n        );\n        staking.executeDelegationRequest(address(this), target);\n        if (staking.isDelegator(address(this))) {\n            return false;\n        } else {\n            currentState = daoState.REVOKED;\n            return true;\n        }\n    }\n\n    // Check how much free balance the DAO currently has. It should be the staking rewards if the DAO state is anything other than REVOKED or COLLECTING.\n    function check_free_balance()\n        public\n        view\n        onlyRole(MEMBER)\n        returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    // Change the collator target, admin only\n    function change_target(\n        address newCollator\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(\n            currentState == daoState.REVOKED ||\n                currentState == daoState.COLLECTING,\n            \"The DAO is not in the correct state to change staking target.\"\n        );\n        target = newCollator;\n    }\n\n    // Reset the DAO state back to COLLECTING, admin only\n    function reset_dao() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        currentState = daoState.COLLECTING;\n    }\n\n    // Override _setupRole to use grantRole as _setupRole does not exist in AccessControl anymore\n    function _setupRole(bytes32 role, address account) internal virtual {\n        grantRole(role, account);\n    }\n}\n</code></pre> </li> <li> <p>Create a new file called <code>StakingInterface.sol</code> in the <code>contracts</code> directory</p> <pre><code>touch StakingInterface.sol\n</code></pre> </li> <li> <p>Copy and paste the contents of StakingInterface.sol into <code>StakingInterface.sol</code></p> StakingInterface.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The ParachainStaking contract's address.\naddress constant PARACHAIN_STAKING_ADDRESS = 0x0000000000000000000000000000000000000800;\n\n/// @dev The ParachainStaking contract's instance.\nParachainStaking constant PARACHAIN_STAKING_CONTRACT = ParachainStaking(\n    PARACHAIN_STAKING_ADDRESS\n);\n\n/// @author The Moonbeam Team\n/// @title Pallet Parachain Staking Interface\n/// @dev The interface through which solidity contracts will interact with Parachain Staking\n/// We follow this same interface including four-byte function selectors, in the precompile that\n/// wraps the pallet\n/// @custom:address 0x0000000000000000000000000000000000000800\ninterface ParachainStaking {\n    /// @dev Check whether the specified address is currently a staking delegator\n    /// @custom:selector fd8ab482\n    /// @param delegator the address that we want to confirm is a delegator\n    /// @return A boolean confirming whether the address is a delegator\n    function isDelegator(address delegator) external view returns (bool);\n\n    /// @dev Check whether the specified address is currently a collator candidate\n    /// @custom:selector d51b9e93\n    /// @param candidate the address that we want to confirm is a collator andidate\n    /// @return A boolean confirming whether the address is a collator candidate\n    function isCandidate(address candidate) external view returns (bool);\n\n    /// @dev Check whether the specifies address is currently a part of the active set\n    /// @custom:selector 740d7d2a\n    /// @param candidate the address that we want to confirm is a part of the active set\n    /// @return A boolean confirming whether the address is a part of the active set\n    function isSelectedCandidate(\n        address candidate\n    ) external view returns (bool);\n\n    /// @dev Total points awarded to all collators in a particular round\n    /// @custom:selector 9799b4e7\n    /// @param round the round for which we are querying the points total\n    /// @return The total points awarded to all collators in the round\n    function points(uint256 round) external view returns (uint256);\n\n    /// @dev Total points awarded to a specific collator in a particular round.\n    /// A value of `0` may signify that no blocks were produced or that the storage for that round has been removed\n    /// @custom:selector bfea66ac\n    /// @param round the round for which we are querying the awarded points\n    /// @param candidate The candidate to whom the points are awarded\n    /// @return The total points awarded to the collator for the provided round\n    function awardedPoints(\n        uint32 round,\n        address candidate\n    ) external view returns (uint32);\n\n    /// @dev The amount delegated in support of the candidate by the delegator\n    /// @custom:selector a73e51bc\n    /// @param delegator Who made this delegation\n    /// @param candidate The candidate for which the delegation is in support of\n    /// @return The amount of the delegation in support of the candidate by the delegator\n    function delegationAmount(\n        address delegator,\n        address candidate\n    ) external view returns (uint256);\n\n    /// @dev Whether the delegation is in the top delegations\n    /// @custom:selector 91cc8657\n    /// @param delegator Who made this delegation\n    /// @param candidate The candidate for which the delegation is in support of\n    /// @return If delegation is in top delegations (is counted)\n    function isInTopDelegations(\n        address delegator,\n        address candidate\n    ) external view returns (bool);\n\n    /// @dev Get the minimum delegation amount\n    /// @custom:selector 02985992\n    /// @return The minimum delegation amount\n    function minDelegation() external view returns (uint256);\n\n    /// @dev Get the CandidateCount weight hint\n    /// @custom:selector a9a981a3\n    /// @return The CandidateCount weight hint\n    function candidateCount() external view returns (uint256);\n\n    /// @dev Get the current round number\n    /// @custom:selector 146ca531\n    /// @return The current round number\n    function round() external view returns (uint256);\n\n    /// @dev Get the CandidateDelegationCount weight hint\n    /// @custom:selector 2ec087eb\n    /// @param candidate The address for which we are querying the nomination count\n    /// @return The number of nominations backing the collator\n    function candidateDelegationCount(\n        address candidate\n    ) external view returns (uint32);\n\n    /// @dev Get the CandidateAutoCompoundingDelegationCount weight hint\n    /// @custom:selector 905f0806\n    /// @param candidate The address for which we are querying the auto compounding\n    ///     delegation count\n    /// @return The number of auto compounding delegations\n    function candidateAutoCompoundingDelegationCount(\n        address candidate\n    ) external view returns (uint32);\n\n    /// @dev Get the DelegatorDelegationCount weight hint\n    /// @custom:selector 067ec822\n    /// @param delegator The address for which we are querying the delegation count\n    /// @return The number of delegations made by the delegator\n    function delegatorDelegationCount(\n        address delegator\n    ) external view returns (uint256);\n\n    /// @dev Get the selected candidates for the current round\n    /// @custom:selector bcf868a6\n    /// @return The selected candidate accounts\n    function selectedCandidates() external view returns (address[] memory);\n\n    /// @dev Whether there exists a pending request for a delegation made by a delegator\n    /// @custom:selector 3b16def8\n    /// @param delegator the delegator that made the delegation\n    /// @param candidate the candidate for which the delegation was made\n    /// @return Whether a pending request exists for such delegation\n    function delegationRequestIsPending(\n        address delegator,\n        address candidate\n    ) external view returns (bool);\n\n    /// @dev Whether there exists a pending exit for candidate\n    /// @custom:selector 43443682\n    /// @param candidate the candidate for which the exit request was made\n    /// @return Whether a pending request exists for such delegation\n    function candidateExitIsPending(\n        address candidate\n    ) external view returns (bool);\n\n    /// @dev Whether there exists a pending bond less request made by a candidate\n    /// @custom:selector d0deec11\n    /// @param candidate the candidate which made the request\n    /// @return Whether a pending bond less request was made by the candidate\n    function candidateRequestIsPending(\n        address candidate\n    ) external view returns (bool);\n\n    /// @dev Returns the percent value of auto-compound set for a delegation\n    /// @custom:selector b4d4c7fd\n    /// @param delegator the delegator that made the delegation\n    /// @param candidate the candidate for which the delegation was made\n    /// @return Percent of rewarded amount that is auto-compounded on each payout\n    function delegationAutoCompound(\n        address delegator,\n        address candidate\n    ) external view returns (uint8);\n\n    /// @dev Join the set of collator candidates\n    /// @custom:selector 1f2f83ad\n    /// @param amount The amount self-bonded by the caller to become a collator candidate\n    /// @param candidateCount The number of candidates in the CandidatePool\n    function joinCandidates(uint256 amount, uint256 candidateCount) external;\n\n    /// @dev Request to leave the set of collator candidates\n    /// @custom:selector b1a3c1b7\n    /// @param candidateCount The number of candidates in the CandidatePool\n    function scheduleLeaveCandidates(uint256 candidateCount) external;\n\n    /// @dev Execute due request to leave the set of collator candidates\n    /// @custom:selector 3867f308\n    /// @param candidate The candidate address for which the pending exit request will be executed\n    /// @param candidateDelegationCount The number of delegations for the candidate to be revoked\n    function executeLeaveCandidates(\n        address candidate,\n        uint256 candidateDelegationCount\n    ) external;\n\n    /// @dev Cancel request to leave the set of collator candidates\n    /// @custom:selector 9c76ebb4\n    /// @param candidateCount The number of candidates in the CandidatePool\n    function cancelLeaveCandidates(uint256 candidateCount) external;\n\n    /// @dev Temporarily leave the set of collator candidates without unbonding\n    /// @custom:selector a6485ccd\n    function goOffline() external;\n\n    /// @dev Rejoin the set of collator candidates if previously had called `goOffline`\n    /// @custom:selector 6e5b676b\n    function goOnline() external;\n\n    /// @dev Request to bond more for collator candidates\n    /// @custom:selector a52c8643\n    /// @param more The additional amount self-bonded\n    function candidateBondMore(uint256 more) external;\n\n    /// @dev Request to bond less for collator candidates\n    /// @custom:selector 60744ae0\n    /// @param less The amount to be subtracted from self-bond and unreserved\n    function scheduleCandidateBondLess(uint256 less) external;\n\n    /// @dev Execute pending candidate bond request\n    /// @custom:selector 2e290290\n    /// @param candidate The address for the candidate for which the request will be executed\n    function executeCandidateBondLess(address candidate) external;\n\n    /// @dev Cancel pending candidate bond request\n    /// @custom:selector b5ad5f07\n    function cancelCandidateBondLess() external;\n\n    /// @dev Make a delegation in support of a collator candidate\n    /// @custom:selector 4b8bc9bf\n    /// @param candidate The address of the supported collator candidate\n    /// @param amount The amount bonded in support of the collator candidate\n    /// @param autoCompound The percent of reward that should be auto-compounded\n    /// @param candidateDelegationCount The number of delegations in support of the candidate\n    /// @param candidateAutoCompoundingDelegationCount The number of auto-compounding delegations\n    /// in support of the candidate\n    /// @param delegatorDelegationCount The number of existing delegations by the caller\n    function delegateWithAutoCompound(\n        address candidate,\n        uint256 amount,\n        uint8 autoCompound,\n        uint256 candidateDelegationCount,\n        uint256 candidateAutoCompoundingDelegationCount,\n        uint256 delegatorDelegationCount\n    ) external;\n\n    /// @dev Request to revoke an existing delegation\n    /// @custom:selector 1a1c740c\n    /// @param candidate The address of the collator candidate which will no longer be supported\n    function scheduleRevokeDelegation(address candidate) external;\n\n    /// @dev Bond more for delegators with respect to a specific collator candidate\n    /// @custom:selector 0465135b\n    /// @param candidate The address of the collator candidate for which delegation shall increase\n    /// @param more The amount by which the delegation is increased\n    function delegatorBondMore(address candidate, uint256 more) external;\n\n    /// @dev Request to bond less for delegators with respect to a specific collator candidate\n    /// @custom:selector c172fd2b\n    /// @param candidate The address of the collator candidate for which delegation shall decrease\n    /// @param less The amount by which the delegation is decreased (upon execution)\n    function scheduleDelegatorBondLess(\n        address candidate,\n        uint256 less\n    ) external;\n\n    /// @dev Execute pending delegation request (if exists &amp;&amp; is due)\n    /// @custom:selector e98c8abe\n    /// @param delegator The address of the delegator\n    /// @param candidate The address of the candidate\n    function executeDelegationRequest(\n        address delegator,\n        address candidate\n    ) external;\n\n    /// @dev Cancel pending delegation request (already made in support of input by caller)\n    /// @custom:selector c90eee83\n    /// @param candidate The address of the candidate\n    function cancelDelegationRequest(address candidate) external;\n\n    /// @dev Sets an auto-compound value for a delegation\n    /// @custom:selector faa1786f\n    /// @param candidate The address of the supported collator candidate\n    /// @param value The percent of reward that should be auto-compounded\n    /// @param candidateAutoCompoundingDelegationCount The number of auto-compounding delegations\n    /// in support of the candidate\n    /// @param delegatorDelegationCount The number of existing delegations by the caller\n    function setAutoCompound(\n        address candidate,\n        uint8 value,\n        uint256 candidateAutoCompoundingDelegationCount,\n        uint256 delegatorDelegationCount\n    ) external;\n\n    /// @dev Fetch the total staked amount of a delegator, regardless of the\n    /// candidate.\n    /// @custom:selector e6861713\n    /// @param delegator Address of the delegator.\n    /// @return Total amount of stake.\n    function getDelegatorTotalStaked(\n        address delegator\n    ) external view returns (uint256);\n\n    /// @dev Fetch the total staked towards a candidate.\n    /// @custom:selector bc5a1043\n    /// @param candidate Address of the candidate.\n    /// @return Total amount of stake.\n    function getCandidateTotalCounted(\n        address candidate\n    ) external view returns (uint256);\n}\n</code></pre> </li> <li> <p><code>DelegationDAO.sol</code> relies on a couple of standard OpenZeppelin contracts. Add the library with the following command:</p> <pre><code>npm install @openzeppelin/contracts\n</code></pre> </li> </ol>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#hardhat-configuration-file","title":"Hardhat Configuration File","text":"<p>When setting up the <code>hardhat.config.js</code> file, we'll need to import a few plugins that we'll use throughout this guide. So to get started, we'll need the Hardhat Toolbox plugin, which conveniently bundles together Hardhat plugins that can be used to deploy and interact with contracts using Ethers, test contracts with Mocha and Chai, verify contracts with Etherscan, and more. You can run the following command to install the plugin:</p> <pre><code>npm install --save-dev @nomicfoundation/hardhat-toolbox \n</code></pre> <p>If you're curious about additional Hardhat plugins, here is a complete list of official Hardhat plugins.</p> <p>Hardhat 3 includes an encrypted secrets manager that makes handling sensitive information like private keys and API keys easier. This ensures you don't have to hardcode secrets in your source code or store them in plain text.</p> <p>Note</p> <p>The encrypted secrets manager is only available in Hardhat 3 or higher. You can install the latest version with:</p> <pre><code>npm install hardhat\n</code></pre> <p>For the latest releases and updates, check the Hardhat releases page.</p> <p>To use encrypted secrets, you'll need to:</p> <ol> <li> <p>Install Hardhat (latest version): <pre><code>npm install hardhat\n</code></pre></p> </li> <li> <p>Set up your secrets using the keystore:</p> </li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>npx hardhat keystore set MOONBEAM_RPC_URL\nnpx hardhat keystore set MOONBEAM_PRIVATE_KEY\n</code></pre> <pre><code>npx hardhat keystore set MOONRIVER_RPC_URL\nnpx hardhat keystore set MOONRIVER_PRIVATE_KEY\n</code></pre> <pre><code>npx hardhat keystore set MOONBASE_RPC_URL\nnpx hardhat keystore set MOONBASE_PRIVATE_KEY\n</code></pre> <pre><code>npx hardhat keystore set DEV_RPC_URL\nnpx hardhat keystore set DEV_PRIVATE_KEY\nnpx hardhat keystore set ALICE_PRIVATE_KEY\nnpx hardhat keystore set BOB_PRIVATE_KEY\n</code></pre> <p>Then, update your configuration file to use the encrypted secrets:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>module.exports = {\n  solidity: '0.8.20',\n  networks: {\n    moonbeam: {\n      type: \"http\",\n      chainType: \"generic\",\n      url: configVariable(\"MOONBEAM_RPC_URL\"),\n      chainId: 1284, // (hex: 0x504),\n      accounts: [configVariable(\"MOONBEAM_PRIVATE_KEY\")],\n    },\n  },\n};\n</code></pre> <pre><code>module.exports = {\n  solidity: '0.8.20',\n  networks: {\n    moonriver: {\n      type: \"http\",\n      chainType: \"generic\",\n      url: configVariable(\"MOONRIVER_RPC_URL\"),\n      chainId: 1285, // (hex: 0x505),\n      accounts: [configVariable(\"MOONRIVER_PRIVATE_KEY\")],\n    },\n  },\n};\n</code></pre> <pre><code>module.exports = {\n  solidity: '0.8.20',\n  networks: {\n    moonbase: {\n      type: \"http\",\n      chainType: \"generic\",\n      url: configVariable(\"MOONBASE_RPC_URL\"),\n      chainId: 1287, // (hex: 0x507),\n      accounts: [configVariable(\"MOONBASE_PRIVATE_KEY\")],\n    },\n  },\n};\n</code></pre> <pre><code>module.exports = {\n  solidity: '0.8.20',\n  networks: {\n    dev: {\n      type: \"http\",\n      chainType: \"generic\",\n      url: configVariable(\"DEV_RPC_URL\"),\n      chainId: 1281, // 0x501 in hex\n      accounts: [\n        configVariable(\"DEV_PRIVATE_KEY\"),\n        configVariable(\"ALICE_PRIVATE_KEY\"), // Alice (Alith) account\n        configVariable(\"BOB_PRIVATE_KEY\")    // Bob (Baltathar) account\n      ],\n    },\n  },\n};\n</code></pre> <p>For this example, you'll need to add your private keys for your two accounts on Moonbase Alpha. Since some of the testing will be done on a development node, you'll also need to add the private keys of two of the pre-funded development node accounts, which, for this example, we can use Alice and Bob. In addition, you'll add your Etherscan API key, which can be used for both Moonbase Alpha and Moonbeam.</p> <pre><code>// 1. Import the Hardhat Toolbox plugin\nrequire('@nomicfoundation/hardhat-toolbox');\nrequire('@nomicfoundation/hardhat-ignition-ethers');\n\nmodule.exports = {\n  // 2. Specify the Solidity version\n  solidity: '0.8.20',\n  networks: {\n    // 3. Add the Moonbase Alpha network specification\n    moonbase: {\n      type: \"http\",\n      chainType: \"generic\",\n      url: configVariable(\"MOONBASE_RPC_URL\"),\n      chainId: 1287, // 0x507 in hex\n      accounts: [configVariable(\"MOONBASE_PRIVATE_KEY\")],\n    },\n    dev: {\n      type: \"http\",\n      chainType: \"generic\",\n      url: configVariable(\"DEV_RPC_URL\"),\n      chainId: 1281, // 0x501 in hex\n      accounts: [\n        configVariable(\"DEV_PRIVATE_KEY\"),\n        configVariable(\"ALICE_PRIVATE_KEY\"), // Alice (Alith) account\n        configVariable(\"BOB_PRIVATE_KEY\")    // Bob (Baltathar) account\n      ],\n    },\n    moonbeam: {\n      type: \"http\",\n      chainType: \"generic\",\n      url: configVariable(\"MOONBEAM_RPC_URL\"),\n      chainId: 1284, // 0x504 in hex\n      accounts: [configVariable(\"MOONBEAM_PRIVATE_KEY\")],\n    },\n  },\n  // 4. Set up your Etherscan API key for contract verification\n  // Moonbeam and Moonbase Alpha use the same Etherscan API key\n  etherscan: {\n    apiKey: {\n      moonbaseAlpha: configVariable(\"ETHERSCAN_API_KEY\"),\n      moonbeam: configVariable(\"ETHERSCAN_API_KEY\"),\n    },\n  },\n};\n</code></pre> <p>Note</p> <p>Any real funds sent to the Alice and Bob development accounts will be lost immediately.Take precautions never to send MainNet funds to exposed development accounts. The private keys for these accounts are:</p> <ul> <li>Alice (Alith): <code>0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133</code></li> <li>Bob (Baltathar): <code>0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b</code></li> </ul> <p>These accounts should only be used on the local development node and never on Moonbeam MainNet or Moonbase Alpha.</p> <p>You're now ready to move on to compilation and testing.</p>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#compiling-the-contract","title":"Compiling the Contract","text":"<p>Now that you have your Hardhat project set up with the encrypted secrets manager, you can proceed with compilation and testing. The project comes with a sample contract and test file that you can use to verify your setup.</p>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#compiling-the-contract","title":"Compiling the Contract","text":"<p>To compile the sample contract, run:</p> <pre><code>npx hardhat compile\n</code></pre> npx hardhat compile Compiled 8 Solidity files successfully (evm target: paris). <p>After compilation, an <code>artifacts</code> directory is created: it holds the bytecode and metadata of the contract, which are <code>.json</code> files. Adding this directory to your <code>.gitignore</code> is a good idea.</p>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#testing","title":"Testing","text":"<p>A robust smart contract development workflow is complete with a testing suite. Hardhat has a number of tools that make it easy to write and run tests. In this section, you'll learn the basics of testing your smart contracts and some more advanced techniques.</p> <p>Hardhat tests are typically written with Mocha and Chai. Mocha is a JavaScript testing framework and Chai is a BDD/TDD JavaScript assertion library. BDD/TDD stands for behavior and test-driven development respectively. Effective BDD/TDD necessitates writing your tests before writing your smart contract code. The structure of this tutorial doesn't strictly follow these guidelines, but you may wish to adopt these principles in your development workflow. Hardhat recommends using Hardhat Toolbox, a plugin that bundles everything you need to get started with Hardhat, including Mocha and Chai.</p> <p>Because we will initially be running our tests on a local Moonbeam node, we need to specify Alice's address as the address of our target collator (Alice's account is the only collator for a local development node):</p> <pre><code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\n</code></pre> <p>If instead you prefer to run your tests against Moonbase Alpha, you can choose the below collator, or any other collator on Moonbase Alpha you would like the DAO to delegate to:</p> <pre><code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5\n</code></pre>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#configuring-the-test-file","title":"Configuring the Test File","text":"<p>To set up your test file, take the following steps:</p> <ol> <li> <p>Create a <code>tests</code> directory</p> <pre><code>mkdir tests\n</code></pre> </li> <li> <p>Create a new file called <code>Dao.js</code></p> <pre><code>touch tests/Dao.js\n</code></pre> </li> <li> <p>Then copy and paste the contents below to set up the initial structure of your test file. Be sure to read the comments, as they can clarify the purpose of each line</p> <pre><code>// Import Ethers\nconst { ethers } = require('hardhat');\n\n// Import Chai to use its assertion functions here\nconst { expect } = require('chai');\n\n// Indicate Alice's address as the target collator on local development node\nconst targetCollator = '0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac';\n</code></pre> </li> </ol>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#deploying-a-staking-dao-for-testing","title":"Deploying a Staking DAO for Testing","text":"<p>Before we can run any test cases we'll need to launch a staking DAO with an initial configuration. Our setup here is relatively simple - we'll be deploying a staking DAO with a single administrator (the deployer) and then adding a new member to the DAO. This simple setup is perfect for demonstration purposes, but it's easy to imagine more complex configurations you'd like to test, such as a scenario with 100 DAO members or one with multiple admins of the DAO.</p> <p>Mocha's <code>describe</code> function enables you to organize your tests. Multiple <code>describe</code> functions can be nested together. It's entirely optional but can be useful, especially in complex projects with many test cases. You can read more about constructing tests and getting started with Mocha on the Mocha docs site.</p> <p>We'll define a function called <code>deployDao</code> containing the setup steps for our staking DAO. To configure your test file, add the following snippet:</p> <pre><code>// The describe function receives the name of a section of your test suite, and a callback. The callback must define the tests of that section. This callback can't be an async function\ndescribe('Dao contract', function () {\n  let wallet1, wallet2;\n\n  before(async function () {\n    // Get signers we defined in Hardhat config\n    const signers = await ethers.getSigners();\n    wallet1 = signers[0];\n    wallet2 = signers[1];\n  });\n\n  async function deployDao() {\n    const delegationDaoFactory = await ethers.getContractFactory(\n      'DelegationDAO',\n      wallet2\n    );\n\n    // Deploy the staking DAO and wait for the deployment transaction to be confirmed\n    try {\n      const deployedDao = await delegationDaoFactory.deploy(\n        targetCollator,\n        wallet2.address\n      );\n      await deployedDao.waitForDeployment(); // Wait for the transaction to be mined\n      return { deployedDao };\n    } catch (error) {\n      console.error('Failed to deploy contract:', error);\n      return null; // Return null to indicate failure\n    }\n  }\n  // Insert additional tests here\n}); \n</code></pre>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#writing-your-first-test-cases","title":"Writing your First Test Cases","text":"<p>First, you'll create a subsection called <code>Deployment</code> to keep the test file organized. This will be nested within the <code>Dao contract</code> describe function. Next, you'll define your first test case by using the <code>it</code> Mocha function. This first test checks to see that the staking DAO correctly stores the address of the target collator.</p> <p>Add the snippet below to the end of your <code>Dao contract</code> function.</p> <pre><code>// You can nest calls to create subsections\ndescribe('Deployment', function () {\n  // Mocha's it function is used to define each of your tests. It receives the test name, and a callback function. If the callback function is async, Mocha will await it. Test case to check that the correct target collator is stored\n  it('should store the correct target collator in the DAO', async function () {\n    const deployment = await deployDao();\n    if (!deployment || !deployment.deployedDao) {\n      throw new Error('Deployment failed; DAO contract was not deployed.');\n    }\n    const { deployedDao } = deployment;\n\n    // The expect function receives a value and wraps it in an assertion object.\n    // This test will pass if the DAO stored the correct target collator\n    expect(await deployedDao.getTarget()).to.equal(\n      '0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac'\n    );\n  });\n  // The following test cases should be added here\n});\n</code></pre> <p>Now, add another test case. When a staking DAO is launched, it shouldn't have any funds. This test verifies that is indeed the case. Go ahead and add the following test case to your <code>Dao.js</code> file:</p> <pre><code>// Test case to check that the DAO has 0 funds at inception\nit('should initially have 0 funds in the DAO', async function () {\n  const { deployedDao } = await deployDao();\n  // This test will pass if the DAO has no funds as expected before any contributions\n  expect(await deployedDao.totalStake()).to.equal(0);\n});\n</code></pre>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#function-reverts","title":"Function Reverts","text":"<p>Now, you'll implement a more complex test case with a slightly different architecture. In prior examples, you've verified that a function returns an expected value. In this one, you'll be verifying that a function reverts. You'll also change the caller's address to test an admin-only function.</p> <p>In the staking DAO contract, only admins are authorized to add new members to the DAO. One could write a test that checks to see if the admin is authorized to add new members but a more important test is to ensure that non-admins can't add new members. To run this test case under a different account, you will ask for another address when you call <code>ethers.getSigners()</code> and specify the caller in the assertion with <code>connect(member1)</code>. Finally, after the function call you'll append <code>.to.be.reverted</code> to indicate that the test case is successful if the function reverts. And if it doesn't revert, it's a failed test!</p> <pre><code>// Test case to check that non-admins cannot grant membership\nit('should not allow non-admins to grant membership', async function () {\n  const { deployedDao } = await deployDao();\n  // Connect the non-admin wallet to the deployed contract\n  const deployedDaoConnected = deployedDao.connect(wallet1);\n  const tx = deployedDaoConnected.grant_member(\n    '0x0000000000000000000000000000000000000000'\n  );\n\n  // Check that the transaction reverts, not specifying any particular reason\n  await expect(tx).to.be.reverted;\n});\n</code></pre>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#signing-transactions-from-other-accounts","title":"Signing Transactions from Other Accounts","text":"<p>For this example, you'll verify whether the newly added DAO member can call the <code>check_free_balance()</code> function of staking DAO, which has an access modifier such that only members can access it.</p> <pre><code>// Test case to check that members can access member only functions\nit('should only allow members to access member-only functions', async function () {\n  const { deployedDao } = await deployDao();\n\n  // Connect the wallet1 to the deployed contract and grant membership\n  const deployedDaoConnected = deployedDao.connect(wallet2);\n  const grantTx = await deployedDaoConnected.grant_member(wallet1.address);\n  await grantTx.wait();\n\n  // Check the free balance using the member's credentials\n  const checkTx = deployedDaoConnected.check_free_balance();\n\n  // Since check_free_balance() does not modify state, we expect it not to be reverted and check the balance\n  await expect(checkTx).to.not.be.reverted;\n  expect(await checkTx).to.equal(0);\n});\n</code></pre> <p>And that's it! You're now ready to run your tests!</p>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#running-your-tests","title":"Running your Tests","text":"<p>If you've followed all of the prior sections, your <code>Dao.js</code> test file should be all set to go.</p> Dao.js <pre><code>// Import Ethers\nconst { ethers } = require('hardhat');\n// Import Chai to use its assertion functions here\nconst { expect } = require('chai');\n\n// Indicate the collator the DAO wants to delegate to\n// For Moonbase Local Node, use: 0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\n// For Moonbase Alpha, use: 0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5\nconst targetCollator = 'INSERT_COLLATOR_ADDRESS';\n\n// The describe function receives the name of a section of your test suite, and a\n// callback. The callback must define the tests of that section. This callback\n// can't be an async function\ndescribe('Dao contract', function () {\n  let wallet1, wallet2;\n\n  before(async function () {\n    // Get signers we defined in Hardhat config\n    const signers = await ethers.getSigners();\n    wallet1 = signers[0];\n    wallet2 = signers[1];\n  });\n\n  async function deployDao() {\n    const delegationDaoFactory = await ethers.getContractFactory(\n      'DelegationDAO',\n      wallet2\n    );\n\n    // Deploy the staking DAO and wait for the deployment transaction to be confirmed\n    try {\n      const deployedDao = await delegationDaoFactory.deploy(\n        targetCollator,\n        wallet2.address\n      );\n      await deployedDao.waitForDeployment(); // Correct way to wait for the transaction to be mined\n      return { deployedDao };\n    } catch (error) {\n      console.error('Failed to deploy contract:', error);\n      return null; // Return null to indicate failure\n    }\n  }\n\n  describe('Deployment', function () {\n    // Test case to check that the correct target collator is stored\n    it('should store the correct target collator in the DAO', async function () {\n      const deployment = await deployDao();\n      if (!deployment || !deployment.deployedDao) {\n        throw new Error('Deployment failed; DAO contract was not deployed.');\n      }\n      const { deployedDao } = deployment;\n      expect(await deployedDao.getTarget()).to.equal(\n        '0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac'\n      );\n    });\n\n    // Test case to check that the DAO has 0 funds at inception\n    it('should initially have 0 funds in the DAO', async function () {\n      const { deployedDao } = await deployDao();\n      expect(await deployedDao.totalStake()).to.equal(0);\n    });\n\n    // Test case to check that non-admins cannot grant membership\n    it('should not allow non-admins to grant membership', async function () {\n      const { deployedDao } = await deployDao();\n      // Connect the non-admin wallet to the deployed contract\n      const deployedDaoConnected = deployedDao.connect(wallet1);\n      const tx = deployedDaoConnected.grant_member(\n        '0x0000000000000000000000000000000000000000'\n      );\n\n      // Check that the transaction reverts, not specifying any particular reason\n      await expect(tx).to.be.reverted;\n    });\n\n    // Test case to check that members can access member only functions\n    it('should only allow members to access member-only functions', async function () {\n      const { deployedDao } = await deployDao();\n\n      // Connect the wallet1 to the deployed contract and grant membership\n      const deployedDaoConnected = deployedDao.connect(wallet2);\n      const grantTx = await deployedDaoConnected.grant_member(wallet1.address);\n      await grantTx.wait();\n\n      // Check the free balance using the member's credentials\n      const checkTx = deployedDaoConnected.check_free_balance();\n\n      // Since check_free_balance() does not modify state, we expect it not to be reverted and check the balance\n      await expect(checkTx).to.not.be.reverted;\n      expect(await checkTx).to.equal(0);\n    });\n  });\n});\n</code></pre> <p>Since our test cases encompass mostly configuration and setup of the staking DAO and don't involve actual delegation actions, we'll be running our tests on a Moonbeam development node (local node). Remember that Alice (<code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code>) is the only collator on a local development node. You can use the flag <code>--network moonbase</code> to run the tests using Moonbase Alpha. In that case, ensure your deployer address is sufficiently funded with DEV tokens.</p> <p>Challenge</p> <p>Try to create an additional test case that verifies the staking DAO successfully delegates to a collator once <code>minDelegationStk</code> is met. You must test this on Moonbase Alpha rather than a local development node.</p> <p>First, make sure that your local Moonbeam node is running by following the instructions for launching a local development node. Take precautions because you could inadvertently send real funds to the Alice and Bob development accounts, resulting in a loss of those funds.  </p> <p>You can run your tests with the following command:</p> <pre><code>npx hardhat test --network dev tests/Dao.js\n</code></pre> <p>If everything was set up correctly, you should see output like the following:</p> npx hardhat test --network dev tests/Dao.js Dao contract      Deployment  \u2705 The DAO should store the correct target collator (1624ms)  \u2705 The DAO should initially have 0 funds in it  \u2705 Non-admins should not be able to grant membership (150ms)  \u2705 DAO members should be able to access member only functions (132ms)  \u2705 4 passing (2s)"},{"location":"tutorials/eth-api/hardhat-start-to-end/#deploying-to-moonbase-alpha","title":"Deploying to Moonbase Alpha","text":"<p>In the following steps, we'll deploy the <code>DelegationDAO</code> to the Moonbase Alpha TestNet. Before deploying to Moonbase Alpha or Moonbeam, double-check that you're not using the Alice and Bob accounts, which should only be used on a local development node.</p> <p>As a side note, <code>DelegationDAO</code> relies on <code>StakingInterface.sol</code>, which is a Substrate-based offering unique to Moonbeam networks. The Hardhat Network and forked networks are simulated EVM environments which do not include the Substrate-based precompiles like <code>StakingInterface.sol</code>. Therefore, <code>DelegationDAO</code> will not work properly if deployed to the local default Hardhat Network or a forked network.</p> <p>To deploy <code>DelegationDAO</code>, you'll use Hardhat Ignition, a declarative framework for deploying smart contracts. Hardhat Ignition is designed to make managing recurring tasks surrounding smart contract deployment and testing easy. For more information about Hardhat Ignition and its architecture, be sure to check out the Hardhat Ignition docs.</p> <p>To set up the proper file structure for your Ignition module, change to the ignition directory and create the DelegationDao.js file:</p> <pre><code>cd ignition/modules &amp;&amp; touch DelegationDao.js\n</code></pre> <p>Next, you can write your Hardhat Ignition module. To get started, take the following steps:</p> <ol> <li>Import the <code>buildModule</code> function from the Hardhat Ignition module</li> <li>Export a module using <code>buildModule</code></li> <li>Specify the target collator candidate for the DAO to delegate to</li> <li>Use the <code>getAccount</code> method to select the deployer account</li> <li>Deploy <code>DelegationDAO.sol</code></li> <li>Return an object from the module. This makes the <code>DelegationDao</code> contract accessible for interaction in Hardhat tests and scripts</li> </ol> <p>When all is said and done your deployment script should look similar to the following:</p> <pre><code>// 1. Import the required function from the Hardhat Ignition module\nimport { buildModule } from '@nomicfoundation/hardhat-ignition/modules';\n\n// 2. Define and export your deployment module using `buildModule`\nconst DelegationDAOModule = buildModule('DelegationDAOModule', (m) =&gt; {\n  // 3. Specify the target collator address for the DAO\n  const targetCollator = '0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5';\n\n  // 4. Use the `getAccount` method to select the deployer account\n  const deployer = m.getAccount(0);\n\n  // 5. Deploy the `DelegationDAO` contract\n  const delegationDao = m.contract(\n    'DelegationDAO',\n    [targetCollator, deployer],\n    {\n      from: deployer,\n    }\n  );\n\n  // 6. Return an object from the module including references to deployed contracts, allowing the contract to be accessible for interaction in Hardhat tests and scripts\n  return { delegationDao };\n});\n\n// Export the module as default\nexport default DelegationDAOModule;\n</code></pre> <p>To run the script and deploy the <code>DelegationDAO.sol</code> contract, use the following command, which requires you to specify the network name as defined in your <code>hardhat.config.js</code>. If you don't specify a network, Hardhat will deploy the contract to a local Hardhat network by default. </p> <pre><code>npx hardhat ignition deploy ./DelegationDao.js --network moonbase --deployment-id INSERT_YOUR_NAME\n</code></pre> <p>You'll be prompted to confirm the network you wish to deploy to. After a few seconds after you confirm, the contract is deployed, and you'll see the contract address in the terminal.</p>  npx hardhat ignition deploy ./DelegationDao.js --network moonbase --deployment-id INSERT_YOUR_NAME \u2705 Confirm deploy to network moonbase (1287)? \u2026 yes Hardhat Ignition \ud83d\ude80 Deploying [ DelegationDAOModule ] Batch #1 Executed DelegationDAOModule#DelegationDAO [ DelegationDAOModule ] successfully deployed \ud83d\ude80 Deployed Addresses DelegationDAOModule#DelegationDAO - 0x69c555fE1A8D0916E6dab0629bd7530D4d2Be4D1 <p>Congratulations, your contract is live on Moonbase Alpha! Save the address, as you will use it to interact with this contract instance in the next step.</p>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#verifying-contracts-on-moonbase-alpha","title":"Verifying Contracts on Moonbase Alpha","text":"<p>Contract verification is an essential step of any developer's workflow, particularly in the theoretical example of this staking DAO. Potential participants in the DAO need to be assured that the smart contract works as intended - and verifying the contract allows anyone to observe and analyze the deployed smart contract.</p> <p>While it's possible to verify smart contracts on the Moonscan website, the Hardhat Etherscan plugin enables us to verify our staking DAO in a faster and easier manner. It's not an exaggeration to say that the plugin dramatically simplifies the contract verification process, especially for projects that include multiple Solidity files or libraries.</p> <p>Before beginning the contract verification process, you'll need to acquire an Etherscan API Key. Note that Moonbeam, Moonriver, and Moonbase Alpha all use the same unified Etherscan API key.</p> <p>To verify the contract, you will run the <code>ignition verify</code> command and pass the name of your deployment you set in the prior step.</p> <pre><code>npx hardhat ignition verify INSERT_YOUR_NAME\n</code></pre> <p>Note</p> <p>If you're deploying <code>DelegationDAO.sol</code> verbatim without any changes, you may get an <code>Already Verified</code> error because Moonscan automatically recognizes and verifies smart contracts that have matching bytecode. Your contract will still show as verified, so there is nothing else you need to do. However, if you'd prefer to verify your own <code>DelegationDAO.sol</code>, you can make a small change to the contract (such as changing a comment) and repeating the compilation, deployment and verification steps.</p> <p>In your terminal, you should see the source code for your contract was successfully submitted for verification. If the verification was successful, you should see Successfully verified contract and there will be a link to the contract code on Moonscan for Moonbase Alpha. If the plugin returns an error, double check that your API key is configured correctly and that you have specified all necessary parameters in the verification command. You can refer to the guide to the Hardhat Etherscan plugin for more information.</p>  npx hardhat ignition verify INSERT_YOUR_NAME Nothing to compile Successfully submitted source code for contract contracts/DelegationDAO.sol:DelegationDAO at 0x5D788B98E4A90F9642352B0b32694998e77cF4d7 for verification on the block explorer. Waiting for verification result... Successfully verified contract DelegationDAO on Etherscan. https://moonbase.moonscan.io/address/0x5D788B98E4A90F9642352B0b32694998e77cF4d7#code"},{"location":"tutorials/eth-api/hardhat-start-to-end/#deploying-to-production-on-moonbeam-mainnet","title":"Deploying to Production on Moonbeam Mainnet","text":"<p>Note</p> <p><code>DelegationDAO.sol</code> is unreviewed and unaudited. It is designed only for demonstration purposes and not intended for production use. It may contain bugs or logic errors that could result in loss of funds.</p> <p>In the following steps, we'll be deploying the <code>DelegationDAO</code> contract to the Moonbeam MainNet network. Remember to add the Moonbeam network to your <code>hardhat.config.js</code> and update the private keys of your accounts on Moonbeam if you haven't done so already. Before deploying <code>DelegationDAO</code> to Moonbeam, we need to change the address of the target collator, since our target collator on Moonbase Alpha does not exist on Moonbeam. Head to your deploy script and change the target collator to <code>0x1C86E56007FCBF759348dcF0479596a9857Ba105</code> or another Moonbeam collator of your choice. Your deployment script, named <code>DelegationDao.js</code>, should thus look like the following:</p> <pre><code>// 1. Import the required function from the Hardhat Ignition module\nimport { buildModule } from '@nomicfoundation/hardhat-ignition/modules';\n\n// 2. Define and export your deployment module using `buildModule`\nconst DelegationDAOModule = buildModule('DelegationDAOModule', (m) =&gt; {\n  // 3. Specify the target collator address for the DAO\n  const targetCollator = '0x1C86E56007FCBF759348dcF0479596a9857Ba105';\n\n  // 4. Use the `getAccount` method to select the deployer account\n  const deployer = m.getAccount(0);\n\n  // 5. Deploy the `DelegationDAO` contract\n  const delegationDao = m.contract(\n    'DelegationDAO',\n    [targetCollator, deployer],\n    {\n      from: deployer,\n    }\n  );\n\n  // 6. Return an object from the module including references to deployed contracts, allowing the contract to be accessible for interaction in Hardhat tests and scripts\n  return { delegationDao };\n});\n\n// Export the module as default\nexport default DelegationDAOModule;\n</code></pre> <p>To run the script and deploy the <code>DelegationDAO.sol</code> contract, use the following command, which requires you to specify the network name as defined in your <code>hardhat.config.js</code>. If you don't specify a network, Hardhat will deploy the contract to a local Hardhat network by default. </p> <pre><code>npx hardhat ignition deploy ./ignition/modules/DelegationDao.js --network moonbeam --deployment-id INSERT_YOUR_NAME\n</code></pre> <p>You'll be prompted to confirm the network you wish to deploy to. After a few seconds after you confirm, the contract is deployed, and you'll see the contract address in the terminal.</p>  npx hardhat ignition deploy ./DelegationDao.js --network moonbeam --deployment-id INSERT_YOUR_NAME \u2705 Confirm deploy to network moonbeam (1284)? \u2026 yes Hardhat Ignition \ud83d\ude80 Deploying [ DelegationDAOModule ] Batch #1 Executed DelegationDAOModule#DelegationDAO [ DelegationDAOModule ] successfully deployed \ud83d\ude80 Deployed Addresses DelegationDAOModule#DelegationDAO - 0x6D895A55F5ba31e582bCEe71cae394266F240e9b <p>Congratulations, your contract is live on Moonbeam! Save the address, as you will use it to interact with this contract instance in the next step.</p>"},{"location":"tutorials/eth-api/hardhat-start-to-end/#verifying-contracts-on-moonbeam","title":"Verifying Contracts on Moonbeam","text":"<p>In this section, we'll be verifying the contract that was just deployed on Moonbeam. Before beginning the contract verification process, you'll need to acquire an Etherscan API Key. Note that Moonbeam, Moonriver, and Moonbase Alpha all use the same unified Etherscan API key.</p> <p>To verify the contract, you will run the <code>ignition verify</code> command and pass the name of your deployment you set in the prior step.</p> <pre><code>npx hardhat ignition verify INSERT_YOUR_NAME\n</code></pre> <p>Note</p> <p>If you're deploying <code>DelegationDAO.sol</code> verbatim without any changes, you may get an <code>Already Verified</code> error because Moonscan automatically recognizes and verifies smart contracts that have matching bytecode. Your contract will still show as verified, so there is nothing else you need to do. However, if you'd prefer to verify your own <code>DelegationDAO.sol</code>, you can make a small change to the contract (such as changing a comment) and repeating the compilation, deployment, and verification steps.</p> <p>In your terminal you should see the source code for your contract was successfully submitted for verification. If the verification was successful, you should see Successfully verified contract and there will be a link to the contract code on Moonbeam Moonscan. If the plugin returns an error, double check that your API key is configured correctly and that you have specified all necessary parameters in the verification command. You can refer to the guide to the Hardhat Etherscan plugin for more information.</p>  npx hardhat ignition verify INSERT_YOUR_NAME Nothing to compile Successfully submitted source code for contract contracts/DelegationDAO.sol:DelegationDAO at 0x6D895A55F5ba31e582bCEe71cae394266F240e9b for verification on the block explorer. Waiting for verification result... Successfully verified contract DelegationDAO on Etherscan. https://moonbeam.moonscan.io/address/0x6D895A55F5ba31e582bCEe71cae394266F240e9b#code <p>And that's it! We covered a lot of ground in this tutorial, but there's more resources available if you'd like to go deeper, including the following:</p> <ul> <li>Hardhat guide to Testing Contracts</li> <li>Writing tasks and scripts</li> </ul>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/eth-api/how-to-build-a-dapp/","title":"How to Build a DApp: Complete DApp Architecture","text":"<p>by Jeremy Boetticher</p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#introduction","title":"Introduction","text":"<p>Decentralized applications, or DApps, have redefined how applications are built, managed, and interacted with in Web3. By leveraging blockchain technology, DApps provide a secure, transparent, and trustless system that enables peer-to-peer interactions without any central authority. At the core of a DApp's architecture are several main components that work in tandem to create a robust, decentralized ecosystem. These components include smart contracts, nodes, frontend user interfaces, and more.  </p> <p></p> <p>In this tutorial, you'll come face-to-face with each major component by writing a full DApp that mints tokens. We'll also explore additional optional components of DApps that can enhance user experience for your future projects. You can view the complete project in its monorepo on GitHub.  </p> <p></p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you should have the following:</p> <ul> <li>A Moonbase Alpha account funded with DEV.    You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>Node.js version 16 or newer installed</li> <li>VS Code with Juan Blanco's Solidity extension is a recommended IDE</li> <li>Understanding of JavaScript and React</li> <li>Novice familiarity with Solidity. If you are not familiar with writing Solidity, there are many resources out there, including Solidity by Example. A 15-minute skim should suffice for this tutorial</li> <li>A wallet like MetaMask installed</li> </ul>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#nodes-and-json-rpc-endpoints","title":"Nodes and JSON-RPC Endpoints","text":"<p>Generally speaking, a JSON-RPC is a remote procedure call (RPC) protocol that utilizes JSON to encode data. For Web3, they refer to the specific JSON-RPCs that DApp developers use to send requests and receive responses from blockchain nodes, making it a crucial element in interactions with smart contracts. They allow frontend user interfaces to seamlessly interact with the smart contracts and provide users with real-time feedback on their actions. They also allow developers to deploy their smart contracts in the first place!  </p> <p>To get a JSON-RPC to communicate with a Moonbeam blockchain, you need to run a node. But that can be expensive, complicated, and a hassle. Fortunately, as long as you have access to a node, you can interact with the blockchain. Moonbase Alpha has a handful of free and paid node options. For this tutorial, we will be using the Moonbeam Foundation's public node for Moonbase Alpha, but you are encouraged to get your own private endpoint.  </p> <pre><code>https://rpc.api.moonbase.moonbeam.network\n</code></pre> <p>So now you have a URL. How do you use it? Over <code>HTTPS</code>, JSON-RPC requests are <code>POST</code> requests that include specific methods for reading and writing data, such as <code>eth_call</code> for executing a smart contract function in a read-only manner or <code>eth_sendRawTransaction</code> for submitting signed transactions to the network (calls that change the blockchain state). The entire JSON request structure will always have a structure similar to the following:  </p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"eth_getBalance\",\n    \"params\": [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\", \"latest\"]\n}\n</code></pre> <p>This example is getting the balance (in DEV on Moonbase Alpha) of the <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code> account. Let's break down the elements:  </p> <ul> <li><code>jsonrpc</code> \u2014 the JSON-RPC API version, usually \"2.0\"</li> <li><code>id</code> \u2014 an integer value that helps identify a response to a request. Can usually just keep it as 1</li> <li><code>method</code> \u2014 the specific method to read/write data from/to the blockchain. You can see many of the RPC methods on our docs site</li> <li><code>params</code> \u2014 an array of the input parameters expected by the specific <code>method</code> </li> </ul> <p>There are also additional elements that can be added to JSON-RPC requests, but those four will be seen the most often.  </p> <p>Now, these JSON-RPC requests are pretty useful, but when writing code, it can be a hassle to create a JSON object over and over again. That's why there exist libraries that help abstract and facilitate the usage of these requests. Moonbeam provides documentation on many libraries, and the one that we will be using in this tutorial is Ethers.js. Just understand that whenever we interact with the blockchain through the Ethers.js package, we're really using JSON-RPC!  </p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#smart-contracts","title":"Smart Contracts","text":"<p>Smart contracts are self-executing contracts with the terms of the agreement directly written into code. They serve as the decentralized backend of any DApp, automating and enforcing the business logic within the system.  </p> <p>If coming from traditional web development, smart contracts are meant to replace the backend with important caveats: the user must have the native currency (GLMR, MOVR, DEV, etc.) to make state-changing requests, storing information can be expensive, and no information stored is private.  </p> <p>When you deploy a smart contract onto Moonbeam, you upload a series of instructions that can be understood by the EVM, or the Ethereum Virtual Machine. Whenever someone interacts with a smart contract, these transparent, tamper-proof, and immutable instructions are executed by the EVM to change the blockchain's state. Writing the instructions in a smart contract properly is very important since the blockchain's state defines the most crucial information about your DApp, such as who has what amount of money.  </p> <p>Since the instructions are difficult to write and make sense of at a low (assembly) level, we have smart contract languages such as Solidity to make it easier to write them. To help write, debug, test, and compile these smart contract languages, developers in the Ethereum community have created developer environments such as Hardhat and Foundry. Moonbeam's developer site provides information on a plethora of developer environments.</p> <p>This tutorial will use Hardhat for managing smart contracts.</p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#create-hardhat-project","title":"Create a Hardhat Project","text":"<p>You can initialize a project with Hardhat using the following command:  </p> <pre><code>npx hardhat init\n</code></pre> <p>When creating a JavaScript or TypeScript Hardhat project, you will be asked if you want to install the sample project's dependencies, which will install Hardhat and the Hardhat Toolbox plugin. You don't need all of the plugins that come wrapped up in the Toolbox, so instead you can install Hardhat, Ethers, and the Hardhat Ethers plugin, which is all you'll need for this tutorial:</p> <pre><code>npm install --save-dev hardhat @nomicfoundation/hardhat-ethers ethers@6\n</code></pre> <p>Before we start writing the smart contract, let's add a JSON-RPC URL to the config. Set the <code>hardhat.config.js</code> file with the following code, and replace <code>INSERT_YOUR_PRIVATE_KEY</code> with your funded account's private key.</p> <p>Remember</p> <p>This is for testing purposes, never store your private key in plain text with real funds.  </p> <pre><code>require('@nomicfoundation/hardhat-ethers');\nmodule.exports = {\n  solidity: '0.8.20',\n  networks: {\n    moonbase: {\n      url: 'https://rpc.api.moonbase.moonbeam.network',\n      chainId: 1287,\n      accounts: ['INSERT_YOUR_PRIVATE_KEY']\n    }\n  }\n};\n</code></pre>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#write-smart-contracts","title":"Write Smart Contracts","text":"<p>Recall that we're making a DApp that allows you to mint a token for a price. Let's write a smart contract that reflects this functionality!  </p> <p>Once you've initialized a Hardhat project, you'll be able to write smart contracts in its <code>contracts</code> folder. This folder will have an initial smart contract, likely called <code>Lock.sol</code>, but you should delete it and add a new smart file called <code>MintableERC20.sol</code>.  </p> <p>The standard for tokens is called ERC-20, where ERC stands for \"Ethereum Request for Comment\". A long time ago, this standard was defined, and now most smart contracts that work with tokens expect tokens to have all of the functionality defined by ERC-20. Fortunately, you don't have to know it from memory since the OpenZeppelin smart contract team provides us with smart contract bases to use.  </p> <p>Install OpenZeppelin smart contracts:  </p> <pre><code>npm install @openzeppelin/contracts\n</code></pre> <p>Now, in your <code>MintableERC20.sol</code>, add the following code:  </p> <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MintableERC20 is ERC20, Ownable {\n    constructor(address initialOwner) ERC20(\"Mintable ERC 20\", \"MERC\") Ownable(initialOwner) {}\n}\n</code></pre> <p>When writing smart contracts, you're going to have to compile them eventually. Every developer environment for smart contracts will have this functionality. In Hardhat, you can compile with:  </p> <pre><code>npx hardhat compile\n</code></pre> <p>Everything should compile well, which should cause two new folders to pop up: <code>artifacts</code> and <code>cache</code>. These two folders hold information about the compiled smart contracts.  </p> <p>Let's continue by adding functionality. Add the following constants, errors, event, and function to your Solidity file:  </p> <pre><code>    uint256 public constant MAX_TO_MINT = 1000 ether;\n\n    event PurchaseOccurred(address minter, uint256 amount);\n    error MustMintOverZero();\n    error MintRequestOverMax();\n    error FailedToSendEtherToOwner();\n\n    /**Purchases some of the token with native currency. */\n    function purchaseMint() payable external {\n        // Calculate amount to mint\n        uint256 amountToMint = msg.value;\n\n        // Check for no errors\n        if(amountToMint == 0) revert MustMintOverZero();\n        if(amountToMint + totalSupply() &gt; MAX_TO_MINT) revert MintRequestOverMax();\n\n        // Send to owner\n        (bool success, ) = owner().call{value: msg.value}(\"\");\n        if(!success) revert FailedToSendEtherToOwner();\n\n        // Mint to user\n        _mint(msg.sender, amountToMint);\n        emit PurchaseOccurred(msg.sender, amountToMint);\n    }\n</code></pre> MintableERC20.sol file <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MintableERC20 is ERC20, Ownable {\n    constructor(address initialOwner) ERC20(\"Mintable ERC 20\", \"MERC\") Ownable(initialOwner) {}\n\n    uint256 public constant MAX_TO_MINT = 1000 ether;\n\n    event PurchaseOccurred(address minter, uint256 amount);\n    error MustMintOverZero();\n    error MintRequestOverMax();\n    error FailedToSendEtherToOwner();\n\n    /**Purchases some of the token with native gas currency. */\n    function purchaseMint() external payable {\n        // Calculate amount to mint\n        uint256 amountToMint = msg.value;\n\n        // Check for no errors\n        if (amountToMint == 0) revert MustMintOverZero();\n        if (amountToMint + totalSupply() &gt; MAX_TO_MINT)\n            revert MintRequestOverMax();\n\n        // Send to owner\n        (bool success, ) = owner().call{value: msg.value}(\"\");\n        if (!success) revert FailedToSendEtherToOwner();\n\n        // Mint to user\n        _mint(msg.sender, amountToMint);\n        emit PurchaseOccurred(msg.sender, amountToMint);\n    }\n}\n</code></pre> <p>This function will allow a user to send the native Moonbeam currency (like GLMR, MOVR, or DEV) as value because it is a payable function. Let's break down the function section by section.  </p> <ol> <li>It will figure out how much of the token to mint based on the value sent</li> <li>Then it will check to see if the amount minted is 0 or if the total amount minted is over the <code>MAX_TO_MINT</code>, giving a descriptive error in both cases</li> <li>The contract will then forward the value included with the function call to the owner of the contract (by default, the address that deployed the contract, which will be you)</li> <li>Finally, tokens will be minted to the user, and an event will be emitted to pick up on later  </li> </ol> <p>To make sure that this works, let's use Hardhat again:  </p> <pre><code>npx hardhat compile\n</code></pre> <p>You've now written the smart contract for your DApp! If this were a production app, we would write tests for it, but that is out of the scope of this tutorial. Let's deploy it next.  </p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#deploying-smart-contracts","title":"Deploy Smart Contracts","text":"<p>Under the hood, Hardhat is a Node project that uses the Ethers.js library to interact with the blockchain. You can also use Ethers.js in conjunction with Hardhat's tool to create scripts to do things like deploy contracts.  </p> <p>Your Hardhat project should already come with a script in the <code>scripts</code> folder, called <code>deploy.js</code>. Let's replace it with a similar, albeit simpler, script.</p> <pre><code>const hre = require('hardhat');\n\nasync function main() {\n  const [deployer] = await hre.ethers.getSigners();\n\n  const MintableERC20 = await hre.ethers.getContractFactory('MintableERC20');\n  const token = await MintableERC20.deploy(deployer.address);\n  await token.waitForDeployment();\n\n  // Get and print the contract address\n  const myContractDeployedAddress = await token.getAddress();\n  console.log(`Deployed to ${myContractDeployedAddress}`);\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre> <p>This script uses Hardhat's instance of the Ethers library to get a contract factory of the <code>MintableERC20.sol</code> smart contract that we wrote earlier. It then deploys it and prints the resultant smart contract's address. Very simple to do with Hardhat and the Ethers.js library, but significantly more difficult using just JSON-RPC!  </p> <p>Let's run the contract on Moonbase Alpha (whose JSON-RPC endpoint we defined in the <code>hardhat.config.js</code> script earlier):  </p> <pre><code>npx hardhat run scripts/deploy.js --network moonbase\n</code></pre> <p>You should see an output that displays the token address. Make sure to save it for use later!</p> <p>Challenge</p> <p>Hardhat has a poor built-in solution for deploying smart contracts. It doesn't automatically save the transactions and addresses related to the deployment! This is why the hardhat-deploy package was created. Can you implement it yourself? Or can you switch to a different developer environment, like Foundry?</p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#creating-a-dapp-frontend","title":"Create a DApp Frontend","text":"<p>Frontends provide an interface for users to interact with blockchain-based applications. React, a popular JavaScript library for building user interfaces, is often used for developing DApp frontends due to its component-based architecture, which promotes reusable code and efficient rendering. The useDApp package, an Ethers.js based React framework for DApps, further simplifies the process of building DApp frontends by providing a comprehensive set of hooks and components that streamline the integration of Ethereum blockchain functionality.  </p> <p>Note</p> <p>Typically, a larger project will create separate GitHub repositories for their frontend and smart contracts, but this is a small enough project to create a monorepo.</p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#create-react-project-with-usedapp","title":"Create a React Project with useDapp","text":"<p>Let's set up a new React project and install dependencies, which we can create within our Hardhat project's folder without much issue. The <code>create-react-app</code> package will create a new <code>frontend</code> directory for us:  </p> <pre><code>npx create-react-app frontend\ncd frontend\nnpm install ethers@5.6.9 @usedapp/core @mui/material @mui/system @emotion/react @emotion/styled\n</code></pre> <p>If you remember, Ethers.js is a library that assists with JSON-RPC communication. The useDApp package is a similar library that uses Ethers.js and formats them into React hooks so that they work better in frontend projects. We've also added two MUI packages for styling and components.</p> <p>Let's set up the <code>App.js</code> file located in the <code>frontend/src</code> directory to add some visual structure:</p> <pre><code>import { useEthers } from '@usedapp/core';\nimport { Button, Grid, Card } from '@mui/material';\nimport { Box } from '@mui/system';\n\nconst styles = {\n  box: { minHeight: '100vh', backgroundColor: '#1b3864' },\n  vh100: { minHeight: '100vh' },\n  card: { borderRadius: 4, padding: 4, maxWidth: '550px', width: '100%' },\n  alignCenter: { textAlign: 'center' },\n};\n\nfunction App() {\n  return (\n    &lt;Box sx={styles.box}&gt;\n      &lt;Grid\n        container\n        direction='column'\n        alignItems='center'\n        justifyContent='center'\n        style={styles.vh100}\n      &gt;\n        {/* This is where we'll be putting our functional components! */}\n      &lt;/Grid&gt;\n    &lt;/Box&gt;\n  );\n}\n\nexport default App;\n</code></pre> <p>You can start the React project by running the following command from within the <code>frontend</code> directory:</p> <pre><code>npm run start\n</code></pre> <p>Note</p> <p>At this point, you may see a couple compilation warnings, but as we continue to build the DApp, we'll make changes that will resolve the warnings.</p> <p>Your frontend will be available at <code>http://localhost:3000</code>.</p> <p>At this point, our frontend project is set up well enough to start working on the functional code!  </p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#providers-signers-and-wallets","title":"Providers, Signers, and Wallets","text":"<p>The frontend communicates with the blockchain using JSON-RPC, but we will be using Ethers.js. When using JSON-RPC, Ethers.js likes to abstract degrees of interaction with the blockchain into objects, such as providers, signers, and wallets.  </p> <p>Providers are the bridge between the frontend user interface and the blockchain network, facilitating communication and data exchange. They abstract the complexities of interacting with the blockchain, offering a simple API for the frontend to use. They are responsible for connecting the DApp to a specific blockchain node, allowing it to read data from the blockchain, and essentially contain the JSON-RPC URL.  </p> <p>Signers are a type of provider that contain a secret that can be used to sign transactions with. This allows the frontend to create transactions, sign them, and then send them with <code>eth_sendRawTransaction</code>. There are multiple types of signers, but we're most interested in wallet objects, which securely store and manage users' private keys and digital assets. Wallets such as MetaMask facilitate transaction signing with a universal and user-friendly process. They act as a user's representation within the DApp, ensuring that only authorized transactions are executed. The Ethers.js wallet object represents this interface within our frontend code.</p> <p>Typically, a frontend using Ethers.js will require you to create a provider, connect to the user's wallet if applicable, and create a wallet object. This process can become unwieldy in larger projects, especially with the number of wallets that exist other than MetaMask.  </p> Example of unwieldy MetaMask handling <pre><code>// Detect if the browser has MetaMask installed\nlet provider, signer;\nif (typeof window.ethereum !== 'undefined') {\n  // Create a provider using MetaMask\n  provider = new ethers.BrowserProvider(window.ethereum);\n\n  // Connect to MetaMask\n  async function connectToMetaMask() {\n    try {\n      // Request access to the user's MetaMask account\n      const accounts = await window.ethereum.request({\n        method: 'eth_requestAccounts',\n      });\n\n      // Create a signer (wallet) using the provider\n      signer = provider.getSigner(accounts[0]);\n    } catch (error) {\n      console.error('Error connecting to MetaMask:', error);\n    }\n  }\n\n  // Call the function to connect to MetaMask\n  connectToMetaMask();\n} else {\n  console.log('MetaMask is not installed');\n}\n\n// ... also the code for disconnecting from the site\n// ... also the code that handles other wallets\n</code></pre> <p>Fortunately, we have installed the useDApp package, which simplifies many of the processes for us. This simultaneously abstracts what Ethers is doing as well, which is why we took a bit of time to explain them here.  </p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#create-provider","title":"Create a Provider","text":"<p>Let's do a bit of setup with the useDApp package. First, in your React frontend's <code>index.js</code> file, which is located in the <code>frontend/src</code> directory, add a <code>DAppProvider</code> object and its config. This essentially acts as the Ethers.js provider object, but can be used throughout your entire project by useDApp hooks:  </p> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport { DAppProvider, MoonbaseAlpha } from '@usedapp/core';\nimport { getDefaultProvider } from 'ethers';\n\nconst config = {\n  readOnlyChainId: MoonbaseAlpha.chainId,\n  readOnlyUrls: {\n    [MoonbaseAlpha.chainId]: getDefaultProvider(\n      'https://rpc.api.moonbase.moonbeam.network'\n    ),\n  },\n};\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  &lt;React.StrictMode&gt;\n    &lt;DAppProvider config={config}&gt;\n      &lt;App /&gt;\n    &lt;/DAppProvider&gt;\n  &lt;/React.StrictMode&gt;\n);\n</code></pre>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#connect-to-a-wallet","title":"Connect to a Wallet","text":"<p>Now in your <code>App.js</code> file, let's add a button that allows us to connect to MetaMask. We don't have to write any code that's wallet-specific, fortunately, since useDApp does it for us with the <code>useEthers</code> hook.  </p> <pre><code>function App() {\n  const { activateBrowserWallet, deactivate, account } = useEthers();\n\n  // Handle the wallet toggle\n  const handleWalletConnection = () =&gt; {\n    if (account) deactivate();\n    else activateBrowserWallet();\n  };\n\n  return (\n    &lt;Box sx={styles.box}&gt;\n      &lt;Grid\n        container\n        direction='column'\n        alignItems='center'\n        justifyContent='center'\n        style={styles.vh100}\n      &gt;\n        &lt;Box position='absolute' top={8} right={16}&gt;\n          &lt;Button variant='contained' onClick={handleWalletConnection}&gt;\n            {account\n              ? `Disconnect ${account.substring(0, 5)}...`\n              : 'Connect Wallet'}\n          &lt;/Button&gt;\n        &lt;/Box&gt;\n      &lt;/Grid&gt;\n    &lt;/Box&gt;\n  );\n};\n</code></pre> <p>Now there should be a button in the top right of your screen that connects your wallet to your frontend! Next, let's find out how we can read data from our smart contract.  </p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#reading-from-contracts","title":"Read Data from Smart Contracts","text":"<p>Reading from contracts is quite easy, as long as we know what we want to read. For our application, we will be reading the maximum amount of tokens that can be minted and the number of tokens that have already been minted. This way, we can display to our users how many tokens can still be minted and hopefully invoke some FOMO...  </p> <p>If you were just using JSON-RPC, you would use <code>eth_call</code> to get this data, but it's quite difficult to do this since you have to encode your requests in a non-straightforward method called ABI encoding. Fortunately, Ethers.js allows us to easily create objects that represent contracts in a human-readable way, so long as we have the ABI of the contract. And we have the ABI of the <code>MintableERC20.sol</code> contract, <code>MintableERC20.json</code>, within the <code>artifacts</code> directory of our Hardhat project!</p> <p>So let's start by moving the <code>MintableERC20.json</code> file into our frontend directory. Every time you change and recompile the smart contract, you'll have to update the ABI in the frontend as well. Some projects will have developer setups that automatically pull ABIs from the same source, but in this case we will just copy it over:  </p> <pre><code>|--artifacts\n    |--@openzeppelin\n    |--build-info\n    |--contracts\n        |--MintableERC20.sol\n            |--MintableERC20.json // This is the file you're looking for!\n            ...\n|--cache\n|--contracts\n|--frontend\n    |--public\n    |--src\n        |--MintableERC20.json // Copy the file to here!\n        ...\n    ...\n...\n</code></pre> <p>Now that we have the ABI, we can use it to create a contract instance of <code>MintableERC20.sol</code>, which we'll use to retrieve token data.</p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#create-a-contract-instance","title":"Create a Smart Contract Instance","text":"<p>Let's import the JSON file and the Ethers <code>Contract</code> object within <code>App.js</code>. We can create a contract object instance with an address and ABI, so replace <code>INSERT_CONTRACT_ADDRESS</code> with the address of the contract that you copied back when you deployed it:</p> <pre><code>// ... other imports\nimport MintableERC20 from './MintableERC20.json'; \nimport { Contract } from 'ethers';\n\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\nfunction App() {\n  const contract = new Contract(contractAddress, MintableERC20.abi);\n  // ...\n}\n</code></pre> App.js file <pre><code>import { useEthers } from '@usedapp/core';\nimport { Button, Grid, Card } from '@mui/material';\nimport { Box } from '@mui/system';\nimport { Contract } from 'ethers';\nimport MintableERC20 from './MintableERC20.json'; \n\nconst styles = {\n  box: { minHeight: '100vh', backgroundColor: '#1b3864' },\n  vh100: { minHeight: '100vh' },\n  card: { borderRadius: 4, padding: 4, maxWidth: '550px', width: '100%' },\n  alignCenter: { textAlign: 'center' },\n};\n\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\nfunction App() {\n  const contract = new Contract(contractAddress, MintableERC20.abi);\n  const { activateBrowserWallet, deactivate, account } = useEthers();\n\n  // Handle the wallet toggle\n  const handleWalletConnection = () =&gt; {\n    if (account) deactivate();\n    else activateBrowserWallet();\n  };\n\n  return (\n    &lt;Box sx={styles.box}&gt;\n      &lt;Grid\n        container\n        direction='column'\n        alignItems='center'\n        justifyContent='center'\n        style={styles.vh100}\n      &gt;\n        &lt;Box position='absolute' top={8} right={16}&gt;\n          &lt;Button variant='contained' onClick={handleWalletConnection}&gt;\n            {account\n              ? `Disconnect ${account.substring(0, 5)}...`\n              : 'Connect Wallet'}\n          &lt;/Button&gt;\n        &lt;/Box&gt;\n      &lt;/Grid&gt;\n    &lt;/Box&gt;\n  );\n}\n\nexport default App;\n</code></pre>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#interact-with-contract-interface","title":"Interact with the Contract Interface to Read Supply Data","text":"<p>And let's create a new <code>SupplyComponent</code> within a new <code>SupplyComponent.js</code> file, which will use the contract interface to retrieve the token supply data and display it:  </p> <pre><code>import { useCall } from '@usedapp/core';\nimport { utils } from 'ethers';\nimport { Grid } from '@mui/material';\n\nexport default function SupplyComponent({ contract }) {\n  const totalSupply = useCall({ contract, method: 'totalSupply', args: [] });\n  const maxSupply = useCall({ contract, method: 'MAX_TO_MINT', args: [] });\n  const totalSupplyFormatted = totalSupply\n    ? utils.formatEther(totalSupply.value.toString())\n    : '...';\n  const maxSupplyFormatted = maxSupply\n    ? utils.formatEther(maxSupply.value.toString())\n    : '...';\n\n  const centeredText = { textAlign: 'center' };\n\n  return (\n    &lt;Grid item xs={12}&gt;\n      &lt;h3 style={centeredText}&gt;\n        Total Supply: {totalSupplyFormatted} / {maxSupplyFormatted}\n      &lt;/h3&gt;\n    &lt;/Grid&gt;\n  );\n}\n</code></pre> <p>Notice that this component uses the <code>useCall</code> hook provided by the useDApp package. This call takes in the contract object we created earlier, a string method, and any relevant arguments for the read-only call and returns the output. While it required some setup, this one-liner is a lot simpler than the entire <code>use_call</code> RPC call that we would have had to do if we weren't using Ethers.js and useDApp.  </p> <p>Also note that we're using a utility format called <code>formatEther</code> to format the output values instead of displaying them directly. This is because our token, like gas currencies, is stored as an unsigned integer with a fixed decimal point of 18 figures. The utility function helps format this value into a way that we, as humans, expect.  </p> <p>Now we can spice up our frontend and call the read-only functions in the contract. We'll update the frontend so that we have a place to display our supply data:</p> <pre><code>// ... other imports\nimport SupplyComponent from './SupplyComponent';\n\nfunction App() {\n  // ...\n\n  return (\n    {/* Wrapper Components */}\n      {/* Button Component */}\n      &lt;Card sx={styles.card}&gt;\n        &lt;h1 style={styles.alignCenter}&gt;Mint Your Token!&lt;/h1&gt;\n        &lt;SupplyComponent contract={contract} /&gt;\n      &lt;/Card&gt;\n    {/* Wrapper Components */}\n  )\n}\n</code></pre> App.js file <pre><code>import { useEthers } from '@usedapp/core';\nimport { Button, Grid, Card } from '@mui/material';\nimport { Box } from '@mui/system';\nimport { Contract } from 'ethers';\nimport MintableERC20 from './MintableERC20.json'; \nimport SupplyComponent from './SupplyComponent';\n\nconst styles = {\n  box: { minHeight: '100vh', backgroundColor: '#1b3864' },\n  vh100: { minHeight: '100vh' },\n  card: { borderRadius: 4, padding: 4, maxWidth: '550px', width: '100%' },\n  alignCenter: { textAlign: 'center' },\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\nfunction App() {\n  const { activateBrowserWallet, deactivate, account } = useEthers();\n  const contract = new Contract(contractAddress, MintableERC20.abi);\n\n  // Handle the wallet toggle\n  const handleWalletConnection = () =&gt; {\n    if (account) deactivate();\n    else activateBrowserWallet();\n  };\n\n  return (\n    &lt;Box sx={styles.box}&gt;\n      &lt;Grid\n        container\n        direction='column'\n        alignItems='center'\n        justifyContent='center'\n        style={styles.vh100}\n      &gt;\n        &lt;Box position='absolute' top={8} right={16}&gt;\n          &lt;Button variant='contained' onClick={handleWalletConnection}&gt;\n            {account\n              ? `Disconnect ${account.substring(0, 5)}...`\n              : 'Connect Wallet'}\n          &lt;/Button&gt;\n        &lt;/Box&gt;\n        &lt;Card sx={styles.card}&gt;\n          &lt;h1 style={styles.alignCenter}&gt;Mint Your Token!&lt;/h1&gt;\n          &lt;SupplyComponent contract={contract} /&gt;\n        &lt;/Card&gt;\n      &lt;/Grid&gt;\n    &lt;/Box&gt;\n  );\n}\n\nexport default App;\n</code></pre> <p>Our frontend should now display the correct data!  </p> <p></p> <p>Challenge</p> <p>There's additional information that could be helpful to display, such as the amount of tokens that the connected account currently has: <code>balanceOf(address)</code>. Can you add that to the frontend yourself?</p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#sending-transactions","title":"Send Transactions","text":"<p>Now for the most important part of all DApps: the state-changing transactions. This is where money moves, where tokens are minted, and value passes.  </p> <p>If you recall from our smart contract, we want to mint some tokens by calling the <code>purchaseMint</code> function with some native currency. So we're going to need:  </p> <ol> <li>A text input that lets the user specify how much value to enter  </li> <li>A button that lets the user initiate the transaction signature</li> </ol> <p>Let's create a new component called <code>MintingComponent</code> in a new file called <code>MintingComponent.js</code>. First, we'll tackle the text input, which will require us to add the logic to store the number of tokens to mint and a text field element.</p> <pre><code>import { useState } from 'react';\nimport { useContractFunction, useEthers, MoonbaseAlpha } from '@usedapp/core';\nimport { Button, CircularProgress, TextField, Grid } from '@mui/material';\nimport { utils } from 'ethers';\n\nexport default function MintingComponent({ contract }) {\n  const [value, setValue] = useState(0);\n  const textFieldStyle = { marginBottom: '16px' };\n\n  return (\n    &lt;&gt;\n      &lt;Grid item xs={12}&gt;\n        &lt;TextField \n          type='number'\n          onChange={(e) =&gt; setValue(e.target.value)}\n          label='Enter value in DEV'\n          variant='outlined'\n          fullWidth\n          style={textFieldStyle} \n        /&gt;\n      &lt;/Grid&gt;\n      {/* This is where we'll add the button */}\n    &lt;/&gt;\n  );\n}\n</code></pre> <p>Next, we'll need to create the button to send the transaction, which will call the <code>purchaseMint</code> of our contract. Interacting with the contract will be a bit more difficult since you're likely not as familiar with it. We've already done a lot of setup in the previous sections, so it doesn't actually take too much code:  </p> <pre><code>export default function MintingComponent({ contract }) {\n  // ...\n\n  // Mint transaction\n  const { account, chainId, switchNetwork } = useEthers();\n  const { state, send } = useContractFunction(contract, 'purchaseMint');\n  const handlePurchaseMint = async () =&gt; {\n    if (chainId !== MoonbaseAlpha.chainId) {\n      await switchNetwork(MoonbaseAlpha.chainId);\n    }\n    send({ value: utils.parseEther(value.toString()) });\n  };\n  const isMining = state?.status === 'Mining';\n\n  return (\n    &lt;&gt;\n      {/* ... */}\n      &lt;Grid item xs={12}&gt;\n        &lt;Button\n          variant='contained' color='primary' fullWidth\n          onClick={handlePurchaseMint}\n          disabled={state.status === 'Mining' || account == null}\n        &gt;\n          {isMining? &lt;CircularProgress size={24} /&gt; : 'Purchase Mint'}\n        &lt;/Button&gt;\n      &lt;/Grid&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre> MintingComponent.js file <pre><code>import { useState } from 'react';\nimport { useContractFunction, useEthers, MoonbaseAlpha } from '@usedapp/core';\nimport { Button, CircularProgress, TextField, Grid } from '@mui/material';\nimport { utils } from 'ethers';\n\nexport default function MintingComponent({ contract }) {\n  const [value, setValue] = useState(0);\n  const textFieldStyle = { marginBottom: '16px' };\n\n  const { account, chainId, switchNetwork } = useEthers();\n  const { state, send } = useContractFunction(contract, 'purchaseMint');\n  const handlePurchaseMint = async () =&gt; {\n    if (chainId !== MoonbaseAlpha.chainId) {\n      await switchNetwork(MoonbaseAlpha.chainId);\n    }\n    send({ value: utils.parseEther(value.toString()) });\n  };\n  const isMining = state?.status === 'Mining';\n\n  return (\n    &lt;&gt;\n      &lt;Grid item xs={12}&gt;\n        &lt;TextField \n          type='number'\n          onChange={(e) =&gt; setValue(e.target.value)}\n          label='Enter value in DEV'\n          variant='outlined'\n          fullWidth\n          style={textFieldStyle} \n        /&gt;\n      &lt;/Grid&gt;\n      &lt;Grid item xs={12}&gt;\n        &lt;Button\n          variant='contained' color='primary' fullWidth\n          onClick={handlePurchaseMint}\n          disabled={state.status === 'Mining' || account == null}\n        &gt;\n          {isMining? &lt;CircularProgress size={24} /&gt; : 'Purchase Mint'}\n        &lt;/Button&gt;\n      &lt;/Grid&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre> <p>Let's break down the non-JSX code a bit:  </p> <ol> <li>The user's account information is being retrieved via <code>useEthers</code>, which can be done because useDApp provides this information throughout the entire project</li> <li>The <code>useContractFunction</code> hook from useDApp is used to create a function, <code>send</code>, that will sign and send a transaction that calls the <code>purchaseMint</code> function on the contract defined by the <code>contract</code> object</li> <li>Another function, <code>handlePurchaseMint</code>, is defined to help inject the native gas value defined by the <code>TextField</code> component into the <code>send</code> function. It first checks if the user has their wallet connected to Moonbase Alpha, and if not, it prompts the user to switch networks</li> <li>A helper constant will determine whether or not the transaction is still in the <code>Mining</code> phase, that is, it hasn't finished</li> </ol> <p>Now let's look at the visual component. The button will call the <code>handlePurchaseMint</code> on press, which makes sense. The button will also be disabled while the transaction happens and if the user hasn't connected to the DApp with their wallet (when the account value isn't defined).  </p> <p>This code essentially boils down to using the <code>useContractFunction</code> hook in conjunction with the <code>contract</code> object, which is a lot simpler than what it does under the hood! Let's add this component to the main <code>App.js</code> file.  </p> <pre><code>// ... other imports\nimport MintingComponent from './MintingComponent';\n\nfunction App() {\n  // ...\n\n  return (\n    {/* Wrapper Components */}\n      {/* Button Component */}\n      &lt;Card sx={styles.card}&gt;\n        &lt;h1 style={styles.alignCenter}&gt;Mint Your Token!&lt;/h1&gt;\n        &lt;SupplyComponent contract={contract} /&gt;\n        &lt;MintingComponent contract={contract} /&gt;\n      &lt;/Card&gt;\n    {/* Wrapper Components */}\n  )\n}\n</code></pre> App.js file <pre><code>import { useEthers } from '@usedapp/core';\nimport { Button, Grid, Card } from '@mui/material';\nimport { Box } from '@mui/system';\nimport { Contract } from 'ethers';\nimport MintableERC20 from './MintableERC20.json';\nimport SupplyComponent from './SupplyComponent';\nimport MintingComponent from './MintingComponent';\n\nconst styles = {\n  box: { minHeight: '100vh', backgroundColor: '#1b3864' },\n  vh100: { minHeight: '100vh' },\n  card: { borderRadius: 4, padding: 4, maxWidth: '550px', width: '100%' },\n  alignCenter: { textAlign: 'center' },\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\nfunction App() {\n  const { activateBrowserWallet, deactivate, account } = useEthers();\n  const contract = new Contract(contractAddress, MintableERC20.abi);\n\n  // Handle the wallet toggle\n  const handleWalletConnection = () =&gt; {\n    if (account) deactivate();\n    else activateBrowserWallet();\n  };\n\n  return (\n    &lt;Box sx={styles.box}&gt;\n      &lt;Grid\n        container\n        direction='column'\n        alignItems='center'\n        justifyContent='center'\n        style={styles.vh100}\n      &gt;\n        &lt;Box position='absolute' top={8} right={16}&gt;\n          &lt;Button variant='contained' onClick={handleWalletConnection}&gt;\n            {account\n              ? `Disconnect ${account.substring(0, 5)}...`\n              : 'Connect Wallet'}\n          &lt;/Button&gt;\n        &lt;/Box&gt;\n        &lt;Card sx={styles.card}&gt;\n          &lt;h1 style={styles.alignCenter}&gt;Mint Your Token!&lt;/h1&gt;\n          &lt;SupplyComponent contract={contract} /&gt;\n          &lt;MintingComponent contract={contract} /&gt;\n        &lt;/Card&gt;\n      &lt;/Grid&gt;\n    &lt;/Box&gt;\n  );\n}\n\nexport default App;\n</code></pre> <p> </p> <p>If you try entering a value like 0.1 and press the button, a MetaMask prompt should occur. Try it out!  </p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#reading-events-from-contracts","title":"Read Events from Contracts","text":"<p>A common way of listening to what happened in a transaction is through events, also known as logs. These logs are emitted by the smart contract through the <code>emit</code> and <code>event</code> keywords and can be very important in a responsive frontend. Often, DApps will use toast elements to represent events in real-time, but for this DApp, we will use a simple table.  </p> <p>We created an event in our smart contract: <code>event PurchaseOccurred(address minter, uint256 amount)</code>, so let's figure out how to display its information in the frontend.  </p> <p>Let's create a new component <code>PurchaseOccurredEvents</code> within a new file <code>PurchaseOccurredEvents.js</code> that reads the last five logs and displays them in a table:  </p> <pre><code>import { useLogs, useBlockNumber } from '@usedapp/core';\nimport { utils } from 'ethers';\nimport {\n  Grid,\n  Table,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TableHead,\n  TableRow,\n} from '@mui/material';\n\nexport default function PurchaseOccurredEvents({ contract }) {\n  return (\n    &lt;Grid item xs={12} marginTop={5}&gt;\n      &lt;TableContainer &gt;\n        &lt;Table&gt;\n          &lt;TableHead&gt;\n            &lt;TableRow&gt;\n              &lt;TableCell&gt;Minter&lt;/TableCell&gt;\n              &lt;TableCell align='right'&gt;Amount&lt;/TableCell&gt;\n            &lt;/TableRow&gt;\n          &lt;/TableHead&gt;\n          &lt;TableBody&gt;\n            {/* This is where we have to inject data from our logs! */}\n          &lt;/TableBody&gt;\n        &lt;/Table&gt;\n      &lt;/TableContainer&gt;\n    &lt;/Grid&gt;\n  );\n}\n</code></pre> <p>This component so far creates an empty table, so let's use two new hooks to read those logs:  </p> <pre><code>export default function PurchaseOccurredEvents({ contract }) {\n  // Get block number to ensure that the useLogs doesn't search from 0, otherwise it will time out\n  const blockNumber = useBlockNumber();\n\n  // Create a filter &amp; get the logs\n  const filter = { args: [null, null], contract, event: 'PurchaseOccurred' };\n  const logs = useLogs(filter, { fromBlock: blockNumber - 10000 });\n  const parsedLogs = logs?.value.slice(-5).map(log =&gt; log.data);\n\n  // ... \n}\n</code></pre> <p>Here's what happens in this code:  </p> <ol> <li>The block number is received from the <code>useBlockNumber</code> hook, similar to using the JSON-RPC method <code>eth_blockNumber</code></li> <li>A filter is created to filter for all events with any arguments on the contract injected into the component with the event name <code>PurchaseOccurred</code></li> <li>Logs are queried for via the <code>useLogs</code> hook, similar to using the <code>eth_getLogs</code> JSON-RPC method. Note that we're only querying the last 10,000 blocks because otherwise the entire history of the blockchain would be queried and the RPC would timeout</li> <li>The resultant logs are parsed, and the most recent five are selected</li> </ol> <p>If we want to display them, we can do it like so:  </p> <pre><code>export default function PurchaseOccurredEvents({ contract }) {\n  // ...\n  return (\n    &lt;Grid item xs={12} marginTop={5}&gt;\n      &lt;TableContainer &gt;\n        &lt;Table&gt;\n          {/* TableHead Component */}\n          &lt;TableBody&gt;\n            {parsedLogs?.reverse().map((log, index) =&gt; (\n              &lt;TableRow key={index}&gt;\n                &lt;TableCell&gt;{log.minter}&lt;/TableCell&gt;\n                &lt;TableCell align='right'&gt;\n                  {utils.formatEther(log.amount)} tokens\n                &lt;/TableCell&gt;\n              &lt;/TableRow&gt;\n            ))}\n          &lt;/TableBody&gt;\n        &lt;/Table&gt;\n      &lt;/TableContainer&gt;\n    &lt;/Grid&gt;\n  );\n}\n</code></pre> PurchaseOccurredEvents.js file <pre><code>import { useLogs, useBlockNumber } from '@usedapp/core';\nimport { utils } from 'ethers';\nimport {\n  Grid,\n  Table,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TableHead,\n  TableRow,\n} from '@mui/material';\n\nexport default function PurchaseOccurredEvents({ contract }) {\n  // Get block number to ensure that the useLogs doesn't search from 0, otherwise it will time out\n  const blockNumber = useBlockNumber();\n\n  // Create a filter &amp; get the logs\n  const filter = { args: [null, null], contract, event: 'PurchaseOccurred' };\n  const logs = useLogs(filter, { fromBlock: blockNumber - 10000 });\n  const parsedLogs = logs?.value.slice(-5).map((log) =&gt; log.data);\n  return (\n    &lt;Grid item xs={12} marginTop={5}&gt;\n      &lt;TableContainer&gt;\n        &lt;Table&gt;\n          &lt;TableHead&gt;\n            &lt;TableRow&gt;\n              &lt;TableCell&gt;Minter&lt;/TableCell&gt;\n              &lt;TableCell align='right'&gt;Amount&lt;/TableCell&gt;\n            &lt;/TableRow&gt;\n          &lt;/TableHead&gt;\n          &lt;TableBody&gt;\n            {parsedLogs?.reverse().map((log, index) =&gt; (\n              &lt;TableRow key={index}&gt;\n                &lt;TableCell&gt;{log.minter}&lt;/TableCell&gt;\n                &lt;TableCell align='right'&gt;\n                  {utils.formatEther(log.amount)} tokens\n                &lt;/TableCell&gt;\n              &lt;/TableRow&gt;\n            ))}\n          &lt;/TableBody&gt;\n        &lt;/Table&gt;\n      &lt;/TableContainer&gt;\n    &lt;/Grid&gt;\n  );\n}\n</code></pre> <p>This too should be added to <code>App.js</code>.</p> <pre><code>// ... other imports\nimport PurchaseOccurredEvents from './PurchaseOccurredEvents';\n\nfunction App() {\n  // ...\n\n  return (\n    {/* Wrapper Components */}\n      {/* Button Component */}\n      &lt;Card sx={styles.card}&gt;\n        &lt;h1 style={styles.alignCenter}&gt;Mint Your Token!&lt;/h1&gt;\n        &lt;SupplyComponent contract={contract} /&gt;\n        &lt;MintingComponent contract={contract} /&gt;\n        &lt;PurchaseOccurredEvents contract={contract} /&gt;\n      &lt;/Card&gt;\n    {/* Wrapper Components */}\n  )\n}\n</code></pre> App.js file <pre><code>import { useEthers } from '@usedapp/core';\nimport { Button, Grid, Card } from '@mui/material';\nimport { Box } from '@mui/system';\nimport { Contract } from 'ethers';\nimport MintableERC20 from './MintableERC20.json'; \nimport SupplyComponent from './SupplyComponent';\nimport MintingComponent from './MintingComponent';\nimport PurchaseOccurredEvents from './PurchaseOccurredEvents';\n\nconst styles = {\n  box: { minHeight: '100vh', backgroundColor: '#1b3864' },\n  vh100: { minHeight: '100vh' },\n  card: { borderRadius: 4, padding: 4, maxWidth: '550px', width: '100%' },\n  alignCenter: { textAlign: 'center' },\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\nfunction App() {\n  const { activateBrowserWallet, deactivate, account } = useEthers();\n  const contract = new Contract(contractAddress, MintableERC20.abi);\n\n  // Handle the wallet toggle\n  const handleWalletConnection = () =&gt; {\n    if (account) deactivate();\n    else activateBrowserWallet();\n  };\n\n  return (\n    &lt;Box sx={styles.box}&gt;\n      &lt;Grid\n        container\n        direction='column'\n        alignItems='center'\n        justifyContent='center'\n        style={styles.vh100}\n      &gt;\n        &lt;Box position='absolute' top={8} right={16}&gt;\n          &lt;Button variant='contained' onClick={handleWalletConnection}&gt;\n            {account\n              ? `Disconnect ${account.substring(0, 5)}...`\n              : 'Connect Wallet'}\n          &lt;/Button&gt;\n        &lt;/Box&gt;\n        &lt;Card sx={styles.card}&gt;\n          &lt;h1 style={styles.alignCenter}&gt;Mint Your Token!&lt;/h1&gt;\n          &lt;SupplyComponent contract={contract} /&gt;\n          &lt;MintingComponent contract={contract} /&gt;\n          &lt;PurchaseOccurredEvents contract={contract} /&gt;\n        &lt;/Card&gt;\n      &lt;/Grid&gt;\n    &lt;/Box&gt;\n  );\n}\n\nexport default App;\n</code></pre> <p>And, if you've done any transactions, you'll see that they'll pop up!  </p> <p></p> <p>Now you've implemented three main components of DApp frontends: reading from storage, sending transactions, and reading logs. With these building blocks as well as the knowledge you gained with smart contracts and nodes, you should be able to cover 80% of DApps.</p> <p>You can view the complete example DApp on GitHub.</p>"},{"location":"tutorials/eth-api/how-to-build-a-dapp/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we covered a wide range of topics and tools essential for successful DApp development. We started with Hardhat, a powerful development environment that simplifies the process of writing, testing, and deploying smart contracts. Ethers.js, a popular library for interacting with Ethereum nodes, was introduced to manage wallets and transactions.  </p> <p>We delved into the process of writing smart contracts, highlighting best practices and key considerations when developing on-chain logic. The guide then explored useDApp, a React-based framework, for creating a user-friendly frontend. We discussed techniques for reading data from contracts, executing transactions, and working with logs to ensure a seamless user experience.</p> <p>Of course, there are more advanced (but optional) components of DApps that have popped up over time:</p> <ul> <li>Decentralized storage protocols \u2014 systems that store websites and files in a decentralized way</li> <li>Oracles \u2014 third-party services that provide external data to smart contracts within blockchains</li> <li>Indexing protocols \u2014 middleware that processes and organizes blockchain data, allowing it to be efficiently queried</li> </ul> <p>An excellent Web2 to Web3 blogpost is available if you are interested in hearing about them in depth.  </p> <p>Hopefully, by reading this guide, you'll be well on your way to creating novel DApps on Moonbeam!</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/eth-api/randomness-lottery/","title":"Create a Lottery Contract using the Randomness Precompile","text":"<p>by Erin Shaben</p>"},{"location":"tutorials/eth-api/randomness-lottery/#introduction","title":"Introduction","text":"<p>Moonbeam utilizes verifiable random functions (VRF) to generate randomness that can be verified on-chain. A VRF is a cryptographic function that takes some input and produces random values, along with a proof of authenticity that these random values were generated by the submitter. The proof can be verified by anyone to ensure the random values generated were calculated correctly.</p> <p>There are two available sources of randomness that provide random inputs based on block producers' VRF keys and past randomness results: local VRF and BABE epoch randomness. Local VRF is determined directly within Moonbeam using the collator of the block's VRF key and the last block's VRF output. On the other hand, BABE epoch randomness is based on all the VRF produced by the relay chain validators during a complete epoch.</p> <p>For more information on the two sources of randomness, how the request and fulfillment process works, and security considerations, please refer to the Randomness on Moonbeam page.</p> <p>Moonbeam provides a Randomness Precompile, which is a Solidity interface that enables smart contract developers to generate randomness via local VRF or BABE epoch randomness using the Ethereum API. Moonbeam also provides a Randomness Consumer Solidity contract that your contract must inherit from in order to consume fulfilled randomness requests.</p> <p>This guide will show you how to use the Randomness Precompile and Randomness Consumer contract to create a lottery where the winners will randomly be selected.</p>"},{"location":"tutorials/eth-api/randomness-lottery/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For this tutorial, you'll need the following:</p> <ul> <li>Create or have three accounts on Moonbase Alpha to test out the lottery contract</li> <li>All of the accounts will need to be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>An empty Hardhat project that is configured for the Moonbase Alpha TestNet. For step-by-step instructions, please refer to the Creating a Hardhat Project and the Hardhat Configuration File sections of our Hardhat documentation page</li> <li> <p>Install the Hardhat Ethers plugin. This provides a convenient way to use the Ethers.js library to interact with the network from your Hardhat project:</p> <pre><code>npm install @nomicfoundation/hardhat-ethers ethers@6\n</code></pre> </li> </ul> <p>Note</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"tutorials/eth-api/randomness-lottery/#contracts","title":"Contract Setup","text":"<p>The following are the contracts that we'll be working with today to create our lottery:</p> <ul> <li><code>Randomness.sol</code> - the Randomness Precompile, which is a Solidity interface that allows you to request randomness, get information about randomness requests, fulfill requests, and more</li> <li><code>RandomnessConsumer.sol</code> - the Randomness Consumer, which is an abstract Solidity contract that is used to interact with the Randomness Precompile. This contract is responsible for validating the origin of randomness requests, ensuring the Randomness Precompile is always the origin, and fulfilling requests</li> <li><code>Lottery.sol</code> - an example lottery contract that we'll be building in this guide together. It will rely on the Randomness Precompile and Consumer to request random words that will be used to select a winner for our lottery</li> </ul> <p>If you don't already have a <code>contracts</code> directory in your Hardhat project, you can create a new directory:</p> <pre><code>mkdir contracts &amp;&amp; cd contracts\n</code></pre> <p>Then you can create the following three files, one for each of the aforementioned contracts:</p> <pre><code>touch Randomness.sol RandomnessConsumer.sol Lottery.sol\n</code></pre> <p>In the <code>Randomness.sol</code> file, you can paste in the Randomness Precompile contract.</p> Randomness.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Randomness contract's address.\naddress constant RANDOMNESS_ADDRESS = 0x0000000000000000000000000000000000000809;\n\n/// @dev The Randomness contract's instance.\nRandomness constant RANDOMNESS_CONTRACT = Randomness(RANDOMNESS_ADDRESS);\n\n/// @dev Maximum number of random words being requested\nuint32 constant MAX_RANDOM_WORDS = 100;\n/// @dev Minimum number of blocks before a request can be fulfilled for Local VRF Request\nuint32 constant MIN_VRF_BLOCKS_DELAY = 2;\n/// @dev Maximum number of blocks before a request can be fulfilled for Local VRF Request\nuint32 constant MAX_VRF_BLOCKS_DELAY = 2000;\n/// @dev The deposit amount needed to request random words. There is 1 deposit per request\nuint256 constant REQUEST_DEPOSIT_AMOUNT = 1000000000000000000;\n\n/// @author The Moonbeam Team\n/// @title Pallet Randomness Interface\n/// @dev The interface through which solidity contracts will interact with Randomness\n/// @custom:address 0x0000000000000000000000000000000000000809\ninterface Randomness {\n    /// @notice Event emitted when the request has been successfully executed\n    event FulFillmentSucceeded();\n    /// @notice Event emitted when the request has failed to execute fulfillment\n    event FulFillmentFailed();\n\n    /// @notice The status of the request\n    /// @param DoesNotExist The request doesn't exist\n    /// @param Pending The request cannot be fulfilled yet\n    /// @param Ready The request is ready to be fulfilled\n    /// @param Expired The request has expired\n    enum RequestStatus {\n        DoesNotExist,\n        Pending,\n        Ready,\n        Expired\n    }\n\n    /// @notice The type of randomness source\n    /// @param LocalVRF Randomness VRF using the parachain material as seed\n    /// @param RelayBabeEpoch Randomness VRF using relay material from previous epoch\n    enum RandomnessSource {\n        LocalVRF,\n        RelayBabeEpoch\n    }\n\n    /// @notice The request details\n    /// @param id The id of the request (is always &lt; 2**64)\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param contractAddress The address of the contract being called back during fulfillment\n    /// @param fee The amount to set aside to pay for the fulfillment\n    /// @param gasLimit The gas limit to use for the fulfillment\n    /// @param salt A string being mixed with the randomness seed to obtain different random words. This should be as unique as possible; using the same salt will lead to same randomness result.\n    /// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n    /// @param randomnessSource The type of randomness source used to generate the random words\n    /// @param fulfillmentBlock The parachain block number at which the request can be fulfilled (for LocalVRF only)\n    /// @param fulfillmentEpochIndex The relay epoch index at which the request can be fulfilled (for RelayBabeEpoch)\n    /// @param expirationBlock The parachain block number at which the request expires (for LocalVRF only)\n    /// @param expirationEpochIndex The relay epoch index at which the request expires (for RelayBabeEpoch)\n    /// @param status The current status of the request\n    struct Request {\n        uint256 id;\n        address refundAddress;\n        address contractAddress;\n        uint256 fee;\n        uint256 gasLimit;\n        bytes32 salt;\n        uint32 numWords;\n        RandomnessSource randomnessSource;\n        uint32 fulfillmentBlock;\n        uint64 fulfillmentEpochIndex;\n        uint32 expirationBlock;\n        uint64 expirationEpochIndex;\n        RequestStatus status;\n    }\n\n    /// Return the current relay epoch index\n    /// @dev An epoch represents real time and not a block number\n    /// @dev Currently, time between epoch changes cannot be longer than:\n    /// @dev  - Kusama/Westend/Rococo: 600 relay blocks (1 hour)\n    /// @dev  - Polkadot: 2400 relay blocks (4 hours)\n    /// @custom:selector 81797566\n    function relayEpochIndex() external view returns (uint64);\n\n    /// Return the deposit required to perform a request\n    /// @dev Each request will need a deposit.\n    /// @custom:selector fb7cfdd7\n    function requiredDeposit() external view returns (uint256);\n\n    /// @notice Returns the request status\n    /// @param requestId The id of the request to check (must be &lt; 2**64)\n    /// @return status Status of the request\n    /// @custom:selector d8a4676f\n    function getRequestStatus(uint256 requestId)\n        external\n        view\n        returns (RequestStatus status);\n\n    /// @notice Returns the request or revert\n    /// @param requestId The id of the request to check (must be &lt; 2**64)\n    /// @return request The request\n    /// @custom:selector c58343ef\n    function getRequest(uint256 requestId)\n        external\n        view\n        returns (Request memory request);\n\n    /// @notice Request random words generated from the parachain VRF\n    /// @dev This is using pseudo-random VRF executed by the collator at the fulfillment\n    /// @dev Warning:\n    /// @dev The collator in charge of producing the block at fulfillment can decide to skip\n    /// @dev producing the block in order to have a different random word generated by the next\n    /// @dev collator, at the cost of a block reward. It is therefore economically viable to use\n    /// @dev this randomness source only if the financial reward at stake is lower than the block\n    /// @dev reward.\n    /// @dev In order to reduce the risk of a collator being able to predict the random words\n    /// @dev when the request is performed, it is possible to increase the delay to multiple blocks\n    /// @dev The higher the delay is, the less likely the collator will be able to know which\n    /// @dev collator will be in charge of fulfilling the request.\n    /// @dev Fulfillment is manual and can be executed by anyone (for free) after the given delay\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param fee The amount to set aside to pay for the fulfillment\n    /// @param gasLimit The gas limit to use for the fulfillment\n    /// @param salt A string being mixed with the randomness seed to obtain different random words\n    /// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n    /// @param delay The number of blocks until the request can be fulfilled (between MIN_DELAY_BLOCKS and MAX_DELAY_BLOCKS)\n    /// @return requestId The id of the request requestLocalVRFRandomWords\n    /// @custom:selector 9478430c\n    function requestLocalVRFRandomWords(\n        address refundAddress,\n        uint256 fee,\n        uint64 gasLimit,\n        bytes32 salt,\n        uint8 numWords,\n        uint64 delay\n    ) external returns (uint256);\n\n    /// @notice Request random words generated from the relaychain Babe consensus\n    /// @dev The random words are generated from the hash of the all the VRF provided by the\n    /// @dev relaychain validator during 1 epoch.\n    /// @dev It requires a delay of at least 1 epoch after the current epoch to be unpredictable\n    /// @dev at the time the request is performed.\n    /// @dev Warning:\n    /// @dev The validator (on the relaychain) of the last block of an epoch can decide to skip\n    /// @dev producing the block in order to choose the previous generated epoch random number\n    /// @dev at the cost of a relaychain block rewards. It is therefore economically viable to use\n    /// @dev this randomness source only if the financial reward at stake is lower than the relaychain\n    /// @dev block reward.\n    /// @dev (see https://crates.parity.io/pallet_babe/struct.RandomnessFromOneEpochAgo.html)\n    /// @dev Fulfillment is manual and can be executed by anyone (for free) at\n    /// @dev the beginning of the 2nd relay epoch following the current one\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param fee Amount to set aside to pay for the fulfillment. Those fees are taken from the contract\n    /// @param gasLimit Gas limit for the fulfillment\n    /// @param salt Salt to be mixed with raw randomness to get output\n    /// @param numWords Number of random words to be returned (limited to MAX_RANDOM_WORDS)\n    /// @return requestId The id of the request\n    /// @custom:selector 33c14a63\n    function requestRelayBabeEpochRandomWords(\n        address refundAddress,\n        uint256 fee,\n        uint64 gasLimit,\n        bytes32 salt,\n        uint8 numWords\n    ) external returns (uint256);\n\n    /// @dev fulFill the request which will call the contract method \"fulfillRandomWords\"\n    /// @dev Fees of the caller are refunded if the request is fulfillable\n    /// @param requestId Request to be fulfilled (must be &lt; 2**64)\n    /// @custom:selector 9a91eb0d\n    function fulfillRequest(uint256 requestId) external;\n\n    /// @param requestId Request receiving the additional fees (must be &lt; 2**64)\n    /// @param feeIncrease Amount to increase\n    /// @custom:selector d0408a7f\n    function increaseRequestFee(uint256 requestId, uint256 feeIncrease)\n        external;\n\n    /// @param requestId Request to be purged (must be &lt; 2**64)\n    /// @custom:selector 1d26cbab\n    function purgeExpiredRequest(uint256 requestId) external;\n}\n</code></pre> <p>Similarly, in the <code>RandomnessConsumer.sol</code> file, you can paste in the Randomness Consumer contract. </p> RandomnessConsumer.sol <pre><code>// Inspired by: https://raw.githubusercontent.com/smartcontractkit/chainlink/8e8a996fd882c0861bdc9824c1ca27c857c87d03/contracts/src/v0.8/VRFConsumerBaseV2.sol\n// SPDX-License-Identifier: GPL-3.0\npragma solidity &gt;=0.8.3;\n\n/// @dev The Randomness contract's address.\naddress constant RANDOMNESS_ADDRESS = 0x0000000000000000000000000000000000000809;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev The purpose of this contract is to make it easy for contracts to talk to\n * @dev the Randomness Precompile. It ensures 2 things:\n * @dev 1. The fulfillment came from the Randomness Precompile\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from RandomnessConsumer\n *\n * @dev Call one of the randomness request functions:\n * @dev 1. requestLocalVRFRandomWords(refundAddress, fee, gasLimit, salt\n * @dev numWords, delay),\n * @dev 2. requestRelayBabeEpochRandomWords(refundAddress, fee, gasLimit, salt\n * @dev numWords),\n * @dev see (Randomness.sol for a description of each function and their arguments).\n *\n * @dev Once the request has been registered and the minimum delay is passed, the\n * @dev request then can be executed (for 0 fee) by anyone. it will call your\n * @dev contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the RandomnessConsumer.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, the collators have some influence over the order in which\n * @dev VRF responses appear on the blockchain, so if your contract could have\n * @dev multiple VRF requests in flight simultaneously, you must ensure that\n * @dev the order in which the VRF responses arrive cannot be used to manipulate\n * @dev your contract's user-significant behavior.\n *\n * @dev Since the output of the random words generated for\n * @dev *requestLocalVRFRandomWords* is dependant of the collator producing the\n * @dev block at fulfillment, the collator could skip its block forcing the\n * @dev fulfillment to be executed by a different collator, and therefore\n * @dev generating a different VRF.\n * @dev However, such an attack would incur the cost of losing the block reward to\n * @dev the collator.\n * @dev It is also possible for a collator to be able to predict some of the\n * @dev possible outcome of the VRF if the delay between the request and the\n * @dev fulfillment is too short. It is for this reason that we allow to provide\n * @dev a higher delay\n *\n * @dev Since the output of the random words generated for\n * @dev *requestRelayBabeEpochRandomWords* is dependant of the relaychain\n * @dev validator producing the blocks during an epoch, it is possible for\n * @dev the last validator of an epoch to choose between 2 possible VRF\n * @dev outputs by skipping the production of a block.\n * @dev However, such an attack would incur the cost of losing the block reward to\n * @dev the validator\n * @dev It is not possible for a parachain collator to predict nor influence\n * @dev the output of the relaychain VRF, not to censor the fulfillment as long as\n * @dev there is one honest collator.\n */\nabstract contract RandomnessConsumer {\n    error OnlyRandomnessPrecompileCanFulfill(address have, address want);\n\n    /**\n     * @notice fulfillRandomness handles the VRF response. Your contract must\n     * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n     * @notice principles to keep in mind when implementing your fulfillRandomness\n     * @notice method.\n     *\n     * @dev RandomnessConsumer expects its subcontracts to have a method with this\n     * @dev signature, and will call it once it has verified the proof\n     * @dev associated with the randomness. (It is triggered via a call to\n     * @dev rawFulfillRandomness, below.)\n     *\n     * @param requestId The Id initially returned by requestLocalVRFRandomWords or requestRelayBabeEpochRandomWords\n     * @param randomWords The VRF output expanded to the requested number of words\n     */\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords)\n        internal\n        virtual;\n\n    // rawFulfillRandomness is called by Randomness Precompile when the executeFulfillement\n    // is called. rawFulfillRandomness then calls fulfillRandomness, after validating\n    // the origin of the call\n    function rawFulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) external {\n        if (msg.sender != RANDOMNESS_ADDRESS) {\n            revert OnlyRandomnessPrecompileCanFulfill(\n                msg.sender,\n                RANDOMNESS_ADDRESS\n            );\n        }\n        fulfillRandomWords(requestId, randomWords);\n    }\n}\n</code></pre> <p>We'll start adding the functionality to the <code>Lottery.sol</code> contract in the following section.</p>"},{"location":"tutorials/eth-api/randomness-lottery/#write-the-lottery-contract","title":"Create the Lottery Smart Contract","text":"<p>At a high level, the lottery contract we're creating will define the rules of the lottery, enable participation, and use randomly generated words to select winners fairly. We'll be requesting the random words via the Randomness Precompile. Then we'll use the Randomness Consumer interface to consume the results of the fulfilled request so that our contract can use the randomly generated words to select the winners and pay them out. We'll break down each step of the process as we build the lottery contract, but for now, you can review the following diagram for an overview of the process.</p> <p></p> <p>This contract is for educational purposes only and is not meant for production use.</p> <p>To get started, let's set up our lottery contract. We'll need to:</p> <ul> <li>Import the <code>Randomness.sol</code> precompile and <code>RandomnessConsumer.sol</code> interface</li> <li>Inherit the Randomness Consumer interface</li> <li>Create a variable for the Randomness Precompile so we can easily access its functions later on</li> </ul> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.0;\n\nimport \"./Randomness.sol\";\nimport {RandomnessConsumer} from \"./RandomnessConsumer.sol\";\n\ncontract Lottery is RandomnessConsumer {\n    // Randomness Precompile interface\n    Randomness public randomness =\n        Randomness(0x0000000000000000000000000000000000000809);\n}\n</code></pre>"},{"location":"tutorials/eth-api/randomness-lottery/#define-parameters","title":"Define Parameters for the Lottery and Randomness Request","text":"<p>Next we're going to need to define the rules of our lottery, such as:</p> <ul> <li>The participation fee</li> <li>The minimum and maximum number of participants</li> <li>The minimum length of the lottery</li> <li>The number of winners</li> </ul> <p>Inside of the <code>Lottery</code> contract, you can add these parameters:</p> <pre><code>// The number of winners. This number corresponds to how many random words\n// will be requested. Cannot exceed MAX_RANDOM_WORDS (from the Randomness\n// Precompile)\nuint8 public NUM_WINNERS = 2;\n\n// The number of blocks before the request can be fulfilled (for Local VRF\n// randomness). The MIN_VRF_BLOCKS_DELAY (from the Randomness Precompile) \n// provides a minimum number that is safe enough for games with low economical\n// value at stake. Increasing the delay slightly reduces the probability \n// (already very low) of a collator being able to predict the pseudo-random number\nuint32 public VRF_BLOCKS_DELAY = MIN_VRF_BLOCKS_DELAY;\n\n// The minimum number of participants to start the lottery\nuint256 public MIN_PARTICIPANTS = 3;\n\n// The maximum number of participants allowed to participate. It is important \n// to limit the total jackpot (by limiting the number of participants) to\n// guarantee the economic incentive of a collator to avoid trying to influence\n// the pseudo-random. (See Randomness.sol for more details)\nuint256 public MAX_PARTICIPANTS = 20;\n\n// The fee needed to participate in the lottery. Will go into the jackpot\nuint256 public PARTICIPATION_FEE = 100000 gwei;\n</code></pre> <p>We will also need to define some parameters specifically related to requesting randomness:</p> <ul> <li>The gas limit for the transaction that fulfills a randomness request</li> <li>The minimum fee needed to start the lottery and request the random words. Each request for randomness requires a fulfillment fee. The purpose of this fee is to pay for the fulfillment of a randomness request, which allows anyone to fulfill a request since the request will already have been paid for. When submitting a randomness request, a refund account can be specified, where any excess fees will be returned to. Our contract will be set up so that the owner of the lottery contract will receive the refund</li> <li>A salt prefix and the global request count, both of which will be used to generate unique randomness requests</li> </ul> <p>You can go ahead and add these parameters:</p> <pre><code>// The gas limit allowed to be used for the fulfillment, which depends on the\n// code that is executed and the number of words requested. Test and adjust\n// this limit based on the size of the request and the processing of the \n// callback request in the fulfillRandomWords() function\nuint64 public FULFILLMENT_GAS_LIMIT = 100000;\n\n// The minimum fee needed to start the lottery. This does not guarantee that \n// there will be enough fee to pay for the gas used by the fulfillment. \n// Ideally it should be over-estimated considering possible fluctuation of \n// the gas price. Additional fee will be refunded to the caller\nuint256 public MIN_FEE = FULFILLMENT_GAS_LIMIT * 150 gwei;\n\n// A string used to allow having different salt than other contracts\nbytes32 public SALT_PREFIX = \"my_demo_salt_change_me\";\n\n// Stores the global number of requests submitted. This number is used as a\n// salt to make each request unique\nuint256 public globalRequestCount;\n</code></pre> <p>Aside from these parameters, we'll need to create some variables which will be used to keep track of the current lottery:</p> <ul> <li>The current request ID</li> <li>The list of current participants</li> <li>The jackpot</li> <li>The owner of the lottery contract. This is necessary because only the owner of the contract will be allowed to start the lottery</li> <li>The source of randomness (local VRF or BABE epoch) that is being used</li> </ul> <pre><code>// The current request id\nuint256 public requestId;\n\n// The list of current participants\naddress[] public participants;\n\n// The current amount of token at stake in the lottery\nuint256 public jackpot;\n\n// the owner of the contract\naddress owner;\n\n// Which randomness source to use. This correlates to the values in the\n// RandomnessSource enum in the Randomness Precompile\nRandomness.RandomnessSource randomnessSource;\n</code></pre>"},{"location":"tutorials/eth-api/randomness-lottery/#create-constructor","title":"Create the Constructor","text":"<p>Now that we have completed the initial set up of all of the variables required for the lottery, we can start to code the functions that will bring the lottery to life. First, we'll start off by creating a constructor function.</p> <p>The constructor will accept a uint8 as the randomness source, which corresponds to the index of the type of randomness defined in the <code>RandomnessSource</code> enum, located in the Randomness Precompile. So, we can either pass in <code>0</code> for local VRF or <code>1</code> for BABE epoch randomness. It will also be <code>payable</code>, as we'll submit the deposit at the time of deployment and will be used to perform the randomness request later on.</p> <p>The deposit is defined in the Randomness Precompile and is required in addition to the fulfillment fee. The deposit will be refunded to the original requester, which in our case is the owner of the contract, after the request has been fulfilled. If a request never gets fulfilled, it will expire and need to be purged. Once it is purged, the deposit will be returned.</p> <pre><code>constructor(\n    Randomness.RandomnessSource source\n) payable RandomnessConsumer() {\n    // Because this contract can only perform one randomness request at a time,\n    // we only need to have one required deposit\n    uint256 requiredDeposit = randomness.requiredDeposit();\n    if (msg.value &lt; requiredDeposit) {\n        revert(\"Deposit too Low\");\n    }\n    // Update parameters\n    randomnessSource = source;\n    owner = msg.sender;\n    globalRequestCount = 0;\n    jackpot = 0;\n    // Set the requestId to the maximum allowed value by the precompile (64 bits)\n    requestId = 2 ** 64 - 1;\n}\n</code></pre>"},{"location":"tutorials/eth-api/randomness-lottery/#participate-logic","title":"Add Logic to Participate in the Lottery","text":"<p>Next we can create the function that will allow users to participate in the lottery. The <code>participate</code> function will be <code>payable</code> as each participant will need to submit a participation fee.</p> <p>The <code>participate</code> function will include the following logic:</p> <ul> <li>Check that the lottery hasn't started yet using the <code>getRequestStatus</code> function of the Randomness Precompile. This function returns the status as defined by the <code>RequestStatus</code> enum. If the status is anything other than <code>DoesNotExist</code>, then the lottery has already been started</li> <li>Check that the participation fee meets the requirement</li> <li>If both of the above are true, then the participant will be added to the list of participants and their participation fee will be added to the jackpot</li> </ul> <pre><code>function participate() external payable {\n    // We check that the lottery hasn't started yet\n    if (\n        randomness.getRequestStatus(requestId) !=\n        Randomness.RequestStatus.DoesNotExist\n    ) {\n        revert(\"Request already initiated\");\n    }\n\n    // Each player must submit a fee to participate, which is added to\n    // the jackpot\n    if (msg.value != PARTICIPATION_FEE) {\n        revert(\"Invalid participation fee\");\n    }\n    participants.push(msg.sender);\n    jackpot += msg.value;\n}\n</code></pre> <p>Challenge</p> <p>In the above function, we check that the lottery hasn't started yet, but what if we want to know the exact status of the lottery? Create a function that solves this problem and returns the status of the lottery.</p>"},{"location":"tutorials/eth-api/randomness-lottery/#start-lottery-logic","title":"Add Logic to Start the Lottery and Request Randomness","text":"<p>The logic for starting the lottery contains a crucial component: requesting randomness. As previously mentioned, only the owner of the lottery contract will be able to start the lottery. As such, the owner will need to submit the fulfillment fee for the request.</p> <p>The <code>startLottery</code> function will include the following logic:</p> <ul> <li>Check that the lottery hasn't started yet, as we did in the <code>participate</code> function</li> <li>Check that there is an acceptable number of participants</li> <li>Check that the fulfillment fee meets the minimum requirements</li> <li>Check that the balance of the contract is enough to pay for the deposit. Remember how the constructor accepts the request deposit? That deposit is stored in the contract until this function is called</li> <li>If all of the above are true, we submit the randomness request via the Randomness Precompile along with the fulfillment fee. Depending on the source of randomness, either the <code>requestLocalVRFRandomWords</code> or the <code>requestRelayBabeEpochRandomWords</code> function of the Randomness Precompile will be called along with the following parameters:<ul> <li>The address where excess fees will be refunded to</li> <li>The fulfillment fee</li> <li>The gas limit to use for the fulfillment</li> <li>The salt, which is a string that is mixed with the randomness seed to obtain different random words. The <code>globalRequestCount</code> is used to ensure uniqueness</li> <li>The number of random words requested, which is based off the number of winners that will be selected</li> <li>(For local VRF only) The delay, which is the number of blocks that must pass before the request can be fulfilled</li> </ul> </li> </ul> <p>Since the lottery function should only be called by the owner, we'll also add in an <code>onlyOwner</code> modifier that requires the <code>msg.sender</code> to be the <code>owner</code>.</p> <pre><code>function startLottery() external payable onlyOwner {\n    // Check we haven't started the randomness request yet\n    if (\n        randomness.getRequestStatus(requestId) !=\n        Randomness.RequestStatus.DoesNotExist\n    ) {\n        revert(\"Request already initiated\");\n    }\n    // Check that the number of participants is acceptable\n    if (participants.length &lt; MIN_PARTICIPANTS) {\n        revert(\"Not enough participants\");\n    }\n    if (participants.length &gt;= MAX_PARTICIPANTS) {\n        revert(\"Too many participants\");\n    }\n    // Check the fulfillment fee is enough\n    uint256 fee = msg.value;\n    if (fee &lt; MIN_FEE) {\n        revert(\"Not enough fee\");\n    }\n    // Check there is enough balance on the contract to pay for the deposit.\n    // This would fail only if the deposit amount required is changed in the\n    // Randomness Precompile.\n    uint256 requiredDeposit = randomness.requiredDeposit();\n    if (address(this).balance &lt; jackpot + requiredDeposit) {\n        revert(\"Deposit too low\");\n    }\n\n    if (randomnessSource == Randomness.RandomnessSource.LocalVRF) {\n        // Request random words using local VRF randomness\n        requestId = randomness.requestLocalVRFRandomWords(\n            msg.sender,\n            fee,\n            FULFILLMENT_GAS_LIMIT,\n            SALT_PREFIX ^ bytes32(globalRequestCount++),\n            NUM_WINNERS,\n            VRF_BLOCKS_DELAY\n        );\n    } else {\n        // Requesting random words using BABE Epoch randomness\n        requestId = randomness.requestRelayBabeEpochRandomWords(\n            msg.sender,\n            fee,\n            FULFILLMENT_GAS_LIMIT,\n            SALT_PREFIX ^ bytes32(globalRequestCount++),\n            NUM_WINNERS\n        );\n    }\n}\n\nmodifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n}\n</code></pre>"},{"location":"tutorials/eth-api/randomness-lottery/#fulfill-randomness-logic","title":"Add Logic to Fulfill the Randomness Request","text":"<p>In this section, we'll be adding in two functions required to request fulfillment and handle the result of the fulfillment: <code>fulfillRequest</code> and <code>fulfillRandomWords</code>.</p> <p>Our <code>fulfillRequest</code> function will call the <code>fulfillRequest</code> method of the Randomness Precompile. When this method is called, under the hood the <code>rawFulfillRandomWords</code> method of the Randomness Consumer is called, which will verify that the call originated from the Randomness Precompile. From there, the <code>fulfillRandomWords</code> function of the Randomness Consumer contract is called and the requested number of random words are computed using the block's randomness result and a given salt, and then it is returned. If the fulfillment was successful, the <code>FulfillmentSucceeded</code> event will be emitted; otherwise, the <code>FulfillmentFailed</code> event will be emitted.</p> <p>For fulfilled requests, the cost of execution will be refunded from the request fee to the caller of <code>fulfillRequest</code>. Then any excess fees and the request deposit are transferred to the specified refund address.</p> <p>Our <code>fulfillRandomWords</code> function defines a callback, the <code>pickWinners</code> function, that is responsible for handling the fulfillment. So, in our case, the callback will use the random words to select a winner and payout the winnings. The signature of our <code>fulfillRandomWords</code> function must match the signature of the Randomness Consumer's <code>fulfillRandomWords</code> function.</p> <pre><code>function fulfillRequest() public {\n    randomness.fulfillRequest(requestId);\n}\n\nfunction fulfillRandomWords(\n    uint256 /* requestId */,\n    uint256[] memory randomWords\n) internal override {\n    pickWinners(randomWords);\n}\n</code></pre> <p>We'll create the logic for the <code>pickWinners</code> function in the next section.</p> <p>Challenge</p> <p>What if gas prices change significantly before we request the fulfillment, and as a result this function fails? Currently, we wouldn't be able to increase the fulfillment fee. Create a function that solves this problem and allows us to increase the fulfillment fee.</p>"},{"location":"tutorials/eth-api/randomness-lottery/#pick-winners-logic","title":"Add Logic to Pick the Lottery Winners","text":"<p>The last step for our lottery contract will be to create the <code>pickWinners</code> function, which, as previously mentioned, is responsible for using the random words to select a winner of the lottery.</p> <p>The <code>pickWinners</code> function contains the following logic:</p> <ul> <li>Determine the number of winners. This is only necessary if you happened to change either the <code>NUM_WINNERS</code> or the number of <code>MIN_PARTICIPANTS</code>, so that the <code>NUM_WINNERS</code> is greater than the <code>MIN_PARTICIPANTS</code></li> <li>Calculate the amount to be awarded to the winners based on the amount in the jackpot and the total number of winners</li> <li>Determine the winners by using the random words</li> <li>Distribute the winnings to each of the winners, making sure to deduct the winnings from the jackpot before transferring them</li> </ul> <pre><code>// This function is called only by the fulfillment callback\nfunction pickWinners(uint256[] memory randomWords) internal {\n    // Get the total number of winners to select\n    uint256 totalWinners = NUM_WINNERS &lt; participants.length\n        ? NUM_WINNERS\n        : participants.length;\n\n    // The amount distributed to each winner\n    uint256 amountAwarded = jackpot / totalWinners;\n    for (uint32 i = 0; i &lt; totalWinners; i++) {\n        // This is safe to index randomWords with i because we requested\n        // NUM_WINNERS random words\n        uint256 randomWord = randomWords[i];\n\n        // Using modulo is not totally fair, but fair enough for this demo\n        uint256 index = randomWord % participants.length;\n        address payable winner = payable(participants[index]);\n        delete participants[index];\n        jackpot -= amountAwarded;\n        winner.transfer(amountAwarded);\n    }\n}\n</code></pre> <p>Congratulations! You've gone through the entire process of creating the <code>Lottery.sol</code> contract! You can view the completed version below. Remember, this contract is for educational purposes only and is not meant for production use.</p> Lottery.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.0;\n\nimport \"./Randomness.sol\";\nimport {RandomnessConsumer} from \"./RandomnessConsumer.sol\";\n\ncontract Lottery is RandomnessConsumer {\n    // Randomness Precompile interface\n    Randomness public randomness =\n        Randomness(0x0000000000000000000000000000000000000809);\n\n    // The number of winners. This number corresponds to how many random words\n    // will be requested. Cannot exceed MAX_RANDOM_WORDS (from the Randomness\n    // Precompile)\n    uint8 public NUM_WINNERS = 2;\n\n    // The number of blocks before the request can be fulfilled (for Local VRF\n    // randomness). The MIN_VRF_BLOCKS_DELAY (from the Randomness Precompile)\n    // provides a minimum number that is safe enough for games with low economical\n    // value at stake. Increasing the delay slightly reduces the probability\n    // (already very low) of a collator being able to predict the pseudo-random number\n    uint32 public VRF_BLOCKS_DELAY = MIN_VRF_BLOCKS_DELAY;\n\n    // The minimum number of participants to start the lottery\n    uint256 public MIN_PARTICIPANTS = 3;\n\n    // The maximum number of participants allowed to participate. It is important\n    // to limit the total jackpot (by limiting the number of participants) to\n    // guarantee the economic incentive of a collator to avoid trying to influence\n    // the pseudo-random. (See Randomness.sol for more details)\n    uint256 public MAX_PARTICIPANTS = 20;\n\n    // The fee needed to participate in the lottery. Will go into the jackpot\n    uint256 public PARTICIPATION_FEE = 100000 gwei;\n\n    // The gas limit allowed to be used for the fulfillment, which depends on the\n    // code that is executed and the number of words requested. Test and adjust\n    // this limit based on the size of the request and the processing of the\n    // callback request in the fulfillRandomWords() function\n    uint64 public FULFILLMENT_GAS_LIMIT = 100000;\n\n    // The minimum fee needed to start the lottery. This does not guarantee that\n    // there will be enough fee to pay for the gas used by the fulfillment.\n    // Ideally it should be over-estimated considering possible fluctuation of\n    // the gas price. Additional fee will be refunded to the caller\n    uint256 public MIN_FEE = FULFILLMENT_GAS_LIMIT * 150 gwei;\n\n    // A string used to allow having different salt than other contracts\n    bytes32 public SALT_PREFIX = \"INSERT_ANY_STRING_FOR_SALT\";\n\n    // Stores the global number of requests submitted. This number is used as a\n    // salt to make each request unique\n    uint256 public globalRequestCount;\n\n    // The current request id\n    uint256 public requestId;\n\n    // The list of current participants\n    address[] public participants;\n\n    // The current amount of token at stake in the lottery\n    uint256 public jackpot;\n\n    // the owner of the contract\n    address owner;\n\n    // Which randomness source to use. This correlates to the values in the\n    // RandomnessSource enum in the Randomness Precompile\n    Randomness.RandomnessSource randomnessSource;\n\n    constructor(\n        Randomness.RandomnessSource source\n    ) payable RandomnessConsumer() {\n        // Because this contract can only perform one randomness request at a time,\n        // we only need to have one required deposit\n        uint256 requiredDeposit = randomness.requiredDeposit();\n        if (msg.value &lt; requiredDeposit) {\n            revert(\"Deposit too Low\");\n        }\n        // Update parameters\n        randomnessSource = source;\n        owner = msg.sender;\n        globalRequestCount = 0;\n        jackpot = 0;\n        // Set the requestId to the maximum allowed value by the precompile (64 bits)\n        requestId = 2 ** 64 - 1;\n    }\n\n    function participate() external payable {\n        // We check that the lottery hasn't started yet\n        if (\n            randomness.getRequestStatus(requestId) !=\n            Randomness.RequestStatus.DoesNotExist\n        ) {\n            revert(\"Request already initiated\");\n        }\n\n        // Each player must submit a fee to participate, which is added to\n        // the jackpot\n        if (msg.value != PARTICIPATION_FEE) {\n            revert(\"Invalid participation fee\");\n        }\n        participants.push(msg.sender);\n        jackpot += msg.value;\n    }\n\n    function startLottery() external payable onlyOwner {\n        // Check we haven't started the randomness request yet\n        if (\n            randomness.getRequestStatus(requestId) !=\n            Randomness.RequestStatus.DoesNotExist\n        ) {\n            revert(\"Request already initiated\");\n        }\n        // Check that the number of participants is acceptable\n        if (participants.length &lt; MIN_PARTICIPANTS) {\n            revert(\"Not enough participants\");\n        }\n        if (participants.length &gt;= MAX_PARTICIPANTS) {\n            revert(\"Too many participants\");\n        }\n        // Check the fulfillment fee is enough\n        uint256 fee = msg.value;\n        if (fee &lt; MIN_FEE) {\n            revert(\"Not enough fee\");\n        }\n        // Check there is enough balance on the contract to pay for the deposit.\n        // This would fail only if the deposit amount required is changed in the\n        // Randomness Precompile.\n        uint256 requiredDeposit = randomness.requiredDeposit();\n        if (address(this).balance &lt; jackpot + requiredDeposit) {\n            revert(\"Deposit too low\");\n        }\n\n        if (randomnessSource == Randomness.RandomnessSource.LocalVRF) {\n            // Request random words using local VRF randomness\n            requestId = randomness.requestLocalVRFRandomWords(\n                msg.sender,\n                fee,\n                FULFILLMENT_GAS_LIMIT,\n                SALT_PREFIX ^ bytes32(globalRequestCount++),\n                NUM_WINNERS,\n                VRF_BLOCKS_DELAY\n            );\n        } else {\n            // Requesting random words using BABE Epoch randomness\n            requestId = randomness.requestRelayBabeEpochRandomWords(\n                msg.sender,\n                fee,\n                FULFILLMENT_GAS_LIMIT,\n                SALT_PREFIX ^ bytes32(globalRequestCount++),\n                NUM_WINNERS\n            );\n        }\n    }\n\n    function fulfillRequest() public {\n        randomness.fulfillRequest(requestId);\n    }\n\n    function fulfillRandomWords(\n        uint256 /* requestId */,\n        uint256[] memory randomWords\n    ) internal override {\n        pickWinners(randomWords);\n    }\n\n    // This function is called only by the fulfillment callback\n    function pickWinners(uint256[] memory randomWords) internal {\n        // Get the total number of winners to select\n        uint256 totalWinners = NUM_WINNERS &lt; participants.length\n            ? NUM_WINNERS\n            : participants.length;\n\n        // The amount distributed to each winner\n        uint256 amountAwarded = jackpot / totalWinners;\n        for (uint32 i = 0; i &lt; totalWinners; i++) {\n            // This is safe to index randomWords with i because we requested\n            // NUM_WINNERS random words\n            uint256 randomWord = randomWords[i];\n\n            // Using modulo is not totally fair, but fair enough for this demo\n            uint256 index = randomWord % participants.length;\n            address payable winner = payable(participants[index]);\n            delete participants[index];\n            jackpot -= amountAwarded;\n            winner.transfer(amountAwarded);\n        }\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n}\n</code></pre> <p>Challenge</p> <p>To make the contract easier to work with, add some events for when a lottery has started, a winner has been chosen, and a winner has been awarded.</p>"},{"location":"tutorials/eth-api/randomness-lottery/#interact-with-lottery-contract","title":"Interact with the Lottery Contract","text":"<p>Now that we've gone through and created our lottery contract, let's deploy it and start a lottery!</p>"},{"location":"tutorials/eth-api/randomness-lottery/#compile-deploy-lottery-contract","title":"Compile &amp; Deploy the Lottery Contract","text":"<p>To compile our contracts, you can simply run:</p> <pre><code>npx hardhat compile\n</code></pre> npx hardhat compile Compiled 3 Solidity files successfully <p>After compilation, an <code>artifacts</code> directory is created: it holds the bytecode and metadata of the contracts, which are <code>.json</code> files. It\u2019s a good idea to add this directory to your <code>.gitignore</code>.</p> <p>Before we can deploy the <code>Lottery.sol</code> contract, we'll need to create a deployment script.</p> <p>You can create a new directory for the script and name it <code>scripts</code> and add a new file to it called <code>deploy.js</code>:</p> <pre><code>mkdir scripts &amp;&amp; \ntouch scripts/deploy.js\n</code></pre> <p>Now to write the deployment script we can use <code>ethers</code>. Because we'll be running it with Hardhat, we don't need to import any libraries. We can simply take the following steps:</p> <ol> <li>Create a local instance of the lottery contract with the <code>getContractFactory</code> method</li> <li>Get the deposit required for a randomness request using the <code>requiredDeposit</code> function of the Randomness Precompile</li> <li>Use the <code>deploy</code> method that exists within this instance to instantiate the smart contract. You can pass in <code>0</code> to use local VRF randomness or <code>1</code> for BABE epoch randomness. For this example, we'll use local VRF randomness. We'll also need to submit the deposit upon deployment</li> <li>Wait for the deployment by using <code>waitForDeployment</code></li> <li>Once deployed, we can fetch the address of the contract using the contract instance</li> </ol> <pre><code>async function main() {\n  // 1. Get the contract to deploy\n  const Lottery = await ethers.getContractFactory('Lottery');\n\n  // 2. Get the required deposit amount from the Randomness Precompile\n  const Randomness = await ethers.getContractAt(\n    'Randomness',\n    '0x0000000000000000000000000000000000000809'\n  );\n  const deposit = await Randomness.requiredDeposit();\n\n  // 3. Instantiate a new Lottery smart contract that uses local VRF\n  // randomness and pass in the required deposit\n  const lottery = await Lottery.deploy(0, { value: deposit });\n  console.log('Deploying Lottery...');\n\n  // 4. Waiting for the deployment to resolve\n  await lottery.waitForDeployment();\n\n  // 5. Use the contract instance to get the contract address\n  console.log('Lottery deployed to:', lottery.target);\n}\n\nmain()\n  .then(() =&gt; process.exit(0))\n  .catch((error) =&gt; {\n    console.error(error);\n    process.exit(1);\n  });\n</code></pre> <p>To deploy our lottery contract, we'll use the <code>run</code> command and specify <code>moonbase</code> as the network:</p> <pre><code>npx hardhat run --network moonbase scripts/deploy.js\n</code></pre> <p>If you're using another Moonbeam network, make sure that you specify the correct network. The network name needs to match how it's defined in the <code>hardhat.config.js</code>.</p> <p>After a few seconds, the contract is deployed, and you should see the address in the terminal. Save the address, as we will use it to interact with this contract instance in the next step.</p> npx hardhat run --network moonbase scripts/deploy.js Deploying Lottery... Lottery deployed to: 0xc20F6c3dd46fBf83fe484AD80E3EffDb26108A12"},{"location":"tutorials/eth-api/randomness-lottery/#participate-in-lottery","title":"Create Scripts to Interact with the Lottery Contract","text":"<p>We can continue to work with our Hardhat project and create additional scripts to interact with our lottery contract and call some of it's functions. For example, to participate in the lottery, we can create another script in our <code>scripts</code> directory:</p> <pre><code>touch participate.js\n</code></pre> <p>Then we can add the following code, which will create an instance of the lottery contract using the name of the contract and the contract address. Then we can obtain the participation fee directly from the contract and call the contract's <code>participate</code> function:</p> <pre><code>async function participate() {\n  const lottery = await ethers.getContractAt(\n    'Lottery',\n    'INSERT_CONTRACT_ADDRESS'\n  );\n\n  const participationFee = await lottery.PARTICIPATION_FEE();\n  const tx = await lottery.participate({ value: participationFee });\n  console.log('Participation transaction hash:', tx.hash);\n}\n\nparticipate()\n  .then(() =&gt; process.exit(0))\n  .catch((error) =&gt; {\n    console.error(error);\n    process.exit(1);\n  });\n</code></pre> <p>To run this script, you can use the following command:</p> <pre><code>npx hardhat run --network moonbase scripts/participate.js\n</code></pre> <p>The transaction hash will be printed to the console. You can use the hash to look up the transaction on Moonscan.</p> npx hardhat run --network moonbase scripts/participate.js Participation transaction hash: 0xc16cb530ea6a29eb50a0f05b2328b53fc271cc342391af2c10f3da329c587326 <p>And that's it! You can feel free to continue creating additional scripts to perform the next steps of the lottery, such as starting the lottery and picking the winners.</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/eth-api/thirdweb/","title":"How to Build an NFT Marketplace DApp with thirdweb","text":"<p>by Kevin Neilson</p> <p>thirdweb is a powerful development platform that simplifies building and deploying Web3 applications on the blockchain. It provides pre-built smart contracts and tools, enabling developers to quickly launch applications that interact with NFTs, tokens, and more with less coding and configuration effort.  </p> <p>In this guide, we'll go step by step through the process of building an NFT marketplace DApp with thirdweb on Moonbeam. We'll deploy all of the associated contracts, including an ERC-721 NFT contract and a marketplace smart contract to Moonbase Alpha with thirdweb, and then we'll integrate them into the DApp.</p> <p>For a more nuts and bolts approach to thirdweb with information about available methods, the thirdweb CLI and deployment tools, be sure to check out the thirdweb guide in the Builders section. </p>"},{"location":"tutorials/eth-api/thirdweb/#clone-the-template","title":"Clone the Template","text":"<p>thirdweb has an NFT marketplace template that is a perfect starting point for our needs. We'll only need to make minor customizations to it. Please note, thirdweb frequently updates their templates and tutorials, so ensure that you're using the latest and greatest, which may be located in another repository.</p> <ol> <li> <p>In your CLI run the following command:</p> <pre><code>git clone https://github.com/thirdweb-example/marketplace-template\n</code></pre> </li> <li> <p>Navigate to your project directory and install dependencies with your preferred package manager:</p> npmyarnpnpm <pre><code>npm install\n</code></pre> <pre><code>yarn\n</code></pre> <pre><code>pnpm install\n</code></pre> </li> </ol> <p>Next, you'll need to create a client ID for your thirdweb project and specify it in a <code>.env</code> file. </p>"},{"location":"tutorials/eth-api/thirdweb/#specify-client-id","title":"Specify Client ID","text":"<p>Before you launch your dApp (locally or publicly deployed), you must have a thirdweb Client ID associated with your project. A thirdweb Client ID is synonymous with an API key. You can create a free API key by signing into your thirdweb account and navigating to Settings then click on API Keys.</p> <p>Press Create API Key then take the following steps:</p> <ol> <li>Give your API key a name</li> <li>Enter the allowed domains that the API key should accept requests from. It's recommended that you allow only necessary domains, but for development purposes, you can select Allow all domains</li> <li>Press Next and confirm the prompt on the next page</li> </ol> <p></p> <p>Now, create a file a called <code>.env.local</code> at the root level directory of your project. Add your Client ID as follows:</p> .env.local<pre><code>NEXT_PUBLIC_TW_CLIENT_ID=\"INSERT_CLIENT_ID\"\n</code></pre> <p>There are no other fields that you need to specify in your <code>.env</code> file at this time. If you're uncertain about formatting, you can refer to the <code>.env.example</code> file included in the project.</p>"},{"location":"tutorials/eth-api/thirdweb/#run-the-project","title":"Run the project","text":"<p>We're not finished with the project yet, but it should be at a stage where you can launch the template and see the web app load successfully in your browser. </p> npmyarnpnpm <pre><code>npm run dev\n</code></pre> <pre><code>yarn dev\n</code></pre> <pre><code>pnpm dev\n</code></pre> <p>If you see a blank screen, this typically means that you've failed to properly configure your client ID. </p>"},{"location":"tutorials/eth-api/thirdweb/#add-support-for-moonbase-alpha","title":"Add Support for Moonbase Alpha","text":"<p>thirdweb offers a small number of chains from <code>@thirdweb/chains</code> and does not include Moonbeam networks in that list, so you'll need to specify the network details including chain ID and RPC URL. You can create a custom chain with <code>defineChain</code> as follows:</p> MoonbeamMoonriverMoonbase Alpha chains.ts<pre><code>import { defineChain } from 'thirdweb';\nconst moonbeam = defineChain({\n  id: 1284,\n  rpc: 'https://rpc.api.moonbeam.network',\n});\n</code></pre> chains.ts<pre><code>import { defineChain } from 'thirdweb';\nconst moonriver = defineChain({\n  id: 1285,\n  rpc: 'https://rpc.api.moonriver.moonbeam.network',\n});\n</code></pre> chains.ts<pre><code>import { defineChain } from 'thirdweb';\nconst moonbase = defineChain({\n  id: 1287,\n  rpc: 'https://rpc.api.moonbase.moonbeam.network',\n});\n</code></pre> <p>The NFT marketplace template includes a <code>chains.ts</code> file under <code>src/consts/chains.ts</code>. To add support for Moonbase Alpha to the DApp, add the following lines: </p> chains.ts<pre><code>export const moonbase = defineChain({\n  id: 1287,\n  rpc: 'https://rpc.api.moonbase.moonbeam.network',\n});\n</code></pre> <p>We don't need to add any import statements because <code>defineChain</code> is already imported by default as part of the template. Feel free to add additional chains if you'd like to add support for Moonbeam, Moonriver, or other networks. The full file can be viewed below:</p> View chains.ts <pre><code>import { defineChain } from 'thirdweb';\n\n/**\n * All chains should be exported from this file\n */\nexport { avalancheFuji, sepolia, polygonAmoy } from 'thirdweb/chains';\n\n/**\n * Define the Moonbase Alpha test network\n */\nexport const moonbase = defineChain({\n  id: 1287,\n  rpc: 'https://rpc.api.moonbase.moonbeam.network',\n});\n</code></pre>"},{"location":"tutorials/eth-api/thirdweb/#deploy-erc-721-nft-contract","title":"Deploy ERC-721 NFT Contract","text":"<p>Of course, we'll need to have an NFT contract to showcase as part of the marketplace. You can use an existing NFT contract, but for demo purposes we'll walk through the steps of deploying a new ERC-721 contract with thirdweb. </p> <p>Head to thirdweb Explore and choose the <code>OpenEditionERC721</code> NFT standard. You can also access the NFT contract directly. Press Deploy Now, then take the following steps:</p> <ol> <li>Add a name for your NFT</li> <li>Optionally add a token symbol</li> <li>Upload the image for your NFT. This will be uploaded to IPFS</li> <li>Review the royalty information. By default, this is set to the address of your currently connected wallet and the royalty is set by default to 0%</li> <li>Review the address to receive the proceeds of initial NFT sales. By default, this is set to the address of your currently connected wallet</li> <li>Select your Network as Moonbase Alpha</li> <li>Press Deploy Now</li> </ol> <p></p> <p>You'll be asked for three wallet confirmations - the first two are transactions and the third is a signature. The first transaction deploys the NFT contract and the second sets the NFT metadata. The signature request is simply to add the NFT contract to your dashboard on thirdweb - this is highly recommended as it makes it easy to find your previously deployed NFTs from one easily-accessible place. </p>"},{"location":"tutorials/eth-api/thirdweb/#set-claim-condition","title":"Set Claim Condition","text":"<p>Before any NFTs can be minted, you'll need to configure the claim condition. If you try to mint any NFTs before setting the claim condition, the transaction will be reverted. To configure the claim condition for an open public mint, follow these steps:</p> <ol> <li>Head to the Claim Conditions page</li> <li>Select Public phase</li> <li>Optionally, choose a price to charge per mint. You can also leave this as 0 for a free mint</li> <li>Press Save Phases</li> </ol> <p></p>"},{"location":"tutorials/eth-api/thirdweb/#mint-some-nfts","title":"Mint Some NFTs","text":"<p>For aesthetic purposes, we'd like to have some NFTs show up in the marketplace that we created. Under the Extensions, NFTs section, press Claim. Then, you can mint some NFTs by taking the following steps:</p> <ol> <li>Enter the address to receive the NFTs</li> <li>Enter the desired quantity to mint</li> <li>Press Claim NFT and confirm the transaction in your wallet</li> </ol> <p></p>"},{"location":"tutorials/eth-api/thirdweb/#add-nft-contract-to-the-dapp","title":"Add NFT Contract to the DApp","text":"<p>After deploying and minting your NFTs, you'll need to specify your NFT contract in <code>src/consts/nft_contract.ts</code>. First, add <code>moonbase</code> to the list of imports as follows: </p> nft_contracts.ts<pre><code>import { moonbase, avalancheFuji, polygonAmoy, sepolia } from './chains';\n</code></pre> <p>Then, add your NFT contract to the array of marketplace contracts as follows:</p> nft_contracts.ts<pre><code>  {\n    address: '0x5647fb3dB4e47f25659F74b4e96902812f5bE9Fb',\n    chain: moonbase,\n    title: 'Moonbase NFT',\n    thumbnailUrl:\n      'https://258c828e8cc853bf5e0efd001055fb39.ipfscdn.io/ipfs/QmTDyLBf2LaG6mzPniPjpX3P4DTFvjAk3gtUgrAb8EVPUF/2024-05-22%2008.17.59.jpg',\n    type: 'ERC721',\n  },\n</code></pre> <p>To get the IPFS URL of the image of your NFT that you uploaded when creating the NFT contract, head to the Events tab of your NFT contract and locate the <code>SharedMetadataUpdated</code> event. Expand the dropdown and you'll see the image URI. You can concatenate this to an IPFS CDN as shown above. </p> <p></p> <p>The finished file can be viewed below:</p> View nft-contracts.ts <pre><code>import type { Chain } from 'thirdweb';\nimport { moonbase, avalancheFuji, polygonAmoy } from './chains';\n\nexport type NftContract = {\n  address: string;\n  chain: Chain;\n  type: 'ERC1155' | 'ERC721';\n\n  title?: string;\n  description?: string;\n  thumbnailUrl?: string;\n  slug?: string;\n};\n\n/**\n * Below is a list of all NFT contracts supported by your marketplace(s).\n * This is of course hard-coded for demo purposes\n *\n * In reality, the list should be dynamically fetched from your own data source\n */\nexport const NFT_CONTRACTS: NftContract[] = [\n  {\n    address: '0x6b869a0cF84147f05a447636c42b8E53De65714E',\n    chain: avalancheFuji,\n    title: 'Steakhouse: Liberatorz',\n    thumbnailUrl:\n      'https://258c828e8cc853bf5e0efd001055fb39.ipfscdn.io/ipfs/bafybeigonh3hde5suwcb3qvkh6ljtvxv7ubfmcqbwfvi3ihoi3igd27jwe/SteakhouseLogo.svg',\n    type: 'ERC721',\n  },\n  {\n    address: '0xC5A2c72c581eA4A17e17bEeF38a9597132830401',\n    chain: avalancheFuji,\n    title: 'Ugly Waifu',\n    thumbnailUrl:\n      'https://258c828e8cc853bf5e0efd001055fb39.ipfscdn.io/ipfs/bafybeidaadqapi7twzd7pjp24tu4ngsr3teubrhop7hg3jk3oj6lqysfgm/OS-LOGO.png',\n    slug: 'ugly-waifu',\n    type: 'ERC721',\n  },\n\n  {\n    address: '0x0896Db00D8987Fba2152aa7c14c4255eBC7354cE',\n    chain: avalancheFuji,\n    title: 'Unnamed Collection',\n    description: '',\n    thumbnailUrl:\n      'https://258c828e8cc853bf5e0efd001055fb39.ipfscdn.io/ipfs/Qmct2vS78Uwug3zVtqQognskPPRmd4wRQiaDAQWt1kRJws/0.png',\n    slug: 'unnamed-collection',\n    type: 'ERC721',\n  },\n  {\n    address: '0x0ACaCa3d3F64bb6e6D3564BBc891c58Bd4A4c83c',\n    chain: avalancheFuji,\n    title: 'GoroBot',\n    thumbnailUrl:\n      'https://258c828e8cc853bf5e0efd001055fb39.ipfscdn.io/ipfs/bafybeiay3ffxy3os56bvnu5cmq7gids4v6n4hf5nvvcb3gy2dzavi3ltnu/profile.jpg',\n    slug: 'gorobot',\n    type: 'ERC721',\n  },\n  {\n    address: '0x4b6CDEFF5885A57678261bb95250aC43aD490752',\n    chain: polygonAmoy,\n    title: 'Mata NFT',\n    thumbnailUrl:\n      'https://258c828e8cc853bf5e0efd001055fb39.ipfscdn.io/ipfs/bafybeidec7x6bptqmrxgptaedd7wfwxbsccqfogzwfsd4a7duxn4sdmnxy/0.png',\n    type: 'ERC721',\n  },\n  {\n    address: '0xd5e815241882676F772A624E3892b27Ff3a449c4',\n    chain: avalancheFuji,\n    title: 'Cats (ERC1155)',\n    thumbnailUrl:\n      'https://258c828e8cc853bf5e0efd001055fb39.ipfscdn.io/ipfs/bafybeif2nz6wbwuryijk2c4ayypocibexdeirlvmciqjyvlzz46mzoirtm/0.png',\n    type: 'ERC1155',\n  },\n  {\n    address: '0x5647fb3dB4e47f25659F74b4e96902812f5bE9Fb',\n    chain: moonbase,\n    title: 'Moonbase NFT',\n    thumbnailUrl:\n      'https://258c828e8cc853bf5e0efd001055fb39.ipfscdn.io/ipfs/QmTDyLBf2LaG6mzPniPjpX3P4DTFvjAk3gtUgrAb8EVPUF/2024-05-22%2008.17.59.jpg',\n    type: 'ERC721',\n  },\n];\n</code></pre>"},{"location":"tutorials/eth-api/thirdweb/#deploy-marketplace-contract","title":"Deploy Marketplace Contract","text":"<p>While the template includes existing marketplace contracts for a couple of TestNets, let's deploy a similar one for Moonbase Alpha. Head to thirdweb Explore and choose the <code>MarketplaceV3</code> contract. You can also access <code>MarketplaceV3</code> directly. Press Deploy Now, then take the following steps:</p> <ol> <li>Add a name for the marketplace</li> <li>Select Moonbase Alpha as the network</li> <li>Press Deploy Now</li> </ol> <p>You'll be asked to confirm a transaction and provide a signature. The former deploys the marketplace contract and the latter adds the contract to your dashboard on thirdweb (which is not required but highly recommend for keeping track of your contracts).</p> <p></p>"},{"location":"tutorials/eth-api/thirdweb/#add-marketplace-contract-to-the-dapp","title":"Add Marketplace Contract to the DApp","text":"<p>After deploying your marketplace contract you'll need to specify it in <code>src/consts/marketplace_contract.ts</code>. To add support for the Moonbase marketplace first add <code>moonbase</code> to the list of imports as follows: </p> marketplace_contract.ts<pre><code>import { moonbase, avalancheFuji, polygonAmoy, sepolia } from './chains';\n</code></pre> <p>Then, add your marketplace contract in the array of marketplace contracts as follows:</p> marketplace_contract.ts<pre><code>  {\n    address: '0xA76C6E534aa651756Af8c222686fC1D3abF6952A',\n    chain: moonbase,\n  },\n</code></pre> <p>The finished file can be viewed below:</p> View marketplace-contracts.ts <pre><code>import type { Chain } from 'thirdweb';\nimport { moonbase, avalancheFuji, polygonAmoy, sepolia } from './chains';\n\ntype MarketplaceContract = {\n  address: string;\n  chain: Chain;\n};\n\n/**\n * You need a marketplace contract on each of the chains you want to support.\n * Only list one marketplace contract address for each chain\n */\nexport const MARKETPLACE_CONTRACTS: MarketplaceContract[] = [\n  {\n    address: '0x8C1D464B385A2B7EAa80dcAAD66DD8BC0256e717',\n    chain: avalancheFuji,\n  },\n  {\n    address: '0x571B773F1e4A7C080b51C36f37e06f371C515569',\n    chain: polygonAmoy,\n  },\n  {\n    address: '0xe0eFD6fb388405b67b3E9FaFc02649c70E749f03',\n    chain: sepolia,\n  },\n  {\n    address: '0xA76C6E534aa651756Af8c222686fC1D3abF6952A',\n    chain: moonbase,\n  },\n];\n</code></pre>"},{"location":"tutorials/eth-api/thirdweb/#wrapping-up","title":"Wrapping Up","text":"<p>And that's it! Congratulations on making it through the tutorial. You can head to <code>http://localhost:3000</code> after running the DApp locally via one of the following: </p> npmyarnpnpm <pre><code>npm run dev\n</code></pre> <pre><code>yarn dev\n</code></pre> <pre><code>pnpm dev\n</code></pre> <p>On the homepage you should see your newly added NFT contract. Click on the NFT collection and you'll see something that looks like the below:</p> <p></p> <p>For more information on what you can do with thirdweb on Moonbeam be sure to check out the thirdweb guide in the Builders section or the thirdweb documentation site.</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/eth-api/using-tenderly/","title":"Using Tenderly to Simulate and Debug Transactions","text":"<p>by Kevin Neilson</p>"},{"location":"tutorials/eth-api/using-tenderly/#introduction","title":"Introduction","text":"<p>Tenderly is an all-in-one development platform for EVM networks that enables Web3 developers to build, test, monitor, and operate their smart contracts. Tenderly has a full suite of product offerings to help you as a developer throughout the lifecycle of a smart contract, from the earliest stages of development to maintenance and alerting on a live production dApp.</p> <p>Most services offered by Tenderly are free to use, but you'll need to subscribe to a paid plan for advanced features like real-time alerting and war room functionality. Tenderly supports Moonbeam and Moonriver but does not support Moonbase Alpha at this time. For more information about Tenderly's product offerings, be sure to familiarize yourself with the Introduction to Tenderly.</p> <p>In this tutorial, we're going to explore two of Tenderly's most powerful features, the debugger and the simulator.</p>"},{"location":"tutorials/eth-api/using-tenderly/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you will need the following:</p> <ul> <li>Have a free Tenderly Account. You do not need a paid plan to complete this tutorial</li> </ul>"},{"location":"tutorials/eth-api/using-tenderly/#create-a-tenderly-project","title":"Create a Tenderly Project","text":"<p>Although not strictly required, it's a good idea to create a Tenderly project to keep things organized and access more of Tenderly's available features. Underneath the Select Project dropdown, you can press Create Project or head directly to the Create Project page of the dashboard.</p> <p>Give your project a name, and then press Create Project. Although you can change your project name at a later point, the URL will remain the original one you created.</p> <p></p> <p>There is a limit of one project with a free account; however, you can have multiple smart contracts under the purview of a single project.</p>"},{"location":"tutorials/eth-api/using-tenderly/#add-smart-contracts","title":"Add Smart Contracts","text":"<p>Adding a smart contract to your Tenderly project is akin to bookmarking it. While not required, adding a contract will unlock additional Tenderly features over simply searching for the contract on the Tenderly platform.</p> <p>To add a smart contract to your Tenderly project, click on the Contracts tab under the Inspect heading, then click Add Contracts. Then, take the following steps:</p> <ol> <li>Enter the address of the contract. For this tutorial, we'll be using the FRAX stablecoin contract <code>0x322E86852e492a7Ee17f28a78c663da38FB33bfb</code></li> <li>Select the network the contract is deployed to. We'll select Moonbeam in this case</li> <li>Give the contract a name to help you recognize it on the dashboard</li> <li>Press Add Contract</li> </ol> <p></p>"},{"location":"tutorials/eth-api/using-tenderly/#simulate-a-transaction","title":"Simulate a Transaction","text":"<p>Simulations allow you to see how a transaction will execute without actually sending it on the blockchain. You can simulate a transaction against any point in time or simply the latest block.</p> <p>Head over to the Simulator tab, and let's craft a transaction to simulate against the Moonbeam network by taking the following steps:</p> <ol> <li>Select the contract that you'd like to interact with. The name displayed here is the nickname that you gave the contract when adding it to your Tenderly workspace</li> <li>Select the contract function you'd like to call. <code>Transfer</code> is selected for demonstration purposes</li> <li>Next, we'll input the relevant function parameters. For destination address, you can input any address, such as Alith's address: <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>For amount, you can also specify any amount, such as <code>10000000000</code></li> <li>Select Pending Block to run the simulation against the latest Moonbeam block produced</li> <li>Specify the from address as Baltathar: <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code> or another address of your choice</li> <li>Press Simulate Transaction</li> </ol> <p></p> <p>Clearly, this simulated transaction is going to fail because we're trying to send 10,000 FRAX that we don't have. But, with the Tenderly Simulator, we can tinker with the blockchain state and run simulations that assume different conditions. For example, let's run the simulation assuming that Baltathar actually holds a balance of 10,000 FRAX. Press Re-Simulate in the upper right corner, then take the following steps:</p> <ol> <li>Expand the State Overrides section</li> <li>Press Add State Override</li> <li>Select the relevant contract, in this case the FRAX one</li> <li>Under the Storage Variables section, we're going to override the mapping that holds the balance of Baltathar by specifying the key as: <code>balanceOf[0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0]</code> and the value as: <code>10000000000</code>. Pay careful attention that you are performing this step in the Storage Variables section and not the Balance section</li> <li>Press Add to confirm adding the state override</li> <li>Press Simulate Transaction</li> </ol> <p></p> <p>Note</p> <p>Remember that the Alith and Baltathar accounts are part of the list of public developer accounts with known private keys. You will lose any funds sent to these addresses.</p> <p>If you correctly added the state override, you should now see a transaction simulation success screen upon running the simulation. If you get an error, you can press Re-Simulate and verify that you have configured the state override correctly.</p> <p></p> <p>You can also access Tenderly's transaction simulator via the Simulations API.</p>"},{"location":"tutorials/eth-api/using-tenderly/#debugging","title":"Debugging","text":"<p>The Debugger is one of the most powerful and acclaimed features of Tenderly. It's also quite fast and requires minimal setup. In fact, if the contract you're investigating is already verified on chain, firing up the debugger is as easy as searching for the transaction hash on Tenderly. Let's try it out.</p> <p>In the upper search bar, you can paste a contract address or a transaction hash. Recall that Tenderly supports Moonbeam and Moonriver but does not currently support Moonbase Alpha. Here's an example transaction hash of a GLMR / FRAX swap on StellaSwap:</p> <pre><code>0x80c87ab47e077ca491045047389e6bd88a748ca24971a288d09608834a3bda07\n</code></pre> <p>After finding the transaction hash, you're greeted at the top with all of the typical statistics about the transaction, such as status, gas price, gas used, etc. Following that, you'll see a breakdown of the tokens transferred. And at the bottom you'll see a long list of every function call. Given that a swap is a relatively complex interaction, and given that StellaSwap uses upgradable proxy contracts, you'll see quite a long list in this example.</p> <p></p> <p>If you click on Contracts on the left-hand navigation bar, you'll see a list of every contract the transaction interacted with. You can click on a contract to see more details and view the entire source code if the contract is verified.</p> <p></p> <p>Heading down the left-hand navigation bar, you'll see an Events tab followed by a State Changes tab, which shows a visual representation of each change to the chain state that occurred as a result of this transaction.</p> <p></p> <p>If you scroll down to the Debugger tab, you'll be able to step through the contracts line by line and see key state information at the bottom, allowing you to pinpoint the source of any error.</p> <p></p> <p>Finally, you'll see a Gas Profiler, which will give you a visual representation of where and how the gas was spent throughout the course of the transaction. You can click on any of the function calls (represented by the blue rectangles) to see how much gas was spent in each call.</p> <p></p> <p>For a more detailed look, be sure to check out the How to Use Tenderly Debugger guide. And that's it! You're well on your way to mastering Tenderly, which is sure to save you time and simplify your development experience building dApps on Moonbeam.</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/integrations/0xgasless/","title":"Enabling Gasless Transactions with 0xGasless","text":""},{"location":"tutorials/integrations/0xgasless/#why-gasless-transactions","title":"Why Gasless Transactions?","text":"<p>One of the primary challenges in blockchain development has been the requirement for users to hold native tokens (like ETH or GLMR) to pay transaction fees. This traditional EOA-based model creates unnecessary friction, particularly when onboarding users who expect Web2-like experiences.</p> <p>Gasless transactions can help solve this through Account Abstraction (ERC-4337), implementing meta-transactions that separate user actions from fee payment. This architecture allows dApps or third-party paymasters to cover gas costs on behalf of users while smart contract wallets handle the transaction execution. 0xGasless leverages these principles in its SDK, enabling Moonbeam developers to implement sophisticated features like social logins, transaction batching, and custom wallet controls \u2013 all while abstracting away the complexity of gas management from end users.</p> <p>In the following tutorial, we'll go through the end-to-end steps of setting up a paymaster on 0xGasless and dispatching a gasless transaction to modify the state of a smart contract on Moonbeam.</p>"},{"location":"tutorials/integrations/0xgasless/#create-and-fund-a-paymaster","title":"Create and Fund a Paymaster","text":"<p>First, you'll need to register for an account on 0xGasless. Then, create a Paymaster for the Moonbeam Network by pressing Create Paymaster and then taking the following steps:</p> <ol> <li>Enter a name for your paymaster</li> <li>Select Moonbeam as the chain</li> <li>Press Create</li> </ol> <p></p> <p>Your paymaster needs funds to cover gas fees for sponsored transactions. To deposit GLMR into your paymaster, take the following steps:</p> <ol> <li>Enter the amount you would like to deposit</li> <li>Press Deposit and confirm the transaction in your wallet</li> </ol> <p></p> <p>Your deposited funds remain flexible - use them to sponsor gasless transactions or withdraw them whenever needed.</p>"},{"location":"tutorials/integrations/0xgasless/#dispatching-a-gasless-transaction","title":"Dispatching a Gasless Transaction","text":"<p>In the following section, we'll create a script demonstrating how to dispatch a gasless transaction. </p>"},{"location":"tutorials/integrations/0xgasless/#prerequisites","title":"Prerequisites","text":"<p>Create a <code>.env</code> file in your project's root directory with the following:</p> <pre><code>PRIVATE_KEY=INSERT_PRIVATE_KEY\nRPC_URL=https://rpc.api.moonbeam.network\n</code></pre> <p>Why are we specifying a private key in the <code>.env</code>? While this transaction will be gasless, you still need a private key to sign the transaction. The account associated with this private key:</p> <ul> <li>Does not need any GLMR tokens</li> <li>Will not pay for gas fees</li> <li>Is only used for transaction signing</li> </ul> <p>Note</p> <p>Never commit your .env file or share your private key. Add .env to your .gitignore file.</p> <p>Also, make sure you have installed the 0xGasless SDK and supporting <code>ethers</code> and <code>dotenv</code> packages:</p> <pre><code>npm install ethers dotenv @0xgasless/smart-account\n</code></pre> <p>First, we'll import the required packages as follows:</p> <pre><code>require('dotenv').config();\nconst ethers = require('ethers');\nconst {\n  PaymasterMode,\n  createSmartAccountClient,\n} = require('@0xgasless/smart-account');\n</code></pre> <p>Next, we'll set the critical constants. We must define the <code>CHAIN_ID</code>, <code>BUNDLER_URL</code>, and <code>PAYMASTER_URL</code>. You can get your unique paymaster URL from the paymaster on your 0xGasless Dashboard.</p> <p>The contract address we've defined here is the address of an Incrementer contract on Moonbeam, on which we'll call the increment function specified by the function selector. This simple contract will allow us to easily see if the gasless transaction has been dispatched successfully. </p> <pre><code>const CHAIN_ID = 1284; // Moonbeam mainnet\nconst BUNDLER_URL = `https://bundler.0xgasless.com/${CHAIN_ID}`;\nconst PAYMASTER_URL =\n  'https://paymaster.0xgasless.com/v1/1284/rpc/INSERT_API_KEY';\nconst CONTRACT_ADDRESS = '0x3aE26f2c909EB4F1EdF97bf60B36529744b09213';\nconst FUNCTION_SELECTOR = '0xd09de08a';\n</code></pre> <p>Warning</p> <p>The Paymaster URL format has recently changed. Use:</p> <pre><code>https://paymaster.0xgasless.com/v1/1284/rpc/INSERT_API_KEY\n</code></pre> <p>Do not use the deprecated format:</p> <pre><code>https://paymaster.0xgasless.com/api/v1/1284/rpc/INSERT_API_KEY\n</code></pre> <p>The difference is that <code>/api</code> has been removed from the path. Make sure your code uses the current format.</p>"},{"location":"tutorials/integrations/0xgasless/#sending-the-transaction","title":"Sending the Transaction","text":"<p>To send a gasless transaction using the 0xGasless smart account, you can call <code>smartWallet.sendTransaction()</code> with two parameters:</p> <ul> <li>The <code>transaction</code> object containing the contract interaction details</li> <li>A configuration object specifying <code>paymasterServiceData</code> with <code>SPONSORED</code> mode. This indicates that the 0xGasless paymaster will use the gas tank to pay for the gas. </li> </ul> <p>The function returns a UserOperation response containing a hash. Wait for the transaction receipt using the <code>waitForUserOpReceipt()</code> helper function, which polls for completion with a configurable timeout (default 60 seconds).</p> <pre><code>const userOpResponse = await smartWallet.sendTransaction(transaction, {\n  paymasterServiceData: { mode: PaymasterMode.SPONSORED },\n});\n\nconst receipt = await waitForUserOpReceipt(userOpResponse, 60000);\n</code></pre> <p>Putting it all together and adding plenty of logging and error handling for easy debugging, the full script is as follows:</p> Dispatch a gasless transaction <pre><code>require('dotenv').config();\nconst ethers = require('ethers');\nconst {\n  PaymasterMode,\n  createSmartAccountClient,\n} = require('@0xgasless/smart-account');\n\nconst CHAIN_ID = 1284; // Moonbeam mainnet\nconst BUNDLER_URL = `https://bundler.0xgasless.com/${CHAIN_ID}`;\nconst PAYMASTER_URL =\n  'https://paymaster.0xgasless.com/v1/1284/rpc/INSERT_API_KEY';\nconst CONTRACT_ADDRESS = '0x3aE26f2c909EB4F1EdF97bf60B36529744b09213';\nconst FUNCTION_SELECTOR = '0xd09de08a';\n\nasync function main() {\n  console.log('Starting the script...');\n  try {\n    // Set up provider and wallet\n    console.log('Setting up provider and wallet...');\n    const provider = new ethers.providers.JsonRpcProvider(process.env.RPC_URL);\n    const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);\n\n    // Check connection and balance\n    console.log('Checking network connection...');\n    const network = await provider.getNetwork();\n    console.log(\n      `Connected to network: ${network.name} (Chain ID: ${network.chainId})`\n    );\n    const balance = await provider.getBalance(wallet.address);\n    console.log(`Wallet balance: ${ethers.utils.formatEther(balance)} GLMR`);\n\n    // Initialize smart account\n    console.log('Initializing smart account...');\n    const smartWallet = await createSmartAccountClient({\n      signer: wallet,\n      paymasterUrl: PAYMASTER_URL,\n      bundlerUrl: BUNDLER_URL,\n      chainId: CHAIN_ID,\n    });\n    const smartWalletAddress = await smartWallet.getAddress();\n    console.log('Smart Account Address:', smartWalletAddress);\n\n    // Create a transaction for contract interaction\n    console.log('Creating contract transaction...');\n    const transaction = {\n      to: CONTRACT_ADDRESS,\n      value: '0', // No native token transfer\n      data: FUNCTION_SELECTOR, // The function selector for the method we want to call\n    };\n\n    // Send the transaction\n    console.log('Sending transaction...');\n    const userOpResponse = await smartWallet.sendTransaction(transaction, {\n      paymasterServiceData: { mode: PaymasterMode.SPONSORED },\n    });\n    console.log('UserOp Hash:', userOpResponse.hash);\n\n    console.log('Waiting for transaction receipt...');\n    const userOpReceipt = await waitForUserOpReceipt(userOpResponse, 60000); // Wait for up to 60 seconds\n\n    if (userOpReceipt.success) {\n      console.log('Transaction successful!');\n      console.log('Transaction hash:', userOpReceipt.receipt.transactionHash);\n    } else {\n      console.log('Transaction failed');\n      console.log('Receipt:', userOpReceipt);\n    }\n  } catch (error) {\n    console.error('An error occurred:');\n    console.error(error);\n  }\n}\n\nasync function waitForUserOpReceipt(userOpResponse, timeoutMs = 60000) {\n  return new Promise((resolve, reject) =&gt; {\n    const startTime = Date.now();\n    const checkReceipt = async () =&gt; {\n      try {\n        const receipt = await userOpResponse.wait();\n        resolve(receipt);\n      } catch (error) {\n        if (Date.now() - startTime &gt; timeoutMs) {\n          reject(new Error(`Transaction wait timeout after ${timeoutMs}ms`));\n        } else {\n          setTimeout(checkReceipt, 5000); // Retry every 5 seconds\n        }\n      }\n    };\n    checkReceipt();\n  });\n}\n\nmain().catch((error) =&gt; {\n  console.error('Unhandled error in main function:');\n  console.error(error);\n});\n</code></pre>"},{"location":"tutorials/integrations/0xgasless/#verifying-completion","title":"Verifying Completion","text":"<p>Upon running the script, you'll see output that looks like the following: </p> 0xgasless % node dispatch.js Starting the script... Setting up provider and wallet... Checking network connection... Connected to network: unknown (Chain ID: 1284) Wallet balance: 8.781249287153010128 GLMR Initializing smart account... Smart Account Address: 0xbBf77D3B43d81D426c4c3D200a76F4D3a914ccE3 Creating contract transaction... Sending transaction... UserOp Hash: undefined Waiting for transaction receipt... Transaction successful! Transaction hash: 0x9cb49cc0acc21abc364c13dd52b3f65c206ec61c57a13c23b635f59e1919cf7c <p>Since the gasless transaction we initiated interacts with an Incrementer smart contract on Moonbeam, it's easy to check to see if the transaction was initiated successfully. You can return to Read Contract section of the Incrementer contract on Moonscan and check the number stored in the contract. Alternatively, you can head to the Internal Transactions tab and toggle advanced mode ON to see the contract call incrementing the contract. </p> <p>For more information about integrating support for gasless transactions into your dApp, be sure to check out the 0xGasless docs.</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/integrations/local-subsquid/","title":"Index a Local Moonbeam Development Node with SQD (formerly Subsquid)","text":"<p>by Erin Shaben and Kevin Neilson</p>"},{"location":"tutorials/integrations/local-subsquid/#introduction","title":"Introduction","text":"<p>When developing a dApp, it's beneficial to develop smart contracts using a local development environment as opposed to a live network, such as a TestNet or MainNet. Local development removes some of the hassles involved with developing on a live network, like having to fund development accounts and waiting for blocks to be produced. On Moonbeam, developers can spin up their own local Moonbeam development node to quickly and easily build and test applications.</p> <p>But what about dApps that rely on indexers to index blockchain data? How can developers of these applications streamline the development process? Thanks to SQD, a data network for retrieving data from 100+ chains, it is now possible to index blocks in a local development environment, such as your Moonbeam development node!</p> <p>This tutorial will walk you through the process of indexing data on a local Moonbeam development node using SQD. We'll create an ERC-20 contract and use SQD to index transfers of our ERC-20.</p>"},{"location":"tutorials/integrations/local-subsquid/#check-prerequisites","title":"Check Prerequisites","text":"<p>To follow along with this tutorial, you'll need to have:</p> <ul> <li>Docker installed</li> <li>Docker Compose installed</li> <li>An empty Hardhat project. For step-by-step instructions, please refer to the Creating a Hardhat Project section of our Hardhat documentation page</li> <li>An ERC-20 token deployed to your local development node, unless you plan on indexing Moonbase Alpha and using an existing ERC-20</li> </ul> <p>We'll configure our Hardhat project and create our SQD project later on in the tutorial.</p>"},{"location":"tutorials/integrations/local-subsquid/#spin-up-a-local-development-node","title":"Spin up a Local Development Node","text":"<p>To get started, we're going to spin up a local Moonbeam development node using Docker. For the purposes of this tutorial, we're going to configure our development node to produce (seal) blocks every four seconds. This will ease the debugging process. However, you can feel free to increase or decrease this time or configure your node to instantly seal blocks. When using instant seal, a block will be created when a transaction is received.</p> <p>We'll use the following commands when starting up our node:</p> <ul> <li><code>--dev</code> - specifies to use a development chain</li> <li><code>--sealing 4000</code> - seals a block every four seconds (4000 milliseconds)</li> <li><code>--rpc-external</code> - listen to all HTTP and WebSocket interfaces</li> </ul> <p>To spin up a development node, which will pull the latest Docker image for Moonbeam, you can run the following command:</p> UbuntuMacOSWindows <pre><code>docker run --rm --name moonbeam_development --network host \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--dev --sealing 4000 --rpc-external\n</code></pre> <pre><code>docker run --rm --name moonbeam_development -p 9944:9944 \\\nmoonbeamfoundation/moonbeam:v0.47.0 \\\n--dev --sealing 4000 --rpc-external\n</code></pre> <pre><code>docker run --rm --name moonbeam_development -p 9944:9944 ^\nmoonbeamfoundation/moonbeam:v0.47.0 ^\n--dev --sealing 4000 --rpc-external\n</code></pre> <p>This will start up our development node, which can be accessed on port 9944. Note that you do not have to use Docker; you can also run a local node by compiling the Moonbeam binary.</p> docker run --rm --name moonbeam_development -p 9944:9944 \\ moonbeamfoundation/moonbeam:v0.47.0 \\ --dev --rpc-external 2025-07-10 09:04:26 Moonbeam Parachain Collator 2025-07-10 09:04:26 \u270c\ufe0f  version 0.47.0-d7df89e7161 2025-07-10 09:04:26 \u2764\ufe0f  by PureStake, 2019-2025 2025-07-10 09:04:26 \ud83d\udccb Chain specification: Moonbase Development Testnet 2025-07-10 09:04:26 \ud83c\udff7  Node name: truthful-volcano-8206 2025-07-10 09:04:26 \ud83d\udc64 Role: AUTHORITY 2025-07-10 09:04:26 \ud83d\udcbe Database: RocksDb at /tmp/substrate5PF2uR/chains/moonbase_dev/db/full 2025-07-10 09:04:26 \ud83d\udd28 Initializing Genesis block/state (state: 0x554b\u20269ef4, header-hash: 0xbe59\u2026cd6e) 2025-07-10 09:04:26 Using default protocol ID \"sup\" because none is configured in the chain specs 2025-07-10 09:04:26 \ud83c\udff7  Local node identity is: 12D3KooWJf8ba9DW6XH6Q7RZZK6qKHyYXAxE7eMSEgLqUDGaNP3n 2025-07-10 09:04:26 Running libp2p network backend 2025-07-10 09:04:26 \ud83d\udcbb Operating system: linux 2025-07-10 09:04:26 \ud83d\udcbb CPU architecture: x86_64 2025-07-10 09:04:26 \ud83d\udcbb Target environment: gnu 2025-07-10 09:04:26 \ud83d\udcbb Memory: 12200MB 2025-07-10 09:04:26 \ud83d\udcbb Kernel: 6.10.14-linuxkit 2025-07-10 09:04:26 \ud83d\udcbb Linux distribution: Debian GNU/Linux 12 (bookworm) 2025-07-10 09:04:26 \ud83d\udcbb Virtual machine: no 2025-07-10 09:04:26 \ud83d\udce6 Highest known block at #0 2025-07-10 09:04:26 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615 2025-07-10 09:04:26 Running JSON-RPC server: addr=0.0.0.0:9944, allowed origins=[\"*\"] 2025-07-10 09:04:26 \ud83c\udfc1 CPU score: 708.84 MiBs 2025-07-10 09:04:26 \ud83c\udfc1 Memory score: 25.72 GiBs 2025-07-10 09:04:26 \ud83c\udfc1 Disk score (seq. writes): 2.24 GiBs 2025-07-10 09:04:26 \ud83c\udfc1 Disk score (rand. writes): 717.22 MiBs 2025-07-10 09:04:26 Development Service Ready 2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0xbe59\u2026cd6e), finalized #0 (0xbe59\u2026cd6e), \u2b07 0 \u2b06 0 <p>Our development node comes with 10 prefunded accounts.</p> Development account addresses and private keys <ul> <li> <p>Alith:</p> <ul> <li>Public Address: <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>Private Key: <code>0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133</code></li> </ul> </li> <li> <p>Baltathar:</p> <ul> <li>Public Address: <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>Private Key: <code>0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b</code></li> </ul> </li> <li> <p>Charleth:</p> <ul> <li>Public Address: <code>0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</code></li> <li>Private Key: <code>0x0b6e18cafb6ed99687ec547bd28139cafdd2bffe70e6b688025de6b445aa5c5b</code></li> </ul> </li> <li> <p>Dorothy:</p> <ul> <li>Public Address: <code>0x773539d4Ac0e786233D90A233654ccEE26a613D9</code></li> <li>Private Key: <code>0x39539ab1876910bbf3a223d84a29e28f1cb4e2e456503e7e91ed39b2e7223d68</code></li> </ul> </li> <li> <p>Ethan:</p> <ul> <li>Public Address: <code>0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB</code></li> <li>Private Key: <code>0x7dce9bc8babb68fec1409be38c8e1a52650206a7ed90ff956ae8a6d15eeaaef4</code></li> </ul> </li> <li> <p>Faith:</p> <ul> <li>Public Address: <code>0xC0F0f4ab324C46e55D02D0033343B4Be8A55532d</code></li> <li>Private Key: <code>0xb9d2ea9a615f3165812e8d44de0d24da9bbd164b65c4f0573e1ce2c8dbd9c8df</code></li> </ul> </li> <li> <p>Goliath:</p> <ul> <li>Public Address: <code>0x7BF369283338E12C90514468aa3868A551AB2929</code></li> <li>Private Key: <code>0x96b8a38e12e1a31dee1eab2fffdf9d9990045f5b37e44d8cc27766ef294acf18</code></li> </ul> </li> <li> <p>Heath: </p> <ul> <li>Public Address: <code>0x931f3600a299fd9B24cEfB3BfF79388D19804BeA</code></li> <li>Private Key: <code>0x0d6dcaaef49272a5411896be8ad16c01c35d6f8c18873387b71fbc734759b0ab</code></li> </ul> </li> <li> <p>Ida: </p> <ul> <li>Public Address: <code>0xC41C5F1123ECCd5ce233578B2e7ebd5693869d73</code></li> <li>Private Key: <code>0x4c42532034540267bf568198ccec4cb822a025da542861fcb146a5fab6433ff8</code></li> </ul> </li> <li> <p>Judith: </p> <ul> <li>Public Address: <code>0x2898FE7a42Be376C8BC7AF536A940F7Fd5aDd423</code></li> <li>Private Key: <code>0x94c49300a58d576011096bcb006aa06f5a91b34b4383891e8029c21dc39fbb8b</code></li> </ul> </li> </ul> <p>For more information on running a Moonbeam development node, please refer to the Getting Started with a Moonbeam Development Node guide.</p>"},{"location":"tutorials/integrations/local-subsquid/#deploy-an-erc-20-with-hardhat","title":"Deploy an ERC-20 with Hardhat","text":"<p>You should have already created an empty Hardhat project, but if you haven't done so, you can find instructions in the Creating a Hardhat Project section of our Hardhat documentation page.</p> <p>In this section, we'll configure our Hardhat project for a local Moonbeam development node, create an ERC-20 contract, and write scripts to deploy and interact with our contract.</p> <p>Before we dive into creating our project, let's install a couple of dependencies that we'll need: the Hardhat Ethers plugin and OpenZeppelin contracts. The Hardhat Ethers plugin provides a convenient way to use the Ethers library to interact with the network. We'll use OpenZeppelin's base ERC-20 implementation to create an ERC-20. To install both of these dependencies, you can run:</p> npmyarn <pre><code>npm install @nomicfoundation/hardhat-ethers ethers@6 @openzeppelin/contracts\n</code></pre> <pre><code>yarn add @nomicfoundation/hardhat-ethers ethers@6 @openzeppelin/contracts\n</code></pre>"},{"location":"tutorials/integrations/local-subsquid/#create-a-hardhat-project","title":"Configure Hardhat for a Local Development Node","text":"<p>Before we update the configuration file, we'll need to get the private key of one of our development accounts, which will be used to deploy our contract and send transactions. For this example, we'll use Alith's private key:</p> <pre><code>0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133\n</code></pre> <p>Remember</p> <p>You should never store your private keys in a JavaScript or Python file.</p> <p>The private keys for the development accounts are public knowledge because the accounts exist within your own development environment. However, when you move on to indexing a live network such as Moonbase Alpha or Moonbeam (which is out of scope for this tutorial), you should manage your private keys with a designated secret manager or similar service.</p> <p>Now we can edit <code>hardhat.config.js</code> to include the following network and account configurations for our Moonbeam development node:</p> hardhat.config.js <pre><code>// Import the Ethers plugin required to interact with the contract\nrequire('@nomicfoundation/hardhat-ethers');\n\n/** @type import('hardhat/config').HardhatUserConfig */\nmodule.exports = {\n  // Specify the Solidity version\n  solidity: '0.8.20',\n  networks: {\n    dev: {\n      url: 'http://127.0.0.1:9944',\n      chainId: 1281, // (hex: 0x501),\n      accounts: [\n        '0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133',\n      ], // Alith's private key\n    },\n  },\n};\n</code></pre>"},{"location":"tutorials/integrations/local-subsquid/#create-an-erc-20-contract","title":"Create an ERC-20 Contract","text":"<p>For the purposes of this tutorial, we'll be creating a simple ERC-20 contract. We'll rely on OpenZeppelin's ERC-20 base implementation. We'll start by creating a file for the contract and naming it <code>MyTok.sol</code>:</p> <pre><code>mkdir -p contracts &amp;&amp; touch contracts/MyTok.sol\n</code></pre> <p>Now we can edit the <code>MyTok.sol</code> file to include the following contract, which will mint an initial supply of MYTOKs and allow only the owner of the contract to mint additional tokens:</p> MyTok.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyTok is ERC20, Ownable {\n    constructor() ERC20(\"MyToken\", \"MTK\") Ownable(msg.sender) {\n        _mint(msg.sender, 50000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n</code></pre>"},{"location":"tutorials/integrations/local-subsquid/#deploy-an-erc-20-contract","title":"Deploy an ERC-20 Contract","text":"<p>Now that we have our contract set up, we can compile and deploy our contract.</p> <p>To compile the contract, you can run:</p> <pre><code>npx hardhat compile\n</code></pre> npx hardhat compile Compiled 6 Solidity files successfully (evm target: paris)  <p>This command will compile our contract and generate an <code>artifacts</code> directory containing the ABI of the contract. To deploy our contract, we'll need to create a deployment script that deploys our ERC-20 contract and mints an initial supply of MYTOKs. We'll use Alith's account to deploy the contract, and we'll specify the initial supply to be 1000 MYTOK. The initial supply will be minted and sent to the contract owner, which is Alith.</p> <p>Let's take the following steps to deploy our contract:</p> <ol> <li> <p>Create a directory and file for our script:</p> <pre><code>mkdir -p scripts &amp;&amp; touch scripts/deploy.js\n</code></pre> </li> <li> <p>In the <code>deploy.js</code> file, go ahead and add the following script:</p> deploy.js <pre><code>// scripts/deploy.js\nconst hre = require('hardhat');\nrequire('@nomicfoundation/hardhat-ethers');\n\nasync function main() {\n  // Get ERC-20 contract\n  const MyTok = await hre.ethers.getContractFactory('MyTok');\n\n  // Deploy the contract\n  const myTok = await MyTok.deploy();\n\n  // Wait for the deployment\n  await myTok.waitForDeployment();\n\n  console.log(`Contract deployed to ${myTok.target}`);\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre> </li> <li> <p>Run the script using the <code>dev</code> network configurations we set up in the <code>hardhat.config.js</code> file:</p> <pre><code>npx hardhat run scripts/deploy.js --network dev\n</code></pre> </li> </ol> <p>The address of the deployed contract should be printed to the terminal. Save the address, as we'll need it to interact with the contract in the following section.</p> npx hardhat run scripts/deploy.js --network dev Contract deployed to 0xc01Ee7f10EA4aF4673cFff62710E1D7792aBa8f3"},{"location":"tutorials/integrations/local-subsquid/#transfer-erc-20s","title":"Transfer ERC-20s","text":"<p>Since we'll be indexing <code>Transfer</code> events for our ERC-20, we'll need to send a few transactions that transfer some tokens from Alith's account to our other test accounts. We'll do this by creating a simple script that transfers 10 MYTOKs to Baltathar, Charleth, Dorothy, and Ethan. We'll take the following steps:</p> <ol> <li> <p>Create a new file script to send transactions:</p> <pre><code>touch scripts/transactions.js\n</code></pre> </li> <li> <p>In the <code>transactions.js</code> file, add the following script and insert the contract address of your deployed MyTok contract (output in the console in the prior step):</p> transactions.js <pre><code>// We require the Hardhat Runtime Environment explicitly here. This is optional\n// but useful for running the script in a standalone fashion through `node &lt;script&gt;`.\n//\n// You can also run a script with `npx hardhat run &lt;script&gt;`. If you do that, Hardhat\n// will compile your contracts, add the Hardhat Runtime Environment's members to the\n// global scope, and execute the script.\nconst hre = require('hardhat');\n\nasync function main() {\n  // Get contract ABI\n  const MyTok = await hre.ethers.getContractFactory('MyTok');\n\n  // Plug ABI to address\n  const myTok = await MyTok.attach(\n    '0xc01Ee7f10EA4aF4673cFff62710E1D7792aBa8f3'\n  );\n\n  const value = 10000000000000000000n;\n\n  let tx;\n  // Transfer to Baltathar\n  tx = await myTok.transfer(\n    '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0',\n    value\n  );\n  await tx.wait();\n  console.log(`Transfer to Baltathar with TxHash ${tx.hash}`);\n\n  // Transfer to Charleth\n  tx = await myTok.transfer(\n    '0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc',\n    value\n  );\n  await tx.wait();\n  console.log(`Transfer to Charleth with TxHash ${tx.hash}`);\n\n  // Transfer to Dorothy\n  tx = await myTok.transfer(\n    '0x773539d4Ac0e786233D90A233654ccEE26a613D9',\n    value\n  );\n  await tx.wait();\n  console.log(`Transfer to Dorothy with TxHash ${tx.hash}`);\n\n  // Transfer to Ethan\n  tx = await myTok.transfer(\n    '0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB',\n    value\n  );\n  await tx.wait();\n  console.log(`Transfer to Ethan with TxHash ${tx.hash}`);\n}\n\n// We recommend this pattern to be able to use async/await everywhere\n// and properly handle errors.\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre> </li> <li> <p>Run the script to send the transactions:</p> <pre><code>npx hardhat run scripts/transactions.js --network dev\n</code></pre> </li> </ol> <p>As each transaction is sent, you'll see a log printed to the terminal.</p> npx hardhat run scripts/transactions.js --network dev Transfer to Baltathar with TxHash 0x188eca1c42c6fa63588f998a453e2ce40d7d2166fdaa36b1838226dd06c8e3c2 Transfer to Charleth with TxHash 0xc38dfa6addffbdb21d66e009a7c96f17c6dffd9f278fcefb62abb839a14f48be Transfer to Dorothy with TxHash Oxe413ee2dea27ac8d1ec281caff3f5235b098c28e38b7cdcae88455c571d2d3b0 Transfer to Ethan with TxHash 0x21cb2a2b8e714a23c12eac41b75a369da06afe8d3bcfa56acf3d68649a4874a1 <p>Now we can move on to creating our Squid to index the data on our local development node.</p>"},{"location":"tutorials/integrations/local-subsquid/#create-SQD-project","title":"Create a SQD Project","text":"<p>Now we're going to create our Subquid project. First, we'll need to install the SQD CLI:</p> <pre><code>npm i -g @subsquid/cli@latest\n</code></pre> <p>To verify successful installation, you can run:</p> <pre><code>sqd --version\n</code></pre> <p>Now we'll be able to use the <code>sqd</code> command to interact with our Squid project. To create our project, we're going to use the <code>--template</code> (<code>-t</code>) flag, which will create a project from a template. We'll be using the EVM Squid template, which is a starter project for indexing EVM chains.</p> <p>You can run the following command to create an EVM Squid named <code>local-squid</code>:</p> <pre><code>sqd init local-squid --template evm\n</code></pre> <p>This will create a Squid with all of the necessary dependencies. You can go ahead and install the dependencies:</p> <pre><code>cd local-squid &amp;&amp; npm ci\n</code></pre> <p>Now that we have a starting point for our project, we'll need to configure our project to index ERC-20 <code>Transfer</code> events from our local development node.</p>"},{"location":"tutorials/integrations/local-subsquid/#set-up-the-indexer-for-erc-20-transfer","title":"Set Up the Indexer for ERC-20 Transfers","text":"<p>In order to index ERC-20 transfers, we'll need to take a series of actions:</p> <ol> <li>Update the database schema and generate models for the data</li> <li>Use the <code>ERC20</code> contract's ABI to generate TypeScript interface classes that will be used by our Squid to index <code>Transfer</code> events</li> <li>Configure the processor to process <code>Transfer</code> events for the <code>ERC20</code> contract</li> <li>Add logic to process the <code>Transfer</code> events and save the processed transfer data</li> </ol> <p>As mentioned, we'll first need to define the database schema for the transfer data. To do so, we'll edit the <code>schema.graphql</code> file, which is located in the root directory, and create a <code>Transfer</code> entity and <code>Account</code> entity. You can copy and paste the below schema, ensuring that any existing schema is first removed.</p> schema.graphql <pre><code>type Account @entity {\n  \"Account address\"\n  id: ID!\n  transfersFrom: [Transfer!] @derivedFrom(field: \"from\")\n  transfersTo: [Transfer!] @derivedFrom(field: \"to\")\n}\n\ntype Transfer @entity {\n  id: ID!\n  blockNumber: Int!\n  timestamp: DateTime!\n  txHash: String!\n  from: Account!\n  to: Account!\n  amount: BigInt!\n}\n</code></pre> <p>Now we can generate the entity classes from the schema, which we'll use when we process the transfer data. This will create new classes for each entity in the <code>src/model/generated</code> directory.</p> <pre><code>sqd codegen\n</code></pre> <p>In the next step, we'll use the ERC-20 ABI to automatically generate TypeScript interface classes. Below is a generic ERC-20 standard ABI. Copy and paste it into a file named <code>erc20.json</code> in the <code>abi</code> folder at the root level of the project.</p> ERC-20 ABI <pre><code>[\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_from\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"decimals\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"name\": \"balance\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"payable\": true,\n    \"stateMutability\": \"payable\",\n    \"type\": \"fallback\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  }\n]\n</code></pre> <p>Next, we can use our contract's ABI to generate TypeScript interface classes. We can do this by running:</p> <pre><code>sqd typegen\n</code></pre> sqd typegen TYPEGEN 22:30:43 INFO sqd:evm-typegen saved src/abi/abi.support.ts 22:30:43 INFO sqd:evm-typegen saved src/abi/multicall.ts 22:30:43 INFO sqd:evm-typegen processing./abi/erc20.json 22:30:43 INFO sqd:evm-typegen saved src/abi/erc20.abi.ts 22:30:43 INFO sqd:evm-typegen saved src/abi/erc20.ts <p>This will generate the related TypeScript interface classes in the <code>src/abi/erc20.ts</code> file. For this tutorial, we'll be accessing the <code>events</code> specifically.</p>"},{"location":"tutorials/integrations/local-subsquid/#configure-the-processor","title":"Configure the Processor","text":"<p>The <code>processor.ts</code> file tells SQD exactly what data you'd like to ingest. Transforming that data into the exact desired format will take place at a later step. In <code>processor.ts</code>, we'll need to indicate a data source, a contract address, the event(s) to index, and a block range.</p> <p>Open up the <code>src</code> folder and head to the <code>processor.ts</code> file.</p> <p>To get started, you can import the ERC-20 ABI, which will be used to define the ERC-20 data to be indexed:</p> <pre><code>import * as erc20 from './abi/erc20';\n</code></pre> <p>Next, we need to tell the SQD processor which contract we're interested in. Create a constant for the address in the following manner:</p> <pre><code>export const contractAddress = 'INSERT_CONTRACT_ADDRESS'.toLowerCase();\n</code></pre> <p>The <code>.toLowerCase()</code> is critical because the SQD processor is case-sensitive, and some block explorers format contract addresses with capitalization. Next, you'll see the line <code>export const processor = new EvmBatchProcessor()</code>, followed by <code>.setDataSource</code>. We'll need to make a few changes here. SQD has available archives for many chains, including Moonbeam, Moonriver, and Moonbase Alpha that can speed up the data retrieval process. For indexing a local development node, there's no archive necessary so the exclusive data source will be the RPC URL of our local node. Go ahead and comment out or delete the archive line. Once done, your code should look similar to the below:</p> <pre><code>.setDataSource({\n  chain: {\n    url: assertNotNull('http://127.0.0.1:9944'),\n    rateLimit: 300,\n  },\n})\n</code></pre> <p>The Squid template comes with a variable for your RPC URL defined in your <code>.env</code> file. You can replace that with the RPC URL for your local development node. For demonstration purposes, the RPC URL for a local development node is hardcoded directly, as shown above. If you're setting the RPC URL in your <code>.env</code>, the respective line will look like this:</p> <pre><code>RPC_ENDPOINT=http://127.0.0.1:9944\n</code></pre> <p>Now, let's define the event that we want to index by adding the following:</p> <pre><code>.addLog({\n  address: [contractAddress],\n  topic0: [erc20.events.Transfer.topic],\n  transaction: true,\n})\n</code></pre> <p>The <code>Transfer</code> event is defined in <code>erc20.ts</code>, which was auto-generated when <code>sqd typegen</code> was run. The import <code>import * as erc20 from './abi/erc20'</code> is already included as part of the Squid EVM template.</p> <p>Block range is an important value to modify to narrow the scope of the blocks you're indexing. For example, if you launched your ERC-20 at block <code>1200000</code> on Moonbeam, there is no need to query the chain before that block for <code>Transfer</code> events. Since we're indexing a local node, this field can be excluded or set to 0. Setting an accurate block range will improve the performance of your indexer. You can set the earliest block to begin indexing in the following manner:</p> <pre><code>.setBlockRange({\n  from: 0, // Note the lack of quotes here\n});\n</code></pre> <p>The chosen start block here is 0 since we're indexing a local development node, but if you were indexing data on another Moonbeam network, you should change it to a starting block relevant to what you're indexing.</p> <p>Change the <code>setFields</code> section to specify the following data for our processor to ingest:</p> <pre><code>.setFields({\n  log: {\n    topics: true,\n    data: true,\n  },\n  transaction: {\n    hash: true,\n  },\n})\n</code></pre> <p>Once you've completed the prior steps, your <code>processor.ts</code> file should look similar to this:</p> processor.ts <pre><code>import { assertNotNull } from '@subsquid/util-internal';\nimport {\n  BlockHeader,\n  EvmBatchProcessor,\n  EvmBatchProcessorFields,\n  Log as _Log,\n  Transaction as _Transaction,\n} from '@subsquid/evm-processor';\nimport * as erc20 from './abi/erc20';\n\n// Here you'll need to import the contract\nexport const contractAddress =\n  '0xc01Ee7f10EA4aF4673cFff62710E1D7792aBa8f3'.toLowerCase();\n\nexport const processor = new EvmBatchProcessor()\n  .setDataSource({\n    chain: {\n      url: assertNotNull('http://127.0.0.1:9944'),\n      rateLimit: 300,\n    },\n  })\n  .setFinalityConfirmation(10)\n  .setFields({\n    log: {\n      topics: true,\n      data: true,\n    },\n    transaction: {\n      hash: true,\n    },\n  })\n  .addLog({\n    address: [contractAddress],\n    topic0: [erc20.events.Transfer.topic],\n    transaction: true,\n  })\n  .setBlockRange({\n    from: 0, // Note the lack of quotes here\n  });\n\nexport type Fields = EvmBatchProcessorFields&lt;typeof processor&gt;;\nexport type Block = BlockHeader&lt;Fields&gt;;\nexport type Log = _Log&lt;Fields&gt;;\nexport type Transaction = _Transaction&lt;Fields&gt;;\n</code></pre>"},{"location":"tutorials/integrations/local-subsquid/#transform-and-save-the-data","title":"Transform and Save the Data","text":"<p>While <code>processor.ts</code> determines the data being consumed, <code>main.ts</code> determines the bulk of actions related to processing and transforming that data. In the simplest terms, we are processing the data that was ingested via the SQD processor and inserting the desired pieces into a TypeORM database. For more detailed information on how SQD works, be sure to check out the SQD docs on Developing a Squid</p> <p>Our <code>main.ts</code> file is going to scan through each processed block for the <code>Transfer</code> event and decode the transfer details, including the sender, receiver, and amount. The script also fetches account details for involved addresses and creates transfer objects with the extracted data. The script then inserts these records into a TypeORM database enabling them to be easily queried.</p> <p>Let's break down the code that comprises <code>main.ts</code> in order:</p> <ol> <li>In <code>processor.run</code>, the processor will iterate through all of the selected blocks and look for <code>Transfer</code> event logs. Whenever it finds a <code>Transfer</code> event, it's going to store it in an array of <code>Transfer</code> events where it awaits further processing</li> <li>The <code>TransferEvent</code> interface is the type of structure that stores the data extracted from the event logs</li> <li><code>getTransfer</code> is a helper function that extracts and decodes ERC-20 <code>Transfer</code> event data from a log entry. It constructs and returns a <code>TransferEvent</code> object, which includes details such as the transaction ID, block number, sender and receiver addresses, and the amount transferred. <code>getTransfer</code> is called at the time of storing the relevant <code>Transfer</code> events into the array of transfers</li> <li><code>processTransfers</code> enriches the transfer data and then inserts these records into a TypeORM database using the <code>ctx.store</code> methods. The account model, while not strictly necessary, allows us to introduce another entity in the schema to demonstrate working with multiple entities in your Squid</li> <li><code>getAccount</code> is a helper function that manages the retrieval and creation of account objects. Given an account ID and a map of existing accounts, it returns the corresponding account object. If the account doesn't exist in the map, it creates a new one, adds it to the map, and then returns it</li> </ol> <p>We'll demo a sample query in a later section. You can copy and paste the below code into your <code>main.ts</code> file:</p> main.ts <pre><code>import { In } from 'typeorm';\nimport { assertNotNull } from '@subsquid/evm-processor';\nimport { TypeormDatabase } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\nimport { Account, Transfer } from './model';\nimport {\n  Block,\n  contractAddress,\n  Log,\n  Transaction,\n  processor,\n} from './processor';\n\n// 1. Iterate through all selected blocks and look for transfer events,\n// storing the relevant events in an array of transfer events\nprocessor.run(new TypeormDatabase({ supportHotBlocks: true }), async (ctx) =&gt; {\n  let transfers: TransferEvent[] = [];\n\n  for (let block of ctx.blocks) {\n    for (let log of block.logs) {\n      if (\n        log.address === contractAddress &amp;&amp;\n        log.topics[0] === erc20.events.Transfer.topic\n      ) {\n        transfers.push(getTransfer(ctx, log));\n      }\n    }\n  }\n\n  await processTransfers(ctx, transfers);\n});\n\n// 2. Define an interface to hold the data from the transfer events\ninterface TransferEvent {\n  id: string;\n  block: Block;\n  transaction: Transaction;\n  from: string;\n  to: string;\n  amount: bigint;\n}\n\n// 3. Extract and decode ERC-20 transfer event data from a log entry\nfunction getTransfer(ctx: any, log: Log): TransferEvent {\n  let event = erc20.events.Transfer.decode(log);\n\n  let from = event.from.toLowerCase();\n  let to = event.to.toLowerCase();\n  let amount = event.value;\n\n  let transaction = assertNotNull(log.transaction, `Missing transaction`);\n\n  return {\n    id: log.id,\n    block: log.block,\n    transaction,\n    from,\n    to,\n    amount,\n  };\n}\n\n// 4. Enrich and insert data into TypeORM database\nasync function processTransfers(ctx: any, transfersData: TransferEvent[]) {\n  let accountIds = new Set&lt;string&gt;();\n  for (let t of transfersData) {\n    accountIds.add(t.from);\n    accountIds.add(t.to);\n  }\n\n  let accounts = await ctx.store\n    .findBy(Account, { id: In([...accountIds]) })\n    .then((q: any[]) =&gt; new Map(q.map((i: any) =&gt; [i.id, i])));\n\n  let transfers: Transfer[] = [];\n\n  for (let t of transfersData) {\n    let { id, block, transaction, amount } = t;\n\n    let from = getAccount(accounts, t.from);\n    let to = getAccount(accounts, t.to);\n\n    transfers.push(\n      new Transfer({\n        id,\n        blockNumber: block.height,\n        timestamp: new Date(block.timestamp),\n        txHash: transaction.hash,\n        from,\n        to,\n        amount,\n      })\n    );\n  }\n\n  await ctx.store.upsert(Array.from(accounts.values()));\n  await ctx.store.insert(transfers);\n}\n\n// 5. Helper function to get account object\nfunction getAccount(m: Map&lt;string, Account&gt;, id: string): Account {\n  let acc = m.get(id);\n  if (acc == null) {\n    acc = new Account();\n    acc.id = id;\n    m.set(id, acc);\n  }\n  return acc;\n}\n</code></pre> <p>Now we've taken all of the steps necessary and are ready to run our indexer!</p>"},{"location":"tutorials/integrations/local-subsquid/#run-indexer","title":"Run the Indexer","text":"<p>To run our indexer, we're going to run a series of <code>sqd</code> commands, as follows:</p> <ol> <li> <p>Build our project</p> <pre><code>sqd build\n</code></pre> </li> <li> <p>Launch the database:</p> <pre><code>sqd up\n</code></pre> </li> <li> <p>Run the following two commands sequentially:</p> <pre><code>sqd migration:generate\nsqd migration:apply\n</code></pre> </li> <li> <p>Launch the processor:</p> <pre><code>sqd process\n</code></pre> </li> </ol> <p>Note</p> <p>You can review the <code>commands.json</code> file to see what each <code>sqd</code> command does under the hood.</p> <p>In your terminal, you should see your indexer starting to process blocks!</p> query: CREATE TABLE \"migrations\" (\"id\" SERIAL NOT NULL, \"timestamp\" bigint NOT NULL, \"name\" character varying NOT NULL, CONSTRAINT \"PK_8c82d7f526340ab734260ea46be\" PRIMARY KEY (\"id\")) query: SELECT * FROM \"migrations\" \"migrations\" ORDER BY \"id\" DESC 0 migrations are already loaded in the database. 1 migrations were found in the source code. 1 migrations are new migrations must be executed. query: START TRANSACTION query: CREATE TABLE \"transfer\" (\"id\" character varying NOT NULL, \"block_number\" integer NOT NULL, \"timestamp\" TIMESTAMP WITH TIME ZONE NOT NULL, \"tx_hash\" text NOT NULL, \"amount\" numeric NOT NULL, \"from_id\" character varying, \"to_id\" character varying, CONSTRAINT \"PK_fd9ddbdd49a17afcbe014401295\" PRIMARY KEY (\"id\")) query: CREATE INDEX \"ID_76bdfed1a7eb27c6d8ecbb7349\" ON \"transfer\" (\"from_id\") query: CREATE INDEX \"IDX_0751309c6697eac9ef1149362\" ON \"transfer\" (\"to_id\") query: CREATE TABLE \"account\" (\"id\" character varying NOT NULL, CONSTRAINT \"PK_54115ee388cdb6d86bb4bf5bZea\" PRIMARY KEY (\"id\")) query: ALTER TABLE \"transfer\" ADD CONSTRAINT \"FK_76bdfed1a7eb27c6d8ecbb73496\" FOREIGN KEY (\"from_id\") REFERENCES \"account\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION query: ALTER TABLE \"transfer\" ADD CONSTRAINT \"FK_0751309c66e97eac9ef11493623\" FOREIGN KEY (\"to_id\") REFERENCES \"account\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION query: INSERT INTO \"migrations\" (\"timestamp\", \"name\") VALUES ($1, $2) -- PARAMETERS: [1700202953250, \"Data1700202953250\"] Migration Data1700202953250 has been executed query: COMMIT  <p>If your Squid isn't indexing blocks properly, make sure that your development node is running with the <code>--sealing</code> flag. For this example, you should have set the flag as <code>--sealing 4000</code>, so that a block is produced every four seconds. You can feel free to edit the sealing interval as needed. Before you try to spin up your Squid again, run the following commands to restart your Squid:</p> <ol> <li> <p>Shut down your Squid</p> <pre><code>sqd down\n</code></pre> </li> <li> <p>Start your Squid back up:</p> <pre><code>sqd up\n</code></pre> </li> <li> <p>Start indexing again:</p> <pre><code>sqd process\n</code></pre> </li> </ol> <p>Now your indexer should be indexing your development node without any problems!</p>"},{"location":"tutorials/integrations/local-subsquid/#query-your-squid","title":"Query your Squid","text":"<p>To query your squid, open up a new terminal window within your project and run the following command:</p> <pre><code>sqd serve\n</code></pre> <p>And that's it! You can now run queries against your Squid on the GraphQL playground at <code>http://localhost:4350/graphql</code>. Try crafting your own GraphQL query, or use the below one:</p> Sample query <pre><code>query {\n  accounts {\n    id\n    transfersFrom {\n      id\n      blockNumber\n      timestamp\n      txHash\n      to {\n        id\n      }\n      amount\n    }\n    transfersTo {\n      id\n      blockNumber\n      timestamp\n      txHash\n      from {\n        id\n      }\n      amount\n    }\n  }\n}\n</code></pre> <p></p> <p>All of the transfers will be returned, including the transfer of the initial supply to Alith's account and the transfers from Alith to Baltathar, Charleth, Dorothy, and Ethan.</p> <p>And that's it! You've successfully used SQD to index data on a local Moonbeam development node! You can view the entire project on GitHub.</p>"},{"location":"tutorials/integrations/local-subsquid/#debug-your-squid","title":"Debug Your Squid","text":"<p>It may seem tricky at first to debug errors when building your Squid, but fortunately, there are several techniques you can use to streamline this process. First and foremost, if you're facing errors with your Squid, you should enable debug mode in your <code>.env</code> file by uncommenting the debug mode line. This will trigger much more verbose logging and will help you locate the source of the error.</p> <pre><code># Uncommenting the below line enables debug mode\nSQD_DEBUG=*\n</code></pre> <p>You can also add logging statements directly to your <code>main.ts</code> file to indicate specific parameters like block height and more. For example, see this version of <code>main.ts</code> which has been enhanced with detailed logging:</p> main.ts <pre><code>import { In } from 'typeorm';\nimport { assertNotNull } from '@subsquid/evm-processor';\nimport { TypeormDatabase } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\nimport { Account, Transfer } from './model';\nimport {\n  Block,\n  contractAddress,\n  Log,\n  Transaction,\n  processor,\n} from './processor';\n\nprocessor.run(new TypeormDatabase({ supportHotBlocks: true }), async (ctx) =&gt; {\n  ctx.log.info('Processor started');\n  let transfers: TransferEvent[] = [];\n\n  ctx.log.info(`Processing ${ctx.blocks.length} blocks`);\n  for (let block of ctx.blocks) {\n    ctx.log.debug(`Processing block number ${block.header.height}`);\n    for (let log of block.logs) {\n      ctx.log.debug(`Processing log with address ${log.address}`);\n      if (\n        log.address === contractAddress &amp;&amp;\n        log.topics[0] === erc20.events.Transfer.topic\n      ) {\n        ctx.log.info(`Transfer event found in block ${block.header.height}`);\n        transfers.push(getTransfer(ctx, log));\n      }\n    }\n  }\n\n  ctx.log.info(`Found ${transfers.length} transfers, processing...`);\n  await processTransfers(ctx, transfers);\n  ctx.log.info('Processor finished');\n});\n\ninterface TransferEvent {\n  id: string;\n  block: Block;\n  transaction: Transaction;\n  from: string;\n  to: string;\n  amount: bigint;\n}\n\nfunction getTransfer(ctx: any, log: Log): TransferEvent {\n  let event = erc20.events.Transfer.decode(log);\n\n  let from = event.from.toLowerCase();\n  let to = event.to.toLowerCase();\n  let amount = event.value;\n\n  let transaction = assertNotNull(log.transaction, `Missing transaction`);\n\n  ctx.log.debug(\n    `Decoded transfer event: from ${from} to ${to} amount ${amount.toString()}`\n  );\n  return {\n    id: log.id,\n    block: log.block,\n    transaction,\n    from,\n    to,\n    amount,\n  };\n}\n\nasync function processTransfers(ctx: any, transfersData: TransferEvent[]) {\n  ctx.log.info('Starting to process transfer data');\n  let accountIds = new Set&lt;string&gt;();\n  for (let t of transfersData) {\n    accountIds.add(t.from);\n    accountIds.add(t.to);\n  }\n\n  ctx.log.debug(`Fetching accounts for ${accountIds.size} addresses`);\n  let accounts = await ctx.store\n    .findBy(Account, { id: In([...accountIds]) })\n    .then((q: any[]) =&gt; new Map(q.map((i: any) =&gt; [i.id, i])));\n  ctx.log.info(\n    `Accounts fetched, processing ${transfersData.length} transfers`\n  );\n\n  let transfers: Transfer[] = [];\n\n  for (let t of transfersData) {\n    let { id, block, transaction, amount } = t;\n\n    let from = getAccount(accounts, t.from);\n    let to = getAccount(accounts, t.to);\n\n    transfers.push(\n      new Transfer({\n        id,\n        blockNumber: block.height,\n        timestamp: new Date(block.timestamp),\n        txHash: transaction.hash,\n        from,\n        to,\n        amount,\n      })\n    );\n  }\n\n  ctx.log.debug(`Upserting ${accounts.size} accounts`);\n  await ctx.store.upsert(Array.from(accounts.values()));\n  ctx.log.debug(`Inserting ${transfers.length} transfers`);\n  await ctx.store.insert(transfers);\n  ctx.log.info('Transfer data processing completed');\n}\n\nfunction getAccount(m: Map&lt;string, Account&gt;, id: string): Account {\n  let acc = m.get(id);\n  if (acc == null) {\n    acc = new Account();\n    acc.id = id;\n    m.set(id, acc);\n  }\n  return acc;\n}\n</code></pre> <p>See the SQD guide to logging for more information on debug mode.</p>"},{"location":"tutorials/integrations/local-subsquid/#common-errors","title":"Common Errors","text":"<p>Below are some common errors you may face when building a project and how you can solve them.</p> <pre><code>FATAL sqd:processor RpcError: Expect block number from id: BlockId::Number(15316)\n</code></pre> <p>This error indicates that your indexer is trying to process blocks that don't exist on your local node. You can resolve this by setting a relevant <code>to</code> block limit in your processor as follows:</p> <pre><code>.setBlockRange({from: 0, to: 100})\n</code></pre> <p>Another common error can occur when you're experimenting with multiple instances of SQD on your machine.</p> <pre><code>Error response from daemon: driver failed programming external connectivity on endpoint my-awesome-squid-db-1\n(49df671a7b0531abbb5dc5d2a4a3f5dc7e7505af89bf0ad1e5480bd1cdc61052):\nBind for 0.0.0.0:23798 failed: port is already allocated\n</code></pre> <p>This error indicates that you have another instance of SQD running somewhere else. You can stop that gracefully with the command <code>sqd down</code> or by pressing the Stop button next to the container in Docker Desktop.</p> <pre><code>Error: connect ECONNREFUSED 127.0.0.1:23798\n     at createConnectionError (node:net:1634:14)\n     at afterConnectMultiple (node:net:1664:40) {\n     errno: -61,code: 'ECONNREFUSED',syscall: 'connect',\n     address: '127.0.0.1',port: 23798}]}\n</code></pre> <p>To resolve this, run <code>sqd up</code> before you run <code>sqd migration:generate</code>.</p> <p>Is your Squid error-free, yet you aren't seeing any transfers detected? Make sure your log events are consistent and identical to the ones your processor is looking for. Your contract address also needs to be lowercase, which you can be assured of by defining it as follows:</p> <pre><code>export const contractAddress = '0x37822de108AFFdd5cDCFDaAa2E32756Da284DB85'.toLowerCase();\n</code></pre>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/integrations/nft-subsquid/","title":"Indexing NFT Transfers on Moonbeam with SQD (formerly Subsquid)","text":"<p>by Massimo Luraschi</p>"},{"location":"tutorials/integrations/nft-subsquid/#introduction","title":"Introduction","text":"<p>SQD (formerly Subsquid) is a data network that allows rapid and cost-efficient retrieval of blockchain data from 100+ chains using SQD's decentralized data lake and open-source SDK.</p> <p>The SDK offers a highly customizable Extract-Transform-Load-Query stack and indexing speeds of up to and beyond 50,000 blocks per second when indexing events and transactions.</p> <p>SQD has native and full support for the Ethereum Virtual Machine (EVM) and Substrate data. This allows developers to extract on-chain data from any of the Moonbeam networks, process EVM logs and Substrate entities (events, extrinsic, and storage items) in one single project, and serve the resulting data with one single GraphQL endpoint. With SQD, filtering by EVM topic, contract address, and block range are all possible.</p> <p>This guide will explain how to create a SQD project (also known as a \"Squid\") from a template (indexing Moonsama transfers on Moonriver) and change it to index ERC-721 token transfers on the Moonbeam network. As such, you'll be looking at the <code>Transfer</code> EVM event topics. This guide can be adapted for Moonbase Alpha as well.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tutorials/integrations/nft-subsquid/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For a Squid project to be able to run, you need to have the following installed:</p> <ul> <li>Familiarity with Git</li> <li>Node.js version 16 or later</li> <li>Docker</li> <li>Squid CLI</li> </ul>"},{"location":"tutorials/integrations/nft-subsquid/#scaffolding-using-sqd-init","title":"Scaffold a Project From a Template","text":"<p>We will start with the <code>frontier-evm</code> squid template, available through <code>sqd init</code>. It is built to index EVM smart contracts deployed on Moonriver, but it can also index Substrate events. To retrieve the template and install the dependencies, run the following:</p> <pre><code>sqd init moonbeam-tutorial --template frontier-evm\ncd moonbeam-tutorial\nnpm ci\n</code></pre>"},{"location":"tutorials/integrations/nft-subsquid/#define-entity-schema","title":"Define the Entity Schema","text":"<p>Next, we ensure the Squid's data schema defines the entities that we want to track. We are interested in:</p> <ul> <li>Token transfers</li> <li>Ownership of tokens</li> <li>Contracts and their minted tokens</li> </ul> <p>The EVM template already contains a schema file that defines <code>Token</code> and <code>Transfer</code> entities, but we need to modify it for our use case and add <code>Owner</code> and <code>Contract</code> entities:</p> schema.graphql<pre><code>type Token @entity {\n  id: ID!\n  owner: Owner\n  uri: String\n  transfers: [Transfer!]! @derivedFrom(field: \"token\")\n  contract: Contract\n}\n\ntype Owner @entity {\n  id: ID!\n  ownedTokens: [Token!]! @derivedFrom(field: \"owner\")\n}\n\ntype Contract @entity {\n  id: ID!\n  name: String\n  symbol: String\n  totalSupply: BigInt\n  mintedTokens: [Token!]! @derivedFrom(field: \"contract\")\n}\n\ntype Transfer @entity {\n  id: ID!\n  token: Token!\n  from: Owner\n  to: Owner\n  timestamp: BigInt\n  block: BigInt!\n}\n</code></pre> <p>It's worth noting a couple of things in this schema definition:</p> <ul> <li><code>@entity</code> - signals that this type will be translated into an ORM model that is going to be persisted in the database</li> <li><code>@derivedFrom</code> - signals that the field will not be persisted in the database. Instead, it will be derived from the entity relations</li> <li>type references (e.g., <code>owner: Owner</code>) - when used on entity types, they establish a relation between two entities</li> </ul> <p>TypeScript entity classes have to be regenerated whenever the schema is changed, and to do that, we use the <code>squid-typeorm-codegen</code> tool. The pre-packaged <code>commands.json</code> already comes with a <code>codegen</code> shortcut, so we can invoke it with <code>sqd</code>:</p> <pre><code>sqd codegen\n</code></pre> <p>The generated entity classes can then be browsed in the <code>src/model/generated</code> directory. Each entity should have a\u00a0<code>.model.ts</code>\u00a0file.</p>"},{"location":"tutorials/integrations/nft-subsquid/#abi-definition","title":"ABI Definition and Type Generation","text":"<p>SQD maintains tools for the automated generation of TypeScript classes to handle Substrate data sources (events, extrinsics, storage items). Possible runtime upgrades are automatically detected and accounted for.</p> <p>Similar functionality is available for EVM indexing through the <code>squid-evm-typegen</code> tool. It generates TypeScript modules for handling EVM logs and transactions based on a JSON ABI of the contract.</p> <p>We will need such a module for the ERC-721-compliant part of the contracts' interfaces for our squid. Once again, the template repository already includes it, but it is still important to explain what needs to be done in case one wants to index a different type of contract.</p> <p>The procedure uses a <code>sqd</code> script from the template that uses <code>squid-evm-typegen</code> to generate Typescript facades for JSON ABIs stored in the <code>abi</code> folder. Place any ABIs you require for interfacing your contracts there and run:</p> <pre><code>sqd typegen:evm\n</code></pre> <p>The results will be stored at <code>src/abi</code>. One module will be generated for each ABI file, including constants useful for filtering, functions for decoding EVM events, and functions defined in the ABI.</p>"},{"location":"tutorials/integrations/nft-subsquid/#define-event-handlers","title":"Processor Object and the Batch Handler","text":"<p>SQD SDK provides users with the <code>SubstrateBatchProcessor</code> class. The <code>SubstrateBatchProcessor</code> declaration and configurations are in the <code>src/processor.ts</code> file. Its instances connect to SQD Network gateways at chain-specific URLs to get chain data and apply custom transformations. The indexing begins at the starting block and keeps up with new blocks after reaching the tip.</p> <p>The <code>SubstrateBatchProcessor</code> exposes methods to \"subscribe\" to specific data such as Substrate events, extrinsics, storage items, or, for EVM, logs, and transactions. The actual data processing is then started by calling the <code>.run()</code> function, as seen in the <code>src/main.ts</code> file. This will start generating requests to the gateway for batches of data specified in the configuration and will trigger the callback function every time a batch is returned by the gateway.</p> <p>This callback function expresses all the mapping logic. This is where chain data decoding should be implemented and where the code to save processed data on the database should be defined.</p>"},{"location":"tutorials/integrations/nft-subsquid/#managing-the-evm-contracts","title":"Manage the EVM Contracts","text":"<p>Before we begin defining the mapping logic of the Squid, we will write a <code>src/contracts.ts</code> utility module to manage the involved EVM contracts. It will export:</p> <ul> <li>Addresses of Exiled Racers Pilots and Exiled Racers Racecrafts</li> <li>A <code>Map</code> from the contract addresses to hardcoded <code>Contract</code> entity instances</li> </ul> <p>Now, let's take a look at the complete contents of the file:</p> src/contracts.ts<pre><code>import { Contract } from './model';\n\nexport const pilots =\n  '0x515e20e6275CEeFe19221FC53e77E38cc32b80Fb'.toLowerCase();\nexport const racecrafts =\n  '0x104b904e19fBDa76bb864731A2C9E01E6b41f855'.toLowerCase();\n\nexport const contractMapping: Map&lt;string, Contract&gt; = new Map();\n\n// Create a Contract entity object for the Exiled Racers Pilot contract\ncontractMapping.set(\n  pilots,\n  new Contract({\n    id: pilots,\n    name: 'Exiled Racers Pilot',\n    symbol: 'EXRP',\n    totalSupply: 1729n,\n    mintedTokens: [],\n  })\n);\n\n// Create a Contract entity object for the Exiled Racers Racecraft contract\ncontractMapping.set(\n  racecrafts,\n  new Contract({\n    id: racecrafts,\n    name: 'Exiled Racers Racecraft',\n    symbol: 'EXRR',\n    totalSupply: 1617n,\n    mintedTokens: [],\n  })\n);\n</code></pre>"},{"location":"tutorials/integrations/nft-subsquid/#configure-processor","title":"Configure the Processor","text":"<p>In the <code>src/processor.ts</code> file, Squids instantiate the processor (a <code>SubstrateBatchProcessor</code> in our case) and configure it.</p> <p>We adapt the template code to process EVM logs for the two Exiled Racers contracts and point the processor data source setting to the Moonbeam SQD Network gateway URL. Here is the result:</p> src/processor.ts<pre><code>import { assertNotNull } from '@subsquid/util-internal';\nimport {\n  BlockHeader,\n  DataHandlerContext,\n  SubstrateBatchProcessor,\n  SubstrateBatchProcessorFields,\n  Event as _Event,\n  Call as _Call,\n  Extrinsic as _Extrinsic,\n} from '@subsquid/substrate-processor';\nimport * as erc721 from './abi/erc721';\nimport { pilots, racecrafts } from './contracts';\n\nexport const processor = new SubstrateBatchProcessor()\n  .setBlockRange({ from: 1250496 })\n  .setGateway('https://v2.archive.subsquid.io/network/moonbeam-substrate')\n  .setRpcEndpoint({\n    url: assertNotNull(process.env.RPC_ENDPOINT), // TODO: Add the RPC URL to your .env file\n    rateLimit: 10,\n  })\n  // Filter Transfer events from the Exiled Racers Pilot contract\n  .addEvmLog({\n    address: [pilots],\n    range: { from: 1250496 }, // Block of the first transfer\n    topic0: [erc721.events.Transfer.topic],\n  })\n  // Filter Transfer events from the Exiled Racers Racecraft contract\n  .addEvmLog({\n    address: [racecrafts],\n    range: { from: 1398762 }, // Block of the first transfer\n    topic0: [erc721.events.Transfer.topic],\n  })\n  // The timestamp is not provided unless we explicitly request it\n  .setFields({\n    block: {\n      timestamp: true,\n    },\n  });\n\nexport type Fields = SubstrateBatchProcessorFields&lt;typeof processor&gt;;\nexport type Block = BlockHeader&lt;Fields&gt;;\nexport type Event = _Event&lt;Fields&gt;;\nexport type Call = _Call&lt;Fields&gt;;\nexport type Extrinsic = _Extrinsic&lt;Fields&gt;;\nexport type ProcessorContext&lt;Store&gt; = DataHandlerContext&lt;Store, Fields&gt;;\n</code></pre> <p>If you are adapting this guide for Moonbase Alpha, be sure to update the data source to the correct network:</p> <pre><code>'https://v2.archive.subsquid.io/network/moonbase-substrate'\n</code></pre> <p>Note</p> <p>This code expects to find a working Moonbeam RPC URL in the <code>RPC_ENDPOINT</code> environment variable. You can get your own endpoint and API key from a supported Endpoint Provider.</p> <p>Set it in the <code>.env</code> file and SQD Cloud secrets if and when you deploy your Squid there. We tested the code using a public endpoint at\u00a0<code>wss://wss.api.moonbeam.network</code>; we recommend using\u00a0private endpoints for production.</p>"},{"location":"tutorials/integrations/nft-subsquid/#define-batch-handler","title":"Define the Batch Handler","text":"<p>We'll need to rewrite the batch handler logic in the <code>src/main.ts</code> file.  We'll iterate over all of the events for each batch of blocks to find the EVM logs relative to the Exiled Racers contracts. We'll extract the from and to addresses and the token ID from the EVM logs. Then, we'll format this data as defined in the schema and save it to the database.</p> <p>Here is the result:</p> src/main.ts<pre><code>import { Store, TypeormDatabase } from '@subsquid/typeorm-store';\nimport { In } from 'typeorm';\nimport { contractMapping, pilots, racecrafts } from './contracts';\nimport { Owner, Token, Transfer } from './model';\nimport * as erc721 from './abi/erc721';\nimport { processor, ProcessorContext, Event, Block } from './processor';\nimport { getEvmLog } from '@subsquid/frontier';\n\nlet contractsSaved = false;\n\nprocessor.run(new TypeormDatabase(), async (ctx) =&gt; {\n  const transfersData: TransferData[] = [];\n\n  for (const block of ctx.blocks) {\n    for (const event of block.events) {\n      // If the event is an EVM log and the contract address emitting the log is\n      // from the Exiled Racers Pilots or Racecrafts contracts, process the logs\n      if (event.name === 'EVM.Log') {\n        if (event.args.address) {\n          if (\n            event.args.address.toLowerCase() == pilots ||\n            event.args.address.toLowerCase() == racecrafts\n          ) {\n            // For each event, get the transfer data\n            const transfer = handleTransfer(block.header, event);\n            transfersData.push(transfer);\n          }\n        }\n      }\n    }\n  }\n\n  // Save the contract addresses if they haven't already been saved. This will \n  // only need to happen once, so that is why the contractsSaved flag is used\n  if (!contractsSaved) {\n    await ctx.store.upsert([...contractMapping.values()]);\n    contractsSaved = true;\n  }\n  await saveTransfers(ctx, transfersData);\n});\n\ntype TransferData = {\n  id: string;\n  from: string;\n  to: string;\n  token: bigint;\n  timestamp?: bigint;\n  block: number;\n  contractAddress: string;\n};\n\nfunction handleTransfer(block: Block, event: Event): TransferData {\n  // Decode the event log into an EVM log\n  const evmLog = getEvmLog(event);\n  // Decode the EVM log to get the from and to addresses and the token ID\n  const { from, to, tokenId } = erc721.events.Transfer.decode(evmLog);\n\n  return {\n    id: event.id,\n    from,\n    to,\n    token: tokenId,\n    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,\n    block: block.height,\n    contractAddress: event.args.address,\n  };\n}\n\nasync function saveTransfers(\n  ctx: ProcessorContext&lt;Store&gt;,\n  transfersData: TransferData[]\n) {\n  // Format the token ID in SYMBOL-ID format\n  const getTokenId = (transferData: TransferData) =&gt;\n    `${\n      contractMapping.get(transferData.contractAddress)?.symbol ?? ''\n    }-${transferData.token.toString()}`;\n\n  const tokensIds: Set&lt;string&gt; = new Set();\n  const ownersIds: Set&lt;string&gt; = new Set();\n\n  // Iterate over the transfers data to get the token IDs and owners\n  for (const transferData of transfersData) {\n    tokensIds.add(getTokenId(transferData));\n    ownersIds.add(transferData.from);\n    ownersIds.add(transferData.to);\n  }\n\n  // Use the token IDs and owners to check the database for existing entries \n  const tokens: Map&lt;string, Token&gt; = new Map(\n    (await ctx.store.findBy(Token, { id: In([...tokensIds]) })).map((token) =&gt; [\n      token.id,\n      token,\n    ])\n  );\n\n  const owners: Map&lt;string, Owner&gt; = new Map(\n    (await ctx.store.findBy(Owner, { id: In([...ownersIds]) })).map((owner) =&gt; [\n      owner.id,\n      owner,\n    ])\n  );\n\n  const transfers: Set&lt;Transfer&gt; = new Set();\n\n  // Process and format all of the data to save to the database\n  for (const transferData of transfersData) {\n    // Create a contract instance, which will be used to query the\n    // contract's tokenURI function below\n    const contract = new erc721.Contract(\n      ctx,\n      { height: transferData.block },\n      transferData.contractAddress\n    );\n\n    // Try to get the from address from the owners pulled from the database\n    let from = owners.get(transferData.from);\n    // If there isn't an existing entry for this owner, create one\n    if (from == null) {\n      from = new Owner({ id: transferData.from });\n      owners.set(from.id, from);\n    }\n\n    // Try to get the to address from the owners pulled from the database\n    let to = owners.get(transferData.to);\n    // If there isn't an existing entry for this owner, create one\n    if (to == null) {\n      to = new Owner({ id: transferData.to });\n      owners.set(to.id, to);\n    }\n\n    const tokenId = getTokenId(transferData);\n    // Try to get the tokenId from the tokens pulled from the database\n    let token = tokens.get(tokenId);\n    // If there isn't an existing entry for this token, create one\n    if (token == null) {\n      token = new Token({\n        id: tokenId,\n        uri: await contract.tokenURI(transferData.token),\n        contract: contractMapping.get(transferData.contractAddress),\n      });\n      tokens.set(token.id, token);\n    }\n\n    // Now that the owner entity has been created, we can establish\n    // the connection between the Owner and the Token\n    token.owner = to;\n\n    // Since the Owner and Token entity objects have been created,\n    // the last step is to create the Transfer entity object\n    const { id, block, timestamp } = transferData;\n    const transfer = new Transfer({\n      id,\n      block: BigInt(block),\n      timestamp,\n      from,\n      to,\n      token,\n    });\n\n    transfers.add(transfer);\n  }\n\n  // Save all of the data from this batch to the database\n  await ctx.store.upsert([...owners.values()]);\n  await ctx.store.upsert([...tokens.values()]);\n  await ctx.store.insert([...transfers]);\n}\n</code></pre> <p>Note</p> <p>The <code>contract.tokenURI</code> call accesses the state of the contract via a chain RPC endpoint. This can slow down indexing, but this data is only available in this way. You'll find more information on accessing state in the dedicated section of the SQD docs.</p>"},{"location":"tutorials/integrations/nft-subsquid/#launch-database","title":"Launch and Set Up the Database","text":"<p>Squid projects automatically manage the database connection and schema via an ORM abstraction. In this approach, the schema is managed through migration files. Because we made changes to the schema, we need to remove the existing migration(s), create a new one, and then apply the new migration.</p> <p>This involves the following steps:</p> <ol> <li> <p>Make sure you start with a clean Postgres database. The following commands drop-create a new Postgres instance in Docker:</p> <pre><code>sqd down\nsqd up\n</code></pre> </li> <li> <p>Generate the new migration (this will wipe any old migrations):</p> <pre><code>sqd migration:generate\n</code></pre> <p>Note</p> <p>This command runs the following commands:</p> <ul> <li><code>clean</code> - deletes all the build artifacts</li> <li><code>build</code> - creates a fresh build of the project</li> <li><code>migration:clean</code> - cleans the migration folder</li> <li><code>migration:generate</code> - generates a database migration matching the TypeORM entities</li> </ul> </li> </ol> <p>When you launch the processor in the next section, your migrations will be applied automatically. However, if you need to apply them manually, you can do so using the <code>sqd migration:apply</code> command.</p>"},{"location":"tutorials/integrations/nft-subsquid/#launch-project","title":"Launch the Project","text":"<p>To launch the processor, run the following command (this will block the current terminal):</p> <pre><code>sqd process\n</code></pre> <p>Note</p> <p>This command runs the following commands:</p> <ul> <li><code>clean</code> - deletes all the build artifacts</li> <li><code>build</code> - creates a fresh build of the project</li> <li><code>migration:apply</code> - applies the database migrations</li> </ul> <p>Finally, in a separate terminal window, launch the GraphQL server:</p> <pre><code>sqd serve\n</code></pre> <p>Visit <code>http://localhost:4350/graphql</code> to access the GraphiQL console. From this window, you can perform queries such as this one to fetch a batch of owners:</p> <pre><code>query MyQuery {\n  owners(limit: 10) {\n    id\n  }\n}\n</code></pre> <p>Or this other one, looking up the tokens owned by a given owner:</p> <pre><code>query MyQuery {\n  tokens(where: {owner: {id_eq: \"0x09534CF342ad376DdBA6C3e94490C3f161F42ed2\"}}) {\n    uri\n    contract {\n      id\n      name\n      symbol\n      totalSupply\n    }\n  }\n}\n</code></pre> <p>Have fun playing around with queries; after all, it's a playground!</p>"},{"location":"tutorials/integrations/nft-subsquid/#publish-the-project","title":"Publish the Project","text":"<p>SQD offers a SaaS solution to host projects created by its community. All templates ship with a deployment manifest file named\u00a0<code>squid.yml</code>, which can be used with the Squid CLI command\u00a0<code>sqd deploy</code>.</p> <p>Please refer to the SQD Cloud Quickstart page on SQD's documentation site for more information.</p>"},{"location":"tutorials/integrations/nft-subsquid/#example-project-repository","title":"Example Project Repository","text":"<p>You can view the template used here and many other example repositories on SQD's examples organization on GitHub.</p> <p>SQD's documentation contains informative material, and it's the best place to start if you are curious about some aspects that were not fully explained in this guide.</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/integrations/supra/","title":"Fetching Price Data with Supra Oracles","text":""},{"location":"tutorials/integrations/supra/#introduction","title":"Introduction","text":"<p>Oracles play a crucial role in blockchain ecosystems by facilitating the interaction between smart contracts and external data sources.</p> <p>Supra Oracles is one Oracle service provider that enables you to retrieve price data from external services and feed it to smart contracts to validate the accuracy of such data and publish it on-chain. Supra achieves this flow using a pull model that fetches price data as needed.</p> <p>In this guide, you'll learn about Supra's pull model and how to use their price feeds to fetch price data in smart contracts on Moonbeam.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tutorials/integrations/supra/#pull-model","title":"An Overview of Supra's V1 Pull Model","text":"<p>Supra uses a pull model as a customized approach that publishes price data upon request. It combines Web2 and Web3 methods to achieve low latency when sending data from Supra to destination chains. The process involves the following steps:</p> <ol> <li>Web2 methods are used to retrieve price data from Supra</li> <li>Smart contracts are utilized for cryptographically verifying and writing the latest price data on-chain, where it lives on immutable ledgers, using Supra's Pull contract</li> <li>Once the data has been written on-chain, the most recently published price feed data will be available in Supra's Storage contract</li> </ol> <p>You can fetch price data from Supra for any available data pairs.</p> <p>The addresses for Supra's contracts on Moonbeam are as follows:</p> MoonbeamMoonbase Alpha Contract Address Pull Oracle 0x2FA6DbFe4291136Cf272E1A3294362b6651e8517 Storage 0xD02cc7a670047b6b012556A88e275c685d25e0c9 Contract Address Pull Oracle 0xaa2f56843Cec7840F0C106F0202313d8d8CB13d6 Storage 0x4591d1B110ad451d8220d82252F829E8b2a91B17 <p>Note</p> <p>Moonriver is not supported at this time.</p>"},{"location":"tutorials/integrations/supra/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this guide, you will need:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"tutorials/integrations/supra/#web2-retrieve-price-data","title":"Use Web2 Code to Retrieve Price Data","text":"<p>To build out the Web2 component required to fetch price data from Supra, you can use their Pull Service Client library, designed to interact with a gRPC server to fetch price data. gRPC is a modern remote procedure call (RPC) framework created by Google. You can check out the gRPC documentation for more information if you need to familiarize yourself.</p> <p>The library offers JavaScript or Rust-based clients for EVM, Sui, and Aptos-based chains. For Moonbeam, you can use the JavaScript or Rust-based EVM client. We'll use the JavaScript client.</p> <p>We'll copy the JavaScript client code and add it to our project, but you can also clone the repository with all the clients.</p>"},{"location":"tutorials/integrations/supra/#create-a-project","title":"Create a Project","text":"<p>Follow these steps to create your project:</p> <ol> <li> <p>Create an empty project directory</p> <pre><code>mkdir moonbeam-supra\n</code></pre> </li> <li> <p>Create a basic <code>package.json</code> file for your project</p> <pre><code>cd moonbeam-supra &amp;&amp; npm init-y\n</code></pre> </li> <li> <p>Install dependencies needed to work with Supra's gRPC server</p> <pre><code>npm install @grpc/grpc-js @grpc/proto-loader\n</code></pre> </li> </ol>"},{"location":"tutorials/integrations/supra/#create-pull-service-client","title":"Create the Pull Service Client","text":"<p>To create the pull service client, you'll need to create two files: one that defines the schema for the gRPC service, <code>client.proto</code>, and another that relies on the schema and is used to fetch the proof for a given data pair, <code>pullServiceClient.js</code>.</p> <p>You can create both files using the following command:</p> <pre><code>touch client.proto pullServiceClient.js\n</code></pre> <p>Then, you can copy the following code snippets and add them to their respective files:</p> Pull service client files client.protopullServiceClient.js <pre><code>syntax = \"proto3\";\n\npackage pull_service;\n\nmessage PullResponse {\n  oneof resp {\n    PullResponseEvm evm = 1;\n    PullResponseSui sui = 2;\n    PullResponseAptos aptos = 3;\n  }\n}\n\nservice PullService {\n  rpc GetProof(PullRequest) returns (PullResponse);\n}\n\nmessage PullRequest {\n  repeated uint32 pair_indexes = 1;\n  string chain_type = 2;\n}\n\nmessage PullResponseEvm {\n  repeated uint32 pair_indexes = 1;\n  bytes proof_bytes = 2;\n}\n</code></pre> <pre><code>const grpc = require('@grpc/grpc-js');\nconst protoLoader = require('@grpc/proto-loader');\n\nclass PullServiceClient {\n  constructor(address) {\n    var PROTO_PATH = __dirname + './client.proto';\n    const packageDefinition = protoLoader.loadSync(PROTO_PATH, {\n      keepCase: true,\n      longs: String,\n      enums: String,\n      defaults: true,\n      oneofs: true,\n    });\n\n    const pullProto =\n      grpc.loadPackageDefinition(packageDefinition).pull_service;\n    this.client = new pullProto.PullService(\n      address,\n      grpc.credentials.createSsl()\n    );\n  }\n\n  getProof(request, callback) {\n    this.client.getProof(request, callback);\n  }\n}\n\nmodule.exports = PullServiceClient;\n</code></pre>"},{"location":"tutorials/integrations/supra/#use-the-pull-service-client","title":"Use the Pull Service Client to Fetch Price Data","text":"<p>In this section, you'll create an instance of the <code>PullServiceClient</code> to retrieve the proof for the ETH_USDT pair. You can modify this example for any of the available data pairs.</p> <p>To get started, create a file to add our logic:</p> <pre><code>touch main.js\n</code></pre> <p>In the <code>main.js</code> file, take the following steps to add the logic for retrieving proof data:</p> <ol> <li> <p>Import the <code>PullServiceClient</code> from the <code>pullServiceClient.js</code> file</p> main.js<pre><code>const PullServiceClient = require('./pullServiceClient');\n</code></pre> </li> <li> <p>Create a variable to store the index of the data pair for which you want to retrieve the price data. This example requests the ETH_USDT data pair, but you can use the index of any available data pair</p> main.js<pre><code>const PullServiceClient = require('./pullServiceClient');\n\nconst pairIndex = 1;\n</code></pre> </li> <li> <p>Create a <code>getProofs</code> function, where you'll add all the logic</p> main.js<pre><code>const getProofs = () =&gt; {\n  // Add logic\n};\n</code></pre> </li> <li> <p>In the <code>getProofs</code> function, you can define the address for the gRPC server and use it to create an instance of the <code>PullServiceClient</code>. Supra has one address for MainNets, <code>'mainnet-dora.supraoracles.com'</code> and one for TestNets, <code>'testnet-dora.supraoracles.com'</code></p> MoonbeamMoonbase Alpha main.js<pre><code>const getProofs = () =&gt; {\n  const address = 'mainnet-dora.supraoracles.com';\n  const client = new PullServiceClient(address);\n};\n</code></pre> main.js<pre><code>const getProofs = () =&gt; {\n  const address = 'testnet-dora.supraoracles.com';\n  const client = new PullServiceClient(address);\n};\n</code></pre> </li> <li> <p>To request data from the client, first, you need to define the data you want to request</p> main.js<pre><code>const getProofs = () =&gt; {\n  // ...\n  const request = {\n    pair_indexes: [pairIndex], // ETH_USDT\n    chain_type: 'evm',\n  };\n};\n</code></pre> </li> <li> <p>Now you can request the proof for the data pair(s) by calling the <code>getProof</code> method of the Pull Service Client</p> main.js<pre><code>const getProofs = () =&gt; {\n  // ...\n  return new Promise((resolve, reject) =&gt; {\n    client.getProof(request, (err, response) =&gt; {\n      if (err) {\n        console.error('Error:', err.details);\n        return;\n      }\n      resolve(response);\n    });\n  });\n};\n</code></pre> </li> <li> <p>Create a <code>main</code> function that calls the <code>getProofs</code> function and saves the proofs to be consumed in later steps</p> main.js<pre><code>const main = async () =&gt; {\n  const proofs = await getProofs();\n};\n\nmain();\n</code></pre> </li> </ol> main.js MoonbeamMoonbase Alpha <pre><code>const PullServiceClient = require('./pullServiceClient');\n\nconst pairIndex = 1;\n\n// Function that fetches proof data from the gRPC server using the specified parameters\nconst getProofs = () =&gt; {\n  const address = 'mainnet-dora.supraoracles.com';\n  const client = new PullServiceClient(address);\n\n  const request = {\n    pair_indexes: [pairIndex], // ETH_USDT\n    chain_type: 'evm',\n  };\n\n  return new Promise((resolve, reject) =&gt; {\n    client.getProof(request, (err, response) =&gt; {\n      if (err) {\n        console.error('Error:', err.details);\n        return;\n      }\n      resolve(response);\n    });\n  });\n};\n\nconst main = async () =&gt; {\n  const proofs = await getProofs();\n};\n\nmain();\n</code></pre> <pre><code>const PullServiceClient = require('./pullServiceClient');\n\nconst pairIndex = 1;\n\n// Function that fetches proof data from the gRPC server using the specified parameters\nconst getProofs = () =&gt; {\n  const address = 'testnet-dora.supraoracles.com';\n  const client = new PullServiceClient(address);\n\n  const request = {\n    pair_indexes: [pairIndex], // ETH_USDT\n    chain_type: 'evm',\n  };\n\n  return new Promise((resolve, reject) =&gt; {\n    client.getProof(request, (err, response) =&gt; {\n      if (err) {\n        console.error('Error:', err.details);\n        return;\n      }\n      resolve(response);\n    });\n  });\n};\n\nconst main = async () =&gt; {\n  const proofs = await getProofs();\n};\n\nmain();\n</code></pre> <p>So far, you have the logic required to retrieve proofs for data pairs. The proofs are bytes of data that are not human-readable, but you can follow the steps in the next section to deserialize the data into human-readable formats. This step is optional, so you can skip ahead to verify the proofs and write the price data on-chain.</p>"},{"location":"tutorials/integrations/supra/#deserialize-proofs","title":"Deserialize the Proofs","text":"<p>If you want to deserialize the data to read the latest price data you've retrieved, you can use the interfaces for the proof data and the signed coherent cluster data.</p> <p>Coherent cluster data is a set of values where all the values in that set agree. This is a component of Supra's DORA (Distributed Oracle Agreement) protocol, which, in its simplest form, is a protocol that aggregates a set of data into a single representative value. If you want to dive deeper, check out the DORA litepaper.</p> <p>You'll need to create a file for each interface, which you can store in a <code>resources</code> directory:</p> <pre><code>mkdir resources &amp;&amp; touch resources/oracleProof.json resources/signedCoherentCluster.json\n</code></pre> <p>Then, you can copy the following code snippets and add them to their respective files:</p> Interface files oracleProof.jsonsignedCoherentCluster.json <pre><code>[\n    {\n        \"type\": \"tuple\",\n        \"name\": \"OracleProof\",\n        \"components\": [\n            {\n                \"type\": \"tuple[]\",\n                \"name\": \"votes\",\n                \"components\": [\n                    {\n                        \"type\": \"tuple\",\n                        \"name\": \"smrBlock\",\n                        \"components\": [\n                            { \"type\": \"uint64\", \"name\": \"round\" },\n                            { \"type\": \"uint128\", \"name\": \"timestamp\" },\n                            { \"type\": \"bytes32\", \"name\": \"author\" },\n                            { \"type\": \"bytes32\", \"name\": \"qcHash\" },\n                            { \"type\": \"bytes32[]\", \"name\": \"batchHashes\" }\n                        ]\n                    },\n                    { \"type\": \"bytes8\", \"name\": \"roundLE\" }\n                ]\n            },\n            { \"type\": \"uint256[2][]\", \"name\": \"sigs\" },\n            {\n                \"type\": \"tuple[]\",\n                \"name\": \"smrBatches\",\n                \"components\": [\n                    { \"type\": \"bytes10\", \"name\": \"protocol\" },\n                    { \"type\": \"bytes32[]\", \"name\": \"txnHashes\" },\n                    { \"type\": \"uint256\", \"name\": \"batchIdx\" }\n                ]\n            },\n            {\n                \"type\": \"tuple[]\",\n                \"name\": \"smrTxns\",\n                \"components\": [\n                    { \"type\": \"bytes32[]\", \"name\": \"clusterHashes\" },\n                    { \"type\": \"bytes32\", \"name\": \"sender\" },\n                    { \"type\": \"bytes10\", \"name\": \"protocol\" },\n                    { \"type\": \"bytes1\", \"name\": \"tx_sub_type\" },\n                    { \"type\": \"uint256\", \"name\": \"txnIdx\" }\n                ]\n            },\n            { \"type\": \"bytes[]\", \"name\": \"clustersRaw\" },\n            { \"type\": \"uint256[]\", \"name\": \"batchToVote\" },\n            { \"type\": \"uint256[]\", \"name\": \"txnToBatch\" },\n            { \"type\": \"uint256[]\", \"name\": \"clusterToTxn\" },\n            { \"type\": \"uint256[]\", \"name\": \"clusterToHash\" },\n            { \"type\": \"bool[]\", \"name\": \"pairMask\" },\n            { \"type\": \"uint256\", \"name\": \"pairCnt\" }\n        ]\n    }\n]\n</code></pre> <pre><code>[\n    {\n        \"type\": \"tuple\",\n        \"name\": \"scc\",\n        \"components\": [\n            {\n                \"type\": \"tuple\",\n                \"name\": \"cc\",\n                \"components\": [\n                    { \"type\": \"bytes32\", \"name\": \"dataHash\" },\n                    { \"type\": \"uint256[]\", \"name\": \"pair\" },\n                    { \"type\": \"uint256[]\", \"name\": \"prices\" },\n                    { \"type\": \"uint256[]\", \"name\": \"timestamp\" },\n                    { \"type\": \"uint256[]\", \"name\": \"decimals\" }\n                ]\n            },\n            { \"type\": \"bytes\", \"name\": \"qc\" },\n            { \"type\": \"uint256\", \"name\": \"round\" },\n            {\n                \"type\": \"tuple\",\n                \"name\": \"origin\",\n                \"components\": [\n                    { \"type\": \"bytes32\", \"name\": \"_publicKeyIdentity\" },\n                    { \"type\": \"uint256\", \"name\": \"_pubMemberIndex\" },\n                    { \"type\": \"uint256\", \"name\": \"_committeeIndex\" }\n                ]\n            }\n        ]\n    }\n]\n</code></pre> <p>To work with these interfaces, you must install the Ethereum library of your choice. For this example, we'll use Web3.js.</p> <pre><code>npm i web3\n</code></pre> <p>Next, you can take the following steps to create a function that deserializes the proof data:</p> <ol> <li> <p>In the <code>main.js</code> file, import the interfaces and Web3</p> main.js<pre><code>const oracleProofABI = require('./resources/oracleProof.json');\nconst signedCoherentClusterABI = require('./resources/signedCoherentCluster.json');\nconst { Web3 } = require('web3');\n</code></pre> </li> <li> <p>Create a Web3 instance, which will be used to interact with the interfaces. You can add this snippet directly after the imports</p> MoonbeamMoonbase Alpha main.js<pre><code>const web3 = new Web3('https://rpc.api.moonbeam.network');\n</code></pre> main.js<pre><code>const web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n</code></pre> </li> <li> <p>Create a <code>deserializeProofBytes</code> function to add all the logic for deserializing the proofs. The function should accept the proof formatted in hex as a parameter</p> main.js<pre><code>const deserializeProofBytes = (proofHex) =&gt; {\n  // Add logic here\n};\n</code></pre> </li> <li> <p>First you can decode the parameters of the proof data using the Oracle Proof interface and extract the raw bytes of the signed pair cluster data and which pair IDs have been requested</p> main.js<pre><code>const deserializeProofBytes = (proofHex) =&gt; {\n  const proof_data = web3.eth.abi.decodeParameters(oracleProofABI, proofHex);\n  // Fatching the raw bytes of the signed pair cluster data\n  const clusters = proof_data[0].clustersRaw;\n  // Fetching which pair IDs have been requested\n  const pairMask = proof_data[0].pairMask;\n};\n</code></pre> </li> <li> <p>Next, you can iterate over the signed pair cluster data and decode the parameters using the Signed Coherent Cluster interface, and then save the data for each pair to variables that you can log to the console</p> main.js<pre><code>const deserializeProofBytes = (proofHex) =&gt; {\n  // ...\n\n  // Helps in iterating the vector of pair masking\n  let pair = 0;\n  // Lists of all the pair IDs, prices, decimals, and timestamps requested\n  const pairId = [];\n  const pairPrice = [];\n  const pairDecimal = [];\n  const pairTimestamp = [];\n\n  for (let i = 0; i &lt; clusters.length; ++i) {\n    // Deserialize the raw bytes of the signed pair cluster data\n    const scc = web3.eth.abi.decodeParameters(\n      signedCoherentClusterABI,\n      clusters[i]\n    );\n\n    for (let j = 0; j &lt; scc[0].cc.pair.length; ++j) {\n      pair += 1;\n      // Verify whether the pair is requested or not\n      if (!pairMask[pair - 1]) {\n        continue;\n      }\n      // Pushing the pair IDs, prices, decimals, and timestamps requested in the output vector\n      pairId.push(scc[0].cc.pair[j].toString(10));\n      pairPrice.push(scc[0].cc.prices[j].toString(10));\n      pairDecimal.push(scc[0].cc.decimals[j].toString(10));\n      pairTimestamp.push(scc[0].cc.timestamp[j].toString(10));\n    }\n  }\n\n  console.log('----- Deserialized Data ------');\n  console.log('Pair index : ', pairId);\n  console.log('Pair Price : ', pairPrice);\n  console.log('Pair Decimal : ', pairDecimal);\n  console.log('Pair Timestamp : ', pairTimestamp);\n  console.log('------------------------------');\n};\n</code></pre> </li> <li> <p>In the <code>main</code> function that you created in the previous section, you can convert the <code>proofs</code> to hex and call the <code>deserializeProofBytes</code> function</p> main.js<pre><code>const main = async () =&gt; {\n  const proofs = await getProofs();\n\n  // Convert oracle proof bytes to hex\n  const hex = web3.utils.bytesToHex(proofs.evm.proof_bytes);\n  deserializeProofBytes(hex);\n};\n\nmain();\n</code></pre> </li> </ol> main.js MoonbeamMoonbase Alpha <pre><code>const PullServiceClient = require('./pullServiceClient');\nconst oracleProofABI = require('./resources/oracleProof.json');\nconst signedCoherentClusterABI = require('./resources/signedCoherentCluster.json');\nconst { Web3 } = require('web3');\n\nconst web3 = new Web3('https://rpc.api.moonbeam.network');\nconst pairIndex = 1;\n\n// Function that fetches proof data from the gRPC server using the specified parameters\nconst getProofs = () =&gt; {\n  const address = 'mainnet-dora.supraoracles.com';\n  const client = new PullServiceClient(address);\n\n  const request = {\n    pair_indexes: [pairIndex], // ETH_USDT\n    chain_type: 'evm',\n  };\n\n  return new Promise((resolve, reject) =&gt; {\n    client.getProof(request, (err, response) =&gt; {\n      if (err) {\n        console.error('Error:', err.details);\n        return;\n      }\n      resolve(response);\n    });\n  });\n};\n\n// Function to convert the proof data to human-readable price data\nconst deserializeProofBytes = (proofHex) =&gt; {\n  const proof_data = web3.eth.abi.decodeParameters(oracleProofABI, proofHex);\n  // Fatching the raw bytes of the signed pair cluster data\n  const clusters = proof_data[0].clustersRaw;\n  // Fetching which pair IDs have been requested\n  const pairMask = proof_data[0].pairMask;\n\n  // Helps in iterating the vector of pair masking\n  let pair = 0;\n  // Lists of all the pair IDs, prices, decimals, and timestamps requested\n  const pairId = [];\n  const pairPrice = [];\n  const pairDecimal = [];\n  const pairTimestamp = [];\n\n  for (let i = 0; i &lt; clusters.length; ++i) {\n    // Deserialize the raw bytes of the signed pair cluster data\n    const scc = web3.eth.abi.decodeParameters(\n      signedCoherentClusterABI,\n      clusters[i]\n    );\n\n    for (let j = 0; j &lt; scc[0].cc.pair.length; ++j) {\n      pair += 1;\n      // Verify whether the pair is requested or not\n      if (!pairMask[pair - 1]) {\n        continue;\n      }\n      // Pushing the pair IDs, prices, decimals, and timestamps requested in the output vector\n      pairId.push(scc[0].cc.pair[j].toString(10));\n      pairPrice.push(scc[0].cc.prices[j].toString(10));\n      pairDecimal.push(scc[0].cc.decimals[j].toString(10));\n      pairTimestamp.push(scc[0].cc.timestamp[j].toString(10));\n    }\n  }\n\n  console.log('----- Deserialized Data ------');\n  console.log('Pair index : ', pairId);\n  console.log('Pair Price : ', pairPrice);\n  console.log('Pair Decimal : ', pairDecimal);\n  console.log('Pair Timestamp : ', pairTimestamp);\n  console.log('------------------------------');\n};\n\nconst main = async () =&gt; {\n  const proofs = await getProofs();\n\n  // Convert oracle proof bytes to hex\n  const hex = web3.utils.bytesToHex(proofs.evm.proof_bytes);\n  deserializeProofBytes(hex);\n};\n\nmain();\n</code></pre> <pre><code>const PullServiceClient = require('./pullServiceClient');\nconst oracleProofABI = require('./resources/oracleProof.json');\nconst signedCoherentClusterABI = require('./resources/signedCoherentCluster.json');\nconst { Web3 } = require('web3');\n\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\nconst pairIndex = 1;\n\n// Function that fetches proof data from the gRPC server using the specified parameters\nconst getProofs = () =&gt; {\n  const address = 'testnet-dora.supraoracles.com';\n  const client = new PullServiceClient(address);\n\n  const request = {\n    pair_indexes: [pairIndex], // ETH_USDT\n    chain_type: 'evm',\n  };\n\n  return new Promise((resolve, reject) =&gt; {\n    client.getProof(request, (err, response) =&gt; {\n      if (err) {\n        console.error('Error:', err.details);\n        return;\n      }\n      resolve(response);\n    });\n  });\n};\n\n// Function to convert the proof data to human-readable price data\nconst deserializeProofBytes = (proofHex) =&gt; {\n  const proof_data = web3.eth.abi.decodeParameters(oracleProofABI, proofHex);\n  // Fatching the raw bytes of the signed pair cluster data\n  const clusters = proof_data[0].clustersRaw;\n  // Fetching which pair IDs have been requested\n  const pairMask = proof_data[0].pairMask;\n\n  // Helps in iterating the vector of pair masking\n  let pair = 0;\n  // Lists of all the pair IDs, prices, decimals, and timestamps requested\n  const pairId = [];\n  const pairPrice = [];\n  const pairDecimal = [];\n  const pairTimestamp = [];\n\n  for (let i = 0; i &lt; clusters.length; ++i) {\n    // Deserialize the raw bytes of the signed pair cluster data\n    const scc = web3.eth.abi.decodeParameters(\n      signedCoherentClusterABI,\n      clusters[i]\n    );\n\n    for (let j = 0; j &lt; scc[0].cc.pair.length; ++j) {\n      pair += 1;\n      // Verify whether the pair is requested or not\n      if (!pairMask[pair - 1]) {\n        continue;\n      }\n      // Pushing the pair IDs, prices, decimals, and timestamps requested in the output vector\n      pairId.push(scc[0].cc.pair[j].toString(10));\n      pairPrice.push(scc[0].cc.prices[j].toString(10));\n      pairDecimal.push(scc[0].cc.decimals[j].toString(10));\n      pairTimestamp.push(scc[0].cc.timestamp[j].toString(10));\n    }\n  }\n\n  console.log('----- Deserialized Data ------');\n  console.log('Pair index : ', pairId);\n  console.log('Pair Price : ', pairPrice);\n  console.log('Pair Decimal : ', pairDecimal);\n  console.log('Pair Timestamp : ', pairTimestamp);\n  console.log('------------------------------');\n};\n\nconst main = async () =&gt; {\n  const proofs = await getProofs();\n\n  // Convert oracle proof bytes to hex\n  const hex = web3.utils.bytesToHex(proofs.evm.proof_bytes);\n  deserializeProofBytes(hex);\n};\n\nmain();\n</code></pre> <p>When you request the proof data, you can view that data in a human-readable format. You can try it out by running:</p> <pre><code>node main.js\n</code></pre> <p>The terminal output should look something like the following:</p> node main.js ----- Deserialized Data ------      Pair index :  [ '1' ]      Pair Price :  [ '3424260000000000000000' ]      Pair Decimal :  [ '18' ]      Pair Timestamp :  [ '1709317443269' ]      ------------------------------"},{"location":"tutorials/integrations/supra/#verify-and-publish-proofs","title":"Use Web3 to Verify and Publish the Proofs","text":"<p>Now that we've retrieved the price data, we need to be able to consume it to verify and publish the data on-chain. To do this, we'll need a smart contract that uses Supra's Pull contract to verify the proof data.</p>"},{"location":"tutorials/integrations/supra/#create-the-consumer-contract","title":"Create the Consumer Contract","text":"<p>You can take the following steps to create our smart contract:</p> <ol> <li> <p>Create a new file for the smart contract, which we'll name <code>OracleClient</code></p> <pre><code>touch OracleClient.sol\n</code></pre> </li> <li> <p>In the file, create an interface for Supra's Pull contract. The interface outlines the data structure for the price data and has a function that we'll call to verify proofs. Then, in our <code>OracleClient</code> contract, we'll instantiate the <code>ISupraOraclePull</code> interface with the address of Supra's Pull contract on Moonbeam or Moonbase Alpha</p> OracleClient.sol<pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.20;\n\ninterface ISupraOraclePull {\n    // Verified price data\n    struct PriceData {\n        // List of pairs\n        uint256[] pairs;\n        // List of prices\n        // prices[i] is the price of pairs[i]\n        uint256[] prices;\n        // List of decimals\n        // decimals[i] is the decimals of pairs[i]\n        uint256[] decimals;\n    }\n\n    function verifyOracleProof(\n        bytes calldata _bytesProof\n    ) external returns (PriceData memory);\n}\n</code></pre> </li> <li> <p>In the same file, create the <code>OracleClient</code> contract. As mentioned in the previous step, the constructor of this contract instantiates the <code>ISupraOraclePull</code> interface with the address of Supra's Pull contract. The contract also includes a function that calls the <code>verifyOracleProof</code> function of the Pull contract and saves the price data on-chain</p> OracleClient.sol<pre><code>// ...\n\n// Contract which can consume oracle pull data\ncontract OracleClient {\n    // The oracle contract\n    ISupraOraclePull internal oracle;\n\n    // Event emitted when a pair price is received\n    event PairPrice(uint256 pair, uint256 price, uint256 decimals);\n\n    constructor(address oracle_) {\n        oracle = ISupraOraclePull(oracle_);\n    }\n\n    function GetPairPrice(\n        bytes calldata _bytesProof,\n        uint256 pair\n    ) external returns (uint256) {\n        // Verify the proof\n        ISupraOraclePull.PriceData memory prices = oracle.verifyOracleProof(\n             _bytesProof\n        );\n        // Set the price and decimals for the requested data pair\n        uint256 price = 0;\n        uint256 decimals = 0;\n        for (uint256 i = 0; i &lt; prices.pairs.length; i++) {\n            if (prices.pairs[i] == pair) {\n                price = prices.prices[i];\n                decimals = prices.decimals[i];\n                break;\n            }\n        }\n        require(price != 0, \"Pair not found\");\n        return price;\n    }\n}\n</code></pre> </li> </ol> OracleClient.sol <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.20;\n\ninterface ISupraOraclePull {\n    // Verified price data\n    struct PriceData {\n        // List of pairs\n        uint256[] pairs;\n        // List of prices\n        // prices[i] is the price of pairs[i]\n        uint256[] prices;\n        // List of decimals\n        // decimals[i] is the decimals of pairs[i]\n        uint256[] decimals;\n    }\n\n    function verifyOracleProof(\n        bytes calldata _bytesProof\n    ) external returns (PriceData memory);\n}\n\n// Contract which can consume oracle pull data\ncontract OracleClient {\n    // The oracle contract\n    ISupraOraclePull internal oracle;\n\n    // Event emitted when a pair price is received\n    event PairPrice(uint256 pair, uint256 price, uint256 decimals);\n\n    constructor(address oracle_) {\n        oracle = ISupraOraclePull(oracle_);\n    }\n\n    function GetPairPrice(\n        bytes calldata _bytesProof,\n        uint256 pair\n    ) external returns (uint256) {\n        // Verify the proof\n        ISupraOraclePull.PriceData memory prices = oracle.verifyOracleProof(\n             _bytesProof\n        );\n        // Set the price and decimals for the requested data pair\n        uint256 price = 0;\n        uint256 decimals = 0;\n        for (uint256 i = 0; i &lt; prices.pairs.length; i++) {\n            if (prices.pairs[i] == pair) {\n                price = prices.prices[i];\n                decimals = prices.decimals[i];\n                break;\n            }\n        }\n        require(price != 0, \"Pair not found\");\n        return price;\n    }\n}\n</code></pre> <p>Note</p> <p>This contract only saves the price data for one pair. So, if you want to save the price data for multiple pairs, you must modify the contract.</p>"},{"location":"tutorials/integrations/supra/#deploy-the-consumer-contract","title":"Deploy the Contract","text":"<p>With the contract created, you must next deploy the contract. Since we've already installed Web3.js, let's use it to deploy the contract. If you're unfamiliar with the process, you can reference the Web3.js docs on deploying a smart contract.</p> <p>To deploy the contract, take the following steps:</p> <ol> <li> <p>Create a file that will contain the logic for compiling and deploying the smart contract</p> <pre><code>touch deploy.js\n</code></pre> </li> <li> <p>Install the Solidity compiler. We're installing version 0.8.20, as that is the version required by the <code>OracleClient</code> contract</p> <pre><code>npm i solc@0.8.20\n</code></pre> </li> <li> <p>Add the following imports</p> deploy.js<pre><code>const fs = require('fs');\nconst solc = require('solc');\nconst { Web3 } = require('web3');\n</code></pre> </li> <li> <p>Create the Web3 instance</p> MoonbeamMoonbase Alpha <pre><code>const web3 = new Web3('https://rpc.api.moonbeam.network');\n</code></pre> <pre><code>const web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n</code></pre> </li> <li> <p>Create a function that compiles the <code>OracleClient</code> contract, saves the ABI in the <code>resources</code> directory for later use, and returns the ABI and bytecode for the deployment</p> deploy.js<pre><code>const compile = () =&gt; {\n  // Get path and load contract\n  const source = fs.readFileSync('OracleClient.sol', 'utf8');\n\n  // Create input object\n  const input = {\n    language: 'Solidity',\n    sources: {\n      'OracleClient.sol': {\n        content: source,\n      },\n    },\n    settings: {\n      outputSelection: {\n        '*': {\n          '*': ['*'],\n        },\n      },\n    },\n  };\n  // Compile the contract\n  const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\n  const contractFile = tempFile.contracts['OracleClient.sol']['OracleClient'];\n\n  // Save ABI to a file\n  fs.writeFileSync(\n    './resources/oracleClient.json',\n    JSON.stringify(contractFile.abi, null, 4),\n    'utf8'\n  );\n\n  return { abi: contractFile.abi, bytecode: contractFile.evm.bytecode.object };\n};\n</code></pre> </li> <li> <p>Create the function to deploy the compiled contract. You'll need to pass the address of Supra's Pull contract to the constructor. You'll also need to provide your address and your private key</p> <p>Remember</p> <p>Never store your private key in a JavaScript file; this is for demo purposes only.</p> MoonbeamMoonbase Alpha deploy.js<pre><code>const deploy = async () =&gt; {\n  // Compile the contract\n  const { abi, bytecode } = compile();\n\n  // Create contract instance\n  const contract = new web3.eth.Contract(abi);\n\n  // Create the deployment transaction and pass in the Pull Oracle contract address\n  const deployTx = contract.deploy({\n    data: bytecode,\n    arguments: ['0x2FA6DbFe4291136Cf272E1A3294362b6651e8517'],\n  });\n\n  // Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: deployTx.encodeABI(),\n      gas: await deployTx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount('INSERT_ADDRESS'),\n    },\n    'INSERT_PRIVATE_KEY'\n  );\n\n  // Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n\n  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);\n};\n\ndeploy();\n</code></pre> deploy.js<pre><code>const deploy = async () =&gt; {\n  // Compile the contract\n  const { abi, bytecode } = compile();\n\n  // Create contract instance\n  const contract = new web3.eth.Contract(abi);\n\n  // Create the deployment transaction and pass in the Pull Oracle contract address\n  const deployTx = contract.deploy({\n    data: bytecode,\n    arguments: ['0xaa2f56843Cec7840F0C106F0202313d8d8CB13d6'],\n  });\n\n  // Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: deployTx.encodeABI(),\n      gas: await deployTx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount('INSERT_ADDRESS'),\n    },\n    'INSERT_PRIVATE_KEY'\n  );\n\n  // Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n\n  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);\n};\n\ndeploy();\n</code></pre> </li> </ol> deploy.js MoonbeamMoonbase Alpha <pre><code>const fs = require('fs');\nconst solc = require('solc');\nconst { Web3 } = require('web3');\n\nconst web3 = new Web3('https://rpc.api.moonbeam.network');\n\nconst compile = () =&gt; {\n  // Get path and load contract\n  const source = fs.readFileSync('OracleClient.sol', 'utf8');\n\n  // Create input object\n  const input = {\n    language: 'Solidity',\n    sources: {\n      'OracleClient.sol': {\n        content: source,\n      },\n    },\n    settings: {\n      outputSelection: {\n        '*': {\n          '*': ['*'],\n        },\n      },\n    },\n  };\n  // Compile the contract\n  const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\n  const contractFile = tempFile.contracts['OracleClient.sol']['OracleClient'];\n\n  // Save ABI to a file\n  fs.writeFileSync(\n    './resources/oracleClient.json',\n    JSON.stringify(contractFile.abi, null, 4),\n    'utf8'\n  );\n\n  return { abi: contractFile.abi, bytecode: contractFile.evm.bytecode.object };\n};\n\nconst deploy = async () =&gt; {\n  // Compile the contract\n  const { abi, bytecode } = compile();\n\n  // Create contract instance\n  const contract = new web3.eth.Contract(abi);\n\n  // Create the deployment transaction and pass in the Pull Oracle contract address\n  const deployTx = contract.deploy({\n    data: bytecode,\n    arguments: ['0x2FA6DbFe4291136Cf272E1A3294362b6651e8517'],\n  });\n\n  // Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: deployTx.encodeABI(),\n      gas: await deployTx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount('INSERT_ADDRESS'),\n    },\n    'INSERT_PRIVATE_KEY'\n  );\n\n  // Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n\n  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);\n};\n\ndeploy();\n</code></pre> <pre><code>const fs = require('fs');\nconst solc = require('solc');\nconst { Web3 } = require('web3');\n\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\nconst compile = () =&gt; {\n  // Get path and load contract\n  const source = fs.readFileSync('OracleClient.sol', 'utf8');\n\n  // Create input object\n  const input = {\n    language: 'Solidity',\n    sources: {\n      'OracleClient.sol': {\n        content: source,\n      },\n    },\n    settings: {\n      outputSelection: {\n        '*': {\n          '*': ['*'],\n        },\n      },\n    },\n  };\n  // Compile the contract\n  const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\n  const contractFile = tempFile.contracts['OracleClient.sol']['OracleClient'];\n\n  // Save ABI to a file\n  fs.writeFileSync(\n    './resources/oracleClient.json',\n    JSON.stringify(contractFile.abi, null, 4),\n    'utf8'\n  );\n\n  return { abi: contractFile.abi, bytecode: contractFile.evm.bytecode.object };\n};\n\nconst deploy = async () =&gt; {\n  // Compile the contract\n  const { abi, bytecode } = compile();\n\n  // Create contract instance\n  const contract = new web3.eth.Contract(abi);\n\n  // Create the deployment transaction and pass in the Pull Oracle contract address\n  const deployTx = contract.deploy({\n    data: bytecode,\n    arguments: ['0xaa2f56843Cec7840F0C106F0202313d8d8CB13d6'],\n  });\n\n  // Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: deployTx.encodeABI(),\n      gas: await deployTx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount('INSERT_ADDRESS'),\n    },\n    'INSERT_PRIVATE_KEY'\n  );\n\n  // Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n\n  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);\n};\n\ndeploy();\n</code></pre> <p>To deploy the contract, run:</p> <pre><code>node deploy.js\n</code></pre> <p>The contract's address will be printed to the terminal; save it as you'll need it in the following steps.</p> node deploy.js Contract deployed at address: 0xaf1207d950a2231937372cedc2e8ddfa22c40665"},{"location":"tutorials/integrations/supra/#call-the-consumer-contract","title":"Call the Contract","text":"<p>To verify the proof data and publish the latest price on-chain, the last step you'll need to do is to create a function that calls the <code>GetPairPrice</code> function of the <code>OracleClient</code> contract.</p> <p>Back in the <code>main.js</code> file, take the following steps:</p> <ol> <li> <p>Import the ABI for the <code>OracleClient</code> contract</p> main.js<pre><code>const oracleClientABI = require('./resources/oracleClient.json');\n</code></pre> </li> <li> <p>Create a function that accepts the hex-formatted proof data and will be responsible for calling the <code>OracleClient</code> contract</p> main.js<pre><code>const callContract = async (proofHex) =&gt; {\n  // Add logic here\n};\n</code></pre> </li> <li> <p>In the <code>callContract</code> function, create an instance of the deployed <code>OracleClient</code> contract using the ABI and the contract address, which you should have saved from deploying the contract in the previous set of steps</p> main.js<pre><code>const callContract = async (proofHex) =&gt; {\n  const contractAddress = 'INSERT_CONTRACT_ADDRESS';\n  const contract = new web3.eth.Contract(oracleClientABI, contractAddress);\n};\n</code></pre> </li> <li> <p>Create the transaction object that will call the <code>GetPairPrice</code> function of the <code>OracleClient</code> contract. You'll need to provide your address in the transaction object</p> main.js<pre><code>const callContract = async (proofHex) =&gt; {\n  const contractAddress = 'INSERT_CONTRACT_ADDRESS';\n  const contract = new web3.eth.Contract(oracleClientABI, contractAddress);\n\n  // Create the transaction object using the hex-formatted proof and the index of the\n  // data pair you requested price data for\n  const txData = contract.methods.GetPairPrice(proofHex, pairIndex).encodeABI();\n  const gasEstimate = await contract.methods\n    .GetPairPrice(proofHex, pairIndex)\n    .estimateGas();\n  const transactionObject = {\n    from: 'INSERT_ADDRESS',\n    to: contractAddress,\n    data: txData,\n    gas: gasEstimate,\n    gasPrice: await web3.eth.getGasPrice(),\n  };\n};\n</code></pre> </li> <li> <p>Add logic for signing and sending the transaction. You'll need to provide your private key</p> <p>Remember</p> <p>Never store your private key in a JavaScript file; this is for demo purposes only.</p> main.js<pre><code>const callContract = async (proofHex) =&gt; {\n  const contractAddress = 'INSERT_CONTRACT_ADDRESS';\n  const contract = new web3.eth.Contract(oracleClientABI, contractAddress);\n\n  // Create the transaction object using the hex-formatted proof and the index of the\n  // data pair you requested price data for\n  const txData = contract.methods.GetPairPrice(proofHex, pairIndex).encodeABI();\n  const gasEstimate = await contract.methods\n    .GetPairPrice(proofHex, pairIndex)\n    .estimateGas();\n  const transactionObject = {\n    from: 'INSERT_ADDRESS',\n    to: contractAddress,\n    data: txData,\n    gas: gasEstimate,\n    gasPrice: await web3.eth.getGasPrice(),\n  };\n\n  // Sign the transaction with the private key\n  const signedTransaction = await web3.eth.accounts.signTransaction(\n    transactionObject,\n    'INSERT_PRIVATE_KEY'\n  );\n\n  // Send the signed transaction\n  return await web3.eth.sendSignedTransaction(signedTransaction.rawTransaction);\n};\n</code></pre> </li> <li> <p>The last step is to call the <code>callContract</code> function from the <code>main</code> function</p> main.js<pre><code>const main = async () =&gt; {\n  const proofs = await getProofs();\n\n  // Convert oracle proof bytes to hex\n  const hex = web3.utils.bytesToHex(proofs.evm.proof_bytes);\n  deserializeProofBytes(hex);\n\n  // Verify and write the latest price data on-chain\n  const receipt = await callContract(hex);\n  console.log('Transaction receipt:', receipt);\n};\n\nmain();\n</code></pre> </li> </ol> main.js MoonbeamMoonbase Alpha <pre><code>const PullServiceClient = require('./pullServiceClient');\nconst oracleProofABI = require('./resources/oracleProof.json');\nconst signedCoherentClusterABI = require('./resources/signedCoherentCluster.json');\nconst { Web3 } = require('web3');\nconst oracleClientABI = require('./resources/oracleClient.json');\n\nconst web3 = new Web3('https://rpc.api.moonbeam.network');\nconst pairIndex = 1;\n\n// Function that fetches proof data from the gRPC server using the specified parameters\nconst getProofs = () =&gt; {\n  const address = 'mainnet-dora.supraoracles.com';\n  const client = new PullServiceClient(address);\n\n  const request = {\n    pair_indexes: [pairIndex], // ETH_USDT\n    chain_type: 'evm',\n  };\n\n  return new Promise((resolve, reject) =&gt; {\n    client.getProof(request, (err, response) =&gt; {\n      if (err) {\n        console.error('Error:', err.details);\n        return;\n      }\n      resolve(response);\n    });\n  });\n};\n\n// Function to convert the proof data to human-readable price data\nconst deserializeProofBytes = (proofHex) =&gt; {\n  const proof_data = web3.eth.abi.decodeParameters(oracleProofABI, proofHex);\n  // Fatching the raw bytes of the signed pair cluster data\n  const clusters = proof_data[0].clustersRaw;\n  // Fetching which pair IDs have been requested\n  const pairMask = proof_data[0].pairMask;\n\n  // Helps in iterating the vector of pair masking\n  let pair = 0;\n  // Lists of all the pair IDs, prices, decimals, and timestamps requested\n  const pairId = [];\n  const pairPrice = [];\n  const pairDecimal = [];\n  const pairTimestamp = [];\n\n  for (let i = 0; i &lt; clusters.length; ++i) {\n    // Deserialize the raw bytes of the signed pair cluster data\n    const scc = web3.eth.abi.decodeParameters(\n      signedCoherentClusterABI,\n      clusters[i]\n    );\n\n    for (let j = 0; j &lt; scc[0].cc.pair.length; ++j) {\n      pair += 1;\n      // Verify whether the pair is requested or not\n      if (!pairMask[pair - 1]) {\n        continue;\n      }\n      // Pushing the pair IDs, prices, decimals, and timestamps requested in the output vector\n      pairId.push(scc[0].cc.pair[j].toString(10));\n      pairPrice.push(scc[0].cc.prices[j].toString(10));\n      pairDecimal.push(scc[0].cc.decimals[j].toString(10));\n      pairTimestamp.push(scc[0].cc.timestamp[j].toString(10));\n    }\n  }\n\n  console.log('----- Deserialized Data ------');\n  console.log('Pair index : ', pairId);\n  console.log('Pair Price : ', pairPrice);\n  console.log('Pair Decimal : ', pairDecimal);\n  console.log('Pair Timestamp : ', pairTimestamp);\n  console.log('------------------------------');\n};\n\n// Function to call the Oracle client to verify and publish the latest price data\nconst callContract = async (proofHex) =&gt; {\n  const contractAddress = 'INSERT_CONTRACT_ADDRESS';\n  const contract = new web3.eth.Contract(oracleClientABI, contractAddress);\n\n  // Create the transaction object using the hex-formatted proof and the index of the\n  // data pair you requested price data for\n  const txData = contract.methods.GetPairPrice(proofHex, pairIndex).encodeABI();\n  const gasEstimate = await contract.methods\n    .GetPairPrice(proofHex, pairIndex)\n    .estimateGas();\n  const transactionObject = {\n    from: 'INSERT_ADDRESS',\n    to: contractAddress,\n    data: txData,\n    gas: gasEstimate,\n    gasPrice: await web3.eth.getGasPrice(),\n  };\n\n  // Sign the transaction with the private key\n  const signedTransaction = await web3.eth.accounts.signTransaction(\n    transactionObject,\n    'INSERT_PRIVATE_KEY'\n  );\n\n  // Send the signed transaction\n  return await web3.eth.sendSignedTransaction(signedTransaction.rawTransaction);\n};\n\nconst main = async () =&gt; {\n  const proofs = await getProofs();\n\n  // Convert oracle proof bytes to hex\n  const hex = web3.utils.bytesToHex(proofs.evm.proof_bytes);\n  deserializeProofBytes(hex);\n\n  // Verify and write the latest price data on-chain\n  const receipt = await callContract(hex);\n  console.log('Transaction receipt:', receipt);\n};\n\nmain();\n</code></pre> <pre><code>const PullServiceClient = require('./pullServiceClient');\nconst oracleProofABI = require('./resources/oracleProof.json');\nconst signedCoherentClusterABI = require('./resources/signedCoherentCluster.json');\nconst { Web3 } = require('web3');\nconst oracleClientABI = require('./resources/oracleClient.json');\n\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\nconst pairIndex = 1;\n\n// Function that fetches proof data from the gRPC server using the specified parameters\nconst getProofs = () =&gt; {\n  const address = 'testnet-dora.supraoracles.com';\n  const client = new PullServiceClient(address);\n\n  const request = {\n    pair_indexes: [pairIndex], // ETH_USDT\n    chain_type: 'evm',\n  };\n\n  return new Promise((resolve, reject) =&gt; {\n    client.getProof(request, (err, response) =&gt; {\n      if (err) {\n        console.error('Error:', err.details);\n        return;\n      }\n      resolve(response);\n    });\n  });\n};\n\n// Function to convert the proof data to human-readable price data\nconst deserializeProofBytes = (proofHex) =&gt; {\n  const proof_data = web3.eth.abi.decodeParameters(oracleProofABI, proofHex);\n  // Fatching the raw bytes of the signed pair cluster data\n  const clusters = proof_data[0].clustersRaw;\n  // Fetching which pair IDs have been requested\n  const pairMask = proof_data[0].pairMask;\n\n  // Helps in iterating the vector of pair masking\n  let pair = 0;\n  // Lists of all the pair IDs, prices, decimals, and timestamps requested\n  const pairId = [];\n  const pairPrice = [];\n  const pairDecimal = [];\n  const pairTimestamp = [];\n\n  for (let i = 0; i &lt; clusters.length; ++i) {\n    // Deserialize the raw bytes of the signed pair cluster data\n    const scc = web3.eth.abi.decodeParameters(\n      signedCoherentClusterABI,\n      clusters[i]\n    );\n\n    for (let j = 0; j &lt; scc[0].cc.pair.length; ++j) {\n      pair += 1;\n      // Verify whether the pair is requested or not\n      if (!pairMask[pair - 1]) {\n        continue;\n      }\n      // Pushing the pair IDs, prices, decimals, and timestamps requested in the output vector\n      pairId.push(scc[0].cc.pair[j].toString(10));\n      pairPrice.push(scc[0].cc.prices[j].toString(10));\n      pairDecimal.push(scc[0].cc.decimals[j].toString(10));\n      pairTimestamp.push(scc[0].cc.timestamp[j].toString(10));\n    }\n  }\n\n  console.log('----- Deserialized Data ------');\n  console.log('Pair index : ', pairId);\n  console.log('Pair Price : ', pairPrice);\n  console.log('Pair Decimal : ', pairDecimal);\n  console.log('Pair Timestamp : ', pairTimestamp);\n  console.log('------------------------------');\n};\n\n// Function to call the Oracle client to verify and publish the latest price data\nconst callContract = async (proofHex) =&gt; {\n  const contractAddress = 'INSERT_CONTRACT_ADDRESS';\n  const contract = new web3.eth.Contract(oracleClientABI, contractAddress);\n\n  // Create the transaction object using the hex-formatted proof and the index of the\n  // data pair you requested price data for\n  const txData = contract.methods.GetPairPrice(proofHex, pairIndex).encodeABI();\n  const gasEstimate = await contract.methods\n    .GetPairPrice(proofHex, pairIndex)\n    .estimateGas();\n  const transactionObject = {\n    from: 'INSERT_ADDRESS',\n    to: contractAddress,\n    data: txData,\n    gas: gasEstimate,\n    gasPrice: await web3.eth.getGasPrice(),\n  };\n\n  // Sign the transaction with the private key\n  const signedTransaction = await web3.eth.accounts.signTransaction(\n    transactionObject,\n    'INSERT_PRIVATE_KEY'\n  );\n\n  // Send the signed transaction\n  return await web3.eth.sendSignedTransaction(signedTransaction.rawTransaction);\n};\n\nconst main = async () =&gt; {\n  const proofs = await getProofs();\n\n  // Convert oracle proof bytes to hex\n  const hex = web3.utils.bytesToHex(proofs.evm.proof_bytes);\n  deserializeProofBytes(hex);\n\n  // Verify and write the latest price data on-chain\n  const receipt = await callContract(hex);\n  console.log('Transaction receipt:', receipt);\n};\n\nmain();\n</code></pre> <p>And that's all the logic you'll need to request, verify, and write the latest price data for a data pair on-chain using Supra!</p> <p>To verify and write the price data on-chain, go ahead and run:</p> <pre><code>node main.js\n</code></pre> <p>The deserialized output and the transaction receipt will be printed to the console.</p> node main.js ----- Deserialized Data ------      Pair index :  [ '1' ]      Pair Price :  [ '3424260000000000000000' ]      Pair Decimal :  [ '18' ]      Pair Timestamp :  [ '1709317443269' ]      ------------------------------    Transaction receipt: {       transactionHash: '0x7d6f14a049e41f8e873dedfed4aff53bc0d52ff06a17fb0901e35464511708b1',     transactionIndex: 1n,     blockHash: '0xb3551d522371b192f37e68634e6b0ce616adecf0d8b18e139980d2cf564f9313',     from: '0x097d9eea23de2d3081169e0225173d0c55768338',     to: '0xaf1207d950a2231937372cedc2e8ddfa22c40665',     blockNumber: 6178886n,     cumulativeGasUsed: 467872n,     gasUsed: 415356n,     logs: [],     logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',     status: 1n,     effectiveGasPrice: 31250000n,     type: 0n     }"},{"location":"tutorials/integrations/supra/#retrieve-on-chain-price-data","title":"Retrieve On-Chain Price Data","text":"<p>If you want to access the on-chain price data, you can create another contract that interacts with Supra's Storage contract.</p>"},{"location":"tutorials/integrations/supra/#create-the-retrieval-contract","title":"Create the Retrieval Contract","text":"<p>To create the contract, you can take the following steps:</p> <ol> <li> <p>Create a new file for the smart contract, which we'll name <code>FeedClient</code></p> <pre><code>touch FeedClient.sol\n</code></pre> </li> <li> <p>In the file, create an interface for Supra's Storage contract. The interface has two functions: one for retrieving the price data for a single data pair and another that retrieves price data for multiple data pairs. Then, in our <code>FeedClient</code> contract, we'll instantiate the <code>ISupraSValueFeed</code> interface with the address of Supra's Storage contract on Moonbeam or Moonbase Alpha</p> FeedClient.sol<pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.20;\n\ninterface ISupraSValueFeed {\n    function getSvalue(uint64 _pairIndex) external view returns (bytes32, bool);\n    function getSvalues(\n        uint64[] memory _pairIndexes\n    ) external view returns (bytes32[] memory, bool[] memory);\n}\n</code></pre> </li> <li> <p>In the same file, create the <code>FeedClient</code> contract. As mentioned in the previous step, the constructor of this contract instantiates the <code>ISupraSValueFeed</code> interface with the address of Supra's Storage contract. The contract also includes functions that call the <code>getSValue</code> and <code>getSValues</code> functions of the Storage contract and return the response in a decoded format</p> FeedClient.sol<pre><code>// ...\n\ncontract FeedClient {\n    // The storage contract\n    ISupraSValueFeed internal sValueFeed;\n\n    constructor(address storage_) {\n        sValueFeed = ISupraSValueFeed(storage_);\n    }\n\n    function unpack(bytes32 data) internal pure returns (uint256[4] memory) {\n        uint256[4] memory info;\n\n        info[0] = bytesToUint256(abi.encodePacked(data &gt;&gt; 192)); // round\n        info[1] = bytesToUint256(abi.encodePacked((data &lt;&lt; 64) &gt;&gt; 248)); // decimal\n        info[2] = bytesToUint256(abi.encodePacked((data &lt;&lt; 72) &gt;&gt; 192)); // timestamp\n        info[3] = bytesToUint256(abi.encodePacked((data &lt;&lt; 136) &gt;&gt; 160)); // price\n\n        return info;\n    }\n\n    function bytesToUint256(\n        bytes memory _bs\n    ) internal pure returns (uint256 value) {\n        require(_bs.length == 32, \"bytes length is not 32.\");\n        assembly {\n            value := mload(add(_bs, 0x20))\n        }\n    }\n\n    function getPrice(\n        uint64 _priceIndex\n    ) external view returns (uint256[4] memory) {\n        (bytes32 val, ) = sValueFeed.getSvalue(_priceIndex);\n\n        uint256[4] memory decoded = unpack(val);\n\n        return decoded;\n    }\n\n    function getPriceForMultiplePair(\n        uint64[] memory _pairIndexes\n    ) external view returns (uint256[4][] memory) {\n        (bytes32[] memory val, ) = sValueFeed.getSvalues(_pairIndexes);\n\n        uint256[4][] memory decodedArray = new uint256[4][](val.length);\n\n        for (uint256 i = 0; i &lt; val.length; i++) {\n            uint256[4] memory decoded = unpack(val[i]);\n            decodedArray[i] = decoded;\n        }\n\n        return decodedArray;\n    }\n}\n</code></pre> </li> </ol> FeedClient.sol <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.20;\n\ninterface ISupraSValueFeed {\n    function getSvalue(uint64 _pairIndex) external view returns (bytes32, bool);\n    function getSvalues(\n        uint64[] memory _pairIndexes\n    ) external view returns (bytes32[] memory, bool[] memory);\n}\n\ncontract FeedClient {\n    // The storage contract\n    ISupraSValueFeed internal sValueFeed;\n\n    constructor(address storage_) {\n        sValueFeed = ISupraSValueFeed(storage_);\n    }\n\n    function unpack(bytes32 data) internal pure returns (uint256[4] memory) {\n        uint256[4] memory info;\n\n        info[0] = bytesToUint256(abi.encodePacked(data &gt;&gt; 192)); // round\n        info[1] = bytesToUint256(abi.encodePacked((data &lt;&lt; 64) &gt;&gt; 248)); // decimal\n        info[2] = bytesToUint256(abi.encodePacked((data &lt;&lt; 72) &gt;&gt; 192)); // timestamp\n        info[3] = bytesToUint256(abi.encodePacked((data &lt;&lt; 136) &gt;&gt; 160)); // price\n\n        return info;\n    }\n\n    function bytesToUint256(\n        bytes memory _bs\n    ) internal pure returns (uint256 value) {\n        require(_bs.length == 32, \"bytes length is not 32.\");\n        assembly {\n            value := mload(add(_bs, 0x20))\n        }\n    }\n\n    function getPrice(\n        uint64 _priceIndex\n    ) external view returns (uint256[4] memory) {\n        (bytes32 val, ) = sValueFeed.getSvalue(_priceIndex);\n\n        uint256[4] memory decoded = unpack(val);\n\n        return decoded;\n    }\n\n    function getPriceForMultiplePair(\n        uint64[] memory _pairIndexes\n    ) external view returns (uint256[4][] memory) {\n        (bytes32[] memory val, ) = sValueFeed.getSvalues(_pairIndexes);\n\n        uint256[4][] memory decodedArray = new uint256[4][](val.length);\n\n        for (uint256 i = 0; i &lt; val.length; i++) {\n            uint256[4] memory decoded = unpack(val[i]);\n            decodedArray[i] = decoded;\n        }\n\n        return decodedArray;\n    }\n}\n</code></pre>"},{"location":"tutorials/integrations/supra/#deploy-the-retrieval-contract","title":"Deploy the Contract","text":"<p>The steps for compiling and deploying the contract are similar to those in the previous section. You can either duplicate the <code>deploy.js</code> file and make the necessary edits or directly edit the existing <code>deploy.js</code> file with the following two changes:</p> <ul> <li>Update the contract name from <code>OracleClient</code> to <code>FeedClient</code></li> <li>Update the contract address in the deployment transaction to be the Storage contract address instead of the Pull contract address</li> </ul> <p>You should end up with the following code:</p> deploy.js MoonbeamMoonbase Alpha <pre><code>const fs = require('fs');\nconst solc = require('solc');\nconst { Web3 } = require('web3');\n\nconst web3 = new Web3('https://rpc.api.moonbeam.network');\n\nconst compile = () =&gt; {\n  // Get path and load contract\n  const source = fs.readFileSync('FeedClient.sol', 'utf8');\n\n  // Create input object\n  const input = {\n    language: 'Solidity',\n    sources: {\n      'FeedClient.sol': {\n        content: source,\n      },\n    },\n    settings: {\n      outputSelection: {\n        '*': {\n          '*': ['*'],\n        },\n      },\n    },\n  };\n  // Compile the contract\n  const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\n  const contractFile = tempFile.contracts['FeedClient.sol']['FeedClient'];\n\n  // Save ABI to a file\n  fs.writeFileSync(\n    './resources/feedClient.json',\n    JSON.stringify(contractFile.abi, null, 4),\n    'utf8'\n  );\n\n  return { abi: contractFile.abi, bytecode: contractFile.evm.bytecode.object };\n};\n\nconst deploy = async () =&gt; {\n  // Compile the contract\n  const { abi, bytecode } = compile();\n\n  // Create contract instance\n  const contract = new web3.eth.Contract(abi);\n\n  // Create the deployment transaction and pass in the Storage contract address\n  const deployTx = contract.deploy({\n    data: bytecode,\n    arguments: ['0xD02cc7a670047b6b012556A88e275c685d25e0c9'],\n  });\n\n  // Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: deployTx.encodeABI(),\n      gas: await deployTx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount('INSERT_ADDRESS'),\n    },\n    'INSERT_PRIVATE_KEY'\n  );\n\n  // Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n\n  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);\n};\n\ndeploy();\n</code></pre> <pre><code>const fs = require('fs');\nconst solc = require('solc');\nconst { Web3 } = require('web3');\n\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\nconst compile = () =&gt; {\n  // Get path and load contract\n  const source = fs.readFileSync('FeedClient.sol', 'utf8');\n\n  // Create input object\n  const input = {\n    language: 'Solidity',\n    sources: {\n      'FeedClient.sol': {\n        content: source,\n      },\n    },\n    settings: {\n      outputSelection: {\n        '*': {\n          '*': ['*'],\n        },\n      },\n    },\n  };\n  // Compile the contract\n  const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\n  const contractFile = tempFile.contracts['FeedClient.sol']['FeedClient'];\n\n  // Save ABI to a file\n  fs.writeFileSync(\n    './resources/feedClient.json',\n    JSON.stringify(contractFile.abi, null, 4),\n    'utf8'\n  );\n\n  return { abi: contractFile.abi, bytecode: contractFile.evm.bytecode.object };\n};\n\nconst deploy = async () =&gt; {\n  // Compile the contract\n  const { abi, bytecode } = compile();\n\n  // Create contract instance\n  const contract = new web3.eth.Contract(abi);\n\n  // Create the deployment transaction and pass in the Storage contract address\n  const deployTx = contract.deploy({\n    data: bytecode,\n    arguments: ['0x4591d1B110ad451d8220d82252F829E8b2a91B17'],\n  });\n\n  // Sign transaction with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: deployTx.encodeABI(),\n      gas: await deployTx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount('INSERT_ADDRESS'),\n    },\n    'INSERT_PRIVATE_KEY'\n  );\n\n  // Send transaction and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n\n  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);\n};\n\ndeploy();\n</code></pre> <p>To deploy the contract, run:</p> <pre><code>node deploy.js\n</code></pre> <p>The contract address will be printed to your terminal; save it as you'll need it in the next section.</p>"},{"location":"tutorials/integrations/supra/#call-the-retrieval-contract","title":"Call the Contract","text":"<p>For simplicity, you can add a function to the <code>main.js</code> file that retrieves the data from the <code>FeedClient</code> contract:</p> <ol> <li> <p>Import the ABI of the <code>FeedClient</code> contract</p> <pre><code>const feedClientABI = require('./resources/feedClient.json'); \n</code></pre> </li> <li> <p>Create a function named <code>getPriceData</code> that accepts the index of a data pair as a parameter and will be responsible for calling the <code>FeedClient</code> contract</p> main.js<pre><code>const getPriceData = async (index) =&gt; {\n  // Add logic here\n};\n</code></pre> </li> <li> <p>In the <code>getPriceData</code> function, create an instance of the deployed <code>FeedClient</code> contract using the ABI and the contract address, which you should have saved from deploying the contract in the previous set of steps</p> main.js<pre><code>const getPriceData = async (index) =&gt; {\n  const contractAddress = 'INSERT_CONTRACT_ADDRESS';\n  const contract = new web3.eth.Contract(feedClientABI, contractAddress);\n};\n</code></pre> </li> <li> <p>Call the <code>getPrice</code> function of the <code>FeedClient</code> contract and log the results to the console</p> main.js<pre><code>const getPriceData = async (index) =&gt; {\n  const contractAddress = 'INSERT_CONTRACT_ADDRESS';\n  const contract = new web3.eth.Contract(feedClientABI, contractAddress);\n\n  // Get the price data and log it to the console\n  const priceData = await contract.methods.getPrice(index).call();\n  console.log('----- On-Chain Price Data ------');\n  console.log('Round : ', priceData[0]);\n  console.log('Decimals : ', priceData[1]);\n  console.log('Timestamp : ', priceData[2]);\n  console.log('Price : ', priceData[3]);\n};\n</code></pre> </li> <li> <p>In the <code>main</code> function, add the logic to call the <code>getPriceData</code> function</p> main.js<pre><code>const main = async () =&gt; {\n  const proofs = await getProofs();\n\n  // Convert oracle proof bytes to hex\n  const hex = web3.utils.bytesToHex(proofs.evm.proof_bytes);\n  deserializeProofBytes(hex);\n\n  // Verify and write the latest price data on-chain\n  const receipt = await callContract(hex);\n  console.log('Transaction receipt:', receipt);\n\n  // Get the latest price data\n  await getPriceData(pairIndex);\n};\n\nmain();\n</code></pre> </li> </ol> main.js MoonbeamMoonbase Alpha <pre><code>const PullServiceClient = require('./pullServiceClient');\nconst oracleProofABI = require('./resources/oracleProof.json');\nconst signedCoherentClusterABI = require('./resources/signedCoherentCluster.json');\nconst { Web3 } = require('web3');\nconst oracleClientABI = require('./resources/oracleClient.json');\nconst feedClientABI = require('./resources/feedClient.json'); \n\nconst web3 = new Web3('https://rpc.api.moonbeam.network');\nconst pairIndex = 1;\n\n// Function that fetches proof data from the gRPC server using the specified parameters\nconst getProofs = () =&gt; {\n  const address = 'mainnet-dora.supraoracles.com';\n  const client = new PullServiceClient(address);\n\n  const request = {\n    pair_indexes: [pairIndex], // ETH_USDT\n    chain_type: 'evm',\n  };\n\n  return new Promise((resolve, reject) =&gt; {\n    client.getProof(request, (err, response) =&gt; {\n      if (err) {\n        console.error('Error:', err.details);\n        return;\n      }\n      resolve(response);\n    });\n  });\n};\n\n// Function to convert the proof data to human-readable price data\nconst deserializeProofBytes = (proofHex) =&gt; {\n  const proof_data = web3.eth.abi.decodeParameters(oracleProofABI, proofHex);\n  // Fatching the raw bytes of the signed pair cluster data\n  const clusters = proof_data[0].clustersRaw;\n  // Fetching which pair IDs have been requested\n  const pairMask = proof_data[0].pairMask;\n\n  // Helps in iterating the vector of pair masking\n  let pair = 0;\n  // Lists of all the pair IDs, prices, decimals, and timestamps requested\n  const pairId = [];\n  const pairPrice = [];\n  const pairDecimal = [];\n  const pairTimestamp = [];\n\n  for (let i = 0; i &lt; clusters.length; ++i) {\n    // Deserialize the raw bytes of the signed pair cluster data\n    const scc = web3.eth.abi.decodeParameters(\n      signedCoherentClusterABI,\n      clusters[i]\n    );\n\n    for (let j = 0; j &lt; scc[0].cc.pair.length; ++j) {\n      pair += 1;\n      // Verify whether the pair is requested or not\n      if (!pairMask[pair - 1]) {\n        continue;\n      }\n      // Pushing the pair IDs, prices, decimals, and timestamps requested in the output vector\n      pairId.push(scc[0].cc.pair[j].toString(10));\n      pairPrice.push(scc[0].cc.prices[j].toString(10));\n      pairDecimal.push(scc[0].cc.decimals[j].toString(10));\n      pairTimestamp.push(scc[0].cc.timestamp[j].toString(10));\n    }\n  }\n\n  console.log('----- Deserialized Data ------');\n  console.log('Pair index : ', pairId);\n  console.log('Pair Price : ', pairPrice);\n  console.log('Pair Decimal : ', pairDecimal);\n  console.log('Pair Timestamp : ', pairTimestamp);\n  console.log('------------------------------');\n};\n\n// Function to call the Oracle client to verify and publish the latest price data\nconst callContract = async (proofHex) =&gt; {\n  const contractAddress = 'INSERT_CONTRACT_ADDRESS';\n  const contract = new web3.eth.Contract(oracleClientABI, contractAddress);\n\n  // Create the transaction object using the hex-formatted proof and the index of the\n  // data pair you requested price data for\n  const txData = contract.methods.GetPairPrice(proofHex, pairIndex).encodeABI();\n  const gasEstimate = await contract.methods\n    .GetPairPrice(proofHex, pairIndex)\n    .estimateGas();\n  const transactionObject = {\n    from: 'INSERT_ADDRESS',\n    to: contractAddress,\n    data: txData,\n    gas: gasEstimate,\n    gasPrice: await web3.eth.getGasPrice(),\n  };\n\n  // Sign the transaction with the private key\n  const signedTransaction = await web3.eth.accounts.signTransaction(\n    transactionObject,\n    'INSERT_PRIVATE_KEY'\n  );\n\n  // Send the signed transaction\n  return await web3.eth.sendSignedTransaction(signedTransaction.rawTransaction);\n};\n\n// Function to get the most recently published on-chain price data\nconst getPriceData = async (index) =&gt; {\n  const contractAddress = 'INSERT_CONTRACT_ADDRESS';\n  const contract = new web3.eth.Contract(feedClientABI, contractAddress);\n\n  // Get the price data and log it to the console\n  const priceData = await contract.methods.getPrice(index).call();\n  console.log('----- On-Chain Price Data ------');\n  console.log('Round : ', priceData[0]);\n  console.log('Decimals : ', priceData[1]);\n  console.log('Timestamp : ', priceData[2]);\n  console.log('Price : ', priceData[3]);\n};\n\nconst main = async () =&gt; {\n  const proofs = await getProofs();\n\n  // Convert oracle proof bytes to hex\n  const hex = web3.utils.bytesToHex(proofs.evm.proof_bytes);\n  deserializeProofBytes(hex);\n\n  // Verify and write the latest price data on-chain\n  const receipt = await callContract(hex);\n  console.log('Transaction receipt:', receipt);\n\n  // Get the latest price data\n  await getPriceData(pairIndex);\n};\n\nmain();\n</code></pre> <pre><code>const PullServiceClient = require('./pullServiceClient');\nconst oracleProofABI = require('./resources/oracleProof.json');\nconst signedCoherentClusterABI = require('./resources/signedCoherentCluster.json');\nconst { Web3 } = require('web3');\nconst oracleClientABI = require('./resources/oracleClient.json');\nconst feedClientABI = require('./resources/feedClient.json'); \n\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\nconst pairIndex = 1;\n\n// Function that fetches proof data from the gRPC server using the specified parameters\nconst getProofs = () =&gt; {\n  const address = 'testnet-dora.supraoracles.com';\n  const client = new PullServiceClient(address);\n\n  const request = {\n    pair_indexes: [pairIndex], // ETH_USDT\n    chain_type: 'evm',\n  };\n\n  return new Promise((resolve, reject) =&gt; {\n    client.getProof(request, (err, response) =&gt; {\n      if (err) {\n        console.error('Error:', err.details);\n        return;\n      }\n      resolve(response);\n    });\n  });\n};\n\n// Function to convert the proof data to human-readable price data\nconst deserializeProofBytes = (proofHex) =&gt; {\n  const proof_data = web3.eth.abi.decodeParameters(oracleProofABI, proofHex);\n  // Fatching the raw bytes of the signed pair cluster data\n  const clusters = proof_data[0].clustersRaw;\n  // Fetching which pair IDs have been requested\n  const pairMask = proof_data[0].pairMask;\n\n  // Helps in iterating the vector of pair masking\n  let pair = 0;\n  // Lists of all the pair IDs, prices, decimals, and timestamps requested\n  const pairId = [];\n  const pairPrice = [];\n  const pairDecimal = [];\n  const pairTimestamp = [];\n\n  for (let i = 0; i &lt; clusters.length; ++i) {\n    // Deserialize the raw bytes of the signed pair cluster data\n    const scc = web3.eth.abi.decodeParameters(\n      signedCoherentClusterABI,\n      clusters[i]\n    );\n\n    for (let j = 0; j &lt; scc[0].cc.pair.length; ++j) {\n      pair += 1;\n      // Verify whether the pair is requested or not\n      if (!pairMask[pair - 1]) {\n        continue;\n      }\n      // Pushing the pair IDs, prices, decimals, and timestamps requested in the output vector\n      pairId.push(scc[0].cc.pair[j].toString(10));\n      pairPrice.push(scc[0].cc.prices[j].toString(10));\n      pairDecimal.push(scc[0].cc.decimals[j].toString(10));\n      pairTimestamp.push(scc[0].cc.timestamp[j].toString(10));\n    }\n  }\n\n  console.log('----- Deserialized Data ------');\n  console.log('Pair index : ', pairId);\n  console.log('Pair Price : ', pairPrice);\n  console.log('Pair Decimal : ', pairDecimal);\n  console.log('Pair Timestamp : ', pairTimestamp);\n  console.log('------------------------------');\n};\n\n// Function to call the Oracle client to verify and publish the latest price data\nconst callContract = async (proofHex) =&gt; {\n  const contractAddress = 'INSERT_CONTRACT_ADDRESS';\n  const contract = new web3.eth.Contract(oracleClientABI, contractAddress);\n\n  // Create the transaction object using the hex-formatted proof and the index of the\n  // data pair you requested price data for\n  const txData = contract.methods.GetPairPrice(proofHex, pairIndex).encodeABI();\n  const gasEstimate = await contract.methods\n    .GetPairPrice(proofHex, pairIndex)\n    .estimateGas();\n  const transactionObject = {\n    from: 'INSERT_ADDRESS',\n    to: contractAddress,\n    data: txData,\n    gas: gasEstimate,\n    gasPrice: await web3.eth.getGasPrice(),\n  };\n\n  // Sign the transaction with the private key\n  const signedTransaction = await web3.eth.accounts.signTransaction(\n    transactionObject,\n    'INSERT_PRIVATE_KEY'\n  );\n\n  // Send the signed transaction\n  return await web3.eth.sendSignedTransaction(signedTransaction.rawTransaction);\n};\n\n// Function to get the most recently published on-chain price data\nconst getPriceData = async (index) =&gt; {\n  const contractAddress = 'INSERT_CONTRACT_ADDRESS';\n  const contract = new web3.eth.Contract(feedClientABI, contractAddress);\n\n  // Get the price data and log it to the console\n  const priceData = await contract.methods.getPrice(index).call();\n  console.log('----- On-Chain Price Data ------');\n  console.log('Round : ', priceData[0]);\n  console.log('Decimals : ', priceData[1]);\n  console.log('Timestamp : ', priceData[2]);\n  console.log('Price : ', priceData[3]);\n};\n\nconst main = async () =&gt; {\n  const proofs = await getProofs();\n\n  // Convert oracle proof bytes to hex\n  const hex = web3.utils.bytesToHex(proofs.evm.proof_bytes);\n  deserializeProofBytes(hex);\n\n  // Verify and write the latest price data on-chain\n  const receipt = await callContract(hex);\n  console.log('Transaction receipt:', receipt);\n\n  // Get the latest price data\n  await getPriceData(pairIndex);\n};\n\nmain();\n</code></pre> <p>Run the following command to print the price data to the terminal:</p> <p>Note</p> <p>Feel free to comment out the calls to the <code>deserializeProofBytes</code> and <code>callContract</code> functions if you only want to retrieve the price data.</p> <pre><code>node main.js\n</code></pre> <p>The terminal output should now include the price data.</p> node main.js ----- On-Chain Price Data ------      Round :  1709333298000n      Decimals :  18n      Timestamp :  1709333298216n      Price :  3430850000000000000000n    <p>And that's it! You've successfully fetched the proof data from Supra, verified and published it on-chain, and retrieved it! For more information on Supra Oracles, please check out their documentation.</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/interoperability/cross-chain-dao/","title":"Building a Cross-Chain DAO with OpenZeppelin's Governor Contract","text":"<p>by Jeremy Boetticher</p>"},{"location":"tutorials/interoperability/cross-chain-dao/#introduction","title":"Introduction","text":"<p>Moonbeam works hard to support interoperability and cross-chain logic. Its multi-chain initiative requires an updating of previously understood smart contract concepts so that they fit a cross-chain world. While some cross-chain primitives have been available for years, such as cross-chain tokens, others are only now starting to be worked on, such as cross-chain swaps, AMMs, and, of particular interest for this tutorial, DAOs.</p> <p>In this tutorial, we will work through a thought process of writing smart contracts for a cross-chain DAO. The smart contracts in this example will be based off of OpenZeppelin's Governance smart contracts to demonstrate an evolution from single-chain to cross-chain and to highlight some incompatibilities that one might face when converting a DApp concept from single-chain to cross-chain. The cross-chain protocol used in this example will be LayerZero, but you are encouraged to adapt its concepts to any other protocol that you see fit, since cross-chain concepts often overlap between the protocols that Moonbeam hosts.  </p> <p>The purpose of this tutorial is not to be the end-all, be-all definition of what a cross-chain DAO would be like, but instead to provide an example of thinking about the intricacies of writing a significantly complex cross-chain DApp. The focus of this tutorial will be on architecture, specifically cross-chain smart contract logic, instead of deploying and testing. The following smart contracts are not tested or recommended for production use. That being said, feel free to take inspiration from some of the design choices if you decide to write your cross-chain DAO. The full code base and demonstration of the DAO is available in a GitHub repository, with relevant instructions.  </p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tutorials/interoperability/cross-chain-dao/#intuition-and-planning","title":"Intuition And Planning","text":"<p>DAO stands for \"Decentralized Autonomous Organization.\" In order for a smart contract to be a DAO, it must be:  </p> <ul> <li>Decentralized \u2014 control is separated and distributed among many actors</li> <li>Autonomous \u2014 execution must occur without reliance on a single person, government, or team</li> <li>Organized \u2014 there must be a way for actions to be proposed and then taken: code is law</li> </ul> <p>One of the best single-chain DAOs is Compound Finance's DAO. It is organized because the smart contract allows users to propose actions to be taken on chain in the form of transaction parameters, which are later executed with the smart contract as the origin. It is autonomous because the execution of the proposals is permissionless and thus does not depend on any specific person or team. It is decentralized because proposals are voted on by holders of the Compound Finance token.</p> <p>Let's take a look at the phases that a proposal in a DAO like Compound Finance's takes:  </p> <p></p> <ol> <li>Proposal \u2014 a user proposes that the DAO execute one or more transactions</li> <li>Voting \u2014 after a voting delay time period, a voting period opens, which allows users to vote with their voting weight. The voting weight is determined by a token balance snapshot typically taken sometime between the proposal start and the end of the voting delay period  </li> <li>Timelock \u2014 an optional period that allows users to exit the ecosystem (sell their tokens) before the proposal can be executed</li> <li>Execution \u2014 if the vote is successful, any user can trustlessly execute it</li> </ol> <p>But what about a cross-chain DAO? In a cross-chain DAO, the actions that you would typically take should also be available cross-chain: proposals, votes, executions, cancellations, etc. This requires a more complex architecture since a lot of information has to be replicated across chains.  </p> <p>There are many ways to architect a cross-chain DApp. You could make a more distributed system, where data and logic are distributed to multiple chains to maximize their use. On the other end of the spectrum, you could use a hub-and-spoke model, where the main logic and data are stored on a single chain and cross-chain messages will interact with it.  </p> <p></p> <p>Let's break down some of the steps in more detail:  </p> <ol> <li>Proposal \u2014 a user proposes that the DAO execute one or more transactions on the hub chain. A cross-chain message is sent to the satellite smart contracts on the spoke chains to let them know the parameters of the vote to take place  </li> <li>Voting \u2014 after a voting delay time period, a voting period opens, which allows users to vote with their voting weight on every chain. The voting weight is determined by a cross-chain token's balance on each chain at a certain timestamp between the proposal start and end  </li> <li>Collection \u2014 after the voting period, the cross-chain DAO on the hub chain sends a request to the spoke chains to send the voting results of each chain to the hub chain  </li> <li>Timelock \u2014 an optional period that allows users to exit the ecosystem (sell their tokens) before the proposal can be executed  </li> <li>Execution \u2014 if the vote is successful, any user can execute it trustlessly on the hub chain</li> </ol> <p>Note</p> <p>Take note of the new collection phase. This is where the cross-chain aspect changes the logic the most. Essentially, the votes on each spoke chain must be collected and submitted to the hub chain after the voting period is over.</p> <p>The process shown here makes it so that anyone can vote from across chains, so long as they hold the DAO token. For holding information that is read-only, we will be storing it on a single chain. Rare one-off actions such as proposals, cancellations, and so on are best done as a hub-and-spoke model. For information regarding voting logic, since users will be voting on multiple chains, voting weight and vote sums will be stored on each spoke chain and only sent to the hub chain after voting is over, since cross-chain actions are generally expensive.  </p> <p> </p> <p>This is, of course, only one way to implement a cross-chain DAO, and you are encouraged to think of alternative and better ways. In the next section, we will look at an implementation.  </p>"},{"location":"tutorials/interoperability/cross-chain-dao/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before we start writing the entire project, it's important to note that its finished form can be found in its own cross-chain DAO GitHub repository. It uses Hardhat, so prerequisite knowledge will be helpful for understanding how the repository works. This tutorial will not include information on how to use Hardhat and will instead focus solely on the smart contracts. If you would like to follow along, the prerequisites are as follows:  </p> <ul> <li>A fresh Hardhat project and knowledge of how to use Hardhat</li> <li>OpenZeppelin smart contracts installed as a dependency</li> <li>LayerZero smart contracts installed as a dependency</li> </ul> <p>To install both dependencies, you can run:</p> <pre><code>npm install @openzeppelin/contracts @layerzerolabs/solidity-examples\n</code></pre>"},{"location":"tutorials/interoperability/cross-chain-dao/#cross-chain-dao-token-contract","title":"Writing the Cross-Chain DAO Token Contract","text":"<p>Let's start at the basics and sort out how users will have their voting power calculated.</p> <p>In Compound Finance's DAO, a user needs the COMP token to vote, which enables the decentralization aspect of a DAO. OpenZeppelin's <code>Governor</code> smart contract also has this feature, abstracting the tokens to votes feature into an <code>IVotes</code> interface.  </p> <p>The <code>IVotes</code> interface requires a lot of different functions to represent the different weights in a voting scheme. Fortunately, OpenZeppelin provides an ERC-20 implementation of <code>IVotes</code>, called ERC20Votes.  </p> <p>Recall from earlier that we intend to have users vote on each chain and to only send voting data to the hub chain during the collection phase. This means that the voting weights must be stored on each chain. This is very easy, since all we have to do is ensure that the <code>ERC20Votes</code> contract is deployed on each chain, or, in other words, make the DAO token a cross-chain token.  </p> <p>Previously, it was mentioned that LayerZero is being used as the cross-chain protocol for this tutorial. LayerZero was chosen because of their OFT contract, which makes it extremely easy to make an ERC-20 token cross-chain. This doesn't mean that you have to use LayerZero, though; every other cross-chain protocol has its own methods and the ability to create cross-chain assets.  </p> <p>We will create a new file named <code>OFTVotes.sol</code>:  </p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@layerzerolabs/solidity-examples/contracts/token/oft/IOFT.sol\";\nimport \"@layerzerolabs/solidity-examples/contracts/token/oft/OFTCore.sol\";\n\nabstract contract OFTVotes is OFTCore, ERC20Votes, IOFT {\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC20(_name, _symbol) OFTCore(_lzEndpoint) {}\n}\n</code></pre> <p>As you can see, <code>OFTVotes</code> is an abstract smart contract that inherits from the <code>OFTCore</code>, <code>ERC20Votes</code>, and <code>IOFT</code> smart contracts. If properly implemented, this will give it both cross-chain ERC-20 properties as well as voting properties. Let's add the following function overrides to the <code>OFTVotes</code> smart contract:  </p> <pre><code>function supportsInterface(bytes4 interfaceId) public view virtual override(OFTCore, IERC165) returns (bool) {\n    return interfaceId == type(IOFT).interfaceId || interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\n}\n\nfunction token() public view virtual override returns (address) {\n    return address(this);\n}\n\nfunction circulatingSupply() public view virtual override returns (uint) {\n    return totalSupply();\n}\n\nfunction _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n    address spender = _msgSender();\n    if (_from != spender) _spendAllowance(_from, spender, _amount);\n    _burn(_from, _amount);\n    return _amount;\n}\n\nfunction _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n    _mint(_toAddress, _amount);\n    return _amount;\n}\n</code></pre> <p>The first few functions are just ensuring compatibility with the smart contracts that they inherit from.</p> <p>The <code>_debitFrom</code> function is a little spicier: it includes logic to burn tokens so that the token bridge works. Similarly, the <code>_creditTo</code> function includes logic to mint tokens. These two functions are required by the <code>OFTCore</code> smart contract. If you are wondering why minting and burning are involved when most bridges wrap, it's because OFT teleports assets instead of wrapping them (similar to one of the XCM asset protocols).  </p> <p>The <code>OFTVotes</code> contract is abstract, so let's create a final smart contract that we'll deploy. In the <code>contracts</code> folder, create a new smart contract called <code>CrossChainDAOToken.sol</code> and add the following:  </p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OFTVotes.sol\";\n\ncontract CrossChainDAOToken is OFTVotes {\n    constructor(uint256 _initialSupply, address _lzEndpoint)\n        OFTVotes(\"Cross Chain DAO Token\", \"CCDT\", _lzEndpoint)\n        ERC20Permit(\"Cross Chain DAO Token\")\n    {\n        _mint(msg.sender, _initialSupply);\n    }\n\n    // The functions below are overrides required by Solidity\n\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal override(ERC20Votes) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    function _mint(address to, uint256 amount) internal override(ERC20Votes) {\n        super._mint(to, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal override(ERC20Votes) {\n        super._burn(account, amount);\n    }\n}\n</code></pre> <p>This smart contract isn't very special since all it really does is add metadata in the constructor and mint preliminary tokens to the user. All of the overridden functions are only there because of Solidity rules, and they simply default to a parent contract's implementation. The only reason we didn't add the metadata to <code>OFTVotes</code> is because, in theory, that smart contract could be reused elsewhere.  </p> <p>The <code>CrossChainDAOToken</code> smart contract is now ready for deployment on both spoke and hub chains. You can check its complete version in the example repository.  </p>"},{"location":"tutorials/interoperability/cross-chain-dao/#cross-chain-dao-contract","title":"Writing the Cross-Chain DAO Contract","text":"<p>Now to the meat of this tutorial: the cross-chain DAO. To be clear, not all of the cross-chain logic will be stored in the cross-chain DAO smart contract. Instead, we will separate the hub logic into one contract and the spoke chain logic into another. This makes sense because of the hub-and-spoke model: some of the logic is stored on a single hub chain, while the spoke chains interface with it through a simpler satellite contract. We don't need logic meant to be on spoke chains to be on the hub chain.</p> <p>We can start off by creating the base for the cross-chain DAO and then edit it so that it becomes cross-chain. To do so, we'll be taking the following steps:</p> <ol> <li>Create the base contract using OpenZeppelin's contract wizard</li> <li>Add support for cross-chain messaging (through LayerZero in this specific example)</li> <li>Count votes from spoke chains</li> <li>Add a new collection phase between voting and execution  <ul> <li>Requesting the collection of votes from spoke chains</li> <li>Receiving the collection of votes from spoke chains</li> </ul> </li> <li>Add functionality to let spoke chains know when there is a new proposal to vote on</li> <li>(Optional) Add ability to receive cross-chain messages to do non-voting action(s), like proposing or executing</li> </ol>"},{"location":"tutorials/interoperability/cross-chain-dao/#starting-with-the-openzeppelin-contract-wizard","title":"Starting with the OpenZeppelin Contract Wizard","text":"<p>A logical starting point for thinking about writing a cross-chain DAO is its predecessor: a single-chain DAO. There are many different implementations that exist, but since OpenZeppelin hosts an already popular smart contract repository, we will use their Governance smart contracts. A second reason why we're using OpenZeppelin's smart contracts is because they're based off of Compound Finance's DAO, which we've already investigated in the previous section.  </p> <p>A good way to play with the configurations of the <code>Governor</code> smart contract is to use the OpenZeppelin smart contract wizard. By going to the OpenZeppelin contract page, scrolling down, and clicking on the Governor tab, you can view the different ways that you can configure the <code>Governor</code> smart contract.</p> <p>We're going to generate as simple of a base smart contract as possible for demonstration purposes:  </p> <ol> <li>Name the <code>Governor</code> contract CrossChainDAO</li> <li>Set the Voting Delay to 0 for simplicity, which also makes it so that the voting weight snapshot is taken as soon as the proposal is made</li> <li>Set the Voting Period to something short, like 6 minutes</li> <li>For calculating quorum (the minimum amount of vote weight required for a vote to pass), set Quorum to the number (#) 1</li> <li>Disable Timelock, since the timelock period is optional anyways  </li> </ol> <p></p> <p>You should see a contract similar to this in the OpenZeppelin smart contract wizard:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/governance/Governor.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorSettings.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorVotes.sol\";\n\ncontract CrossChainDAO is Governor, GovernorSettings, GovernorCountingSimple, GovernorVotes {\n    constructor(IVotes _token)\n        Governor(\"CrossChainDAO\")\n        GovernorSettings(0 /* 0 block */, 30 /* 6 minutes */, 0)\n        GovernorVotes(_token)\n    {}\n\n    function quorum(uint256 blockNumber) public pure override returns (uint256) {\n        return 1e18;\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function votingDelay() public view override(IGovernor, GovernorSettings) returns (uint256) {\n        return super.votingDelay();\n    }\n\n    function votingPeriod() public view override(IGovernor, GovernorSettings) returns (uint256) {\n        return super.votingPeriod();\n    }\n\n    function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) {\n        return super.proposalThreshold();\n    }\n}\n</code></pre> <p>Let's take this <code>CrossChainDAO</code> smart contract and add it to our working directory as <code>CrossChainDAO.sol</code>.  </p>"},{"location":"tutorials/interoperability/cross-chain-dao/#adding-cross-chain-support","title":"Adding Cross-Chain Support","text":"<p>Let's tackle our next task: supporting cross-chain messaging. For this implementation, we will use the <code>NonblockingLzApp</code> smart contract provided by LayerZero to make it easy to receive and send cross-chain messages. Most cross-chain protocols will have some smart contract to inherit from to receive a generic bytes payload, so you can use similar logic with a different parent smart contract.  </p> <p>To get started, we'll take the following steps:</p> <ol> <li>Import <code>NonblockingLzApp</code> and add it to the parent smart contracts of <code>CrossChainDAO</code></li> <li>Update the constructor as required by the <code>NonblockingLzApp</code> contract by passing in LayerZero's on-chain smart contract as an input</li> <li>Create a function that overrides the <code>_nonblockingLzReceive</code> function of the <code>NonblockingLzApp</code> contract that will be responsible for receiving cross-chain data</li> </ol> <pre><code>// ...other imports go here\nimport \"@layerzerolabs/solidity-examples/contracts/lzApp/NonblockingLzApp.sol\";\n\ncontract CrossChainDAO is Governor, GovernorSettings, GovernorCountingSimple, GovernorVotes, NonblockingLzApp {\n    constructor(IVotes _token, address lzEndpoint)\n        Governor(\"CrossChainDAO\")\n        GovernorSettings(0 /* 0 blocks */, 30 /* 6 minutes */, 0)\n        GovernorVotes(_token)\n        NonblockingLzApp(lzEndpoint)\n    { }\n\n    function _nonblockingLzReceive( uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal override {\n        // TODO: add cross-chain logic\n    }\n} \n</code></pre> <p>We will come back to fully implement the <code>_nonblockingLzReceive</code> function when implementing the collection phase. Just understand that it is the interface by which LayerZero's cross-chain protocol interacts with when there are incoming messages.  </p>"},{"location":"tutorials/interoperability/cross-chain-dao/#counting-votes-with-cross-chain-governor-counting-contract","title":"Counting Votes with Cross-Chain Governor Counting Contract","text":"<p>We intend to receive cross-chain voting data via <code>_nonblockingLzReceive</code>, but that is pointless if it is not stored or counted. This logic and data will be housed in a parent contract of the <code>CrossChainDAO</code>. So let's implement this parent contract before beginning to write the <code>_nonblockinglzReceive</code> function.  </p> <p>OpenZeppelin has divided many of the aspects of a DAO into multiple smart contracts, making it easier to replace sections of logic without having to change others. We don't have to go over all of the different smart contracts that came out of the OpenZeppelin smart contract wizard, but we do have to know what the <code>GovernorCountingSimple</code> contract does.  </p> <p>The <code>GovernorCountingSimple</code> contract defines how votes are counted and what votes are. It stores how many votes have been cast per proposal, what a vote can be (for, against, abstain), and it also controls whether or not quorum has been reached.  </p> <p>Fortunately, when converting to a cross-chain version, a lot of the counting logic does not change. The only difference between our cross-chain variant and the single-chain variant is that the cross-chain variant must account for the collection phase and the votes that come with it. Let's add in some of that logic.</p> <p>Before we write any custom code ourselves, copy and paste the <code>GovernorCountingSimple</code> contract into a new file named <code>CrossChainGovernorCountingSimple.sol</code>. You can get the contract from its repository or within the <code>node_modules</code> folder.  </p> <p>Let's start making changes:</p> <ol> <li>Update the imported contract to use <code>@openzeppelin/contracts</code> instead of using a relative path</li> <li>Rename the contract to <code>CrossChainGovernorCountingSimple</code></li> <li>Add a constructor that will take in a <code>uint16[]</code> to define the spoke chains that the <code>CrossChainDAO</code> smart contract will connect with</li> <li>Add a struct and a corresponding map of them that will store the vote data received from other chains</li> </ol> <pre><code>import \"@openzeppelin/contracts/governance/Governor.sol\"\n\nabstract contract CrossChainGovernorCountingSimple is Governor {\n    // ...\n    // The lz-chain IDs that the DAO expects to receive data from during the \n    // collection phase\n    uint16[] public spokeChains;\n\n    constructor(uint16[] memory _spokeChains) {\n        spokeChains = _spokeChains;\n    }\n\n    struct SpokeProposalVote {\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 abstainVotes;\n        bool initialized;\n    }\n\n    // Maps a proposal ID to a map of a chain ID to summarized spoke voting data\n    mapping(uint256 =&gt; mapping(uint16 =&gt; SpokeProposalVote)) public spokeVotes;\n    // ...\n}\n</code></pre> <p>Challenge</p> <p>In a production-ready cross-chain DAO, you would make the spoke chains modifiable by governance instead of keeping it static. Can you add an additional function that would make this possible? Which address should have access to this function?  </p> <p>Hint: replace the array with a mapping.</p> <p>You might notice that the <code>SpokeProposalVote</code> is based off of the <code>ProposalVote</code> struct in <code>GovernorCountingSimple</code>. The first difference is that the new struct includes a <code>bool</code> called <code>initialized</code> so that it's possible to check whether or not data was received from the spoke chain by retrieving the struct from the <code>spokeVotes</code> map. The second difference is that <code>SpokeProposalVote</code> does not include a map of users to votes because that information stays on the spoke chains and is not necessary for the calculations of whether or not a vote succeeded.</p> <p>Challenge</p> <p>The new <code>SpokeProposalVote</code> struct is very similar to the <code>ProposalVote</code> struct. Can you think of a more optimal data structure for the smart contract that requires only one struct?</p> <p>Now we have a place to store the cross-chain data, and we have a data structure to organize it with. We also want the cross-chain data to matter when calculating if a vote reached quorum and if a vote passed. By iterating through the stored cross-chain data from each of the spoke chains, the votes for each spoke chain are being added to the quorum and vote success calculations. To do so, you'll need to edit the <code>_quorumReached</code> and <code>_voteSucceeded</code> functions.</p> <pre><code>function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n    ProposalVote storage proposalVote = _proposalVotes[proposalId];\n    uint256 abstainVotes = proposalVote.abstainVotes;\n    uint256 forVotes = proposalVote.forVotes;\n\n    for (uint16 i = 0; i &lt; spokeChains.length; i++) {\n        SpokeProposalVote storage v = spokeVotes[proposalId][spokeChains[i]];\n        abstainVotes += v.abstainVotes;\n        forVotes += v.forVotes;\n    }\n\n    return quorum(proposalSnapshot(proposalId)) &lt;= forVotes + abstainVotes;\n}\n\nfunction _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n    ProposalVote storage proposalVote = _proposalVotes[proposalId];\n    uint256 againstVotes = proposalVote.againstVotes;\n    uint256 forVotes = proposalVote.forVotes;\n\n    for (uint16 i = 0; i &lt; spokeChains.length; i++) {\n        SpokeProposalVote storage v = spokeVotes[proposalId][spokeChains[i]];\n        againstVotes += v.againstVotes;\n        forVotes += v.forVotes;\n    }\n    return forVotes &gt; againstVotes;\n}\n</code></pre> <p>That should be it for changes to how cross-chain votes are counted and stored. You can view the smart contract in its completed state in the GitHub repository.  </p> <p>Now, in the child contract <code>CrossChainDAO</code>, you can import the <code>CrossChainGovernorCountingSimple</code> contract and replace <code>GovernorCountingSimple</code> with it:  </p> <pre><code>// ...\nimport \"@openzeppelin/contracts/governance/extensions/GovernorSettings.sol\";\nimport \"./CrossChainGovernorCountingSimple.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorVotes.sol\";\n\ncontract CrossChainDAO is Governor, GovernorSettings, CrossChainGovernorCountingSimple, GovernorVotes, NonblockingLzApp {\n\n    constructor(IVotes _token, address lzEndpoint)\n        Governor(\"CrossChainDAO\")\n        GovernorSettings(0 /* 0 blocks */, 30 /* 6 minutes */, 0)\n        GovernorVotes(_token)\n        NonblockingLzApp(lzEndpoint)\n        CrossChainGovernorCountingSimple(_spokeChains)\n    { }\n\n    // ...\n}\n</code></pre>"},{"location":"tutorials/interoperability/cross-chain-dao/#implementing-a-collection-phase","title":"Implementing a Collection Phase","text":"<p>If you recall from the initial conception, a new collection phase should be added in between the voting period and the proposal's execution. During this phase:  </p> <ol> <li>Execution must be postponed</li> <li>The hub chain must request voting data from the spoke chains</li> <li>The spoke chain must subsequently send the voting data</li> </ol>"},{"location":"tutorials/interoperability/cross-chain-dao/#defining-the-collection-phase-and-preventing-execution","title":"Defining the Collection Phase and Preventing Execution","text":"<p>Let's tackle the first issue: ensuring that execution must be disabled during the collection phase. This will effectively define the collection phase from within the <code>CrossChainDAO</code> contract.</p> <p>We'll need to:</p> <ol> <li>Add two new mappings, <code>collectionStarted</code> and <code>collectionFinished</code>, which have been defined to track the collection status that we'll use in multiple functions throughout this section</li> <li>Add a function that overrides the <code>_beforeExecute</code> function of the OpenZeppelin <code>Governor</code> contract that checks whether or not the each of the spoke chains have sent in voting data before a proposal is executed (which is found by checking <code>initialized</code>)</li> <li>Add a function that marks a collection phase as <code>true</code> if all of the satellite chains have sent a cross-chain message back</li> </ol> <pre><code>mapping(uint256 =&gt; bool) public collectionStarted;\nmapping(uint256 =&gt; bool) public collectionFinished;\n\nfunction _beforeExecute(\n    uint256 proposalId,\n    address[] memory targets,\n    uint256[] memory values,\n    bytes[] memory calldatas,\n    bytes32 descriptionHash\n) internal override {\n    finishCollectionPhase(proposalId);\n\n    require(\n        collectionFinished[proposalId],\n        \"Collection phase for this proposal is unfinished!\"\n    );\n\n    super._beforeExecute(proposalId, targets, values, calldatas, descriptionHash);\n}\n\nfunction finishCollectionPhase(uint256 proposalId) public {\n    bool phaseFinished = true;\n    for (uint16 i = 0; i &lt; spokeChains.length &amp;&amp; phaseFinished; i++) {\n        phaseFinished =\n            phaseFinished &amp;&amp;\n            spokeVotes[proposalId][spokeChains[i]].initialized;\n    }\n\n    collectionFinished[proposalId] = phaseFinished;\n}\n</code></pre> <p>If you wanted, you could also add the collection phase within the IGovernor state machine. This would require more effort than it would be worth and is more feasible for a cross-chain DAO written from scratch, so we will not be doing it in this tutorial.  </p>"},{"location":"tutorials/interoperability/cross-chain-dao/#requesting-votes-from-spoke-chains","title":"Requesting Votes from Spoke Chains","text":"<p>Moving on, let's figure out how to request voting data from spoke chains. We can start by making a new public trustless function to begin the collection phase, similar to the <code>execute</code> function:  </p> <pre><code>// Requests the voting data from all of the spoke chains\nfunction requestCollections(uint256 proposalId) public payable {\n    require(\n        block.number &gt; proposalDeadline(proposalId),\n        \"Cannot request for vote collection until after the vote period is over!\"\n    );\n    require(\n        !collectionStarted[proposalId],\n        \"Collection phase for this proposal has already started!\"\n    );\n\n    collectionStarted[proposalId] = true;\n\n    // Sends an empty message to each of the aggregators. If they receive a \n    // message at all, it is their cue to send data back\n    uint256 crossChainFee = msg.value / spokeChains.length;\n    for (uint16 i = 0; i &lt; spokeChains.length; i++) {\n        // Using \"1\" as the function selector\n        bytes memory payload = abi.encode(1, abi.encode(proposalId));\n        _lzSend({\n            _dstChainId: spokeChains[i],\n            _payload: payload,\n            _refundAddress: payable(address(this)),\n            _zroPaymentAddress: address(0x0),\n            _adapterParams: bytes(\"\"),\n            _nativeFee: crossChainFee\n        });\n    }\n}\n</code></pre> <p>This function allows any user to start the collection process for a specific <code>proposalId</code> as long as:  </p> <ol> <li>The voting phase for the proposal has finished</li> <li>The collection phase has not yet started</li> </ol> <p>Recall that each spoke chain will have a <code>DAOSatellite</code> smart contract associated with it that can also receive and send cross-chain messages. This function sends a cross-chain message to every registered spoke chain's <code>DAOSatellite</code> during the collection phase. The message contains a function selector, <code>1</code>, and a proposal ID. The function selector is used to request voting data for the given proposal instead of some other action (we will revisit this concept very soon) from the destination <code>DAOSatellite</code> contract.</p> <p>Note</p> <p>By using LayerZero, multiple messages must be sent in a single transaction so that every spoke chain can receive data. LayerZero, along with other cross-chain protocols, is unicast instead of multicast. As in, a cross-chain message can only arrive to a single destination. When designing a hub-and-spoke architecture, research if your protocol supports multicast messaging, as it may be more succinct.</p> <p>This should be it for requesting data, since most of the logic afterwards will be hosted within the DAO Satellite. Just understand that when sending the proposal to the</p>"},{"location":"tutorials/interoperability/cross-chain-dao/#receiving-votes-from-spoke-chains","title":"Receiving Votes from Spoke Chains","text":"<p>Recall that connected contracts that use LayerZero implement the <code>_nonblockingLzReceive</code> function to receive cross-chain messages. For incoming messages, we must be able to receive the voting data from other chains during the collection phase. Like good software developers, we want to maintain extensibility; we might also want to receive messages from other chains that do other actions, like execute or propose. But we only get one payload in one receiving function! How do we resolve this issue?  </p> <p>Note</p> <p>For sake of simplicity, we won't implement cross-chain execution or proposals in this tutorial. The function selector concept is being introduced because it is an important topic in cross-chain DApps.  </p> <p>Let's think about the EVM. How does a smart contract know that a transaction wants to call a specific function? Each function has a function selector, a hashed value that is mapped to a specific action. We can do the same thing, but with cross-chain messages and with integers instead of hashes.  </p> <p>We'll update the <code>_nonblockingLzReceive</code> function as follows:</p> <ol> <li>Define the function selector as a <code>uint16</code> variable stored at the start of the bytes payload. From here on out, we will ensure in our design that every cross-chain message sent will have this <code>uint16</code> function selector at the start of its payload.</li> <li>Use assembly to load data at <code>payload's address + 32 bytes</code> into the <code>option</code> variable. Understanding why this is necessary requires a bit of understanding of how <code>abi.encode</code> works. The first 32 bytes of an ABI encoded payload are dedicated to information on the entire payload's size. After these first 32 bytes, the rest of the information is stored, which in this case is the function selector</li> <li>Based on the input of the <code>option</code> variable, perform some type of cross-chain action. For this example, the number <code>0</code> maps to the option to receive the voting data from the other chains. You could add additional functionality to the next number, <code>1</code>, such as proposing or executing</li> <li>If the <code>option</code> is <code>0</code>, we'll need to add functionality to receive the voting data. So, we'll call a function that will receive the voting data and pass in the <code>_srcChainId</code> and the newly unwrapped <code>payload</code> to this function. We'll create this function in the following steps</li> </ol> <p>Add the following code to the <code>_nonblockingLzReceive</code> function:  </p> <pre><code>// Gets a function selector option\nuint16 option;\nassembly {\n    option := mload(add(payload, 32))\n}\n\n// Some options for cross-chain actions are: propose, vote, vote with reason,\n// vote with reason and params, cancel, etc.\nif (option == 0) {\n    onReceiveSpokeVotingData(_srcChainId, payload);\n} else if (option == 1) {\n    // TODO: Feel free to put your own cross-chain actions (propose, execute, etc.)\n} else {\n    // TODO: You could revert here if you wanted to\n}\n</code></pre> <p>When cross-chain messages are received (from any cross-chain protocol), they come with an arbitrary bytes payload. Typically, this bytes payload is created from an invocation of <code>abi.encode</code>, where multiple types of data are inserted. For the smart contract that receives this data, the data must be decoded with <code>abi.decode</code>, where information is decoded in a manner that is expected. For example, if the receiving smart contract's logic requires a <code>uint16</code> and an <code>address</code> to function properly, it will decode by including <code>abi.decode(payload, (uint16, address))</code>.  </p> <p>When we have multiple functionalities packed into a message with a single payload, that payload might come in multiple formats, since different functions will require different bytes. Hence, we must examine the function selector before decoding the entire message.  </p> <p>Note</p> <p>The <code>abi.encode</code> function is used the most because it has the most support for dynamic types, but you could feasibly use <code>abi.encodePacked</code> if your use case permits. Assembly-level logic would have to change if you chose to make this change.</p> <p>We haven't written the <code>onReceiveSpokeVotingData</code> function yet. To do so, we'll take the following steps:</p> <ol> <li>Create the <code>onReceiveSpokeVotingData</code> function that accepts a <code>_srcChainId</code> and <code>payload</code></li> <li>Store the external voting data for future use. We have already defined what type of information we want from spoke chains in <code>CrossChainGovernorCountingSimple</code> via the <code>SpokeProposalVote</code> struct. We want three vote values: <code>forVotes</code>, <code>againstVotes</code>, and <code>abstainVotes</code>. Plus, we want to know for which proposal the data received is for, so we also want a proposal ID</li> </ol> <pre><code>function onReceiveSpokeVotingData(uint16 _srcChainId, bytes memory payload) internal virtual {\n    (\n        , // uint16 option\n        uint256 _proposalId,\n        uint256 _for,\n        uint256 _against,\n        uint256 _abstain\n    ) = abi.decode(payload, (uint16, uint256, uint256, uint256, uint256));\n}\n</code></pre> <p>We can now store the data within the <code>spokeVotes</code> map defined in <code>CrossChainGovernorCountingSimple</code>, so long as that data hasn't already been stored:  </p> <pre><code>    // As long as the received data isn't already initialized...\n    if (spokeVotes[_proposalId][_srcChainId].initialized) {\n        revert(\"Already initialized!\");\n    } else {\n        // Add it to the map (while setting initialized true)\n        spokeVotes[_proposalId][_srcChainId] = SpokeProposalVote(\n            _for,\n            _against,\n            _abstain,\n            true\n        );\n    }\n</code></pre> <p>At this point, the collection phase has been finished! The collection phase stops the execution before all votes are counted, and a message is sent requesting voting data from spoke chains.</p>"},{"location":"tutorials/interoperability/cross-chain-dao/#making-proposals-cross-chain","title":"Making Proposals Cross-Chain","text":"<p>OpenZeppelin's <code>Governor</code> smart contract came with a <code>propose</code> function, but unfortunately it doesn't work for our purposes. When a user sends a proposal, the smart contract needs to send cross-chain messages to let the spoke chains know that there is a new proposal to vote on. But the destination chains also need gas to complete the messages' journey. Most cross-chain protocols currently require extra gas paid in the origin chain's native currency for the destination chain's transaction, and that can only be sent via a payable function. The <code>propose</code> function is not payable, hence why we must write our own cross-chain version.  </p> <p>Note</p> <p>Technically, the cross-chain messages should be sent when the voting delay is over to sync with when the voting weight snapshot is taken. In this instance, the proposal and snapshot are made at the same time.</p> <p>We'll rename the original <code>propose</code> function included in the <code>Governor</code> smart contract to be <code>crossChainPropose</code>. Then we'll modify it to send cross-chain messages with information on the proposal to every spoke chain, the IDs of which you may remember being stored in the <code>CrossChainGovernorCountingSimple</code> contract:</p> <pre><code>function crossChainPropose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description) \n    public payable virtual returns (uint256) {\n    uint256 proposalId = super.propose(targets, values, calldatas, description);\n\n    // Sends the proposal to all of the other chains\n    if (spokeChains.length &gt; 0) {\n        uint256 crossChainFee = msg.value / spokeChains.length;\n\n        // Iterate over every spoke chain\n        for (uint16 i = 0; i &lt; spokeChains.length; i++) {\n            bytes memory payload = abi.encode(\n                0, // Function selector \"0\" for destination contract\n                abi.encode(proposalId, block.timestamp) // Encoding the proposal start\n            );\n\n            // Send a cross-chain message with LayerZero to the chain in the iterator\n            _lzSend({\n                _dstChainId: spokeChains[i],\n                _payload: payload,\n                _refundAddress: payable(address(this)),\n                _zroPaymentAddress: address(0x0),\n                _adapterParams: bytes(\"\"),\n                _nativeFee: crossChainFee\n            });\n        }\n    }\n\n    return proposalId;\n}\n</code></pre> <p>Remember when we designed the <code>CrossChainDAO</code> smart contract's <code>_nonblockingLzReceive</code> function to expect a function selector? This is the same idea, except now we're expecting the satellite smart contract to also implement these features. So in this case, we've defined <code>0</code> as receiving a new proposal. We did the same thing when requesting voting information from spoke chains.  </p> <p>At this point, the <code>CrossChainDAO.sol</code> smart contract is finished! If you want to view the completed smart contract, it is available in its GitHub repository.</p>"},{"location":"tutorials/interoperability/cross-chain-dao/#dao-satellite-contract","title":"Writing the DAO Satellite Contract","text":"<p>So far, we've only talked about the cross-chain DAO and its accompanying token. The cross-chain DAO is never deployed on the spoke chains because it wouldn't be efficient to replicate all of the data across each spoke chain. But, we still need an interface to work with the <code>CrossChainDAO</code> smart contract on the spoke chains. Hence, we will create a satellite contract named <code>DAOSatellite</code>.</p> <p>We'll take the following steps to create the new <code>DAOSatellite</code> contract:</p> <ol> <li>Add dependencies and inherit the <code>NonblockingLzApp</code> contract</li> <li>Add a constructor that defines what the hub chain is (every chain has its own ID in LayerZero and every other cross-chain protocol), the LayerZero endpoint, the cross-chain token that defines voting weight, and the average seconds per block on this weight (more on that later)</li> <li>Add some structs, and storage variables to use later. They're mainly stripped-down versions of what are found in the <code>CrossChainDAO</code> and its parent contracts</li> <li>Add a function to check if a given proposal ID is valid and open to voting</li> </ol> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@layerzerolabs/solidity-examples/contracts/lzApp/NonblockingLzApp.sol\";\nimport \"@openzeppelin/contracts/utils/Timers.sol\";\nimport \"@openzeppelin/contracts/utils/Checkpoints.sol\";\nimport \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\n\ncontract DAOSatellite is NonblockingLzApp { \n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address =&gt; bool) hasVoted;\n    }\n\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct RemoteProposal {\n        // Blocks provided by the hub chain as to when the local votes should start/finish.\n        uint256 localVoteStart;\n        bool voteFinished;\n    }\n\n    constructor(uint16 _hubChain, address _endpoint, IVotes _token, uint _targetSecondsPerBlock) \n        NonblockingLzApp(_endpoint) payable {\n        hubChain = _hubChain;\n        token = _token;\n        targetSecondsPerBlock = _targetSecondsPerBlock;\n    }\n\n    uint16 public immutable hubChain;\n    IVotes public immutable token;\n    uint256 public immutable targetSecondsPerBlock;\n    mapping(uint256 =&gt; RemoteProposal) public proposals;\n    mapping(uint256 =&gt; ProposalVote) public proposalVotes;\n\n    function isProposal(uint256 proposalId) view public returns(bool) {\n        return proposals[proposalId].localVoteStart != 0;\n    }\n}\n</code></pre> <p>Since this smart contract inherits from <code>NonblockingLzApp</code>, it requires <code>_nonblockingLzReceive</code> to receive cross-chain messages. This smart contract communicates with the <code>CrossChainDAO</code> smart contract, and recall that there are currently two instances in which the <code>CrossChainDAO</code> sends a message:  </p> <ul> <li>When the <code>CrossChainDAO</code> wants to notify the spoke chains of a new proposal (function selector is <code>0</code>)  </li> <li>When the <code>CrossChainDAO</code> wants the spoke chains to send their voting data to the hub chain (function selector is <code>1</code>)  </li> </ul> <p>Keeping that in mind, let's start with writing the receiving function <code>_nonblockingLzReceive</code> with a function selector just like the <code>CrossChainDAO</code>:  </p> <pre><code>function _nonblockingLzReceive(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal override {\n    require(_srcChainId == hubChain, \"Only messages from the hub chain can be received!\");\n\n    uint16 option;\n    assembly {\n        option := mload(add(_payload, 32))\n    }\n\n    if (option == 0) {\n        // Begin a proposal on the local chain, with local block times\n     }\n    else if (option == 1) {\n        // Send vote results back to the hub chain\n     }\n}\n</code></pre> <p>Let's tackle the first action, <code>if (option == 0)</code>, beginning a proposal on the local chain:</p> <ol> <li>Decode the payload, which includes a proposal ID and the timestamp of when the proposal was made as mentioned in the CrossChainDAO section</li> <li>Perform some funky calculations to generate a <code>cutOffBlockEstimation</code> by subtracting blocks from the current block based on the timestamp and a predetermined seconds-per-block estimate</li> <li>Add a <code>RemoteProposal</code> struct to the proposals map, effectively registering the proposal and its voting-related data on the spoke chain</li> </ol> <pre><code>(, uint256 proposalId, uint256 proposalStart) = abi.decode(_payload, (uint16, uint256, uint256));\nrequire(!isProposal(proposalId), \"Proposal ID must be unique.\");\n\nuint256 cutOffBlockEstimation = 0;\nif(proposalStart &lt; block.timestamp) {\n    uint256 blockAdjustment = (block.timestamp - proposalStart) / targetSecondsPerBlock;\n    if(blockAdjustment &lt; block.number) {\n        cutOffBlockEstimation = block.number - blockAdjustment;\n    }\n    else {\n        cutOffBlockEstimation = block.number;\n    }\n}\nelse {\n    cutOffBlockEstimation = block.number;\n}\n\nproposals[proposalId] = RemoteProposal(cutOffBlockEstimation, false);\n</code></pre> <p>The calculations in the above snippet are not enough to ensure a correct setup. While it may not matter as much when people can start voting, it does matter when the vote weight snapshot is made. If the vote weight snapshot is made too far apart between the spoke and hub chains, a user could send a token from one chain to another and effectively double their voting weight. Some example mitigation strategies are listed below, but they are too complex to investigate in detail for this tutorial. In the meantime, the only strategy is to subtract blocks from the current block based on the timestamp and a predetermined seconds-per-block estimate.  </p> <p>Now let's add logic to send vote results back to the hub chain:</p> <ol> <li>Retrieve the proposal ID from the cross-chain message</li> <li>Get the data for said proposal from the relevant map</li> <li>Encode that data into a payload as defined by the <code>CrossChainDAO</code></li> <li>Send that data through LayerZero</li> </ol> <pre><code>uint256 proposalId = abi.decode(_payload, (uint256));\nProposalVote storage votes = proposalVotes[proposalId];\nbytes memory votingPayload = abi.encode(\n    0, \n    abi.encode(proposalId, votes.forVotes, votes.againstVotes, votes.abstainVotes)\n);\n_lzSend({\n    _dstChainId: hubChain,\n    _payload: votingPayload,\n    _refundAddress: payable(address(this)),\n    _zroPaymentAddress: address(0x0),\n    _adapterParams: bytes(\"\"),\n    // NOTE: DAOSatellite needs to be funded beforehand, in the constructor.\n    //       There are better solutions, such as cross-chain swaps being built in from the hub chain, but\n    //       this is the easiest solution for demonstration purposes.\n    _nativeFee: 0.1 ether \n});\nproposals[proposalId].voteFinished = true;\n</code></pre> <p>The only issue here is that the gas payment for the cross-chain message's transaction on the hub chain must be included, and there is no simple way to receive it. There are options that could potentially avert this issue, as explained below, but for simplicity's sake, the satellite contract will have to be sent native currency every once in a while.  </p> <p>Finally, the last thing to add is a vote mechanism that allows users to vote. This mechanism is nearly exactly the same as the mechanism in the <code>GovernorCountingSimple</code> smart contract, so much of the code can be copied over:  </p> <pre><code>function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256 balance)\n{\n    RemoteProposal storage proposal = proposals[proposalId];\n    require(\n        !proposal.voteFinished,\n        \"DAOSatellite: vote not currently active\"\n    );\n    require(\n        isProposal(proposalId), \n        \"DAOSatellite: not a started vote\"\n    );\n\n    uint256 weight = token.getPastVotes(msg.sender, proposal.localVoteStart);\n    _countVote(proposalId, msg.sender, support, weight);\n\n    return weight;\n}\n\nfunction _countVote(uint256 proposalId, address account, uint8 support, uint256 weight) internal virtual \n{\n    ProposalVote storage proposalVote = proposalVotes[proposalId];\n\n    require(!proposalVote.hasVoted[account], \"DAOSatellite: vote already cast\");\n    proposalVote.hasVoted[account] = true;\n\n    if (support == uint8(VoteType.Against)) {\n        proposalVote.againstVotes += weight;\n    } else if (support == uint8(VoteType.For)) {\n        proposalVote.forVotes += weight;\n    } else if (support == uint8(VoteType.Abstain)) {\n        proposalVote.abstainVotes += weight;\n    } else {\n        revert(\"DAOSatellite: invalid value for enum VoteType\");\n    }\n}\n</code></pre> <p>Note that the <code>castVote</code> function requires that:  </p> <ul> <li>The proposal isn't finished</li> <li>The proposal exists, as in, there is data that's stored within the <code>proposals</code> map.</li> </ul> <p>In fact, the <code>_countVote</code> function is directly copied from the hub chain! Much of the logic of single-chain dApps can be reused in cross-chain dApps with minor tweaks.  </p> <p>That's it for breaking down the satellite contract. It was more or less simple because most of the logic is just a reflection of what happens on the hub chain. You can view the completed smart contract in its GitHub repository.  </p> <p>At this point, every single smart contract has been finished, and a deployment scheme like the one below can be made. If you are interested in seeing this in action, the GitHub repository that hosts the cross-chain DAO allows you to deploy on TestNets.  </p> <p> </p> <p>As a reminder, this tutorial's smart contracts are not tested or recommended for production use.</p>"},{"location":"tutorials/interoperability/cross-chain-dao/#caveats-and-other-designs","title":"Caveats and Other Designs","text":"<p>Every single part of the smart contract system has been written, and if you got through it all, good job! It's a lot to soak in, and there are still parts that need to be developed for it to be production-ready.</p> <p>The design of this cross-chain DAO was created off of OpenZeppelin's Governor base, but that doesn't mean that it's flawless. It's good to work off of preexisting smart contracts for a version 1 cross-chain DApp, but as you get closer to production-ready code, it's best to start from scratch and leave only the parts that are still relevant to the design. Working off of logic that's meant for single-chain can get in the way several times, which you will find a common occurrence when working with cross-chain smart contracts.  </p> <p>For example, the <code>propose</code> function from the <code>Governor</code> smart contract couldn't be used and had to be replaced with a new cross-chain function. It would be best to completely remove the <code>propose</code> function, but that can't be done because of the way the <code>Governor</code> smart contract was designed. This is an obvious issue, and it goes to show that while it's good to prototype cross-chain DApps using preexisting smart contracts, it can be better to completely rewrite them while still reusing some logic.  </p> <p>Challenge</p> <p>Can you rewrite the <code>CrossChainDAO</code> smart contract to only include the logic and functions necessary for cross-chain interactions? While you're at it, can you implement any of the alternate designs suggested below?</p>"},{"location":"tutorials/interoperability/cross-chain-dao/#division-of-the-cross-chain-selector-into-multiple-contracts","title":"Division of the Cross-Chain Selector Into Multiple Contracts","text":"<p>The cross-chain function selection method that was used in the <code>CrossChainDAO</code> and <code>DAOSatellite</code> smart contracts works fine enough. But instead of having a selector within a single smart contract, you could have cross-chain messages directed at multiple smart contracts that have special permissions within the <code>CrossChainDAO</code>. You may find this helpful in case you believe in single responsibility (SRP) for smart contracts.  </p> <p>For example, the hub chain's <code>CrossChainDAO</code> could be composed of the main contract that receives cross-chain data as well as two other smart contracts: <code>CrossChainExecutor</code> and <code>CrossChainProposer</code>. So, when interacting with the <code>DAOSatellite</code> contract to send a message to <code>CrossChainDAO</code>, the spoke chain's smart contract could target <code>CrossChainExecutor</code> to execute or <code>CrossChainProposer</code> to propose. This would remove the need to double-wrap payloads and the need to include function-selecting logic in the cross-chain message receiving function. It could even help convert a single-chain DAO into one with cross-chain abilities.  </p> <p> </p>"},{"location":"tutorials/interoperability/cross-chain-dao/#distributed-proposal-and-execution","title":"Distributed Proposal and Execution","text":"<p>What if you wanted users to be able to execute a proposal on multiple chains instead of just the hub chain? There are a few ways to go about it:  </p> <ul> <li>Stick with a hub-and-spoke model</li> <li>Completely decentralize  </li> </ul> <p>The hub-and-spoke model is already laid out in detail in this tutorial. In such a case where an execution could occur on multiple chains, you would have to have a smart contract on each chain that executes on behalf of the hub chain (which could be added to <code>DAOSatellite</code>). This smart contract would receive a message from the <code>execute</code> function provided by the <code>Governor</code> smart contract. This is simple enough, but it might be too many cross-chain messages to be efficient.  </p> <p>If you decide to completely decentralize the DAO, it would be most likely to remove the <code>DAOSatellite</code> smart contract and deploy a modified <code>CrossChainDAO</code> smart contract on every chain. Each <code>CrossChainDAO</code> could control the proposals meant to be executed on its chain. It would require a redesign of how proposals are made and sent, however.  </p> <p>You may also find an issue when generating the proposal ID. Take a look at how the IDs are being generated now:  </p> <pre><code>function hashProposal(\n    address[] memory targets,\n    uint256[] memory values,\n    bytes[] memory calldatas,\n    bytes32 descriptionHash\n) public pure virtual override returns (uint256) {\n    return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n}\n</code></pre> <p>Conceivably, the same description and transaction details could be sent on both chain A and on chain B. This could cause errors because then there would be conflicting transactions. It may serve best to include another parameter to hash a proposal ID: the chain ID of the chain on which the proposal is meant to execute.</p>"},{"location":"tutorials/interoperability/cross-chain-dao/#double-weight-attack-from-snapshot-mismatch","title":"Double-Weight Attack from Snapshot Mismatch","text":"<p>One primary issue with the distribution of voting weight across chains via the <code>CrossChainDAOToken</code> is that blocks are not properly aligned across networks. This can cause a situation where the vote snapshots between multiple chains are not close together enough, resulting in a situation where voting weight is doubled when a cross-chain transfer of the DAO token front-runs a new proposal's voting weight snapshot.</p> <p>One option is using an oracle that aligns blocks with timestamps to ensure that snapshots on spoke chains are as close to the hub chain's timestamp as possible.</p> <p>A more simple solution would be to alter the <code>ERC20Votes</code> smart contract to depend on timestamps instead of blocks, but this could still be open to attacks in case the block producers on two chains collude.  </p> <p>Alternatively, you could alter the <code>OFTVotes</code> smart contract to postpone the addition of voting weight until a few blocks after the weight is received.</p>"},{"location":"tutorials/interoperability/cross-chain-dao/#chained-cross-chain-message-fees","title":"Chained Cross-Chain Message Fees","text":"<p>One of the flaws overlooked with the spoke chain's <code>DAOSatellite</code> smart contract is that whenever voting data is requested from the hub chain, the destination chain fees must be stored in the smart contract beforehand. Here are two plausible solutions to this:  </p> <ul> <li>Storing the request for data, and allowing anyone to trustlessly send the data back</li> <li>Sending the gas from the hub chain with the cross-chain message that requests the data</li> </ul> <p>The first is the simplest solution, though it may increase the turn-around time from proposal to execution if you don't plan on running additional infrastructure. Similar to how the <code>execute</code> function can be run by anyone once a proposal has been finished, a new function would be written to allow anyone to send the vote data to the hub chain. Preferably, this would also require a timeout for the collection phase.  </p> <p> </p> <p>The second is significantly more complex. It would require a setup that sends tokens with a payload instead of just a payload like the current contract does, and for a swap to occur on the destination chain to retrieve native currency for a cross-chain transaction.  </p>"},{"location":"tutorials/interoperability/cross-chain-dao/#collection-phase-time-out","title":"Collection Phase Time Out","text":"<p>In case you want to be safe and you believe that a spoke chain might stall or even stop being supported, you would want to include a way to cap the amount of time that the collection phase takes and also add a way for your DAO's governance to add and remove spoke chains.  </p> <p>For example, the hub chain would wait 30 blocks before disregarding voting data from spoke chains. And if the DAO's participants believe that chain A should be removed from future voting, they could start a proposal to do so, similar to OpenZeppelin's <code>GovernorSettings</code> contract.  </p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/interoperability/remote-batched-evm-calls/","title":"Remote Batch EVM Calls via XCM","text":"<p>by Kevin Neilson</p>"},{"location":"tutorials/interoperability/remote-batched-evm-calls/#introduction","title":"Introduction","text":"<p>In this tutorial, we\u2019ll be making a series of remote batch EVM calls from a relay chain (what Polkadot is to Moonbeam) using Polkadot's general message passing protocol called XCM. To do so, we'll be using a particular combination of XCM instructions that allow you to call Moonbeam's EVM through an XCM message. The unique twist to this tutorial is that rather than making a single remote EVM contract call, we'll be using Moonbeam's Batch Precompile to combine multiple EVM calls into a single transaction.</p> <p>To get the most out of this tutorial, you may wish to first familiarize yourself with Remote EVM Calls Through XCM as well as Moonbeam's Batch Precompile.</p> <p>The content of this tutorial is for educational purposes only!</p> <p>For this example, you'll be working on top of Moonbase Alpha (Moonbeam TestNet), which has its own relay chain called Moonbase relay (akin to the Polkadot relay chain). The relay chain token is called UNIT, while Moonbase Alpha's is called DEV. Importantly, you must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, it is essential to test XCM features on a TestNet before moving to a production environment.</p> <p>The goal of this tutorial is to show you how the Batch Precompile can work in conjunction with Polkadot's XCM to allow you to trigger batch remote EVM calls on Moonbeam. To avoid adding complexity to this tutorial, the actual batch EVM calls we'll be making will be quite simple. We'll be initiating multiple mints of planet ERC-20 test tokens on Moonbase Alpha. Although we've chosen simple contract calls for demonstration purposes, there are lots more real-life defi examples that you may wish to emulate, such as token approvals and swaps, claiming rewards from multiple pools, or swapping and depositing into LP pools.</p> <p>Throughout this tutorial, we will refer to the account executing the batch EVM calls via XCM as Alice. Let's preview the flow of this tutorial:</p> <ol> <li>Alice has an account on the relay chain, and she wants to mint Mars (MARS) and Neptune (NEPT) tokens (ERC-20s on Moonbase Alpha) using Moonbase Minter. Alice needs to send an XCM message to Moonbase Alpha from her relay chain account</li> <li>The XCM message will be received by Moonbase Alpha and its instructions executed. The instructions state Alice's intention to buy some block execution time in Moonbase Alpha and execute a call to Moonbase's Batch Precompile, composed of two distinct mint calls. The batch EVM call is dispatched through a special account Alice controls on Moonbase Alpha via XCM messages. This account is known as the Computed Origin account. Even though this is a keyless account (private key is unknown), the public address can be calculated in a deterministic way</li> <li>The successful XCM execution will result in the mint commands being executed by the EVM, and Alice will receive her MARS and NEPT tokens in her special account</li> <li>The execution of the remote EVM call through XCM will result in some EVM logs that are picked up by explorers. There is an EVM transaction and receipt that anyone can query to verify</li> </ol> <p>The \"happy path\" of a remote batch EVM call dispatched via XCM is as follows: </p>"},{"location":"tutorials/interoperability/remote-batched-evm-calls/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Considering all the steps summarized in the introduction, the following prerequisites need to be accounted for:</p> <ul> <li>You need to have UNITs on the relay chain to pay for transaction fees when sending the XCM. If you have a Moonbase Alpha account funded with DEV tokens, you can swap some DEV for xcUNIT here on Moonbeam Swap. Then withdraw the xcUNIT from Moonbase Alpha to your account on the Moonbase relay chain using apps.moonbeam.network.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>Your Computed Origin account must hold DEV tokens to fund the call to the Batch Precompile, and also pay for the XCM execution (although this could be paid in UNIT tokens as xcUNIT). We will calculate the Computed Origin account address in the next section</li> </ul>"},{"location":"tutorials/interoperability/remote-batched-evm-calls/#calculating-your-computed-origin-account","title":"Calculating your Computed Origin Account","text":"<p>Copy the account of your existing or newly created account on the Moonbase relay chain. You're going to need it to calculate the corresponding Computed Origin account, which is a special type of account that\u2019s keyless (the private key is unknown). Transactions from a Computed Origin account can be initiated only via valid XCM instructions from the corresponding account on the relay chain. In other words, you are the only one who can initiate transactions on your Computed Origin account, and if you lose access to your Moonbase relay account, you\u2019ll also lose access to your Computed Origin account.</p> <p>To generate the Computed Origin account, first clone the xcm-tools repo. Run <code>yarn</code> to install the necessary packages, and then run:</p> <pre><code>yarn calculate-multilocation-derivative-account \\\n--ws-provider wss://wss.api.moonbase.moonbeam.network \\\n--address INSERT_MOONBASE_RELAY_ACCOUNT \\\n--para-id INSERT_ORIGIN_PARACHAIN_ID_IF_APPLIES \\\n--parents INSERT_PARENTS_VALUE_IF_APPLIES\n</code></pre> <p>Let's review the parameters passed along with this command:</p> <ul> <li>The <code>--ws-provider</code> or <code>-w</code> flag corresponds to the endpoint we\u2019re using to fetch this information</li> <li>The <code>--address</code> or <code>-a</code> flag corresponds to your Moonbase relay chain address</li> <li>The <code>--para-id</code> or <code>-p</code> flag corresponds to the parachain ID of the origin chain (if applicable). If you are sending the XCM from the relay chain, you don't need to provide this parameter</li> <li>The <code>-parents</code> flag corresponds to the parents value of the origin chain in relation to the destination chain. If you're deriving a multi-location derivative account on a parachain destination from a relay chain origin, this value would be <code>1</code>. If left out, the parents value defaults to <code>0</code></li> </ul> <p>For our case, we will send the remote EVM call via XCM from Alice's account, which is <code>5Fe4nNwxJ9ai9hVkUubiy4e6BVs1tzJGDLXAdhUKuePq9CLp</code>. A parachain ID is omitted from the command since we are sending the XCM instruction from the relay chain. A parents value of <code>1</code> indicates that the relay chain is a parent of the destination parachain. The command and response should resemble the following image:</p> yarn calculate-multilocation-derivative-account \\ --ws-provider wss://wss.api.moonbase.moonbeam.network \\ --address 5Fe4nNwxJ9ai9hVkUubiy4e6BVs1tzJGDLXAdhUKuePq9CLp \\ --parents 1 yarn run v1.22.10 warning ../../../package.json: No license field $ ts-node 'scripts/calculate-multilocation-derivative-account.ts' --ws-provider wss://wss.api.moonbase.moonbeam.network --address 5Fe4nNwxJ9ai9hVkUubiy4e6BVs1tzJGDLXAdhUKuePq9CLp --parents 1 Remote Origin calculated as ParentChain Parents 1 AccountId32: 5Fe4nNwxJ9ai9hVkUubiy4e6BVs1tzJGDLXAdhUKuePq9CLp 32 byte address is 0xf0615483cbe76f5b2aa80a8ce2b2e9a8206deb65b8a1323270e25802f600f95c 20 byte address is 0xf0615483cbe76f5b2aa80a8ce2b2e9a8206deb65 \u2728  Done in 1.02s. <p>The values are all summarized in the following table:</p> Name Value Origin Chain Encoded Address <code>5Fe4nNwxJ9ai9hVkUubiy4e6BVs1tzJGDLXAdhUKuePq9CLp</code> Origin Chain Decoded Address <code>0x9e263df66ff98212347e9a6b51d56f7a982bc25bb1300cd20e5a68d726789043</code> Computed Origin Account (32 bytes) <code>0xf0615483cbe76f5b2aa80a8ce2b2e9a8206deb65b8a1323270e25802f600f95c</code> Computed Origin Account (20 bytes) <code>0xf0615483cbe76f5b2aa80a8ce2b2e9a8206deb65</code> <p>The script will return 32-byte and 20-byte addresses. We\u2019re interested in the Ethereum-style account, the 20-byte one, which is <code>0xf0615483cbe76f5b2aa80a8ce2b2e9a8206deb65</code>. Feel free to look up your Computed Origin account on Moonscan. Next, you can fund this account with DEV tokens.</p> <p>You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet.</p>"},{"location":"tutorials/interoperability/remote-batched-evm-calls/#preparing-the-mint-evm-calldata","title":"Preparing the Mint EVM Calldata","text":"<p>First, we'll generate the necessary calldata for minting the MARS and NEPT tokens. We'll then reference the Batch Precompile to batch the calls into a single one.</p> <p>The function being targeted here is the <code>mint</code> function of Moonbase Minter. It takes no parameters, and the function calldata is the same for each planet. However, each planet has a different contract address.</p> <p>The easiest way to get the calldata is through the Moonbase Minter page. Once you land on the website, take the following steps:</p> <ol> <li>Press Connect MetaMask and unlock your wallet</li> <li>Click on any of the Mint buttons since they all have the same calldata</li> <li>MetaMask should pop up, but do not sign the transaction. In MetaMask, click on the hex tab, and the encoded calldata should show up</li> <li>Click on the Copy raw transaction data button. This will copy the encoded calldata to the clipboard, which should match: <code>0x2004ffd9</code></li> </ol> <p></p> <p>Note</p> <p>Other wallets also offer the same capabilities of checking the encoded calldata before signing the transaction.</p>"},{"location":"tutorials/interoperability/remote-batched-evm-calls/#preparing-the-batched-calldata","title":"Preparing the Batch Calldata","text":"<p>Now that we have the calldata for the mint actions, we can work with the Batch Precompile to combine multiple calls into a single one. The Batch Precompile offers several different methods of batching your transactions according to your tolerance for subcall failures. For this example, we'll use the <code>batchAll</code> function, which reverts all subcalls if a single subcall fails. For more information about how each method of the Batch Precompile works, be sure to check out the full Batch Precompile tutorial.</p> <p>For demonstration purposes, we'll be using Remix to visualize and construct our calldata. If needed, the Batch Precompile page offers a step-by-step guide for getting started with the Batch Precompile in Remix.</p> <p>To quickly get started, go ahead and copy <code>Batch.sol</code> and compile it. From the Deploy tab of Remix, specify your environment in Remix as Injected Web3 and make sure your wallet is on the Moonbase Alpha network. As it is a precompile, we won't be deploying anything but rather will access the Batch Precompile at its respective address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000808\n</code></pre> <pre><code>0x0000000000000000000000000000000000000808\n</code></pre> <pre><code>0x0000000000000000000000000000000000000808\n</code></pre> <p>After inputting the address and pressing At Address, take the following steps to prepare the batch calls:</p> <ol> <li>Expand the batchAll or another desired method of the Batch Precompile</li> <li>In the To field, place the addresses of the MARS and NEPT contracts enclosed in quotes and separated by a comma. The entire line should be wrapped in brackets as follows:  <code>[\"0x1FC56B105c4F0A1a8038c2b429932B122f6B631f\",\"0xed13B028697febd70f34cf9a9E280a8f1E98FD29\"]</code></li> <li>Provide an empty array (<code>[]</code>) in the value field. We don't want to send any tokens to the contracts, as they are not payable contracts</li> <li>In the <code>callData</code> field, provide the following: <code>[\"0x2004ffd9\",\"0x2004ffd9\"]</code>. Note that you need to provide the calldata for each call, even if the calldata is identical, like it is with both <code>mint</code> calls</li> <li>Optionally, you could specify a gas limit, but there is no need here, so simply provide an empty array (<code>[]</code>)</li> <li>To validate that you have correctly configured the calls, you can press Transact, but don't confirm the transaction in your wallet. If you get an error, double-check that you have correctly formatted each parameter</li> <li>MetaMask should pop up, but do not sign the transaction. In MetaMask, click on the hex tab, and the encoded calldata should show up</li> <li>Click on the Copy raw transaction data button. This will copy the encoded calldata of the batch call to the clipboard</li> </ol> <p></p> <p>We've now finished preparing our EVM calldata for the batch call. Next, we'll need to prepare the XCM instructions that will execute our remote batch call.</p>"},{"location":"tutorials/interoperability/remote-batched-evm-calls/#generating-the-moonbeam-encoded-call-data","title":"Generating the Moonbeam Encoded Calldata","text":"<p>Now that we have the batch EVM calldata that contains the two mint commands, we need to generate the bytes that the <code>Transact</code> XCM instruction from the XCM message will execute. Note that these bytes represent the action that will be executed in the remote chain. In this example, we want the XCM message execution to enter the EVM and issue the two mint commands, from which we got the encoded calldata.</p> <p>To get the SCALE (encoding type) encoded calldata for the transaction parameters, we can leverage the following Polkadot.js API script (note that it requires <code>@polkadot/api</code>).</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\n// 1. Input Data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst batchPrecompile = '0x0000000000000000000000000000000000000808';\nconst contractCall =\n  '0x96e292b8000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000020000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f000000000000000000000000ed13b028697febd70f34cf9a9e280a8f1e98fd29000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000042004ffd90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000042004ffd9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';\n\nconst generateCallData = async () =&gt; {\n  // 2. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Estimate Gas for EVM Call\n  const gasLimit = 140000n;\n\n  // 4. Call Parameters\n  const callParams = {\n    V2: {\n      gasLimit: gasLimit + 10000n, // Estimated plus some extra gas\n      action: { Call: batchPrecompile }, // Address of the Batch Precompile\n      value: 0, // Not a payable contract\n      input: contractCall, // Batch of the 2 mint calls\n    },\n  };\n\n  // 5. Create the Extrinsic\n  const tx = api.tx.ethereumXcm.transact(callParams);\n\n  // 6. Get SCALE Encoded Calldata\n  const encodedCall = tx.method.toHex();\n  console.log(`Encoded Calldata: ${encodedCall}`);\n\n  api.disconnect();\n};\n\ngenerateCallData();\n</code></pre> <p>Note</p> <p>You can also get the SCALE encoded calldata by manually building the extrinsic in Polkadot.js Apps.</p> <p>Let's go through each of the main components of the snippet shown above:</p> <ol> <li>Provide the input data for the request. This includes: <ul> <li>Moonbase Alpha endpoint URL to create the providers</li> <li>Address of the Batch Precompile</li> <li>Encoded calldata for the batch call that contains both mint commands</li> </ul> </li> <li>Create the necessary providers. One is a Polkadot.js API provider, through which we can call Moonbeam pallets directly</li> <li>Here, we are hardcoding the gas limit for simplicity and to avoid gas estimation issues as a result of the Batch Precompile</li> <li>Build the remote EVM call containing the batch call</li> <li>Create the Ethereum XCM pallet call to the <code>transact</code> method, providing the call parameters specified above</li> <li>Get the SCALE calldata of the specific transaction parameter, which we need to provide to the <code>Transact</code> XCM instruction later on. Note that in this particular scenario, because we need only the calldata of the transaction parameters, we have to use <code>tx.method.toHex()</code></li> </ol> <p>Once you have the code set up, you can execute it with <code>node</code>, and you'll get the Moonbase Alpha remote EVM calldata:</p> node generate-encoded-calldata.js Encoded Calldata: 0x260001f0490200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008080000000000000000000000000000000000000000000000000000000000000000110896e292b8000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000020000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f000000000000000000000000ed13b028697febd70f34cf9a9e280a8f1e98fd29000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000042004ffd90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000042004ffd900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 <p>The encoded calldata for this example is:</p> <pre><code>0x260001f0490200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008080000000000000000000000000000000000000000000000000000000000000000110896e292b8000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000020000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f000000000000000000000000ed13b028697febd70f34cf9a9e280a8f1e98fd29000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000042004ffd90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000042004ffd900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n</code></pre> <p>And that is it! You have everything you need to start crafting the XCM message itself! It has been a long journey, but we are almost there.</p>"},{"location":"tutorials/interoperability/remote-batched-evm-calls/#building-the-xcm-message-relay-chain","title":"Building the XCM Message from the Relay Chain","text":"<p>We are almost in the last part of this tutorial! In this section, we'll craft the XCM message using the Polkadot.js API. We'll also break down the message instruction by instruction to understand what is happening each step of the way.</p> <p>The XCM message we are about to build is composed of the following instructions:</p> <ul> <li><code>WithdrawAsset</code> \u2014 takes funds from the account dispatching the XCM in the destination chain and puts them in holding where they can be used for later actions</li> <li><code>BuyExecution</code> \u2014 buy a certain amount of block execution time</li> <li><code>Transact</code> \u2014 use part of the block execution time bought with the previous instruction to execute some arbitrary bytes</li> <li><code>DepositAsset</code> \u2014 takes assets from holding and deposits them to a given account</li> </ul> <p>To build the XCM message, which will initiate the remote EVM call through XCM, and get its SCALE encoded calldata, you can use the following snippet:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\n// 1. Input Data\nconst providerWsURL =\n  'wss://relay.api.moonbase.moonbeam.network';\nconst amountToWithdraw = BigInt(1 * 10 ** 16); // 0.01 DEV\nconst devMultiLocation = {\n  parents: 0,\n  interior: { X1: { PalletInstance: 3 } },\n};\nconst weightTransact = 43500000000n; // 25000 * Gas limit of EVM call\nconst multiLocAccount = '0xf0615483cbe76f5b2aa80a8ce2b2e9a8206deb65'; // REPLACE with your Computed Origin account\nconst transactBytes =\n  '0x260001f0490200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008080000000000000000000000000000000000000000000000000000000000000000110896e292b8000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000020000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f000000000000000000000000ed13b028697febd70f34cf9a9e280a8f1e98fd29000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000042004ffd90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000042004ffd900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';\n\n// 2. XCM Destination (Moonbase Alpha Parachain ID 1000)\nconst dest = { V4: { parents: 0, interior: { X1: [{ Parachain: 1000 }] } } };\n\n// 3. XCM Instruction 1\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { Concrete: devMultiLocation },\n      fun: { Fungible: amountToWithdraw },\n    },\n  ],\n};\n\n// 4. XCM Instruction 2\nconst instr2 = {\n  BuyExecution: {\n    fees: {\n      id: { Concrete: devMultiLocation },\n      fun: { Fungible: amountToWithdraw },\n    },\n    weightLimit: { Unlimited: null },\n  },\n};\n\n// 5. XCM Instruction 3\nconst instr3 = {\n  Transact: {\n    originKind: 'SovereignAccount',\n    requireWeightAtMost: { refTime: weightTransact, proofSize: 200000n },\n    call: {\n      encoded: transactBytes,\n    },\n  },\n};\n\n// 6. XCM Instruction 4\nconst instr4 = {\n  DepositAsset: {\n    assets: { Wild: 'All' },\n    beneficiary: {\n      parents: 0,\n      interior: { X1: [{ AccountKey20: { key: multiLocAccount } }] },\n    },\n  },\n};\n\n// 7. Build XCM Message\nconst message = { V4: [instr1, instr2, instr3, instr4] };\n\nconst generateCallData = async () =&gt; {\n  // 8. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 9. Create the Extrinsic\n  const tx = api.tx.xcmPallet.send(dest, message);\n\n  // 10. Get SCALE Encoded Calldata\n  const encodedCall = tx.toHex();\n  console.log(`Encoded Calldata: ${encodedCall}`);\n\n  api.disconnect();\n};\n\ngenerateCallData();\n</code></pre> <p>Note</p> <p>You can also get the SCALE encoded calldata by manually building the extrinsic in Polkadot.js Apps.</p> <p>Let's go through each of the main components of the snippet shown above:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>Moonbase relay chain endpoint URL to create the provider</li> <li>Amount of tokens (in Wei) to withdraw from the Computed Origin account. For this example, <code>0.01</code> tokens are more than enough. To understand how to get this value, please refer to the XCM fee page</li> <li>The multilocation of the DEV token, as seen by Moonbase Alpha</li> <li>The weight for the <code>transact</code> XCM instruction. This can be obtained by multiplying <code>25000</code> by the gas limit obtained before. It is recommended to add approximately 10% more of the estimated value. You can read more about this value on the Remote EVM Calls through XCM page</li> <li>The Computed Origin account, as it will be needed later for an XCM instruction</li> <li>The bytes for the <code>transact</code> XCM instruction that we calculated in the previous section</li> </ul> </li> <li>Define the destination multilocation for the XCM message. In this case, it is the Moonbase Alpha parachain</li> <li>First XCM instruction, <code>WithdrawAsset</code>. You need to provide the asset multilocation and the amount you want to withdraw. Both variables were already described before</li> <li>Second XCM instruction, <code>BuyExecution</code>. Here, we are paying for Moonbase Alpha block execution time in DEV tokens by providing its multilocation and the amount we took out with the previous instruction. Next, we are buying all the execution we can (<code>Unlimited</code> weight) with <code>0.01 DEV</code> tokens which should be around 20 billion weight units, plenty for our example</li> <li>Third XCM instruction, <code>Transact</code>. The instruction will use a portion of the weight bought (defined as <code>requireWeightAtMost</code>) and execute the arbitrary bytes that are provided (<code>transactBytes</code>)</li> <li>Fourth XCM instruction, <code>DepositAsset</code>. Whatever is left in holding after the actions executed before (in this case, it should be only DEV tokens) is deposited into the Computed Origin account, set as the <code>beneficiary</code>.</li> <li>Build the XCM message by concatenating the instructions inside a <code>V3</code> array</li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>xcmPallet.send</code> extrinsic with the destination and XCM message. This method will append the <code>DescendOrigin</code> XCM instruction to our XCM message, and it is the instruction that will provide the necessary information to calculate the Computed Origin account</li> <li>Get the SCALE encoded calldata. Note that in this particular scenario, because we need the full SCALE encoded calldata, we have to use <code>tx.toHex()</code>. This is because we will submit this transaction using the calldata</li> </ol> <p>Once you have the code set up, you can execute it with <code>node</code>, and you'll get the relay chain XCM calldata:</p> node build-xcm-message.js Encoded Calldata: 0xb50a04630004000100a10f041000040000000f0000c16ff28623130000000f0000c16ff28623000601070053cd200a02350c007d09260001f0490200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008080000000000000000000000000000000000000000000000000000000000000000110896e292b8000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000020000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f000000000000000000000000ed13b028697febd70f34cf9a9e280a8f1e98fd29000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000042004ffd90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000042004ffd9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d010000010300f0615483cbe76f5b2aa80a8ce2b2e9a8206deb65 <p>The encoded calldata for this example is:</p> <pre><code>0xb50a04630004000100a10f041000040000000f0000c16ff28623130000000f0000c16ff28623000601070053cd200a02350c007d09260001f0490200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008080000000000000000000000000000000000000000000000000000000000000000110896e292b8000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000020000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f000000000000000000000000ed13b028697febd70f34cf9a9e280a8f1e98fd29000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000042004ffd90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000042004ffd9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d010000010300f0615483cbe76f5b2aa80a8ce2b2e9a8206deb65\n</code></pre> <p>Note</p> <p>The encoded calldata for you should be slightly different, as you should have replaced the Computed Origin account in the script with the one you created in the Calculating Your Computed Origin Account section.</p> <p>Now that we have the SCALE encoded calldata, the last step is to submit the transaction, which will send our XCM message to Moonbase Alpha, and do the remote batch EVM call!</p>"},{"location":"tutorials/interoperability/remote-batched-evm-calls/#send-xcm-message-relay-chain","title":"Sending the XCM Message from the Relay Chain","text":"<p>Congratulations on making it here, you're almost done! Let's recap what we've done so far:</p> <ul> <li>We've created a relay chain account that is funded with UNIT tokens (relay chain native tokens)</li> <li>We determined its Computed Origin account on Moonbase Alpha and funded this new address with DEV tokens</li> <li>We obtained the Batch Precompile calldata which combines two mint calls for MARS and NEPT ERC-20 tokens</li> <li>We built the SCALE encoded calldata in Moonbase Alpha to access its EVM via XCM</li> <li>We crafted our transaction to send an XCM message to Moonbase Alpha, in which we will ask it to execute the SCALE encoded calldata that was previously built. This, in turn, will execute the call to the Batch Precompile which includes the mint calls for both the MARS and NEPT ERC-20 tokens!</li> </ul> <p>To send the XCM message that we built in the previous section, you can use the following code snippet:</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\n// 1. Input Data\nconst providerWsURL =\n  'wss://relay.api.moonbase.moonbeam.network';\nconst MNEMONIC = 'INSERT_MNEMONIC'; // Not safe, only for testing\nconst txCall =\n  '0xb50a04630004000100a10f041000040000000f0000c16ff28623130000000f0000c16ff28623000601070053cd200a02350c007d09260001f0490200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008080000000000000000000000000000000000000000000000000000000000000000110896e292b8000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000020000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f000000000000000000000000ed13b028697febd70f34cf9a9e280a8f1e98fd29000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000042004ffd90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000042004ffd9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d010000010300f0615483cbe76f5b2aa80a8ce2b2e9a8206deb65';\n\nconst sendXCM = async () =&gt; {\n  // 2. Create Keyring Instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'sr25519' });\n  const alice = keyring.addFromUri(MNEMONIC);\n\n  // 3. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 4. Create the Extrinsic\n  const tx = await api.tx(txCall).signAndSend(alice, (result) =&gt; {\n    // 5. Check Transaction Status\n    console.log(`Transaction sent`);\n    if (result.status.isInBlock) {\n      console.log(\n        `Transaction included in blockHash ${result.status.asInBlock}`\n      );\n    }\n  });\n\n  api.disconnect();\n};\n\nsendXCM();\n</code></pre> <p>Once you have the code set up, you can execute it with <code>node</code>, and the XCM message will be sent to initiate your call to the Batch Precompile for the mints of MARS and NEPT ERC-20 tokens in Moonbase Alpha. Don't worry if you see an <code>Abnormal Closure</code> error. You can verify that your remote batch call was successful by looking up your Computed Origin account on Moonbase Moonscan.</p> node send-xcm-message.js Transaction sent Transaction sent <p>And that is it! You've sent an XCM message, which performed a remote EVM call to the Batch Precompile via XCM and resulted in the minting of MARS and NEPT ERC-20 tokens. But let's go into more detail about what happened.</p> <p>This action will emit different events. The first one is only relevant in the relay chain, and it is named <code>xcmPallet.Sent</code>, which is from the <code>xcmPallet.send</code> extrinsic. In Moonbase Alpha, the following events emitted by the <code>parachainSystem.setValidationData</code> extrinsic (where all the inbound XCM messages are processed) are of interest:</p> <ul> <li><code>parachainSystem.DownwardMessagesReceived</code> \u2014 states that there was an XCM message received</li> <li><code>evm.Log</code> \u2014 internal events emitted by the different contract calls. The structure is the same: contract address, topics, and relevant data</li> <li><code>ethereum.Executed</code> \u2014 contains information on the <code>from</code> address, the <code>to</code> address, and the transaction hash of an EVM call done</li> <li><code>polkadotXcm.AssetsTrapped</code> \u2014 flags that some assets were in holding and were not deposited to a given address. If the <code>Transact</code> XCM instruction does not exhaust the tokens allocated to it, it will execute a <code>RefundSurplus</code> after the XCM is processed. This instruction will take any leftover tokens from the execution bought and put them in holding. We could prevent this by adjusting the fee provided to the <code>Transact</code> instruction or by adding the instruction right after the <code>Transact</code></li> <li><code>dmpQueue.ExecutedDownward</code> \u2014 states the result of executing a message received from the relay chain (a DMP message). In this case, the <code>outcome</code> is marked as <code>Complete</code></li> </ul> <p>Our XCM was successfully executed! If you visit Moonbase Alpha Moonscan and search for the transaction hash, you'll find the call to the Batch Precompile that was executed via the XCM message. Note that you can only call the <code>mint</code> commands once per hour per planet. If you wish to experiment further and make additional mint calls, simply change the destination contract address to a different planet when configuring the batch call.</p> <p>Challenge</p> <p>Use the Batch Precompile and remote EVM calls via XCM to combine an approval and a Uniswap V2 swap of MARS for any other token you want. As a thought experiment, consider carefully which method of the Batch Precompile is best suited to combine an approval and a swap transaction. Both the Uniswap V2 Swap from Polkadot via XCM tutorial and the Batch Precompile tutorial are great resources to help you get started.</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production."},{"location":"tutorials/interoperability/remote-staking-xcm/","title":"Remote Staking via XCM","text":"<p>by Kevin Neilson</p>"},{"location":"tutorials/interoperability/remote-staking-xcm/#introduction","title":"Introduction","text":"<p>In this tutorial, we\u2019ll stake DEV tokens remotely by sending XCM instructions from an account on the Moonbase relay chain (equivalent to the Polkadot relay chain). This tutorial assumes a basic familiarity with XCM and Remote Execution via XCM. You don\u2019t have to be an expert on these topics but you may find it helpful to have some XCM knowledge as background.</p> <p>There are actually two possible approaches for staking on Moonbeam remotely via XCM. We could send a remote EVM call that calls the staking precompile, or we could use XCM to call the parachain staking pallet directly without interacting with the EVM. For this tutorial, we\u2019ll be taking the latter approach and interacting with the parachain staking pallet directly.</p> <p>Note that there are still limitations in what you can remotely execute through XCM messages. In addition, developers must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, it is essential to test XCM features on a TestNet before moving to a production environment.</p>"},{"location":"tutorials/interoperability/remote-staking-xcm/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For development purposes this tutorial is written for Moonbase Alpha and Moonbase relay using TestNet funds. For prerequisites:</p> <ul> <li>A Moonbase Alpha relay chain account funded with some UNIT, the native token of the Moonbase relay chain. If you have a Moonbase Alpha account funded with DEV tokens, you can swap some DEV for xcUNIT here on Moonbeam Swap. Then withdraw the xcUNIT from Moonbase Alpha to your account on the Moonbase relay chain using apps.moonbeam.network</li> <li>You'll need to calculate the Computed Origin account of your Moonbase Alpha relay chain account and fund it with DEV tokens. You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"tutorials/interoperability/remote-staking-xcm/#calculating-your-computed-origin-account","title":"Calculating your Computed Origin Account","text":"<p>Copy the account of your existing or newly created account on the Moonbase relay chain. You're going to need it to calculate the corresponding Computed Origin account, which is a special type of account that\u2019s keyless (the private key is unknown). Transactions from a Computed Origin account can be initiated only via valid XCM instructions from the corresponding account on the relay chain. In other words, you are the only one who can initiate transactions on your Computed Origin account, and if you lose access to your Moonbase relay account, you\u2019ll also lose access to your Computed Origin account.</p> <p>To generate the Computed Origin account, first clone the xcm-tools repo. Run <code>yarn</code> to install the necessary packages, and then run:</p> <pre><code>yarn calculate-multilocation-derivative-account \\\n--ws-provider wss://wss.api.moonbase.moonbeam.network \\\n--address INSERT_MOONBASE_RELAY_ACCOUNT \\\n--para-id INSERT_ORIGIN_PARACHAIN_ID_IF_APPLIES \\\n--parents INSERT_PARENTS_VALUE_IF_APPLIES\n</code></pre> <p>Let's review the parameters passed along with this command:</p> <ul> <li>The <code>--ws-provider</code> or <code>-w</code> flag corresponds to the endpoint we\u2019re using to fetch this information</li> <li>The <code>--address</code> or <code>-a</code> flag corresponds to your Moonbase relay chain address</li> <li>The <code>--para-id</code> or <code>-p</code> flag corresponds to the parachain ID of the origin chain (if applicable). If you are sending the XCM from the relay chain, you don't need to provide this parameter</li> <li>The <code>-parents</code> flag corresponds to the parents value of the origin chain in relation to the destination chain. If you're deriving a multi-location derivative account on a parachain destination from a relay chain origin, this value would be <code>1</code>. If left out, the parents value defaults to <code>0</code></li> </ul> <p>Here, we have specified a parents value of <code>1</code> because the relay chain is the origin of the request (and the relay chain is considered a parent to the Moonbase alpha parachain). The relay chain does not have a parachain id so that field is omitted.</p> yarn calculate-multilocation-derivative-account \\ --ws-provider wss://wss.api.moonbase.moonbeam.network \\ --address 5DCvkTpkqo5AuvUFSrT76ABnm48iSBHpgsoDFNxFZAtesvWD \\ --parents 1 yarn run v1.22.10 warning ../../../package.json: No license field $ ts-node 'scripts/calculate-multilocation-derivative-account.ts' --ws-provider wss://wss.api.moonbase.moonbeam.network --address 5DCvkTpkqo5AuvUFSrT76ABnm48iSBHpgsoDFNxFZAtesvWD --parents 1 Remote Origin calculated as ParentChain Parents 1 AccountId32: 5DCvkTpkqo5AuvUFSrT76ABnm48iSBHpgsoDFNxFZAtesvWD 32 byte address is 0x55738eb7227f27c9d55775f65ad261c5ac2894dcde73d913f77f69bf51e26279 20 byte address is 0x55738eb7227f27c9d55775f65ad261c5ac2894dc \u2728  Done in 1.02s. <p>The script will return 32-byte and 20-byte addresses. We\u2019re interested in the Ethereum-style account - the 20-byte one. Feel free to look up your Computed Origin account on Moonscan. You\u2019ll note that this account is empty. You\u2019ll now need to fund this account with at least 1.1 DEV which you can get from the faucet. And if you need more, you can always reach out to us on Discord for additional DEV tokens.</p>"},{"location":"tutorials/interoperability/remote-staking-xcm/#preparing-to-stake-on-moonbase-alpha","title":"Preparing to Stake on Moonbase Alpha","text":"<p>First and foremost, you\u2019ll need the address of the collator you want to delegate to. To locate it, head to the Moonbase Alpha Staking dApp in a second window. Ensure you\u2019re on the correct network, then press Select a Collator. Press the icon next to your desired collator to copy its address. You\u2019ll also need to make a note of the number of delegations your collator has. The Moonbeam Foundation 01 collator shown below has <code>7</code> delegations at the time of writing.</p> <p></p>"},{"location":"tutorials/interoperability/remote-staking-xcm/#remote-staking-via-xcm-with-the-polkadot-api","title":"Remote Staking via XCM with the Polkadot.js API","text":"<p>This tutorial will cover the two-step process to perform remote staking operations. The first step we'll take is to generate the encoded call data for delegating a collator. Secondly, we'll send the encoded call data via XCM from the relay chain to Moonbase Alpha, which will result in the execution of the delegation.</p>"},{"location":"tutorials/interoperability/remote-staking-xcm/#generate-encoded-call-data","title":"Generate the Encoded Call Data","text":"<p>We'll be using the <code>delegateWithAutoCompound</code> function of the Parachain Staking Pallet, which accepts six parameters: <code>candidate</code>, <code>amount</code>, <code>autoCompound</code>, <code>candidateDelegationCount</code>, <code>candidateAutoCompoundingDelegationCount</code>, and <code>delegationCount</code>.</p> <p>In order to generate the encoded call data, we'll need to assemble the arguments for each of the <code>delegateWithAutoCompound</code> parameters and use them to build a transaction which will call the <code>delegateWithAutoCompound</code> function. We are not submitting a transaction, but simply preparing one to get the encoded call data. We'll take the following steps to build our script:</p> <ol> <li>Create a Polkadot.js API provider</li> <li> <p>Assemble the arguments for each of the parameters of the <code>delegateWithAutoCompound</code> function:</p> <ul> <li><code>candidate</code>- for this example we'll use the Moonbeam Foundation 01 collator: <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>. To retrieve the entire list of candidates, you can refer back to the Preparing to Stake section</li> <li><code>amount</code> - we'll stake the minimum amount, which is 1 DEV or <code>1000000000000000000</code> Wei. You can find a unit converter on Moonscan</li> <li><code>autoCompound</code> - we'll set this to <code>100</code> to auto-compound all rewards</li> <li><code>candidateDelegationCount</code> - we'll retrieve using the <code>candidateInfo</code> function of the Parachain Staking Pallet to get the exact count. Alternatively, you can enter the upper bound of <code>300</code> because this estimation is only used to determine the weight of the call</li> <li><code>candidateAutoCompoundingDelegationCount</code> - we'll retrieve using the <code>autoCompoundingDelegations</code> function of the Parachain Staking Pallet to get the exact count. Alternatively, you can enter the upper bound of <code>300</code> because this estimation is only used to determine the weight of the call</li> <li><code>delegationCount</code> - we'll retrieve using the <code>delegatorState</code> function of the Parachain Staking Pallet to get the exact count. Alternatively, you can specify an upper bound here of <code>100</code></li> </ul> </li> <li> <p>Craft the <code>parachainStaking.delegateWithAutoCompound</code> extrinsic with each of the required arguments</p> </li> <li>Use the transaction to get the encoded call data for the delegation</li> </ol> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nconst provider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n\nconst candidate = '0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5';\nconst amount = '1000000000000000000';\nconst autoCompound = 100;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({ provider: provider });\n\n  // Fetch your existing number of delegations\n  let delegatorDelegationCount;\n  const delegatorInfo = await api.query.parachainStaking.delegatorState(\n    'INSERT_ACCOUNT' // Use the account you're delegating with\n  );\n\n  if (delegatorInfo.toHuman()) {\n    delegatorDelegationCount = delegatorInfo.toHuman()['delegations'].length;\n  } else {\n    delegatorDelegationCount = 0;\n  }\n\n  // Fetch the collators existing delegations\n  const collatorInfo = await api.query.parachainStaking.candidateInfo(\n    candidate\n  );\n  const candidateDelegationCount = collatorInfo.toHuman()['delegationCount'];\n\n  // Fetch the collators number of existing auto-compounding delegations\n  const autoCompoundingDelegationsInfo =\n    await api.query.parachainStaking.autoCompoundingDelegations(candidate);\n  const candidateAutoCompoundingDelegationCount =\n    autoCompoundingDelegationsInfo.length;\n\n  // Craft extrinsic\n  const tx = api.tx.parachainStaking.delegateWithAutoCompound(\n    candidate,\n    amount,\n    autoCompound,\n    candidateDelegationCount,\n    candidateAutoCompoundingDelegationCount,\n    delegatorDelegationCount\n  );\n\n  // Get SCALE encoded call data\n  const encodedCall = tx.method.toHex();\n  console.log(`Encoded Call Data: ${encodedCall}`);\n\n  api.disconnect();\n};\nmain();\n</code></pre> <p>Note</p> <p>If running this as a TypeScript project, be sure to set the <code>strict</code> flag under <code>compilerOptions</code> to <code>false</code> in your <code>tsconfig.json</code>.</p> <p>If you'd prefer not to set up a local environment, you can run a code snippet in the JavaScript console of Polkadot.js Apps.</p> Code to run in the Polkadot.js Apps JavaScript console <pre><code>const candidate = '0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5';\nconst amount = '1000000000000000000';\nconst autoCompound = 100;\n\n// Fetch your existing number of delegations\nlet delegatorDelegationCount;\n// Use the account you're delegating with\nconst delegatorInfo = await api.query.parachainStaking.delegatorState(\n  'INSERT_ACCOUNT'\n);\n\nif (delegatorInfo.toHuman()) {\n  delegatorDelegationCount = delegatorInfo.toHuman()['delegations'].length;\n} else {\n  delegatorDelegationCount = 0;\n}\n\n// Fetch the collators existing delegations\nconst collatorInfo = await api.query.parachainStaking.candidateInfo(candidate);\nconst candidateDelegationCount = collatorInfo.toHuman()['delegationCount'];\n\n// Fetch the collators number of existing auto-compounding delegations\nconst autoCompoundingDelegationsInfo =\n  await api.query.parachainStaking.autoCompoundingDelegations(candidate);\nconst candidateAutoCompoundingDelegationCount =\n  autoCompoundingDelegationsInfo.length;\n\n// Craft extrinsic\nconst tx = api.tx.parachainStaking.delegateWithAutoCompound(\n  candidate,\n  amount,\n  autoCompound,\n  candidateDelegationCount,\n  candidateAutoCompoundingDelegationCount,\n  delegatorDelegationCount\n);\n\n// Get SCALE Encoded Call Data\nconst encodedCall = tx.method.toHex();\nconsole.log(`Encoded Call Data: ${encodedCall}`);\n</code></pre>"},{"location":"tutorials/interoperability/remote-staking-xcm/#sending-the-xcm-instructions-via-the-polkadot-api","title":"Assemble and Send XCM Instructions via the Polkadot.js API","text":"<p>In this section, we'll be using the Polkadot.js API to construct and send XCM instructions via the <code>send</code> extrinsic of the XCM Pallet on the Moonbase relay chain. The XCM message will transport our remote execution instructions to the Moonbase Alpha parachain to ultimately stake our desired amount of DEV tokens to a chosen collator.</p> <p>The <code>send</code> function of the XCM Pallet accepts two parameters: <code>dest</code> and <code>message</code>. You can start assembling these parameters by taking the following steps:</p> <ol> <li> <p>Build the multilocation of the DEV token on Moonbase Alpha for the <code>dest</code>:</p> <pre><code>const dest = { V4: { parents: 0, interior: { X1: [{ Parachain: 1000 }] } } };\n</code></pre> </li> <li> <p>Build the <code>WithdrawAsset</code> instruction, which will require you to define:</p> <ul> <li>The multilocation of the DEV token on Moonbase Alpha</li> <li>The amount of DEV tokens to withdraw</li> </ul> <pre><code>const instr1 = {\n  WithdrawAsset: [\n    {\n      id: {\n        parents: 0,\n        interior: { X1: [{ PalletInstance: 3 }] },\n      },\n      fun: { Fungible: 100000000000000000n },\n    },\n  ],\n};\n</code></pre> </li> <li> <p>Build the <code>BuyExecution</code> instruction, which will require you to define:</p> <ul> <li>The multilocation of the DEV token on Moonbase Alpha</li> <li>The amount of DEV tokens to buy for execution</li> <li>The weight limit</li> </ul> <pre><code>const instr2 = {\n  BuyExecution: [\n    {\n      id: {\n        parents: 0,\n        interior: { X1: [{ PalletInstance: 3 }] },\n      },\n      fun: { Fungible: 100000000000000000n },\n    },\n    { Unlimited: null },\n  ],\n};\n</code></pre> </li> <li> <p>Build the <code>Transact</code> instruction, which will require you to define:</p> <ul> <li>The origin type, which will be <code>SovereignAccount</code></li> <li>The required weight for the transaction. You'll need to define a value for <code>refTime</code>, which is the amount of computational time that can be used for execution, and the <code>proofSize</code>, which is the amount of storage in bytes that can be used. It is recommended that the weight given to this instruction needs to be around 10% more of <code>25000</code> times the gas limit for the call you want to execute via XCM</li> <li>The encoded call data for delegating a collator, which we generated in the previous section</li> </ul> <pre><code>const instr3 = {\n  Transact: {\n    originKind: 'SovereignAccount',\n    requireWeightAtMost: { refTime: 40000000000n, proofSize: 900000n },\n    call: {\n      encoded:\n        '0x0c1212e7bcca9b1b15f33585b5fc898b967149bdb9a5000064a7b3b6e00d000000000000000064070000000700000000000000',\n    },\n  },\n};\n</code></pre> </li> <li> <p>Combine the XCM instructions into a versioned XCM message:</p> <pre><code>const message = { V4: [instr1, instr2, instr3] };\n</code></pre> </li> </ol> <p>Now that you have the values for each of the parameters, you can write the script to send the XCM message. You'll take the following steps:</p> <ol> <li>Provide the values for each of the parameters of the <code>send</code> function</li> <li>Create the Polkadot.js API provider using the WSS endpoint of the Alphanet relay chain</li> <li>Create a Keyring instance using the mnemonic of your relay chain account, which will be used to send the transaction</li> <li>Craft the <code>xcmPallet.send</code> extrinsic with the <code>dest</code> and <code>message</code></li> <li>Send the transaction using the <code>signAndSend</code> extrinsic and the Keyring instance you created in the third step</li> </ol> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a JavaScript file.</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\nconst privateKey = 'INSERT_PRIVATE_KEY_OR_MNEMONIC';\n\n// 1. Define the dest and message arguments\nconst dest = { V4: { parents: 0, interior: { X1: [{ Parachain: 1000 }] } } };\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: {\n        parents: 0,\n        interior: { X1: [{ PalletInstance: 3 }] },\n      },\n      fun: { Fungible: 100000000000000000n },\n    },\n  ],\n};\nconst instr2 = {\n  BuyExecution: [\n    {\n      id: {\n        parents: 0,\n        interior: { X1: [{ PalletInstance: 3 }] },\n      },\n      fun: { Fungible: 100000000000000000n },\n    },\n    { Unlimited: null },\n  ],\n};\nconst instr3 = {\n  Transact: {\n    originKind: 'SovereignAccount',\n    requireWeightAtMost: { refTime: 40000000000n, proofSize: 900000n },\n    call: {\n      encoded:\n        '0x0c1212e7bcca9b1b15f33585b5fc898b967149bdb9a5000064a7b3b6e00d000000000000000064070000000700000000000000',\n    },\n  },\n};\nconst message = { V4: [instr1, instr2, instr3] };\n\nconst performRemoteDelegation = async () =&gt; {\n  // 2. Construct API provider\n  const wsProvider = new WsProvider(\n    'wss://relay.api.moonbase.moonbeam.network'\n  );\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // 3. Initialize wallet key pairs\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'sr25519' });\n  // For demo purposes only. Never store your private key or mnemonic in a JavaScript file\n  const otherPair = keyring.addFromUri(privateKey);\n  console.log(`Derived Address from Private Key: ${otherPair.address}`);\n\n  // 4. Define the transaction using the send method of the xcm pallet\n  const tx = api.tx.xcmPallet.send(dest, message);\n\n  // 5. Sign and send the transaction\n  const txHash = await tx.signAndSend(otherPair);\n  console.log(`Submitted with hash ${txHash}`);\n\n  api.disconnect();\n};\n\nperformRemoteDelegation();\n</code></pre> <p>Note</p> <p>Remember that your Computed Origin account must be funded with at least 1.1 DEV or more to ensure you have enough to cover the stake amount and transaction fees.</p> <p>In the above snippet, besides submitting the remote staking via XCM transaction, we also print out the transaction hash to assist with any debugging.</p> <p>And that\u2019s it! To verify that your delegation was successful, you can visit Subscan to check your staking balance. Be advised that it may take a few minutes before your staking balance is visible on Subscan. Additionally, be aware that you will not be able to see this staking operation on Moonscan, because we initiated the delegation action directly via the Parachain Staking Pallet (on the Substrate side) rather than through the Staking Precompile (on the EVM).</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production."},{"location":"tutorials/interoperability/uniswapv2-swap-xcm/","title":"Uniswap V2 Swap from Polkadot via XCM","text":"<p>by Alberto Viera</p>"},{"location":"tutorials/interoperability/uniswapv2-swap-xcm/#introduction","title":"Introduction","text":"<p>In this tutorial, we\u2019ll perform a Uniswap V2-styled swap from a relay chain (what Polkadot is to Moonbeam) using Polkadot's interoperability general message passing protocol called XCM. To do so, we'll be using a particular combination of XCM instructions that allow you to call Moonbeam's EVM through an XCM message. Consequently, any blockchain that is able to send an XCM message to Moonbeam can tap into its EVM and all the dApps built on top of it.</p> <p>The content of this tutorial is for educational purposes only!</p> <p>For this example, you'll be working on top of the Moonbase Alpha (Moonbeam TestNet), which has its own relay chain (similar to Polkadot). The relay chain token is called <code>UNIT</code>, while Moonbase Alpha's is called <code>DEV</code>. Doing this in TestNet is less fun than doing it in production, but developers must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, it is essential to test XCM features on a TestNet before moving to a production environment.</p> <p>Throughout this tutorial, we will refer to the account performing the Uniswap V2 swap via XCM as Alice. The tutorial has a lot of moving parts, so let's summarize them in a list and a flow diagram:</p> <ol> <li>Alice has an account on the relay chain, and she wants to swap <code>DEV</code> tokens for <code>MARS</code> tokens (ERC-20 on Moonbase Alpha) on Moonbeam-Swap, a demo Uniswap V2 clone on Moonbase Alpha. Alice needs to send an XCM message to Moonbase Alpha from her relay chain account</li> <li>The XCM message will be received by Moonbase Alpha and its instructions executed. The instructions state Alice's intention to buy some block execution time in Moonbase Alpha and execute a call to Moonbase's EVM, specifically, the Uniswap V2 (Moonbeam-Swap) router contract. The EVM call is dispatched through a special account Alice controls on Moonbase Alpha via XCM messages. This account is known as the Computed Origin account. Even though this is a keyless account (private key is unknown), the public address can be calculated in a deterministic way</li> <li>The XCM execution will result in the swap being executed by the EVM, and Alice will receive her <code>MARS</code> tokens in her special account</li> <li>The execution of the remote EVM call through XCM will result in some EVM logs that are picked up by explorers. There is an EVM transaction and receipt that anyone can query to verify</li> </ol> <p></p> <p>With the steps outlined, some prerequisites need to be taken into account, let's jump right into it!</p>"},{"location":"tutorials/interoperability/uniswapv2-swap-xcm/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Considering all the steps summarized in the introduction, the following prerequisites need to be accounted for:</p> <ul> <li>You need to have UNITs on the relay chain to pay for transaction fees when sending the XCM. If you have a Moonbase Alpha account funded with DEV tokens, you can swap some DEV for xcUNIT here on Moonbeam Swap. Then withdraw the xcUNIT from Moonbase Alpha to your account on the Moonbase relay chain using apps.moonbeam.network</li> <li>Your Computed Origin account must hold <code>DEV</code> tokens to fund the Uniswap V2 swap, and also pay for the XCM execution (although this could be paid in UNIT tokens as <code>xcUNIT</code>). We will calculate the Computed Origin account address in the next section</li> </ul> <p>You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</p>"},{"location":"tutorials/interoperability/uniswapv2-swap-xcm/#calculating-your-computed-origin-account","title":"Calculating your Computed Origin Account","text":"<p>Copy the account of your existing or newly created account on the Moonbase relay chain. You're going to need it to calculate the corresponding Computed Origin account, which is a special type of account that\u2019s keyless (the private key is unknown). Transactions from a Computed Origin account can be initiated only via valid XCM instructions from the corresponding account on the relay chain. In other words, you are the only one who can initiate transactions on your Computed Origin account, and if you lose access to your Moonbase relay account, you\u2019ll also lose access to your Computed Origin account.</p> <p>To generate the Computed Origin account, first clone the xcm-tools repo. Run <code>yarn</code> to install the necessary packages, and then run:</p> <pre><code>yarn calculate-multilocation-derivative-account \\\n--ws-provider wss://wss.api.moonbase.moonbeam.network \\\n--address INSERT_MOONBASE_RELAY_ACCOUNT \\\n--para-id INSERT_ORIGIN_PARACHAIN_ID_IF_APPLIES \\\n--parents INSERT_PARENTS_VALUE_IF_APPLIES\n</code></pre> <p>Let's review the parameters passed along with this command:</p> <ul> <li>The <code>--ws-provider</code> or <code>-w</code> flag corresponds to the endpoint we\u2019re using to fetch this information</li> <li>The <code>--address</code> or <code>-a</code> flag corresponds to your Moonbase relay chain address</li> <li>The <code>--para-id</code> or <code>-p</code> flag corresponds to the parachain ID of the origin chain (if applicable). If you are sending the XCM from the relay chain, you don't need to provide this parameter</li> <li>The <code>-parents</code> flag corresponds to the parents value of the origin chain in relation to the destination chain. If you're deriving a multi-location derivative account on a parachain destination from a relay chain origin, this value would be <code>1</code>. If left out, the parents value defaults to <code>0</code></li> </ul> <p>For our case, we will send the remote EVM call via XCM from Alice's account, which is <code>5GKh9gMK5dn9SJp6qfMNcJiMMnY7LReYmgug2Fr5fKE64imn</code>, so the command and response would look like the following image.</p> yarn calculate-multilocation-derivative-account \\ --ws-provider wss://wss.api.moonbase.moonbeam.network \\ --address 5GKh9gMK5dn9SJp6qfMNcJiMMnY7LReYmgug2Fr5fKE64imn \\ --parents 1 yarn run v1.22.10 warning ../../../package.json: No license field $ ts-node 'scripts/calculate-multilocation-derivative-account.ts' --ws-provider wss://wss.api.moonbase.moonbeam.network --address 5GKh9gMK5dn9SJp6qfMNcJiMMnY7LReYmgug2Fr5fKE64imn --parents 1 Remote Origin calculated as ParentChain Parents 1 AccountId32: 5GKh9gMK5dn9SJp6qfMNcJiMMnY7LReYmgug2Fr5fKE64imn 32 byte address is 0x61cd3e07fe7d7f6d4680e3e322986b7877f108ddb18ec02c2f17e82fe15f9016 20 byte address is 0x61cd3e07fe7d7f6d4680e3e322986b7877f108dd \u2728  Done in 1.02s. <p>The values are all summarized in the following table:</p> Name Value Origin Chain Encoded Address <code>5GKh9gMK5dn9SJp6qfMNcJiMMnY7LReYmgug2Fr5fKE64imn</code> Origin Chain Decoded Address <code>0xbc5f3c61709f218d983fc773a600958a07fb18047418df7eeb0501d0679e397a</code> Computed Origin Account (32 bytes) <code>0x61cd3e07fe7d7f6d4680e3e322986b7877f108ddb18ec02c2f17e82fe15f9016</code> Computed Origin Account (20 bytes) <code>0x61cd3e07fe7d7f6d4680e3e322986b7877f108dd</code> <p>The script will return 32-byte and 20-byte addresses. We\u2019re interested in the Ethereum-style account - the 20-byte one, which is <code>0x61cd3e07fe7d7f6d4680e3e322986b7877f108dd</code>. Feel free to look up your Computed Origin account on Moonscan. Next, you can fund this account with DEV tokens.</p> <p>You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet.</p>"},{"location":"tutorials/interoperability/uniswapv2-swap-xcm/#getting-uniswapv2-swap-calldata","title":"Getting the Uniswap V2 Swap Calldata","text":"<p>The following section will walk through the steps of getting the calldata for the Uniswap V2 swap, as we need to feed this calldata to the remote EVM call that we will build via XCM.</p> <p>The function being targeted here is one from the Uniswap V2 router, more specifically swapExactETHForTokens. This function will swap an exact amount of protocol native tokens (in this case <code>DEV</code>) for another ERC-20 token. It has the following inputs:</p> <ul> <li>Minimum amount of tokens that you expect out of the swap (accounting for slippage)</li> <li>Path that the take will trade (if there is no direct pool, the swap might be routed through multiple pair pools)</li> <li>Address of the recipient of the tokens swapped</li> <li>The deadline (in Unix time) from which the trade is no longer valid</li> </ul> <p>The easiest way to get the calldata is through the Moonbeam Uniswap V2 Demo page. Once you go in the website, take the following steps:</p> <ol> <li>Set the swap from value and token and also set the swap to token. For this example, we want to swap 1 <code>DEV</code> token for <code>MARS</code></li> <li>Click on the Swap button. Metamask should pop up, do not sign the transaction</li> <li>In Metamask, click on the hex tab, and the encoded calldata should show up</li> <li>Click on the Copy raw transaction data button. This will copy the encoded calldata to the clipboard</li> </ol> <p></p> <p>Note</p> <p>Other wallets also offer the same capabilities of checking the encoded calldata before signing the transaction.</p> <p>Once you have the encoded calldata, feel free to reject the transaction in your wallet. The swap calldata that we obtained is encoded as follows (all but the function selector are expressed in 32 bytes or 64 hexadecimal characters blobs):</p> <ol> <li>The function selector, which is 4 bytes long (8 hexadecimal characters) that represents the function you are calling</li> <li>The minimum amount out of the swap that we want accounting for slippage, in this case, <code>10b3e6f66568aaee</code> is <code>1.2035</code> <code>MARS</code> tokens</li> <li>The location (pointer) of the data part of the path parameter (which is of type dynamic). <code>80</code> in hex is <code>128</code> decimal, meaning that information about the path is presented after 128 bytes from the beginning (without counting on the function selector). Consequently, the next bit of information about the path is presented in element 6</li> <li>The address receiving the tokens after the swap, in this case, is the <code>msg.sender</code> of the call</li> <li>The deadline limit for the swap</li> <li>The length of the address array representing the path</li> <li>First token involved in the swap, which is wrapped <code>DEV</code></li> <li>Second token involved in the swap, <code>MARS</code>, so it is the last</li> </ol> <pre><code>1. 0x7ff36ab5\n2. 00000000000000000000000000000000000000000000000010b3e6f66568aaee -&gt; Min Amount Out\n3. 0000000000000000000000000000000000000000000000000000000000000080\n4. 000000000000000000000000d720165d294224a7d16f22ffc6320eb31f3006e1 -&gt; Receiving Address\n5. 0000000000000000000000000000000000000000000000000000000063dbcda5 -&gt; Deadline\n6. 0000000000000000000000000000000000000000000000000000000000000002\n7. 000000000000000000000000d909178cc99d318e4d46e7e66a972955859670e1\n8. 0000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f\n</code></pre> <p>In the calldata, we need to change three fields to ensure our swap will go through:</p> <ul> <li>The minimum amount out, to account for slippage as the pool may have a different <code>DEV/MARS</code> balance when you try this out</li> <li>The receiving address to our Computed Origin account</li> <li>The deadline to provide a bit more flexibility for our swap, so you don't have to submit this immediately</li> </ul> <p>This is OK because we are just testing things :), do not use this code in production! Our encoded calldata should look like this (the line breaks were left for visibility):</p> <pre><code>0x7ff36ab5\n0000000000000000000000000000000000000000000000000de0b6b3a7640000 -&gt; New Min Amount\n0000000000000000000000000000000000000000000000000000000000000080\n00000000000000000000000061cd3e07fe7d7f6d4680e3e322986b7877f108dd -&gt; New Address\n00000000000000000000000000000000000000000000000000000000A036B1B9 -&gt; New Deadline\n0000000000000000000000000000000000000000000000000000000000000002\n000000000000000000000000d909178cc99d318e4d46e7e66a972955859670e1\n0000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f\n</code></pre> <p>Which, as one line, is:</p> <pre><code>0x7ff36ab50000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000061cd3e07fe7d7f6d4680e3e322986b7877f108dd00000000000000000000000000000000000000000000000000000000A036B1B90000000000000000000000000000000000000000000000000000000000000002000000000000000000000000d909178cc99d318e4d46e7e66a972955859670e10000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f\n</code></pre> <p>You can also get the calldata programmatically using the Uniswap V2 SDK.</p>"},{"location":"tutorials/interoperability/uniswapv2-swap-xcm/#generating-the-moonbeam-encoded-call-data","title":"Generating the Moonbeam Encoded Calldata","text":"<p>Now that we have the Uniswap V2 swap encoded calldata, we need to generate the bytes that the <code>Transact</code> XCM instruction from the XCM message will execute. Note that these bytes represent the action that will be executed in the remote chain. In this example, we want the XCM message execution to enter the EVM and perform the swap, from which we got the encoded calldata.</p> <p>To get the SCALE (encoding type) encoded calldata for the transaction parameters, we can leverage the following Polkadot.js API script (note that it requires <code>@polkadot/api</code> and <code>ethers</code>).</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\nimport { ethers } from 'ethers'; // Version 6.12.0\nimport BN from 'bn.js'; // Importing directly from bn.js\n\n// 1. Input Data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst uniswapV2Router = '0x8a1932D6E26433F3037bd6c3A40C816222a6Ccd4';\nconst contractCall =\n  '0x7ff36ab50000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000061cd3e07fe7d7f6d4680e3e322986b7877f108dd00000000000000000000000000000000000000000000000000000000A036B1B90000000000000000000000000000000000000000000000000000000000000002000000000000000000000000d909178cc99d318e4d46e7e66a972955859670e10000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f';\n\nconst generateCallData = async () =&gt; {\n  // 2. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const ethProvider = new ethers.WebSocketProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Estimate Gas for EVM Call\n  const gasLimit = await ethProvider.estimateGas({\n    to: uniswapV2Router,\n    data: contractCall,\n    value: ethers.parseEther('0.01'),\n  });\n  console.log(`Gas required for call is ${gasLimit.toString()}`);\n\n  // Convert ethers' BigNumber to Polkadot's BN and add some extra\n  const totalGasLimit = new BN(gasLimit.toString()).add(new BN(10000));\n\n  // 4. Call Parameters\n  const callParams = {\n    V2: {\n      gasLimit: totalGasLimit, // Estimated plus some extra gas\n      action: { Call: uniswapV2Router }, // Uniswap V2 router address\n      value: new BN(ethers.parseEther('0.01').toString()), // 0.01 DEV\n      input: contractCall, // Swap encoded calldata\n    },\n  };\n\n  // 5. Create the Extrinsic\n  const tx = api.tx.ethereumXcm.transact(callParams);\n\n  // 6. Get SCALE Encoded Calldata\n  const encodedCall = tx.method.toHex();\n  console.log(`Encoded Calldata: ${encodedCall}`);\n\n  api.disconnect();\n};\n\ngenerateCallData();\n</code></pre> <p>Note</p> <p>You can also get the SCALE encoded calldata by manually building the extrinsic in Polkadot.js Apps.</p> <p>Let's go through each of the main components of the snippet shown above:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>Moonbase Alpha endpoint URL to create the providers</li> <li>Uniswap V2 router address which is the one the call interacts with</li> <li>Encoded calldata for the Uniswap V2 swap that we calculated before</li> </ul> </li> <li>Create the necessary providers. One is a Polkadot.js API provider, through which we can call Moonbeam pallets directly. The other one is an Ethereum API provider through Ethers.js</li> <li>This step is mainly a best practice. Here, we are estimating the gas of the EVM call that will be executed via XCM, as this is needed later on. You can also hardcode the gas limit value, but it is not recommended</li> <li>Build the remote EVM call. We bumped the gas by <code>10000</code> units to provide a bit of room in case conditions change. The inputs are identical to those used for the gas estimation</li> <li>Create the Ethereum XCM pallet call to the <code>transact</code> method, providing the call parameters we previously built</li> <li>Get the SCALE calldata of the specific transaction parameter, which we need to provide to the <code>Transact</code> XCM instruction later on. Note that in this particular scenario, because we need only the calldata of the transaction parameters, we have to use <code>tx.method.toHex()</code></li> </ol> <p>Once you have the code set up, you can execute it with <code>node</code>, and you'll get the Moonbase Alpha remote EVM calldata:</p> node generate-call-data-swap.js Gas required for call is 596363 Encoded Calldata: 0x2600019b40090000000000000000000000000000000000000000000000000000000000008a1932d6e26433f3037bd6c3a40c816222a6ccd40000c16ff286230000000000000000000000000000000000000000000000000091037ff36ab50000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000061cd3e07fe7d7f6d4680e3e322986b7877f108dd00000000000000000000000000000000000000000000000000000000a036b1b90000000000000000000000000000000000000000000000000000000000000002000000000000000000000000d909178cc99d318e4d46e7e66a972955859670e10000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f00 <p>The encoded calldata for this example is:</p> <pre><code>0x2600019b40090000000000000000000000000000000000000000000000000000000000008a1932d6e26433f3037bd6c3a40c816222a6ccd40000c16ff286230000000000000000000000000000000000000000000000000091037ff36ab50000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000061cd3e07fe7d7f6d4680e3e322986b7877f108dd00000000000000000000000000000000000000000000000000000000a036b1b90000000000000000000000000000000000000000000000000000000000000002000000000000000000000000d909178cc99d318e4d46e7e66a972955859670e10000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f00\n</code></pre> <p>And that is it! You have everything you need to start crafting the XCM message itself! It has been a long journey, but we are almost there.</p>"},{"location":"tutorials/interoperability/uniswapv2-swap-xcm/#building-the-xcm-message-relay-chain","title":"Building the XCM Message from the Relay Chain","text":"<p>We are almost in the last part of this tutorial! In this section, we'll craft the XCM message using the Polkadot.js API. We'll also dissect the message instruction per instruction to understand what is happening every step of the way.</p> <p>The XCM message we are about to build is composed of the following instructions:</p> <ul> <li><code>WithdrawAsset</code> \u2014 takes funds from the account dispatching the XCM in the destination chain and puts them in holding, a special take where funds can be used for later actions</li> <li><code>BuyExecution</code> \u2014 buy a certain amount of block execution time</li> <li><code>Transact</code> \u2014 use part of the block execution time bought with the previous instruction to execute some arbitrary bytes</li> <li><code>DepositAsset</code> \u2014 takes assets from holding and deposits them to a given account</li> </ul> <p>To build the XCM message, which will initiate the remote EVM call through XCM, and get its SCALE encoded calldata, you can use the following snippet:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\n// 1. Input Data\nconst providerWsURL =\n  'wss://relay.api.moonbase.moonbeam.network';\nconst amountToWithdraw = BigInt(1 * 10 ** 16); // 0.01 DEV\nconst devMultiLocation = {\n  parents: 0,\n  interior: { X1: [{ PalletInstance: 3 }] },\n};\nconst weightTransact = 40000000000n; // 25000 * Gas limit of EVM call\nconst multiLocAccount = '0x61cd3e07fe7d7f6d4680e3e322986b7877f108dd';\nconst transactBytes =\n  '0x2600019b40090000000000000000000000000000000000000000000000000000000000008a1932d6e26433f3037bd6c3a40c816222a6ccd40000c16ff286230000000000000000000000000000000000000000000000000091037ff36ab50000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000061cd3e07fe7d7f6d4680e3e322986b7877f108dd00000000000000000000000000000000000000000000000000000000a036b1b90000000000000000000000000000000000000000000000000000000000000002000000000000000000000000d909178cc99d318e4d46e7e66a972955859670e10000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f00';\n\n// 2. XCM Destination (Moonbase Alpha Parachain ID 1000)\nconst dest = { V4: { parents: 0, interior: { X1: [{ Parachain: 1000 }] } } };\n\n// 3. XCM Instruction 1\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: devMultiLocation,\n      fun: { Fungible: amountToWithdraw },\n    },\n  ],\n};\n\n// 4. XCM Instruction 2\nconst instr2 = {\n  BuyExecution: {\n    fees: {\n      id: devMultiLocation,\n      fun: { Fungible: amountToWithdraw },\n    },\n    weightLimit: { Unlimited: null },\n  },\n};\n\n// 5. XCM Instruction 3\nconst instr3 = {\n  Transact: {\n    originKind: 'SovereignAccount',\n    requireWeightAtMost: { refTime: weightTransact, proofSize: 700000n },\n    call: {\n      encoded: transactBytes,\n    },\n  },\n};\n\n// 6. XCM Instruction 4\nconst instr4 = {\n  DepositAsset: {\n    assets: { Wild: 'All' },\n    beneficiary: {\n      parents: 0,\n      interior: { X1: [{ AccountKey20: { key: multiLocAccount } }] },\n    },\n  },\n};\n\n// 7. Build XCM Message\nconst message = { V4: [instr1, instr2, instr3, instr4] };\n\nconst generateCallData = async () =&gt; {\n  // 8. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 9. Create the Extrinsic\n  const tx = api.tx.xcmPallet.send(dest, message);\n\n  // 10. Get SCALE Encoded Calldata\n  const encodedCall = tx.toHex();\n  console.log(`Encoded Calldata: ${encodedCall}`);\n\n  api.disconnect();\n};\n\ngenerateCallData();\n</code></pre> <p>Note</p> <p>You can also get the SCALE encoded calldata by manually building the extrinsic in Polkadot.js Apps.</p> <p>Let's go through each of the main components of the snippet shown above:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>Moonbase Alpha relay chain endpoint URL to create the provider</li> <li>Amount of tokens (in Wei) to withdraw from the Computed Origin account. For this example, <code>0.01</code> tokens are more than enough. To understand how to get this value, please refer to the XCM fee page</li> <li>The multilocation of the <code>DEV</code> token as seen by Moonbase Alpha</li> <li>The weight for the <code>transact</code> XCM instruction. This can be obtained by multiplying <code>25000</code> and the gas limit obtained before. It is recommended to add approximately 10% more of the estimated value. You can read more about this value in the Remote EVM Calls through XCM page</li> <li>The Computed Origin account as it will be needed later for an XCM instruction</li> <li>The bytes for the <code>transact</code> XCM instruction that we calculated in the previous section</li> </ul> </li> <li>Define the destination multilocation for the XCM message. In this case, it is the Moonbase Alpha parachain</li> <li>First XCM instruction, <code>WithdrawAsset</code>. You need to provide the asset multilocation and the amount you want to withdraw. Both variables were already described before</li> <li>Second XCM instruction, <code>BuyExecution</code>. Here, we are paying for Moonbase Alpha block execution time in <code>DEV</code> tokens by providing its multilocation and the amount we took out with the previous instruction. Next, we are buying all the execution we can (<code>Unlimited</code> weight) with <code>0.001 DEV</code> tokens which should be around 20 billion weight units, plenty for our example</li> <li>Third XCM instruction, <code>Transact</code>. The instruction will use a portion of the weight bought (defined as <code>requireWeightAtMost</code>) and execute the arbitrary bytes that are provided (<code>transactBytes</code>)</li> <li>Fourth XCM instruction, <code>DepositAsset</code>. Whatever is left in holding after the actions executed before (in this case, it should be only <code>DEV</code> tokens) is deposited to the Computed Origin account, set as the <code>beneficiary</code>.</li> <li>Build the XCM message by concatenating the instructions inside a <code>V2</code> array</li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>xcmPallet.send</code> extrinsic with the destination and XCM message. This method will append the <code>DescendOrigin</code> XCM instruction to our XCM message, and it is the instruction that will provide the necessary information to calculate the Computed Origin account</li> <li>Get the SCALE encoded calldata. Note that in this particular scenario, because we need the full SCALE encoded calldata, we have to use <code>tx.toHex()</code>. This is because we will submit this transaction using the calldata</li> </ol> <p>Challenge</p> <p>Try a more straightforward example and perform a balance transfer from the Computed Origin account to any other account you like. You'll have to build the SCALE encoded calldata for a <code>balance.Transfer</code> extrinsic or create the Ethereum call as a balance transfer transaction.</p> <p>Once you have the code set up, you can execute it with <code>node</code>, and you'll get the relay chain XCM calldata:</p> node build-xcm-message-swap.js Encoded Calldata: 0x450604630004000100a10f0410000400010403000f0000c16ff286231300010403000f0000c16ff286230006010700902f500982b92a00fd042600019b40090000000000000000000000000000000000000000000000000000000000008a1932d6e26433f3037bd6c3a40c816222a6ccd40000c16ff286230000000000000000000000000000000000000000000000000091037ff36ab50000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000061cd3e07fe7d7f6d4680e3e322986b7877f108dd00000000000000000000000000000000000000000000000000000000a036b1b90000000000000000000000000000000000000000000000000000000000000002000000000000000000000000d909178cc99d318e4d46e7e66a972955859670e10000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f000d01000001030061cd3e07fe7d7f6d4680e3e322986b7877f108dd <p>The encoded calldata for this example is:</p> <pre><code>0x450604630004000100a10f0410000400010403000f0000c16ff286231300010403000f0000c16ff286230006010700902f500982b92a00fd042600019b40090000000000000000000000000000000000000000000000000000000000008a1932d6e26433f3037bd6c3a40c816222a6ccd40000c16ff286230000000000000000000000000000000000000000000000000091037ff36ab50000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000061cd3e07fe7d7f6d4680e3e322986b7877f108dd00000000000000000000000000000000000000000000000000000000a036b1b90000000000000000000000000000000000000000000000000000000000000002000000000000000000000000d909178cc99d318e4d46e7e66a972955859670e10000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f000d01000001030061cd3e07fe7d7f6d4680e3e322986b7877f108dd\n</code></pre> <p>Now that we have the SCALE encoded calldata, the last step is to submit the transaction, which will send our XCM message to Moonbase Alpha, and do the remote EVM call!</p>"},{"location":"tutorials/interoperability/uniswapv2-swap-xcm/#send-xcm-message-relay-chain","title":"Sending the XCM Message from the Relay Chain","text":"<p>This section is where everything comes together and where the magic happens! Let's recap what we've done so far:</p> <ul> <li>We've created a relay chain account that is funded with <code>UNIT</code> tokens (relay chain native tokens)</li> <li>We determined its Computed Origin account on Moonbase Alpha and funded this new address with <code>DEV</code> tokens (Moonbase Alpha native token)</li> <li>We obtained the Uniswap V2 swap calldata, in which we'll be swapping <code>0.01 DEV</code> token for <code>MARS</code>, an ERC-20 that exists in Moonbase Alpha. We had to modify a couple of fields to adapt it to this particular example</li> <li>We built the SCALE encoded calldata in Moonbase Alpha to access its EVM via XCM</li> <li>We crafted our transaction to send an XCM message to Moonbase Alpha, in which we will ask it to execute the SCALE encoded calldata that was previously built. This, in turn, will execute an EVM call which will perform the Uniswap V2 swap for the precious <code>MARS</code> tokens!</li> </ul> <p>To send the XCM message that we built in the previous section, you can use the following code snippet:</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\n// 1. Input Data\nconst providerWsURL =\n  'wss://relay.api.moonbase.moonbeam.network';\nconst MNEMONIC = 'INSERT_MNEMONIC'; // Not safe, only for testing\nconst txCall =\n  '0x450604630004000100a10f0410000400010403000f0000c16ff286231300010403000f0000c16ff286230006010700902f500982b92a00fd042600019b40090000000000000000000000000000000000000000000000000000000000008a1932d6e26433f3037bd6c3a40c816222a6ccd40000c16ff286230000000000000000000000000000000000000000000000000091037ff36ab50000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000061cd3e07fe7d7f6d4680e3e322986b7877f108dd00000000000000000000000000000000000000000000000000000000a036b1b90000000000000000000000000000000000000000000000000000000000000002000000000000000000000000d909178cc99d318e4d46e7e66a972955859670e10000000000000000000000001fc56b105c4f0a1a8038c2b429932b122f6b631f000d01000001030061cd3e07fe7d7f6d4680e3e322986b7877f108dd';\n\nconst sendXCM = async () =&gt; {\n  // 2. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Create Keyring Instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'sr25519' });\n  const alice = keyring.addFromUri(MNEMONIC);\n\n  // 4. Create the Extrinsic\n  const tx = await api.tx(txCall).signAndSend(alice, (result) =&gt; {\n    // 5. Check Transaction Status\n    if (result.status.isInBlock) {\n      console.log(\n        `Transaction included in blockHash ${result.status.asInBlock}`\n      );\n    }\n  });\n\n  api.disconnect();\n};\n\nsendXCM();\n</code></pre> <p>Once you have the code set up, you can execute it with <code>node</code>, and the XCM message will be sent to initiate your Uniswap V2 swap in Moonbase Alpha:</p> node send-xcm-message-swap.js Transaction included in blockHash 0x4260e32a208dde976c704bb8b08eccd6cdd2cdd9796d79a572c40ba38ce48af6 <p>And that is it! You've sent an XCM message, which performed a remote EVM call via XCM and resulted in a Uniswap V2-styled swap in Moonbase Alpha. But let's go into more detail about what happened.</p> <p>This action will emit different events. The first one is the only relevant in the relay chain, and it is named <code>xcmPallet.Sent</code>, which is from the <code>xcmPallet.send</code> extrinsic. In Moonbase Alpha, the following events emitted by the <code>parachainSystem.setValidationData</code> extrinsic (where all the inbound XCM messages are processed) are of interest:</p> <ul> <li><code>parachainSystem.DownwardMessagesReceived</code> \u2014 states that there was an XCM message received</li> <li><code>evm.Log</code> \u2014 internal events emitted by the different contract calls. The structure is the same: contract address, the topics, and relevant data</li> <li><code>ethereum.Executed</code> \u2014 contains information on the <code>from</code> address, the <code>to</code> address, and the transaction hash of an EVM call done</li> <li><code>polkadotXcm.AssetsTrapped</code> \u2014 flags that some assets were in holding and were not deposited to a given address. If the <code>Transact</code> XCM instruction does not exhaust the tokens allocated to it, it will execute a <code>RefundSurplus</code> after the XCM is processed. This instruction will take any leftover tokens from the execution bought and put them in holding. We could prevent this by adjusting the fee provided to the <code>Transact</code> instruction, or by adding the instruction right after the <code>Transact</code></li> <li><code>dmpQueue.ExecutedDownward</code> \u2014 states the result of executing a message received from the relay chain (a DMP message). In this case, the <code>outcome</code> is marked as <code>Complete</code></li> </ul> <p>Our XCM was successfully executed! If you visit Moonbase Alpha Moonscan and search for the transaction hash, you'll find the Uniswap V2 swap that was executed via the XCM message.</p> <p>Challenge</p> <p>Do a Uniswap V2 swap of <code>MARS</code> for any other token you want. Note that in this case, you'll have to remotely execute an ERC-20 <code>approve</code> via XCM first to allow the Uniswap V2 Router to spend the tokens on your behalf. Once the approval is done, you can send the XCM message for the swap itself.</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production."},{"location":"tutorials/interoperability/using-axelar-sdk/","title":"Minting a Cross-Chain NFT with the Axelar SDK","text":"<p>by Jeremy Boetticher &amp; Kevin Neilson</p>"},{"location":"tutorials/interoperability/using-axelar-sdk/#introduction","title":"Introduction","text":"<p>Axelar\u2019s general message passing (GMP) allows smart contracts to communicate securely across chains. This enables developers to build cross-chain connected applications on Moonbeam that can tap into functionality from Polkadot, Ethereum, Avalanche, Cosmos, and beyond. In this tutorial, we'll introduce the JavaScript SDK package Axelar packed with tools to aid developers in this cross-chain vision.</p> <p>The AxelarJS SDK  allows developers to estimate fees, track and recover transactions, and quickly transfer tokens. To show off some of the SDK's tools, we will walk through a demo that deploys an NFT that can be minted across chains. Before following along with the tutorial, you may wish to first familiarize yourself with this Overview of Axelar.</p> <p>In this tutorial, we'll mint an NFT on a remote chain by using Axelar to send a specific message to trigger the mint. We'll be using the AxelarJS SDK in conjunction with a minting script that will define the parameters of the cross-chain mint, such as the destination chain, destination contract address, and more.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tutorials/interoperability/using-axelar-sdk/#axelar-refresher","title":"Axelar Refresher","text":"<p>Axelar is a blockchain that connects blockchains, delivering secure cross-chain communication. Every validator in Axelar\u2019s network runs light nodes on chains that Axelar supports. In this demo, we'll interact with two Axelar contracts, one of which is the Axelar Gateway contract. The dynamic validator set uses this contract to monitor activity on each chain. Their role is crucial for achieving consensus, ensuring that messages are accurately transmitted from one chain to another</p> <p></p> <p>The other contract we will be working with is the Axelar Gas Receiver microservice. Whenever you use the Axelar Gateway to send a cross-chain transaction, the Gas Receiver lets you pay for the subsequent transaction on the destination chain. Although not mandatory, this feature enables the end user to send just a single transaction. This transaction automatically updates the destination chain and allows all transaction fees to be paid using the source-chain token already held by the user.</p>"},{"location":"tutorials/interoperability/using-axelar-sdk/#building-the-cross-chain-nft-contract","title":"Building the Cross-Chain NFT Contract","text":"<p>We'll be deploying a simple contract that can only mint an NFT if it receives a specific cross-chain message. Minting the NFT will require a token payment, which will be wrapped DEV (Moonbase Alpha\u2019s native currency). A wrapped token for a native currency like DEV will mint one ERC-20 WDEV token for each DEV sent to it, and gives the option to redeem one WDEV token for one DEV. Using WDEV instead of native DEV is required because Axelar requires all tokens sent to be ERC-20s.</p> <p>So to mint in the cross-chain message, it must receive at least 0.05 WDEV.</p> <p>We\u2019re putting the same contract on two chains, so it must send and receive messages. From a high level, our contract does two things:</p> <ol> <li>Send an encoded address message with WDEV across chains via Axelar\u2019s Gateway with the option to pay for its gas on the destination chain</li> <li>Receive an encoded address message from Axelar, and execute only if it received at least 0.05 WDEV</li> </ol> <p>You\u2019ll be using a Hardhat project, but before we set it up, let\u2019s first take a look at a few parts of the contract. I encourage you to follow along!</p> <p>Contracts executed by the Axelar Gateway, like ours here, inherit from <code>IAxelarExecutable</code>. This parent contract has two overridable functions, <code>_execute</code> and <code>_executeWithToken</code>, that allow developers to change the logic when a contract receives a contract call from the Axelar Gateway. Both functions have the same inputs, but <code>_executeWithToken</code> also includes <code>tokenSymbol</code> and <code>amount</code> to describe the token being sent cross-chain.</p> <p>Now let\u2019s finally take a look at our mint function. It takes three inputs: a destination address, a destination chain, and the amount of WDEV to send. Remember that this mint function is called on the origin chain (Moonbase Alpha), which mints an NFT on a different destination chain.</p> mintXCNFT function <pre><code>function mintXCNFT(\n    string memory destinationAddress,\n    string memory destinationChain,\n    uint256 amount\n) external payable {\n    // Create the payload\n    bytes memory payload = abi.encode(msg.sender);\n\n    // Takes WDEV from the user and puts them into this contract for the Gateway to take        \n    wDev.transferFrom(msg.sender, address(this), amount);\n    wDev.approve(address(gateway), amount);\n\n    // Pay for gas\n    // This is a gas service SPECIFICALLY for sending with token\n    gasService.payNativeGasForContractCallWithToken{value: msg.value}(\n        address(this),\n        destinationChain,\n        destinationAddress,\n        payload,\n        \"WDEV\",\n        amount,\n        msg.sender\n    );\n\n    // Call remote contract\n    gateway.callContractWithToken(\n        destinationChain,\n        destinationAddress,\n        payload,\n        \"WDEV\",\n        amount\n    );\n}\n</code></pre> <p>The logic itself has three steps. First, it takes WDEV from the caller. The caller must approve our NFT contract to transfer their WDEV beforehand. Then, our NFT contract approves the gateway to transfer the WDEV from the caller since the gateway contract will try to transfer the tokens from our NFT contract in the final step.</p> <p>Next, to pay for gas on the destination chain, we make use of the <code>IAxelarGasService</code> contract. This contract has many different configurations to pay for gas, like paying for <code>execute</code> versus <code>executeWithToken</code> or using an ERC-20 token as payment versus using native currency. Be careful if you plan on writing your own contract later!</p> <p>In this case, since the origin chain is Moonbase Alpha, the native currency is DEV. We can use native DEV to pay for gas on the destination chain based on the conversion rates between Moonbase Alpha\u2019s native currency and the destination chain\u2019s native currency. Since we\u2019re sending a contract call that includes a token to pay for destination gas in DEV, we will be using the <code>payNativeGasForContractCallWithToken</code> function.</p> <p>Finally, we call the gateway to send our cross-chain message with <code>callContractWithToken.</code> Notice that the payload (generic data that sent in a cross-chain call) that we\u2019re sending is just the caller\u2019s address. This data will need to be decoded by the destination contract.</p> <p>Now let\u2019s take a look at what happens on the destination chain. Since we expect tokens to be sent as payment for an NFT mint, we will override <code>_executeWithToken</code> from <code>IAxelarExecutable.</code></p> executeWithToken function <pre><code>// Mints the NFT for the user\nfunction _executeWithToken(\n    string memory, /*sourceChain*/\n    string memory, /*sourceAddress*/\n    bytes calldata payload,\n    string memory tokenSymbol,\n    uint256 amount\n) internal override {\n    require(\n        keccak256(abi.encodePacked(tokenSymbol)) == keccak256(\"WDEV\"),\n        \"Only WDEV is accepted\"\n    );\n    require(amount &gt;= 0.05 ether, \"Not enough to mint!\");\n\n    address user = abi.decode(payload, (address));\n\n    _mint(user, currentNFTID);\n    currentNFTID++;\n}\n</code></pre> <p>In our implementation of <code>_executeWithToken</code>, we first check to ensure that the <code>tokenSymbol</code> provided by Axelar is \u201cWDEV\u201d. Then we expect 0.05 WDEV tokens for payment and will revert if any other token or anything less than 0.05 WDEV gets sent. Afterwards, we decode the payload to get the address of the origin chain\u2019s caller so that we can mint an NFT to that address. Finally, we finish the minting!</p> <p>You can find the full code for the <code>CrossChainNFT.sol</code> below.</p> CrossChainNFT.sol <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol\";\nimport { AxelarExecutable } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol';\n\n// Allows users to mint an NFT, but only cross chain\ncontract CrossChainNFT is ERC721, AxelarExecutable {\n    constructor(\n        address _gateway,\n        IAxelarGasService _gasService,\n        IERC20 _wDev\n    ) ERC721(\"Cross Chain NFT\", \"XCNFT\") AxelarExecutable(_gateway) {\n        gasService = _gasService;\n        wDev = _wDev;\n    }\n\n    uint256 currentNFTID;\n    IAxelarGasService gasService;\n    IERC20 wDev;\n\n    // Mints the NFT for the user\n    function _executeWithToken(\n        string memory, /*sourceChain*/\n        string memory, /*sourceAddress*/\n        bytes calldata payload,\n        string memory tokenSymbol,\n        uint256 amount\n    ) internal override {\n        require(\n            keccak256(abi.encodePacked(tokenSymbol)) == keccak256(\"WDEV\"),\n            \"Only WDEV is accepted\"\n        );\n        require(amount &gt;= 0.05 ether, \"Not enough to mint!\");\n\n        address user = abi.decode(payload, (address));\n\n        _mint(user, currentNFTID);\n        currentNFTID++;\n    }\n\n    function mintXCNFT(\n        string memory destinationAddress,\n        string memory destinationChain,\n        uint256 amount\n    ) external payable {\n        // Create the payload\n        bytes memory payload = abi.encode(msg.sender);\n\n        // Takes WDEV from the user and puts them into this contract for the Gateway to take        \n        wDev.transferFrom(msg.sender, address(this), amount);\n        wDev.approve(address(gateway), amount);\n\n        // Pay for gas \n        // This is a gas service SPECIFICALLY for sending with token\n        gasService.payNativeGasForContractCallWithToken{value: msg.value}(\n            address(this),\n            destinationChain,\n            destinationAddress,\n            payload,\n            \"WDEV\",\n            amount,\n            msg.sender\n        );\n\n        // Call remote contract\n        gateway.callContractWithToken(\n            destinationChain,\n            destinationAddress,\n            payload,\n            \"WDEV\",\n            amount\n        );\n    }\n}\n</code></pre>"},{"location":"tutorials/interoperability/using-axelar-sdk/#setting-up-the-repository","title":"Setting Up the Repository","text":"<p>Make sure to clone the GitHub repository for this tutorial. We need to install some dependencies, including Hardhat, OpenZeppelin contracts, some Axelar contracts, and the Axelar SDK. To configure the dependencies properly, run the following command:</p> <pre><code>npm install\n</code></pre> <p>The repository contains two Solidity files. The first file is the <code>CrossChainNFT</code> as expected, and the second is an Axelar library <code>StringAddressUtils.sol</code> that doesn\u2019t have an npm package yet but is still required for the Hardhat implementation.</p> <p>There are also four Hardhat scripts within the repository\u2019s scripts folder.</p> <ul> <li><code>axelarStatus.js</code> - a Hardhat task that lets you view information about Axelar transactions</li> <li><code>deploy.js</code> - deploys the <code>CrossChainNFT</code> to the network provided by Hardhat</li> <li><code>gatewayGasReceiver.js</code> - returns hardcoded values for Axelar\u2019s Gateway and gas service contracts</li> <li><code>mint.js</code> - mints the <code>CrossChainNFT</code> (only run on Moonbase Alpha)</li> </ul> <p>Before we get into the fun part, you will need to get an account with a private key funded with DEV to deploy the contract and sign all future transactions. Place this within a <code>secrets.json</code> file within the repository\u2019s main directory. You should format it as follows:</p> <pre><code>{\n    \"privateKey\": \"INSERT_PRIVATE_KEY\"\n}\n</code></pre> <p>If everything goes well, you will be able to compile correctly:</p> <pre><code>npx hardhat compile\n</code></pre>"},{"location":"tutorials/interoperability/using-axelar-sdk/#deploying-the-cross-chain-contract-to-moonbase-alpha","title":"Deploying the Cross-Chain Contract to Moonbase Alpha","text":"<p>This demo focuses on using the scripts, so it\u2019s best to take a look at them, starting with <code>deploy.js</code>, which is similar to the Ethers.js tutorial deployment contracts.</p> <p><code>gatewayGasReceiver.js</code> stores many of the contract addresses in this repo, which are necessary for the deployment. You likely will not have to change any of the hardcoded addresses. Try deploying your contract to the origin chain:</p> <pre><code>npx hardhat run scripts/deploy.js --network moonbase\n</code></pre> <p>You should see the address deployed and printed in the console. Be sure to copy it! You will need it to interact with the next script. You also need to deploy it to the destination chain. The choice of which destination network to use is up to you, but you will need its native currency to deploy. I\u2019ve included some of the available networks and their faucets here:</p> Network Faucet Deployment Command Sepolia Faucet Link <pre><code>npx hardhat run scripts/deploy.js --network sepolia</code></pre> Polygon Mumbai Faucet Link <pre><code>npx hardhat run scripts/deploy.js --network mumbai</code></pre> Avalanche Fuji Faucet Link <pre><code>npx hardhat run scripts/deploy.js --network fuji</code></pre> Fantom TestNet Faucet Link <pre><code>npx hardhat run scripts/deploy.js --network fantom</code></pre> <p>After running a deployment command, you'll see output like the below. Be sure to copy the destination chain's contract address because you'll need to provide that later. </p> npx hardhat run scripts/deploy.js --network moonbase Compiled 1 Solidity file successfully Nothing to compile Deployed CrossChainNFT on moonbase at: 0xB1972a5487A0Af15C47d321f25E25E8E3c3e8462"},{"location":"tutorials/interoperability/using-axelar-sdk/#building-the-mint-js-script","title":"Building the Mint.js Script","text":"<p>The minting contract is quite exciting and will require Axelar\u2019s SDK. At the top of the <code>mint.js</code> script, Ethers.js is initialized in a Hardhat script. The Axelar SDK is also initialized. There are multiple Axelar APIs available in the SDK, but in this case we will only be using the Axelar Query API since it includes all of the gas estimation functionality that we\u2019ll need for paying gas fees across chains.</p> <pre><code>const ethers = hre.ethers;\nconst axelarSDK = new AxelarQueryAPI({\n  environment: Environment.TESTNET,\n});\n</code></pre> <p>There are also some constants for you to change right after. This walkthrough is using Fantom as the destination chain, but you can use whichever chains you deployed to. Note that even though we\u2019re using a TestNet environment, Axelar refers to the chain names by their MainNet equivalents, hence why the origin chain is <code>moonbeam</code> and not <code>moonbase.</code></p> <pre><code>const ORIGIN_CHAIN = 'moonbeam';\nconst DESTINATION_CHAIN = 'ethereum-sepolia';\n// Address of CrossChainNFT printed in the console after running deploy script\nconst ORIGIN_CHAIN_ADDRESS = 'INSERT_CONTRACT_ADDRESS';\n// Address of AxelarAcceptEverything.sol on Sepolia, you can change this \n// contract address to your own AxelarAcceptEverything.sol contract \nconst DESTINATION_CHAIN_ADDRESS = '0x89f801C7DB23439FDdBad4f913D788F13d1d7494'; \n</code></pre> <p>Next, we have to work with wrapped DEV to send across chains. First, we must wrap our DEV, and then we approve the contract on the origin chain to take some of our WDEV. This is necessary because the origin chain\u2019s contract has to send your WDEV to pay for minting the NFT on the destination chain.</p> <p>Note here that instead of hardcoding the WDEV contract address, we\u2019re using the <code>IAxelarGateway</code> contract to find the address. We could have also done this in the smart contract, but I wanted to show off how you would do it with Ethers.js. As expected, we sign two transactions: first to wrap 0.13 WDEV, then to approve our <code>CrossChainNFT</code> contract to send that WDEV.</p> <p>You may be wondering why we\u2019re wrapping 0.13 WDEV when the price of the mint is only 0.05. At the time of writing, Axelar collects a small fee (0.08 WDEV in this case) when transferring tokens between networks, which can be calculated on their website. Gateways do this automatically, but this responsibility may be delegated to the <code>IAxelarGasService</code>contract in the future.</p> <pre><code>const MOONBASE_WDEV_ADDRESS = await gateway.tokenAddresses('WDEV');\n\n// Wrap + Approve WDEV to be used by the NFT contract\n// wrap =&gt; transfer to contract =&gt; contract transfers to Gateway\nconst wDEVPayment = ethers.utils.parseUnits('0.13', 'ether');\nconst wDEV = await ethers.getContractAt('WETH9', MOONBASE_WDEV_ADDRESS);\n\nconst wrapTx = await wDEV.deposit({ value: wDEVPayment });\nconsole.log('Wrap transaction hash: ', wrapTx.hash);\n\nconst approveTx = await wDEV.approve(ORIGIN_CHAIN_ADDRESS, wDEVPayment);\nconsole.log('Approve transaction hash: ', approveTx.hash);\n\nconsole.log('Awaiting transaction confirmations...');\nawait ethers.provider.waitForTransaction(approveTx.hash, 1);\n</code></pre> <p>Now we have to estimate the amount of DEV that we send to the <code>mintXCNFT</code> function to pay for gas on the destination chain. This is where the Axelar SDK kicks in.</p> <p>We must estimate the amount of gas to spend on the destination chain because it is difficult to estimate a function that can only be called by a specific contract. In this case, we overestimate the amount of gas we will spend as <code>400,000</code>. In an actual production environment, you should benchmark the amount of gas that you spend. However, if you do end up overestimating by a lot, you will get refunded by Axelar\u2019s gas services.</p> <p>The estimateGasFee function provided by the Axelar SDK will find the conversion between the origin chain\u2019s native currency and the destination chain\u2019s native currency to find the right amount to send to the destination chain.</p> <p>You, the astute reader, might wonder why we\u2019re using <code>GLMR</code> instead of <code>DEV</code>. Similar to how Axelar uses the MainNet chain names instead of using the TestNet names, Axelar will interpret <code>GLMR</code> as <code>DEV</code> since we\u2019re using the TestNet environment.</p> <pre><code>const estimateGasUsed = 400000;\nconst gasFee = await axelarSDK.estimateGasFee(\n  ORIGIN_CHAIN,\n  DESTINATION_CHAIN,\n  GasToken.GLMR,\n  estimateGasUsed\n);\nconst gasFeeToHuman = ethers.utils.formatEther(ethers.BigNumber.from(gasFee));\nconsole.log(`Cross-Chain Gas Fee: ${gasFee} Wei / ${gasFeeToHuman} Ether`);\n</code></pre> <p>Calling this function from the SDK will return a string representing the amount of DEV WEI to pay, like <code>241760932800000</code>. That\u2019s hard for us simple humans to understand, so we use Ethers.js to convert it into a more human-readable version to print to the console later.</p> <pre><code>const gasFeeToHuman = ethers.utils.formatEther(ethers.BigNumber.from(gasFee));\n</code></pre> <p>Finally, we call the <code>mintXCNFT</code> contract function. The important takeaway here is that we\u2019re sending the gas fee not as a gas limit but as value. Ethers.js can calculate how much gas to send on the origin chain. However, to pay for the destination chain, we have to calculate with the Axelar SDK and send it as value to the <code>IAxelarGasReceiver</code> contract.</p> <pre><code>// Begin the minting\nconst mintRes = await nft.mintXCNFT(\n  DESTINATION_CHAIN_ADDRESS,\n  DESTINATION_CHAIN,\n  wDEVPayment,\n  { value: gasFee }\n);\nconsole.log('Minting transaction hash: ', mintRes.hash);\n</code></pre> <p>That\u2019s the entire script! Before we run the script, check again to make sure that the four constants (<code>ORIGIN_CHAIN</code>, <code>DESTINATION_CHAIN</code>, <code>ORIGIN_CHAIN_ADDRESS</code>, <code>DESTINATION_CHAIN_ADDRESS</code>) at the top of the script are set correctly.</p> <p>Here\u2019s the command to mint your NFT!</p> <pre><code>npx hardhat run scripts/mint.js --network moonbase\n</code></pre> <p>The console should output something similar to this:</p> npx hardhat run scripts/mint.js --network moonbase Nothing to compile Wrap transaction hash:  0x89bd6c42c9b7791ce51a0ef74e83fa46fc063eefcd838def3664cb12970156cd Approve transaction hash:  0x1594d43444d1f8abdadcab78098452d8b25a9eed72c89597c1b9822b5a8e1605 Awaiting transaction confirmations... Cross-Chain Gas Fee: 1694247418108372848 Wei / 1.694247418108372848 Ether Minting transaction hash:  0x9daa8c762dc3c60c5ef009486fbd6c4e91baa55baec79db2be6e7d10cfc06c4c <p>The most important data here is the minting transaction because that\u2019s how you track your transaction's status. So don\u2019t lose it! But if you do, you can look at all of the recent transactions on Axelar\u2019s TestNet scanner.</p>"},{"location":"tutorials/interoperability/using-axelar-sdk/#viewing-axelar-transaction-status","title":"Viewing Axelar Transaction Status","text":"<p>Axelar has a TestNet explorer, and a successful transaction for the interaction you just completed would look something like this:</p> <p></p> <p>It's a good idea to try out the SDK to view the status of your transactions because it gives more information about your transaction and any possible errors. To do this, I wrote a Hardhat task for us to use. You can view the code in <code>axelarStatus.js</code>, but we\u2019ll take a dive here too.</p> <p>The main meat of the code is in these five lines. First, we initialize the SDK module that we will be using, the <code>AxelarGMPRecoveryAPI</code>. Unlike the <code>AxelarQueryAPI</code> that we used in the minting script, the <code>AxelarGMPRecoveryAPI</code> helps track and recover stalled transactions. Next, we have to query the transaction status, and the SDK takes care of it for us.</p> <pre><code>const sdk = new AxelarGMPRecoveryAPI({\n  environment: Environment.TESTNET,\n});\nconst txStatus = await axelarSDK.queryTransactionStatus(txHash);\nconsole.log(txStatus);\n</code></pre> <p>You can learn a bit more about the <code>AxelarGMPRecoveryAPI</code> in Axelar\u2019s documentation. It includes additional functionality in case a transaction goes wrong, especially if there isn\u2019t enough gas sent along with the cross-chain transaction.</p> <p>The <code>axelarStatus.js</code> file is configured as a Hardhat task rather than a script, which means that the command to run it will differ slightly from the command style required to execute a script. Be sure to note these differences and carefully craft the below command, replacing <code>INSERT_TRANSACTION_HASH</code> with the transaction of hash on the origin chain that you sent a cross-chain message in:</p> <pre><code>npx hardhat axelarStatus --tx INSERT_TRANSACTION_HASH\n</code></pre> <p>If you run the Hardhat script, you\u2019ll end up with something like this in your console (I didn\u2019t include all of it since it\u2019s so large). You\u2019re likely most interested in the status, where a list of possible ones is in Axelar\u2019s documentation. You\u2019re looking for <code>destination_executed</code> to indicate that it was received and executed correctly, but if you\u2019re too early you might find <code>source_gateway_called</code> or <code>destination_gateway_approved</code>.</p> Status: 'source_gateway_called' Error: undefined Total Time Spent: { total: 39 } Gas Paid Info: Status: 'gas_paid' Block Hash: '0x4e9ec37b8ebfb2acb7180aff401493dfb3025439c42225c2908f984b54131baa' Chain: 'moonbeam' Address: '0xbE406F0189A0B4cf3A05C286473D23791Dd44Cc6' Transaction Hash: '0xeb3dc836b890bded6c9e9ce103cdbac69843c55fb19ade1771936d44b3bb9151' Event: 'NativeGasPaidForContractCallWithToken' Event Signature: 'NativeGasPaidForContractCallWithToken(address,string,string,bytes32,string,uint256,uint256,address)' Transaction Index: 0 Event Index: 2 Block Number: 7963797 Block Timestamp: 1721782902 Call Transaction Details: Chain: 'moonbeam' Contract Address: '0x5769D84DD62a6fD969856c75c7D321b84d455929' Transaction Hash: '0xeb3dc836b890bded6c9e9ce103cdbac69843c55fb19ade1771936d44b3bb9151' Block Number: 7963797 Log Index: 4 Event: 'ContractCallWithToken' Sender: '0x1AE99204240C92DE9B01207Ed5dF777E4e738e05' Destination Chain: 'ethereum-sepolia' Destination Contract Address: '0x89f801C7DB23439FDdBad4f913D788F13d1d7494' Payload Hash: '0x4af6b315b6befdc046499484184d0fe2f273e733bfdb5927aeb5872b8a3761f7' Symbol: 'WDEV' Amount: '130000000000000000' Transaction Receipt Details: Block Hash: '0x4e9ec37b8ebfb2acb7180aff401493dfb3025439c42225c2908f984b54131baa' Transaction Index: 0 Gas Used: 813360 Status: 1 From: '0x3b939fead1557c741ff06492fd0127bd287a421e' To: '0x1ae99204240C92DE9B01207Ed5dF777E4e738e05' Effective Gas Price: 125000000 <p>You can learn more about debugging contracts in Axelar\u2019s documentation, where they go into depth on specific error messages and how to use tools like Tenderly for logic errors.</p>"},{"location":"tutorials/interoperability/using-axelar-sdk/#conclusion","title":"Conclusion","text":"<p>You\u2019re well on your way to creating your own connected contracts with Axelar! Learn more about Axelar on their docs site, and read about how Moonbeam is shaping up to be the leader in blockchain interoperability in our introduction to connected contracts. For more information on the AxelarJS SDK, be sure to check out the Axelar Docs.</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}]}