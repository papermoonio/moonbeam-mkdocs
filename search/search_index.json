{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"ai-resources/ai-resources/","title":"AI Resources","text":"<p>Moonbeam provides <code>.txt</code> files containing the documentation content and navigation structure, optimized for use with large language models (LLMs) and AI tools. These resources help build AI assistants, power code search, or enable custom tooling trained on Moonbeam\u2019s documentation.</p> <p>Each category file includes foundational content from the Basics and Reference categories to ensure LLMs have the necessary context.</p>"},{"location":"ai-resources/ai-resources/#download-llm-files","title":"Download LLM Files","text":"Category Description File Actions Index Navigation index of all Moonbeam documentation pages <code>llms.txt</code> Full Documentation Full content of all documentation pages <code>llms-full.txt</code> Basics Moonbeam's framework, architecture, and core components <code>llms-basics.txt</code> Reference Reference material including network endpoints, JSON-RPC methods, and contract or token addresses <code>llms-reference.txt</code> Ethereum Toolkit Useful tools and smart contracts to work with Moonbeam's EVM <code>llms-ethereum-toolkit.txt</code> Substrate Toolkit Useful tools and smart contracts to work with Substrate <code>llms-substrate-toolkit.txt</code> GMP Providers How to use General Message Passing (GMP) for cross-chain communication <code>llms-gmp-providers.txt</code> XCM Learn about and use Cross-Consensus Messaging (XCM) <code>llms-xcm.txt</code> XC-20 Guides for interacting with XC-20 tokens <code>llms-xc-20.txt</code> XCM Remote Execution How to make cross-chain calls with XCM <code>llms-xcm-remote-execution.txt</code> Precompiles Guides to using Moonbeam's precompiles <code>llms-precompiles.txt</code> Libraries and SDKs Resources for commonly used libraries and SDKs <code>llms-libraries-and-sdks.txt</code> Dev Environments How to set up developer environments such as Hardhat and Foundry <code>llms-dev-environments.txt</code> JSON-RPC APIs RPC usage and tracing <code>llms-json-rpc-apis.txt</code> Node Operators and Collators How to run a full node or a block-producing collator <code>llms-node-operators-and-collators.txt</code> Oracle Nodes How to integrate with oracle node providers <code>llms-oracle-nodes.txt</code> Indexers and Queries How to integrate with indexer and query node providers <code>llms-indexers-and-queries.txt</code> Tokens and Accounts How to manage tokens and accounts on Moonbeam <code>llms-tokens-and-accounts.txt</code> Staking Guides to delegate and collate <code>llms-staking.txt</code> Governance Guides to governance including voting and treasury <code>llms-governance.txt</code> Integrations Guides to integrating Moonbeam with various tools such as wallets and analytics <code>llms-integrations.txt</code> Tutorials Comprehensive, step-by-step, guided project builds <code>llms-tutorials.txt</code> <p>Note</p> <p>The <code>llms-full.txt</code> file may exceed the input limits of some language models due to its size. If you encounter limitations, consider using the files by category.</p>"},{"location":"builders/build/historical-updates/","title":"Historical Updates","text":""},{"location":"builders/build/historical-updates/#introduction","title":"Introduction","text":"<p>This page overviews historical updates on Moonbeam and Moonriver, such as bug fixes to the Moonbeam source code and data migrations applied.</p> <p>This page aims to provide information about unexpected behaviors or data inconsistencies associated with updates that require forced data migrations.</p>"},{"location":"builders/build/historical-updates/#bugs","title":"Bugs","text":""},{"location":"builders/build/historical-updates/#invalid-transactions-stored","title":"Invalid Transactions Stored","text":"<p>For invalid transactions where the transaction cost couldn't be paid, the EVM pallet inserted the transaction metadata into storage instead of discarding it because there was no transaction cost validation. As a result, the runtime storage was unnecessarily bloated with invalid transaction data.</p> <p>This bug only impacted Moonriver and Moonbase Alpha and existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonriver RT49 RT600 0 - 455106 Moonbase Alpha RT40 RT600 0 - 675175 <p>For more information, you can review the relative Frontier PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#ethereum-fees-to-treasury","title":"Ethereum Fees Weren't Sent to Treasury","text":"<p>The Moonbeam transaction fee model before Runtime 3401 and the passage of MB101 mandated a 20% allocation of fees sent to the on-chain Treasury and 80% burned as a deflationary force. However, before runtime 800, Ethereum transactions did not correctly allocate 20% of the transaction fees to the on-chain Treasury.</p> <p>This bug only impacted Moonriver and Moonbase Alpha and existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonriver RT49 RT800 0 - 684728 Moonbase Alpha RT40 RT800 0 - 915684 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#missing-refunds","title":"Missing Refunds","text":"<p>Moonbeam is configured to set the existential deposit to 0, meaning that accounts do not need a minimum balance to be considered active. For Substrate-based chains with this configuration, some refunds were missing from zeroed accounts because the account was interpreted as not existing.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT900 RT1001 0 - 5164 Moonriver RT49 RT1001 0 - 1052241 Moonbase Alpha RT40 RT1001 0 - 1285915 <p>For more information, you can review the relative Frontier PR and the associated Substrate PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#incorrect-collator-selection","title":"Incorrect Collator Selection","text":"<p>The total delegations for collator candidates were not correctly updated when a delegation was increased via the <code>delegatorBondMore</code> extrinsic. This led to issues where the increased delegation amount wasn't included in the candidates' total amount bonded, which is used to determine which candidates are in the active set of collators. As a result, some candidates may not have been selected to be in the active set when they should have been, impacting their own and their delegators' rewards.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT900 RT1300 0 - 524762 Moonriver RT49 RT1300 0 - 1541735 Moonbase Alpha RT40 RT1300 0 - 1761128 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#new-account-event","title":"New Account Event Bug","text":"<p>The <code>System.NewAccount</code> event is emitted when a new account is created. However, a bug prevented this event from being emitted for some accounts at creation time. A hotfix was applied that patched the impacted accounts and emitted the <code>System.NewAccount</code> at a later time.</p> <p>The hotfix was applied in the following block ranges:</p> Network Block Range Moonbeam 1041355 - 1041358 and 1100752 Moonriver 1835760 - 1835769 Moonbase Alpha 2097782 - 2097974 <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT900 RT1401 0 - 915320 Moonriver RT49 RT1401 0 - 1705939 Moonbase Alpha RT40 RT1400 0 - 1962557 <p>For more information, you can review the relative Frontier PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#incorrect-timestamp-units","title":"Incorrect Timestamp Units","text":"<p>EIP-2612 and Ethereum blocks deal with timestamps in seconds; however, the Substrate timestamp pallet that Moonbeam implements uses milliseconds. This only affected the EIP-2612 implementation, not the <code>block.timestamp</code> value.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT900 RT1606 0 - 1326697 Moonriver RT49 RT1605 0 - 2077598 Moonbase Alpha RT40 RT1603 0 - 2285346 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#substrate-tips","title":"Substrate Tips Missing Treasury Distribution","text":"<p>Tips for Substrate-based transactions weren't handled properly. The entire portion of the tip was burned because it was not handled in the runtime code. A fix was applied so that 20% was paid to the Treasury and 80% was burned, consistent with all other fee behavior at that time.</p> <p>Note that RT3401 introduced a parameters pallet fee configuration allowing governance to adjust how fees are split between the Treasury and burning. After this runtime upgrade combined with the passage of MB101, 100% of all transaction fees on both Moonbeam and Moonriver are now burned.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT900 RT2403 0 - 4163078 Moonriver RT49 RT2401 0 - 4668844 Moonbase Alpha RT40 RT2401 0 - 4591616 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#incorrect-delegation-reward-calculation","title":"Incorrect Delegation Reward Calculation","text":"<p>The reward payouts for all delegations and collators were underestimated whenever there were pending requests. Delegation rewards are calculated based on the amount of tokens bonded by each delegator with respect to the total stake of the given collator. By counting delegation amounts for pending requests, the rewards to collators and their delegations were less than they should have been.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1001 RT1802 5165 - 1919457 Moonriver RT1001 RT1801 1052242 - 2572555 Moonbase Alpha RT1001 RT1800 1285916 - 2748785 <p>You can review the relative PR on GitHub for more information.</p>"},{"location":"builders/build/historical-updates/#block-parent-hash-calculated-incorrectly","title":"Block Parent Hash Calculated Incorrectly","text":"<p>After EIP-1559 support was introduced, which included the transition to new Ethereum transaction types, the block header parent hash was miscalculated to <code>H256::default</code>.</p> <p>This bug only impacted Moonbase Alpha and only impacted the following block:</p> Network Introduced Fixed Impacted Block Moonbase Alpha RT1200 RT1201 1648995 <p>While the root issue was fixed in RT1201, the incorrect hash was corrected in RT2601.</p> <p>For more information on the root fix, you can review the relative Frontier PR on GitHub. To take a look at the correction of the parent hash, check out the corresponding Moonbeam PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#incorrect-gas-fees-eip1559","title":"Incorrect Handling of EIP-1559 Gas Fees","text":"<p>With the introduction of EIP-1559 support, the logic for handling <code>maxFeePerGas</code> and <code>maxPriorityFeePerGas</code> was implemented incorrectly. As a result, the <code>maxPriorityFeePerGas</code> was added to the <code>baseFee</code> even if the total amount was over the <code>maxFeePerGas</code>.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1201 RT1401 415946 - 915320 Moonriver RT1201 RT1401 1471037 - 1705939 Moonbase Alpha RT1200 RT1400 1648994 - 1962557 <p>For more information, you can review the relative Frontier PR.</p>"},{"location":"builders/build/historical-updates/#transaction-fees-paid-to-collators","title":"Transaction Fees Paid to Collators","text":"<p>For blocks that included EIP-1559 transactions where a priority fee was applied, the transaction fees were incorrectly calculated and distributed to the block's collator. The fee model on Moonbeam for transactions and smart contract execution was previously handled so that 20% of the fees went to the on-chain Treasury and 80% were burned as a deflationary force. Due to this bug, the transaction fees of the impacted transactions were not burned as expected.</p> <p>Note that RT3401 introduced a parameters pallet fee configuration allowing governance to adjust how fees are split between the Treasury and burning. After this runtime upgrade combined with the passage of MB101, 100% of all transaction fees on both Moonbeam and Moonriver are now burned.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1201 RT1504 415946 - 1117309 Moonriver RT1201 RT1504 1471037 - 1910639 Moonbase Alpha RT1200 RT1504 1648994 - 2221772 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#incorrect-state-root-hash","title":"Incorrect State Root Hash","text":"<p>The state root hash was miscalculated for non-legacy transactions as the transaction-type byte was not considered. With the support of EIP-2930 and EIP-1559, the transaction types introduced are <code>0x01</code> (1) and <code>0x02</code> (2), respectively. These transaction types were omitted from the state root hash calculation.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1201 RT1701 415946 - 1581456 Moonriver RT1201 RT1701 1471037 - 2281722 Moonbase Alpha RT1200 RT1700 1648994 - 2529735 <p>For more information, you can review the relative Frontier PR and Moonbeam PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#ethereum-transactions-duplicated-in-storage","title":"Ethereum Transactions Duplicated in Storage","text":"<p>An upstream bug was introduced to Frontier in the Ethereum Pallet, causing pending transactions that existed during a runtime upgrade to be duplicated in storage across two different blocks. This only impacted the first two blocks after the runtime upgrade in which this bug was introduced.</p> <p>Only Moonriver and Moonbase Alpha were impacted. The bug was introduced in the following runtimes and affected the following blocks:</p> Network Introduced Impacted Blocks Moonriver RT1605 2077599 and 2077600 Moonbase Alpha RT1603 2285347 and 2285348 <p>The following transactions were duplicated:</p> MoonriverMoonbase Alpha <pre><code>'0x2cceda1436e32ae3b3a2194a8cb5bc4188259600c714789bae1fedc0bbc5125f',\n'0x3043660e35e89cafd7b0e0dce9636f5fcc218fce2a57d1104cf21aabbff9a1c0',\n'0x514411fb5c08f7c5aa6c61c38f33edfa74ff7e160831f6140e8dd3783648dbca',\n'0xf1647c357d8e1b05c522d11cff1f5090a4df114595d0f4b9e4ac5bb746473eea',\n'0x4be94803fe7839d5ef13ddd2633a293b4a7dddbe526839c15c1646c72e7b0b23',\n'0x15fceb009bd49692b598859f9146303ed4d8204b38e35c147fcdb18956679dbe',\n'0xa7460d23d5c633feec3d8e8f4382240d9b71a0d770f7541c3c32504b5403b70c',\n'0x1c838b4c4e7796a9db5edfd0377aee6e0d89b623bf1d7803f766f4cf71daefb9',\n'0xfb233a893e62d717ed627585f14b1ee8b3e300ac4e2c3016eb63e546a60820f0',\n'0xfaf8908838683ad51894eb3c68196afb99ba2e2bb698a40108960ee55417b56a',\n'0xa53973acbeac9fe948015dcfad6e0cb28d91b93c8115347c178333e73fd332d3',\n'0x9df769c96c5fdd505c67fee27eaff3714bf8f3d45a2afc02dd2984884b3cecac',\n'0x8f912ae91b408f082026992a87060ed245dac6e382a84288bd38fc08dbac30fe',\n'0xb22af459d24cb25bc53785bdd0ae6a573e24f226c94fd8d2e4663b87d3b07a88',\n'0x8ab9cd2bde7d679f798528b0c75325787f5fc7997e00589445b35b3954a815aa',\n'0xd08a1f82f4d3dc553b4b559925f997ef8bb85cb24cb4d0b893f017129fb33b78',\n'0xa1d40bce7cc607c19ca4b37152b6d8d3a408e3de6b9789c5977fcdef7ef14d97',\n'0xe442227634db10f5d0e8c1da09f8721c2a57267edbf97c4325c4f8432fd48ade',\n'0x0b4f5d8338a7c2b1604c1c42e96b12dc2a9d5ab264eb74ff730354e9765de13f',\n'0x0b00fc907701003aad75560d8b1a33cbf4b75f76c81d776b8b92d20e1d2e9d31',\n'0x9c18bd783f28427d873970ff9deaf1549db2f9a76e3edd6bdeae11358e447ef4',\n'0x8b2523f163989969dd0ebcac85d14805756bc0075b89da1274fd2c53ccaa396a',\n'0x47e80a0c533265974a55ea62131814e31b10f42895709f7e531e3e7b69f1387c'\n</code></pre> <pre><code>'0x006a6843eb35ad35a9ea9a99affa8d81f1ed500253c98cc9c080d84171a0afb3',\n'0x64c102f664eb435206ad4fcb49b526722176bcf74801c79473c3b5b2c281a243',\n'0xf546335453b6e35ce7e236ee873c96ba3a22602b3acc4f45f5d68b33a76d79ca',\n'0x4ed713ccd474fc33d2022a802f064cc012e3e37cd22891d4a89c7ba3d776f2db',\n'0xa5355f86844bb23fe666b10b509543fa377a9e324513eb221e0a2c926a64cae4',\n'0xc14791a3a392018fc3438f39cac1d572e8baadd4ed350e0355d1ca874a169e6a'\n</code></pre> <p>The duplicated transactions belong to the first block. So, on Moonriver, the transactions belong to block 2077599, and on Moonbase Alpha, the impacted transactions belong to block 2285347.</p> <p>For more information, you can review the relative Frontier PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#gas-limit-too-high-for-non-transactional-calls","title":"Gas Limit Too High for Non-Transactional Calls","text":"<p>When a non-transactional call, such as <code>eth_call</code> or <code>eth_estimateGas</code>, is made without specifying a gas limit for a past block, the client defaults to using the gas limit multiplier (10x), which causes the gas limit validation to fail as it is validating against an upper bound of the block gas limit. So, if the gas limit is greater than the block gas limit for a given call, a gas limit too high error is returned.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1701 RT1802 1581457 - 1919457 Moonriver RT1701 RT1802 2281723 - 2616189 Moonbase Alpha RT1700 RT1802 2529736 - 2879402 <p>You can review the relative Frontier PR on GitHub for more information.</p>"},{"location":"builders/build/historical-updates/#remote-evm-calls-return-identical-tx-hashes","title":"Remote EVM Calls Return Identical Transaction Hashes","text":"<p>When multiple remote EVM calls were sent from different accounts with the same transaction payload and nonce, the same transaction hash was returned for each call. This was possible because remote EVM calls are executed from a keyless account, so if the senders all had the same nonce and were sending the same transaction object, there was no differentiation in the calculation of the transaction hash. This was fixed by adding a global nonce to the Ethereum XCM Pallet, which is the pallet that makes remote EVM calls possible.</p> <p>This bug only existed on Moonbase Alpha during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbase Alpha RT1700 RT1900 2529736 - 3069634 <p>You can review the relative PR on GitHub for more information.</p>"},{"location":"builders/build/historical-updates/#gas-estimation-discrepancy","title":"Gas Estimation Discrepancy","text":"<p>There was a difference between estimating the gas for a transaction using a non-transaction call, such as <code>eth_call</code>, and the execution of it on-chain. The discrepancy occurred because the non-transactional calls were not properly accounting for <code>maxFeePerGas</code> and <code>maxPriorityFeePerGas</code>, as such, the (Proof of Validity) consumed by the Ethereum transaction was counted differently. This was fixed by properly accounting for these fields when estimating the size of the on-chain transaction.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1201 RT2501 415946 - 4543267 Moonriver RT1201 RT2500 1471037 - 5175574 Moonbase Alpha RT1200 RT2500 1648994 - 5053547 <p>You can review the relative PR on GitHub for more information.</p>"},{"location":"builders/build/historical-updates/#incorrect-effective-gas-price","title":"Incorrect Effective Gas Price In Transaction Receipts","text":"<p>The <code>effectiveGasPrice</code> value returned by <code>eth_getTransactionReceipt</code> was different from the on-chain value due to an incorrect calculation of the base fee. Specifically, the transaction receipt's value was computed using the <code>NextFeeMultiplier</code> from the block in which the transaction was included rather than the previous block, which is the correct source for computing the base fee.</p> <p>This bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbeam RT1201 RT2801 415946 - 5899847 Moonriver RT1201 RT2801 1471037 - 6411588 Moonbase Alpha RT1200 RT2801 1648994 - 6209638 <p>You can review the relative Frontier PR and Moonbeam PR on GitHub for more information.</p>"},{"location":"builders/build/historical-updates/#skipped-ethereum-transaction-traces","title":"Skipped Ethereum Transaction Traces","text":"<p>Runtimes with the <code>evm-tracing</code> feature enabled introduced additional <code>ref_time</code> overhead due to special logic that traces Ethereum transactions (emitting events for each component: gasometer, runtime, EVM) used to fill information for RPC calls like <code>debug_traceTransaction</code> and <code>trace_filter</code>. </p> <p>Since the real <code>ref_time</code> in production runtimes is smaller, this could cause the block weight limits to be reached when replaying a block in an EVM-tracing runtime, resulting in skipped transaction traces. This was observed in Moonbeam block 9770044.</p> <p>The fix consisted of resetting the previously consumed weight before tracing each Ethereum transaction. It's important to note that this issue only affected code under <code>evm-tracing</code>, which is not included in any production runtime.</p> <p>This bug was fixed in the following runtime:</p> Network Fixed Impacted Block Moonbeam RT3501 9770044 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#notify-inactive-collator-fails","title":"Notify Inactive Collator Fails for Long-Inactive Collators","text":"<p>The <code>notifyInactiveCollator</code> extrinsic, designed to remove collators from the pool if they haven't produced any blocks in the last two rounds, failed for collators who had been inactive for significantly longer than two rounds. The transaction would only succeed within the first few blocks of a new round.</p> <p>The bug existed during the following runtimes and block ranges:</p> Network Introduced Fixed Impacted Block Range Moonbase Alpha RT2601 RT3500 5474345 \u2013 10750816 Moonriver RT2602 RT3501 5638536 \u2013 10665393 Moonbeam RT2602 RT3501 4977160 \u2013 10056989"},{"location":"builders/build/historical-updates/#for-more-information-you-can-review-the-relative-pr-on-github","title":"For more information, you can review the relative PR on GitHub.","text":""},{"location":"builders/build/historical-updates/#migrations","title":"Migrations","text":"<p>Migrations are necessary when a storage item is changed or added and needs to be populated with data. The migrations listed below have been organized by the impacted pallet(s).</p>"},{"location":"builders/build/historical-updates/#author-mapping","title":"Author Mapping Pallet","text":""},{"location":"builders/build/historical-updates/#update-mapping-storage-item","title":"Update the Mapping Storage Item","text":"<p>This migration updated the now deprecated <code>Mapping</code> storage item of the author mapping pallet to use a more secure hasher type. The hasher type was updated to Blake2_128Concat instead of Twox64Concat.</p> <p>This migration was only applied to Moonriver and Moonbase Alpha and was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonriver RT800 684728 Moonbase Alpha RT800 915684 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#add-support-for-vrf-keys","title":"Add Support for VRF Keys","text":"<p>When VRF key support was introduced, the <code>MappingWithDeposit</code> storage item of the author mapping pallet was updated to include a <code>keys</code> field to support VRF keys that can be looked up via the Nimbus ID. A migration was applied to update the existing storage items with this new field.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1502 1107285 Moonriver RT1502 1814458 Moonbase Alpha RT1502 2112058 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#one-nimbus-id-per-account-id","title":"One Nimbus ID per Account ID","text":"<p>A migration was applied to ensure that an account ID can have only one Nimbus ID. The migration accepted the first Nimbus ID owned by a given account and cleared any additional Nimbus IDs associated with the account. For any cleared associations, the bond for the association was returned.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1606 1326697 Moonriver RT1605 2077599 Moonbase Alpha RT1603 2285347 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#base-fee","title":"Base Fee Pallet","text":""},{"location":"builders/build/historical-updates/#set-elasticity","title":"Set Elasticity Storage Item Value","text":"<p>This migration sets the <code>Elasticity</code> storage item of the base fee pallet to zero, which results in a constant <code>BaseFeePerGas</code>.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1300 524762 Moonriver RT1300 1541735 Moonbase Alpha RT1300 1761128 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#democracy","title":"Democracy Pallet","text":""},{"location":"builders/build/historical-updates/#preimage-storage-moved-to-new-preimage-pallet","title":"Preimage Storage Moved to New Preimage Pallet","text":"<p>A migration was applied, which moved preimages stored in the democracy pallet to a new preimage pallet. This migration on Moonbeam was required as a result of an upstream change to Polkadot.</p> <p>There was one preimage that was affected in Moonbeam, which was dropped from the scheduler queue and never executed: <code>0x14262a42aa6ccb3cae0a169b939ca5b185bc317bb7c449ca1741a0600008d306</code>. This preimage was manually removed by the account that initially submitted the preimage.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2000 3310369 Moonriver RT2000 3202604 Moonbase Alpha RT2000 2673234 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#remove-gov-v1-collectives","title":"Remove Governance V1 Collectives","text":"<p>A migration was applied to remove the governance V1 collectives, which included the Council and Technical Committee. The governance V1 collectives were replaced with the OpenGov (governance V2) Technical Committee.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2801 5899847 Moonriver RT2801 6411588 Moonbase Alpha RT2801 6209638 <p>For more information, you can review the relative PR on GitHub.</p> <p>A follow-up migration was required to properly clear the storage entries associated with the governance V1 collectives, which was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2901 6197065 Moonriver RT2901 6699589 Moonbase Alpha RT2901 6710531 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#remove-gov-v1-collectives","title":"Remove Governance V1 Democracy Pallet","text":"<p>A migration was applied to remove the storage associated with the Democracy Pallet used in governance V1. The Democracy Pallet was replaced with the Preimage, Referenda, and Collective Voting OpenGov (governance V2) pallets.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2901 6197065 Moonriver RT2901 6699589 Moonbase Alpha RT2901 6710531 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#evm-pallet","title":"EVM Pallet","text":""},{"location":"builders/build/historical-updates/#evm-contract-metadata","title":"EVM Contract Metadata","text":"<p>A migration was introduced to automate the manual process of setting EVM contract metadata for contracts deployed more than two years ago that hadn't been interacted with after the introduction of metadata storage item. This migration replaces the need to manually call <code>createContractMetadata(address)</code> on these contracts to make them compatible with the current runtime. </p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT3200 7985204 Moonriver RT3200 8519187"},{"location":"builders/build/historical-updates/#moonbeam-orbiter","title":"Moonbeam Orbiter Pallet","text":""},{"location":"builders/build/historical-updates/#remove-orbiter-minimum-bond","title":"Remove the Minimum Bond Requirement for Orbiter Collators","text":"<p>A migration was applied to the Moonbeam Orbiter Pallet that sets the bonds of the existing orbiter collators to zero. This change enabled payouts to be even for future orbiter program expansions.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2602 4977160 Moonriver RT2602 5638536 Moonbase Alpha RT2601 5474345 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#parachain-staking","title":"Parachain Staking Pallet","text":""},{"location":"builders/build/historical-updates/#update-collator-state-storage-item","title":"Update Collator State Storage Item","text":"<p>A migration was applied that updated the <code>Collator</code> storage item of the parachain staking pallet to the new <code>Collator2</code> storage item. This change updated the collator state to include the following items:</p> <ul> <li>The <code>nominators</code> set is a list of all of the nominator (delegator) account IDs without their respective balance bonded</li> <li>A new <code>top_nominators</code> storage item that returns a list of all of the top nominators ordered by greatest bond amount to least</li> <li>A new <code>bottom_nominators</code> storage item that returns a list of all of the bottom nominators ordered by least bond amount to greatest</li> <li>The <code>total</code> storage item was replaced with <code>total_counted</code> and <code>total_backing</code>. The <code>total_counted</code> item returns the sum of the top nominations and the collator's self-bond, whereas the <code>total_backing</code> item returns the sum of all of the nominations and the collator's self-bond</li> </ul> <p>This migration was only applied to Moonriver and Moonbase Alpha and was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonriver RT53 9696 Moonbase Alpha RT52 238827 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#patch-total-staked-amount","title":"Patch Total Staked Amount","text":"<p>A migration was applied to the <code>total</code> staked amount of the <code>CollatorState</code> storage item in the Parachain Staking Pallet due to a potential bug that may have led to an incorrect amount.</p> <p>This migration was only applied to Moonriver and Moonbase Alpha and was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonriver RT53 9696 Moonbase Alpha RT52 238827 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#support-delayed-nominator-exits","title":"Support Delayed Nominator (Delegator) Exits","text":"<p>The exit queue for handling candidate exits had been updated to include support for delayed nominator (delegator) exits and revocations, which required a migration to update the <code>ExitQueue</code> parachain staking pallet storage item to <code>ExitQueue2</code>. The <code>NominatorState</code> storage item was also migrated to <code>NominatorState2</code> to prevent a nominator from performing more nominations when they already have scheduled an exit.</p> <p>These migrations were only applied to Moonriver and Moonbase Alpha and were executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonriver RT200 259002 Moonbase Alpha RT200 457614 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#purge-staking-storage-bloat","title":"Purge Staking Storage Bloat","text":"<p>A migration was applied to purge staking storage bloat for the <code>Points</code> and <code>AtStake</code> storage items of the parachain staking pallet that are older than two rounds.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1001 5165 Moonriver RT1001 1052242 Moonbase Alpha RT1001 1285916 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#support-manual-exits-dpos-terminology","title":"Support Manual Exits and DPoS Terminology","text":"<p>The parachain staking pallet was updated to include manual exits. If a candidate or delegator wanted to decrease or revoke their bond or leave the candidate or delegator pool, they would need to schedule a request first, wait for a delay period to pass, and then manually execute the request. As such, a migration was applied to replace the automatic exit queue, including the <code>ExitQueue2</code> storage item, with a manual exits API.</p> <p>In addition, a change was made to switch from Nominated Proof of Stake (NPoS) to Delegated Proof of Stake (DPoS) terminology; this marked the sweeping change from \"nominate\" to \"delegate\". This required the migration of the following parachain staking pallet storage items:</p> <ul> <li><code>CollatorState2</code> was migrated to <code>CandidateState</code></li> <li><code>NominatorState2</code> was migrated to <code>DelegatorState</code></li> </ul> <p>These migrations were executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1001 5165 Moonriver RT1001 1052242 Moonbase Alpha RT1001 1285916 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#increase-max-delegations-per-candidate","title":"Increase Max Delegations per Candidate","text":"<p>A migration was applied to increase the maximum number of delegations per candidate in the parachain staking pallet. It increased the delegations from 100 to 500 on Moonbase Alpha and Moonriver and from 100 to 1000 on Moonbeam.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1101 171061 Moonriver RT1101 1188000 Moonbase Alpha RT1100 1426319 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#split-candidate-delegations-top-bottom","title":"Split Candidate Delegations into Top and Bottom","text":"<p>This migration splits the deprecated <code>CandidateState</code> storage item of the parachain staking pallet into the following three new storage items to avoid unnecessary storage reads:</p> <ul> <li><code>CandidateInfo</code></li> <li><code>TopDelegations</code></li> <li><code>BottomDelegations</code></li> </ul> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1201 415946 Moonriver RT1201 1471037 Moonbase Alpha RT1200 1648994 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#patch-incorrect-total-delegations","title":"Patch Incorrect Total Delegations","text":"<p>There was a migration applied to fix the Incorrect Collator Selection bug and patch the delegations total for all candidates.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1300 524762 Moonriver RT1300 1541735 Moonbase Alpha RT1300 1761128 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#split-delegator-state","title":"Split Delegator State into Delegation Scheduled Requests","text":"<p>A migration was applied that moved pending delegator requests from the <code>DelegatorState</code> storage item of the parachain staking pallet into a new <code>DelegationScheduledRequests</code> storage item.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1502 1107285 Moonriver RT1502 1814458 Moonbase Alpha RT1502 2112058 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#replace-staking-reserves","title":"Replace Staking Reserves with Locks","text":"<p>A migration was applied that changed users' staking reserved balances to locked balances. The locked balance is the same type as democracy-locked funds, allowing users to use their staked funds to participate in democracy.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1701 1581457 Moonriver RT1701 2281723 Moonbase Alpha RT1700 2529736 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#auto-compounding-support","title":"Auto-Compounding Support","text":"<p>To support auto-compounding, two migrations were applied to the <code>AtStake</code> storage item in the parachain staking pallet:</p> <ul> <li><code>RemovePaidRoundsFromAtStake</code> - to remove any stale <code>AtStake</code> entries relating to already paid-out rounds with candidates that didn't produce any blocks. This migration is a prerequisite for the <code>MigrateAtStakeAutoCompound</code> migration</li> <li><code>MigrateAtStakeAutoCompound</code> - migrates the snapshots for unpaid rounds for <code>AtStake</code> entries</li> </ul> <p>These migrations were executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1901 2317683 Moonriver RT1901 2911863 Moonbase Alpha RT1900 3069635 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#block-based-staking-rounds","title":"Switch to Block-Based Staking Rounds","text":"<p>A migration was applied to switch from time-based staking rounds to fixed block-based rounds.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2801 5899847 Moonriver RT2801 6411588 Moonbase Alpha RT2801 6209638 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#renaming-of-parachain-bond-reserve-events","title":"Renaming of Parachain Bond Reserve Events","text":"<p>Prior to Runtime 3300, the <code>ReservedForParachainBond</code> event was emitted once per round to indicate parachain bond reserve funding through inflation. In Runtime 3300, this same event was renamed to <code>InflationDistributed</code>.</p> <p>This change took effect at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT3300 8381443 Moonriver RT3300 8894417 Moonbase Alpha RT3300 9062316 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#parachainstaking-currency-to-fungible","title":"ParachainStaking: Currency \u2192 Fungible Migration","text":"<p>A migration was applied to move the <code>ParachainStaking</code> pallet from the deprecated Currency trait to the modern Fungible trait. Operationally, staking \u201clocks\u201d were replaced by balance \u201cfreezes\u201d: queries that previously read <code>Balances.Locks</code> with identifiers [<code>stkngcol</code>, <code>stkngdel</code>] must now read <code>Balances.Freezes</code> with freeze reasons [<code>StakingCollator</code>, <code>StakingDelegator</code>]. The frozen balance shown in <code>System.Account</code> is unchanged by this migration. </p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT4000 - Moonriver RT4000 - Moonbase Alpha RT4000 14191989"},{"location":"builders/build/historical-updates/#referenda-pallet","title":"Referenda Pallet","text":""},{"location":"builders/build/historical-updates/#refunds-for-submission-deposits","title":"Refunds for Submission Deposits","text":"<p>A migration was introduced to support refunds for submission deposits on closed referenda that updated the <code>ReferendumInfo</code> type. The following invariants of <code>ReferendumInfo</code> were changed so that the second parameter, <code>Deposit&lt;AccountId, Balance&gt;</code>, is now optional, <code>Option&lt;Deposit&lt;AccountId, Balance&gt;&gt;</code>: <code>Approved</code>, <code>Rejected</code>, <code>Cancelled</code>, and <code>TimedOut</code>.</p> <p>This stemmed from an upstream change to the Substrate repository.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2302 3456477 Moonriver RT2302 4133065 Moonbase Alpha RT2301 4172407 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#restore-corrupted-referenda-deposits","title":"Restore Corrupted Referenda Deposits","text":"<p>A migration was introduced to support restoring referenda deposits affected by corrupted storage values. The issue arose when a migration was applied twice due to a pallet version error, resulting in invalid values and non-refundable submission deposits. As the number of values to correct was finite and small, this migration created a list to update them by hand.</p> <p>This migration was only applied to Moonbeam and was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT3100 7303601"},{"location":"builders/build/historical-updates/#xcm-related-pallets","title":"XCM-Related Pallets","text":""},{"location":"builders/build/historical-updates/#update-transaction-info","title":"Update Transact Info Storage Item","text":"<p>There was a migration applied to the <code>TransactInfo</code> storage item of the XCM Transactor Pallet that changed the following items:</p> <ul> <li><code>max_weight</code> is added to prevent transactors from stalling the queue in the destination chain</li> <li>Removes <code>fee_per_byte</code>, <code>metadata_size</code>, and <code>base_weight</code> as these items are not necessary for XCM transactions</li> <li><code>fee_per_second</code> replaces <code>fee_per_weight</code> to better reflect cases (like Kusama) in which the <code>fee_per_weight</code> unit is lower than one</li> </ul> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1201 415946 Moonriver RT1201 1471037 Moonbase Alpha RT1200 1648994 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#add-support-statemine-prefix","title":"Add Support for Kusama Asset Hub (Statemine) Prefix Breaking Change","text":"<p>The following three migrations were added to the asset manager pallet to avoid issues with Kusama Asset Hub's (previously referred to as Statemine) breaking change to the way it represents assets and possible future breaking changes:</p> <ul> <li><code>UnitsWithAssetType</code> - updates the <code>AssetTypeUnitsPerSecond</code> storage item to a mapping of the <code>AssetType</code> to <code>units_per_second</code>, instead of the mapping <code>AssetId</code> to <code>units_per_second</code>. This is done to avoid additional migrations whenever a breaking change arises</li> <li><code>PopulateAssetTypeIdStorage</code> - creates a new <code>AssetTypeId</code> storage item that holds the <code>AssetType</code> to <code>AssetId</code> mapping, which allows the decoupling of <code>assetIds</code> and <code>AssetTypes</code></li> <li><code>ChangeStateminePrefixes</code> - updates already registered Kusama Asset Hub (Statemine) assets to their new form</li> </ul> <p>These migrations were executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1201 415946 Moonriver RT1201 1471037 Moonbase Alpha RT1200 1648994 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#add-supported-fee-payment-assets","title":"Add New Supported Fee Payment Assets Storage Item","text":"<p>A migration was applied to the asset manager pallet, creating a new <code>SupportedFeePaymentAssets</code> storage item by reading the supported asset data from the <code>AssetTypeUnitsPerSecond</code> storage item. This storage item will hold all the assets we accept for XCM fee payment. It will be read when an incoming XCM message is received, and if the asset is not in storage, the message will not be processed.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1300 524762 Moonriver RT1300 1541735 Moonbase Alpha RT1300 1761128 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#update-xcm-transactor","title":"Update the XCM Transactor Storage from V2 to V3","text":"<p>With the support of XCM V3, a migration was applied to update the XCM Transactor pallet's storage from XCM V2 to V3. The <code>transactInfoWithWeightLimit</code> and <code>destinationAssetFeePerSecond</code> storage items were updated to support XCM V3 multilocations.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2302 3456477 Moonriver RT2302 4133065 Moonbase Alpha RT2301 4172407 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#remove-local-assets","title":"Remove Mintable XC-20s","text":"<p>Mintable XC-20s were deprecated in favor of XCM-enabled ERC-20s; as such, a migration was applied to remove the local assets pallet and clear the assets in storage.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT2801 5899847 Moonriver RT2801 6411588 Moonbase Alpha RT2801 6209638 <p>For more information, you can review the relative PR on GitHub.</p>"},{"location":"builders/build/historical-updates/#foreign-assets-migration","title":"Manage Foreign Assets via Smart Contracts","text":"<p>A migration was applied to transition existing foreign assets to a new design that manages XCM derivative assets on Moonbeam through EVM smart contracts instead of the previous implementation using the Asset and Asset Manager pallets. The migration process involved several extrinsics in the Moonbeam Lazy Migration pallet:</p> <ul> <li><code>approve_assets_to_migrate</code> - sets the list of asset IDs approved for migration</li> <li><code>start_foreign_asset_migration</code> - initiates migration for a specific foreign asset by freezing the original asset and creating a new EVM smart contract</li> <li><code>migrate_foreign_asset_balances</code> - migrates asset balances in batches from old assets pallet to the new system</li> <li><code>migrate_foreign_asset_approvals</code> - migrates asset approvals in batches while unreserving deposits from the old approval system</li> <li><code>finish_foreign_asset_migration</code> - completes migration after all balances and approvals are migrated and performs final cleanup</li> </ul> <p>This migration preserves compatibility with existing foreign assets by identifying each foreign asset with the same AssetID integer as before. This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT3501 10056989 Moonriver RT3501 10665393 Moonbase Alpha RT3500 10750816 <p>For more information, you can review the relative PRs on GitHub: 2869 and 3020.</p>"},{"location":"builders/build/historical-updates/#nimbus","title":"Nimbus Author Filter Pallet","text":""},{"location":"builders/build/historical-updates/#replace-eligible-ratio","title":"Replace Eligible Ratio with Eligible Count","text":"<p>A breaking change was applied to the Nimbus repository, deprecating <code>EligibleRatio</code> in favor of the <code>EligibleCount</code> config. As a result, a migration was applied to the Moonbeam repository, populating the new <code>EligibleCount</code> value as a percentage of the potential authors defined at that block height if the <code>EligibleRatio</code> value existed. Otherwise, the value was set to a default value of <code>50</code>.</p> <p>This migration was executed at the following runtimes and blocks:</p> Network Executed Runtime Block Applied Moonbeam RT1502 1107285 Moonriver RT1502 1814458 Moonbase Alpha RT1502 2112058 <p>For more information, you can review the relative Nimbus PR and Moonbeam PR on GitHub.</p>"},{"location":"builders/build/runtime-upgrades/","title":"Runtime Upgrades","text":""},{"location":"builders/build/runtime-upgrades/#introduction","title":"Introduction","text":"<p>Moonbeam runtime upgrades allow for the maintenance and evolution of the chain logic without the need for a hard fork. These runtime upgrades can introduce new features, improve performance, fix bugs, and respond to changing requirements.</p> <p>This page provides a historical record of runtime upgrades by block for each of the Moonbeam-based networks.</p>"},{"location":"builders/build/runtime-upgrades/#runtime-upgrades-by-block","title":"Runtime Upgrades by Block","text":"<p>The following table contains a list of the runtime upgrades and the block at which the upgrade occurred for each network. Runtime upgrades occur first on Moonbase Alpha before being released on Moonriver and then on Moonbeam. You can read the release notes for each runtime on the Moonbeam releases GitHub page.</p> <p>Not all runtime upgrades are released on each network, as sometimes after releasing the initial runtime upgrade, the need for a subsequent upgrade arises. If a runtime upgrade version has been skipped or hasn't been released yet (only applicable to the latest runtime upgrade), you'll see a <code>-</code> in that row.</p> Runtime Moonbeam Moonriver Moonbase Alpha 40 - - 0 44 - - 142863 47 - - 209144 49 - 0 - 52 - - 238827 53 - 9696 - 155 - 67938 278703 159 - 166749 383465 200 - 259002 457614 300 - 344698 485543 400 - 400458 610935 501 - 430442 653692 600 - 455107 675176 701 - 581187 797200 800 - 684728 915684 900 0 923864 1075626 901 - - 1130271 902 - - 1175311 1001 5165 1052242 1285916 1002 32532 1141593 1396972 1101 171061 1188000 1426319 1102 214641 1295420 1517440 1103 312036 1389122 1591913 1200 - - 1648994 1201 415946 1471037 1679619 1300 524762 1541735 1761128 1400 - - 1962557 1401 915320 1705939 1967358 1502 1107285 1814458 2112058 1503 1115896 1909326 2220736 1504 1117310 1910640 2221773 1603 - - 2285347 1605 - 2077599 2318567 1606 1326697 2105127 2379759 1700 - - 2529736 1701 1581457 2281723 2534200 1702 1821212 2524247 - 1800 - - 2748786 1801 - 2572556 2830542 1802 1919458 2616190 2879403 1803 2073477 2767174 3004714 1900 - - 3069635 1901 2317683 2911863 3073562 2000 2673234 3202604 3310369 2100 3011798 3588831 3609708 2201 3290853 3858885 3842850 2301 - - 4172407 2302 3456477 4133065 4193323 2401 - 4668844 4591616 2402 - - 4772817 2403 4163078 4770488 4804425 2500 - 5175574 5053547 2501 4543267 5211264 5194594 2601 - - 5474345 2602 4977160 5638536 5576588 2700 5504531 6041969 5860584 2801 5899847 6411588 6209638 2901 6197065 6699589 6710531 2902 - - 6732678 3000 - 7043011 7299818 3001 6593037 - - 3100 7303601 7829527 8034666 3102 7586782 - - 3200 7985204 8519187 8722328 3300 8381443 8894417 9062316 3400 9376921 9774989 9830392 3401 9661355 10269872 10422450 3500 - - 10750816 3501 10056989 10665393 10833906 3600 10746745 11251274 11452321 3601 10999397 11692212 - 3700 - - 12152458 3701 11426910 12003279 12242104 3702 11499659 12156948 12683255 3800 12120762 12540836 12853655 3900 12960126 13423618 13744975 3901 13428709 - - 4000 - 14078615 14191989 4001 13654437 - - 4100 - 14623899 14535211 4101 - 14664970 - 4102 14314943 14970171 -"},{"location":"builders/ethereum/canonical-contracts/","title":"Canonical Contracts","text":""},{"location":"builders/ethereum/canonical-contracts/#common-goods-contracts","title":"Common-good Contracts","text":"<p>The following contracts addresses have been established:</p> MoonbeamMoonriverMoonbase Alpha Contract Address WGLMR 0xAcc15dC74880C9944775448304B263D191c6077F Multicall 0x83e3b61886770de2F64AAcaD2724ED4f08F7f36B Multicall2 0x6477204E12A7236b9619385ea453F370aD897bb2 Multicall3 0xcA11bde05977b3631167028862bE2a173976CA11 Multisig Factory 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2 EIP-1820 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24 Contract Address WMOVR 0x98878B06940aE243284CA214f92Bb71a2b032B8A Multicall* 0x30f283Cc0284482e9c29dFB143bd483B5C19954b Multicall2 0xaef00a0cf402d9dedd54092d9ca179be6f9e5ce3 Multicall3 0xcA11bde05977b3631167028862bE2a173976CA11 Multisig Factory 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2 EIP-1820 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24 <p>*Deployed by SushiSwap</p> Contract Address WDEV 0xD909178CC99d318e4D46e7E66a972955859670E1 Multicall* 0x4E2cfca20580747AdBA58cd677A998f8B261Fc21 Multicall2 0x37084d0158C68128d6Bc3E5db537Be996f7B6979 Multicall3 0xcA11bde05977b3631167028862bE2a173976CA11 Multisig Factory 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2 EIP-1820 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24 <p>*Deployed in the UniswapV2 Demo Repo</p>"},{"location":"builders/ethereum/canonical-contracts/#precompiled-contracts","title":"Precompiled Contracts","text":"<p>There are a set of precompiled contracts included on Moonbeam, Moonriver, and Moonbase Alpha that are categorized by address and based on the origin network. If you were to convert the precompiled addresses to decimal format, and break them into categories by numeric value, the categories are as follows:</p> <ul> <li>0-1023 - Ethereum MainNet precompiles</li> <li>1024-2047 - precompiles that are not in Ethereum and not Moonbeam specific</li> <li>2048-4095 - Moonbeam specific precompiles</li> </ul>"},{"location":"builders/ethereum/canonical-contracts/#ethereum-mainnet-precompiles","title":"Ethereum MainNet Precompiles","text":"MoonbeamMoonriverMoonbase Alpha Contract Address ECRECOVER 0x0000000000000000000000000000000000000001 SHA256 0x0000000000000000000000000000000000000002 RIPEMD160 0x0000000000000000000000000000000000000003 Identity 0x0000000000000000000000000000000000000004 Modular Exponentiation 0x0000000000000000000000000000000000000005 BN128Add 0x0000000000000000000000000000000000000006 BN128Mul 0x0000000000000000000000000000000000000007 BN128Pairing 0x0000000000000000000000000000000000000008 Blake2 0x0000000000000000000000000000000000000009 P256Verify 0x0000000000000000000000000000000000000100 Contract Address ECRECOVER 0x0000000000000000000000000000000000000001 SHA256 0x0000000000000000000000000000000000000002 RIPEMD160 0x0000000000000000000000000000000000000003 Identity 0x0000000000000000000000000000000000000004 Modular Exponentiation 0x0000000000000000000000000000000000000005 BN128Add 0x0000000000000000000000000000000000000006 BN128Mul 0x0000000000000000000000000000000000000007 BN128Pairing 0x0000000000000000000000000000000000000008 Blake2 0x0000000000000000000000000000000000000009 P256Verify 0x0000000000000000000000000000000000000100 Contract Address ECRECOVER 0x0000000000000000000000000000000000000001 SHA256 0x0000000000000000000000000000000000000002 RIPEMD160 0x0000000000000000000000000000000000000003 Identity 0x0000000000000000000000000000000000000004 Modular Exponentiation 0x0000000000000000000000000000000000000005 BN128Add 0x0000000000000000000000000000000000000006 BN128Mul 0x0000000000000000000000000000000000000007 BN128Pairing 0x0000000000000000000000000000000000000008 Blake2 0x0000000000000000000000000000000000000009 P256Verify 0x0000000000000000000000000000000000000100"},{"location":"builders/ethereum/canonical-contracts/#non-moonbeam-specific-nor-ethereum-precompiles","title":"Non-Moonbeam Specific nor Ethereum Precompiles","text":"MoonbeamMoonriverMoonbase Alpha Contract Address SHA3FIPS256 0x0000000000000000000000000000000000000400 Dispatch [Removed] 0x0000000000000000000000000000000000000401 ECRecoverPublicKey 0x0000000000000000000000000000000000000402 Contract Address SHA3FIPS256 0x0000000000000000000000000000000000000400 Dispatch [Removed] 0x0000000000000000000000000000000000000401 ECRecoverPublicKey 0x0000000000000000000000000000000000000402 Contract Address SHA3FIPS256 0x0000000000000000000000000000000000000400 Dispatch [Removed] 0x0000000000000000000000000000000000000401 ECRecoverPublicKey 0x0000000000000000000000000000000000000402"},{"location":"builders/ethereum/canonical-contracts/#moonbeam-specific-precompiles","title":"Moonbeam-Specific Precompiles","text":"MoonbeamMoonriverMoonbase Alpha Contract Address Parachain Staking 0x0000000000000000000000000000000000000800 ERC-20 Interface 0x0000000000000000000000000000000000000802 Democracy [Removed] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 Relay Encoder 0x0000000000000000000000000000000000000805 XCM Transactor V1 0x0000000000000000000000000000000000000806 Author Mapping 0x0000000000000000000000000000000000000807 Batch 0x0000000000000000000000000000000000000808 Randomness 0x0000000000000000000000000000000000000809 Call Permit 0x000000000000000000000000000000000000080a Proxy 0x000000000000000000000000000000000000080b XCM Utilities 0x000000000000000000000000000000000000080C XCM Transactor V2 0x000000000000000000000000000000000000080d Council Collective [Removed] 0x000000000000000000000000000000000000080e Technical Committee Collective [Removed] 0x000000000000000000000000000000000000080f Treasury Council Collective 0x0000000000000000000000000000000000000810 Referenda 0x0000000000000000000000000000000000000811 Conviction Voting 0x0000000000000000000000000000000000000812 Preimage 0x0000000000000000000000000000000000000813 OpenGov Tech Committee 0x0000000000000000000000000000000000000814 Precompile Registry 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM Transactor V3 0x0000000000000000000000000000000000000817 Identity 0x0000000000000000000000000000000000000818 XCM Interface 0x000000000000000000000000000000000000081A Contract Address Parachain Staking 0x0000000000000000000000000000000000000800 ERC-20 Interface 0x0000000000000000000000000000000000000802 Democracy [Removed] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 Relay Encoder 0x0000000000000000000000000000000000000805 XCM Transactor V1 0x0000000000000000000000000000000000000806 Author Mapping 0x0000000000000000000000000000000000000807 Batch 0x0000000000000000000000000000000000000808 Randomness 0x0000000000000000000000000000000000000809 Call Permit 0x000000000000000000000000000000000000080a Proxy 0x000000000000000000000000000000000000080b XCM Utilities 0x000000000000000000000000000000000000080C XCM Transactor V2 0x000000000000000000000000000000000000080d Council Collective [Removed] 0x000000000000000000000000000000000000080e Technical Committee Collective [Removed] 0x000000000000000000000000000000000000080f Treasury Council Collective 0x0000000000000000000000000000000000000810 Referenda 0x0000000000000000000000000000000000000811 Conviction Voting 0x0000000000000000000000000000000000000812 Preimage 0x0000000000000000000000000000000000000813 OpenGov Tech Committee 0x0000000000000000000000000000000000000814 Precompile Registry 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM Transactor V3 0x0000000000000000000000000000000000000817 Identity 0x0000000000000000000000000000000000000818 XCM Interface 0x000000000000000000000000000000000000081A Contract Address Parachain Staking 0x0000000000000000000000000000000000000800 ERC-20 Interface 0x0000000000000000000000000000000000000802 Democracy [Removed] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 Relay Encoder 0x0000000000000000000000000000000000000805 XCM Transactor V1 0x0000000000000000000000000000000000000806 Author Mapping 0x0000000000000000000000000000000000000807 Batch 0x0000000000000000000000000000000000000808 Randomness 0x0000000000000000000000000000000000000809 Call Permit 0x000000000000000000000000000000000000080a Proxy 0x000000000000000000000000000000000000080b XCM Utilities 0x000000000000000000000000000000000000080C XCM Transactor V2 0x000000000000000000000000000000000000080d Council Collective [Removed] 0x000000000000000000000000000000000000080e Technical Committee Collective [Removed] 0x000000000000000000000000000000000000080f Treasury Council Collective 0x0000000000000000000000000000000000000810 Referenda 0x0000000000000000000000000000000000000811 Conviction Voting 0x0000000000000000000000000000000000000812 Preimage 0x0000000000000000000000000000000000000813 OpenGov Tech Committee 0x0000000000000000000000000000000000000814 Precompile Registry 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM Transactor V3 0x0000000000000000000000000000000000000817 Identity 0x0000000000000000000000000000000000000818 XCM Interface 0x000000000000000000000000000000000000081A"},{"location":"builders/ethereum/dev-env/foundry/","title":"Using Foundry to Deploy To Moonbeam","text":""},{"location":"builders/ethereum/dev-env/foundry/#introduction","title":"Introduction","text":"<p>Foundry is an Ethereum development environment written in Rust that helps developers manage dependencies, compile projects, run tests, deploy contracts, and interact with blockchains from the command line. Foundry can directly interact with Moonbeam's Ethereum API so it can be used to deploy smart contracts into Moonbeam.</p> <p>Four tools make up Foundry:  </p> <ul> <li>Forge: Compiles, tests, and deploys contracts.</li> <li>Cast: A command line interface for interacting with contracts.</li> <li>Anvil: A local TestNet node for development purposes that can fork preexisting networks.</li> <li>Chisel: A Solidity REPL for quickly testing Solidity snippets.</li> </ul> <p>This guide will cover how to use Foundry to compile, deploy, and debug Ethereum smart contracts on the Moonbase Alpha TestNet. This guide can also be adapted for Moonbeam, Moonriver, or a Moonbeam development node.</p>"},{"location":"builders/ethereum/dev-env/foundry/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you will need the following:</p> <ul> <li>Have an account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet.</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</li> <li>Have Foundry installed</li> </ul>"},{"location":"builders/ethereum/dev-env/foundry/#creating-a-foundry-project","title":"Creating a Foundry Project","text":"<p>You will need to create a Foundry project if you don't already have one. You can create one by completing the following steps:</p> <ol> <li> <p>Install Foundry if you haven't already. If on Linux or MacOS, you can run these commands:</p> <pre><code>curl -L https://foundry.paradigm.xyz | bash\nfoundryup\n</code></pre> <p>If on Windows, you'll have to install Rust and then build Foundry from source:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs/ | sh\ncargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked\n</code></pre> </li> <li> <p>Create the project, which will create a folder with three folders within it, and open it:</p> <pre><code>forge init foundry &amp;&amp; cd foundry\n</code></pre> </li> </ol> <p>With the default project created, you should see three folders.  </p> <ul> <li><code>lib</code>: All of the project's dependencies in the form of git submodules.</li> <li><code>src</code>: Where to put your smart contracts (with functionality).</li> <li><code>test</code>: Where to put the forge tests for your project, which are written in Solidity.</li> </ul> <p>In addition to these three folders, a git project will also be created along with a prewritten <code>.gitignore</code> file with relevant file types and folders ignored.</p>"},{"location":"builders/ethereum/dev-env/foundry/#the-src-folder","title":"The Source Folder","text":"<p>The <code>src</code> folder may already contain <code>Counter.sol</code>, a minimal Solidity contract. Feel free to delete it. To avoid errors, you should also delete the <code>Counter.s.sol</code> file in the <code>scripts</code> folder and the <code>Counter.t.sol</code> file in the <code>test</code> folder. In the following steps, you will be deploying an ERC-20 contract. In the contracts directory, you can create the <code>MyToken.sol</code> file:</p> <pre><code>cd src\ntouch MyToken.sol\n</code></pre> <p>Open the file and add the following contract to it:</p> <pre><code>pragma solidity ^0.8.30;\n\n// Import OpenZeppelin Contract\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// This ERC-20 contract mints the specified amount of tokens to the contract creator\ncontract MyToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MYTOK\") {\n        _mint(msg.sender, initialSupply);\n    }\n}\n</code></pre> <p>Before you attempt to compile, install OpenZeppelin contracts as a dependency. You may have to commit previous changes to git beforehand. By default, Foundry uses git submodules instead of npm packages, so the traditional npm import path and command are not used. Instead, use the name of OpenZeppelin's GitHub repository:</p> <pre><code>forge install OpenZeppelin/openzeppelin-contracts\n</code></pre>"},{"location":"builders/ethereum/dev-env/foundry/#compiling-solidity","title":"Compiling Solidity","text":"<p>Once all dependencies have been installed, you can compile the contract:</p> <pre><code>forge build\n</code></pre> forge build [\u2812] Compiling... [\u2830] Compiling 30 files with 0.8.23 [\u2814] Solc 0.8.23 finished in 2.29s Compiler run successful! <p>After compilation, two folders will be created: <code>out</code> and <code>cache</code>. The ABI and bytecode for your contracts will be contained within the <code>out</code> folder. These two folders are already ignored by the <code>.gitignore</code> included in the default Foundry project initialization.</p>"},{"location":"builders/ethereum/dev-env/foundry/#deploying-the-contract","title":"Deploying the Contract","text":"<p>There are two primary ways to deploy contracts using Foundry. The first is the straightforward command <code>forge create</code>. There's also the more flexible and powerful option of foundry scripting, which runs simulations before any deployments. In the following sections, <code>forge create</code> and foundry scripting will both be covered.</p>"},{"location":"builders/ethereum/dev-env/foundry/#using-forge-create","title":"Using Forge Create","text":"<p>Before deploying, you'll need to set up your keystore by importing your private key. You can do this using the <code>cast wallet import</code> command as follows:</p> <pre><code>cast wallet import deployer --interactive\n</code></pre> <p>This will prompt you to:</p> <ol> <li>Enter your private key.</li> <li>Enter a password to encrypt the keystore.</li> </ol> <p>The account will be saved as \"deployer\" in your keystore. You can then use this account name in the deployment commands. You'll be prompted for your keystore password when deploying contracts or sending transactions. </p> <p>Deploying the contract with <code>forge create</code> takes a single command, but you must include an RPC endpoint and constructor arguments. <code>MyToken.sol</code> asks for an initial supply of tokens in its constructor, so each of the following commands includes 100 as a constructor argument. You can deploy the <code>MyToken.sol</code> contract using the following command for the correct network:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>forge create src/MyToken.sol:MyToken \\\n--rpc-url INSERT_RPC_API_ENDPOINT \\\n--broadcast \\\n--account deployer \\\n--constructor-args 100\n</code></pre> <pre><code>forge create src/MyToken.sol:MyToken \\\n--rpc-url INSERT_RPC_API_ENDPOINT \\\n--broadcast \\\n--account deployer \\\n--constructor-args 100\n</code></pre> <pre><code>forge create src/MyToken.sol:MyToken \\\n--rpc-url https://rpc.api.moonbase.moonbeam.network \\\n--broadcast \\\n--account deployer \\\n--constructor-args 100\n</code></pre> <pre><code>forge create src/MyToken.sol:MyToken \\\n--rpc-url http://127.0.0.1:9944 \\\n--broadcast \\\n--account deployer \\\n--constructor-args 100\n</code></pre> <p>After you've deployed the contract and a few seconds have passed, you should see the address in the terminal.</p> forge create src/MyToken.sol:MyToken \\ --rpc-url https://rpc.api.moonbase.moonbeam.network \\ --account deployer \\ --constructor-args 100 [\u2812] Compiling... No files changed, compilation skipped Deployer: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Deployed to: 0xc111402Aa1136ff6224106709ae51864512eC68f Transaction hash: 0xd77fc26aa296e81f35718b5878cda98e8371f6bf33b0f57e7d92997a36cf6465 <p>Congratulations! Your contract is live! Save the address, as you will use it to interact with this contract instance in the next step.</p>"},{"location":"builders/ethereum/dev-env/foundry/#deploying-via-solidity-scripting","title":"Deploying via Solidity Scripting","text":"<p>Solidity scripting is a more powerful and flexible way to deploy contracts than <code>forge create</code>. Writing a Solidity script is identical to writing a typical Solidity smart contract, though you won't ever deploy this contract.</p> <p>You can tailor the behavior of <code>forge script</code> with various parameters. All components are optional except for local simulation, which is a required part of every run. The <code>forge script</code> command will attempt to execute all applicable steps in the following order:</p> <ol> <li>Local simulation: Simulate the transaction(s) in a local EVM.</li> <li>Onchain simulation: Simulate the transaction(s) via the provided RPC URL.</li> <li>Broadcasting: When the <code>--broadcast</code> flag is provided, and simulations succeed, the transaction(s) are dispatched.</li> <li>Verification: API-based smart contract verification when the <code>--verify</code> flag and a valid API key are provided.</li> </ol> <p>Now, go ahead and write the script. In the script folder, create a file named <code>MyToken.s.sol</code>. Copy and paste the contents of the below file. </p> <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport \"forge-std/Script.sol\";\nimport \"../src/MyToken.sol\";\n\ncontract MyScript is Script {\n    function run() external {\n        vm.startBroadcast();\n\n        MyToken mytoken = new MyToken(1000000000);\n\n        vm.stopBroadcast();\n    }\n}\n</code></pre> <p>Notice that even though the above script is not being deployed, it still requires all the typical formatting for a Solidity contract, such as the pragma statement.</p> <p>For this example, Foundry will first attempt a local simulation and a simulation against the provided RPC before deploying the contract. Remember that it will execute all relevant steps in order. Foundry won't proceed with the deployment if any of the simulations fail. You can deploy the <code>MyToken.sol</code> contract with this command.</p> <pre><code>forge script script/MyToken.s.sol --rpc-url https://rpc.api.moonbase.moonbeam.network --broadcast --account deployer\n</code></pre> <p>If your script's execution succeeds, your terminal should resemble the output below.</p> forge script script/MyToken.s.sol --rpc-url https://rpc.api.moonbase.moonbeam.network --broadcast --account deployer --sender 0x3b939fead1557c741ff06492fd0127bd287a421e [\u2812] Compiling... No files changed, compilation skipped EIP-3855 is not supported in one or more of the RPCs used. Unsupported Chain IDs: 1287. Contracts deployed with a Solidity version equal or higher than 0.8.20 might not work properly. For more information, please see https://eips.ethereum.org/EIPS/eip-3855 Script ran successfully. ## Setting up 1 EVM. ========================== Chain 1287 Estimated gas price: 0.0625 gwei Estimated total gas used for script: 1196500 Estimated amount required: 0.00007478125 ETH ========================== Enter keystore password: ## Sending transactions [0 - 0]. \u2801 [00:00:00] [########################################################################################################] 1/1 txes (0.0s)## Waiting for receipts. \u2809 [00:00:07] [#########################################################################################################################] 1/1 receipts (0.0s) ##### moonbase \u2705  [Success]Hash: 0xb70942942d731486872e7faba8a800e86809f44c2c3bd3f6306373562712e9d3 Contract Address: 0x98c3fC51d3487c1689e39ee63Ba110cfD8e1F552 Block: 11847291 Paid: 0.000027472875 ETH (879132 gas * 0.03125 gwei) ========================== ONCHAIN EXECUTION COMPLETE &amp; SUCCESSFUL. Total Paid: 0.000027472875 ETH (879132 gas * avg 0.03125 gwei) Transactions saved to: /Users/ubuntu-jammy/foundry/foundry/broadcast/MyToken.s.sol/1287/run-latest.json Sensitive values saved to: /Users/ubuntu-jammy/foundry/foundry/cache/MyToken.s.sol/1287/run-latest.json <p>And that's it! For more information about Solidity scripting with Foundry, be sure to check out Foundry's documentation site.</p>"},{"location":"builders/ethereum/dev-env/foundry/#interacting-with-the-contract","title":"Interacting with the Contract","text":"<p>Foundry includes cast, a CLI for performing Ethereum RPC calls.</p> <p>Try to retrieve your token's name using Cast, where <code>INSERT_YOUR_CONTRACT_ADDRESS</code> is the address of the contract that you deployed in the previous section:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url https://rpc.api.moonbase.moonbeam.network\n</code></pre> <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url http://127.0.0.1:9944\n</code></pre> <p>You should get this data in hexadecimal format:</p> <pre><code>0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000\n</code></pre> <p>This is far from readable, but you can use Cast to convert it into your desired format. In this case, the data is text, so you can convert it into ASCII characters to see \"My Token\":</p> cast --to-ascii 0x000000000000000000000000000000000000000000000000000000000000002000     000000000000000000000000000000000000000000000000000000000000074d7954     6f6b656e00000000000000000000000000000000000000000000000000  MyToken <pre><code>cast --to-ascii 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000\n</code></pre> <p>You can also mutate data with cast as well. Try burning tokens by sending them to the zero address.</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n--rpc-url INSERT_RPC_API_ENDPOINT \\\n--chain 1284 \\\nINSERT_YOUR_CONTRACT_ADDRESS \\\n\"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n--rpc-url INSERT_RPC_API_ENDPOINT \\\n--chain 1285 \\\nINSERT_YOUR_CONTRACT_ADDRESS \\\n\"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n--rpc-url https://rpc.api.moonbase.moonbeam.network \\\n--chain 1287 \\\nINSERT_YOUR_CONTRACT_ADDRESS \\\n\"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n--rpc-url http://127.0.0.1:9944 \\\n--chain 1281 \\\nINSERT_YOUR_CONTRACT_ADDRESS \\\n\"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <p>The transaction will be signed by your Moonbase account and be broadcast to the network. The output should look similar to:</p> cast send --private-key INSERT_PRIVATE_KEY \\ --rpc-url https://rpc.api.moonbase.moonbeam.network \\ --chain 1287 \\ INSERT_CONTRACT_ADDRESS \\ \"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1 blockHash               0x6f99fac1bb49feccb7b0476e0ffcd3cef4c456aa9111e193ce11c7a1ab62314e blockNumber             5892860 contractAddress cumulativeGasUsed       51332 effectiveGasPrice       3125000000 gasUsed                 51332 logs                    [{\"address\":\"0xc111402aa1136ff6224106709ae51864512ec68f\",\"topics\":[\"0xddf252ad1be2c89b69     c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",     \"0x0000000000000000000000003b939fead155     7c741ff06492fd0127bd287a421e\",     \"0x0000000000000000000000000000000000000000000000000000000000000001\"],     \"data\":\"0x0000000000000000000000000000000000000     000000000000000000000000001\",     \"blockHash\":\"0x6f99fac1bb49feccb7b0476e0ffcd3cef4c4     56aa9111e193ce11c7a1ab62314e\",     \"blockNumber\":\"0x59eafc\",     \"transactionHash\":\"0xdd5f11be68d5     2967356ccf34b9a4b2632d0d5ac8932ff27e72c544320dec33e3\",     \"transactionIndex\":\"0x0\",\"logIndex\":\"0x0\",\"transactionLogIndex\":\"0x0\",\"removed\":false}] logsBloom               0x000000000000000000000000000000000000000000000000000000000000000000000000000000004     00000000000000000000000000000000000000000040000000000000000000000000008000000000000     00000004000000000000000000000000000000000000000100000000000000000000000000000000001     00000010000000000000000000000000000000000000000000000000000000002000000040000000000     00000000000000000000000000000000000000000000000000000000002000000000000000000000000     00000000000000000000000000004000000000000000000000000000000000000000000000000000000     0001000000 root status                  1 transactionHash         0xdd5f11be68d52967356ccf34b9a4b2632d0d5ac8932ff27e72c544320dec33e3 transactionIndex        0 type                    2 <p>Congratulations, you have successfully deployed and interacted with a contract using Foundry!</p>"},{"location":"builders/ethereum/dev-env/foundry/#forking-with-cast-anvil","title":"Forking with Anvil","text":"<p>As previously mentioned, Anvil is a local TestNet node for development purposes that can fork preexisting networks. Forking Moonbeam allows you to interact with live contracts deployed on the network.</p> <p>There are some limitations to be aware of when forking with Anvil. Since Anvil is based on an EVM implementation, you cannot interact with any of the Moonbeam precompiled contracts and their functions. Precompiles are a part of the Substrate implementation and therefore cannot be replicated in the simulated EVM environment. This prohibits you from interacting with cross-chain assets on Moonbeam and Substrate-based functionality such as staking and governance.</p> <p>To fork Moonbeam or Moonriver, you will need to have your own endpoint and API key which you can get from one of the supported Endpoint Providers.</p> <p>To fork Moonbeam from the command line, you can run the following command from within your Foundry project directory:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>anvil --fork-url INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>anvil --fork-url INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>anvil --fork-url https://rpc.api.moonbase.moonbeam.network\n</code></pre> <p>Your forked instance will have 10 development accounts that are pre-funded with 10,000 test tokens. The forked instance is available at <code>http://127.0.0.1:8545/</code>. The output in your terminal should resemble the following:</p> anvil --fork-url https://rpc.api.moonbase.moonbeam.network Available Accounts ================== (0) \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\" (10000.000000000000000000 ETH) (1) \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\" (10000.000000000000000000 ETH) (2) \"0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC\" (10000.000000000000000000 ETH) (3) \"0x90F79bf6EB2c4f870365E785982E1f101E93b906\" (10000.000000000000000000 ETH) (4) \"0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65\" (10000.000000000000000000 ETH) (5) \"0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc\" (10000.000000000000000000 ETH) (6) \"0x976EA74026E726554dB657fA54763abd0C3a0aa9\" (10000.000000000000000000 ETH) (7) \"0x14dC79964da2C08b23698B3D3cc7Ca32193d9955\" (10000.000000000000000000 ETH) (8) \"0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f\" (10000.000000000000000000 ETH) (9) \"0xa0Ee7A142d267C1f36714E4a8F75612F20a79720\" (10000.000000000000000000 ETH) Private Keys ================== (0) 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 (1) 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d (2) 0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a (3) 0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6 (4) 0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a (5) 0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba (6) 0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e (7) 0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356 (8) 0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97 (9) 0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6 Wallet ================== Mnemonic: test test test test test test test test test test test junk Derivation path: m/44'/60'/0'/0/ Fork ================== Endpoint: https://rpc.api.moonbase.moonbeam.network Block number: 5892944 Block hash: 0xc9579299f55d507c305d5357d4c1b9d9c550788ddb471b0231d8d0146e7144b7 Chain ID: 1287 Base Fee ================== 125000000 Gas Limit ================== 30000000 Genesis Timestamp ================== 1705278817 Listening on 127.0.0.1:8545 <p>To verify you have forked the network, you can query the latest block number:</p> <pre><code>curl --data '{\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}' -H \"Content-Type: application/json\" -X POST localhost:8545 \n</code></pre> <p>If you convert the <code>result</code> from hex to decimal, you should get the latest block number from the time you forked the network. You can cross reference the block number using a block explorer.</p> <p>From here you can deploy new contracts to your forked instance of Moonbeam or interact with contracts already deployed. Building off of the previous example in this guide, you can make a call using Cast to check the balance of the minted MYTOK tokens in the account you deployed the contract with:</p> <pre><code>cast call INSERT_CONTRACT_ADDRESS  \"balanceOf(address)(uint256)\" INSERT_YOUR_ADDRESS --rpc-url http://localhost:8545\n</code></pre>"},{"location":"builders/ethereum/dev-env/foundry/#using-chisel","title":"Using Chisel","text":"<p>Chisel is a Solidity REPL or shell. It allows a developer to write Solidity directly in the console for testing small snippets of code, letting developers skip the project setup and contract deployment steps for what should be a quick process.  </p> <p>Since Chisel is mainly useful for quick testing, it can be used outside of a Foundry project. But, if executed within a Foundry project, it will keep the configurations within <code>foundry.toml</code> when running.  </p> <p>For this example, you will be testing out some of the features of <code>abi</code> within Solidity because it is complex enough to demonstrate how Chisel could be useful. To get started using Chisel, run the following in the command line to start the shell:</p> <pre><code>chisel\n</code></pre> <p>In the shell, you can write Solidity code as if it were running within a function:</p> <pre><code>bytes memory myData = abi.encode(100, true, \"Develop on Moonbeam\");\n</code></pre> <p>Let's say you were interested in how <code>abi</code> encoded data because you're looking into how to most efficiently store data on the blockchain and thus save gas. To view how the <code>myData</code> is stored in memory, you can use the following command while in the Chisel shell:</p> <pre><code>!memdump\n</code></pre> <p><code>memdump</code> will dump all of the data in your current session. You'll likely see something like this below. If you aren't good at reading hexadecimal or if you don't know how ABI encoding works, then you might not be able to find where the <code>myData</code> variable has been stored.</p> chisel Welcome to Chisel! Type `!help` to show available commands.  bytes memory myData = abi.encode(100, true, \"Develop on Moonbeam\");  !memdump [0x00:0x20]: 0x0000000000000000000000000000000000000000000000000000000000000000 [0x20:0x40]: 0x0000000000000000000000000000000000000000000000000000000000000000 [0x40:0x60]: 0x0000000000000000000000000000000000000000000000000000000000000140 [0x60:0x80]: 0x0000000000000000000000000000000000000000000000000000000000000000 [0x80:0xa0]: 0x00000000000000000000000000000000000000000000000000000000000000a0 [0xa0:0xc0]: 0x0000000000000000000000000000000000000000000000000000000000000064 [0xc0:0xe0]: 0x0000000000000000000000000000000000000000000000000000000000000001 [0xe0:0x100]: 0x0000000000000000000000000000000000000000000000000000000000000060 [0x100:0x120]: 0x0000000000000000000000000000000000000000000000000000000000000013 [0x120:0x140]: 0x446576656c6f70206f6e204d6f6f6e6265616d00000000000000000000000000 <p>Fortunately, Chisel lets you easily figure out where this information is stored. Using the <code>!rawstack</code> command, you can find the location in the stack where the value of a variable:  </p> <pre><code>!rawstack myData\n</code></pre> <p>In this situation, since bytes is over 32 bytes in length, the memory pointer is displayed instead. But that's exactly what's needed since you already know the entirety of the stack from the <code>!memdump</code> command.</p> chisel Welcome to Chisel! Type `!help` to show available commands.  bytes memory myData = abi.encode(100, true, \"Develop on Moonbeam\");  !memdump [0x00:0x20]: 0x0000000000000000000000000000000000000000000000000000000000000000 [0x20:0x40]: 0x0000000000000000000000000000000000000000000000000000000000000000 [0x40:0x60]: 0x0000000000000000000000000000000000000000000000000000000000000140 [0x60:0x80]: 0x0000000000000000000000000000000000000000000000000000000000000000 [0x80:0xa0]: 0x00000000000000000000000000000000000000000000000000000000000000a0 [0xa0:0xc0]: 0x0000000000000000000000000000000000000000000000000000000000000064 [0xc0:0xe0]: 0x0000000000000000000000000000000000000000000000000000000000000001 [0xe0:0x100]: 0x0000000000000000000000000000000000000000000000000000000000000060 [0x100:0x120]: 0x0000000000000000000000000000000000000000000000000000000000000013 [0x120:0x140]: 0x446576656c6f70206f6e204d6f6f6e6265616d00000000000000000000000000  !rawstack myData  Type: bytes32  \u2514 Data: 0x0000000000000000000000000000000000000000000000000000000000000080 <p>The <code>!rawstack</code> command shows that the <code>myData</code> variable is stored at <code>0x80</code>, so when comparing this with the memory dump retrieved from the <code>!memdump</code> command, it looks like <code>myData</code> is stored like this:  </p> <pre><code>[0x80:0xa0]: 0x00000000000000000000000000000000000000000000000000000000000000a0\n[0xa0:0xc0]: 0x0000000000000000000000000000000000000000000000000000000000000064\n[0xc0:0xe0]: 0x0000000000000000000000000000000000000000000000000000000000000001\n[0xe0:0x100]: 0x0000000000000000000000000000000000000000000000000000000000000060\n[0x100:0x120]: 0x0000000000000000000000000000000000000000000000000000000000000013\n[0x120:0x140]: 0x446576656c6f70206f6e204d6f6f6e6265616d00000000000000000000000000\n</code></pre> <p>At first glance, this makes sense, since <code>0xa0</code> has a value of <code>0x64</code> which is equal to 100, and <code>0xc0</code> has a value of <code>0x01</code> which is equal to true. If you want to learn more about how ABI-encoding works, the Solidity documentation for ABI is helpful. In this case, there are a lot of zeros in this method of data packing, so as a smart contract developer you might instead try to use structs or pack the data together more efficiently with bitwise code.  </p> <p>Since you're done with this code, you can clear the state of Chisel so that it doesn't mess with any future logic that you want to try out (while running the same instance of Chisel):  </p> <pre><code>!clear\n</code></pre> <p>There's an even easier way to test with Chisel. When writing code that ends with a semicolon (<code>;</code>), Chisel will run it as a statement, storing its value in Chisel's runtime state. But if you only needed to see how the ABI-encoded data was represented, then you could get away with running the code as an expression. To try this out with the same <code>abi</code> example, write the following in the Chisel shell:</p> <pre><code>abi.encode(100, true, \"Develop on Moonbeam\")\n</code></pre> <p>You should see something like the following:  </p>  !clear Cleared session!  abi.encode(100, true, \"Develop on Moonbeam\") Type: dynamic bytes \u251c Hex (Memory): \u251c\u2500 Length ([0x00:0x20]): 0x00000000000000000000000000000000000000000000000000000000000000a0 \u251c\u2500 Contents ([0x20:..]): 0x0000000000000000000000000000000000000000000000000000000000000064 0000000000000000000000000000000000000000000000000000000000000001 0000000000000000000000000000000000000000000000000000000000000060 0000000000000000000000000000000000000000000000000000000000000001 34446576656c6f70206f6e204d6f6f6e6265616d00000000000000000000000000 \u251c Hex (Tuple Encoded): \u251c\u2500 Pointer ([0x00:0x20]): 0x0000000000000000000000000000000000000000000000000000000000000020 \u251c\u2500 Length ([0x20:0x40]): 0x00000000000000000000000000000000000000000000000000000000000000a0 \u2514\u2500 Contents ([0x40:..]): 0x0000000000000000000000000000000000000000000000000000000000000064 0000000000000000000000000000000000000000000000000000000000000001 0000000000000000000000000000000000000000000000000000000000000060 0000000000000000000000000000000000000000000000000000000000000001 34446576656c6f70206f6e204d6f6f6e6265616d00000000000000000000000000 <p>While it doesn't display the data in the same way, you still get the contents of the data, and it also further breaks down how the information is coded, such as letting you know that the <code>0xa0</code> value defines the length of the data.  </p> <p>By default, when you leave the Chisel shell, none of the data is persisted. But you can instruct chisel to do so. For example, you can take the following steps to store a variable:</p> <ol> <li> <p>Store a <code>uint256</code> in Chisel.     <pre><code>uint256 myNumber = 101;\n</code></pre></p> </li> <li> <p>Store the session with <code>!save</code>. For this example, you can use the number <code>1</code> as a save ID.     <pre><code>!save 1\n</code></pre></p> </li> <li> <p>Quit the session.     <pre><code>!quit\n</code></pre></p> </li> </ol> <p>Then to view and interact with your stored Chisel states, you can take the following steps:</p> <ol> <li> <p>View a list of saved Chisel states.      <pre><code>chisel list\n</code></pre></p> </li> <li> <p>Load your stored states.     <pre><code>chisel load 1\n</code></pre></p> </li> <li> <p>View the <code>uint256</code> saved in Chisel from the previous set of steps.     <pre><code>!rawstack myNumber\n</code></pre></p> </li> </ol>  uint256 myNumber = 101;  !save 1  Saved session to cache with ID = 1  !quit chisel list \u2692\ufe0f Chisel Sessions \u251c\u2500 \"2024-01-15 01:17:34\" - chisel-1.json chisel load 1 Welcome to Chisel! Type `!help` to show available commands.  !rawstack myNumber Type: bytes32 \u2514 Data: 0x0000000000000000000000000000000000000000000000000000000000000065 <p>You can even fork networks while using Chisel:</p> <pre><code>!fork https://rpc.api.moonbase.moonbeam.network\n</code></pre> <p>Then, for example, you can query the balance of one of Moonbase Alpha's collators:  </p> <pre><code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5.balance\n</code></pre>  !fork https://rpc.api.moonbase.moonbeam.network Set fork URL to https://rpc.api.moonbase.moonbeam.network  0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5.balance Type: uint \u251c Hex: 0x000000000000000000000000000000000000000000000358affd3d76ebb78555 \u2514 Decimal: 15803094286802091476309 <p>If you want to learn more about Chisel, download Foundry and refer to its official reference page.</p>"},{"location":"builders/ethereum/dev-env/foundry/#foundry-with-hardhat","title":"Foundry With Hardhat","text":"<p>Often, there will be the case where a project that you wish to integrate with has all of its setup within Hardhat, making it an arduous task to convert the entirety of the project into Foundry. This additional work is avoidable by creating a hybrid project that uses both Hardhat and Foundry features together. This is possible with Hardhat's hardhat-foundry plugin.  </p> <p>To convert your preexisting Foundry project to a hybrid project, you will essentially have to install a Hardhat project into the same folder:  </p> <pre><code>npm init\nnpm install --save-dev hardhat @nomicfoundation/hardhat-foundry\nnpx hardhat init\n</code></pre> <p>For more information, please refer to our documentation on Creating a Hardhat Project.</p> <p>After initializing the new Hardhat project, a few new folders and files should appear: <code>contracts</code>, <code>hardhat.config.js</code>, <code>scripts</code>, and <code>test/Lock.js</code>. You'll need to make a few modifications to create a hybrid project:</p> <ol> <li> <p>Edit the <code>hardhat.config.js</code> file within your repository. Open it up, and at the top, add the following:  </p> <pre><code>require(\"@nomicfoundation/hardhat-foundry\");\n</code></pre> <p>After adding the <code>hardhat-foundry</code> plugin, the typical <code>contracts</code> folders for Hardhat will not work because now Hardhat expects all smart contracts to be stored within Foundry's <code>src</code> folder</p> </li> <li> <p>Move all smart contracts within the <code>contracts</code> folder into the <code>src</code> folder, and then delete the <code>contracts</code> folder.</p> </li> <li> <p>Edit the <code>foundry.toml</code> file to ensure that dependencies installed via Git submodules and npm can be compiled by the Forge tool. Edit the <code>profile.default</code> to ensure that the <code>libs</code> entry has both <code>lib</code> and <code>node_modules</code>:  </p> <pre><code>[profile.default]\nsrc = 'src'\nout = 'out'\nlibs = ['lib', 'node_modules']\nsolc = '0.8.20'\nevm_version = 'london'\n</code></pre> </li> </ol> <p>Now both <code>forge build</code> and <code>npx hardhat compile</code> should work regardless of the dependencies.  </p> <p>Both <code>forge test</code> and <code>npx hardhat test</code> should now be able to access all smart contracts and dependencies. <code>forge test</code> will only test the Solidity tests, whereas <code>npx hardhat test</code> will only test the JavaScript tests. If you would like to use them in conjunction, then you can create a new script within your <code>package.json</code> file:  </p> <pre><code>\"scripts\": {\n    \"test\": \"npx hardhat test &amp;&amp; forge test\"\n}\n</code></pre> <p>You can run this command with:  </p> <pre><code>npm run test\n</code></pre> <p>Finally, while not necessary, it could be worthwhile to move all JavaScript scripts from the <code>scripts</code> folder into Foundry's <code>script</code> folder and delete the <code>scripts</code> folder so that you don't have two folders that serve the same purpose.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/dev-env/hardhat/","title":"Using Hardhat to Deploy To Moonbeam","text":""},{"location":"builders/ethereum/dev-env/hardhat/#introduction","title":"Introduction","text":"<p>Hardhat is a flexible and extensible Ethereum development environment that streamlines the smart contract development process. Since Moonbeam is Ethereum-compatible, you can use Hardhat to develop and deploy smart contracts on Moonbeam.</p> <p>Hardhat takes a task-based approach to development, where you can define and execute tasks that perform specific actions. These actions include compiling and deploying contracts, running tests, and more. Tasks are highly configurable, so you can create, customize, and execute tasks that are tailored to meet your needs.</p> <p>You can also extend Hardhat's functionality through the use of plugins. Plugins are external extensions that integrate with Hardhat to provide additional features and tools for your workflow. For example, there are plugins for common Ethereum libraries, like Ethers.js and viem, a plugin that extends the Chai assertion library to include Ethereum-specific functionality, and more. All of these plugins can be used to extend your Hardhat project on Moonbeam.</p> <p>This guide will provide a brief introduction to Hardhat and show you how to use Hardhat to compile, deploy, and debug Ethereum smart contracts on the Moonbase Alpha TestNet. This guide can also be adapted for Moonbeam, Moonriver, or a Moonbeam development node. The content below targets Hardhat 3 (current release: 3.0.17).</p> <p>Please note that although Hardhat comes with a Hardhat Network component, which provides a local development environment, you should use a local Moonbeam development node instead. You can connect a Moonbeam development node to Hardhat just like you would with any other network.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you will need the following:</p> <ul> <li>Have Node.js 22.10.0 or later (Hardhat 3 only supports even-numbered LTS versions) and npm</li> <li>Have MetaMask installed and connected to Moonbase Alpha.</li> <li>Have an account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul>"},{"location":"builders/ethereum/dev-env/hardhat/#creating-a-hardhat-project","title":"Create a Hardhat Project","text":"<p>You will need to create a Hardhat project if you don't already have one. You can create one by completing the following steps:</p> <ol> <li> <p>Create a directory for your project.</p> <pre><code>mkdir hardhat &amp;&amp; cd hardhat\n</code></pre> </li> <li> <p>Initialize the project, which will create a <code>package.json</code> file.</p> <pre><code>npm init -y\n</code></pre> </li> <li> <p>Install Hardhat.</p> <pre><code>npm install --save-dev hardhat\n</code></pre> </li> <li> <p>Create a Hardhat project.</p> <pre><code>npx hardhat --init\n</code></pre> <p>Note</p> <p><code>npx</code> is used to run executables installed locally in your project. Although Hardhat can be installed globally, installing it locally in each project is recommended so you can control the version on a project-by-project basis.</p> </li> <li> <p>You'll be prompted with a series of questions to set up your project:</p> <ul> <li>Choose Hardhat 3 Beta (recommended for new projects) rather than Hardhat 2.</li> <li>Choose where to initialize the project (default is current directory).</li> <li>Confirm converting to ESM (required for Hardhat v3).</li> <li>Select the type of project to initialize:<ul> <li>A TypeScript Hardhat project using Node Test Runner and viem</li> <li>A TypeScript Hardhat project using Mocha and Ethers.js</li> </ul> </li> </ul> <p>For this example, you can choose either option based on your preference. If you choose the Mocha and Ethers.js option, you'll get a project structure with:</p> <ul> <li>A sample contract in <code>contracts/Counter.sol</code></li> <li>A test file in <code>test/Counter.ts</code></li> <li>TypeScript configuration</li> <li>Mocha and Ethers.js dependencies</li> </ul> <p>The project will be set up with all necessary dependencies and configurations for you to start developing.</p> </li> </ol> npx hardhat init 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 8888888888\u00a0\u00a08888b.\u00a0\u00a0888d888\u00a0.d88888\u00a088888b.\u00a0\u00a0\u00a08888b.\u00a0\u00a0888888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\"88b\u00a0888P\"\u00a0\u00a0d88\"\u00a0888\u00a0888\u00a0\"88b\u00a0\u00a0\u00a0\u00a0\u00a0\"88b\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0.d888888\u00a0888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0.d888888\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0Y88b\u00a0888\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0Y88b. 888\u00a0\u00a0\u00a0\u00a0888\u00a0\"Y888888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\"Y88888\u00a0888\u00a0\u00a0888\u00a0\"Y888888\u00a0\u00a0\"Y888 \ud83d\udc77 Welcome to Hardhat v3.0.17 \ud83d\udc77\u200d \u00a0Which version of Hardhat would you like to use? \u2026 \u00a0Hardhat 3 Beta (recommended for new projects) \u00a0\u00a0Hardhat 2 (older version) \u00a0Where would you like to initialize the project? \u00a0. \u00a0Hardhat only supports ESM projects. Would you like to change \"package.json\" to turn your project into ESM? (Y/n) \u00b7 true \u00a0What type of project would you like to initialize? \u2026 \u00a0\u00a0A TypeScript Hardhat project using Node Test Runner and Viem \u00a0A TypeScript Hardhat project using Mocha and Ethers.js"},{"location":"builders/ethereum/dev-env/hardhat/#hardhat-configuration-file","title":"Hardhat Configuration File","text":"<p>The Hardhat configuration file is the entry point into your Hardhat project. It defines various settings and options for your Hardhat project, such as the Solidity compiler version to use and the networks you can deploy your contracts to.</p> <p>If you are using JavaScript, keep <code>\"type\": \"module\"</code> in your <code>package.json</code>. A minimal <code>hardhat.config.js</code> looks like:</p> <pre><code>import { defineConfig } from 'hardhat/config';\n\nexport default defineConfig({\n  solidity: '0.8.28',\n});\n</code></pre> <p>If you chose a TypeScript template, the file will be <code>hardhat.config.ts</code>, and the config content will be the same. For this example, you can keep the Solidity compiler version at <code>0.8.28</code>; however, if you are using a contract that requires a newer version, don't forget to update it here.</p> <p>Install the plugins and libraries used in this guide if your project template did not add them:</p> <pre><code>npm install --save-dev @nomicfoundation/hardhat-ethers @nomicfoundation/hardhat-ignition-ethers @nomicfoundation/hardhat-keystore ethers\n</code></pre> <p>Next, you'll need to modify your configuration file to add the network configurations for the network you want to deploy your contract to. For Moonbeam networks, you'll need to specify the following:</p> <ul> <li><code>url</code>: The RPC endpoint of the node.</li> <li><code>chainId</code>: The chain ID, which is used to validate the network.</li> <li><code>accounts</code>: The accounts that can be used to deploy and interact with contracts. You can either enter an array of the private keys for your accounts or use an HD Wallet.</li> <li><code>type</code>: For external RPC networks on Moonbeam, set <code>type: 'http'</code>.</li> <li><code>chainType</code>: For Moonbeam networks, set <code>chainType: 'l1'</code>.</li> </ul> <p>Hardhat includes an encrypted secrets manager via the <code>@nomicfoundation/hardhat-keystore</code> plugin, which keeps sensitive data out of source control. After installing and importing the plugin, set your secrets with the keystore:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>npx hardhat keystore set MOONBEAM_RPC_URL\nnpx hardhat keystore set MOONBEAM_PRIVATE_KEY\n</code></pre> <pre><code>npx hardhat keystore set MOONRIVER_RPC_URL\nnpx hardhat keystore set MOONRIVER_PRIVATE_KEY\n</code></pre> <pre><code>npx hardhat keystore set MOONBASE_RPC_URL\nnpx hardhat keystore set MOONBASE_PRIVATE_KEY\n</code></pre> <pre><code>npx hardhat keystore set DEV_RPC_URL\nnpx hardhat keystore set DEV_PRIVATE_KEY\n</code></pre> <p>Warning</p> <p>The Hardhat console task does not currently prompt for keystore secrets. Use environment variables for your config variables before running <code>npx hardhat console</code>, or interact through scripts/tasks instead of the console when using the keystore.</p> <p>Then, update your configuration file to use the encrypted secrets and ESM syntax:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>import hardhatEthers from '@nomicfoundation/hardhat-ethers';\nimport hardhatIgnitionEthers from '@nomicfoundation/hardhat-ignition-ethers';\nimport hardhatKeystore from '@nomicfoundation/hardhat-keystore';\nimport { configVariable, defineConfig } from 'hardhat/config';\n\nexport default defineConfig({\n  plugins: [hardhatEthers, hardhatIgnitionEthers, hardhatKeystore],\n  solidity: '0.8.28',\n  networks: {\n    moonbeam: {\n      type: 'http',\n      chainType: 'l1',\n      url: configVariable('MOONBEAM_RPC_URL'),\n      chainId: 1284, // (hex: 0x504),\n      accounts: [configVariable('MOONBEAM_PRIVATE_KEY')],\n    },\n  },\n});\n</code></pre> <pre><code>import hardhatEthers from '@nomicfoundation/hardhat-ethers';\nimport hardhatIgnitionEthers from '@nomicfoundation/hardhat-ignition-ethers';\nimport hardhatKeystore from '@nomicfoundation/hardhat-keystore';\nimport { configVariable, defineConfig } from 'hardhat/config';\n\nexport default defineConfig({\n  plugins: [hardhatEthers, hardhatIgnitionEthers, hardhatKeystore],\n  solidity: '0.8.28',\n  networks: {\n    moonriver: {\n      type: 'http',\n      chainType: 'l1',\n      url: configVariable('MOONRIVER_RPC_URL'),\n      chainId: 1285, // (hex: 0x505),\n      accounts: [configVariable('MOONRIVER_PRIVATE_KEY')],\n    },\n  },\n});\n</code></pre> <pre><code>import hardhatEthers from '@nomicfoundation/hardhat-ethers';\nimport hardhatIgnitionEthers from '@nomicfoundation/hardhat-ignition-ethers';\nimport hardhatKeystore from '@nomicfoundation/hardhat-keystore';\nimport { configVariable, defineConfig } from 'hardhat/config';\n\nexport default defineConfig({\n  plugins: [hardhatEthers, hardhatIgnitionEthers, hardhatKeystore],\n  solidity: '0.8.28',\n  networks: {\n    moonbase: {\n      type: 'http',\n      chainType: 'l1',\n      url: configVariable('MOONBASE_RPC_URL'),\n      chainId: 1287, // (hex: 0x507),\n      accounts: [configVariable('MOONBASE_PRIVATE_KEY')],\n    },\n  },\n});\n</code></pre> <pre><code>import hardhatEthers from '@nomicfoundation/hardhat-ethers';\nimport hardhatIgnitionEthers from '@nomicfoundation/hardhat-ignition-ethers';\nimport hardhatKeystore from '@nomicfoundation/hardhat-keystore';\nimport { configVariable, defineConfig } from 'hardhat/config';\n\nexport default defineConfig({\n  plugins: [hardhatEthers, hardhatIgnitionEthers, hardhatKeystore],\n  solidity: '0.8.28',\n  networks: {\n    dev: {\n      type: 'http',\n      chainType: 'l1',\n      url: configVariable('DEV_RPC_URL'),\n      chainId: 1281, // (hex: 0x501),\n      accounts: [configVariable('DEV_PRIVATE_KEY')],\n    },\n  },\n});\n</code></pre> <p>When you run tasks that require these secrets, Hardhat will prompt you for the password to decrypt them. The secrets are only decrypted when needed, meaning you only need to enter the password if a Hardhat task uses a secret.</p> <p>If you are planning on using any plugins with your project, you'll need to install the plugin and import it into your Hardhat config file (<code>hardhat.config.ts</code> or <code>hardhat.config.js</code>). Once a plugin has been imported, it becomes part of the Hardhat Runtime Environment, and you can leverage the plugin's functionality within tasks, scripts, and more.</p> <p>For more information on the available configuration options, please refer to Hardhat's documentation on Configuration.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#the-contract-file","title":"The Contract File","text":"<p>Now that you've configured your project, you can begin the development process by creating your smart contract. The contract will be a simple one that will let you store a value that can be retrieved later, called <code>Box</code>.</p> <p>To add the contract, you'll take the following steps:</p> <ol> <li> <p>Change into the <code>contracts</code> directory.</p> <pre><code>cd contracts\n</code></pre> </li> <li> <p>Create a <code>Box.sol</code> file.</p> <pre><code>touch Box.sol\n</code></pre> </li> <li> <p>Open the file and add the following contract to it:</p> <pre><code>// contracts/Box.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\ncontract Box {\n    uint256 private value;\n\n    // Emitted when the stored value changes\n    event ValueChanged(uint256 newValue);\n\n    // Stores a new value in the contract\n    function store(uint256 newValue) public {\n        value = newValue;\n        emit ValueChanged(newValue);\n    }\n\n    // Reads the last stored value\n    function retrieve() public view returns (uint256) {\n        return value;\n    }\n}\n</code></pre> </li> </ol>"},{"location":"builders/ethereum/dev-env/hardhat/#compiling-solidity","title":"Compile the Contract","text":"<p>The next step is to compile the <code>Box.sol</code> smart contract. For this, you can use the built-in <code>compile</code> task, which will look for Solidity files in the <code>contracts</code> directory and compile them using the version and compiler settings defined in your Hardhat config file.</p> <p>To use the <code>compile</code> task, all you have to do is run:</p> <pre><code>npx hardhat compile\n</code></pre> npx hardhat compile Compiled 2 Solidity files with solc 0.8.28 (evm target: cancun) Compiled 1 Solidity test file with solc 0.8.28 (evm target: cancun) <p>After compilation, an <code>artifacts</code> directory is created that holds the bytecode and metadata of the contract, which are <code>.json</code> files. It's a good idea to add this directory to a <code>.gitignore</code> file.</p> <p>If you make changes to the contract after you've compiled it, you can compile it again using the same command. Hardhat will look for any changes and recompile the contract. If no changes are found, nothing will be compiled. If needed, you can force a compilation using the <code>clean</code> task, which will clear the cache and delete the old artifacts.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#deploying-the-contract","title":"Deploy the Contract","text":"<p>To deploy the contract, you'll use Hardhat Ignition, a declarative framework for deploying smart contracts. Hardhat Ignition is designed to make it easy to manage recurring tasks surrounding smart contract deployment and testing. For more information, be sure to check out the Hardhat Ignition docs. </p> <p>To set up the proper file structure for your Ignition module, create a folder named <code>ignition</code> and a subdirectory called <code>modules</code>. Then add a new file to it called <code>Box.js</code>. You can take all three of these steps with the following command:</p> <pre><code>cd ignition/modules &amp;&amp; touch Box.js\n</code></pre> <p>Next, you can write your Hardhat Ignition module. To get started, take the following steps:</p> <ol> <li>Import the <code>buildModule</code> function from the Hardhat Ignition module.</li> <li>Export a module using <code>buildModule</code>.</li> <li>Use the <code>getAccount</code> method to select the deployer account.</li> <li>Deploy the <code>Box</code> contract.</li> <li>Return an object from the module. This makes the <code>Box</code> contract accessible for interaction in Hardhat tests and scripts.</li> </ol> <pre><code>// 1. Import the `buildModule` function from the Hardhat Ignition module\nimport { buildModule } from '@nomicfoundation/hardhat-ignition/modules';\n\n// 2. Export a module using `buildModule`\n// Use `export default` instead of `module.exports`\nexport default buildModule('BoxModule', (m) =&gt; {\n  // 3. Use the `getAccount` method to select the deployer account\n  const deployer = m.getAccount(0);\n\n  // 4. Deploy the `Box` contract\n  const box = m.contract('Box', [], {\n    from: deployer, \n  });\n\n  // 5. Return an object from the module\n  return { box };\n});\n</code></pre> <p>To run the script and deploy the <code>Box.sol</code> contract, use the following command, which requires you to specify the network name as defined in your Hardhat config file. If you don't specify a network, hardhat will deploy the contract to a local Hardhat network by default. </p> <pre><code>npx hardhat ignition deploy ./ignition/modules/Box.js --network moonbase\n</code></pre> <p>Note</p> <p>If you're using another Moonbeam network, make sure that you specify the correct network. The network name needs to match the one defined in your Hardhat config file.</p> <p>You'll be prompted to enter your password for the Hardhat secrets manager. Next, you'll be prompted to confirm the network you wish to deploy to. A few seconds after you confirm, the contract is deployed, and you'll see the contract address in the terminal.</p>  npx hardhat ignition deploy ./ignition/modules/Box.js --network moonbase \u2705 Confirm deploy to network moonbase (1287)? \u2026 yes Hardhat Ignition \ud83d\ude80 Deploying [ BoxModule ] Batch #1 Executed BoxModule#Box [ BoxModule ] successfully deployed \ud83d\ude80 Deployed Addresses BoxModule#Box - 0xfBD78CE8C9E1169851119754C4Ea2f70AB159289 <p>Congratulations, your contract is live! Save the address, as you will use it to interact with this contract instance in the next step.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#interacting-with-the-contract","title":"Interact with the Contract","text":"<p>You can interact with your newly deployed contract using Hardhat in two ways: run console-style commands from a helper script (recommended for Hardhat 3), or reuse that script to automate interactions via the <code>run</code> task.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#hardhat-console","title":"Console-Style Interaction","text":"<p>Similarly to the deployment script, you can create a lightweight helper that mirrors the console workflow, save it under <code>scripts</code>, and run it with the built-in <code>run</code> task. This approach works even when your credentials are stored in the Hardhat keystore because <code>network.connect()</code> is executed inside a normal Hardhat task (which can unlock the keystore) instead of the console, which does not have access to the Hardhat keystore.</p> <p>To get started, create a <code>box-console.ts</code> file in the <code>scripts</code> directory:</p> <pre><code>cd scripts &amp;&amp; touch box-console.ts\n</code></pre> <p>Update the script with your deployed contract address before running it. The full helper looks like this:</p> View the complete script <pre><code>// scripts/box-console.ts\nimport { network } from 'hardhat';\n\nconst CONTRACT_ADDRESS = 'INSERT_CONTRACT_ADDRESS';\nconst VALUE_TO_STORE = 5n;\n\nasync function main() {\n  if (CONTRACT_ADDRESS === 'INSERT_CONTRACT_ADDRESS') {\n    throw new Error(\n      'Update CONTRACT_ADDRESS with the Box deployment address (0x...).'\n    );\n  }\n\n  if (!CONTRACT_ADDRESS.startsWith('0x')) {\n    throw new Error('CONTRACT_ADDRESS must start with 0x.');\n  }\n\n  const { ethers } = await network.connect('moonbase');\n  const [signer] = await ethers.getSigners();\n\n  console.log(`Using signer ${signer.address}`);\n  console.log(`Attaching to Box at ${CONTRACT_ADDRESS}`);\n\n  const Box = await ethers.getContractFactory('Box');\n  const box = await Box.attach(CONTRACT_ADDRESS);\n\n  const current = (await box.retrieve()).toString();\n  console.log(`Current stored value: ${current}`);\n\n  console.log(`Calling store(${VALUE_TO_STORE})...`);\n  const tx = await box.store(VALUE_TO_STORE);\n  console.log(`Submitted tx ${tx.hash}, waiting for confirmation...`);\n  await tx.wait();\n\n  const updated = (await box.retrieve()).toString();\n  console.log(`Updated stored value: ${updated}`);\n}\n\nmain().catch((err) =&gt; {\n  console.error(err);\n  process.exitCode = 1;\n});\n</code></pre> <p>Replace <code>INSERT_CONTRACT_ADDRESS</code> with the address printed by Hardhat Ignition and adjust <code>VALUE_TO_STORE</code> if you want to store a different value.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#run-the-script","title":"Run the Script","text":"<p>Use the <code>run</code> task to execute the helper script against your deployed <code>Box</code> contract so you can verify the keystore unlock flow works and confirm the contract stores the new value on Moonbase Alpha.</p> <pre><code>npx hardhat run --network moonbase scripts/box-console.ts\n</code></pre> <p>You'll be prompted for the Hardhat keystore password (if you're using encrypted secrets), after which the script connects to Moonbase Alpha, attaches to your deployed <code>Box</code> contract, and logs the values stored before and after calling <code>store(5n)</code>. Upon running it, you should see output similar to:</p> npx hardhat run --network moonbase scripts/box-console.ts [hardhat-keystore] Enter the password: ********** Using signer 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Attaching to Box at INSERT_CONTRACT_ADDRESS Current stored value: 4 Calling store(5)... Submitted tx 0xdb0a7bfe9caeae5fb590cde27ad156f9b2788434aa4a94b95d1c3a8ce3d58b30, waiting for confirmation... Updated stored value: 5 % <p>The script prints the signer being used, the value stored before the transaction, the submitted transaction hash, and the updated value after calling <code>store(5n)</code>.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#hardhat-forking","title":"Hardhat Forking","text":"<p>You can fork any EVM-compatible chain using Hardhat, including Moonbeam. Forking simulates the live Moonbeam network locally, enabling you to interact with deployed contracts on Moonbeam in a local test environment. Since Hardhat forking is based on an EVM implementation, you can interact with the fork using standard Ethereum JSON-RPC methods supported by Moonbeam and Hardhat.</p> <p>There are some limitations to be aware of when using Hardhat forking. You cannot interact with any of the Moonbeam precompiled contracts or their functions. Precompiles are a part of the Substrate implementation and therefore cannot be replicated in the simulated EVM environment. This prohibits you from interacting with cross-chain assets on Moonbeam and Substrate-based functionality such as staking and governance.</p>"},{"location":"builders/ethereum/dev-env/hardhat/#forking-moonbeam","title":"Forking Moonbeam","text":"<p>You can fork Moonbeam from the command line or configure your Hardhat project to always run the fork from your Hardhat config file. To fork Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>To fork Moonbeam from the command line, you can run the following command from within your Hardhat project directory:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>npx hardhat node --fork INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>npx hardhat node --fork INSERT_RPC_API_ENDPOINT\n</code></pre> <pre><code>npx hardhat node --fork https://rpc.api.moonbase.moonbeam.network\n</code></pre> <p>If you prefer to configure your Hardhat project, you can update your Hardhat config file with the following configurations:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>...\nnetworks: {\n  hardhat: {\n    forking: {\n      url: 'INSERT_RPC_API_ENDPOINT',\n    },\n  },\n},\n...\n</code></pre> <pre><code>...\nnetworks: {\n  hardhat: {\n    forking: {\n      url: 'INSERT_RPC_API_ENDPOINT',\n    },\n  },\n},\n...\n</code></pre> <pre><code>...\nnetworks: {\n  hardhat: {\n    forking: {\n      url: 'https://rpc.api.moonbase.moonbeam.network',\n    },\n  },\n},\n...\n</code></pre> <p>When you spin up the Hardhat fork, you'll have 20 development accounts that are pre-funded with 10,000 test tokens. The forked instance is available at <code>http://127.0.0.1:8545/</code>. The output in your terminal should resemble the following:</p> Private Key: Oxdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97 Account #9: Oxa0Ee7A142d267C1f36714E4a8F75612F20a79720 (10000 ETH) Private Key: 0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6 Account #10: OxBcd4042DE499D14e55001CcbB24a551F3b954096 (10000 ETH) Private Key: Oxf214f2b2cd398c806f84e317254e0f0b801d0643303237d97a22a48e01628897 Account #11: 0x71bE63f3384f5fb98995898A86B02Fb2426c5788 (10000 ETH) Private Key: 0x701b615bbdfb9de65240bc28bd21bbc0d996645a3dd57e7b12bc2bdf6f192c82 Account #12: OxFABBOac9d68B0B445fB7357272F202C5651694a (10000 ETH) Private Key: Oxa267530f49f8280200edf313ee7af6b827f2a8bce2897751d06a843f644967b1 Account #13: 0x1CBd3b2770909D4e10f157cABC84C7264073C9Ec (10000 ETH) Private Key: 0x47c99abed3324a2707c28affff1267e45918ec8c3f20b8aa892e8b065d2942dd Account #14: OxdF3e18d64BC6A983f673Ab319CCaE4f1a5707097 (10000 ETH) Private Key: Oxc526ee95bf44d8fc405a158bb884d9d1238d990612e9f33d006bb0789009aaa Account #15: Oxcd3B766CCDd6AE721141F452C550Ca635964ce71 (10000 ETH) Private Key: 0x8166f546bab6da521a8369cab06c5d2b9e46670292d85c875ee9ec20e84ffb61 Account #16: 0\u00d72546BcD3c84621e976D8185a91A922aE77ECEc30 (10000 ETH) Private Key: Oxea6c44ac03bff858b476bba40716402b03e41b8e97e276d1baec7c37d42484a0 Account #17: OxbDA5747bFD65F08deb54cb465eB87D40e51B197E (10000 ETH) Private Key: 0x689af8efa8c651a91ad287602527f3af2fe9f6501a7ac4b06166765a93e037fd Account #18: OxdD2FD4581271e230360230F9337D5c0430Bf44C0 (10000 ETH) Private Key: Oxde9be858da4a475276426320d5e9262ecfc3ba460bfac56360bfa6c4c28b4ee0 Account #19: 0\u00d78626f6940E2eb28930eFb4CeF49B2d1F2C9C1199 (10000 ETH) Private Key: Oxdf57089febbacf7ba0bc227dafbffa9fc08a93fdc68e1e42411a14efcf23656e WARNING: These accounts, and their private keys, are publicly known.Any funds sent to them on Mainnet or any other live network WILL BE LOST. <p>To verify you have forked the network, you can query the latest block number:</p> <pre><code>curl --data '{\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}' -H \"Content-Type: application/json\" -X POST localhost:8545 \n</code></pre> <p>If you convert the <code>result</code> from hex to decimal, you should get the latest block number from the time you forked the network. You can cross-reference the block number using a block explorer.</p> <p>From here, you can deploy new contracts to your forked instance of Moonbeam or interact with contracts already deployed by creating a local instance of the deployed contract.</p> <p>To interact with an already deployed contract, you can create a new script in the <code>scripts</code> directory using <code>ethers</code>. Because you'll be running it with Hardhat, you can import <code>ethers</code> directly from the Hardhat runtime without extra setup. Inside the script, you can access a live contract on the network using the following snippet:</p> <pre><code>import { ethers } from 'hardhat';\n\nasync function main() {\n  const provider = new ethers.JsonRpcProvider('http://127.0.0.1:8545/');\n\n  const contract = new ethers.Contract(\n    'INSERT_CONTRACT_ADDRESS',\n    'INSERT_CONTRACT_ABI',\n    provider\n  );\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/dev-env/remix/","title":"Using Remix to Deploy to Moonbeam","text":""},{"location":"builders/ethereum/dev-env/remix/#introduction","title":"Introduction","text":"<p>Remix is an integrated development environment (IDE) for developing smart contracts on Ethereum and Ethereum-compatible chains. It provides an easy-to-use interface for writing, compiling, and deploying smart contracts. Given Moonbeam\u2019s Ethereum compatibility features, you can use Remix directly with any Moonbeam network.</p> <p>This guide walks through the process of creating and deploying a Solidity smart contract to a Moonbeam development node using the Remix IDE. This guide can be adapted for Moonbeam, Moonriver, or Moonbase Alpha.</p> <p>If you're familiar with Remix, you can skip ahead to the Connect Remix to Moonbeam section to learn how to use Remix with Moonbeam.</p>"},{"location":"builders/ethereum/dev-env/remix/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the purposes of this guide, you'll need to have the following:</p> <ul> <li>A locally running Moonbeam development node</li> <li>MetaMask installed and connected to your development node</li> </ul> <p>If you followed the guides above, you should have a local Moonbeam node, which will begin to author blocks as transactions arrive.</p> ./target/release/moonbeam --dev 2025-10-03 20:17:18 \u26a1 Idle (0 peers), best: #0 (0x28cd...88a6), finalized #0 (0x28cd...88a6), \u2b07 0 \u2b06 1 \u2b07 0 2025-10-03 20:17:23 \u26a1 Idle (0 peers), best: #0 (0x28cd...88a6), finalized #0 (0x28cd...88a6), \u2b07 0 \u2b06 1 \u2b07 0 2025-10-03 20:17:28 \u26a1 Idle (0 peers), best: #0 (0x28cd...88a6), finalized #0 (0x28cd...88a6), \u2b07 0 \u2b06 1 \u2b07 0 <p>Your development node comes with 10 pre-funded accounts. You should have MetaMask connected to your Moonbeam development node and have imported at least one of the pre-funded accounts. You can refer to the Import Accounts section of the MetaMask docs for step-by-step instructions on how to import a development account.</p> <p></p> <p>If you're adapting this guide for Moonbeam, Moonriver, or Moonbase Alpha, make sure you are connected to the correct network and have an account with funds. You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet.</p>"},{"location":"builders/ethereum/dev-env/remix/#get-familiar-with-remix","title":"Get Familiar with Remix","text":"<p>If you navigate to https://remix.ethereum.org/, you'll see that the layout of Remix is split into four sections:</p> <ol> <li>The plugin panel</li> <li>The side panel</li> <li>The main panel</li> <li>The terminal</li> </ol> <p></p> <p>The plugin panel displays icons for each of the preloaded plugins, the plugin manager, and the settings menu. You'll see a few icons there for each of the preloaded plugins, which are the File explorer, Search in files, Solidity compiler, and Deploy and run transactions plugins. As additional plugins are activated, their icons will appear in this panel.</p> <p>The side panel displays the content of the plugin that is currently being viewed. By default, you'll see the File explorer plugin, which displays the default workspace and some preloaded files and folders. However, if you select one of the other icons from the plugin panel, you'll see the content for the selected plugin.</p> <p>The main panel is automatically loaded with the Home tab, which contains links to a variety of resources. You can close this tab at any time and reopen it by clicking on the blue Remix icon in the top left corner of the plugin panel. The main panel is where you'll be able to see each of the files you're working with. For example, you can double-click on any file in the File explorer side panel and it will appear as a tab in the main panel.</p> <p>The terminal panel is similar to a standard terminal that you have on your OS; you can execute scripts from it, and logs are printed to it. All transactions and contract interactions are automatically logged to the terminal. You can also interact with the Ethers JavaScript library directly from the terminal.</p>"},{"location":"builders/ethereum/dev-env/remix/#add-a-smart-contract-to-the-file-explorer","title":"Add a Smart Contract to the File Explorer","text":"<p>For this example, you will create a new file that contains an ERC-20 token contract. This will be a simple ERC-20 contract based on the current OpenZeppelin ERC-20 template. The contract will create a <code>MyToken</code> token with the <code>MYTOK</code> symbol that mints the entirety of the initial supply to the creator of the contract.</p> <p>From the File explorer tab on the plugin panel, you can create a new file by taking the following steps:</p> <ol> <li>Click on the file icon</li> <li>Enter the name of the contract: <code>MyToken.sol</code></li> </ol> <p></p> <p>The main panel will switch to an empty file where you can add the Solidity code for the contract. Paste the <code>MyToken.sol</code> smart contract into the new file:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MYTOK\") {\n        _mint(msg.sender, initialSupply);\n    }\n}\n</code></pre> <p></p>"},{"location":"builders/ethereum/dev-env/remix/#compile-a-solidity-smart-contract","title":"Compile a Solidity Smart Contract","text":"<p>Before you compile a contract, make sure you've selected the file of the contract from the File explorer tab. Then, select the Solidity Compiler option from the plugin panel.</p> <p>Make sure that the compiler version in the top-left corner meets the version defined in your contract and the version defined in OpenZeppelin's <code>ERC20.sol</code> contract. For example, the <code>MyToken.sol</code> contract requires Solidity ^0.8.30, and OpenZeppelin's <code>ERC20.sol</code> contract is compatible with ^0.8.30, so the compiler needs to be set to version 0.8.30 or newer.</p> <p>The Solidity compiler plugin also lets you change some settings and apply advanced configurations for the compiler. If you're planning on iterating over the smart contract, you can check the Auto compile box, and whenever you make a change, the contract will automatically be recompiled.</p> <p>Additionally, from the Advanced Configurations menu, you can change the EVM version, enable optimizations, and set the number of times the bytecode is expected to be run throughout the contract's lifetime; the default is set to 200 times. For more information on contract optimization, please refer to the Solidity docs on The Optimizer.</p> <p>For this example, no additional configurations are needed. To compile the <code>MyToken.sol</code> contract, simply click on the Compile MyToken.sol contract. If the compilation was successful, you'll see a green check mark appear on the plugin panel next to the Solidity compiler plugin.</p> <p></p>"},{"location":"builders/ethereum/dev-env/remix/#debug-compilation-errors","title":"Debug Compilation Errors","text":"<p>If you tried to compile your smart contract but there was an error or warning, you can easily debug the issue with the help of ChatGPT directly from the Solidity compiler plugin in Remix.</p> <p>For example, if you only provided the token name to the ERC-20 constructor but forgot the token symbol and tried to compile the contract, an error would appear in the side panel. You can scroll down to read the error, and you'll see that there is also an ASK GPT button. To get help debugging the issue, you can click on ASK GPT, and a response will be returned in the Remix terminal that will guide you in the right direction to try and fix the issue. If you need additional help, you can go straight to the source and ask ChatGPT directly.</p> <p></p> <p>Once you successfully fix the issue and recompile the contract, you'll see a green check mark appear on the plugin panel next to the Solidity compiler plugin.</p> <p></p>"},{"location":"builders/ethereum/dev-env/remix/#deploy-a-solidity-smart-contract","title":"Deploy a Solidity Smart Contract","text":"<p>The Deploy and run transactions plugin enables you to configure contract deployment options, deploy contracts, and interact with deployed contracts.</p> <p>The side panel consists of the following deployment options:</p> <ul> <li>Environment - allows you to choose the execution environment for deployment</li> <li>Account - the account from which the deployment transaction will be sent</li> <li>Gas Limit - the maximum amount of gas that the deployment transaction can consume</li> <li>Value - the amount of the native asset to send along with the deployment transaction</li> <li>Contract - the contract to deploy</li> <li>Deploy - sends the deployment transaction to the specified environment using the selected account, gas limit, value, and the values for any constructor arguments</li> <li>At Address - allows you to interact with an existing contract by specifying its address</li> </ul> <p>The following section will cover how to configure the environment for deployment to be Moonbeam.</p>"},{"location":"builders/ethereum/dev-env/remix/#connect-remix-to-moonbeam","title":"Connect Remix to Moonbeam","text":"<p>To deploy the smart contract to Moonbeam, you'll need to make sure that you've connected your wallet to your Moonbeam development node or the Moonbeam network of your choice. Then, from the Deploy and run transactions tab, you can connect Remix to your wallet by selecting your wallet from the ENVIRONMENT dropdown. For example, if you have Trust Wallet installed, you'll see Injected Provider - TrustWallet from the dropdown. Aside from injected providers, you can also connect to Moonbeam via WalletConnect.</p> <p>For this example, MetaMask will be used. You should already have MetaMask installed and connected to your local Moonbeam development node. If not, please refer to the Interacting with Moonbeam Using MetaMask guide for step-by-step instructions.</p> <p>From the ENVIRONMENT dropdown, select Injected Provider - MetaMask.</p> <p></p> <p>MetaMask will pop up automatically and prompt you to connect to Remix. You'll need to:</p> <ol> <li>Select the account you want to connect to Remix</li> <li>Click Next</li> <li>Click Connect to connect your account to Remix</li> </ol> <p></p> <p>Once you've connected MetaMask to Remix, the side panel will update to reveal the network and account you're connected to. For a Moonbeam development node, you should see Custom (1281) network.</p> <p></p>"},{"location":"builders/ethereum/dev-env/remix/#deploy-the-contract-to-moonbeam","title":"Deploy the Contract to Moonbeam","text":"<p>Now that you've connected your wallet, you're ready to deploy the contract. Since you're deploying a simple ERC-20 token smart contract, the default gas limit set by Remix of 3 million is more than enough, and you don't need to specify a value to send along with the deployment. As such, you can take the following steps to deploy the contract:</p> <ol> <li>Make sure the ENVIRONMENT is set to Injected Provider - MetaMask</li> <li>Make sure the connected account is the one you want to deploy the transaction from</li> <li>Use the default GAS LIMIT of <code>3000000</code></li> <li>Leave the VALUE as <code>0</code></li> <li>Make sure <code>MyToken.sol</code> is the selected contract</li> <li>Expand the DEPLOY dropdown</li> <li>Specify the initial supply. For this example, you can set it to 8 million tokens. Since this contract uses the default of 18 decimals, the value to put in the box is <code>8000000000000000000000000</code></li> <li>Click transact to send the deployment transaction</li> <li>MetaMask will pop up, and you can click Confirm to deploy the contract</li> </ol> <p></p> <p>Once the transaction has been deployed, you'll see details about the deployment transaction in the Remix terminal. Additionally, the contract will appear under the Deployed Contracts section of the side panel.</p>"},{"location":"builders/ethereum/dev-env/remix/#interact-with-deployed-smart-contracts","title":"Interact with Deployed Smart Contracts","text":"<p>Once you've deployed a smart contract or accessed an existing contract via the At Address button, the contract will appear under the Deployed Contracts section of the side panel. You can expand the contract to view all of the contract's functions you can interact with.</p> <p>To interact with a given function, you can click on the function name, which will be contained in an orange, red, or blue button. Orange buttons are for functions that write to the blockchain and are non-payable; red buttons are for functions that write to the blockchain and are payable; and blue buttons are for functions that read data from the blockchain.</p> <p>Depending on the function you're interacting with, you may need to input parameter values. If the function requires inputs, you'll be able to enter them by expanding the function and entering a value for each of the parameters.</p> <p>If the function you're interacting with is payable, you'll be able to enter an amount in the VALUE field towards the top of the side panel, in the same value field used for contracts that have payable constructors.</p>"},{"location":"builders/ethereum/dev-env/remix/#call-the-smart-contract-functions","title":"Call the Smart Contract Functions","text":"<p>If you expand the MYTOKEN contract dropdown, you'll be able to see all of the available functions you can interact with. To interact with a given function, you can provide any inputs, if needed, and then click on the button containing the function name you want to interact with.</p> <p>For example, if you wanted to call the <code>totalSupply</code> function, you wouldn't need to sign a transaction, as you'd get a response right away.</p> <p></p> <p>On the other hand, if you call the <code>approve</code> function, which will approve an account as a spender of a given amount of MYTOK tokens, you'll need to submit the approval in MetaMask. To test this out, you can take the following steps:</p> <ol> <li>Set the spender to an account that you want to be able to spend tokens on your behalf. For this example, you can use Bob's account (one of the pre-funded development accounts): <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>Enter the amount the spender can spend. For this example, you can approve Bob to spend 10 MYTOK by entering in <code>10000000000000000000</code></li> <li>Press transact</li> <li>MetaMask will pop up and you'll need to review the details of the approval and submit the approval</li> </ol> <p></p> <p>To view your balance or approvals, or transfer MYTOKs, you can add the MYTOK to your wallet. For information on how to add a token to MetaMask, you can refer to the Add an ERC-20 Token section of our MetaMask documentation.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/dev-env/tenderly/","title":"Using Tenderly on Moonbeam","text":""},{"location":"builders/ethereum/dev-env/tenderly/#introduction","title":"Introduction","text":"<p>Tenderly is a Web3 development platform that contains a suite of tools designed to help developers throughout the DApp development life cycle. With Tenderly, you can build, debug, test, optimize, monitor, set up alerts, and view analytics for your smart contracts on Moonbeam and Moonriver.</p> <p>The Tenderly platform provides the following features:</p> <ul> <li> <p>Contract Verification - as it is essential to verify your smart contracts to take full advantage of all of Tenderly's features, Tenderly provides several methods of verification. You can verify smart contracts through the Tenderly dashboard, the Tenderly CLI and Foundry, or the Tenderly Hardhat plugin</p> </li> <li> <p>Debugger - use the visual debugger to inspect transactions and get better insight into the behavior of your code. With the debugger, you can review a transaction's stack trace, view the calls made in a transaction, step through a contract, and review decoded inputs, outputs, and state variables. You can use the debugger on the Tenderly dashboard or the Tenderly Debugger Chrome Extension</p> </li> <li> <p>Gas Profiler - view how much gas you're spending on a granular level, so you can optimize your smart contracts and reduce transaction gas costs</p> </li> <li> <p>Simulator - simulate transactions in a TestNet development environment to learn how your transactions will behave without having to send them on-chain. This way, you can know the transaction's outcome and ensure it works as expected before sending it to the network. You can experiment with different parameters, simulate historical and current transactions, and edit the contract source code. You can access the simulator from the Tenderly dashboard, or you can use the Tenderly Simulation API to take advantage of the simulator programmatically</p> </li> <li> <p>Virtual TestNets - simulate the live Moonbeam network in an isolated environment to interact with deployed contracts and real-time on-chain data. These test environments enable controlled development, testing, and debugging across smart contracts, UI, backend, and data indexing. They support sequential transaction simulations for complex scenarios. There are some limitations to be aware of when using this feature. Moonbeam precompiled contracts are not supported, as they are part of the Substrate implementation and cannot be replicated in the simulated EVM environment, prohibiting you from interacting with cross-chain assets, staking, and governance.</p> </li> <li> <p>Alerting - configure real-time alerts to notify you whenever a specific event occurs, allowing you to stay informed about what's going on with your smart contracts</p> </li> <li> <p>Web3 Actions - create programmable functions in JavaScript or TypeScript that are executed automatically by Tenderly when a specific smart contract or chain event occurs</p> </li> </ul> <p>Note</p> <p>Tenderly supports Moonbeam, Moonriver, and Moonbase Alpha, except for the Web3 Gateway. For more information, check out Tenderly's documentation on Supported Networks.</p>"},{"location":"builders/ethereum/dev-env/tenderly/#getting-started","title":"Getting Started","text":"<p>The Tenderly dashboard provides access to an all-in-one Web3 development platform. To get started with the dashboard, you'll need to sign up for an account. Once you've signed up, you'll be able to start exploring your Tenderly dashboard.</p> <p></p> <p>If you prefer not to set up an account, you can also access limited features using Tenderly's explorer. Without an account, you can still gain insights into contracts and transactions. However, you won't be able to simulate transactions or create Virtual TestNets.</p> <p>To interact with Tenderly's features programmatically, you can check out the Tenderly CLI GitHub repository for more information.</p> <p>The following sections will show you how to get started with Tenderly on Moonbeam. For more detailed documentation, please refer to Tenderly's documentation site.</p>"},{"location":"builders/ethereum/dev-env/tenderly/#add-a-contract","title":"Add a Contract","text":"<p>A good place to start with the Tenderly dashboard is to add a deployed smart contract. Once you've added a contract, you'll be able to create transaction simulations and Virtual TestNets, use the debugger, set up monitoring and alerts, and more.</p> <p>To add a new contract, you can click on Contracts on the left-side panel and click Add Contract. A pop-up will appear, and you can take the following steps:</p> <ol> <li>Enter the contract address</li> <li>(Optional) You can give your contract a name</li> <li>Choose Moonbeam, Moonriver, or Moonbase Alpha as the network, depending on which network you've deployed your smart contract to</li> <li>(Optional) Toggle the Add more slider to add additional contracts after the initial one</li> <li>Finally, to add the contract to the dashboard, click Save</li> </ol> <p></p> <p>After a contract has been added, it will appear in the list of contracts on the Contracts dashboard. If the contract hasn't been verified yet, the dashboard will display an Unverified status along with a Verify button.</p> <p></p> <p>To take full advantage of the Tenderly tool set, it is recommended that you verify your smart contracts, which you can do by clicking on Verify. You can choose to verify your contract by uploading the contract's JSON, ABI, or source code. For more information, please refer to Tenderly's documentation on Smart Contract Verification.</p>"},{"location":"builders/ethereum/dev-env/tenderly/#virtual-testnets-moonbeam","title":"Create a Virtual TestNet","text":"<p>Tenderly's Virtual TestNets feature simulates the live Moonbeam network in an isolated environment, which enables you to interact with deployed contracts and live on-chain data.</p> <p>There are some limitations to be aware of when using this feature. You cannot interact with any of the Moonbeam precompiled contracts and their functions. Precompiles are a part of the Substrate implementation and, therefore, cannot be replicated in the simulated EVM environment. This prohibits you from interacting with cross-chain assets on Moonbeam and Substrate-based functionality such as staking and governance.</p> <p>Tenderly makes creating a TestNet through the dashboard quite simple. To get started, click on Virtual TestNets on the left-side menu and then click Create Virtual TestNet. From there, you can take the following steps:</p> <ol> <li>Select Moonbeam, Moonriver, or Moonbase Alpha from the Parent network dropdown</li> <li>(Optional) Give your TestNet a name</li> <li>Select your Chain ID; you can use a custom one or the original network ID. It is recommended to set a custom Chain ID to prevent replay attacks and avoid issues when adding the Virtual TestNet to wallets</li> <li>Choose whether to turn on or off the Public Explorer</li> <li>Enable State Sync if you want to keep your Virtual TestNet updated in real-time with the parent network</li> <li>To limit data, disable Use latest block and enter a block number, or keep it enabled to include all blocks</li> <li>Click Create</li> </ol> <p></p> <p>Once you've created your Virtual TestNet, you can start using it by deploying a contract or creating a transaction simulation.</p> <p>To deploy a contract, go to Contracts in the left menu. Use one from Watched Contracts or add a new one via Watch Contract. Once added, it will appear in Contracts, where you can view its details.</p> <p>To create a simulation, click the Simulation button and enter the configurations for the simulation. For more information on simulations, please refer to Tenderly's Simulator UI Overview documentation.</p> <p></p> <p>Now that you've learned how to get started with a few of Tenderly's features on Moonbeam, please feel free to dive in and check out the other tools available in their development platform. You can visit Tenderly's documentation site for more information. You can also check out Moonbeam's tutorial on Using Tenderly to Simulate and Debug Transactions.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/json-rpc/debug-trace/","title":"Debug API &amp; Trace Module","text":""},{"location":"builders/ethereum/json-rpc/debug-trace/#introduction","title":"Introduction","text":"<p>Geth's debug and txpool APIs and OpenEthereum's trace module provide non-standard RPC methods for deeper insight into transaction processing. Some of these non-standard RPC methods are supported as part of Moonbeam's goal of providing a seamless Ethereum experience for developers. Supporting these RPC methods is an essential milestone because many projects like The Graph rely on them to index blockchain data.</p> <p>This guide will cover the supported RPC methods available on Moonbeam and how to invoke them using curl commands against a tracing node with the debug, txpool, and tracing flags enabled. You can access a tracing node in one of two ways: through a supported tracing RPC provider or by spinning up a tracing node of your own.</p> <p>To view a list of tracing RPC providers, please check out the Network Endpoints page.</p> <p>If you wish to set up your own tracing node, you can follow the Running a Tracing Node guide. The RPC HTTP endpoint of your tracing node should be at <code>http://127.0.0.1:9944</code> and your node should display similar logs to the following:</p> docker run --network host  \\     -u $(id -u ${USER}):$(id -g ${USER}) \\         moonbeamfoundation/moonbeam-tracing:v0.49.2-4100-4d7b \\     --name=\"Moonbeam-Tracing-Tutorial\" \\     --unsafe-rpc-external \\     --ethapi=debug,trace,txpool \\     --wasm-runtime-overrides=/moonbeam/moonbase-substitutes-tracing \\     --runtime-cache-size 64 \\     --dev     2025-07-10 09:04:26 Moonbeam Parachain Collator      2025-07-10 09:04:26 \u270c\ufe0f  version 0.49.2      2025-07-10 09:04:26 \u2764\ufe0f  by PureStake, 2019-2025      2025-07-10 09:04:26 \ud83d\udccb Chain specification: Moonbase Development Testnet      2025-07-10 09:04:26 \ud83c\udff7  Node name: Moonbeam-Tracing-Tutorial      2025-07-10 09:04:26 \ud83d\udc64 Role: AUTHORITY      2025-07-10 09:04:26 \ud83d\udcbe Database: RocksDb at /tmp/substrateO3YeRz/chains/moonbase_dev/db/full      2025-07-10 09:04:26 Found wasm override. version=moonbase-300 (moonbase-0.tx2.au3) file=/moonbeam/moonbase-substitutes-tracing/moonbase-runtime-300-substitute-tracing.wasm      ...      2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0x18e6\u20262eb1), finalized #0 (0x18e6\u20262eb1), \u2b07 0 \u2b06 0"},{"location":"builders/ethereum/json-rpc/debug-trace/#supported-methods","title":"Supported Debug and Trace JSON-RPC Methods","text":"debug_traceTransaction <p>This method attempts to replay a transaction in the same manner as it was executed on the network. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <ul> <li><code>transaction_hash</code> string - the hash of the transaction to be traced</li> <li><code>tracer_config</code> string - (optional) a JSON object for configuring the tracer that contains the following field: <ul> <li><code>tracer</code> string - sets the type of tracer</li> </ul> </li> </ul> <p>If no <code>tracer_config</code> is provided, the opcode logger will be the default tracer. The opcode logger provides the following additional fields:</p> <ul> <li><code>opcode_config</code> string - (optional) a JSON object for configuring the opcode logger:<ul> <li><code>disableStorage</code> boolean \u2014 (optional, default: <code>false</code>) setting this to <code>true</code> disables storage capture</li> <li><code>disableMemory</code> boolean \u2014 (optional, default: <code>false</code>) setting this to <code>true</code> disables memory capture</li> <li><code>disableStack</code> boolean \u2014 (optional, default: <code>false</code>) setting this to <code>true</code> disables stack capture</li> </ul> </li> </ul> <p>If you supplied a <code>tracer_config</code>, the <code>result</code> object contains the following fields:</p> <ul> <li><code>type</code> - the type of the call</li> <li><code>from</code> - the address the transaction is sent from</li> <li><code>to</code> - the address the transaction is directed to</li> <li><code>value</code> - the integer of the value sent with this transaction</li> <li><code>gas</code> - the integer of the gas provided for the transaction execution</li> <li><code>gasUsed</code> - the integer of the gas used</li> <li><code>input</code> - the data given at the time of input</li> <li><code>output</code> - the data which is returned as an output</li> <li><code>error</code> - the type of error, if any</li> <li><code>revertReason</code> - the type solidity revert reason, if any</li> <li><code>calls</code> - a list of sub-calls, if any</li> </ul> <p> If you used the default opcode logger, the <code>result</code> object contains the following fields:</p> <ul> <li><code>gas</code>- the integer of the gas provided for the transaction execution</li> <li><code>returnValue</code> - the output produced by the execution of the transaction</li> <li><code>structLogs</code> - an array of objects containing a detailed log of each opcode executed during the transaction</li> <li><code>failed</code> - a boolean indicating whether the transaction execution failed or succeeded</li> </ul> <p>Using the <code>tracer_config</code>:</p> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n'{\n  \"jsonrpc\":\"2.0\",\n  \"id\": 1,\n  \"method\": \"debug_traceTransaction\",\n  \"params\": [\"INSERT_TRANSACTION_HASH\", {\"tracer\": \"callTracer\"}]\n}'\n</code></pre> <p> Using the default opcode logger:</p> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n'{\n  \"jsonrpc\":\"2.0\",\n  \"id\": 1,\n  \"method\": \"debug_traceTransaction\",\n  \"params\": [\"INSERT_TRANSACTION_HASH\"]\n}'\n</code></pre> debug_traceBlockByNumber <p>This method attempts to replay a block in the same manner as it was executed on the network. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <ul> <li><code>block_number</code> string - the block number of the block to be traced</li> <li><code>tracer_config</code> string - a JSON object for configuring the tracer that contains the following field: <ul> <li><code>tracer</code> string - sets the type of tracer. This must be set to <code>callTracer</code>, which only returns transactions and sub-calls. Otherwise, the tracer will attempt to default to the opcode logger, which is not supported at this time due to the heavy nature of the call</li> </ul> </li> </ul> <p>The method returns a JSON object with a top-level result property that is an array. Each element in this array corresponds to a single transaction in the block and includes a <code>txHash</code> and a <code>result</code> object as follows: </p> <ul> <li><code>txHash</code> - the transaction hash</li> </ul> <p>The <code>result</code> object contains the following fields:</p> <ul> <li><code>type</code> - the type of the call</li> <li><code>from</code> - the address the transaction is sent from</li> <li><code>to</code> - the address the transaction is directed to</li> <li><code>value</code> - the integer of the value sent with this transaction</li> <li><code>gas</code> - the integer of the gas provided for the transaction execution</li> <li><code>gasUsed</code> - the integer of the gas used</li> <li><code>input</code> - the data given at the time of input</li> <li><code>output</code> - the data which is returned as an output</li> <li><code>error</code> - the type of error, if any</li> <li><code>revertReason</code> - the type solidity revert reason, if any</li> <li><code>calls</code> - a list of sub-calls, if any</li> </ul> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"debug_traceBlockByNumber\",\n    \"params\": [\"INSERT_BLOCK_NUMBER\", {\"tracer\": \"callTracer\"}]\n  }'\n</code></pre> debug_traceBlockByHash <p>This method attempts to replay a block in the same manner as it was executed on the network. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <ul> <li><code>block_hash</code> string - the block hash of the block to be traced</li> <li><code>tracer_config</code> string - a JSON object for configuring the tracer that contains the following field: <ul> <li><code>tracer</code> string - sets the type of tracer. This must be set to <code>callTracer</code>, which only returns transactions and sub-calls. Otherwise, the tracer will attempt to default to the opcode logger, which is not supported at this time due to the heavy nature of the call</li> </ul> </li> </ul> <p>The method returns a JSON object with a top-level result property that is an array. Each element in this array corresponds to a single transaction in the block and includes a <code>txHash</code> and a <code>result</code> object as follows: </p> <ul> <li><code>txHash</code> - the transaction hash</li> </ul> <p>The <code>result</code> object contains the following fields:</p> <ul> <li><code>type</code> - the type of the call</li> <li><code>from</code> - the address the transaction is sent from</li> <li><code>to</code> - the address the transaction is directed to</li> <li><code>value</code> - the integer of the value sent with this transaction</li> <li><code>gas</code> - the integer of the gas provided for the transaction execution</li> <li><code>gasUsed</code> - the integer of the gas used</li> <li><code>input</code> - the data given at the time of input</li> <li><code>output</code> - the data which is returned as an output</li> <li><code>error</code> - the type of error, if any</li> <li><code>revertReason</code> - the type solidity revert reason, if any</li> <li><code>calls</code> - a list of sub-calls</li> </ul> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"debug_traceBlockByHash\",\n    \"params\": [\"INSERT_BLOCK_HASH\", {\"tracer\": \"callTracer\"}]\n  }'\n</code></pre> debug_traceCall <p>This method executes an eth_call within the context of the given block using the final state of the parent block as the base. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <ul> <li><code>call_object</code> object the transaction object to be executed</li> <li><code>block_hash</code> string - the block hash of the base block</li> </ul> <ul> <li><code>gas</code>- the integer of the gas provided for the transaction execution</li> <li><code>returnValue</code> - the output produced by the execution of the transaction</li> <li><code>structLogs</code> - an array of objects containing a detailed log of each opcode executed during the transaction</li> </ul> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"debug_traceCall\",\n    \"params\": [{\n        \"from\": \"INSERT_FROM_ADDRESS\",\n        \"to\":\"INSERT_TO_ADDRESS\",\n        \"data\":\"INSERT_CALL_DATA\"\n        }, \"INSERT_BLOCK_HASH\"]\n  }'\n</code></pre> trace_filter <p>This method returns matching traces for the given filters. Refer to Open Ethereum's documentation for more information.</p> ParametersReturnsExample <ul> <li><code>fromBlock</code> string \u2014 (optional) either block number (hex), <code>earliest</code>, which is the genesis block, or <code>latest</code> (default), which is the best block available. The trace starting block</li> <li><code>toBlock</code> string \u2014 (optional) either block number (hex), <code>earliest</code>, which is the genesis block, or <code>latest</code>, which is the best block available. The trace-ending block</li> <li><code>fromAddress</code> array \u2014 (optional) filter transactions from these addresses only. If an empty array is provided, no filtering is done with this field</li> <li><code>toAddress</code> array \u2014 (optional) filter transactions to these addresses only. If an empty array is provided, no filtering is done with this field</li> <li><code>after</code> uint \u2014 (optional) the default offset is <code>0</code>. The trace offset (or starting) number</li> <li><code>count</code> uint \u2014 (optional) number of traces to display in a batch</li> </ul> <p>There are a couple of default values that you should be aware of:</p> <ul> <li>The maximum number of trace entries a single request of <code>trace_filter</code> is allowed to return is <code>500</code>. A request exceeding this limit will return an error</li> <li>Blocks processed by requests are temporarily stored in the cache for <code>300</code> seconds, after which they are deleted</li> </ul> <p>You can configure additional flags when spinning up your tracing node to change the default values.</p> <p>The <code>result</code> array contains an array of objects for the block traces. All objects will contain the following fields:</p> <ul> <li><code>blockHash</code>- the hash of the block where this transaction was in</li> <li><code>blockNumber</code> - the block number where this transaction was in</li> <li><code>subtraces</code> - the traces of contract calls made by the transaction</li> <li><code>traceAddress</code> - the list of addresses where the call was executed, the address of the parents, and the order of the current sub-call</li> <li><code>transactionHash</code> - the hash of the transaction</li> <li><code>transactionPosition</code> - the transaction position</li> <li><code>type</code> - the value of the method, such as <code>call</code> or <code>create</code></li> </ul> <p> If the <code>type</code> of the transaction is a <code>call</code>, these additional fields will exist:</p> <ul> <li><code>action</code> - an object containing the call information:<ul> <li><code>from</code> - the address of the sender</li> <li><code>callType</code> - the type of method, such as <code>call</code> and <code>delegatecall</code></li> <li><code>gas</code> - the gas provided by the sender, encoded as hexadecimal</li> <li><code>input</code> - the data sent along with the transaction</li> <li><code>to</code> - the address of the receiver</li> <li><code>value</code> - the integer of the value sent with this transaction, encoded as hexadecimal</li> </ul> </li> <li><code>result</code> - an object containing the result of the transaction<ul> <li><code>gasUsed</code>- the amount of gas used by this specific transaction alone</li> <li><code>output</code>- the value returned by the contract call, and it only contains the actual value sent by the return method. If the return method was not executed, the output is empty bytes</li> </ul> </li> </ul> <p>If the <code>type</code> of the transaction is a <code>create</code>, these additional fields will exist:</p> <ul> <li><code>action</code> - an object containing information on the contract creation:<ul> <li><code>from</code> - the address of the sender</li> <li><code>creationMethod</code> - the creation method, such as <code>create</code></li> <li><code>gas</code> - the gas provided by the sender, encoded as hexadecimal</li> <li><code>init</code> - the initialization code of the contract</li> <li><code>value</code> - the integer of the value sent with this transaction, encoded as hexadecimal</li> </ul> </li> <li><code>result</code> - an object containing the result of the transaction<ul> <li><code>address</code> - the address of the contract</li> <li><code>code</code> - the bytecode of the contract</li> <li><code>gasUsed</code>- the amount of gas used by this specific transaction alone</li> </ul> </li> </ul> <p>This example starts with a zero offset and provides the first 20 traces:</p> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"trace_filter\", \"params\": \n    [{\n      \"fromBlock\": \"INSERT_FROM_BLOCK\",\n      \"toBlock\": \"INSERT_TO_BLOCK\",\n      \"toAddress\": [\"INSERT_ADDRESS_TO_FILTER\"],\n      \"after\": 0,\n      \"count\": 20\n    }]\n  }'\n</code></pre> txpool_content <p>Returns the details for all currently pending transactions waiting to be included in the next block(s) and all queued transactions for future execution. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <p>None</p> <p>The <code>result</code> object contains the following fields:</p> <ul> <li><code>pending</code> - an object containing the pending transaction details, which maps an address to a batch of scheduled transactions<ul> <li><code>address</code> - the address initiating a transaction, which maps the addresses' associating nonces with their transactions<ul> <li><code>nonce</code> - the nonce of the sending address<ul> <li><code>blockHash</code> - the hash of the block where this transaction was included. For pending transactions, this is an empty 32-byte string in hexadecimal format</li> <li><code>blockNumber</code> - the block number where this transaction was added encoded as a hexadecimal. For pending transactions, this is <code>null</code></li> <li><code>from</code> - the address of the sender</li> <li><code>gas</code> - the total amount of gas units used in the transaction</li> <li><code>gasPrice</code> - the total amount in Wei the sender is willing to pay for the transaction</li> <li><code>maxFeePerGas</code> - the maximum amount of gas willing to be paid for the transaction</li> <li><code>maxPriorityFeePerGas</code> - the maximum amount of gas to be included as a tip to the miner</li> <li><code>hash</code> - the hash of the transaction</li> <li><code>input</code> - the encoded transaction input data</li> <li><code>nonce</code> - the number of transactions the sender has sent till now</li> <li><code>to</code> - the address of the receiver. <code>null</code> when it's a contract creation transaction</li> <li><code>transactionIndex</code> - an integer of the transactions index position in the block encoded as a hexadecimal format. For pending transactions, this is <code>null</code></li> <li><code>value</code> - the value transferred in Wei encoded as a hexadecimal format</li> </ul> </li> </ul> </li> </ul> </li> <li><code>queued</code> - an object containing the queued transaction details, which maps an address to a batch of scheduled transactions<ul> <li><code>address</code> - the address initiating a transaction, which maps the addresses' associating nonces with their transactions<ul> <li><code>nonce</code> - the nonce of the sending address<ul> <li><code>blockHash</code> - the hash of the block where this transaction was included. For queued transactions, this is an empty 32-byte string in hexadecimal format</li> <li><code>blockNumber</code> - the block number where this transaction was added encoded as a hexadecimal. For queued transactions, this is <code>null</code></li> <li><code>from</code> - the address of the sender</li> <li><code>gas</code> - the total amount of gas units used in the transaction</li> <li><code>gasPrice</code> - the total amount in wei the sender is willing to pay for the transaction</li> <li><code>maxFeePerGas</code> - the maximum amount of gas willing to be paid for the transaction</li> <li><code>maxPriorityFeePerGas</code> - the maximum amount of gas to be included as a tip to the miner</li> <li><code>hash</code> - the hash of the transaction</li> <li><code>input</code> - the encoded transaction input data</li> <li><code>nonce</code> - the number of transactions the sender has sent till now</li> <li><code>to</code> - the address of the receiver. <code>null</code> when it's a contract creation transaction</li> <li><code>transactionIndex</code> - an integer of the transactions index position in the block encoded as a hexadecimal format. For queued transactions, this is <code>null</code></li> <li><code>value</code> - the value transferred in Wei encoded as a hexadecimal format</li> </ul> </li> </ul> </li> </ul> </li> </ul> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"txpool_content\", \"params\":[]\n  }'\n</code></pre> txpool_inspect <p>Returns a summary for all currently pending transactions waiting to be included in the next block(s) and all queued transactions for future execution. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <p>None</p> <p>The <code>result</code> object contains the following fields:</p> <ul> <li><code>pending</code> - an object containing the pending transaction summary strings, which maps an address to a batch of scheduled transactions<ul> <li><code>address</code> - the address initiating a transaction, which maps the addresses' associating nonces with their transaction summary strings</li> </ul> </li> <li><code>queued</code> - an object containing the queued transaction summary strings, which maps an address to a batch of scheduled transactions<ul> <li><code>address</code> - the address initiating a transaction, which maps the addresses' associating nonces with their transaction summary strings</li> </ul> </li> </ul> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"txpool_inspect\", \"params\":[]\n  }'\n</code></pre> txpool_status <p>Returns the total number of transactions currently pending transactions waiting to be included in the next block(s) and all queued transactions for future execution. Refer to Geth's documentation for more information.</p> ParametersReturnsExample <p>None</p> <p>The <code>result</code> object contains the following fields:</p> <ul> <li><code>pending</code> - a counter representing the number of pending transactions</li> <li><code>queued</code> - a counter representing the number of queued transactions</li> </ul> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"txpool_status\", \"params\":[]\n  }'\n</code></pre>"},{"location":"builders/ethereum/json-rpc/eth-rpc/","title":"Supported Ethereum RPC Methods","text":""},{"location":"builders/ethereum/json-rpc/eth-rpc/#introduction","title":"Introduction","text":"<p>The Moonbeam team has collaborated closely with Parity on developing Frontier, an Ethereum compatibility layer for Substrate-based chains. This layer enables developers to run unmodified Ethereum dApps on Moonbeam seamlessly.</p> <p>Nevertheless, not all Ethereum JSON-RPC methods are supported; some of those supported return default values (those related to Ethereum's PoW consensus mechanism in particular). This guide provides a comprehensive list of supported Ethereum JSON-RPC methods on Moonbeam. Developers can quickly reference this list to understand the available functionality for interfacing with Moonbeam's Ethereum-compatible blockchain.</p>"},{"location":"builders/ethereum/json-rpc/eth-rpc/#basic-rpc-methods","title":"Standard Ethereum JSON-RPC Methods","text":"<p>The basic JSON-RPC methods from the Ethereum API supported by Moonbeam are:</p> <ul> <li>eth_protocolVersion \u2014 returns <code>1</code> by default</li> <li>eth_syncing \u2014 returns an object with data about the sync status or <code>false</code></li> <li>eth_hashrate \u2014 returns <code>\"0x0\"</code> by default</li> <li>eth_coinbase \u2014 returns the latest block author. Not necessarily a finalized block</li> <li>eth_mining \u2014 returns <code>false</code> by default</li> <li>eth_chainId \u2014 returns the chain ID used for signing at the current block</li> <li>eth_gasPrice \u2014 returns the base fee per unit of gas used. This is currently the minimum gas price for each network</li> <li>eth_accounts \u2014 returns a list of addresses owned by the client</li> <li>eth_blockNumber \u2014 returns the highest available block number</li> <li>eth_getBalance \u2014 returns the balance of the given address. Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_getStorageAt \u2014 returns the content of the storage at a given address. Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_getBlockByHash \u2014 returns information about the block of the given hash, including <code>baseFeePerGas</code> on post-London blocks</li> <li>eth_getBlockByNumber \u2014 returns information about the block specified by block number, including <code>baseFeePerGas</code> on post-London blocks. Instead of providing a block number as the first parameter, you can provide a default block parameter</li> <li>eth_getBlockReceipts \u2014 returns all transaction receipts for a given block</li> <li>eth_getTransactionCount \u2014 returns the number of transactions sent from the given address (nonce). Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_getBlockTransactionCountByHash \u2014 returns the number of transactions in a block with a given block hash</li> <li>eth_getBlockTransactionCountByNumber \u2014 returns the number of transactions in a block with a given block number</li> <li>eth_getUncleCountByBlockHash \u2014  returns <code>\"0x0\"</code> by default</li> <li>eth_getUncleCountByBlockNumber \u2014 returns <code>\"0x0\"</code> by default</li> <li>eth_getCode \u2014 returns the code at the given address at the given block number. Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_sendTransaction \u2014 creates a new message call transaction or a contract creation, if the data field contains code. Returns the transaction hash or the zero hash if the transaction is not yet available</li> <li>eth_sendRawTransaction \u2014 creates a new message call transaction or a contract creation for signed transactions. Returns the transaction hash or the zero hash if the transaction is not yet available</li> <li>eth_call \u2014 executes a new message call immediately without creating a transaction on the blockchain, returning the value of the executed call<ul> <li>Moonbeam supports the use of the optional state override set object. This address-to-state mapping object allows the user to specify some state to be ephemerally overridden before executing a call to <code>eth_call</code>. The state override set is commonly used for tasks like debugging smart contracts. Visit the go-ethereum documentation to learn more</li> <li>Instead of providing a block number as a parameter, you can provide a default block parameter</li> </ul> </li> <li>eth_estimateGas \u2014 returns an estimated amount of gas necessary for a given transaction to succeed. You can optionally specify a <code>gasPrice</code> or <code>maxFeePerGas</code> and <code>maxPriorityFeePerGas</code>. Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_maxPriorityFeePerGas - returns an estimate of how much priority fee, in Wei, is needed for inclusion in a block</li> <li>eth_feeHistory \u2014 returns <code>baseFeePerGas</code>, <code>gasUsedRatio</code>, <code>oldestBlock</code>, and <code>reward</code> for a specified range of up to 1024 blocks</li> <li>eth_getTransactionByHash \u2014 returns the information about a transaction with a given hash. EIP-1559 transactions have <code>maxPriorityFeePerGas</code> and <code>maxFeePerGas</code> fields</li> <li>eth_getTransactionByBlockHashAndIndex \u2014 returns information about a transaction at a given block hash and a given index position. EIP-1559 transactions have <code>maxPriorityFeePerGas</code> and <code>maxFeePerGas</code> fields</li> <li>eth_getTransactionByBlockNumberAndIndex \u2014 returns information about a transaction at a given block number and a given index position. EIP-1559 transactions have <code>maxPriorityFeePerGas</code> and <code>maxFeePerGas</code> fields. Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_getTransactionReceipt \u2014 returns the transaction receipt of a given transaction hash</li> <li>eth_getUncleByBlockHashAndIndex \u2014 returns <code>null</code> by default</li> <li>eth_getUncleByBlockNumberAndIndex \u2014 returns <code>null</code> by default</li> <li>eth_getLogs \u2014 returns an array of all logs matching a given filter object. Instead of providing a block number as a parameter, you can provide a default block parameter</li> <li>eth_newFilter \u2014 creates a filter object based on the input provided. Returns a filter ID</li> <li>eth_newBlockFilter \u2014 creates a filter in the node to notify when a new block arrives. Returns a filter ID</li> <li>eth_newPendingTransactionFilter - creates a filter in the node to notify when new pending transactions arrive. Returns a filter ID</li> <li>eth_getFilterChanges \u2014 polling method for filters (see methods above). Returns an array of logs that occurred since the last poll</li> <li>eth_getFilterLogs \u2014 returns an array of all the logs matching the filter with a given ID</li> <li>eth_uninstallFilter \u2014 uninstall a filter with a given ID. It should be used when polling is no longer needed. Filters timeout when they are not requested using <code>eth_getFilterChanges</code> after some time</li> </ul>"},{"location":"builders/ethereum/json-rpc/eth-rpc/#default-block-parameters","title":"Default Block Parameters","text":"<p>Moonbeam supports several default block parameters that allow you to query a subset of JSON-RPC methods at significant block heights. Moonbeam supports the following default block parameters: </p> <ul> <li><code>finalized</code> - Refers to the most recent block that Polkadot validators have finalized</li> <li><code>safe</code> - Synonymous with <code>finalized</code> in Moonbeam. In Ethereum, <code>safe</code> refers to the most recent block that is considered safe by the network, meaning it is unlikely to be reverted but has not yet been finalized. With Moonbeam's fast and deterministic finality, <code>finalized</code> and <code>safe</code> refer to the same blocks. </li> <li><code>earliest</code> - Refers to the genesis block of the blockchain</li> <li><code>pending</code> - Represents the latest state, including pending transactions that have not yet been mined into a block. This is a live view of the mempool</li> <li><code>latest</code> - Refers to the latest confirmed block in the blockchain, which may not be finalized</li> </ul>"},{"location":"builders/ethereum/json-rpc/eth-rpc/#unsupported-rpc-methods","title":"Unsupported Ethereum JSON-RPC Methods","text":"<p>Moonbeam does not support the following Ethereum API JSON-RPC methods:</p> <ul> <li>eth_getProof - returns the account and storage values of the specified account including the Merkle-proof</li> <li>eth_blobBaseFee - returns the expected base fee for blobs in the next block</li> <li>eth_createAccessList - creates an EIP-2930 type <code>accessList</code> based on a given transaction object</li> <li>eth_sign - allows the user to sign an arbitrary hash to be sent at a later time. Presents a security risk as the arbitrary hash can be fraudulently applied to other transactions</li> <li>eth_signTransaction - allows the user to sign a transaction to be sent at a later time. It is rarely used due to associated security risks</li> </ul>"},{"location":"builders/ethereum/json-rpc/eth-rpc/#additional-rpc-methods","title":"Additional RPC Methods","text":"<p>Check out some of the non-standard Ethereum and Moonbeam-specific RPC methods:</p> <ul> <li>Debug and Trace</li> <li>Event Subscription</li> <li>Custom Moonbeam</li> </ul>"},{"location":"builders/ethereum/json-rpc/moonbeam-custom-api/","title":"Moonbeam Custom API","text":""},{"location":"builders/ethereum/json-rpc/moonbeam-custom-api/#introduction","title":"Introduction","text":"<p>Moonbeam nodes include support for custom JSON-RPC endpoints: </p> <ul> <li><code>moon_isBlockFinalized</code> </li> <li><code>moon_isTxFinalized</code></li> <li><code>moon_getEthSyncBlockRange</code></li> </ul> <p>These endpoints provide valuable functionality for checking the finality of on-chain events.</p> <p>To begin exploring Moonbeam's custom JSON-RPC endpoints, you can try out the provided curl examples below. These examples demonstrate how to query the public RPC endpoint of Moonbase Alpha. However, you can easily modify them to use with your own Moonbeam or Moonriver endpoint by changing the URL and API key. If you haven't already, you can obtain your endpoint and API key from one of our supported Endpoint Providers.</p>"},{"location":"builders/ethereum/json-rpc/moonbeam-custom-api/#rpc-methods","title":"Supported Custom RPC Methods","text":"moon_isBlockFinalized <p>Checks for the finality of the block given by its block hash.</p> ParametersReturnsExample <ul> <li><code>block_hash</code> string - the hash of the block, accepts either Substrate-style or Ethereum-style block hash as its input</li> </ul> <p>Returns a boolean: <code>true</code> if the block is finalized, <code>false</code> if the block is not finalized or not found.</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"moon_isBlockFinalized\",\n  \"params\": [\"INSERT_BLOCK_HASH\"]\n}' https://rpc.api.moonbase.moonbeam.network\n</code></pre> moon_isTxFinalized <p>Checks for the finality of a transaction given its EVM transaction hash.</p> ParametersReturnsExample <ul> <li><code>tx_hash</code> string - the EVM transaction hash of the transaction </li> </ul> <p>Returns a boolean: <code>true</code> if the transaction is finalized, <code>false</code> if the transaction is not finalized or not found.</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"moon_isTxFinalized\",\n  \"params\": [\"INSERT_TRANSACTION_HASH\"]\n}' https://rpc.api.moonbase.moonbeam.network\n</code></pre> moon_getEthSyncBlockRange <p>Returns the range of blocks that are fully indexed in Frontier's backend.</p> ParametersReturnsExample <p>None</p> <p>Returns the range of blocks that are fully indexed in Frontier's backend. An example response below includes the Substrate block hashes of block <code>0</code> and the latest fully indexed block:</p> <p><code>[ \"0x91bc6e169807aaa54802737e1c504b2577d4fafedd5a02c10293b1cd60e39527\", \"0xb1b49bd709ca9fe0e751b8648951ffbb2173e1258b8de8228cfa0ab27003f612\" ]</code></p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"moon_getEthSyncBlockRange\",\n  \"params\": []\n}' https://rpc.api.moonbase.moonbeam.network\n</code></pre>"},{"location":"builders/ethereum/json-rpc/pubsub/","title":"Subscribe to Events","text":""},{"location":"builders/ethereum/json-rpc/pubsub/#introduction","title":"Introduction","text":"<p>Moonbeam supports event subscriptions for Ethereum-style events, which allows you to wait for events and handle them accordingly instead of polling for them.</p> <p>It works by subscribing to particular events; an ID is returned for each subscription. For each event that matches the subscription, a notification with relevant data is sent together with the subscription ID.</p> <p>In this guide, you will learn how to subscribe to event logs, incoming pending transactions, and incoming block headers on Moonbase Alpha. This guide can also be adapted for Moonbeam or Moonriver.</p>"},{"location":"builders/ethereum/json-rpc/pubsub/#filter-rpc-methods","title":"Supported Pubsub JSON-RPC Methods","text":"<p>Please note that the examples in this section require installing wscat.</p> eth_subscribe <p>Creates a subscription for a given subscription name.</p> ParametersReturnsExample <ul> <li><code>subscription_name</code> string - the type of the event to subscribe to. The supported subscription types are:<ul> <li><code>newHeads</code> \u2014 triggers a notification each time a new header is appended to the chain</li> <li><code>logs</code> \u2014 returns logs that are included in new imported blocks and match a given filter criteria</li> <li><code>newPendingTransactions</code> \u2014 returns the hash for all transactions that are added to the pending state</li> <li><code>syncing</code> \u2014 indicates when the node starts or stops synchronizing with the network</li> </ul> </li> </ul> <p>The <code>result</code> returns the subscription ID.</p> <pre><code>wscat -c wss://wss.api.moonbase.moonbeam.network -x '\n  {\n    \"jsonrpc\": \"2.0\", \n    \"id\": 1, \n    \"method\": \"eth_subscribe\", \n    \"params\": [\"INSERT_SUBSCRIPTION_NAME\"]\n  }'\n</code></pre> eth_unsubscribe <p>Cancels an existing subscription given its subscription ID.</p> ParametersReturnsExample <ul> <li><code>subscription_id</code> string - the subscription ID</li> </ul> <p>The <code>result</code> returns a boolean indicating whether or not the subscription was successfully canceled.</p> <pre><code>wscat -c wss://wss.api.moonbase.moonbeam.network -x '\n  {\n    \"jsonrpc\": \"2.0\", \n    \"id\": 1, \n    \"method\": \"eth_unsubscribe\", \n    \"params\": [\"INSERT_SUBSCRIPTION_ID\"]\n  }'\n</code></pre>"},{"location":"builders/ethereum/json-rpc/pubsub/#subscribe-to-events","title":"Subscribe to Events Using Ethereum Libraries","text":"<p>This section will show you how to use Ethereum libraries, like Ethers.js, to programmatically subscribe to events on Moonbeam.</p>"},{"location":"builders/ethereum/json-rpc/pubsub/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The examples in this guide are based on an Ubuntu 22.04 environment. You will also need the following:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To deploy your own ERC-20 token on Moonbase Alpha. You can do this by following our Remix tutorial while first pointing MetaMask to Moonbase Alpha</li> <li> <p>Ethers.js or the Ethereum library of your choice installed. You can install Ethers.js via npm:</p> <pre><code>npm install ethers\n</code></pre> </li> </ul>"},{"location":"builders/ethereum/json-rpc/pubsub/#subscribing-to-event-logs-in-moonbase-alpha","title":"Subscribe to Event Logs","text":"<p>Any contract that follows the ERC-20 token standard emits an event related to a token transfer, that is, <code>event Transfer(address indexed from, address indexed to, uint256 value)</code>. In this section, you'll learn how to subscribe to these events using the Ethers.js library.</p> <p>Use the following code snippet to set up a subscription to listen for token transfer events:</p> <pre><code>const { ethers } = require('ethers');\n\nconst provider = new ethers.WebSocketProvider(\n  'wss://wss.api.moonbase.moonbeam.network'\n);\n\nconst tokenAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = [\n  'event Transfer(address indexed from, address indexed to, uint256 value)',\n];\nconst iface = new ethers.Interface(abi);\nconst transferTopic = ethers.id('Transfer(address,address,uint256)');\n\nconst filter = {\n  address: tokenAddress,\n  topics: [transferTopic],\n};\n\nconst main = async () =&gt; {\n  console.log('\ud83d\udd54 Subscription set up. Waiting for new logs');\n\n  provider.on(filter, (log) =&gt; {\n    const parsed = iface.parseLog(log);\n\n    console.log({\n      from: parsed.args.from,\n      to: parsed.args.to,\n      value: parsed.args.value.toString(),\n      blockNumber: log.blockNumber,\n      txHash: log.transactionHash,\n    });\n  });\n};\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre> <p>Note</p> <p>Make sure to replace <code>'INSERT_CONTRACT_ADDRESS'</code> with the actual address of the ERC-20 token contract that you should have already deployed (as a prerequisite).</p> <p>In the provided code:</p> <ul> <li>A WebSocket provider is used to listen for the <code>Transfer</code> event and parse the log with the contract ABI</li> <li> <p>The listener filters for the <code>Transfer</code> event by signature, which can be calculated as follows:</p> <pre><code>EventSignature = keccak256(Transfer(address,address,uint256))\n</code></pre> <p>This translates to <code>0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</code> and is used as the first topic in the subscription filter.</p> </li> </ul> <p>If you do not provide any topics, you subscribe to all events emitted by the contract. More information about topics can be found in the Understanding event logs on the Ethereum blockchain Medium post.</p> <p>By executing this code, you'll establish a subscription to monitor ERC-20 token transfer events on Moonbeam. New events will be logged to the terminal as they occur.</p>  node contract-events.js 0x35547a6f7777444f35306f5353556271"},{"location":"builders/ethereum/json-rpc/pubsub/#understanding-event-logs","title":"Understanding Event Logs","text":"<p>To illustrate the process, assume that an ERC-20 token transfer has been sent with the following parameters:</p> <ul> <li>From address - <code>0x44236223aB4291b93EEd10E4B511B37a398DEE55</code></li> <li>To address - <code>0x8841701Dba3639B254D9CEe712E49D188A1e941e</code></li> <li>Value (tokens) - <code>1000000000000000000</code> (1 DEV in Wei)</li> </ul> <p>The event logs emitted by the transaction are as follows:</p>  node contract-events.js 0x35547a6f7777444f35306f5353556271 {   address: '0xCc17F1FAEAab9Fe70Dc2D616Ea768a4336f3c506',   blockHash: '0x12d1f37db14f8d4efa2540ecb63d7f8b95236bb11c405e58691a45070d2c7e7f',   blockNumber: 16736,   data: '0x0000000000000000000000000000000000000000000000000d0b6b3a7640000',   logIndex: 0,   removed: false,   topics: [     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',     '0x00000000000000000000000044236223ab4291b93eed10e4b511b37a398dee55',     '0x0000000000000000000000008841701dba3639b254d9cee712e49d188a1e941e'   ],   transactionHash: '0xd53891693a731e0bca3287adc6375d04fe3b6605d00b186a669c6bbc8d22e88d',   transactionIndex: 0,   transactionLogIndex: '0x0',   id: 'log_83c933b0' } <p>If you look at the <code>topics</code> array, there are a total of three topics present (in this order):</p> <ol> <li>The event signature of the <code>Transfer</code> event</li> <li>The <code>from</code> address</li> <li>The <code>to</code> address</li> </ol> <p>As there are a total of three topics (the maximum is four), this corresponds to the LOG3 opcode:</p> <p></p> <p>Indexed topics, such as the <code>from</code> and <code>to</code> addresses, are typically represented by 256-bit (64 hexadecimal character) values. If necessary, they are padded with zeros to reach the full length.</p> <p>Unindexed data, such as the value of tokens transferred, is not included in the <code>topics</code> array. Instead, it is returned within the logs' <code>data</code> field, encoded in bytes32/hex format. To decode it, you can use, for example, this Web3 Type Converter tool and verify that the <code>data</code> is 1 DEV token formatted in Wei.</p> <p>If the event returns multiple unindexed values, they will be appended one after the other in the same order the event emits them. Therefore, each value is obtained by deconstructing data into separate 32-byte (or 64-hex-character-long) pieces.</p>"},{"location":"builders/ethereum/json-rpc/pubsub/#using-wildcards-and-conditional-formatting","title":"Use Wildcards and Conditional Formatting","text":"<p>Using the same example as in the previous section, you can subscribe to Transfer events while filtering by specific senders with the following code:</p> <pre><code>const { ethers } = require('ethers');\n\nconst provider = new ethers.WebSocketProvider(\n  'wss://wss.api.moonbase.moonbeam.network'\n);\n\nconst tokenAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = [\n  'event Transfer(address indexed from, address indexed to, uint256 value)',\n];\nconst contract = new ethers.Contract(tokenAddress, abi, provider);\n\n// Listen for Transfer events where the \"from\" address matches either entry below\nconst fromAddresses = [\n  '0x44236223aB4291b93EEd10E4B511B37a398DEE55',\n  '0x8841701Dba3639B254D9CEe712E49D188A1e941e',\n];\n\nconst filter = contract.filters.Transfer(fromAddresses, null);\n\nconst main = async () =&gt; {\n  console.log('\ud83d\udd54 Subscription set up. Waiting for new logs');\n\n  contract.on(filter, (from, to, value, event) =&gt; {\n    console.log({\n      from,\n      to,\n      value: value.toString(),\n      blockNumber: event.blockNumber,\n      txHash: event.transactionHash,\n    });\n  });\n};\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre> <p>Here, the first indexed parameter (<code>from</code>) is filtered to the provided address list, while <code>to</code> is set to <code>null</code> to act as a wildcard. The contract filter handles topic formatting for you, so you don't need to manually pad the addresses.</p>  node contract-events.js 0x51583364703338703441507476516675 {   address: '0xCc17F1FAEAab9Fe70Dc2D616Ea768a4336f3c506',   blockHash: '0xc7fa1139a35fb7a634514907feeb771e6aac7717906922a8589f029f709dcaef',   blockNumber: 16739,   data: '0x0000000000000000000000000000000000000000000000000de0b6b3a7640000',   logIndex: 0,   removed: false,   topics: [     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',     '0x00000000000000000000000044236223ab4291b93eed10e4b511b37a398dee55',     '0x0000000000000000000000008841701dba3639b254d9cee712e49d188a1e941e'   ],   transactionHash: '0x84154ea6ee44a4ffc446acd17579966691105694ce370f01de09d3a9f1b9506',   transactionIndex: 0,   transactionLogIndex: '0x0',   id: 'log_188dbef1' } {   address: '0xCc17F1FAEAab9Fe70Dc2D616Ea768a4336f3c506',   blockHash: '0xf21ded1bc724d2be74bc97c2045e31754d5326f3964796d62a1cba3e1d06203',   blockNumber: 16740,   data: '0x0000000000000000000000000000000000000000000000000de0b6b3a7640000',   logIndex: 0,   removed: false,   topics: [     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',     '0x0000000000000000000000008841701dba3639b254d9cee712e49d188a1e941e',     '0x00000000000000000000000044236223ab4291b93eed10e4b511b37a398dee55'   ],   transactionHash: '0x091b736bd31457a9b0725a98926dc3ebfb0608e71197c10d4d9ccb80de6d9ac3',   transactionIndex: 0,   transactionLogIndex: '0x0',   id: 'log_401c7925' } <p>As shown, after you provided the two addresses with conditional formatting, you should have received two logs with the same subscription. Events emitted by transactions from different addresses will not throw any logs to this subscription.</p> <p>This example showed how you could subscribe to just the event logs of a specific contract, but the same approach applies to other subscription types covered in the following sections.</p>"},{"location":"builders/ethereum/json-rpc/pubsub/#subscribe-to-incoming-pending-transactions","title":"Subscribe to Incoming Pending Transactions","text":"<p>To subscribe to pending transactions with Ethers.js, you can use a WebSocket provider and the <code>provider.on('pending')</code> event. The transaction hash of the pending transactions is returned, and you can optionally fetch full transaction details with <code>provider.getTransaction(hash)</code>.</p>  node pending-tx.js 0x3350757676747651354e4553724e7269 0x5e3870e2c38274f4344cb86f3719dad84193b610a13b7e60c7ee65868b7ebc9a 0x54a28da6915df1ec83af4aafeab57364bbf4239d5ba71b596faabc76ba355eab <p>You can try this by sending a transaction and verifying that the transaction hash returned by the subscription is the same one returned by the development tool or wallet you are using.</p>"},{"location":"builders/ethereum/json-rpc/pubsub/#subscribe-to-incoming-block-headers","title":"Subscribe to Incoming Block Headers","text":"<p>You can also subscribe to new block headers using <code>provider.on('block')</code>, then fetch the block with <code>provider.getBlock(blockNumber)</code>. This subscription provides incoming block headers and can be used to track changes in the blockchain.</p>  node block-headers.js 0x6472456d30776b636c615a317158514e {   author: '0x0000000000000000000000000000000000000000',   difficulty: '0',   extraData: '0x',   gasLimit: 0,   gasUsed: 0,   hash: '0x1a28a9a7a176ed0d627f1bc521bda4eaca1e8186bf6642f089578067b713da43',   logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',   miner: '0x0000000000000000000000000000000000000000',   number: 16756,   parentHash: '0x89401a45d6226a5eb509fd3abfd90cb74aa5d7b5f747ef2506013d1afa36a418',   receiptsRoot: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',   sealFields: [     '0x0000000000000000000000000000000000000000000000000000000000000000',     '0x0000000000000000'   ],   sha3Uncles: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',   size: 509,   stateRoot: '0x92f3417ed90a81fecb2587fd820c1479f88f27228b8f508dfde601061d14371d',   timestamp: 1607710710159,   transactionsRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421' } <p>Note that only one block header is shown in the image. These messages are displayed for every block produced so they can quickly fill up the terminal.</p>"},{"location":"builders/ethereum/json-rpc/pubsub/#check-if-a-node-is-synchronized-with-the-network","title":"Check If a Node Is Synchronized with the Network","text":"<p>With pubsub, checking whether a particular node is currently synchronizing with the network is also possible. You can call the <code>eth_subscribe</code> RPC with <code>syncing</code> using your preferred library's low-level WebSocket request helper. This subscription will either return a boolean when <code>syncing</code> is false or an object describing the syncing progress when <code>syncing</code> is true, as seen below.</p>  node syncing.js 0x3252615570630563274436770446371 {   syncing: true,   startingBlock: 120237,   currentBlock: 146952,   highestBlock: 2553484 } <p>Note</p> <p>The pubsub implementation in Frontier is still in active development. This current version allows users to subscribe to specific event types, but there may still be some limitations.</p>"},{"location":"builders/ethereum/libraries/ethersjs/","title":"Ethers.js JavaScript Library","text":""},{"location":"builders/ethereum/libraries/ethersjs/#introduction","title":"Introduction","text":"<p>The Ethers.js library provides a set of tools to interact with Ethereum Nodes with JavaScript, similar to Web3.js. Moonbeam has an Ethereum-like API available that is fully compatible with Ethereum-style JSON-RPC invocations. Therefore, developers can leverage this compatibility and use the Ethers.js library to interact with a Moonbeam node as if they were doing so on Ethereum. For more information on Ethers.js, check their documentation site.</p> <p>In this guide, you'll learn how to use the Ethers.js library to send a transaction and deploy a contract on Moonbase Alpha. This guide can be adapted for Moonbeam, Moonriver, or a Moonbeam development node.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#install-ethersjs","title":"Installing Ethers.js","text":"<p>To get started, you'll need to start a basic JavaScript project. First, create a directory to store all of the files you'll be creating throughout this guide and initialize the project with the following command:</p> <pre><code>mkdir ethers-examples &amp;&amp; cd ethers-examples &amp;&amp; npm init --y\n</code></pre> <p>For this guide, you'll need to install the Ethers.js library and the Solidity compiler. To install both NPM packages, you can run the following command:</p> npmyarn <pre><code>npm install ethers solc@0.8.30\n</code></pre> <pre><code>yarn add ethers solc@0.8.30\n</code></pre>"},{"location":"builders/ethereum/libraries/ethersjs/#setting-up-the-ethers-provider","title":"Setting up the Ethers Provider","text":"<p>Throughout this guide, you'll be creating a bunch of scripts that provide different functionality such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts you'll need to create an Ethers provider to interact with the network.</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>To create a provider, you can take the following steps:</p> <ol> <li>Import the <code>ethers</code> library</li> <li>Define the <code>providerRPC</code> object, which can include the network configurations for any of the networks you want to send a transaction on. You'll include the <code>name</code>, <code>rpc</code>, and <code>chainId</code> for each network</li> <li>Create the <code>provider</code> using the <code>ethers.JsonRpcProvider</code> method</li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>// 1. Import ethers\nconst ethers = require('ethers');\n\n// 2. Define network configurations\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT', // Insert your RPC URL here\n    chainId: 1284, // 0x504 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n</code></pre> <pre><code>// 1. Import ethers\nconst ethers = require('ethers');\n\n// 2. Define network configurations\nconst providerRPC = {\n  moonriver: {\n    name: 'moonriver',\n    rpc: 'INSERT_RPC_API_ENDPOINT', // Insert your RPC URL here\n    chainId: 1285, // 0x505 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonriver.rpc, {\n  chainId: providerRPC.moonriver.chainId,\n  name: providerRPC.moonriver.name,\n});\n</code></pre> <pre><code>// 1. Import ethers\nconst ethers = require('ethers');\n\n// 2. Define network configurations\nconst providerRPC = {\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287, // 0x507 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n});\n</code></pre> <pre><code>// 1. Import ethers\nconst ethers = require('ethers');\n\n// 2. Define network configurations\nconst providerRPC = {\n  dev: {\n    name: 'moonbeam-development',\n    rpc: 'http://127.0.0.1:9944',\n    chainId: 1281, // 0x501 in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.dev.rpc, {\n  chainId: providerRPC.dev.chainId,\n  name: providerRPC.dev.name,\n});\n</code></pre> <p>Save this code snippet as you'll need it for the scripts that are used in the following sections.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#send-a-transaction","title":"Send a Transaction","text":"<p>During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.</p> <p>You can also use the balance script to check the account balances after the transaction has been sent.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#check-balances-script","title":"Check Balances Script","text":"<p>You'll only need one file to check the balances of both addresses before and after the transaction is sent.  To get started, you can create a <code>balances.js</code> file by running:</p> <pre><code>touch balances.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Ethers provider</li> <li>Define the <code>addressFrom</code> and <code>addressTo</code> variables</li> <li>Create the asynchronous <code>balances</code> function which wraps the <code>provider.getBalance</code> method</li> <li>Use the <code>provider.getBalance</code> function to fetch the balances for the <code>addressFrom</code> and <code>addressTo</code> addresses. You can also leverage the <code>ethers.formatEther</code> function to transform the balance into a more readable number in ETH</li> <li>Lastly, run the <code>balances</code> function</li> </ol> <pre><code>// 1. Add the Ethers provider logic here:\n// {...}\n\n// 2. Create address variables\nconst addressFrom = 'INSERT_FROM_ADDRESS';\nconst addressTo = 'INSERT_TO_ADDRESS';\n\n// 3. Create balances function\nconst balances = async () =&gt; {\n  // 4. Fetch balances\n  const balanceFrom = ethers.formatEther(await provider.getBalance(addressFrom));\n  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} DEV`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} DEV`);\n};\n\n// 5. Call the balances function\nbalances();\n</code></pre> View the complete script <pre><code>// Import ethers\nconst ethers = require('ethers');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Define addresses\nconst addressFrom = 'INSERT_FROM_ADDRESS';\nconst addressTo = 'INSERT_TO_ADDRESS';\n\n// Create balances function\nconst balances = async () =&gt; {\n  // Fetch balances\n  const balanceFrom = ethers.formatEther(\n    await provider.getBalance(addressFrom)\n  );\n  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} DEV`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} DEV`);\n};\n\n// Call the balances function\nbalances();\n</code></pre> <p>To run the script and fetch the account balances, you can run the following command:</p> <pre><code>node balances.js\n</code></pre> <p>If successful, the balances for the origin and receiving address will be displayed in your terminal in DEV.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#send-transaction-script","title":"Send Transaction Script","text":"<p>You'll only need one file for executing a transaction between accounts. For this example, you'll be transferring 1 DEV token from an origin address (from which you hold the private key) to another address. To get started, you can create a <code>transaction.js</code> file by running:</p> <pre><code>touch transaction.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Ethers provider</li> <li>Define the <code>privateKey</code> and the <code>addressTo</code> variables. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create a wallet using the <code>privateKey</code> and <code>provider</code> from the previous steps. The wallet instance is used to sign transactions</li> <li>Create the asynchronous <code>send</code> function which wraps the transaction object and the <code>wallet.sendTransaction</code> method</li> <li>Create the transaction object which only requires the recipient's address and the amount to send. Note that <code>ethers.parseEther</code> can be used, which handles the necessary unit conversions from Ether to Wei - similar to using <code>ethers.parseUnits(value, 'ether')</code></li> <li>Send the transaction using the <code>wallet.sendTransaction</code> method and then use <code>await</code> to wait until the transaction is processed and the transaction receipt is returned</li> <li>Lastly, run the <code>send</code> function</li> </ol> <pre><code>// 1. Add the Ethers provider logic here:\n// {...}\n\n// 2. Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst addressTo = 'INSERT_TO_ADDRESS';\n\n// 3. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 4. Create send function\nconst send = async () =&gt; {\n  console.log(`Attempting to send transaction from ${wallet.address} to ${addressTo}`);\n\n  // 5. Create tx object\n  const tx = {\n    to: addressTo,\n    value: ethers.parseEther('1'),\n  };\n\n  // 6. Sign and send tx - wait for receipt\n  const createReceipt = await wallet.sendTransaction(tx);\n  await createReceipt.wait();\n  console.log(`Transaction successful with hash: ${createReceipt.hash}`);\n};\n\n// 7. Call the send function\nsend();\n</code></pre> View the complete script <pre><code>// Import ethers\nconst ethers = require('ethers');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Define accounts and wallet\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst addressTo = 'INSERT_TO_ADDRESS';\nconst wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${wallet.address} to ${addressTo}`\n  );\n\n  // Create transaction\n  const tx = {\n    to: addressTo,\n    value: ethers.parseEther('1'),\n  };\n\n  // Send transaction and get hash\n  const createReceipt = await wallet.sendTransaction(tx);\n  await createReceipt.wait();\n  console.log(`Transaction successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the send function\nsend();\n</code></pre> <p>To run the script, you can run the following command in your terminal:</p> <pre><code>node transaction.js\n</code></pre> <p>If the transaction was successful, in your terminal you'll see the transaction hash has been printed out.</p> <p>You can also use the <code>balances.js</code> script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:</p> node balances.js The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3604.673685275447543445 DEV The balance of 0xFFA0352d300cdd8aCdA5c947D87CbCc3f0B3485A is: 0 DEV node transaction.js Attempting to send transaction from 0x3B939FeaD1557C741Ff06492FD0127bd287A421e to 0xFFA0352d300cdd8aCdA5c947D87CbCc3f0B3485A Transaction successful with hash: 0x01e42c627fe79b1d5649a64d39fceec34aba3904e37d768e74ec71fcd62b897f node balances.js The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3603.673682650447543445 DEV The balance of 0xFFA0352d300cdd8aCdA5c947D87CbCc3f0B3485A is: 1.0 DEV"},{"location":"builders/ethereum/libraries/ethersjs/#deploy-a-contract","title":"Deploy a Contract","text":"<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (the default is <code>0</code>). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only and does not handle values wrapping around.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#compile-contract-script","title":"Compile Contract Script","text":"<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.js</code> file by running:</p> <pre><code>touch compile.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>fs</code> and <code>solc</code> packages</li> <li>Using the <code>fs.readFileSync</code> function, you'll read and save the file contents of <code>Incrementer.sol</code> to <code>source</code></li> <li>Build the <code>input</code> object for the Solidity compiler by specifying the <code>language</code>, <code>sources</code>, and <code>settings</code> to be used</li> <li>Using the <code>input</code> object, you can compile the contract using <code>solc.compile</code></li> <li>Extract the compiled contract file and export it to be used in the deployment script</li> </ol> <pre><code>// 1. Import packages\nconst fs = require('fs');\nconst solc = require('solc');\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n   language: 'Solidity',\n   sources: {\n      'Incrementer.sol': {\n         content: source,\n      },\n   },\n   settings: {\n      outputSelection: {\n         '*': {\n            '*': ['*'],\n         },\n      },\n   },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nmodule.exports = contractFile;\n</code></pre>"},{"location":"builders/ethereum/libraries/ethersjs/#deploy-contract-script","title":"Deploy Contract Script","text":"<p>With the script for compiling the <code>Incrementer.sol</code> contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called <code>deploy.js</code>:</p> <pre><code>touch deploy.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the contract file from <code>compile.js</code></li> <li>Set up the Ethers provider</li> <li>Define the <code>privateKey</code> for the origin account. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create a wallet using the <code>privateKey</code> and <code>provider</code> from the previous steps. The wallet instance is used to sign transactions</li> <li>Load the contract <code>bytecode</code> and <code>abi</code> for the compiled contract</li> <li>Create a contract instance with signer using the <code>ethers.ContractFactory</code> function, providing the <code>abi</code>, <code>bytecode</code>, and <code>wallet</code> as parameters</li> <li>Create the asynchronous <code>deploy</code> function that will be used to deploy the contract</li> <li>Within the <code>deploy</code> function, use the <code>incrementer</code> contract instance to call <code>deploy</code> and pass in the initial value. For this example, you can set the initial value to <code>5</code>. This will send the transaction for contract deployment. To wait for a transaction receipt you can use the <code>deployed</code> method of the contract deployment transaction</li> <li>Lastly, run the <code>deploy</code> function</li> </ol> <pre><code>// 1. Import the contract file\nconst contractFile = require('./compile');\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\n\n// 4. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Load contract information\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// 6. Create contract instance with signer\nconst incrementer = new ethers.ContractFactory(abi, bytecode, wallet);\n\n// 7. Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${wallet.address}`);\n\n  // 8. Send tx (initial value set to 5) and wait for receipt\n  const contract = await incrementer.deploy(5);\n  const txReceipt = await contract.deploymentTransaction().wait();\n\n  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);\n};\n\n// 9. Call the deploy function\ndeploy();\n</code></pre> View the complete script <pre><code>// Import ethers and compile\nconst ethers = require('ethers');\nconst contractFile = require('./compile');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Define accounts and wallet\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Load contract info\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// Create contract instance with signer\nconst incrementer = new ethers.ContractFactory(abi, bytecode, wallet);\n\n// Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${wallet.address}`);\n\n  // Send tx (initial value set to 5) and wait for receipt\n  const contract = await incrementer.deploy(5);\n  const txReceipt = await contract.deploymentTransaction().wait();\n\n  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);\n};\n\n// Call the deploy function\ndeploy();\n</code></pre> <p>To run the script, you can enter the following command into your terminal:</p> <pre><code>node deploy.js\n</code></pre> <p>If successful, the contract's address will be displayed in the terminal.</p> node deploy.js Attempting to deploy from account: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Contract deployed at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A"},{"location":"builders/ethereum/libraries/ethersjs/#read-contract-data","title":"Read Contract Data (Call Methods)","text":"<p>Call methods are the type of interaction that don't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.</p> <p>To get started, you can create a file and name it <code>get.js</code>:</p> <pre><code>touch get.js\n</code></pre> <p>Then you can take the following steps to create the script:</p> <ol> <li>Import the <code>abi</code> from the <code>compile.js</code> file</li> <li>Set up the Ethers provider</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract</li> <li>Create an instance of the contract using the <code>ethers.Contract</code> function and passing in the <code>contractAddress</code>, <code>abi</code>, and <code>provider</code></li> <li>Create the asynchronous <code>get</code> function</li> <li>Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you will call the <code>number</code> method which doesn't require any inputs. You can use <code>await</code> which will return the value requested once the request promise resolves</li> <li>Lastly, call the <code>get</code> function</li> </ol> <pre><code>// 1. Import the ABI\nconst { abi } = require('./compile');\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Contract address variable\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create contract instance\nconst incrementer = new ethers.Contract(contractAddress, abi, provider);\n\n// 5. Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // 6. Call contract \n  const data = await incrementer.number();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 7. Call get function\nget();\n</code></pre> View the complete script <pre><code>// Import ethers and compile\nconst ethers = require('ethers');\nconst { abi } = require('./compile');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Contract address variable\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create contract instance\nconst incrementer = new ethers.Contract(contractAddress, abi, provider);\n\n// Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // Call contract\n  const data = await incrementer.number();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// Call get function\nget();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node get.js\n</code></pre> <p>If successful, the value will be displayed in the terminal.</p>"},{"location":"builders/ethereum/libraries/ethersjs/#interact-with-contract","title":"Interact with Contract (Send Methods)","text":"<p>Send methods are the type of interaction that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them <code>increment.js</code> and <code>reset.js</code>:</p> <pre><code>touch increment.js reset.js\n</code></pre> <p>Open the <code>increment.js</code> file and take the following steps to create the script:</p> <ol> <li>Import the <code>abi</code> from the <code>compile.js</code> file</li> <li>Set up the Ethers provider</li> <li>Define the <code>privateKey</code> for the origin account, the <code>contractAddress</code> of the deployed contract, and the <code>_value</code> to increment by. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create a wallet using the <code>privateKey</code> and <code>provider</code> from the previous steps. The wallet instance is used to sign transactions</li> <li>Create an instance of the contract using the <code>ethers.Contract</code> function and passing in the <code>contractAddress</code>, <code>abi</code>, and <code>provider</code></li> <li>Create the asynchronous <code>increment</code> function</li> <li>Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you will call the <code>increment</code> method which requires the value to increment by as an input. You can use <code>await</code> which will return the value requested once the request promise resolves</li> <li>Lastly, call the <code>increment</code> function</li> </ol> <pre><code>// 1. Import the contract ABI\nconst { abi } = require('./compile');\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// 4. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Create contract instance with signer\nconst incrementer = new ethers.Contract(contractAddress, abi, wallet);\n\n// 6. Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // 7. Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.increment(_value);\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// 8. Call the increment function\nincrement();\n</code></pre> View the complete script <pre><code>// Import ethers and compile\nconst ethers = require('ethers');\nconst { abi } = require('./compile');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create contract instance with signer\nconst incrementer = new ethers.Contract(contractAddress, abi, wallet);\n\n// Create reset function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.increment(_value);\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the reset function\nincrement();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node increment.js\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.js</code> script alongside the <code>increment.js</code> script to make sure that value is changing as expected:</p> node get.js Making a call to contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A The current number stored is: 5 node increment.js Calling the increment by 3 function in contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A Tx successful with hash: 0xc7fe935db03cfacf56c5649cd79a566d1a7b68417f904f0095a1b1c203875bf2 node get.js Making a call to contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A The current number stored is: 8 <p>Next you can open the <code>reset.js</code> file and take the following steps to create the script:</p> <ol> <li>Import the <code>abi</code> from the <code>compile.js</code> file</li> <li>Set up the Ethers provider</li> <li>Define the <code>privateKey</code> for the origin account and the <code>contractAddress</code> of the deployed contract. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create a wallet using the <code>privateKey</code> and <code>provider</code> from the previous steps. The wallet instance is used to sign transactions</li> <li>Create an instance of the contract using the <code>ethers.Contract</code> function and passing in the <code>contractAddress</code>, <code>abi</code>, and <code>provider</code></li> <li>Create the asynchronous <code>reset</code> function</li> <li>Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you will call the <code>reset</code> method which doesn't require any inputs. You can use <code>await</code> which will return the value requested once the request promise resolves</li> <li>Lastly, call the <code>reset</code> function</li> </ol> <pre><code>// 1. Import the contract ABI\nconst { abi } = require('./compile');\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Create contract instance with signer\nconst incrementer = new ethers.Contract(contractAddress, abi, wallet);\n\n// 6. Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // 7. sign and send tx and wait for receipt\n  const createReceipt = await incrementer.reset();\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// 8. Call the reset function\nreset();\n</code></pre> View the complete script <pre><code>// Import ethers and compile\nconst ethers = require('ethers');\nconst { abi } = require('./compile');\n\n// Define network configurations\nconst providerRPC = {\n  development: {\n    name: 'moonbeam-development',\n    rpc: 'http://localhost:9944',\n    chainId: 1281,\n  },\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network',\n    chainId: 1287,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n}); // Change to correct network\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create contract instance with signer\nconst incrementer = new ethers.Contract(contractAddress, abi, wallet);\n\n// Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.reset();\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the reset function\nreset();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node reset.js\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.js</code> script alongside the <code>reset.js</code> script to make sure that value is changing as expected:</p> node get.js Making a call to contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A The current number stored is: 8 node reset.js Calling the reset function in contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A Tx successful with hash: 0xc452d21d8c2be6b81aadab7414103d68149c94a6399149ab8b79a58f0a3b5db7 node get.js Making a call to contract at address: 0x2B9c71fc2730B7353Dd3865ae26881Fa38FE598A The current number stored is: 0    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/libraries/viem/","title":"viem TypeScript Ethereum Library","text":""},{"location":"builders/ethereum/libraries/viem/#introduction","title":"Introduction","text":"<p>viem is a modular TypeScript library that allows developers to interact with abstractions over the JSON-RPC API, making it easy to interact with Ethereum nodes. Since Moonbeam has an Ethereum-like API available that is fully compatible with Ethereum-style JSON RPC invocations, developers can leverage this compatibility to interact with Moonbeam nodes. For more information on viem, check out their documentation site.</p> <p>In this guide, you'll learn how to use viem to send a transaction and deploy a contract on the Moonbase Alpha TestNet. This guide can be adapted for Moonbeam, Moonriver, or a Moonbeam development node.</p>"},{"location":"builders/ethereum/libraries/viem/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"},{"location":"builders/ethereum/libraries/viem/#installing-viem","title":"Installing viem","text":"<p>To get started, you'll need to create a basic TypeScript project. First, create a directory to store all of the files you'll be creating throughout this guide, and initialize the project with the following command:</p> <pre><code>mkdir viem-examples &amp;&amp; cd viem-examples &amp;&amp; npm init --y\n</code></pre> <p>For this guide, you'll need to install the viem library and the Solidity compiler. To install both packages, you can run the following command:</p> npmyarn <pre><code>npm install typescript ts-node viem solc@0.8.30\n</code></pre> <pre><code>yarn add typescript ts-node viem solc@0.8.30\n</code></pre> <p>You can create a TypeScript configuration file by running:</p> <pre><code>npx tsc --init\n</code></pre> <p>Note</p> <p>This tutorial was created using Node.js v18.18.0.</p>"},{"location":"builders/ethereum/libraries/viem/#setting-up-a-viem-provider","title":"Set Up a viem Client (Provider)","text":"<p>Throughout this guide, you'll be creating a bunch of scripts that provide different functionality, such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts, you'll need to create a viem client to interact with the network.</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>You can create a viem client for reading chain data, like balances or contract data, using the <code>createPublicClient</code> function, or you can create a viem client for writing chain data, like sending transactions, using the <code>createWalletClient</code> function.</p>"},{"location":"builders/ethereum/libraries/viem/#for-reading-chain-data","title":"For Reading Chain Data","text":"<p>To create a client for reading chain data, you can take the following steps:</p> <ol> <li>Import the <code>createPublicClient</code> and <code>http</code> functions from <code>viem</code> and the network you want to interact with from <code>viem/chains</code>. The chain can be any of the following: <code>moonbeam</code>, <code>moonriver</code>, or <code>moonbaseAlpha</code></li> <li>Create the <code>client</code> using the <code>createPublicClient</code> function and pass in the network and the HTTP RPC endpoint</li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>import { createPublicClient, http } from 'viem';\nimport { moonbeam } from 'viem/chains';\n\nconst rpcUrl = 'INSERT_RPC_API_ENDPOINT'\nconst publicClient = createPublicClient({\n  chain: moonbeam,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createPublicClient, http } from 'viem';\nimport { moonriver } from 'viem/chains';\n\nconst rpcUrl = 'INSERT_RPC_API_ENDPOINT'\nconst publicClient = createPublicClient({\n  chain: moonriver,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createPublicClient, http } from 'viem';\nimport { moonbaseAlpha } from 'viem/chains';\n\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network'\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createPublicClient, http } from 'viem';\nimport { moonbeamDev } from 'viem/chains';\n\nconst rpcUrl = 'http://127.0.0.1:9944'\nconst publicClient = createPublicClient({\n  chain: moonbeamDev,\n  transport: http(rpcUrl),\n})\n</code></pre>"},{"location":"builders/ethereum/libraries/viem/#for-writing-chain-data","title":"For Writing Chain Data","text":"<p>To create a client for writing chain data, you can take the following steps:</p> <ol> <li>Import the <code>createWalletClient</code> and <code>http</code> functions from <code>viem</code>, the <code>privateKeyToAccount</code> function for loading your accounts via their private keys, and the network you want to interact with from <code>viem/chains</code>. The chain can be any of the following: <code>moonbeam</code>, <code>moonriver</code>, or <code>moonbaseAlpha</code></li> <li>Create your account using the <code>privateKeyToAccount</code> function</li> <li>Create the <code>client</code> using the <code>createWalletClient</code> function and pass in the account, network, and the HTTP RPC endpoint</li> </ol> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a TypeScript file.</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>import { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbeam } from 'viem/chains';\n\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'INSERT_RPC_API_ENDPOINT'\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbeam,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonriver } from 'viem/chains';\n\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'INSERT_RPC_API_ENDPOINT'\nconst walletClient = createWalletClient({\n  account,\n  chain: moonriver,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbaseAlpha } from 'viem/chains';\n\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network'\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n</code></pre> <pre><code>import { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbeamDev } from 'viem/chains';\n\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'http://127.0.0.1:9944'\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbeamDev,\n  transport: http(rpcUrl),\n});\n</code></pre> <p>Note</p> <p>To interact with browser-based wallets, you can use the following code to create an account:</p> <pre><code>const [account] = await window.ethereum.request({\n  method: 'eth_requestAccounts',\n});\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbeam,\n  transport: custom(window.ethereum),\n});\n</code></pre>"},{"location":"builders/ethereum/libraries/viem/#send-transaction","title":"Send a Transaction","text":"<p>During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.</p> <p>You can also use the balance script to check the account balances after the transaction has been sent.</p>"},{"location":"builders/ethereum/libraries/viem/#check-balances-script","title":"Check Balances Script","text":"<p>You'll only need one file to check the balances of both addresses before and after the transaction is sent. To get started, you can create a <code>balances.ts</code> file by running:</p> <pre><code>touch balances.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Update your imports to include the <code>createPublicClient</code>, <code>http</code>, and <code>formatEther</code> functions from <code>viem</code> and the network you want to interact with from <code>viem/chains</code></li> <li>Set up a public viem client, which can be used for reading chain data, such as account balances</li> <li>Define the <code>addressFrom</code> and <code>addressTo</code> variables</li> <li>Create the asynchronous <code>balances</code> function that wraps the <code>publicClient.getBalance</code> method</li> <li>Use the <code>publicClient.getBalance</code> function to fetch the balances for the <code>addressFrom</code> and <code>addressTo</code> addresses. You can also leverage the <code>formatEther</code> function to transform the balance into a more readable number (in GLMR, MOVR, or DEV)</li> <li>Lastly, run the <code>balances</code> function</li> </ol> <pre><code>// 1. Imports\nimport { createPublicClient, http, formatEther } from 'viem';\nimport { moonbaseAlpha } from 'viem/chains';\n\n// 2. Create a public client for reading chain data\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network';\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 3. Create address variables\nconst addressFrom = 'INSERT_FROM_ADDRESS';\nconst addressTo = 'INSERT_TO_ADDRESS';\n\n// 4. Create balances function\nconst balances = async () =&gt; {\n  // 5. Fetch balances\n  const balanceFrom = formatEther(\n    await publicClient.getBalance({ address: addressFrom })\n  );\n  const balanceTo = formatEther(\n    await publicClient.getBalance({ address: addressTo })\n  );\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} DEV`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} DEV`);\n};\n\n// 6. Call the balances function\nbalances();\n</code></pre> <p>To run the script and fetch the account balances, you can run the following command:</p> <pre><code>npx ts-node balances.ts\n</code></pre> <p>If successful, the balances for the origin and receiving address will be displayed in your terminal in DEV.</p> npx ts-node balances.ts The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3601.72 DEV The balance of 0x78F34038c82638E0563b974246D421154C26b004 is: 0 DEV"},{"location":"builders/ethereum/libraries/viem/#send-transaction-script","title":"Send Transaction Script","text":"<p>You'll only need one file to execute a transaction between accounts. For this example, you'll be transferring 1 DEV token from an origin address (from which you hold the private key) to another address. To get started, you can create a <code>transaction.ts</code> file by running:</p> <pre><code>touch transaction.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Update your imports to include the <code>createWalletClient</code>, <code>http</code>, and <code>parseEther</code> functions from <code>viem</code>, the <code>privateKeyToAccount</code> function from <code>viem/accounts</code>, and the network you want to interact with from <code>viem/chains</code></li> <li>Set up a viem wallet client for writing chain data, which can be used along with your private key to send transactions. Note: This is for example purposes only. Never store your private keys in a TypeScript file</li> <li>Set up a public viem client for reading chain data, which will be used to wait for the transaction receipt</li> <li>Define the <code>addressTo</code> variable</li> <li>Create the asynchronous <code>send</code> function, which wraps the transaction object and the <code>walletClient.sendTransaction</code> method</li> <li>Use the <code>walletClient.sendTransaction</code> function to sign and send the transaction. You'll need to pass in the transaction object, which only requires the recipient's address and the amount to send. Note that <code>parseEther</code> can be used, which handles the necessary unit conversions from Ether to Wei, similar to using <code>parseUnits(value, decimals)</code>. Use <code>await</code> to wait until the transaction is processed and the transaction hash is returned</li> <li>Use the <code>publicClient.waitForTransactionReceipt</code> function to wait for the transaction receipt, signaling that the transaction has been completed. This is particularly helpful if you need the transaction receipt or if you're running the <code>balances.ts</code> script directly after this one to check if the balances have been updated as expected</li> <li>Lastly, run the <code>send</code> function</li> </ol> <pre><code>// 1. Imports\nimport { createPublicClient, createWalletClient, http, parseEther } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbaseAlpha } from 'viem/chains';\n\n// 2. Create a wallet client for writing chain data\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network';\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 3. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 4. Create to address variable\nconst addressTo = 'INSERT_ADDRESS';\n\n// 5. Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${account.address} to ${addressTo}`\n  );\n\n  // 6. Sign and send tx\n  const hash = await walletClient.sendTransaction({\n    to: addressTo,\n    value: parseEther('1'),\n  });\n\n  // 7. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Transaction successful with hash: ${hash}`);\n};\n\n// 8. Call the send function\nsend();\n</code></pre> <p>To run the script, you can run the following command in your terminal:</p> <pre><code>npx ts-node transaction.ts\n</code></pre> <p>If the transaction was successful, in your terminal you'll see the transaction hash has been printed out.</p> <p>Note</p> <p>Viem requires that you prepend your private key with <code>0x</code>. Many wallets omit this <code>0x</code>, so verify you've included it as you replace <code>INSERT_PRIVATE_KEY</code>.</p> <p>You can also use the <code>balances.ts</code> script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:</p> npx ts-node balances.ts The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3601.72 DEV The balance of 0x78F34038c82638E0563b974246D421154C26b004 is: 0 DEV npx ts-node transaction.ts Attempting to send transaction from 0x3B939FeaD1557C741Ff06492FD0127bd287A421e to 0x78F34038c82638E0563b974246D421154C26b004 Transaction successful with hash: 0xc482d907b2ae4ca1202c6cc5b486694b8439a9853caad9c2cdafec39defa1968 npx ts-node balances.ts The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3600.72 DEV The balance of 0x78F34038c82638E0563b974246D421154C26b004 is: 1 DEV"},{"location":"builders/ethereum/libraries/viem/#deploy-contract","title":"Deploy a Contract","text":"<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (the default is <code>0</code>). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only and does not handle values wrapping around.</p>"},{"location":"builders/ethereum/libraries/viem/#compile-contract-script","title":"Compile Contract Script","text":"<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.ts</code> file by running:</p> <pre><code>touch compile.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>fs</code> and <code>solc</code> packages</li> <li>Using the <code>fs.readFileSync</code> function, you'll read and save the file contents of <code>Incrementer.sol</code> to <code>source</code></li> <li>Build the <code>input</code> object for the Solidity compiler by specifying the <code>language</code>, <code>sources</code>, and <code>settings</code> to be used</li> <li>Using the <code>input</code> object, you can compile the contract using <code>solc.compile</code></li> <li>Extract the compiled contract file and export it to be used in the deployment script</li> </ol> <pre><code>// 1. Import packages\nconst fs = require('fs');\nconst solc = require('solc');\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n   language: 'Solidity',\n   sources: {\n      'Incrementer.sol': {\n         content: source,\n      },\n   },\n   settings: {\n      outputSelection: {\n         '*': {\n            '*': ['*'],\n         },\n      },\n   },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nexport default contractFile;\n</code></pre>"},{"location":"builders/ethereum/libraries/viem/#deploy-contract-script","title":"Deploy Contract Script","text":"<p>With the script for compiling the <code>Incrementer.sol</code> contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called <code>deploy.ts</code>:</p> <pre><code>touch deploy.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Update your imports to include the <code>createPublicClient</code>, <code>createWalletClient</code>, and <code>http</code> functions from <code>viem</code>, the <code>privateKeyToAccount</code> function from <code>viem/accounts</code>, the network you want to interact with from <code>viem/chains</code>, and the <code>contractFile</code> from the <code>compile.ts</code> file you created in the Compile Contract Script section</li> <li>Set up a viem wallet client for writing chain data, which will be used along with your private key to deploy the <code>Incrementer</code> contract. Note: This is for example purposes only. Never store your private keys in a TypeScript file</li> <li>Set up a public viem client for reading chain data, which will be used to read the transaction receipt for the deployment</li> <li>Load the contract <code>bytecode</code> and <code>abi</code> for the compiled contract</li> <li>Create the asynchronous <code>deploy</code> function that will be used to deploy the contract via the <code>walletClient.deployContract</code> method</li> <li>Use the <code>walletClient.deployContract</code> function to sign and send the transaction. You'll need to pass in the contract's ABI and bytecode, the account to deploy the transaction from, and the initial value for the incrementer. Use <code>await</code> to wait until the transaction is processed and the transaction hash is returned</li> <li>Use the <code>publicClient.readContract</code> function to get the transaction receipt for the deployment. Use <code>await</code> to wait until the transaction is processed and the contract address is returned</li> <li>Lastly, run the <code>deploy</code> function</li> </ol> <pre><code>// 1. Update imports\nimport { createPublicClient, createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbaseAlpha } from 'viem/chains';\nimport contractFile from './compile';\n\n// 2. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network';\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n// 3. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 4. Load contract information\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\nconst _initialNumber = 5;\n\n// 5. Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${account.address}`);\n\n  // 6. Send tx (initial value set to 5)\n  const contract = await walletClient.deployContract({\n    abi,\n    account,\n    bytecode,\n    args: [_initialNumber],\n  });\n\n  // 7. Get the transaction receipt for the deployment\n  const transaction = await publicClient.waitForTransactionReceipt({\n    hash: contract,\n  });\n\n  console.log(`Contract deployed at address: ${transaction.contractAddress}`);\n};\n\n// 8. Call the deploy function\ndeploy();\n</code></pre> <p>To run the script, you can enter the following command into your terminal:</p> <pre><code>npx ts-node deploy.ts\n</code></pre> <p>If successful, the contract's address will be displayed in the terminal.</p> npx ts-node deploy.ts Attempting to deploy from account: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Contract deployed at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9"},{"location":"builders/ethereum/libraries/viem/#read-contract-data","title":"Read Contract Data (Call Methods)","text":"<p>Call methods are the type of interaction that doesn't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.</p> <p>To get started, you can create a file and name it <code>get.ts</code>:</p> <pre><code>touch get.ts\n</code></pre> <p>Then you can take the following steps to create the script:</p> <ol> <li>Update your imports to include the <code>createPublicClient</code> and <code>http</code> functions from <code>viem</code>, the network you want to interact with from <code>viem/chains</code>, and the <code>contractFile</code> from the <code>compile.ts</code> file you created in the Compile Contract Script section</li> <li>Set up a public viem client for reading chain data, which will be used to read the current number of the <code>Incrementer</code> contract</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract and the <code>abi</code> variable using the <code>contractFile</code> from the <code>compile.ts</code> file</li> <li>Create the asynchronous <code>get</code> function</li> <li>Call the contract using the <code>publicClient.readContract</code> function, passing in the <code>abi</code>, the name of the function, the <code>contractAddress</code>, and any arguments (if needed). You can use <code>await</code>, which will return the value requested once the request promise resolves</li> <li>Lastly, call the <code>get</code> function</li> </ol> <pre><code>// 1. Update imports\nimport { createPublicClient, http } from 'viem';\nimport { moonbaseAlpha } from 'viem/chains';\nimport contractFile from './compile';\n\n// 2. Create a public client for reading chain data\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network';\nconst client = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 3. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\n\n// 4. Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // 5. Call contract\n  const data = await client.readContract({\n    abi,\n    functionName: 'number',\n    address: contractAddress,\n    args: [],\n  });\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 6. Call get function\nget();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>npx ts-node get.ts\n</code></pre> <p>If successful, the value will be displayed in the terminal.</p> npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 5"},{"location":"builders/ethereum/libraries/viem/#interact-with-contract","title":"Interact with Contract (Send Methods)","text":"<p>Send methods are the type of interactions that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them <code>increment.ts</code> and <code>reset.ts</code>:</p> <pre><code>touch increment.ts reset.ts\n</code></pre> <p>Open the <code>increment.ts</code> file and take the following steps to create the script:</p> <ol> <li>Update your imports to include the <code>createWalletClient</code> and <code>http</code> functions from <code>viem</code>, the network you want to interact with from <code>viem/chains</code>, and the <code>contractFile</code> from the <code>compile.ts</code> file you created in the Compile Contract Script section</li> <li>Set up a viem wallet client for writing chain data, which will be used along with your private key to send a transaction. Note: This is for example purposes only. Never store your private keys in a TypeScript file</li> <li>Set up a public viem client for reading chain data, which will be used to wait for the transaction receipt</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract, the <code>abi</code> variable using the <code>contractFile</code> from the <code>compile.ts</code> file, and the <code>_value</code> to increment the contract by</li> <li>Create the asynchronous <code>increment</code> function</li> <li>Call the contract using the <code>walletClient.writeContract</code> function, passing in the <code>abi</code>, the name of the function, the <code>contractAddress</code>, and the <code>_value</code>. You can use <code>await</code>, which will return the transaction hash once the request promise resolves</li> <li>Use the <code>publicClient.waitForTransactionReceipt</code> function to wait for the transaction receipt, signaling that the transaction has been completed. This is particularly helpful if you need the transaction receipt or if you're running the <code>get.ts</code> script directly after this one to check that the current number has been updated as expected</li> <li>Lastly, call the <code>increment</code> function</li> </ol> <pre><code>// 1. Update imports\nimport { createPublicClient, createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbaseAlpha } from 'viem/chains';\nimport contractFile from './compile';\n\n// 2. Create a wallet client for writing chain data\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network';\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 3. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 4. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\nconst _value = 3;\n\n// 5. Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n  // 6. Call contract\n  const hash = await walletClient.writeContract({\n    abi,\n    functionName: 'increment',\n    address: contractAddress,\n    args: [_value],\n  });\n\n  // 7. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Tx successful with hash: ${hash}`);\n};\n\n// 8. Call increment function\nincrement();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>npx ts-node increment.ts\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.ts</code> script alongside the <code>increment.ts</code> script to make sure that value is changing as expected.</p> npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 5 npx ts-node increment.ts Calling the increment by 3 function in contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 Tx successful with hash: 0x041c9767e7a96f60f372341647430560569fd6ff64a27b4b9c6241e55dde57e1 npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 8 <p>Next, you can open the <code>reset.ts</code> file and take the following steps to create the script:</p> <ol> <li>Update your imports to include the <code>createWalletClient</code> and <code>http</code> functions from <code>viem</code>, the network you want to interact with from <code>viem/chains</code>, and the <code>contractFile</code> from the <code>compile.ts</code> file you created in the Compile Contract Script section</li> <li>Set up a viem wallet client for writing chain data, which will be used along with your private key to send a transaction. Note: This is for example purposes only. Never store your private keys in a TypeScript file</li> <li>Set up a public viem client for reading chain data, which will be used to wait for the transaction receipt</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract and the <code>abi</code> variable using the <code>contractFile</code> from the <code>compile.ts</code> file to increment the contract by</li> <li>Create the asynchronous <code>reset</code> function</li> <li>Call the contract using the <code>walletClient.writeContract</code> function, passing in the <code>abi</code>, the name of the function, the <code>contractAddress</code>, and an empty array for the arguments. You can use <code>await</code>, which will return the transaction hash once the request promise resolves</li> <li>Use the <code>publicClient.waitForTransactionReceipt</code> function to wait for the transaction receipt, signaling that the transaction has been completed. This is particularly helpful if you need the transaction receipt or if you're running the <code>get.ts</code> script directly after this one to check that the current number has been reset to <code>0</code></li> <li>Lastly, call the <code>reset</code> function</li> </ol> <pre><code>// 1. Update imports\nimport { createPublicClient, createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { moonbaseAlpha } from 'viem/chains';\nimport contractFile from './compile';\n\n// 2. Create a wallet client for writing chain data\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://rpc.api.moonbase.moonbeam.network';\nconst walletClient = createWalletClient({\n  account,\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 3. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: moonbaseAlpha,\n  transport: http(rpcUrl),\n});\n\n// 4. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\n\n// 5. Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // 6. Call contract\n  const hash = await walletClient.writeContract({\n    abi,\n    functionName: 'reset',\n    address: contractAddress,\n    args: [],\n  });\n\n  // 7. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Tx successful with hash: ${hash}`);\n};\n\n// 8. Call reset function\nreset();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>npx ts-node reset.ts\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.ts</code> script alongside the <code>reset.ts</code> script to make sure that value is changing as expected.</p> npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 8 npx ts-node reset.ts Calling the reset function in contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 Tx successful with hash: 0xc1a772131ccf6a03675ff3e88798a6e70a99e145eeb0e98170ff2e3345ee14a7 npx ts-node get.ts Making a call to contract at address: 0x4503b1086c6780e888194fd9caebca5f65b210c9 The current number stored is: 0    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/libraries/web3py/","title":"Web3.py Python Library","text":""},{"location":"builders/ethereum/libraries/web3py/#introduction","title":"Introduction","text":"<p>Web3.py is a set of libraries that allow developers to interact with Ethereum nodes using HTTP, IPC, or WebSocket protocols with Python. Moonbeam has an Ethereum-like API available that is fully compatible with Ethereum-style JSON-RPC invocations. Therefore, developers can leverage this compatibility and use the Web3.py library to interact with a Moonbeam node as if they were doing so on Ethereum.</p> <p>In this guide, you'll learn how to use the Web3.py library to send a transaction and deploy a contract on Moonbase Alpha. This guide can be adapted for Moonbeam, Moonriver, or a Moonbeam development node.</p>"},{"location":"builders/ethereum/libraries/web3py/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"},{"location":"builders/ethereum/libraries/web3py/#create-a-python-project","title":"Create a Python Project","text":"<p>To get started, you can create a directory to store all of the files you'll be creating throughout this guide:</p> <pre><code>mkdir web3-examples &amp;&amp; cd web3-examples\n</code></pre> <p>For this guide, you'll need to install the Web3.py library and the Solidity compiler. To install both packages, you can run the following command:</p> <pre><code>pip3 install web3 py-solc-x solc-select\n</code></pre>"},{"location":"builders/ethereum/libraries/web3py/#setup-web3-with-moonbeam","title":"Setup Web3.py with Moonbeam","text":"<p>Throughout this guide, you'll be creating a bunch of scripts that provide different functionalities, such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts, you'll need to create a Web3.py provider to interact with the network.</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>To create a provider, you can take the following steps:</p> <ol> <li>Import the <code>web3</code> library</li> <li>Create the <code>web3</code> provider using the <code>Web3(Web3.HTTPProvider())</code> method and providing the endpoint URL</li> </ol> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nweb3 = Web3(Web3.HTTPProvider(\"INSERT_RPC_API_ENDPOINT\")) # Insert your RPC URL here\n</code></pre> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nweb3 = Web3(Web3.HTTPProvider(\"INSERT_RPC_API_ENDPOINT\")) # Insert your RPC URL here\n</code></pre> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n</code></pre> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nweb3 = Web3(Web3.HTTPProvider(\"http://127.0.0.1:9944\"))\n</code></pre> <p>Save this code snippet, as you'll need it for the scripts that are used in the following sections.</p>"},{"location":"builders/ethereum/libraries/web3py/#send-a-transaction","title":"Send a Transaction","text":"<p>During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.</p> <p>You can also use the balance script to check the account balances after the transaction has been sent.</p>"},{"location":"builders/ethereum/libraries/web3py/#check-balances-script","title":"Check Balances Script","text":"<p>You'll only need one file to check the balances of both addresses before and after the transaction is sent.  To get started, you can create a <code>balances.py</code> file by running:</p> <pre><code>touch balances.py\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Web3 provider</li> <li>Define the <code>address_from</code> and <code>address_to</code> variables</li> <li>Get the balance for the accounts using the <code>web3.eth.get_balance</code> function and format the results using the <code>web3.from_wei</code></li> </ol> <pre><code>from web3 import Web3\n\n# 1. Add the Web3 provider logic here:\nprovider_rpc = {\n    \"development\": \"http://localhost:9944\",\n    \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network\n\n# 2. Create address variables\naddress_from = 'INSERT_FROM_ADDRESS'\naddress_to = 'INSERT_TO_ADDRESS'\n\n# 3. Fetch balance data\nbalance_from = web3.from_wei(\n    web3.eth.get_balance(Web3.to_checksum_address(address_from)), \"ether\"\n)\nbalance_to = web3.from_wei(\n    web3.eth.get_balance(Web3.to_checksum_address(address_to)), \"ether\"\n)\n\nprint(f\"The balance of { address_from } is: { balance_from } DEV\")\nprint(f\"The balance of { address_to } is: { balance_to } DEV\")\n</code></pre> <p>To run the script and fetch the account balances, you can run the following command:</p> <pre><code>python3 balances.py\n</code></pre> <p>If successful, the balances for the origin and receiving address will be displayed in your terminal in ETH.</p>"},{"location":"builders/ethereum/libraries/web3py/#send-transaction-script","title":"Send Transaction Script","text":"<p>You'll only need one file for executing a transaction between accounts. For this example, you'll be transferring 1 DEV token from an origin address (from which you hold the private key) to another address. To get started, you can create a <code>transaction.py</code> file by running:</p> <pre><code>touch transaction.py\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Add imports, including Web3.py and the <code>rpc_gas_price_strategy</code>, which will be used in the following steps to get the gas price used for the transaction</li> <li>Set up the Web3 provider</li> <li>Define the <code>account_from</code>, including the <code>private_key</code>, and the <code>address_to</code> variables. The private key is required to sign the transaction. Note: This is for example purposes only. Never store your private keys in a Python file</li> <li>Use the Web3.py Gas Price API to set a gas price strategy. For this example, you'll use the imported <code>rpc_gas_price_strategy</code></li> <li>Create and sign the transaction using the <code>web3.eth.account.sign_transaction</code> function. Pass in the <code>nonce</code> <code>gas</code>, <code>gasPrice</code>, <code>to</code>, and <code>value</code> for the transaction along with the sender's <code>private_key</code>. To get the <code>nonce</code> you can use the <code>web3.eth.get_transaction_count</code> function and pass in the sender's address. To predetermine the <code>gasPrice</code> you'll use the <code>web3.eth.generate_gas_price</code> function. For the <code>value</code>, you can format the amount to send from an easily readable format to Wei using the <code>web3.to_wei</code> function</li> <li>Using the signed transaction, you can then send it using the <code>web3.eth.send_raw_transaction</code> function and wait for the transaction receipt by using the <code>web3.eth.wait_for_transaction_receipt</code> function</li> </ol> <pre><code># 1. Add imports\nfrom web3.gas_strategies.rpc import rpc_gas_price_strategy\nfrom web3 import Web3\n\n# 2. Add the Web3 provider logic here:\nprovider_rpc = {\n    \"development\": \"http://localhost:9944\",\n    \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network\n\n# 3. Create address variables\naccount_from = {\n    'private_key': 'INSERT_YOUR_PRIVATE_KEY',\n    'address': 'INSERT_PUBLIC_ADDRESS_OF_PK',\n}\naddress_to = 'INSERT_TO_ADDRESS'\n\nprint(\n    f'Attempting to send transaction from { account_from[\"address\"] } to { address_to }'\n)\n\n# 4. Set the gas price strategy\nweb3.eth.set_gas_price_strategy(rpc_gas_price_strategy)\n\n# 5. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(\n    {\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n        \"gasPrice\": web3.eth.generate_gas_price(),\n        \"gas\": 21000,\n        \"to\": Web3.to_checksum_address(address_to),\n        \"value\": web3.to_wei(\"1\", \"ether\"),\n    },\n    account_from[\"private_key\"],\n)\n\n# 6. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Transaction successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>To run the script, you can run the following command in your terminal:</p> <pre><code>python3 transaction.py\n</code></pre> <p>If the transaction was successful, in your terminal you'll see the transaction hash has been printed out.</p> <p>You can also use the <code>balances.py</code> script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:</p> python3 balances.py The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3563.79 DEV The balance of 0x9Bf5Ae10540a1ab9B363bEA02A9406E6b2efA9af is: 0 DEV python3 transaction.py Attempting to send transaction from 0x3B939FeaD1557C741Ff06492FD0127bd287A421e to 0x9Bf5Ae10540a1ab9B363bEA02A9406E6b2efA9af Transaction successful with hash: 0xac70452510657ed43c27510578d3ce4b3b880d4cca1a24ade1497c6e0ee7f5d6 python3 balances.py The balance of 0x3B939FeaD1557C741Ff06492FD0127bd287A421e is: 3562.79 DEV The balance of 0x9Bf5Ae10540a1ab9B363bEA02A9406E6b2efA9af is: 1 DEV"},{"location":"builders/ethereum/libraries/web3py/#deploy-a-contract","title":"Deploy a Contract","text":"<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (the default is <code>0</code>). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only and does not handle values wrapping around.</p>"},{"location":"builders/ethereum/libraries/web3py/#compile-contract-script","title":"Compile Contract Script","text":"<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.py</code> file by running:</p> <pre><code>touch compile.py\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>solcx</code> package</li> <li>Optional - If you haven't already installed the Solidity compiler, you can do so with by using the <code>solcx.install_solc</code> function</li> <li>Compile the <code>Incrementer.sol</code> function using the <code>solcx.compile_files</code> function</li> <li>Export the contract's ABI and bytecode</li> </ol> <pre><code># 1. Import solcx\nimport solcx\n\n# 2. If you haven't already installed the Solidity compiler, uncomment the following line\n# solcx.install_solc()\n\n# 3. Compile contract\ntemp_file = solcx.compile_files(\n    'Incrementer.sol',\n    output_values=['abi', 'bin'],\n    # solc_version='0.8.19'\n)\n\n# 4. Export contract data\nabi = temp_file['Incrementer.sol:Incrementer']['abi']\nbytecode = temp_file['Incrementer.sol:Incrementer']['bin']\n</code></pre> <p>Note</p> <p>If you see an error stating that <code>Solc is not installed</code>, uncomment step 2 described in the code snippet.</p>"},{"location":"builders/ethereum/libraries/web3py/#deploy-contract-script","title":"Deploy Contract Script","text":"<p>With the script for compiling the <code>Incrementer.sol</code> contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called <code>deploy.py</code>:</p> <pre><code>touch deploy.py\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Add imports, including Web3.py and the ABI and bytecode of the <code>Incrementer.sol</code> contract</li> <li>Set up the Web3 provider</li> <li>Define the <code>account_from</code>, including the <code>private_key</code>. The private key is required to sign the transaction. Note: This is for example purposes only. Never store your private keys in a Python file</li> <li>Create a contract instance using the <code>web3.eth.contract</code> function and passing in the ABI and bytecode of the contract</li> <li>Build a constructor transaction using the contract instance and passing in the value to increment by. For this example, you can use <code>5</code>. You'll then use the <code>build_transaction</code> function to pass in the transaction information including the <code>from</code> address and the <code>nonce</code> for the sender. To get the <code>nonce</code> you can use the <code>web3.eth.get_transaction_count</code> function </li> <li>Sign the transaction using the <code>web3.eth.account.sign_transaction</code> function and pass in the constructor transaction and the <code>private_key</code> of the sender</li> <li>Using the signed transaction, you can then send it using the <code>web3.eth.send_raw_transaction</code> function and wait for the transaction receipt by using the <code>web3.eth.wait_for_transaction_receipt</code> function</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi, bytecode\nfrom web3 import Web3\n\n# 2. Add the Web3 provider logic here:\nprovider_rpc = {\n    \"development\": \"http://localhost:9944\",\n    \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network\n\n# 3. Create address variable\naccount_from = {\n    'private_key': 'INSERT_YOUR_PRIVATE_KEY',\n    'address': 'INSERT_PUBLIC_ADDRESS_OF_PK',\n}\n\nprint(f'Attempting to deploy from account: { account_from[\"address\"] }')\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(abi=abi, bytecode=bytecode)\n\n# 5. Build constructor tx\nconstruct_txn = Incrementer.constructor(5).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(\n    construct_txn, account_from[\"private_key\"]\n)\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Contract deployed at address: { tx_receipt.contractAddress }\")\n</code></pre> <p>To run the script, you can enter the following command into your terminal:</p> <pre><code>python3 deploy.py\n</code></pre> <p>If successful, the contract's address will be displayed in the terminal.</p> python3 deploy.py Attempting to deploy from account: 0x3B939FeaD1557C741Ff06492FD0127bd287A421e Contract deployed at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08"},{"location":"builders/ethereum/libraries/web3py/#read-contract-data","title":"Read Contract Data (Call Methods)","text":"<p>Call methods are the type of interaction that don't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.</p> <p>To get started, you can create a file and name it <code>get.py</code>:</p> <pre><code>touch get.py\n</code></pre> <p>Then you can take the following steps to create the script:</p> <ol> <li>Add imports, including Web3.py and the ABI of the <code>Incrementer.sol</code> contract</li> <li>Set up the Web3 provider</li> <li>Define the <code>contract_address</code> of the deployed contract</li> <li>Create a contract instance using the <code>web3.eth.contract</code> function and passing in the ABI and address of the deployed contract</li> <li>Using the contract instance, you can then call the <code>number</code> function</li> </ol> <pre><code># 1. Import the ABI\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Add the Web3 provider logic here:\nprovider_rpc = {\n    \"development\": \"http://localhost:9944\",\n    \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network\n\n# 3. Create address variable\ncontract_address = 'INSERT_CONTRACT_ADDRESS'\n\nprint(f\"Making a call to contract at address: { contract_address }\")\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Call Contract\nnumber = Incrementer.functions.number().call()\nprint(f\"The current number stored is: { number } \")\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>python3 get.py\n</code></pre> <p>If successful, the value will be displayed in the terminal.</p>"},{"location":"builders/ethereum/libraries/web3py/#interact-with-contract","title":"Interact with Contract (Send Methods)","text":"<p>Send methods are the type of interaction that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them <code>increment.py</code> and <code>reset.py</code>:</p> <pre><code>touch increment.py reset.py\n</code></pre> <p>Open the <code>increment.py</code> file and take the following steps to create the script:</p> <ol> <li>Add imports, including Web3.py and the ABI of the <code>Incrementer.sol</code> contract</li> <li>Set up the Web3 provider</li> <li>Define the <code>account_from</code>, including the <code>private_key</code>, the <code>contract_address</code> of the deployed contract, and the <code>value</code> to increment by. The private key is required to sign the transaction. Note: This is for example purposes only. Never store your private keys in a Python file</li> <li>Create a contract instance using the <code>web3.eth.contract</code> function and passing in the ABI and address of the deployed contract</li> <li>Build the increment transaction using the contract instance and passing in the value to increment by. You'll then use the <code>build_transaction</code> function to pass in the transaction information including the <code>from</code> address and the <code>nonce</code> for the sender. To get the <code>nonce</code> you can use the <code>web3.eth.get_transaction_count</code> function</li> <li>Sign the transaction using the <code>web3.eth.account.sign_transaction</code> function and pass in the increment transaction and the <code>private_key</code> of the sender</li> <li>Using the signed transaction, you can then send it using the <code>web3.eth.send_raw_transaction</code> function and wait for the transaction receipt by using the <code>web3.eth.wait_for_transaction_receipt</code> function</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Add the Web3 provider logic here:\nprovider_rpc = {\n    \"development\": \"http://localhost:9944\",\n    \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network\n\n# 3. Create variables\naccount_from = {\n    'private_key': 'INSERT_YOUR_PRIVATE_KEY',\n    'address': 'INSERT_PUBLIC_ADDRESS_OF_PK',\n}\ncontract_address = 'INSERT_CONTRACT_ADDRESS'\nvalue = 3\n\nprint(\n    f\"Calling the increment by { value } function in contract at address: { contract_address }\"\n)\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Build increment tx\nincrement_tx = Incrementer.functions.increment(value).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(increment_tx, account_from[\"private_key\"])\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Tx successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>python3 increment.py\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.py</code> script alongside the <code>increment.py</code> script to make sure that value is changing as expected:</p> python get.py Making a call to contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 The current number stored is: 5 python increment.py Calling the increment by 3 function in contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 Tx successful with hash: 0x47757fd97e3ef8db973e335d1f2d19c46b37d0dbd53fea1636ec559ccf119a13 python get.py Making a call to contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 The current number stored is: 8 <p>Next you can open the <code>reset.py</code> file and take the following steps to create the script:</p> <ol> <li>Add imports, including Web3.py and the ABI of the <code>Incrementer.sol</code> contract</li> <li>Set up the Web3 provider</li> <li>Define the <code>account_from</code>, including the <code>private_key</code>, and the <code>contract_address</code> of the deployed contract. The private key is required to sign the transaction. Note: This is for example purposes only. Never store your private keys in a Python file</li> <li>Create a contract instance using the <code>web3.eth.contract</code> function and passing in the ABI and address of the deployed contract</li> <li>Build the reset transaction using the contract instance. You'll then use the <code>build_transaction</code> function to pass in the transaction information including the <code>from</code> address and the <code>nonce</code> for the sender. To get the <code>nonce</code> you can use the <code>web3.eth.get_transaction_count</code> function</li> <li>Sign the transaction using the <code>web3.eth.account.sign_transaction</code> function and pass in the reset transaction and the <code>private_key</code> of the sender</li> <li>Using the signed transaction, you can then send it using the <code>web3.eth.send_raw_transaction</code> function and wait for the transaction receipt by using the <code>web3.eth.wait_for_transaction_receipt</code> function</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Add the Web3 provider logic here:\nprovider_rpc = {\n    \"development\": \"http://localhost:9944\",\n    \"moonbase\": \"https://rpc.api.moonbase.moonbeam.network\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"moonbase\"]))  # Change to correct network\n\n# 3. Create variables\naccount_from = {\n    'private_key': 'INSERT_YOUR_PRIVATE_KEY',\n    'address': 'INSERT_PUBLIC_ADDRESS_OF_PK',\n}\ncontract_address = 'INSERT_CONTRACT_ADDRESS'\n\nprint(f\"Calling the reset function in contract at address: { contract_address }\")\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Build reset tx\nreset_tx = Incrementer.functions.reset().build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(reset_tx, account_from[\"private_key\"])\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Tx successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>python3 reset.py\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.py</code> script alongside the <code>reset.py</code> script to make sure that value is changing as expected:</p> python get.py Making a call to contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 The current number stored is: 8 python reset.py Calling the reset function in contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 Tx successful with hash: 0x152f07430b524838da848b44d58577db252681fba6fbeaf117b2f9d432e301b2 python get.py Making a call to contract at address: 0xFef3cFb8eE1FE727b3848E551ae5DC8903237B08 The current number stored is: 0    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/ethereum/precompiles/overview/","title":"Overview of the Precompiled Contracts on Moonbeam","text":""},{"location":"builders/ethereum/precompiles/overview/#introduction","title":"Overview","text":"<p>On Moonbeam, a precompiled contract is native Substrate code that has an Ethereum-style address and can be called using the Ethereum API, like any other smart contract. The precompiles allow you to call the Substrate runtime directly which is not normally accessible from the Ethereum side of Moonbeam.</p> <p>The Substrate code responsible for implementing precompiles can be found in the EVM pallet. The EVM pallet includes the standard precompiles found on Ethereum and some additional precompiles that are not specific to Ethereum. It also provides the ability to create and execute custom precompiles through the generic <code>Precompiles</code> trait. There are several custom Moonbeam-specific precompiles that have been created, all of which can be found in the Moonbeam codebase. It is important to highlight that the precompiles from this list with the <code>CallableByContract</code> check are not callable inside the contract constructor.</p> <p>The Ethereum precompiled contracts contain complex functionality that is computationally intensive, such as hashing and encryption. The custom precompiled contracts on Moonbeam provide access to Substrate-based functionality such as staking, governance, XCM-related functions, and more.</p> <p>The Moonbeam-specific precompiles can be interacted with through familiar and easy-to-use Solidity interfaces using the Ethereum API, which are ultimately used to interact with the underlying Substrate interface. This flow is depicted in the following diagram:</p> <p></p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/overview/#precompiled-contract-addresses","title":"Precompiled Contract Addresses","text":"<p>The precompiled contracts are categorized by address and based on the origin network. If you were to convert the precompiled addresses to decimal format, and break them into categories by numeric value, the categories are as follows:</p> <ul> <li>0-1023 - Ethereum MainNet precompiles</li> <li>1024-2047 - precompiles that are not in Ethereum and not Moonbeam specific</li> <li>2048-4095 - Moonbeam specific precompiles</li> </ul>"},{"location":"builders/ethereum/precompiles/overview/#ethereum-mainnet-precompiles","title":"Ethereum MainNet Precompiles","text":"MoonbeamMoonriverMoonbase Alpha Contract Address ECRECOVER 0x0000000000000000000000000000000000000001 SHA256 0x0000000000000000000000000000000000000002 RIPEMD160 0x0000000000000000000000000000000000000003 Identity 0x0000000000000000000000000000000000000004 Modular Exponentiation 0x0000000000000000000000000000000000000005 BN128Add 0x0000000000000000000000000000000000000006 BN128Mul 0x0000000000000000000000000000000000000007 BN128Pairing 0x0000000000000000000000000000000000000008 Blake2 0x0000000000000000000000000000000000000009 P256Verify 0x0000000000000000000000000000000000000100 Contract Address ECRECOVER 0x0000000000000000000000000000000000000001 SHA256 0x0000000000000000000000000000000000000002 RIPEMD160 0x0000000000000000000000000000000000000003 Identity 0x0000000000000000000000000000000000000004 Modular Exponentiation 0x0000000000000000000000000000000000000005 BN128Add 0x0000000000000000000000000000000000000006 BN128Mul 0x0000000000000000000000000000000000000007 BN128Pairing 0x0000000000000000000000000000000000000008 Blake2 0x0000000000000000000000000000000000000009 P256Verify 0x0000000000000000000000000000000000000100 Contract Address ECRECOVER 0x0000000000000000000000000000000000000001 SHA256 0x0000000000000000000000000000000000000002 RIPEMD160 0x0000000000000000000000000000000000000003 Identity 0x0000000000000000000000000000000000000004 Modular Exponentiation 0x0000000000000000000000000000000000000005 BN128Add 0x0000000000000000000000000000000000000006 BN128Mul 0x0000000000000000000000000000000000000007 BN128Pairing 0x0000000000000000000000000000000000000008 Blake2 0x0000000000000000000000000000000000000009 P256Verify 0x0000000000000000000000000000000000000100"},{"location":"builders/ethereum/precompiles/overview/#non-moonbeam-specific-nor-ethereum-precompiles","title":"Non-Moonbeam Specific nor Ethereum Precompiles","text":"MoonbeamMoonriverMoonbase Alpha Contract Address SHA3FIPS256 0x0000000000000000000000000000000000000400 Dispatch [Removed] 0x0000000000000000000000000000000000000401 ECRecoverPublicKey 0x0000000000000000000000000000000000000402 Contract Address SHA3FIPS256 0x0000000000000000000000000000000000000400 Dispatch [Removed] 0x0000000000000000000000000000000000000401 ECRecoverPublicKey 0x0000000000000000000000000000000000000402 Contract Address SHA3FIPS256 0x0000000000000000000000000000000000000400 Dispatch [Removed] 0x0000000000000000000000000000000000000401 ECRecoverPublicKey 0x0000000000000000000000000000000000000402"},{"location":"builders/ethereum/precompiles/overview/#moonbeam-specific-precompiles","title":"Moonbeam Specific Precompiles","text":"MoonbeamMoonriverMoonbase Alpha Contract Address Parachain Staking 0x0000000000000000000000000000000000000800 ERC-20 Interface 0x0000000000000000000000000000000000000802 Democracy [Removed] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 Relay Encoder 0x0000000000000000000000000000000000000805 XCM Transactor V1 0x0000000000000000000000000000000000000806 Author Mapping 0x0000000000000000000000000000000000000807 Batch 0x0000000000000000000000000000000000000808 Randomness 0x0000000000000000000000000000000000000809 Call Permit 0x000000000000000000000000000000000000080a Proxy 0x000000000000000000000000000000000000080b XCM Utilities 0x000000000000000000000000000000000000080C XCM Transactor V2 0x000000000000000000000000000000000000080d Council Collective [Removed] 0x000000000000000000000000000000000000080e Technical Committee Collective [Removed] 0x000000000000000000000000000000000000080f Treasury Council Collective 0x0000000000000000000000000000000000000810 Referenda 0x0000000000000000000000000000000000000811 Conviction Voting 0x0000000000000000000000000000000000000812 Preimage 0x0000000000000000000000000000000000000813 OpenGov Tech Committee 0x0000000000000000000000000000000000000814 Precompile Registry 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM Transactor V3 0x0000000000000000000000000000000000000817 XCM interface 0x000000000000000000000000000000000000081A Identity 0x0000000000000000000000000000000000000818 Contract Address Parachain Staking 0x0000000000000000000000000000000000000800 ERC-20 Interface 0x0000000000000000000000000000000000000802 Democracy [Disabled] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 Relay Encoder 0x0000000000000000000000000000000000000805 XCM Transactor V1 0x0000000000000000000000000000000000000806 Author Mapping 0x0000000000000000000000000000000000000807 Batch 0x0000000000000000000000000000000000000808 Randomness 0x0000000000000000000000000000000000000809 Call Permit 0x000000000000000000000000000000000000080a Proxy 0x000000000000000000000000000000000000080b XCM Utilities 0x000000000000000000000000000000000000080C XCM Transactor V2 0x000000000000000000000000000000000000080d Council Collective [Removed] 0x000000000000000000000000000000000000080e Technical Committee Collective [Removed] 0x000000000000000000000000000000000000080f Treasury Council Collective 0x0000000000000000000000000000000000000810 Referenda 0x0000000000000000000000000000000000000811 Conviction Voting 0x0000000000000000000000000000000000000812 Preimage 0x0000000000000000000000000000000000000813 OpenGov Tech Committee 0x0000000000000000000000000000000000000814 Precompile Registry 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM Transactor V3 0x0000000000000000000000000000000000000817 XCM interface 0x000000000000000000000000000000000000081A Identity 0x0000000000000000000000000000000000000818 Contract Address Parachain Staking 0x0000000000000000000000000000000000000800 ERC-20 Interface 0x0000000000000000000000000000000000000802 Democracy [Removed] 0x0000000000000000000000000000000000000803 X-Tokens 0x0000000000000000000000000000000000000804 Relay Encoder 0x0000000000000000000000000000000000000805 XCM Transactor V1 0x0000000000000000000000000000000000000806 Author Mapping 0x0000000000000000000000000000000000000807 Batch 0x0000000000000000000000000000000000000808 Randomness 0x0000000000000000000000000000000000000809 Call Permit 0x000000000000000000000000000000000000080a Proxy 0x000000000000000000000000000000000000080b XCM Utilities 0x000000000000000000000000000000000000080C XCM Transactor V2 0x000000000000000000000000000000000000080d Council Collective [Removed] 0x000000000000000000000000000000000000080e Technical Committee Collective [Removed] 0x000000000000000000000000000000000000080f Treasury Council Collective 0x0000000000000000000000000000000000000810 Referenda 0x0000000000000000000000000000000000000811 Conviction Voting 0x0000000000000000000000000000000000000812 Preimage 0x0000000000000000000000000000000000000813 OpenGov Tech Committee 0x0000000000000000000000000000000000000814 Precompile Registry 0x0000000000000000000000000000000000000815 GMP 0x0000000000000000000000000000000000000816 XCM Transactor V3 0x0000000000000000000000000000000000000817 XCM Interface 0x000000000000000000000000000000000000081A Identity 0x0000000000000000000000000000000000000818"},{"location":"builders/ethereum/precompiles/account/identity/","title":"Identity Precompile on Moonbeam","text":""},{"location":"builders/ethereum/precompiles/account/identity/#introduction","title":"Introduction","text":"<p>The Identity Precompile is a Solidity interface that allows you to create, manage, and retrieve information on on-chain identities. Identities are attached to accounts and include personal information, such as your legal name, display name, website, Twitter handle, Riot (now known as Element) name, and more. You can also take advantage of custom fields to include any other relevant information.</p> <p>The Identity Precompile interacts directly with Moonbeam's underlying Substrate Identity runtime logic to provide the functionality needed to create and manage identities. This pallet is coded in Rust and is normally not accessible from the Ethereum side of Moonbeam. However, the Identity Precompile allows you to access this functionality directly from the Solidity interface.</p> <p>The Identity Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000818\n</code></pre> <pre><code>0x0000000000000000000000000000000000000818\n</code></pre> <pre><code>0x0000000000000000000000000000000000000818\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/account/identity/#the-solidity-interface","title":"The Identity Precompile Solidity Interface","text":"<p><code>Identity.sol</code> is a Solidity interface that allows developers to interact with the precompile's methods.</p> Identity.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Identity contract's address.\naddress constant IDENTITY_ADDRESS = 0x0000000000000000000000000000000000000818;\n\n/// @dev The Identity contract's instance.\nIdentity constant IDENTITY_CONTRACT = Identity(IDENTITY_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Pallet Identity Interface\n/// @title The interface through which solidity contracts will interact with the Identity pallet\n/// @custom:address 0x0000000000000000000000000000000000000818\ninterface Identity {\n    /// @dev Associated raw data.\n    struct Data {\n        /// Is `true` if it represents data, else the absence of data is represented by `false`.\n        bool hasData;\n        /// The contained value.\n        bytes value;\n    }\n\n    /// @dev The super-identity of an alternative \"sub\" identity.\n    struct SuperOf {\n        /// Is `true` if the struct is valid, `false` otherwise.\n        bool isValid;\n        /// The super account.\n        address account;\n        /// The associated data.\n        Data data;\n    }\n\n    /// @dev Alternative \"sub\" identities of an account.\n    struct SubsOf {\n        /// The deposit against this identity.\n        uint256 deposit;\n        /// The sub accounts\n        address[] accounts;\n    }\n\n    /// @dev Registrar judgements are limited to attestations on these fields.\n    struct IdentityFields {\n        /// Set to `true` if the display field is supported, `false` otherwise.\n        bool display;\n        /// Set to `true` if the legal field is supported, `false` otherwise.\n        bool legal;\n        /// Set to `true` if the web field is supported, `false` otherwise.\n        bool web;\n        /// Set to `true` if the riot field is supported, `false` otherwise.\n        bool riot;\n        /// Set to `true` if the email field is supported, `false` otherwise.\n        bool email;\n        /// Set to `true` if the PGP Fingerprint field is supported, `false` otherwise.\n        bool pgpFingerprint;\n        /// Set to `true` if the image field is supported, `false` otherwise.\n        bool image;\n        /// Set to `true` if the twitter field is supported, `false` otherwise.\n        bool twitter;\n    }\n\n    /// @dev Registrar info.\n    struct Registrar {\n        /// Is `true` if the struct is valid, `false` otherwise.\n        bool isValid;\n        /// The registrar's index.\n        uint32 index;\n        /// The account address.\n        address account;\n        /// Amount required to be given to the registrar for them to provide judgement.\n        uint256 fee;\n        /// Relevant fields for this registrar.\n        IdentityFields fields;\n    }\n\n    /// @dev Represents an additional field in identity info.\n    struct Additional {\n        /// The assciated key.\n        Data key;\n        /// The assciated value.\n        Data value;\n    }\n\n    /// @dev The identity information set for an account.\n    struct IdentityInfo {\n        /// Represents the additional fields for the identity.\n        Additional[] additional;\n        /// Represents the display info for the identity.\n        Data display;\n        /// Represents the legal info for the identity.\n        Data legal;\n        /// Represents the web info for the identity.\n        Data web;\n        /// Represents the riot info for the identity.\n        Data riot;\n        /// Represents the email info for the identity.\n        Data email;\n        /// Set to `true` if `pgpFingerprint` is set, `false` otherwise.\n        bool hasPgpFingerprint;\n        /// Represents a 20-byte the PGP fingerprint info for the identity.\n        bytes pgpFingerprint;\n        /// Represents the image info for the identity.\n        Data image;\n        /// Represents the twitter info for the identity.\n        Data twitter;\n    }\n\n    /// @dev Judgement provided by a registrar.\n    struct Judgement {\n        /// The default value; no opinion is held.\n        bool isUnknown;\n        /// No judgement is yet in place, but a deposit is reserved as payment for providing one.\n        bool isFeePaid;\n        /// The deposit reserved for providing a judgement.\n        uint256 feePaidDeposit;\n        /// The data appears to be reasonably acceptable in terms of its accuracy.\n        bool isReasonable;\n        /// The target is known directly by the registrar and the registrar can fully attest to it.\n        bool isKnownGood;\n        /// The data was once good but is currently out of date.\n        bool isOutOfDate;\n        /// The data is imprecise or of sufficiently low-quality to be problematic.\n        bool isLowQuality;\n        /// The data is erroneous. This may be indicative of malicious intent.\n        bool isErroneous;\n    }\n\n    /// @dev Judgement item provided by a registrar.\n    struct JudgementInfo {\n        /// The registrar's index that provided this judgement.\n        uint32 registrarIndex;\n        /// The registrar's provided judgement.\n        Judgement judgement;\n    }\n\n    /// @dev Registrar info.\n    struct Registration {\n        /// Is `true` if the struct is valid, `false` otherwise.\n        bool isValid;\n        /// The judgments provided on this identity.\n        JudgementInfo[] judgements;\n        /// Amount required to be given to the registrar for them to provide judgement.\n        uint256 deposit;\n        /// The associated identity info.\n        IdentityInfo info;\n    }\n\n    /// @dev Alternative \"sub\" identity of an account.\n    struct SubAccount {\n        /// The account address.\n        address account;\n        /// The associated data.\n        Data data;\n    }\n\n    /// @dev Retrieve identity information for an account.\n    /// @custom:selector f0eb5e54\n    /// @param who The requested account\n    function identity(address who) external view returns (Registration memory);\n\n    /// @dev Retrieve super account for an account.\n    /// @custom:selector c18110d6\n    /// @param who The requested account\n    function superOf(address who) external view returns (SuperOf memory);\n\n    /// @dev Retrieve sub accounts for an account.\n    /// @custom:selector 3f08986b\n    /// @param who The requested account\n    function subsOf(address who) external view returns (SubsOf memory);\n\n    /// @dev Retrieve the registrars.\n    /// @custom:selector e88e512e\n    function registrars() external view returns (Registrar[] memory);\n\n    /// @dev Set identity info for the caller.\n    /// @custom:selector 7e08b4cb\n    /// @param info The identity info\n    function setIdentity(IdentityInfo memory info) external;\n\n    /// @dev Set sub accounts for the caller.\n    /// @custom:selector 5a5a3591\n    /// @param subs The sub accounts\n    function setSubs(SubAccount[] memory subs) external;\n\n    /// @dev Clears identity of the caller.\n    /// @custom:selector 7a6a10c7\n    function clearIdentity() external;\n\n    /// @dev Requests registrar judgement on caller's identity.\n    /// @custom:selector d523ceb9\n    /// @param regIndex The registrar's index\n    /// @param maxFee The maximum fee the caller is willing to pay\n    function requestJudgement(uint32 regIndex, uint256 maxFee) external;\n\n    /// @dev Cancels the caller's request for judgement from a registrar.\n    /// @custom:selector c79934a5\n    /// @param regIndex The registrar's index\n    function cancelRequest(uint32 regIndex) external;\n\n    /// @dev Sets the registrar's fee for providing a judgement. Caller must be the account at the index.\n    /// @custom:selector a541b37d\n    /// @param regIndex The registrar's index\n    /// @param fee The fee the registrar will charge\n    function setFee(uint32 regIndex, uint256 fee) external;\n\n    /// @dev Sets the registrar's account. Caller must be the account at the index.\n    /// @custom:selector 889bc198\n    /// @param regIndex The registrar's index\n    /// @param newAccount The new account to set\n    function setAccountId(uint32 regIndex, address newAccount) external;\n\n    /// @dev Sets the registrar's identity fields. Caller must be the account at the index.\n    /// @custom:selector 05297450\n    /// @param regIndex The registrar's index\n    /// @param fields The identity fields\n    function setFields(uint32 regIndex, IdentityFields memory fields) external;\n\n    /// @dev Provides judgement on an accounts identity.\n    /// @custom:selector cd7663a4\n    /// @param regIndex The registrar's index\n    /// @param target The target account to provide judgment for\n    /// @param judgement The judgement to provide\n    /// @param identity The hash of the identity info\n    function provideJudgement(\n        uint32 regIndex,\n        address target,\n        Judgement memory judgement,\n        bytes32 identity\n    ) external;\n\n    /// @dev Add a \"sub\" identity account for the caller.\n    /// @custom:selector 98717196\n    /// @param sub The sub account\n    /// @param data The associated data\n    function addSub(address sub, Data memory data) external;\n\n    /// @dev Rename a \"sub\" identity account of the caller.\n    /// @custom:selector 452df561\n    /// @param sub The sub account\n    /// @param data The new associated data\n    function renameSub(address sub, Data memory data) external;\n\n    /// @dev Removes a \"sub\" identity account of the caller.\n    /// @custom:selector b0a323e0\n    /// @param sub The sub account\n    function removeSub(address sub) external;\n\n    /// @dev Removes the sender as a sub-account.\n    /// @custom:selector d5a3c2c4\n    function quitSub() external;\n\n    /// @dev An identity was set or reset (which will remove all judgements).\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param who Address of the target account\n    event IdentitySet(address who);\n\n    /// @dev An identity was cleared, and the given balance returned.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param who Address of the target account\n    event IdentityCleared(address who);\n\n    /// @dev A judgement was asked from a registrar.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param who Address of the requesting account\n    /// @param registrarIndex The registrar's index\n    event JudgementRequested(address who, uint32 registrarIndex);\n\n    /// @dev A judgement request was retracted.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param who Address of the target account.\n    /// @param registrarIndex The registrar's index\n    event JudgementUnrequested(address who, uint32 registrarIndex);\n\n    /// @dev A judgement was given by a registrar.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param target Address of the target account\n    /// @param registrarIndex The registrar's index\n    event JudgementGiven(address target, uint32 registrarIndex);\n\n    /// @dev A sub-identity was added to an identity and the deposit paid.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param sub Address of the sub account\n    /// @param main Address of the main account\n    event SubIdentityAdded(address sub, address main);\n\n    /// @dev A sub-identity was removed from an identity and the deposit freed.\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param sub Address of the sub account\n    /// @param main Address of the main account\n    event SubIdentityRemoved(address sub, address main);\n\n    /// @dev A sub-identity was cleared and the given deposit repatriated from the main identity account to the sub-identity account\n    /// @custom:selector 3839f7832b2a6263aa1fd5040f37d10fd4f9e9c4a9ef07ec384cb1cef9fb4c0e\n    /// @param sub Address of the sub account\n    event SubIdentityRevoked(address sub);\n}\n</code></pre> <p>The Identity Precompile contains some functions that can be called by anyone and some judgment-related functions that can only be called by a registrar. The functions that can be called by anyone are as follows:</p> identity(address who) - returns registration information for a given account Parameters <ul> <li><code>who</code> - address of the account to query the identity information for</li> </ul> superOf(address who) - retrieves the super account for a sub-account. If the given account is not a sub-account, the address returned is <code>0x0000000000000000000000000000000000000000</code> Parameters <ul> <li><code>who</code> - address of the account to query the super-account for</li> </ul> subsOf(address who) - returns the sub-accounts for a given account. If the given account doesn't have any sub-accounts, an empty array is returned (<code>[]</code>) Parameters <ul> <li><code>who</code> - address of the account to query the sub-accounts for</li> </ul> registrars() - returns the list of registrars Parameters <p>None.</p> setIdentity(IdentityInfo memory info) - sets the identity for the caller Parameters <ul> <li><code>info</code> - IdentityInfo memory struct containing the identity information to be set</li> </ul> setSubs(SubAccount[] memory subs) - sets the sub-accounts for the caller Parameters <ul> <li><code>subs</code> - SubAccount[] memory array containing the sub-accounts to be set</li> </ul> clearIdentity() - clears the identity for the caller Parameters <p>None.</p> requestJudgement(uint32 regIndex, uint256 maxFee) - requests judgment from a given registrar along with the maximum fee the caller is willing to pay Parameters <ul> <li><code>regIndex</code> - uint32 index of the registrar to request judgment from</li> <li><code>maxFee</code> - uint256 maximum fee the caller is willing to pay for the judgment</li> </ul> cancelRequest(uint32 regIndex) - cancels the caller's request for judgment from a given registrar Parameters <ul> <li><code>regIndex</code> - uint32 index of the registrar to cancel the judgment request from</li> </ul> addSub(address sub, Data memory data) - adds a sub-identity account for the caller Parameters <ul> <li><code>sub</code> - address of the sub-account to add</li> <li><code>data</code> - Data memory struct containing the sub-account information</li> </ul> renameSub(address sub, Data memory data) - renames a sub-identity account for the caller Parameters <ul> <li><code>sub</code> - address of the sub-account to rename</li> <li><code>data</code> - Data memory struct containing the new sub-account information</li> </ul> removeSub(address sub) - removes a sub identity account for the caller Parameters <ul> <li><code>sub</code> - address of the sub-account to remove</li> </ul> quitSub(address sub) - removes the caller as a sub-identity account Parameters <ul> <li><code>sub</code> - address of the sub-account to quit</li> </ul> <p>The judgment-related functions that must be called by a registrar and the caller must be the registrar account that corresponds to the <code>regIndex</code> are:</p> setFee(uint32 regIndex, uint256 fee) - sets the fee for a registrar Parameters <ul> <li><code>regIndex</code> - uint32 index of the registrar setting the fee</li> <li><code>fee</code> - uint256 new fee amount to be set for the registrar</li> </ul> setAccountId(uint32 regIndex, address newAccount) - sets a new account for a registrar Parameters <ul> <li><code>regIndex</code> - uint32 index of the registrar being updated</li> <li><code>newAccount</code> - address of the new account to be set for the registrar</li> </ul> setFields(uint32 regIndex, IdentityFields memory fields) - sets the registrar's identity Parameters <ul> <li><code>regIndex</code> - uint32 index of the registrar setting their identity fields</li> <li><code>fields</code> - IdentityFields memory struct containing the identity fields to be set</li> </ul> provideJudgement(uint32 regIndex, address target, Judgement memory judgement, bytes32 identity) - provides judgment on an account's identity Parameters <ul> <li><code>regIndex</code> - uint32 index of the registrar providing the judgment</li> <li><code>target</code> - address of the account receiving the judgment</li> <li><code>judgement</code> - Judgement memory struct containing the judgment details</li> <li><code>identity</code> - bytes32 hash of the identity information being judged</li> </ul>"},{"location":"builders/ethereum/precompiles/account/identity/#interact-with-interface","title":"Interact with the Solidity Interface","text":"<p>The following sections will cover how to interact with the Identity Precompile using Ethereum libraries, such as Ethers.js and Web3.py.</p> <p>The examples in this guide will be on Moonbase Alpha. To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/ethereum/precompiles/account/identity/#use-ethereum-libraries","title":"Using Ethereum Libraries","text":"<p>To interact with the Identity Precompile's Solidity interface with an Ethereum library, you'll need the Identity Precompile's ABI.</p> Identity Precompile ABI <pre><code>[\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"IdentityCleared\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"IdentitySet\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"target\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint32\",\n                \"name\": \"registrarIndex\",\n                \"type\": \"uint32\"\n            }\n        ],\n        \"name\": \"JudgementGiven\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint32\",\n                \"name\": \"registrarIndex\",\n                \"type\": \"uint32\"\n            }\n        ],\n        \"name\": \"JudgementRequested\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint32\",\n                \"name\": \"registrarIndex\",\n                \"type\": \"uint32\"\n            }\n        ],\n        \"name\": \"JudgementUnrequested\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"main\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"SubIdentityAdded\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"main\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"SubIdentityRemoved\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"SubIdentityRevoked\",\n        \"type\": \"event\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            },\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"hasData\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bytes\",\n                        \"name\": \"value\",\n                        \"type\": \"bytes\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Data\",\n                \"name\": \"data\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"name\": \"addSub\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            }\n        ],\n        \"name\": \"cancelRequest\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"clearIdentity\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"identity\",\n        \"outputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isValid\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"uint32\",\n                                \"name\": \"registrarIndex\",\n                                \"type\": \"uint32\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isUnknown\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isFeePaid\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"uint256\",\n                                        \"name\": \"feePaidDeposit\",\n                                        \"type\": \"uint256\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isReasonable\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isKnownGood\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isOutOfDate\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isLowQuality\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"isErroneous\",\n                                        \"type\": \"bool\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Judgement\",\n                                \"name\": \"judgement\",\n                                \"type\": \"tuple\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.JudgementInfo[]\",\n                        \"name\": \"judgements\",\n                        \"type\": \"tuple[]\"\n                    },\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"deposit\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"components\": [\n                                    {\n                                        \"components\": [\n                                            {\n                                                \"internalType\": \"bool\",\n                                                \"name\": \"hasData\",\n                                                \"type\": \"bool\"\n                                            },\n                                            {\n                                                \"internalType\": \"bytes\",\n                                                \"name\": \"value\",\n                                                \"type\": \"bytes\"\n                                            }\n                                        ],\n                                        \"internalType\": \"struct Identity.Data\",\n                                        \"name\": \"key\",\n                                        \"type\": \"tuple\"\n                                    },\n                                    {\n                                        \"components\": [\n                                            {\n                                                \"internalType\": \"bool\",\n                                                \"name\": \"hasData\",\n                                                \"type\": \"bool\"\n                                            },\n                                            {\n                                                \"internalType\": \"bytes\",\n                                                \"name\": \"value\",\n                                                \"type\": \"bytes\"\n                                            }\n                                        ],\n                                        \"internalType\": \"struct Identity.Data\",\n                                        \"name\": \"value\",\n                                        \"type\": \"tuple\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Additional[]\",\n                                \"name\": \"additional\",\n                                \"type\": \"tuple[]\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"display\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"legal\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"web\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"riot\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"email\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasPgpFingerprint\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"pgpFingerprint\",\n                                \"type\": \"bytes\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"image\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"twitter\",\n                                \"type\": \"tuple\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.IdentityInfo\",\n                        \"name\": \"info\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Registration\",\n                \"name\": \"\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"target\",\n                \"type\": \"address\"\n            },\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isUnknown\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isFeePaid\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"feePaidDeposit\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isReasonable\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isKnownGood\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isOutOfDate\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isLowQuality\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isErroneous\",\n                        \"type\": \"bool\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Judgement\",\n                \"name\": \"judgement\",\n                \"type\": \"tuple\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"identity\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"provideJudgement\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"quitSub\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"registrars\",\n        \"outputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isValid\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"uint32\",\n                        \"name\": \"index\",\n                        \"type\": \"uint32\"\n                    },\n                    {\n                        \"internalType\": \"address\",\n                        \"name\": \"account\",\n                        \"type\": \"address\"\n                    },\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"fee\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"display\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"legal\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"web\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"riot\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"email\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"pgpFingerprint\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"image\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"twitter\",\n                                \"type\": \"bool\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.IdentityFields\",\n                        \"name\": \"fields\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Registrar[]\",\n                \"name\": \"\",\n                \"type\": \"tuple[]\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"removeSub\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"sub\",\n                \"type\": \"address\"\n            },\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"hasData\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bytes\",\n                        \"name\": \"value\",\n                        \"type\": \"bytes\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.Data\",\n                \"name\": \"data\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"name\": \"renameSub\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"maxFee\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"requestJudgement\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"newAccount\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"setAccountId\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"fee\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"setFee\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"regIndex\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"display\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"legal\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"web\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"riot\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"email\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"pgpFingerprint\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"image\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"twitter\",\n                        \"type\": \"bool\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.IdentityFields\",\n                \"name\": \"fields\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"name\": \"setFields\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"components\": [\n                    {\n                        \"components\": [\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"key\",\n                                \"type\": \"tuple\"\n                            },\n                            {\n                                \"components\": [\n                                    {\n                                        \"internalType\": \"bool\",\n                                        \"name\": \"hasData\",\n                                        \"type\": \"bool\"\n                                    },\n                                    {\n                                        \"internalType\": \"bytes\",\n                                        \"name\": \"value\",\n                                        \"type\": \"bytes\"\n                                    }\n                                ],\n                                \"internalType\": \"struct Identity.Data\",\n                                \"name\": \"value\",\n                                \"type\": \"tuple\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Additional[]\",\n                        \"name\": \"additional\",\n                        \"type\": \"tuple[]\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"display\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"legal\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"web\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"riot\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"email\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"hasPgpFingerprint\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"bytes\",\n                        \"name\": \"pgpFingerprint\",\n                        \"type\": \"bytes\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"image\",\n                        \"type\": \"tuple\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"twitter\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.IdentityInfo\",\n                \"name\": \"info\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"name\": \"setIdentity\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"address\",\n                        \"name\": \"account\",\n                        \"type\": \"address\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"data\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.SubAccount[]\",\n                \"name\": \"subs\",\n                \"type\": \"tuple[]\"\n            }\n        ],\n        \"name\": \"setSubs\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"subsOf\",\n        \"outputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"deposit\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"internalType\": \"address[]\",\n                        \"name\": \"accounts\",\n                        \"type\": \"address[]\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.SubsOf\",\n                \"name\": \"\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"who\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"superOf\",\n        \"outputs\": [\n            {\n                \"components\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"isValid\",\n                        \"type\": \"bool\"\n                    },\n                    {\n                        \"internalType\": \"address\",\n                        \"name\": \"account\",\n                        \"type\": \"address\"\n                    },\n                    {\n                        \"components\": [\n                            {\n                                \"internalType\": \"bool\",\n                                \"name\": \"hasData\",\n                                \"type\": \"bool\"\n                            },\n                            {\n                                \"internalType\": \"bytes\",\n                                \"name\": \"value\",\n                                \"type\": \"bytes\"\n                            }\n                        ],\n                        \"internalType\": \"struct Identity.Data\",\n                        \"name\": \"data\",\n                        \"type\": \"tuple\"\n                    }\n                ],\n                \"internalType\": \"struct Identity.SuperOf\",\n                \"name\": \"\",\n                \"type\": \"tuple\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    }\n]\n</code></pre> <p>Once you have the ABI, you can interact with the precompile using the Ethereum library of your choice. Generally speaking, you'll take the following steps:</p> <ol> <li>Create a provider</li> <li>Create a contract instance of the Identity Precompile</li> <li>Interact with the Identity Precompile's functions</li> </ol> <p>In the examples below, you'll learn how to assemble the data required to set an identity, how to set an identity, and how to retrieve the identity information once it's been set.</p> <p>Remember</p> <p>The following snippets are for demo purposes only. Never store your private keys in a JavaScript or Python file.</p> Ethers.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport ABI from './identityPrecompileABI.js'; // Import Identity Precompile ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst identityPrecompileAddress = '0x0000000000000000000000000000000000000818';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n// Create interface for the Identity Precompile\nconst identityPrecompile = new ethers.Contract(\n  identityPrecompileAddress,\n  ABI,\n  signer\n);\n\n// Interact with the Precompile Registry\nconst setIdentity = async () =&gt; {\n  // Assemble identity info\n  const identityInfo = {\n    additional: [],\n    display: {\n      hasData: true,\n      value: '0x416c696365', // Alice in hex\n    },\n    legal: {\n      hasData: false,\n      value: '0x',\n    },\n    web: {\n      hasData: false,\n      value: '0x',\n    },\n    riot: {\n      hasData: false,\n      value: '0x',\n    },\n    email: {\n      hasData: false,\n      value: '0x',\n    },\n    hasPgpFingerprint: false,\n    pgpFingerprint: '0x',\n    image: {\n      hasData: false,\n      value: '0x',\n    },\n    twitter: {\n      hasData: false,\n      value: '0x',\n    },\n  };\n\n  // Set the identity\n  const submitIdentity = await identityPrecompile.setIdentity(identityInfo);\n  console.log(`Identity set. Transaction hash: ${submitIdentity.hash}`);\n\n  // Retrieve the identity\n  const identity = await identityPrecompile.identity(signer.address);\n  console.log(`Identity is valid: ${identity[0]}`);\n  console.log(`Judgements provided for this identity: ${identity[1]}`);\n  console.log(`Deposit paid for this identity: ${identity[2]}`);\n  console.log(`Identity information: ${identity[3]}`);\n  console.log(`Display name: ${ethers.toUtf8String(identity[3][1][1])}`);\n};\n\nsetIdentity();\n</code></pre> <pre><code>from web3 import Web3\n\n# Paste or import the Identity Precompile ABI\nabi = \"INSERT_IDENTITY_PRECOMPILE_ABI\"\naccount_from = {\n    \"private_key\": \"INSERT_PRIVATE_KEY\",\n    \"address\": \"INSERT_ADDRESS\",\n}\nidentity_precompile_address = \"0x0000000000000000000000000000000000000818\"\n\n# Create provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create interface for the Precompile Registry\nidentity_precompile = web3.eth.contract(address=identity_precompile_address, abi=abi)\n\n\ndef set_identity():\n    # Assemble identity info\n    identity_info = {\n        \"additional\": [],\n        \"display\": {\n            \"hasData\": True,\n            \"value\": \"0x416c696365\",  # Alice in hex\n        },\n        \"legal\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"web\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"riot\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"email\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"hasPgpFingerprint\": False,\n        \"pgpFingerprint\": \"0x\",\n        \"image\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n        \"twitter\": {\n            \"hasData\": False,\n            \"value\": \"0x\",\n        },\n    }\n\n    # Set the identity\n    submit_identity = identity_precompile.functions.setIdentity(\n        identity_info\n    ).build_transaction(\n        {\n            \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n            \"nonce\": web3.eth.get_transaction_count(\n                Web3.to_checksum_address(account_from[\"address\"])\n            ),\n        }\n    )\n    # Sign and send the transaction to set the identity\n    tx_create = web3.eth.account.sign_transaction(\n        submit_identity, account_from[\"private_key\"]\n    )\n    tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\n    tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n    print(f\"Identity set. Transaction hash: { tx_receipt.transactionHash.hex() }\")\n\n    # Retrieve the identity\n    identity = identity_precompile.functions.identity(account_from[\"address\"]).call()\n    print(f\"Identity is valid: { identity[0] }\")\n    print(f\"Judgements provided for this identity: { identity[1] }\")\n    print(f\"Deposit paid for this identity: { identity[2] }\")\n    print(f\"Identity information: { identity[3] }\")\n    print(f\"Display name: { web3.to_text(identity[3][1][1]) }\")\n\n\nset_identity()\n</code></pre>"},{"location":"builders/ethereum/precompiles/account/proxy/","title":"Interacting with the Proxy Precompile","text":""},{"location":"builders/ethereum/precompiles/account/proxy/#introduction","title":"Introduction","text":"<p>The Proxy Precompile on Moonbeam allows accounts to set proxy accounts that can perform specific limited actions on their behalf, such as governance, staking, or balance transfers.</p> <p>If a user wants to provide a second user access to a limited number of actions on their behalf, traditionally the only method to do so would be by providing the first account's private key to the second. However, Moonbeam includes native proxy functionality in the runtime, which enables proxy accounts. Proxy accounts should be used due to the additional layer of security that they provide, where many accounts can perform actions for a main account. This is best if, for example, a user wants to keep their wallet safe in cold storage but still wants to access parts of the wallet's functionality like governance or staking.</p> <p>The Proxy Precompile can only be called from an Externally Owned Account (EOA) or by the Batch Precompile.</p> <p>To learn more about proxy accounts and how to set them up for your own purposes without use of the Proxy Precompile, view the Setting up a Proxy Account page.</p> <p>The Proxy Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x000000000000000000000000000000000000080b\n</code></pre> <pre><code>0x000000000000000000000000000000000000080b\n</code></pre> <pre><code>0x000000000000000000000000000000000000080b\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/account/proxy/#the-proxy-solidity-interface","title":"The Proxy Solidity Interface","text":"<p><code>Proxy.sol</code> is an interface through which Solidity contracts can interact with the Proxy Pallet. You do not have to be familiar with the Substrate API since you can interact with it using the Ethereum interface you're familiar with.</p> <p>The interface includes the following functions:</p> addProxy(address delegate, ProxyType proxyType, uint32 delay) - registers a proxy account for the sender after a specified number of <code>delay</code> blocks (generally zero). Will fail if a proxy for the caller already exists Parameters <ul> <li><code>delegate</code> - address of the account to be registered as a proxy</li> <li><code>proxyType</code> - ProxyType enumeration specifying the type of proxy to be registered</li> <li><code>delay</code> - uint32 number of blocks before the proxy registration becomes active</li> </ul> removeProxy(address delegate, ProxyType proxyType, uint32 delay) - removes a registered proxy for the sender Parameters <ul> <li><code>delegate</code> - address of the proxy account to be removed</li> <li><code>proxyType</code> - ProxyType enumeration of the proxy type to be removed</li> <li><code>delay</code> - uint32 delay value of the proxy to be removed</li> </ul> removeProxies() - removes all of the proxy accounts delegated to the sender Parameters <p>None.</p> proxy(address real, address callTo, bytes callData) - dispatches <code>callData</code> to <code>callTo</code> on behalf of <code>real</code> using the caller's registered proxy rights Parameters <ul> <li><code>real</code> - address of the account the call will be executed for</li> <li><code>callTo</code> - address receiving the proxied call (subject to dispatch limitations)</li> <li><code>callData</code> - call data to forward to the destination</li> </ul> proxyForceType(address real, ProxyType forceProxyType, address callTo, bytes callData) - dispatches <code>callData</code> on behalf of <code>real</code> while enforcing the provided proxy type instead of inferring it Parameters <ul> <li><code>real</code> - address of the account the call will be executed for</li> <li><code>forceProxyType</code> - ProxyType value that must match the caller's registered proxy type</li> <li><code>callTo</code> - address receiving the proxied call (subject to dispatch limitations)</li> <li><code>callData</code> - call data to forward to the destination</li> </ul> isProxy(address real, address delegate, ProxyType proxyType, uint32 delay) - returns a boolean, <code>true</code> if the delegate address is a proxy of type <code>proxyType</code>, for address <code>real</code>, with the specified <code>delay</code> Parameters <ul> <li><code>real</code> - address of the account that might be represented by the proxy</li> <li><code>delegate</code> - address of the potential proxy account</li> <li><code>proxyType</code> - ProxyType enumeration of the proxy type to check</li> <li><code>delay</code> - uint32 delay value to check</li> </ul> <p>The <code>proxyType</code> parameter is defined by the following <code>ProxyType</code> enum, where the values start at <code>0</code> with the most permissive proxy type and are represented as <code>uint8</code> values:</p> <pre><code>enum ProxyType {\n    Any,\n    NonTransfer,\n    Governance,\n    Staking,\n    CancelProxy,\n    Balances,\n    AuthorMapping,\n    IdentityJudgement\n}\n</code></pre>"},{"location":"builders/ethereum/precompiles/account/proxy/#proxy-types","title":"Proxy Types","text":"<p>There are multiple types of proxy roles that can be delegated to accounts, which are represented in <code>Proxy.sol</code> through the <code>ProxyType</code> enum. The following list includes all of the possible proxies and the type of transactions they can make on behalf of the primary account:</p> <ul> <li>Any \u2014 allows the proxy account to dispatch the <code>Governance</code>, <code>Staking</code>, <code>Balances</code>, and <code>AuthorMapping</code> actions permitted by the runtime filter; arbitrary smart contract targets are not allowed, and balance transfers are limited to EOAs without contract code</li> <li>NonTransfer \u2014 allows transactions through the <code>Governance</code>, <code>Staking</code> and <code>AuthorMapping</code> precompiles, where the <code>msg.value</code> is checked to be zero; no contract calls outside those precompiles are permitted</li> <li>Governance - the governance proxy will allow the proxy account to make any type of governance related transaction (includes both democracy or council pallets)</li> <li>Staking - the staking proxy will allow the proxy account to make staking related transactions through the <code>Staking</code> Precompile, including calls to the <code>AuthorMapping</code> Precompile</li> <li>CancelProxy - the cancel proxy will allow the proxy account to reject and remove delayed proxy announcements (of the primary account). Currently, this is not an action supported by the Proxy Precompile</li> <li>Balances - allows only plain balance transfers to EOAs with no contract code and does not support calling contracts or precompiles</li> <li>AuthorMapping - this type of proxy account is used by collators to migrate services from one server to another</li> <li>IdentityJudgement - the identity judgement proxy will allow the proxy account to judge and certify the personal information associated with accounts on Polkadot. Currently, this is not an action supported by the Proxy Precompile</li> </ul>"},{"location":"builders/ethereum/precompiles/account/proxy/#proxy-dispatch-limitations","title":"Proxy Dispatch Limitations","text":"<p>Moonbeam applies an EVM call filter to proxy dispatches. The key rules are as follows:</p> <ul> <li>Only EOAs (or the Batch Precompile) can call the Proxy Precompile; contracts cannot</li> <li>Not a general \u201ccall any contract as the real account\u201d path\u2014non-precompile contract calls are rejected</li> <li>Governance, Staking, and AuthorMapping calls must target their respective precompiles with <code>msg.value = 0</code></li> <li>Balances proxy calls only allow plain value transfers to EOAs with no contract code (not to contracts or precompiles)</li> <li><code>CancelProxy</code> is not dispatched through the Proxy Precompile</li> </ul>"},{"location":"builders/ethereum/precompiles/account/proxy/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":"<p>The following section will cover how to interact with the Proxy Precompile from Remix. Please note that the Proxy Precompile can only be called from an EOA or by the Batch Precompile.</p>"},{"location":"builders/ethereum/precompiles/account/proxy/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The below example is demonstrated on Moonbase Alpha, however, similar steps can be taken for Moonbeam and Moonriver. You should:  </p> <ul> <li>Have MetaMask installed and connected to Moonbase Alpha</li> <li>Have an account with some DEV tokens.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>Have a second account that you control to use as a proxy account (funding optional)</li> </ul>"},{"location":"builders/ethereum/precompiles/account/proxy/#remix-set-up","title":"Remix Set Up","text":"<p>To get started, get a copy of <code>Proxy.sol</code> and take the following steps:</p> <ol> <li>Click on the File explorer tab</li> <li>Copy and paste the file contents into a Remix file named <code>Proxy.sol</code></li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/account/proxy/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile Proxy.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/account/proxy/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure Proxy.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the Precompile in the At Address field</li> <li>Provide the address of the Proxy Precompile for Moonbase Alpha: <code>0x000000000000000000000000000000000000080b</code> and click At Address</li> <li>The Proxy Precompile will appear in the list of Deployed Contracts</li> </ol>"},{"location":"builders/ethereum/precompiles/account/proxy/#add-proxy","title":"Add a Proxy","text":"<p>You can add a proxy for your account via the Proxy Precompile if your account doesn't already have a proxy. In this example, you will add a balances proxy to an account by taking the following steps:</p> <ol> <li>Expand the Proxy Precompile contract to see the available functions</li> <li>Find the addProxy function and press the button to expand the section</li> <li>Insert your second account's address as the delegate, <code>5</code> as proxyType, and <code>0</code> as delay</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p>Note</p> <p>When constructing the transaction in Remix, the proxyType is represented as a <code>uint8</code>, instead of the expected enum <code>ProxyType</code>. In Solidity, enums are compiled as <code>uint8</code>, so when you pass in <code>5</code> for proxyType, you indicate the sixth element in the <code>ProxyType</code> enum, which is the balances proxy.</p> <p></p>"},{"location":"builders/ethereum/precompiles/account/proxy/#check-proxy","title":"Check a Proxy's Existence","text":"<p>You can determine whether or not an account is a proxy account for a primary account. In this example, you will insert the parameters of the previously added proxy to determine if the proxy account was successfully added:</p> <ol> <li>Find the isProxy function and press the button to expand the section</li> <li>Insert your primary account's address as real, your second account's address as delegate, <code>5</code> as proxyType, and <code>0</code> as delay</li> <li>Press call</li> </ol> <p>If everything went correctly, the output should be <code>true</code>.</p> <p></p>"},{"location":"builders/ethereum/precompiles/account/proxy/#dispatch-proxy-call","title":"Dispatch a Proxy Call","text":"<p>Once you've registered a proxy, you can forward a call on behalf of the real account. In Remix, expand the Proxy Precompile contract and open proxy (or proxyForceType if you want to force the proxy type). The following example will use a Balances proxy (or <code>Any</code> with Balances allowed) to send value to an EOA with no contract code, keeping <code>callData</code> as <code>0x</code> for a plain transfer. Remember that the runtime limits described in Proxy Dispatch Limitations apply.</p> <p>Ensure MetaMask is connected to the delegate/proxy account (the one authorized via <code>addProxy</code>), not the primary account, before dispatching. Then, take the following steps:</p> <ol> <li>In Remix, set the amount to send in the VALUE field. Double-check the VALUE units (wei vs ether) before sending. </li> <li>Enter the address of the account being proxied.</li> <li>Enter the callTo address (this is the receiving account).</li> <li>Enter <code>0x</code> for call data.</li> <li>Press Transact to dispatch the call.</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/account/proxy/#remove-proxy","title":"Remove a Proxy","text":"<p>You can remove a proxy from your account via the Proxy Precompile. In this example, you will remove the balances proxy previously added to your delegate account by taking the following steps:</p> <ol> <li>Expand the Proxy Precompile contract to see the available functions</li> <li>Find the removeProxy function and press the button to expand the section</li> <li>Insert your second account's address as the delegate, <code>5</code> as proxyType, <code>0</code> and as delay</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p>After the transaction is confirmed, if you repeat the steps to check for a proxy's existence, the result should be <code>false</code>.</p> <p></p> <p>And that's it! You've completed your introduction to the Proxy Precompile. Additional information on setting up proxies is available on the Setting up a Proxy Account page and the Proxy Accounts page on Polkadot's documentation. Feel free to reach out on Discord if you have any questions about any aspect of the Proxy Precompile.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/","title":"Interacting with the Randomness Precompile","text":""},{"location":"builders/ethereum/precompiles/features/randomness/#introduction","title":"Introduction","text":"<p>Moonbeam utilizes verifiable random functions (VRF) to generate randomness that can be verified on-chain. A VRF is a cryptographic function that takes some input and produces random values, along with a proof of authenticity that these random values were generated by the submitter. The proof can be verified by anyone to ensure the random values generated were calculated correctly.</p> <p>There are two available sources of randomness that provide random inputs based on block producers' VRF keys and past randomness results: local VRF and BABE epoch randomness. Local VRF is determined directly within Moonbeam using the collator of the block's VRF key and the last block's VRF output. On the other hand, BABE epoch randomness is based on all the VRF produced by the relay chain validators during a complete epoch.</p> <p>For more information on the two sources of randomness, how the request and fulfillment process works, and security considerations, please refer to the Randomness on Moonbeam page.</p> <p>Moonbeam provides a randomness precompile, which is a Solidity interface that enables smart contract developers to generate randomness via local VRF or BABE epoch randomness using the Ethereum API. Moonbeam also provides a randomness consumer Solidity contract that your contract must inherit from in order to consume fulfilled randomness requests.</p> <p>This guide will show you how to use the randomness precompile and randomness consumer contract to create a lottery where the winners will randomly be selected. You'll also learn how to interact with the randomness precompile directly to perform actions such as purging an expired randomness request.</p> <p>The randomness precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000809\n</code></pre> <pre><code>0x0000000000000000000000000000000000000809\n</code></pre> <pre><code>0x0000000000000000000000000000000000000809\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#the-randomness-interface","title":"The Randomness Solidity Interface","text":"<p>Randomness.sol is a Solidity interface that allows developers to interact with the precompile's methods.</p> Randomness.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Randomness contract's address.\naddress constant RANDOMNESS_ADDRESS = 0x0000000000000000000000000000000000000809;\n\n/// @dev The Randomness contract's instance.\nRandomness constant RANDOMNESS_CONTRACT = Randomness(RANDOMNESS_ADDRESS);\n\n/// @dev Maximum number of random words being requested\nuint32 constant MAX_RANDOM_WORDS = 100;\n/// @dev Minimum number of blocks before a request can be fulfilled for Local VRF Request\nuint32 constant MIN_VRF_BLOCKS_DELAY = 2;\n/// @dev Maximum number of blocks before a request can be fulfilled for Local VRF Request\nuint32 constant MAX_VRF_BLOCKS_DELAY = 2000;\n/// @dev The deposit amount needed to request random words. There is 1 deposit per request\nuint256 constant REQUEST_DEPOSIT_AMOUNT = 1000000000000000000;\n\n/// @author The Moonbeam Team\n/// @title Pallet Randomness Interface\n/// @dev The interface through which solidity contracts will interact with Randomness\n/// @custom:address 0x0000000000000000000000000000000000000809\ninterface Randomness {\n    /// @notice Event emitted when the request has been successfully executed\n    event FulFillmentSucceeded();\n    /// @notice Event emitted when the request has failed to execute fulfillment\n    event FulFillmentFailed();\n\n    /// @notice The status of the request\n    /// @param DoesNotExist The request doesn't exist\n    /// @param Pending The request cannot be fulfilled yet\n    /// @param Ready The request is ready to be fulfilled\n    /// @param Expired The request has expired\n    enum RequestStatus {\n        DoesNotExist,\n        Pending,\n        Ready,\n        Expired\n    }\n\n    /// @notice The type of randomness source\n    /// @param LocalVRF Randomness VRF using the parachain material as seed\n    /// @param RelayBabeEpoch Randomness VRF using relay material from previous epoch\n    enum RandomnessSource {\n        LocalVRF,\n        RelayBabeEpoch\n    }\n\n    /// @notice The request details\n    /// @param id The id of the request (is always &lt; 2**64)\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param contractAddress The address of the contract being called back during fulfillment\n    /// @param fee The amount to set aside to pay for the fulfillment\n    /// @param gasLimit The gas limit to use for the fulfillment\n    /// @param salt A string being mixed with the randomness seed to obtain different random words. This should be as unique as possible; using the same salt will lead to same randomness result.\n    /// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n    /// @param randomnessSource The type of randomness source used to generate the random words\n    /// @param fulfillmentBlock The parachain block number at which the request can be fulfilled (for LocalVRF only)\n    /// @param fulfillmentEpochIndex The relay epoch index at which the request can be fulfilled (for RelayBabeEpoch)\n    /// @param expirationBlock The parachain block number at which the request expires (for LocalVRF only)\n    /// @param expirationEpochIndex The relay epoch index at which the request expires (for RelayBabeEpoch)\n    /// @param status The current status of the request\n    struct Request {\n        uint256 id;\n        address refundAddress;\n        address contractAddress;\n        uint256 fee;\n        uint256 gasLimit;\n        bytes32 salt;\n        uint32 numWords;\n        RandomnessSource randomnessSource;\n        uint32 fulfillmentBlock;\n        uint64 fulfillmentEpochIndex;\n        uint32 expirationBlock;\n        uint64 expirationEpochIndex;\n        RequestStatus status;\n    }\n\n    /// Return the current relay epoch index\n    /// @dev An epoch represents real time and not a block number\n    /// @dev Currently, time between epoch changes cannot be longer than:\n    /// @dev  - Kusama/Westend/Rococo: 600 relay blocks (1 hour)\n    /// @dev  - Polkadot: 2400 relay blocks (4 hours)\n    /// @custom:selector 81797566\n    function relayEpochIndex() external view returns (uint64);\n\n    /// Return the deposit required to perform a request\n    /// @dev Each request will need a deposit.\n    /// @custom:selector fb7cfdd7\n    function requiredDeposit() external view returns (uint256);\n\n    /// @notice Returns the request status\n    /// @param requestId The id of the request to check (must be &lt; 2**64)\n    /// @return status Status of the request\n    /// @custom:selector d8a4676f\n    function getRequestStatus(uint256 requestId)\n        external\n        view\n        returns (RequestStatus status);\n\n    /// @notice Returns the request or revert\n    /// @param requestId The id of the request to check (must be &lt; 2**64)\n    /// @return request The request\n    /// @custom:selector c58343ef\n    function getRequest(uint256 requestId)\n        external\n        view\n        returns (Request memory request);\n\n    /// @notice Request random words generated from the parachain VRF\n    /// @dev This is using pseudo-random VRF executed by the collator at the fulfillment\n    /// @dev Warning:\n    /// @dev The collator in charge of producing the block at fulfillment can decide to skip\n    /// @dev producing the block in order to have a different random word generated by the next\n    /// @dev collator, at the cost of a block reward. It is therefore economically viable to use\n    /// @dev this randomness source only if the financial reward at stake is lower than the block\n    /// @dev reward.\n    /// @dev In order to reduce the risk of a collator being able to predict the random words\n    /// @dev when the request is performed, it is possible to increase the delay to multiple blocks\n    /// @dev The higher the delay is, the less likely the collator will be able to know which\n    /// @dev collator will be in charge of fulfilling the request.\n    /// @dev Fulfillment is manual and can be executed by anyone (for free) after the given delay\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param fee The amount to set aside to pay for the fulfillment\n    /// @param gasLimit The gas limit to use for the fulfillment\n    /// @param salt A string being mixed with the randomness seed to obtain different random words\n    /// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n    /// @param delay The number of blocks until the request can be fulfilled (between MIN_DELAY_BLOCKS and MAX_DELAY_BLOCKS)\n    /// @return requestId The id of the request requestLocalVRFRandomWords\n    /// @custom:selector 9478430c\n    function requestLocalVRFRandomWords(\n        address refundAddress,\n        uint256 fee,\n        uint64 gasLimit,\n        bytes32 salt,\n        uint8 numWords,\n        uint64 delay\n    ) external returns (uint256);\n\n    /// @notice Request random words generated from the relaychain Babe consensus\n    /// @dev The random words are generated from the hash of the all the VRF provided by the\n    /// @dev relaychain validator during 1 epoch.\n    /// @dev It requires a delay of at least 1 epoch after the current epoch to be unpredictable\n    /// @dev at the time the request is performed.\n    /// @dev Warning:\n    /// @dev The validator (on the relaychain) of the last block of an epoch can decide to skip\n    /// @dev producing the block in order to choose the previous generated epoch random number\n    /// @dev at the cost of a relaychain block rewards. It is therefore economically viable to use\n    /// @dev this randomness source only if the financial reward at stake is lower than the relaychain\n    /// @dev block reward.\n    /// @dev (see https://crates.parity.io/pallet_babe/struct.RandomnessFromOneEpochAgo.html)\n    /// @dev Fulfillment is manual and can be executed by anyone (for free) at\n    /// @dev the beginning of the 2nd relay epoch following the current one\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param fee Amount to set aside to pay for the fulfillment. Those fees are taken from the contract\n    /// @param gasLimit Gas limit for the fulfillment\n    /// @param salt Salt to be mixed with raw randomness to get output\n    /// @param numWords Number of random words to be returned (limited to MAX_RANDOM_WORDS)\n    /// @return requestId The id of the request\n    /// @custom:selector 33c14a63\n    function requestRelayBabeEpochRandomWords(\n        address refundAddress,\n        uint256 fee,\n        uint64 gasLimit,\n        bytes32 salt,\n        uint8 numWords\n    ) external returns (uint256);\n\n    /// @dev fulFill the request which will call the contract method \"fulfillRandomWords\"\n    /// @dev Fees of the caller are refunded if the request is fulfillable\n    /// @param requestId Request to be fulfilled (must be &lt; 2**64)\n    /// @custom:selector 9a91eb0d\n    function fulfillRequest(uint256 requestId) external;\n\n    /// @param requestId Request receiving the additional fees (must be &lt; 2**64)\n    /// @param feeIncrease Amount to increase\n    /// @custom:selector d0408a7f\n    function increaseRequestFee(uint256 requestId, uint256 feeIncrease)\n        external;\n\n    /// @param requestId Request to be purged (must be &lt; 2**64)\n    /// @custom:selector 1d26cbab\n    function purgeExpiredRequest(uint256 requestId) external;\n}\n</code></pre> <p>The interface includes functions, constants, events, and enums, as covered in the following sections.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#functions","title":"Functions","text":"<p>The interface includes the following functions:</p> relayEpochIndex() - returns the current relay epoch index, where an epoch represents real time and not a block number ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> current relay epoch index</li> </ul> requiredDeposit() - returns the deposit required to perform a randomness request ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> required deposit amount</li> </ul> getRequestStatus(uint256 requestId) - returns the request status of a given randomness request ParametersReturns <ul> <li><code>requestId</code> - uint256 ID of the randomness request</li> </ul> <ul> <li><code>uint8</code> status code of the request</li> </ul> getRequest(uint256 requestId) - returns the request details of a given randomness request ParametersReturns <ul> <li><code>requestId</code> - uint256 ID of the randomness request</li> </ul> <ul> <li><code>bool</code> whether the request is ready or not</li> <li><code>bool</code> whether the request is expired or not</li> <li><code>uint256</code> deposit amount</li> <li><code>uint256</code> fee amount</li> </ul> requestLocalVRFRandomWords(address refundAddress, uint256 fee, uint64 gasLimit, bytes32 salt, uint8 numWords, uint64 delay) - request random words generated from the parachain VRF ParametersReturns <ul> <li><code>refundAddress</code> - address receiving the left-over fees after the fulfillment</li> <li><code>fee</code> - uint256 amount to set aside to pay for the fulfillment</li> <li><code>gasLimit</code> - uint64 gas limit to use for the fulfillment</li> <li><code>salt</code> - bytes32 string that is mixed with the randomness seed to obtain different random words</li> <li><code>numWords</code> - uint8 number of random words requested, up to the maximum number of random words</li> <li><code>delay</code> - uint64 number of blocks that must pass before the request can be fulfilled. This value will need to be between the minimum and maximum number of blocks before a local VRF request can be fulfilled</li> </ul> <ul> <li><code>uint256</code> ID of the created request</li> </ul> requestRelayBabeEpochRandomWords(address refundAddress, uint256 fee, uint64 gasLimit, bytes32 salt, uint8 numWords) - request random words generated from the relay chain BABE consensus ParametersReturns <ul> <li><code>refundAddress</code> - address receiving the left-over fees after the fulfillment</li> <li><code>fee</code> - uint256 amount to set aside to pay for the fulfillment</li> <li><code>gasLimit</code> - uint64 gas limit to use for the fulfillment</li> <li><code>salt</code> - bytes32 string that is mixed with the randomness seed to obtain different random words</li> <li><code>numWords</code> - uint8 number of random words requested, up to the maximum number of random words</li> </ul> <ul> <li><code>uint256</code> ID of the created request</li> </ul> fulfillRequest(uint256 requestId) - fulfill the request which will call the consumer contract method <code>fulfillRandomWords</code>. Fees of the caller are refunded if the request is fulfillable ParametersReturns <ul> <li><code>requestId</code> - uint256 ID of the randomness request</li> </ul> <p>None.</p> increaseRequestFee(uint256 requestId, uint256 feeIncrease) - increases the fee associated with a given randomness request. This is needed if the gas price increases significantly before the request is fulfilled ParametersReturns <ul> <li><code>requestId</code> - uint256 ID of the randomness request</li> <li><code>feeIncrease</code> - uint256 amount to increase fees by</li> </ul> <p>None.</p> purgeExpiredRequest(uint256 requestId) - removes a given expired request from storage and transfers the request fees to the caller and the deposit back to the original requester ParametersReturns <ul> <li><code>requestId</code> - uint256 ID of the randomness request</li> </ul> <p>None.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#constants","title":"Constants","text":"<p>The interface includes the following constants:</p> <ul> <li>maxRandomWords - the maximum number of random words being requested</li> <li>minBlockDelay - the minimum number of blocks before a request can be fulfilled for local VRF requests</li> <li>maxBlockDelay - the maximum number of blocks before a request can be fulfilled for local VRF requests</li> <li>deposit - the deposit amount needed to request random words. There is one deposit per request</li> </ul> MoonbeamMoonriverMoonbase Alpha Variable Value MAX_RANDOM_WORDS 100 words MIN_VRF_BLOCKS_DELAY 2 blocks MAX_VRF_BLOCKS_DELAY 2000 blocks REQUEST_DEPOSIT_AMOUNT 100 GLMR Variable Value MAX_RANDOM_WORDS 100 words MIN_VRF_BLOCKS_DELAY 2 blocks MAX_VRF_BLOCKS_DELAY 2000 blocks REQUEST_DEPOSIT_AMOUNT 1 MOVR Variable Value MAX_RANDOM_WORDS 100 words MIN_VRF_BLOCKS_DELAY 2 blocks MAX_VRF_BLOCKS_DELAY 2000 blocks REQUEST_DEPOSIT_AMOUNT 1 DEV"},{"location":"builders/ethereum/precompiles/features/randomness/#events","title":"Events","text":"<p>The interface includes the following events:</p> <ul> <li>FulfillmentSucceeded() - emitted when the request has been successfully executed</li> <li>FulfillmentFailed() - emitted when the request has failed to execute fulfillment</li> </ul>"},{"location":"builders/ethereum/precompiles/features/randomness/#enums","title":"Enums","text":"<p>The interface includes the following enums:</p> <ul> <li>RequestStatus - the status of the request, which can be <code>DoesNotExist</code> (0), <code>Pending</code> (1), <code>Ready</code> (2), or <code>Expired</code> (3)</li> <li>RandomnessSource - the type of the randomness source, which can be <code>LocalVRF</code> (0) or <code>RelayBabeEpoch</code> (1)</li> </ul>"},{"location":"builders/ethereum/precompiles/features/randomness/#randomness-consumer-solidity-interface","title":"The Randomness Consumer Solidity Interface","text":"<p>The <code>RandomnessConsumer.sol</code> Solidity interface makes it easy for smart contracts to interact with the randomness precompile. Using the randomness consumer ensures the fulfillment comes from the randomness precompile.</p> RandomnessConsumer.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Randomness contract's address.\naddress constant RANDOMNESS_ADDRESS = 0x0000000000000000000000000000000000000809;\n\n/// @dev The Randomness contract's instance.\nRandomness constant RANDOMNESS_CONTRACT = Randomness(RANDOMNESS_ADDRESS);\n\n/// @dev Maximum number of random words being requested\nuint32 constant MAX_RANDOM_WORDS = 100;\n/// @dev Minimum number of blocks before a request can be fulfilled for Local VRF Request\nuint32 constant MIN_VRF_BLOCKS_DELAY = 2;\n/// @dev Maximum number of blocks before a request can be fulfilled for Local VRF Request\nuint32 constant MAX_VRF_BLOCKS_DELAY = 2000;\n/// @dev The deposit amount needed to request random words. There is 1 deposit per request\nuint256 constant REQUEST_DEPOSIT_AMOUNT = 1000000000000000000;\n\n/// @author The Moonbeam Team\n/// @title Pallet Randomness Interface\n/// @dev The interface through which solidity contracts will interact with Randomness\n/// @custom:address 0x0000000000000000000000000000000000000809\ninterface Randomness {\n    /// @notice Event emitted when the request has been successfully executed\n    event FulFillmentSucceeded();\n    /// @notice Event emitted when the request has failed to execute fulfillment\n    event FulFillmentFailed();\n\n    /// @notice The status of the request\n    /// @param DoesNotExist The request doesn't exist\n    /// @param Pending The request cannot be fulfilled yet\n    /// @param Ready The request is ready to be fulfilled\n    /// @param Expired The request has expired\n    enum RequestStatus {\n        DoesNotExist,\n        Pending,\n        Ready,\n        Expired\n    }\n\n    /// @notice The type of randomness source\n    /// @param LocalVRF Randomness VRF using the parachain material as seed\n    /// @param RelayBabeEpoch Randomness VRF using relay material from previous epoch\n    enum RandomnessSource {\n        LocalVRF,\n        RelayBabeEpoch\n    }\n\n    /// @notice The request details\n    /// @param id The id of the request (is always &lt; 2**64)\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param contractAddress The address of the contract being called back during fulfillment\n    /// @param fee The amount to set aside to pay for the fulfillment\n    /// @param gasLimit The gas limit to use for the fulfillment\n    /// @param salt A string being mixed with the randomness seed to obtain different random words. This should be as unique as possible; using the same salt will lead to same randomness result.\n    /// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n    /// @param randomnessSource The type of randomness source used to generate the random words\n    /// @param fulfillmentBlock The parachain block number at which the request can be fulfilled (for LocalVRF only)\n    /// @param fulfillmentEpochIndex The relay epoch index at which the request can be fulfilled (for RelayBabeEpoch)\n    /// @param expirationBlock The parachain block number at which the request expires (for LocalVRF only)\n    /// @param expirationEpochIndex The relay epoch index at which the request expires (for RelayBabeEpoch)\n    /// @param status The current status of the request\n    struct Request {\n        uint256 id;\n        address refundAddress;\n        address contractAddress;\n        uint256 fee;\n        uint256 gasLimit;\n        bytes32 salt;\n        uint32 numWords;\n        RandomnessSource randomnessSource;\n        uint32 fulfillmentBlock;\n        uint64 fulfillmentEpochIndex;\n        uint32 expirationBlock;\n        uint64 expirationEpochIndex;\n        RequestStatus status;\n    }\n\n    /// Return the current relay epoch index\n    /// @dev An epoch represents real time and not a block number\n    /// @dev Currently, time between epoch changes cannot be longer than:\n    /// @dev  - Kusama/Westend/Rococo: 600 relay blocks (1 hour)\n    /// @dev  - Polkadot: 2400 relay blocks (4 hours)\n    /// @custom:selector 81797566\n    function relayEpochIndex() external view returns (uint64);\n\n    /// Return the deposit required to perform a request\n    /// @dev Each request will need a deposit.\n    /// @custom:selector fb7cfdd7\n    function requiredDeposit() external view returns (uint256);\n\n    /// @notice Returns the request status\n    /// @param requestId The id of the request to check (must be &lt; 2**64)\n    /// @return status Status of the request\n    /// @custom:selector d8a4676f\n    function getRequestStatus(uint256 requestId)\n        external\n        view\n        returns (RequestStatus status);\n\n    /// @notice Returns the request or revert\n    /// @param requestId The id of the request to check (must be &lt; 2**64)\n    /// @return request The request\n    /// @custom:selector c58343ef\n    function getRequest(uint256 requestId)\n        external\n        view\n        returns (Request memory request);\n\n    /// @notice Request random words generated from the parachain VRF\n    /// @dev This is using pseudo-random VRF executed by the collator at the fulfillment\n    /// @dev Warning:\n    /// @dev The collator in charge of producing the block at fulfillment can decide to skip\n    /// @dev producing the block in order to have a different random word generated by the next\n    /// @dev collator, at the cost of a block reward. It is therefore economically viable to use\n    /// @dev this randomness source only if the financial reward at stake is lower than the block\n    /// @dev reward.\n    /// @dev In order to reduce the risk of a collator being able to predict the random words\n    /// @dev when the request is performed, it is possible to increase the delay to multiple blocks\n    /// @dev The higher the delay is, the less likely the collator will be able to know which\n    /// @dev collator will be in charge of fulfilling the request.\n    /// @dev Fulfillment is manual and can be executed by anyone (for free) after the given delay\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param fee The amount to set aside to pay for the fulfillment\n    /// @param gasLimit The gas limit to use for the fulfillment\n    /// @param salt A string being mixed with the randomness seed to obtain different random words\n    /// @param numWords The number of random words requested (from 1 to MAX_RANDOM_WORDS)\n    /// @param delay The number of blocks until the request can be fulfilled (between MIN_DELAY_BLOCKS and MAX_DELAY_BLOCKS)\n    /// @return requestId The id of the request requestLocalVRFRandomWords\n    /// @custom:selector 9478430c\n    function requestLocalVRFRandomWords(\n        address refundAddress,\n        uint256 fee,\n        uint64 gasLimit,\n        bytes32 salt,\n        uint8 numWords,\n        uint64 delay\n    ) external returns (uint256);\n\n    /// @notice Request random words generated from the relaychain Babe consensus\n    /// @dev The random words are generated from the hash of the all the VRF provided by the\n    /// @dev relaychain validator during 1 epoch.\n    /// @dev It requires a delay of at least 1 epoch after the current epoch to be unpredictable\n    /// @dev at the time the request is performed.\n    /// @dev Warning:\n    /// @dev The validator (on the relaychain) of the last block of an epoch can decide to skip\n    /// @dev producing the block in order to choose the previous generated epoch random number\n    /// @dev at the cost of a relaychain block rewards. It is therefore economically viable to use\n    /// @dev this randomness source only if the financial reward at stake is lower than the relaychain\n    /// @dev block reward.\n    /// @dev (see https://crates.parity.io/pallet_babe/struct.RandomnessFromOneEpochAgo.html)\n    /// @dev Fulfillment is manual and can be executed by anyone (for free) at\n    /// @dev the beginning of the 2nd relay epoch following the current one\n    /// @param refundAddress The address receiving the left-over fees after the fulfillment\n    /// @param fee Amount to set aside to pay for the fulfillment. Those fees are taken from the contract\n    /// @param gasLimit Gas limit for the fulfillment\n    /// @param salt Salt to be mixed with raw randomness to get output\n    /// @param numWords Number of random words to be returned (limited to MAX_RANDOM_WORDS)\n    /// @return requestId The id of the request\n    /// @custom:selector 33c14a63\n    function requestRelayBabeEpochRandomWords(\n        address refundAddress,\n        uint256 fee,\n        uint64 gasLimit,\n        bytes32 salt,\n        uint8 numWords\n    ) external returns (uint256);\n\n    /// @dev fulFill the request which will call the contract method \"fulfillRandomWords\"\n    /// @dev Fees of the caller are refunded if the request is fulfillable\n    /// @param requestId Request to be fulfilled (must be &lt; 2**64)\n    /// @custom:selector 9a91eb0d\n    function fulfillRequest(uint256 requestId) external;\n\n    /// @param requestId Request receiving the additional fees (must be &lt; 2**64)\n    /// @param feeIncrease Amount to increase\n    /// @custom:selector d0408a7f\n    function increaseRequestFee(uint256 requestId, uint256 feeIncrease)\n        external;\n\n    /// @param requestId Request to be purged (must be &lt; 2**64)\n    /// @custom:selector 1d26cbab\n    function purgeExpiredRequest(uint256 requestId) external;\n}\n</code></pre> <p>The consumer interface includes the following functions:</p> <ul> <li>fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) - handles the VRF response for a given request. This method is triggered by a call to <code>rawFulfillRandomWords</code></li> <li>rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) - executed when the <code>fulfillRequest</code> function of the randomness precompile is called. The origin of the call is validated, ensuring the randomness precompile is the origin, and then the <code>fulfillRandomWords</code> method is called</li> </ul>"},{"location":"builders/ethereum/precompiles/features/randomness/#request-and-fulfill-process","title":"Request &amp; Fulfill Process","text":"<p>To consume randomness, you must have a contract that does the following:</p> <ul> <li>Imports the <code>Randomness.sol</code> precompile and <code>RandomnessConsumer.sol</code> interface</li> <li>Inherits from the <code>RandomnessConsumer.sol</code> interface</li> <li>Requests randomness through the precompile's <code>requestLocalVRFRandomWords</code> method or <code>requestRelayBabeEpochRandomWords</code> method, depending on the source of randomness you want to use</li> <li>Requests fulfillment through the precompile's <code>fulfillRequest</code> method</li> <li>Consumes randomness through a <code>fulfillRandomWords</code> method with the same signature as the <code>fulfillRandomWords</code> method of the <code>RandomnessConsumer.sol</code> contract</li> </ul> <p>When randomness is requested through the precompile's <code>requestLocalVRFRandomWords</code> or <code>requestRelayBabeEpochRandomWords</code> method, a fee is set aside to pay for the fulfillment of the request. When using local VRF, to increase unpredictability, a specified delay period (in blocks) must pass before the request can be fulfilled. At the very least, the delay period must be greater than one block. For BABE epoch randomness, you do not need to specify a delay but can fulfill the request at the beginning of the 2nd epoch following the current one.</p> <p>After the delay, fulfillment of the request can be manually executed by anyone through the <code>fulfillRequest</code> method using the fee that was initially set aside for the request.</p> <p>When fulfilling the randomness request via the precompile's <code>fulfillRequest</code> method, the <code>rawFulfillRandomWords</code> function in the <code>RandomnessConsumer.sol</code> contract will be called, which will verify that the sender is the randomness precompile. From there, <code>fulfillRandomWords</code> is called and the requested number of random words are computed using the current block's randomness result and a given salt and returned. If the fulfillment was successful, the <code>FulfillmentSucceeded</code> event will be emitted; otherwise the <code>FulfillmentFailed</code> event will be emitted.</p> <p>For fulfilled requests, the cost of execution will be refunded from the request fee to the caller of <code>fulfillRequest</code>. Then any excess fees and the request deposit are transferred to the specified refund address.</p> <p>Your contract's <code>fulfillRandomWords</code> callback is responsible for handling the fulfillment. For example, in a lottery contract, the callback would use the random words to choose a winner and payout the winnings.</p> <p>If a request expires it can be purged through the precompile's <code>purgeExpiredRequest</code> function. When this function is called the request fee is paid out to the caller and the deposit will be returned to the original requester.</p> <p>The happy path for a randomness request is shown in the following diagram:</p> <p></p>"},{"location":"builders/ethereum/precompiles/features/randomness/#interact-with-the-solidity-interfaces","title":"Generate a Random Number using the Randomness Precompile","text":"<p>In the following sections of this tutorial, you'll learn how to create a smart contract that generates a random number using the Randomness Precompile and the Randomness Consumer. If you want to just explore some of the functions of the Randomness Precompile, you can skip ahead to the Use Remix to Interact Directly with the Randomness Precompile section.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For this guide, you will need to have the following:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account funded with DEV tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/features/randomness/#create-random-generator-contract","title":"Create a Random Number Generator Contract","text":"<p>The contract that will be created in this section includes the functions that you'll need at a bare minimum to request randomness and consume the results from fulfilling randomness requests.</p> <p>This contract is for educational purposes only and is not meant for production use.</p> <p>The contract will include the following functions:</p> <ul> <li>A constructor that accepts the deposit required to request randomness</li> <li>A function that submits randomness requests. For this example, the source of randomness will be local VRF, but you can easily modify the contract to use BABE epoch randomness</li> <li>A function that fulfills the request by calling the <code>fulfillRequest</code> function of the Randomness Precompile. This function will be <code>payable</code> as the fulfillment fee will need to be submitted at the time of the randomness request</li> <li>A function that consumes the fulfillment results. This function's signature must match the signature of the <code>fulfillRandomWords</code> method of the Randomness Consumer contract</li> </ul> <p>Without further ado, the contract is as follows:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.30;\n\nimport \"https://github.com/moonbeam-foundation/moonbeam/blob/master/precompiles/randomness/Randomness.sol\";\nimport {RandomnessConsumer} from \"https://github.com/moonbeam-foundation/moonbeam/blob/master/precompiles/randomness/RandomnessConsumer.sol\";\n\ncontract RandomNumber is RandomnessConsumer {\n    // The Randomness Precompile Interface\n    Randomness public randomness =\n        Randomness(0x0000000000000000000000000000000000000809);\n\n    // Variables required for randomness requests\n    uint256 public requiredDeposit = randomness.requiredDeposit();\n    uint64 public FULFILLMENT_GAS_LIMIT = 100000;\n    // The fee can be set to any value as long as it is enough to cover\n    // the fulfillment costs. Any leftover fees will be refunded to the\n    // refund address specified in the requestRandomness function below.\n    // 150 Gwei should be sufficient for all networks.\n    // For Moonbase Alpha and Moonriver, you can specify 5 Gwei \n    uint256 public MIN_FEE = FULFILLMENT_GAS_LIMIT * 150 gwei; \n    uint32 public VRF_BLOCKS_DELAY = MIN_VRF_BLOCKS_DELAY;\n    bytes32 public SALT_PREFIX = \"INSERT_ANY_STRING_FOR_SALT\";\n\n    // Storage variables for the current request\n    uint256 public requestId;\n    uint256[] public random;\n\n    constructor() payable RandomnessConsumer() {\n        // Because this contract can only perform 1 random request at a time,\n        // We only need to have 1 required deposit\n        require(msg.value &gt;= requiredDeposit);\n    }\n\n    function requestRandomness() public payable {\n        // Make sure that the value sent is enough\n        require(msg.value &gt;= MIN_FEE);\n        // Request local VRF randomness\n        requestId = randomness.requestLocalVRFRandomWords(\n            msg.sender, // Refund address\n            msg.value, // Fulfillment fee\n            FULFILLMENT_GAS_LIMIT, // Gas limit for the fulfillment\n            SALT_PREFIX ^ bytes32(requestId++), // A salt to generate unique results\n            1, // Number of random words\n            VRF_BLOCKS_DELAY // Delay before request can be fulfilled\n        );\n    }\n\n    function fulfillRequest() public {\n        randomness.fulfillRequest(requestId);\n    }\n\n    function fulfillRandomWords(\n        uint256, // requestId\n        uint256[] memory randomWords\n    ) internal override {\n        // Save the randomness results\n        random = randomWords;\n    }\n}\n</code></pre> <p>As you can see, there are also some constants in the contract that can be edited as you see fit, especially the <code>SALT_PREFIX</code> which can be used to produce unique results.</p> <p>In the following sections, you'll use Remix to deploy and interact with the contract.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#remix-set-up","title":"Remix Set Up","text":"<p>To add the contract to Remix and follow along with this section of the tutorial, you will need to create a new file named <code>RandomnessNumber.sol</code> in Remix and paste the <code>RandomNumber</code> contract into the file.</p> <p></p>"},{"location":"builders/ethereum/precompiles/features/randomness/#compile-deploy-random-number","title":"Compile &amp; Deploy the Random Number Generator Contract","text":"<p>To compile the <code>RandomNumber.sol</code> contract in Remix, you'll need to take the following steps:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Click on the Compile RandomNumber.sol button</li> </ol> <p>If the contract was compiled successfully, you will see a green checkmark next to the Compile tab.</p> <p></p> <p>Now you can go ahead and deploy the contract by taking these steps:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT dropdown. Once you select Injected Provider - Metamask, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Enter the deposit amount in the VALUE field, which is <code>1000000000000000000</code> in Wei (<code>1</code> Ether)</li> <li>Ensure RandomNumber - RandomNumber.sol is selected in the CONTRACT dropdown</li> <li>Click Deploy</li> <li>Confirm the MetaMask transaction that appears by clicking Confirm</li> </ol> <p></p> <p>The RANDOMNUMBER contract will appear in the list of Deployed Contracts.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#request-randomness","title":"Submit a Request to Generate a Random Number","text":"<p>To request randomness, you're going to use the <code>requestRandomness</code> function of the contract, which will require you to submit a deposit as defined in the Randomness Precompile. You can submit the randomness request and pay the deposit by taking these steps:</p> <ol> <li>Enter an amount in the VALUE field for the fulfillment fee, it must be equal to or greater than the minimum fee specified in the <code>RandomNumber</code> contract, which is <code>15000000</code> Gwei.</li> <li>Expand the RANDOMNUMBER contract</li> <li>Click on the requestRandomness button</li> <li>Confrm the transaction in MetaMask</li> </ol> <p></p> <p>Once you submit the transaction, the <code>requestId</code> will be updated with the ID of the request. You can use the <code>requestId</code> call of the Random Number contract to get the request ID and the <code>getRequestStatus</code> function of the Randomness Precompile to check the status of this request ID.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#fulfill-request-save-number","title":"Fulfill the Request and Save the Random Number","text":"<p>After submitting the randomness request, you'll need to wait for the duration of the delay before you can fulfill the request. For the <code>RandomNumber.sol</code> contract, the delay was set to the minimum block delay defined in the Randomness Precompile, which is 2 blocks. You must also fulfill the request before it is too late. For local VRF, the request expires after 10000 blocks and for BABE epoch randomness, the request expires after 10000 epochs.</p> <p>Assuming you've waited for the minimum blocks (or epochs if you're using BABE epoch randomness) to pass and the request hasn't expired, you can fulfill the request by taking the following steps:</p> <ol> <li>Click on the fulfillRequest button</li> <li>Confirming the transaction in MetaMask</li> </ol> <p></p> <p>Once the request has been fulfilled, you can check the random number that was generated:</p> <ol> <li>Expand the random function</li> <li>Since the contract only requested one random word, you can get the random number by accessing the <code>0</code> index of the <code>random</code> array</li> <li>Click call</li> <li>The random number will appear below the call button</li> </ol> <p></p> <p>Upon successful fulfillment, the excess fees and deposit will be sent to the address specified as the refund address.</p> <p>If the request happened to expire before it could be fulfilled, you can interact with the Randomness Precompile directly to purge the request and unlock the deposit and fees. Please refer to the following section for instructions on how to do this.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#interact-directly","title":"Use Remix to Interact Directly with the Randomness Precompile","text":"<p>In addition to interacting with the randomness precompile via a smart contract, you can also interact with it directly in Remix to perform operations such as creating a randomness request, checking on the status of a request, and purging expired requests. Remember, you need to have a contract that inherits from the consumer contract in order to fulfill requests, as such if you fulfill a request using the precompile directly there will be no way to consume the results.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#remix-set-up","title":"Remix Set Up","text":"<p>To add the interfaces to Remix and follow along with this section of the tutorial, you will need to:</p> <ol> <li>Get a copy of <code>Randomness.sol</code></li> <li>Paste the file contents into a Remix file named Randomness.sol</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/features/randomness/#compile-randomness","title":"Compile &amp; Access the Randomness Precompile","text":"<p>Next, you will need to compile the <code>Randomness.sol</code> file in Remix. To get started, make sure you have the Randomness.sol file open and take the following steps:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>To compile the contract, click on Compile Randomness.sol</li> </ol> <p>If the contract was compiled successfully, you will see a green checkmark next to the Compile tab.</p> <p>Instead of deploying the randomness precompile, you will access the interface given the address of the precompiled contract:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note the precompiled contract is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT dropdown. Once selected, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure Randomness - Randomness.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract, there is no need to deploy any code. Instead we are going to provide the address of the precompile in the At Address Field</li> <li>Provide the address of the batch precompile: <code>0x0000000000000000000000000000000000000809</code> and click At Address</li> </ol> <p></p> <p>The RANDOMNESS precompile will appear in the list of Deployed Contracts. You will use this to fulfill the randomness request made from the lottery contract later on in this tutorial.</p>"},{"location":"builders/ethereum/precompiles/features/randomness/#get-request-status-and-purge","title":"Get Request Status &amp; Purge Expired Request","text":"<p>Anyone can purge expired requests. You do not need to be the one who requested the randomness to be able to purge it. When you purge an expired request, the request fees will be transferred to you, and the deposit for the request will be returned to the original requester.</p> <p>To purge a request, first you have to make sure that the request has expired. To do so, you can verify the status of a request using the <code>getRequestStatus</code> function of the precompile. The number that is returned from this call corresponds to the index of the value in the <code>RequestStatus</code> enum. As a result, you'll want to verify the number returned is <code>3</code> for <code>Expired</code>.</p> <p>Once you've verified that the request is expired, you can call the <code>purgeExpiredRequest</code> function to purge the request.</p> <p>To verify and purge a request, you can take the following steps:</p> <ol> <li>Expand the RANDOMNESS contract</li> <li>Enter the request ID of the request you want to verify has expired and click on getRequestStatus</li> <li>The response will appear just underneath the function. Verify that you received a <code>3</code></li> <li>Expand the purgeExpiredRequest function and enter the request ID</li> <li>Click on transact</li> <li>MetaMask will pop-up and you can confirm the transaction</li> </ol> <p></p> <p>Once the transaction goes through, you can verify the request has been purged by calling the getRequestStatus function again with the same request ID. You should receive a status of <code>0</code>, or <code>DoesNotExist</code>. You can also expect the amount of the request fees to be transferred to your account.</p>"},{"location":"builders/ethereum/precompiles/features/staking/","title":"Interacting with the Staking Precompile","text":""},{"location":"builders/ethereum/precompiles/features/staking/#introduction","title":"Introduction","text":"<p>Moonbeam uses a Delegated Proof of Stake system through the Parachain Staking Pallet, allowing token holders (delegators) to express exactly which collator candidates they would like to support and with what quantity of stake. The design of the Parachain Staking Pallet is such that it enforces shared risk/reward on chain between delegators and candidates. For general information on staking, such as general terminology, staking variables, and more, please refer to the Staking on Moonbeam page.</p> <p>The staking module is coded in Rust and it is part of a pallet that is normally not accessible from the Ethereum side of Moonbeam. However, a staking precompile allows developers to access the staking features using the Ethereum API in a precompiled contract located at address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000800\n</code></pre> <pre><code>0x0000000000000000000000000000000000000800\n</code></pre> <pre><code>0x0000000000000000000000000000000000000800\n</code></pre> <p>This guide will cover the available methods in the staking precompile interface. In addition, it will show you how to interact with the Parachain Staking Pallet through the staking precompile and the Ethereum API. The examples in this guide are done on Moonbase Alpha, but they can be adapted for Moonbeam or Moonriver.</p> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/features/staking/#exit-delays","title":"Exit Delays","text":"<p>Some of the Parachain Staking Pallet extrinsics include exit delays that you must wait before the request can be executed. The exit delays to note are as follows:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Decrease candidate bond 28 rounds (168 hours) Decrease delegator bond 28 rounds (168 hours) Revoke delegation 28 rounds (168 hours) Leave candidates 28 rounds (168 hours) Leave delegators 28 rounds (168 hours) Variable Value Decrease candidate bond 24 rounds (48 hours) Decrease delegator bond 24 rounds (48 hours) Revoke delegation 24 rounds (48 hours) Leave candidates 24 rounds (48 hours) Leave delegators 24 rounds (48 hours) Variable Value Decrease candidate bond 2 rounds (4 hours) Decrease delegator bond 2 rounds (4 hours) Revoke delegation 2 rounds (4 hours) Leave candidates 2 rounds (4 hours) Leave delegators 2 rounds (4 hours)"},{"location":"builders/ethereum/precompiles/features/staking/#the-parachain-staking-solidity-interface","title":"Parachain Staking Solidity Interface","text":"<p><code>StakingInterface.sol</code> is an interface through which Solidity contracts can interact with parachain-staking. The beauty is that Solidity developers don\u2019t have to learn the Substrate API. Instead, they can interact with staking functions using the Ethereum interface they are familiar with.</p> <p>The Solidity interface includes the following functions:</p> isDelegator(address delegator) - read-only function that checks whether the specified address is currently a staking delegator. Uses the <code>delegatorState</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>delegator</code> - address to check if they are currently a delegator</li> </ul> <ul> <li><code>bool</code> whether the address is currently a delegator</li> </ul> isCandidate(address candidate) - read-only function that checks whether the specified address is currently a collator candidate. Uses the <code>candidateState</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address to check if they are currently a collator candidate</li> </ul> <ul> <li><code>bool</code> whether the address is currently a candidate</li> </ul> isSelectedCandidate(address candidate) - read-only function that checks whether the specified address is currently part of the active collator set. Uses the <code>selectedCandidates</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address to check if they are currently an active collator</li> </ul> <ul> <li><code>bool</code> whether the address is currently an active collator</li> </ul> points(uint256 round) - read-only function that gets the total points awarded to all collators in a given round. Uses the <code>points</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>round</code> - uint256 round number to query points for</li> </ul> <ul> <li><code>uint256</code> total points awarded in the specified round</li> </ul> awardedPoints(uint32 round, address candidate) - read-only function that returns the total points awarded in a given round to a given collator. If <code>0</code> is returned, it could be because no blocks were produced or the storage for that round has been removed. Uses the <code>points</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>round</code> - uint32 round number to query</li> <li><code>candidate</code> - address of the collator to query points for</li> </ul> <ul> <li><code>uint256</code> points awarded to the collator in the specified round</li> </ul> delegationAmount(address delegator, address candidate) - read-only function that returns the amount delegated by a given delegator in support of a given candidate. Uses the <code>delegatorState</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>delegator</code> - address of the delegator</li> <li><code>candidate</code> - address of the candidate</li> </ul> <ul> <li><code>uint256</code> amount delegated</li> </ul> isInTopDelegations(address delegator, address candidate) - read-only function that returns a boolean indicating whether the given delegator is in the top delegations for the given candidate. Uses the <code>topDelegations</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>delegator</code> - address of the delegator to check</li> <li><code>candidate</code> - address of the candidate</li> </ul> <ul> <li><code>bool</code> whether the delegator is in the top delegations</li> </ul> minDelegation() - read-only function that gets the minimum delegation amount. Uses the <code>minDelegation</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> minimum delegation amount</li> </ul> candidateCount() - read-only function that gets the current amount of collator candidates. Uses the <code>candidatePool</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> current number of collator candidates</li> </ul> round() - read-only function that returns the current round number. Uses the <code>round</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> current round number</li> </ul> candidateDelegationCount(address candidate) - read-only function that returns the number of delegations for the specified collator candidate address. Uses the <code>candidateInfo</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the collator candidate to query</li> </ul> <ul> <li><code>uint256</code> number of delegations for the candidate</li> </ul> candidateAutoCompoundingDelegationCount(address candidate) - a read-only function that returns the number of auto-compounding delegations for the specified candidate. Uses the <code>autoCompoundingDelegations</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to query</li> </ul> <ul> <li><code>uint256</code> number of auto-compounding delegations</li> </ul> delegatorDelegationCount(address delegator) - read-only function that returns the number of delegations for the specified delegator address. Uses the <code>delegatorState</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>delegator</code> - address of the delegator to query</li> </ul> <ul> <li><code>uint256</code> number of delegations for the delegator</li> </ul> selectedCandidates() - read-only function that gets the selected candidates for the current round. Uses the <code>selectedCandidates</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <ul> <li><code>address[]</code> array of selected candidate addresses</li> </ul> delegationRequestIsPending(address delegator, address candidate) - returns a boolean to indicate whether there is a pending delegation request made by a given delegator for a given candidate ParametersReturns <ul> <li><code>delegator</code> - address of the delegator</li> <li><code>candidate</code> - address of the candidate</li> </ul> <ul> <li><code>bool</code> whether there is a pending delegation request</li> </ul> candidateExitIsPending(address candidate) - returns a boolean to indicate whether a pending exit exists for a specific candidate. Uses the <code>candidateInfo</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to check</li> </ul> <ul> <li><code>bool</code> whether there is a pending exit request</li> </ul> candidateRequestIsPending(address candidate) - returns a boolean to indicate whether there is a pending bond less request made by a given candidate. Uses the <code>candidateInfo</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to check</li> </ul> <ul> <li><code>bool</code> whether there is a pending bond less request</li> </ul> delegationAutoCompound(address delegator, address candidate) - returns the auto-compound percentage for a delegation given the delegator and candidate ParametersReturns <ul> <li><code>delegator</code> - address of the delegator</li> <li><code>candidate</code> - address of the candidate</li> </ul> <ul> <li><code>uint256</code> auto-compound percentage</li> </ul> getDelegatorTotalStaked(address delegator) - read-only function that returns the total staked amount of a given delegator, regardless of the candidate. Uses the <code>delegatorState</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>delegator</code> - address of the delegator to query</li> </ul> <ul> <li><code>uint256</code> total staked amount</li> </ul> getCandidateTotalCounted(address candidate) - read-only function that returns the total amount staked for a given candidate. Uses the <code>candidateInfo</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to query</li> </ul> <ul> <li><code>uint256</code> total amount staked for the candidate</li> </ul> joinCandidates(uint256 amount, uint256 candidateCount) - allows the account to join the set of collator candidates with the specified bond amount and the current candidate count. Uses the <code>joinCandidates</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>amount</code> - uint256 bond amount to stake as a candidate</li> <li><code>candidateCount</code> - uint256 current number of candidates in the pool</li> </ul> <p>None.</p> scheduleLeaveCandidates(uint256 candidateCount) - schedules a request for a candidate to remove themselves from the candidate pool. Scheduling the request does not automatically execute it. There is an exit delay that must be waited before you can execute the request via the <code>executeLeaveCandidates</code> extrinsic. Uses the <code>scheduleLeaveCandidates</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidateCount</code> - uint256 current number of candidates in the pool</li> </ul> <p>None.</p> executeLeaveCandidates(address candidate, uint256 candidateDelegationCount) - executes the due request to leave the set of collator candidates. Uses the <code>executeLeaveCandidates</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate leaving the pool</li> <li><code>candidateDelegationCount</code> - uint256 number of delegations for the candidate</li> </ul> <p>None.</p> cancelLeaveCandidates(uint256 candidateCount) - allows a candidate to cancel a pending scheduled request to leave the candidate pool. Given the current number of candidates in the pool. Uses the <code>cancelLeaveCandidates</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidateCount</code> - uint256 current number of candidates in the pool</li> </ul> <p>None.</p> goOffline() - temporarily leave the set of collator candidates without unbonding. Uses the <code>goOffline</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <p>None.</p> goOnline() - rejoin the set of collator candidates after previously calling <code>goOffline()</code>. Uses the <code>goOnline</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <p>None.</p> candidateBondMore(uint256 more) - collator candidate increases bond by the specified amount. Uses the <code>candidateBondMore</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>more</code> - uint256 amount to increase the bond by</li> </ul> <p>None.</p> scheduleCandidateBondLess(uint256 less) - schedules a request to decrease a candidates bond by the specified amount. Scheduling the request does not automatically execute it. There is an exit delay that must be waited before you can execute the request via the <code>execute_candidate_bond_request</code> extrinsic. Uses the <code>scheduleCandidateBondLess</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>less</code> - uint256 amount to decrease the bond by</li> </ul> <p>None.</p> executeCandidateBondLess(address candidate) - executes any due requests to decrease a specified candidate's bond amount. Uses the <code>executeCandidateBondLess</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to execute the bond decrease for</li> </ul> <p>None.</p> cancelCandidateBondLess() - allows a candidate to cancel a pending scheduled request to decrease a candidates bond. Uses the <code>cancelCandidateBondLess</code> method of the Parachain Staking Pallet ParametersReturns <p>None.</p> <p>None.</p> delegateWithAutoCompound(address candidate, uint256 amount, uint8 autoCompound, uint256 candidateDelegationCount, uint256 candidateAutoCompoundingDelegationCount, uint256 delegatorDelegationCount) - makes a delegation in support of a collator candidate and automatically sets the percent of rewards to auto-compound given an integer (no decimals) for <code>autoCompound</code> between 0-100. Uses the <code>delegateWithAutoCompound</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to delegate to</li> <li><code>amount</code> - uint256 amount to delegate</li> <li><code>autoCompound</code> - uint8 percentage of rewards to auto-compound (0-100)</li> <li><code>candidateDelegationCount</code> - uint256 current number of delegations for the candidate</li> <li><code>candidateAutoCompoundingDelegationCount</code> - uint256 current number of auto-compounding delegations for the candidate</li> <li><code>delegatorDelegationCount</code> - uint256 current number of delegations from the delegator</li> </ul> <p>None.</p> scheduleRevokeDelegation(address candidate) - schedules a request to revoke a delegation given the address of a candidate. Scheduling the request does not automatically execute it. There is an exit delay that must be waited before you can execute the request via the <code>executeDelegationRequest</code> extrinsic. Uses the <code>scheduleRevokeDelegation</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to revoke delegation from</li> </ul> <p>None.</p> delegatorBondMore(address candidate, uint256 more) - delegator increases bond to a collator by the specified amount. Uses the <code>delegatorBondMore</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to increase delegation for</li> <li><code>more</code> - uint256 amount to increase the delegation by</li> </ul> <p>None.</p> scheduleDelegatorBondLess(address candidate, uint256 less) - schedules a request for a delegator to bond less with respect to a specific candidate. Scheduling the request does not automatically execute it. There is an exit delay that must be waited before you can execute the request via the <code>executeDelegationRequest</code> extrinsic. Uses the <code>scheduleDelegatorBondLess</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to decrease delegation for</li> <li><code>less</code> - uint256 amount to decrease the delegation by</li> </ul> <p>None.</p> executeDelegationRequest(address delegator, address candidate) - executes any due delegation requests provided the address of a delegator and a candidate. Uses the <code>executeDelegationRequest</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>delegator</code> - address of the delegator</li> <li><code>candidate</code> - address of the candidate</li> </ul> <p>None.</p> cancelDelegationRequest(address candidate) - cancels any pending delegation requests provided the address of a candidate. Uses the <code>cancelDelegationRequest</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate to cancel the delegation request for</li> </ul> <p>None.</p> setAutoCompound(address candidate, uint8 value, uint256 candidateAutoCompoundingDelegationCount, uint256 delegatorDelegationCount) - sets an auto-compound value for an existing delegation given an integer (no decimals) for the <code>value</code> between 0-100. Uses the <code>setAutoCompound</code> method of the Parachain Staking Pallet ParametersReturns <ul> <li><code>candidate</code> - address of the candidate</li> <li><code>value</code> - uint8 percentage to auto-compound (0-100)</li> <li><code>candidateAutoCompoundingDelegationCount</code> - uint256 current number of auto-compounding delegations for the candidate</li> <li><code>delegatorDelegationCount</code> - uint256 current number of delegations from the delegator</li> </ul> <p>None.</p>"},{"location":"builders/ethereum/precompiles/features/staking/#interact-with-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/ethereum/precompiles/features/staking/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The below example is demonstrated on Moonbase Alpha, however, similar steps can be taken for Moonbeam and Moonriver.</p> <ul> <li>Have MetaMask installed and connected to Moonbase Alpha</li> <li>Have an account with at least <code>1</code> token.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul> <p>Note</p> <p>The example below requires more than <code>1</code> token due to the minimum delegation amount plus gas fees. If you need more than the faucet dispenses, please contact us on Discord and we will be happy to help you.</p>"},{"location":"builders/ethereum/precompiles/features/staking/#remix-set-up","title":"Remix Set Up","text":"<ol> <li>Click on the File explorer tab</li> <li>Get a copy of <code>StakingInterface.sol</code> and paste the file contents into a Remix file named <code>StakingInterface.sol</code></li> </ol>"},{"location":"builders/ethereum/precompiles/features/staking/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile StakingInterface.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/features/staking/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure ParachainStaking - StakingInterface.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the staking precompile for Moonbase Alpha: <code>0x0000000000000000000000000000000000000800</code> and click At Address</li> <li>The Parachain Staking precompile will appear in the list of Deployed Contracts</li> </ol>"},{"location":"builders/ethereum/precompiles/features/staking/#delegate-a-collator","title":"Delegate a Collator with Auto-Compounding","text":"<p>For this example, you are going to be delegating a collator and setting up the percentage of rewards to auto-compound on Moonbase Alpha. Delegators are token holders who stake tokens, vouching for specific candidates. Any user that holds a minimum amount of 1 token in their free balance can become a delegator. When delegating a candidate, you can simultaneously set up auto-compounding. You'll be able to specify a percentage of your rewards that will automatically be applied to your total delegation. You don't have to set up auto-compounding right away, you can always do it at a later time.</p> <p>You can do your own research and select the candidate you desire. For this guide, the following candidate address will be used: <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>.</p> <p>In order to delegate a candidate, you'll need to determine the candidate's current delegation count, their auto-compounding delegation count, and your own delegation count.</p> <p>The candidate delegation count is the number of delegations backing a specific candidate. To obtain the candidate delegator count, you can call a function that the staking precompile provides. Expand the PARACHAINSTAKING contract found under the Deployed Contracts list, then:</p> <ol> <li>Find and expand the candidateDelegationCount function</li> <li>Enter the candidate address (<code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>)</li> <li>Click call</li> <li>After the call is complete, the results will be displayed</li> </ol> <p></p> <p>The auto-compounding delegation count is the amount of delegations that have auto-compounding configured. To determine the number of delegations that have auto-compounding set up, you can</p> <ol> <li>Find and expand the candidateAutoCompoundingDelegationCount function</li> <li>Enter the candidate address (<code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>)</li> <li>Click call</li> <li>After the call is complete, the results will be displayed</li> </ol> <p></p> <p>The last item you'll need to retrieve is your delegation count. If you don't know your existing number of delegations, you can easily get them by following these steps:</p> <ol> <li>Find and expand the delegatorDelegationCount function</li> <li>Enter your address</li> <li>Click call</li> <li>After the call is complete, the results will be displayed</li> </ol> <p></p> <p>Now that you have obtained the candidate delegator count, the auto-compounding delegation count, and your number of existing delegations, you have all of the information you need to delegate a candidate and set up auto-compounding. To get started:</p> <ol> <li>Find and expand the delegateWithAutoCompound function</li> <li>Enter the candidate address you would like to delegate. For this example you can use <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>Provide the amount to delegate in Wei. There is a minimum of <code>1</code> token to delegate, so the lowest amount in Wei is <code>1000000000000000000</code></li> <li>Enter an integer (no decimals) between 0-100 to represent the percentage of rewards to auto-compound</li> <li>Enter the delegation count for the candidate</li> <li>Enter the auto-compounding delegation count for the candidate</li> <li>Enter your delegation count</li> <li>Press transact</li> <li>MetaMask will pop up, you can review the details and confirm the transaction</li> </ol> <p></p> <p>If you want to delegate without setting up auto-compounding, you can follow the previous steps, but instead of using delegateWithAutoCompound, you can use the delegate extrinsic.</p>"},{"location":"builders/ethereum/precompiles/features/staking/#verify-delegation","title":"Verify Delegation","text":"<p>To verify your delegation was successful, you can check the chain state in Polkadot.js Apps. First, add your MetaMask address to the address book in Polkadot.js Apps.</p> <p>Navigate to Accounts and then Address Book, click on Add contact, and enter the following information:</p> <ol> <li>Add your MetaMask address</li> <li>Provide a nickname for the account</li> <li>Click Save</li> </ol> <p></p> <p>To verify your delegation was successful, head to Polkadot.js Apps and navigate to Developer and then Chain State</p> <ol> <li>Select the parachainStaking pallet</li> <li>Select the delegatorState query</li> <li>Enter your address</li> <li>Optionally, you can enable the include option slider if you want to provide a specific blockhash to query</li> <li>Click the + button to return the results and verify your delegation</li> </ol> <p>Note</p> <p>You do not have to enter anything in the blockhash to query at field if you are looking for an overview of your delegations.</p> <p></p>"},{"location":"builders/ethereum/precompiles/features/staking/#confirm-auto-compounding","title":"Confirm Auto-Compounding Percentage","text":"<p>You can confirm the percentage of rewards you've set to auto-compound in Remix using the <code>delegationAutoCompound</code> function of the Solidity interface:</p> <ol> <li>Find and expand the delegationAutoCompound function</li> <li>Enter your account you used to delegate with</li> <li>Enter the candidate you've delegated</li> <li>Click call</li> <li>The response will appear below the call button</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/features/staking/#set-or-change-auto-compounding","title":"Set or Change the Auto-Compounding Percentage","text":"<p>If you initially set up your delegation without auto-compounding or if you want to update the percentage on an existing delegation with auto-compounding set up, you can use the <code>setAutoCompound</code> function of the Solidity interface.</p> <p>You'll need to get the number of delegations with auto-compounding set up for the candidate you want to set or update auto-compounding for. You'll also need to retrieve your own delegation count. You can follow the instructions in the Delegate a Collator with Auto-Compounding section to get both of these items.</p> <p>Once you have the necessary information, you can take the following steps in Remix:</p> <ol> <li>Find and expand the setAutoCompound function</li> <li>Enter the candidate's account you want to set or update auto-compounding for</li> <li>Enter a number 0-100 to represent the percentage of rewards you want to auto-compound</li> <li>Enter the auto-compounding delegation count for the candidate</li> <li>Enter your delegation count</li> <li>Press transact</li> <li>MetaMask will pop up, you can review the details and confirm the transaction</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/features/staking/#revoke-a-delegation","title":"Revoke a Delegation","text":"<p>As of runtime version 1001, there have been significant changes to the way users can interact with various staking features. Including the way staking exits are handled.</p> <p>Exits now require you to schedule a request to exit or revoke a delegation, wait a delay period, and then execute the request.</p> <p>To revoke a delegation for a specific candidate and receive your tokens back, you can use the <code>scheduleRevokeDelegation</code> extrinsic. Scheduling a request does not automatically revoke your delegation, you must wait an exit delay, and then execute the request by using the <code>executeDelegationRequest</code> method.</p> <p>To revoke a delegation and receive your tokens back, head back over to Remix, then:</p> <ol> <li>Find and expand the scheduleRevokeDelegation function</li> <li>Enter the candidate address you would like to revoke the delegation for</li> <li>Click transact</li> <li>MetaMask will pop up, you can review the transaction details, and click Confirm</li> </ol> <p></p> <p>Once the transaction is confirmed, you must wait the duration of the exit delay before you can execute and revoke the delegation request. If you try to revoke it before the exit delay is up, your extrinsic will fail.</p> <p>After the exit delay has passed, you can go back to Remix and follow these steps to execute the due request:</p> <ol> <li>Find and expand the executeDelegationRequest function</li> <li>Enter the address of the delegator you would like to revoke the delegation for</li> <li>Enter the candidate address you would like to revoke the delegation from</li> <li>Click transact</li> <li>MetaMask will pop up, you can review the transaction details, and click Confirm</li> </ol> <p>After the call is complete, the results will be displayed and the delegation will be revoked for the given delegator and from the specified candidate. You can also check your delegator state again on Polkadot.js Apps to confirm.</p> <p>If for any reason you need to cancel a pending scheduled request to revoke a delegation, you can do so by following these steps in Remix:</p> <ol> <li>Find and expand the cancelDelegationRequest function</li> <li>Enter the candidate address you would like to cancel the pending request for</li> <li>Click transact</li> <li>MetaMask will pop up, you can review the transaction details, and click Confirm</li> </ol> <p>You can check your delegator state again on Polkadot.js Apps to confirm that your delegation is still intact.</p>"},{"location":"builders/ethereum/precompiles/features/governance/collective/","title":"Interacting with the Collective Precompile","text":""},{"location":"builders/ethereum/precompiles/features/governance/collective/#introduction","title":"Introduction","text":"<p>The Collective Precompile enables a user to directly interact with Substrate's collective pallet directly from a Solidity interface.</p> <p>A collective is a group of members that are responsible for specific democracy-related actions such as proposing, voting on, executing, and closing motions. Each can execute different actions with different origins. Consequently, collectives can be created with very specific scopes. There are currently two collectives: the Treasury Council collective and the OpenGov Technical Committee collective. As such, there is a precompile for each collective. For more information on the OpenGov Technical Committee please refer to the Governance on Moonbeam page, and for more information on the Treasury Council, please refer to the Treasury on Moonbeam page.</p> <p>This guide will show you how to propose, vote on, and close a proposal using the Collective Precompile.</p> <p>The Collective Precompiles are located at the following addresses:</p> MoonbeamMoonriverMoonbase Alpha Collective Address Treasury Council 0x0000000000000000000000000000000000000810 OpenGov Technical Committee 0x0000000000000000000000000000000000000814 Collective Address Treasury Council 0x0000000000000000000000000000000000000810 OpenGov Technical Committee 0x0000000000000000000000000000000000000814 Collective Address Treasury Council 0x0000000000000000000000000000000000000810 OpenGov Technical Committee 0x0000000000000000000000000000000000000814 <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#the-call-permit-interface","title":"The Collective Solidity Interface","text":"<p><code>Collective.sol</code> is a Solidity interface that allows developers to interact with the precompile's five methods.</p> <p>The interface includes the following functions:</p> execute(bytes memory proposal) - executes a proposal as a single member of the collective. The sender must be a member of the collective. This will not revert if the Substrate proposal is dispatched but fails Parameters <ul> <li><code>proposal</code> - bytes memory containing the SCALE encoded Substrate call that proposes an action</li> </ul> propose(uint32 threshold, bytes memory proposal) - adds a new proposal to be voted on. The sender must be a member of the collective. If the threshold is less than two then the proposal will be dispatched and executed directly, with the proposer as dispatcher. If the threshold is met, the index of the new proposal is returned Parameters <ul> <li><code>threshold</code> - uint32 amount of members required to dispatch the proposal</li> <li><code>proposal</code> - bytes memory containing the SCALE encoded Substrate call that proposes an action</li> </ul> vote(bytes32 proposalHash, uint32 proposalIndex, bool approve) - votes on a proposal. The sender must be a member of the collective Parameters <ul> <li><code>proposalHash</code> - bytes32 hash of the proposal</li> <li><code>proposalIndex</code> - uint32 index of the proposal</li> <li><code>approve</code> - bool indicating the vote to approve the proposal or not</li> </ul> close(bytes32 proposalHash, uint32 proposalIndex, uint64 proposalWeightBound, uint32 lengthBound) - closes a proposal. Can be called by anyone once there are enough votes. Returns a boolean indicating whether the proposal was executed or removed Parameters <ul> <li><code>proposalHash</code> - bytes32 hash of the proposal</li> <li><code>proposalIndex</code> - uint32 index of the proposal</li> <li><code>proposalWeightBound</code> - uint64 maximum amount of Substrate weight the proposal can use. If the proposal call uses more, the call will revert</li> <li><code>lengthBound</code> - uint32 value higher or equal to the length of the SCALE encoded proposal in bytes</li> </ul> proposalHash(bytes memory proposal) - computes the hash of a proposal Parameters <ul> <li><code>proposal</code> - bytes memory containing the SCALE encoded Substrate call that proposes an action</li> </ul> <p>The interface includes the following events:</p> <ul> <li>Executed(bytes32 proposalHash) - emitted when a proposal is executed</li> <li>Proposed(address indexed who, uint32 indexed proposalIndex, bytes32 indexed proposalHash, uint32 threshold) - emitted when a proposal has successfully been proposed and can be executed or voted on</li> <li>Voted(address indexed who, bytes32 indexed proposalHash, bool* voted) - emitted when a proposal is voted on</li> <li>Closed(bytes32 indexed proposalHash) - emitted when a proposal has been closed</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#interacting-with-the-solidity-interface","title":"Interacting with the Solidity Interface","text":"<p>The example in this section will show you how to submit a Treasury proposal using the Treasury Council Collective Precompile. As such, the proposal will be subject to meeting the voting requirements of the Treasury Council. The threshold for accepting a Treasury proposal is at least three-fifths of the Treasury Council. On the other hand, the threshold for rejecting a proposal is at least one-half of the Treasury Council. Please keep in mind that in order to propose and vote on the proposal, you must be a member of the Treasury Council.</p> <p>If you are not a member of the Treasury Council on Moonbeam, Moonriver, or Moonbase Alpha, you can test out the features of the Collective Precompile using a Moonbeam development node. The Moonbeam development node comes with ten pre-funded accounts, of which Baltathar, Charleth, and Dorothy are automatically set as members of the Treasury Council collective. You can use any of these three accounts to follow along with the rest of the guide.</p>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The example in this guide will be shown on a Moonbeam development node, however, it can be adapted for any of the Moonbeam-based networks.</p> <p>To get started, you will need to have the following:</p> <ul> <li>Have MetaMask installed and connected to one of the Moonbeam-based networks</li> <li>Have an account with funds. If using a Moonbeam development node, the development accounts are pre-funded. For Moonbeam, Moonriver, or Moonbase Alpha, you'll need to fund your account.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul> <p>If you're using a Moonbeam development node and the development accounts, you'll also need to do the following:</p> <ul> <li>Set your development node to seal blocks on a time interval such as every 6 seconds (6000 milliseconds) using the <code>--sealing 6000</code> flag</li> <li>Connect Polkadot.js Apps to your local Moonbeam development node</li> <li>Import Baltathar's, Charleth's, and/or Dorothy's accounts into Polkadot.js Apps and MetaMask</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#remix-set-up","title":"Remix Set Up","text":"<ol> <li>Get a copy of <code>Collective.sol</code> </li> <li>Copy and paste the file contents into a Remix file named <code>Collective.sol</code></li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile Collective.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: You are not deploying a contract here; instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure Collective - Collective.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address Field</li> <li>Provide the address of the Collective Precompile,<code>0x0000000000000000000000000000000000000810</code>, and click At Address</li> <li>The Collective Precompile will appear in the list of Deployed Contracts</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#create-a-proposal","title":"Create a Proposal","text":"<p>In order to submit a proposal to be voted on by the Treasury Council collective, you must first create a Treasury proposal. If a Treasury proposal that you want to vote on already exists and you have the proposal index, you can skip ahead to the next section.</p> <p>To submit a Treasury proposal, you can do so via the Polkadot.js Apps Treasury page. For this example, you can create a simple proposal to send Alith 10 DEV tokens that can be used to host a community event. To get started, click on Submit proposal, and fill out the following information:</p> <ol> <li>From the submit with account dropdown, select the account you want to submit the proposal with. The bond for the proposal will be taken from this account</li> <li>Select the beneficiary, which can be Alith for this example</li> <li>Enter <code>10</code> for the value</li> <li>Click on Submit proposal and then sign and submit the proposal</li> </ol> <p></p> <p>You should see the proposal appear in the proposals section. If this is the first proposal created, it will have a proposal index of <code>0</code>, which will be needed in the next section. To view all of the proposals, you can navigate to the Developer tab, select Chain State, and take the following steps:</p> <ol> <li>From the selected state query dropdown, choose treasury</li> <li>Select the proposals extrinsic</li> <li>Toggle the include option slider off</li> <li>Click + to submit the query</li> <li>The results will appear below with the proposal index and the proposal details</li> </ol> <p></p> <p>Now that you have the proposal and the proposal index, you'll be able to approve the proposal in the following section using the Collective Precompile.</p>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#propose-the-proposal","title":"Propose the Proposal","text":"<p>In order to propose a proposal using the Collective Precompile, so that the corresponding collective can vote on it, you will need to obtain the encoded call data of the call, to be executed by proposal. You can get the encoded call data from Polkadot.js Apps. For this example, you need to propose the approveProposal extrinsic of the treasury pallet. To do so, navigate to the Developer tab, select Extrinsics, and take the following steps:</p> <ol> <li>Select an account (any account is fine because you're not submitting any transaction here)</li> <li>Select the treasury pallet</li> <li>Choose the approveProposal extrinsic</li> <li>Enter the proposal index that the collective will vote on to approve</li> <li>Copy the encoded call data for the proposal</li> </ol> <p></p> <p>For this example, the extrinsic encoded call data for the proposal in this example is <code>0x110200</code>.</p> <p>With the encoded proposal, you can head back to Remix and expand the COLLECTIVE precompile contract under the Deployed Contracts section. Make sure you're connected to your account that is a member of the Treasury Council, and take the following steps to propose the approval:</p> <ol> <li>Expand the propose function</li> <li>Enter the threshold. Keep in mind that for Treasury proposals to be approved, at least three-fifths of the Treasury Council is needed to vote in approval. As such, you can set the threshold to <code>2</code> for this example</li> <li>For the proposal field, you can paste the encoded proposal you retrieved from Polkadot.js Apps</li> <li>Click transact</li> <li>MetaMask will pop up and you can confirm the transaction</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#vote-on-a-proposal","title":"Vote on a Proposal","text":"<p>To vote on a proposal, you'll need to get the proposal hash by passing in the encoded proposal into the proposalHash function.</p> <p></p> <p>Once you have the proposal hash, make sure you're connected to your account that is a member of the Treasury Council, and take the following steps to vote on a proposal:</p> <ol> <li>Expand the vote function in Remix</li> <li>Enter the proposalHash</li> <li>Enter the proposalIndex</li> <li>Enter <code>true</code> for the approve field</li> <li>Click transact</li> <li>MetaMask will pop up and you can confirm the transaction</li> </ol> <p></p> <p>With the threshold set to <code>2</code>, you'll need to switch accounts in MetaMask to another member of the Treasury Council collective and repeat the steps above to vote and meet the threshold. Once the threshold has been met, you can then close the proposal, which will automatically execute it, and if approved, the proposal enters a queue to be placed into a spend period where the proposed amount will be distributed to the beneficiary. In this case, once the proposal is placed into a spend period, 10 DEV tokens will be distributed to Alith.</p>"},{"location":"builders/ethereum/precompiles/features/governance/collective/#close-a-proposal","title":"Close a Proposal","text":"<p>If a proposal has enough votes, anyone can close a proposal. You do not need to be a member of the Treasury Council in order to close a proposal. To close a proposal, you can take the following steps:</p> <ol> <li>Expand the close function</li> <li>Enter the proposalHash</li> <li>Enter the proposalIndex</li> <li>Enter the proposalWeightBound, which for this example can be <code>1000000000</code></li> <li>Enter the lengthBound, which can be a value equal to or greater than the length of the encoded call data for the proposal. For this example the encoded call data is <code>0x110200</code>, and as such, you can set this value to <code>8</code></li> <li>Click on transact</li> <li>MetaMask will pop up and you can confirm the transaction</li> </ol> <p></p> <p>You can verify the proposal has been approved using Polkadot.js Apps. From the Developer tab, select Chain State, and take the following steps:</p> <ol> <li>Select the treasury pallet</li> <li>Select the approvals extrinsic</li> <li>Click + to submit the query</li> <li>The proposal will appear in the list of approvals</li> </ol> <p></p> <p>Once the proposal is in a spend period, the funds will get distributed to the beneficiary, and the original bond will be returned to the proposer. If the Treasury runs out of funds, the approved proposals will remain in storage until the following spend period when the Treasury has enough funds again.</p>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/","title":"Interacting with the Conviction Voting Precompile","text":""},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#introduction","title":"Introduction","text":"<p>As a Polkadot parachain and decentralized network, Moonbeam features native on-chain governance that enables stakeholders to participate in the direction of the network. With the introduction of OpenGov, also referred to as Governance v2, the Conviction Voting Pallet allows token holders to make, delegate, and manage Conviction-weighted votes on referenda. To learn more about Moonbeam's governance system, such as an overview of related terminology, principles, mechanics, and more, please refer to the Governance on Moonbeam page.</p> <p>The Conviction Voting Precompile interacts directly with Substrate's Conviction Voting Pallet. This pallet is coded in Rust and is normally not accessible from the Ethereum API side of Moonbeam. However, the Conviction Voting Precompile allows you to access governance-related functions of the Substrate Conviction Voting Pallet directly from a Solidity interface. Additionally, this enables a vastly improved end-user experience. For example, token holders can vote on referenda or delegate a vote directly from MetaMask, rather than importing an account in Polkadot.js Apps and navigating a complex UI.</p> <p>The Conviction Voting Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000812\n</code></pre> <pre><code>0x0000000000000000000000000000000000000812\n</code></pre> <pre><code>0x0000000000000000000000000000000000000812\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#the-conviction-voting-solidity-interface","title":"The Conviction Voting Solidity Interface","text":"<p><code>ConvictionVoting.sol</code> is a Solidity interface that allows developers to interact with the precompile's methods.</p> <p>The interfaces includes a <code>Conviction</code> enum that defines the Conviction multiplier types. The enum has the following variables:</p> <ul> <li>None -  0.1x votes, unlocked</li> <li>Locked1x - 1x votes, locked for an Enactment Period following a successful vote</li> <li>Locked2x - 2x votes, locked for 2x Enactment Period following a successful vote</li> <li>Locked3x - 4x votes, locked for 4x Enactments Period following a successful vote</li> <li>Locked4x - 8x votes, locked for 8x Enactments Period following a successful vote</li> <li>Locked5x - 16x votes, locked for 16x Enactments Period following a successful vote</li> <li>Locked6x - 32x votes, locked for 32x Enactments Period following a successful vote</li> </ul> <p>The interface includes the following functions:</p> votingFor(address who, uint16 trackId) - returns the votes for a given account and Track Parameters <ul> <li><code>who</code> - address of the account to query the votes for</li> <li><code>trackId</code> - uint16 Track ID where the requested changes need to occur</li> </ul> classLocksFor(address who) - returns the class locks for a given account Parameters <ul> <li><code>who</code> - address of the account to query the class locks for</li> </ul> voteYes(uint32 pollIndex, uint256 voteAmount, Conviction conviction) - votes a Conviction-weighted \"Aye\" on a poll (referendum) Parameters <ul> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> <li><code>voteAmount</code> - uint256 balance to be locked for the vote</li> <li><code>conviction</code> - Conviction represents a value from the aforementioned <code>Conviction</code> enum</li> </ul> voteNo(uint32 pollIndex, uint256 voteAmount, Conviction conviction) - votes a Conviction-weighted \"Nay\" on a poll (referendum) Parameters <ul> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> <li><code>voteAmount</code> - uint256 balance to be locked for the vote</li> <li><code>conviction</code> - Conviction represents a value from the aforementioned <code>Conviction</code> enum</li> </ul> voteSplit(uint32 pollIndex, uint256 aye, uint256 nay) - votes a split vote, with a given amount locked for \"Aye\" and a given amount locked for \"Nay\", on a poll (referendum) Parameters <ul> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> <li><code>aye</code> - uint256 balance to be locked for the \"Aye\" vote</li> <li><code>nay</code> - uint256 balance to be locked for the \"Nay\" vote</li> </ul> voteSplitAbstain(uint32 pollIndex, uint256 aye, uint256 nay) - votes a split abstained vote, with a given amount locked for \"Aye\", a given amount locked for \"Nay\", and a given amount locked for an abstain vote (support), on a poll (referendum) Parameters <ul> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> <li><code>aye</code> - uint256 balance to be locked for the \"Aye\" vote</li> <li><code>nay</code> - uint256 balance to be locked for the \"Nay\" vote</li> </ul> removeVote(uint32 pollIndex) - removes a vote in a poll (referendum). Parameters <ul> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> </ul> removeVoteForTrack(uint32 pollIndex, uint16 trackId) - removes a vote from a specific track in a poll (referendum). Parameters <ul> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> <li><code>trackId</code> - uint16 Track ID where the requested changes need to occur</li> </ul> removeOtherVote(address target, uint16 trackId, uint32 pollIndex) - removes a vote in a poll (referendum) for another voter. Parameters <ul> <li><code>target</code> - address that has a vote or tokens to be removed or unlocked</li> <li><code>trackId</code> - uint16 Track ID where the requested changes need to occur</li> <li><code>pollIndex</code> - uint32 index of the poll (referendum)</li> </ul> delegate(uint16 trackId, address representative, Conviction conviction, uint256 amount) - delegates another account as a representative to place a Conviction-weighted vote on the behalf of the sending account for a specific Track Parameters <ul> <li><code>trackId</code> - uint16 Track ID where the requested changes need to occur</li> <li><code>representative</code> - address of the account to be delegated as representative</li> <li><code>conviction</code> - Conviction represents a value from the aforementioned <code>Conviction</code> enum</li> <li><code>amount</code> - uint256 balance to be delegated</li> </ul> undelegate(uint16 trackId) - removes the caller's vote delegations for a specific Track Parameters <ul> <li><code>trackId</code> - uint16 Track ID where the requested changes need to occur</li> </ul> unlock(uint16 trackId, address target) - unlocks the locked tokens of a specific account for a specific Track Parameters <ul> <li><code>trackId</code> - uint16 Track ID where the requested changes need to occur</li> <li><code>target</code> - address that has a vote or tokens to be removed or unlocked</li> </ul> <p>The interface also includes the following events:</p> <ul> <li>Voted(uint32 indexed pollIndex, address voter, bool aye, uint256 voteAmount, uint8 conviction) - emitted when an account makes a vote</li> <li>VoteSplit(uint32 indexed pollIndex, address voter, uin256 aye, uint256 nay) - emitted when an account makes a split vote</li> <li>VoteSplitAbstained(uint32 indexed pollIndex, address voter, uin256 aye, uint256 nay, uint256 nay) - emitted when an account makes a split abstained vote</li> <li>VoteRemoved(uint32 indexed pollIndex, address voter) - emitted when an account's (<code>voter</code>) vote has been removed from an ongoing poll (referendum)</li> <li>VoteRemovedForTrack(uint32 indexed pollIndex, uint16 trackId, address voter) - emitted when an account's (<code>voter</code>) vote has been removed from an ongoing poll (referendum) for a specific Track</li> <li>VoteRemovedOther(uint32 indexed pollIndex, address caller, address target, uint16 trackId) - emitted when an account (<code>caller</code>) removed a vote for another account (<code>target</code>)</li> <li>Delegated(uint16 indexed trackId, address from, address to, uint256 delegatedAmount, uint8 conviction) - emitted when an account (<code>from</code>) delegates a Conviction-weighted vote of a given amount to another account (<code>to</code>)</li> <li>Undelegated(uint16 indexed trackId, address caller) - emitted when an account's (<code>caller</code>) delegations are removed for a specific Track</li> <li>Unlocked(uint16 indexed trackId, address caller) - emitted when an account's (<code>caller</code>) locked tokens are unlocked for a specific Track</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The below example is demonstrated on Moonbase Alpha, however, similar steps can be taken for Moonriver. To follow the steps in this guide, you'll need to have the following:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account with some DEV tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#remix-set-up","title":"Remix Set Up","text":"<ol> <li>Click on the File explorer tab</li> <li>Paste a copy of <code>ConvictionVoting.sol</code> into a Remix file named <code>ConvictionVoting.sol</code></li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile ConvictionVoting.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure ConvictionVoting.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the Conviction Voting Precompile for Moonbase Alpha: <code>0x0000000000000000000000000000000000000812</code> and click At Address</li> <li>The Conviction Voting Precompile will appear in the list of Deployed Contracts</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#vote-on-a-referendum","title":"Vote on a Referendum","text":"<p>You can lock tokens and vote on a referendum at anytime during the Lead-in Period or the Decide Period. In order for a referendum to pass, it needs to garner minimum Approval and Support, which vary by track. For more information on each of the relative periods and the Approval and Support requirements by Track, please refer to the OpenGov section of the governance overview page.</p> <p>First, you'll need to get the index of the referendum you wish to vote on. To get the index of a referendum, head to Polkadot.js Apps and take the following steps:</p> <ol> <li>From the Governance tab dropdown, select Referenda</li> <li>Look for the referenda you want to vote on. You can view more details about a specific referendum by clicking on the triangle icon. If there is no triangle icon, this means that only a proposal hash, and no preimage has been submitted for the proposal</li> <li>Take note of the referendum index</li> </ol> <p></p> <p>Now, you're ready to return to Remix to vote on the referendum via the Conviction Voting Precompile. There are two methods you can use to vote on a referendum: <code>voteYes</code> or <code>voteNo</code>. As you probably have already figured out, if you're in agreement with the proposal, you'll use <code>voteYes</code> and if in disagreement, you'll use <code>voteNo</code>. You'll specify the amount of tokens you want to lock with your vote and the Conviction, using index of the Conviction you want to vote with in the aforementioned <code>Conviction</code> enum. For example, if you wanted to lock your tokens for the duration of two Enactment Periods following a successful vote, you would enter <code>2</code> for the <code>Locked2x</code> Conviction. For more information on Convictions, you can check out the Conviction Multiplier section of the Governance v2 documentation.</p> <p>To submit your vote, you can take the following steps:</p> <ol> <li>Expand the Conviction Voting Precompile contract to see the available functions if it is not already open</li> <li>Find the voteYes or voteNo function, however you want to vote, and press the button to expand the section</li> <li>Enter the index of the referendum to vote on</li> <li>Enter the number of tokens to lock in Wei. Avoid entering your full balance here because you need to pay for transaction fees</li> <li>Enter the Conviction you want to vote with</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p></p> <p>Once the referendum has closed, you can use the Conviction Voting precompile to remove your vote and unlock your tokens.</p>"},{"location":"builders/ethereum/precompiles/features/governance/conviction-voting/#delegate-a-vote","title":"Delegate a Vote","text":"<p>In addition to voting on a referendum yourself, you can delegate a Conviction-weighted vote to someone who is more knowledgeable on a particular topic to vote on your behalf, a process known as Vote Delegation. You can even delegate a different account for each of the Tracks.</p> <p>To get started, you can take the following steps:</p> <ol> <li>Find the delegate function and press the button to expand the section</li> <li>Enter the Track ID of the Track that you want the delegation to be used on. Track IDs can be found in the Referenda page of Polkadot.js Apps</li> <li>Enter the delegate account that will have the power to vote on your behalf</li> <li>Enter the number of tokens they can vote with in Wei. Avoid entering your full balance here because you need to pay for transaction fees</li> <li>Enter the Conviction they can vote with</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p></p> <p>Now the delegate account can vote on your behalf! If you no longer want a delegate vote to exist, you can remove it using the <code>undelegate</code> function of the Conviction Voting Precompile.</p> <p>And that's it! You've completed your introduction to the Conviction Voting Precompile. There are a few more functions that are documented in <code>ConvictionVoting.sol</code> \u2014 feel free to reach out on Discord if you have any questions about those functions or any other aspect of the Conviction Voting Precompile.</p>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/","title":"Interacting with the Preimage Precompile","text":""},{"location":"builders/ethereum/precompiles/features/governance/preimage/#introduction","title":"Introduction","text":"<p>As a Polkadot parachain and decentralized network, Moonbeam features native on-chain governance that enables stakeholders to participate in the direction of the network. With the introduction of OpenGov, also referred to as Governance v2, the Preimage Pallet allows token holders to take the first step towards creating a proposal by submitting the preimage, which is the action to be carried out in the proposal, on-chain. The hash of the preimage is required to submit the proposal. To learn more about Moonbeam's governance system, such as an overview of related terminology, the roadmap of a proposal, and more, please refer to the Governance on Moonbeam page.</p> <p>The Preimage Precompile interacts directly with Substrate's Preimage Pallet. This pallet is coded in Rust and is normally not accessible from the Ethereum side of Moonbeam. However, the Preimage Precompile allows you to access functions needed to create and manage preimages, all of which are part of the Substrate Preimage Pallet, directly from a Solidity interface.</p> <p>The Preimage Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000813\n</code></pre> <pre><code>0x0000000000000000000000000000000000000813\n</code></pre> <pre><code>0x0000000000000000000000000000000000000813\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/#the-preimage-solidity-interface","title":"The Preimage Solidity Interface","text":"<p><code>Preimage.sol</code> is a Solidity interface that allows developers to interact with the precompile's two methods:</p> notePreimage(bytes memory encodedProposal) - registers a preimage on-chain for an upcoming proposal. This doesn't require the proposal to be in the dispatch queue but does require a deposit which is returned once enacted. Parameters <ul> <li><code>encodedProposal</code> - bytes memory containing the encoded proposal to be registered. Returns the preimage hash</li> </ul> unnotePreimage(bytes32 hash) - clears an unrequested preimage from storage. Parameters <ul> <li><code>hash</code> - bytes32 hash of the preimage to be removed from storage</li> </ul> <p>The interface also includes the following events:</p> <ul> <li>PreimageNoted(bytes32 hash) - emitted when a preimage was registered on-chain</li> <li>PreimageUnnoted(bytes32 hash) - emitted when a preimage was un-registered on-chain</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/ethereum/precompiles/features/governance/preimage/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The below example is demonstrated on Moonbase Alpha, however, similar steps can be taken for Moonriver. To follow the steps in this guide, you'll need to have the following:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account with some DEV tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/#remix-set-up","title":"Remix Set Up","text":"<ol> <li>Click on the File explorer tab</li> <li>Paste a copy of <code>Preimage.sol</code> into a Remix file named <code>Preimage.sol</code></li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile Preimage.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure Preimage.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the Preimage Precompile for Moonbase Alpha: <code>0x0000000000000000000000000000000000000813</code> and click At Address</li> <li>The Preimage Precompile will appear in the list of Deployed Contracts</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/preimage/#submit-a-preimage","title":"Submit a Preimage of a Proposal","text":"<p>In order to submit a proposal, you'll first need to submit a preimage of that proposal, which essentially defines the proposed action on-chain. You can submit the preimage using the <code>notePreimage</code> function of the Preimage Precompile. The <code>notePreimage</code> function accepts the encoded proposal, so the first step you'll need to take is to get the encoded proposal, which can easily be done using Polkadot.js Apps.</p> <p>In this section, you'll get the preimage hash and the encoded proposal data for a proposal. To get the preimage hash, you'll first need to navigate to the Preimage page of Polkadot.js Apps:</p> <ol> <li>Navigate to the Governance tab</li> <li>Select Preimages from the dropdown</li> <li>From the Preimages page, click on + Add preimage</li> </ol> <p></p> <p>Then take the following steps:</p> <ol> <li>Select an account (any account is fine because you're not submitting any transaction here)</li> <li>Choose the pallet you want to interact with and the dispatchable function (or action) to propose. The action you choose will determine the fields that need to fill in the following steps. In this example, it is the system pallet and the remark function</li> <li>Enter the text of the remark, ensuring it is unique. Duplicate proposals such as \"Hello World!\" will not be accepted</li> <li>Click the Submit preimage button but don't sign or confirm the transaction on the next page </li> </ol> <p></p> <p>On the next screen, take the following steps:</p> <ol> <li>Press the triangle icon to reveal the encoded proposal in bytes</li> <li>Copy the bytes (encoded proposal) \u2014 you'll need them when calling the <code>notePreimage</code> function</li> </ol> <p></p> <p>Note</p> <p>You should NOT sign and submit the transaction here. You will submit this information via the <code>notePreimage</code> function in the next step.</p> <p>Now you can take the bytes of the encoded proposal that you got from Polkadot.js Apps and submit it via the <code>notePreimage</code> function of the Preimage Precompile. To submit the preimage via the <code>notePreimage</code> function, take the following steps:</p> <ol> <li>Expand the Preimage Precompile contract to see the available functions</li> <li>Find the notePreimage function and press the button to expand the section</li> <li>Provide the bytes of the encoded proposal that you noted in the prior section. Note, the encoded proposal is not the same as the preimage hash. Ensure you are entering the correct value into this field</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p></p> <p>Now that you've submitted the preimage for your proposal your proposal can be submitted! Head over to the Referenda Precompile documentation to learn how to submit your proposal.</p> <p>If you wish to remove a preimage, you can follow the same steps noted above except use the <code>unnotePreimage</code> function and pass in the preimage hash instead of the encoded proposal.</p>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/","title":"Interacting with the Referenda Precompile","text":""},{"location":"builders/ethereum/precompiles/features/governance/referenda/#introduction","title":"Introduction","text":"<p>As a Polkadot parachain and decentralized network, Moonbeam features native on-chain governance that enables stakeholders to participate in the direction of the network. With the introduction of OpenGov, also referred to as Governance v2, the Referenda Pallet allows token holders to get information on existing referenda, submit a proposal to be put forth for referenda, and manage actions related to the Decision Deposit, which is required for a referenda to be decided on. To learn more about Moonbeam's governance system, such as an overview of related terminology, principles, mechanics, and more, please refer to the Governance on Moonbeam page.</p> <p>The Referenda Precompile interacts directly with Substrate's Referenda Pallet. This pallet is coded in Rust and is normally not accessible from the Ethereum side of Moonbeam. However, it allows you to access functions needed to view referenda, submit referenda, and manage the required Decision Deposit. These functions are part of the Substrate Referenda Pallet and can be accessed directly from a Solidity interface.</p> <p>The Referenda Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000811\n</code></pre> <pre><code>0x0000000000000000000000000000000000000811\n</code></pre> <pre><code>0x0000000000000000000000000000000000000811\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#the-referenda-solidity-interface","title":"The Referenda Solidity Interface","text":"<p><code>Referenda.sol</code> is a Solidity interface that allows developers to interact with the precompile's methods.</p> <p>The methods are as follows:</p> referendumCount() - a read-only function that returns the total referendum count ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> total count of referenda</li> </ul> submissionDeposit() - a read-only function that returns the Submission Deposit required for each referendum ParametersReturns <p>None.</p> <ul> <li><code>uint256</code> amount of the required Submission Deposit</li> </ul> decidingCount(uint16 trackId) - a read-only function that returns the total count of deciding referenda for a given Track ParametersReturns <ul> <li><code>trackId</code> - uint16 Track ID to query the deciding count for</li> </ul> <ul> <li><code>uint256</code> count of deciding referenda for the specified Track</li> </ul> trackIds() - a read-only function that returns a list of the Track IDs for all Tracks (and Origins) ParametersReturns <p>None.</p> <ul> <li><code>uint16[]</code> array of Track IDs</li> </ul> trackInfo(uint16 trackId) - a read-only function that returns the following governance parameters configured for a given Track ID ParametersReturns <ul> <li><code>trackId</code> - uint16 Track ID to query the parameters for</li> </ul> <ul> <li><code>string</code> name - the name of the Track</li> <li><code>uint256</code> maxDeciding - the maximum number of referenda that can be decided on at once</li> <li><code>uint256</code> decisionDeposit - the amount of the Decision Deposit</li> <li><code>uint256</code> preparePeriod - the duration of the Prepare Period</li> <li><code>uint256</code> decisionPeriod - the duration of the Decide Period</li> <li><code>uint256</code> confirmPeriod - the duration of the Confirm Period</li> <li><code>uint256</code> minEnactmentPeriod - the minimum amount of time the Enactment Period must be</li> <li><code>bytes</code> minApproval - the minimum \"Aye\" votes as a percentage of overall Conviction-weighted votes needed for an approval</li> <li><code>bytes</code> minSupport - minimum number of \"Aye\" votes, not taking into consideration Conviction-weighted votes, needed as a percent of the total supply needed for an approval</li> </ul> referendumStatus(uint32 referendumIndex) - a read-only function that returns the status for a given referendum ParametersReturns <ul> <li><code>referendumIndex</code> - uint32 index of the referendum to query the status for</li> </ul> <p>ReferendumStatus enum: <pre><code>enum ReferendumStatus {\n     Ongoing,\n     Approved,\n     Rejected,\n     Cancelled,\n     TimedOut,\n     Killed\n}\n</code></pre></p> ongoingReferendumInfo(uint32 referendumIndex) - a read-only function that returns information pertaining to an ongoing referendum ParametersReturns <ul> <li><code>referendumIndex</code> - uint32 index of the ongoing referendum to query</li> </ul> <ul> <li><code>uint16</code> trackId - the Track of this referendum</li> <li><code>bytes</code> origin - the Origin for this referendum</li> <li><code>bytes</code> proposal - the hash of the proposal up for referendum</li> <li><code>bool</code> enactmentType - <code>true</code> if the proposal is scheduled to be dispatched at enactment time and <code>false</code> if after enactment time</li> <li><code>uint256</code> enactmentTime - the time the proposal should be scheduled for enactment</li> <li><code>uint256</code> submissionTime - the time of submission</li> <li><code>address</code> submissionDepositor - the address of the depositor for the Submission Deposit</li> <li><code>uint256</code> submissionDeposit - the amount of the Submission Deposit</li> <li><code>address</code> decisionDepositor - the address of the depositor for the Decision Deposit</li> <li><code>uint256</code> decisionDeposit - the amount of the Decision Deposit</li> <li><code>uint256</code> decidingSince - when this referendum entered the Decide Period</li> <li><code>uint256</code> decidingConfirmingEnd - when this referendum is scheduled to leave the Confirm Period</li> <li><code>uint256</code> ayes - the number of \"Aye\" votes, expressed in terms of post-conviction lock-vote</li> <li><code>uint32</code> support - percent of \"Aye\" votes, expressed pre-conviction, over total votes in the class</li> <li><code>uint32</code> approval - percent of \"Aye\" votes over \"Aye\" and \"Nay\" votes</li> <li><code>bool</code> inQueue - <code>true</code> if this referendum has been placed in the queue for being decided</li> <li><code>uint256</code> alarmTime - the next scheduled wake-up</li> <li><code>bytes</code> taskAddress - scheduler task address if scheduled</li> </ul> closedReferendumInfo(uint32 referendumIndex) - a read-only function that returns information pertaining to a closed referendum ParametersReturns <ul> <li><code>referendumIndex</code> - uint32 index of the closed referendum to query</li> </ul> <ul> <li><code>uint256</code> end - when the referendum ended</li> <li><code>address</code> submissionDepositor - the address of the depositor for the Submission Deposit</li> <li><code>uint256</code> submissionDeposit - the amount of the Submission Deposit</li> <li><code>address</code> decisionDepositor - the address of the depositor for the Decision Deposit</li> <li><code>uint256</code> decisionDeposit - the amount of the Decision Deposit</li> </ul> killedReferendumBlock(uint32 referendumIndex) - a read-only function that returns the block a given referendum was killed ParametersReturns <ul> <li><code>referendumIndex</code> - uint32 index of the killed referendum to query</li> </ul> <ul> <li><code>uint256</code> block number at which the referendum was killed</li> </ul> submitAt(uint16 trackId, bytes32 proposalHash, uint32 proposalLen, uint32 block) - submits a referendum given a Track ID corresponding to the origin from which the proposal is to be dispatched. Returns the referendum index of the submitted referendum ParametersReturns <ul> <li><code>trackId</code> - uint16 Track ID corresponding to the origin from which the proposal is to be dispatched</li> <li><code>proposalHash</code> - bytes32 preimage hash of the proposed runtime call</li> <li><code>proposalLen</code> - uint32 length of the proposal</li> <li><code>block</code> - uint32 block number at which this will be executed</li> </ul> <ul> <li><code>uint32</code> index of the submitted referendum</li> </ul> submitAfter(uint16 trackId, bytes32 proposalHash, uint32 proposalLen, uint32 block) - submits a referendum given a Track ID corresponding to the origin from which the proposal is to be dispatched. Returns the referendum index of the submitted referendum ParametersReturns <ul> <li><code>trackId</code> - uint16 Track ID corresponding to the origin from which the proposal is to be dispatched</li> <li><code>proposalHash</code> - bytes32 preimage hash of the proposed runtime call</li> <li><code>proposalLen</code> - uint32 length of the proposal</li> <li><code>block</code> - uint32 block number after which this will be executed</li> </ul> <ul> <li><code>uint32</code> index of the submitted referendum</li> </ul> placeDecisionDeposit(uint32 index) - posts the Decision Deposit for a referendum given the index of the going referendum ParametersReturns <ul> <li><code>index</code> - uint32 index of the ongoing referendum to place the Decision Deposit for</li> </ul> <p>None.</p> refundDecisionDeposit(uint32 index) - refunds the Decision Deposit for a closed referendum back to the depositor ParametersReturns <ul> <li><code>index</code> - uint32 index of the closed referendum in which the Decision Deposit is still locked</li> </ul> <p>None.</p> refundSubmissionDeposit(uint32 index) - refunds the Submission Deposit for a closed referendum back to the depositor ParametersReturns <ul> <li><code>index</code> - uint32 index of the closed referendum to refund the Submission Deposit for</li> </ul> <p>None.</p> <p>The interface also includes the following events:</p> <ul> <li>SubmittedAt(uint16 indexed trackId, uint32 referendumIndex, bytes32 hash) - emitted when a referenda has been submitted at a given block</li> <li>SubmittedAfter(uint16 indexed trackId, uint32 referendumIndex, bytes32 hash) - emitted when a referenda has been submitted after a given block</li> <li>DecisionDepositPlaced(uint32 index, address caller, uint256 depositedAmount) - emitted when a Decision Deposit for a referendum has been placed</li> <li>DecisionDepositRefunded(uint32 index, address caller, uint256 refundedAmount) - emitted when a Decision Deposit for a closed referendum has been refunded</li> <li>SubmissionDepositRefunded(uint32 index, address caller, uint256 refundedAmount) - emitted when a Submission Deposit for a valid referendum has been refunded</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/ethereum/precompiles/features/governance/referenda/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The below example is demonstrated on Moonbase Alpha, however, similar steps can be taken for Moonriver. To follow the steps in this guide, you'll need to have the following:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account with some DEV tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#remix-set-up","title":"Remix Set Up","text":"<ol> <li>Click on the File explorer tab</li> <li>Paste a copy of <code>Referenda.sol</code> into a Remix file named <code>Referenda.sol</code></li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile Referenda.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure Referenda.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the Referenda Precompile for Moonbase Alpha: <code>0x0000000000000000000000000000000000000811</code> and click At Address</li> <li>The Referenda Precompile will appear in the list of Deployed Contracts</li> </ol>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#submit-a-proposal","title":"Submit a Proposal","text":"<p>In order to submit a proposal, you should have already submitted the preimage hash for the proposal. If you have not done so, please follow the steps outlined in the Preimage Precompile documentation. There are two methods that can be used to submit a proposal: <code>submitAt</code> and <code>submitAfter</code>. The <code>submitAt</code> function submits a proposal to be executed at a given block and the <code>submitAfter</code> function submits a proposal to be executed after a specific block. For this example, <code>submitAt</code> will be used, but the same steps can be applied if you want to use <code>submitAfter</code> instead.</p> <p>To submit the proposal, you'll need to determine which Track your proposal belongs to and the Track ID of that Track. For help with these requirements, you can refer to the OpenGov section of the governance overview page.</p> <p>You'll also need to make sure you have the preimage hash and the length of the preimage handy, both of which you should have received from following the steps in the Preimage Precompile documentation. If you're unsure, you can find your preimage from the Preimage page of Polkadot.js Apps and copy the preimage hash. To get the length of the preimage, you can then query the <code>preimage</code> pallet using the <code>preimageFor</code> method from the Polkadot.js Apps Chain State page.</p> <p>Once you have the Track ID, preimage hash, and preimage length, you can go ahead and submit the proposal using the Referenda Precompile. From Remix, you can take the following steps:</p> <ol> <li>Expand the Referenda Precompile contract to see the available functions</li> <li>Find the submitAt function and press the button to expand the section</li> <li>Enter the track ID that your proposal will be processed through</li> <li>Enter the preimage hash. You should have received this from following the steps in the Preimage Precompile documentation</li> <li>Enter the length of the preimage</li> <li>Enter the block you want the proposal to be executed at</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p></p> <p>After your transaction has been confirmed you'll be able to see the proposal listed on the Referenda page of Polkadot.js Apps. You can also check out your proposal on Polkassembly, which sorts proposals by the Track they belong to.</p>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#submit-decision-deposit","title":"Submit Decision Deposit","text":"<p>Now that you've submitted your proposal, the next step is to submit the Decision Deposit. The Decision Deposit is the minimum deposit amount required for a referendum to progress to the decision phase at the end of the Lead-in Period. For more information on the Decision Deposit, please refer to the OpenGov section of the governance overview page.</p> <p>You can submit the Decision Deposit using the <code>placeDecisionDeposit</code> function of the Referenda Precompile. You'll just need to have the index of the referendum and enough funds to do so. The Decision Deposit varies by Track, to find the minimum amount required you can take a look at the General Parameters by Track table on the governance overview page.</p> <p>To submit the deposit, you can take the following steps:</p> <ol> <li>Find the placeDecisionDeposit function and press the button to expand the section</li> <li>Enter the index of the referendum</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p></p> <p>Now that the Decision Deposit has been placed, the referendum is one step closer to moving to the Decide Period. There will also need to be enough Capacity in the designated Track and the duration of the Prepare Period must pass for it to move to the Decide Period.</p> <p>To vote on referenda, you can follow the steps outlined in the Conviction Voting Precompile documentation.</p>"},{"location":"builders/ethereum/precompiles/features/governance/referenda/#refund-decision-deposit","title":"Refund Decision Deposit","text":"<p>Once a referendum has either been approved or rejected, the Decision Deposit can be refunded. This holds true as long as the referendum wasn't cancelled due to the proposal being malicious. If the proposal is deemed malicious and killed via the Root Track or the Emergency Killer Track, the Decision Deposit will be slashed.</p> <p>To refund the Decision Deposit, you can use the <code>refundDecisionDeposit</code> function of the Referenda Precompile. To do so, you can take the following steps:</p> <ol> <li>Find the refundDecisionDeposit function and press the button to expand the section</li> <li>Enter the index of the referendum</li> <li>Press transact and confirm the transaction in MetaMask</li> </ol> <p></p> <p>And that's it! You've completed your introduction to the Referenda Precompile. There are a few more functions that are documented in <code>Referenda.sol</code> \u2014 feel free to reach out on Discord if you have any questions about those functions or any other aspect of the Referenda Precompile.</p>"},{"location":"builders/ethereum/precompiles/interoperability/gmp/","title":"Interacting with the GMP Precompile","text":""},{"location":"builders/ethereum/precompiles/interoperability/gmp/#introduction","title":"Introduction","text":"<p>Moonbeam Routed Liquidity (MRL) refers to Moonbeam\u2019s use case as the port parachain for liquidity from origin chains into other Polkadot parachains. This is possible because of general message passing (GMP), where messages with arbitrary data and tokens can be sent across non-parachain blockchains through chain-agnostic GMP protocols. These GMP protocols can combine with Polkadot's XCM messaging system to allow for seamless liquidity routing.  </p> <p>The GMP precompile acts as an interface for Moonbeam Routed Liquidity, acting as a middleman between token-bearing messages from GMP protocols and parachains connected to Moonbeam via XCMP. Currently, the GMP Precompile only supports the relaying of liquidity through the Wormhole GMP protocol.  </p> <p>The GMP Precompile is located at the following address:  </p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000816\n</code></pre> <pre><code>0x0000000000000000000000000000000000000816\n</code></pre> <pre><code>0x0000000000000000000000000000000000000816\n</code></pre> <p>In practice, it is unlikely that a developer will have to directly interact with the precompile. GMP protocols' relayers interact with the precompile to complete cross-chain actions, so the origin chain that the cross-chain action originates is where the developer has the responsibility to ensure that the GMP precompile is used eventually.  </p>"},{"location":"builders/ethereum/precompiles/interoperability/gmp/#the-gmp-solidity-interface","title":"The GMP Solidity Interface","text":"<p><code>Gmp.sol</code> is a Solidity interface that allows developers to interact with the precompile.   </p> Gmp.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Gmp contract's address.\naddress constant GMP_ADDRESS = 0x0000000000000000000000000000000000000816;\n\n/// @dev The Gmp contract's instance.\nGmp constant GMP_CONTRACT = Gmp(GMP_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Gmp precompile\n/// @dev Provides an endpoint to Gmp protocols which can automatically forward to XCM\n/// @custom:address 0x0000000000000000000000000000000000000816\ninterface Gmp {\n    // TODO: Here we would specify the endpoints for each GMP protocol on a case by case basis.\n    //       These endpoints are basically the hand offs for each protocol -- where they delegate to\n    //       the target contract.\n    //\n    //       This design should allow users to interact with this precompile with no changes to the\n    //       underlying GMP protocols by simply specifying the correct precompile as the target.\n\n    /// Receive a wormhole VAA and process it\n    ///\n    /// @custom:selector f53774ab\n    function wormholeTransferERC20(bytes memory vaa) external;\n}\n</code></pre> <p>The GMP precompile has one method: </p> <ul> <li>wormholeTransferERC20(bytes memory vaa) - receives a Wormhole bridge transfer verified action approval (VAA), mints tokens via the Wormhole token bridge, and forwards the liquidity to the custom payload\u2019s multilocation. The payload is expected to be a precompile-specific SCALE encoded object, as explained in this guide's Building the Payload for Wormhole section</li> </ul> <p>VAAs are payload-containing packages generated after origin-chain transactions and are discovered by Wormhole Guardians.</p> <p>The most common instance in which a user will have to interact with the precompile is during a recovery, where a relayer doesn\u2019t complete an MRL transaction. For example, a user must search for the VAA that comes with their origin chain transaction and manually invoke the <code>wormholeTransferERC20</code> function.</p>"},{"location":"builders/ethereum/precompiles/interoperability/gmp/#building-the-payload-for-wormhole","title":"Building the Payload for Wormhole","text":"<p>Currently, the GMP precompile only supports sending liquidity with Wormhole, through Moonbeam, and into other parachains. The GMP precompile does not assist with a route from parachains back to Moonbeam and subsequently, Wormhole-connected chains.    </p> <p>To send liquidity from a Wormhole-connected origin chain like Ethereum, users must invoke the <code>transferTokensWithPayload</code> method on the origin-chain's deployment of the WormholeTokenBridge smart contract. This function requires a bytes payload, which must be formatted as a SCALE encoded multilocation object wrapped within another precompile-specific versioned type.</p> <p>You may be unfamiliar with SCALE encoding and multilocations if you are unfamiliar with the Polkadot ecosystem. SCALE encoding is a compact form of encoding that Polkadot uses. The <code>MultiLocation</code> type is used to define a relative point in Polkadot, such as a specific account on a specific parachain (Polkadot blockchain).  </p> <p>Moonbeam\u2019s GMP protocol requires a multilocation to represent the destination for liquidity routing, which most likely means an account on another parachain. Whatever it is, this destination must be expressed as relative to Moonbeam.  </p> <p>Remember</p> <p>Multilocations being relative is important, because a parachain team may erroneously give you a multilocation relative to their own chain, which can be different. Providing an incorrect multilocation can result in loss of funds!</p> <p>Each parachain will have its specific methods of interpreting a multilocation, and should confirm with the project that the multilocation that you formed is correct. However, you will most likely be forming a multilocation with an account.</p> <p>Multiple types of accounts can be included in a multilocation, which you must know beforehand when constructing your multilocation. The two most common are:</p> <ul> <li>AccountKey20 \u2014 an account ID that is 20-bytes in length, including Ethereum-compatible account IDs such as those on Moonbeam</li> <li>AccountId32 \u2014 an account ID that is 32-bytes in length, standard in Polkadot and its parachains</li> </ul> <p>The following multilocation templates target accounts on other parachains with Moonbeam as the relative origin. To use them, replace <code>INSERT_PARACHAIN_ID</code> with the parachain ID of the network you wish to send funds to and replace <code>INSERT_ADDRESS</code> with the address of the account you want to send funds to on that parachain.  </p> AccountId32AccountKey20 <pre><code>{\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { Parachain: 'INSERT_PARACHAIN_ID' },\n        {\n          AccountId32: {\n            id: 'INSERT_ADDRESS',\n          },\n        },\n      ],\n    },\n  },\n};\n</code></pre> <pre><code>{\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { Parachain: 'INSERT_PARACHAIN_ID' },\n        {\n          AccountKey20: {\n            key: 'INSERT_ADDRESS',\n          },\n        },\n      ],\n    },\n  }\n};\n</code></pre> <p>It can be challenging to correctly SCALE encode the entire payload without the right tools, mainly due to the custom types expected by the precompile. Fortunately, the Polkadot.js API can assist with this.</p> <p>The versioned user action expected by the precompile accepts two versions: V1 and V2. V1 accepts the <code>XcmRoutingUserAction</code> type, which attempts to route the transferred assets to the destination defined by the multilocation. V2 accepts the <code>XcmRoutingUserActionWithFee</code> type, which also attempts to route the transferred assets to the destination and allows a fee to be paid. Relayers can use V2 to specify a fee on Moonbeam to relay the transaction to the given destination.</p> <p>The following script shows how to create a <code>Uint8Array</code> that can be used as a payload for the GMP precompile:  </p> V1V2 <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nenum MRLTypes {\n  // Runtime defined MultiLocation. Allows for XCM versions 2, 3, and 4\n  XcmVersionedLocation = 'XcmVersionedLocation',\n  // MRL payload (V1) that only defines the destination MultiLocation\n  XcmRoutingUserAction = 'XcmRoutingUserAction',\n  // Wrapper object for the MRL payload\n  VersionedUserAction = 'VersionedUserAction',\n}\n\n// Parachain IDs of each parachain\nenum Parachain {\n  MoonbaseBeta = 888,\n  // Insert additional parachain IDs\n}\n\n// List of parachains that use ethereum (20) accounts\nconst ETHEREUM_ACCOUNT_PARACHAINS = [Parachain.MoonbaseBeta];\n\n// A function that creates a SCALE encoded payload to use with transferTokensWithPayload\nasync function createMRLPayload(\n  parachainId: Parachain,\n  account: string\n): Promise&lt;Uint8Array&gt; {\n  // Create a multilocation object based on the target parachain's account type\n  const isEthereumStyle = ETHEREUM_ACCOUNT_PARACHAINS.includes(parachainId);\n  const multilocation = {\n    V4: {\n      parents: 1,\n      interior: {\n        X2: [\n          { Parachain: parachainId },\n          isEthereumStyle\n            ? { AccountKey20: { key: account } }\n            : { AccountId32: { id: account } },\n        ],\n      },\n    },\n  };\n\n  // Creates an API for Moonbeam that defines MRL's special types\n  const wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n  const api = await ApiPromise.create({\n    provider: wsProvider,\n    types: {\n      [MRLTypes.XcmRoutingUserAction]: {\n        destination: MRLTypes.XcmVersionedLocation,\n      },\n      [MRLTypes.VersionedUserAction]: {\n        _enum: { V1: MRLTypes.XcmRoutingUserAction },\n      },\n    },\n  });\n\n  // Format multilocation object as a Polkadot.js type\n  const versionedLocation = api.createType(\n    MRLTypes.XcmVersionedLocation,\n    multilocation\n  );\n  const userAction = api.createType(MRLTypes.XcmRoutingUserAction, {\n    destination: versionedLocation,\n  });\n\n  // Wrap and format the MultiLocation object into the precompile's input type\n  const versionedUserAction = api.createType(MRLTypes.VersionedUserAction, {\n    V1: userAction,\n  });\n\n  // Disconnect the API\n  api.disconnect();\n\n  // SCALE encode resultant precompile formatted objects\n  return versionedUserAction.toU8a();\n}\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { u256 } from '@polkadot/types';\n\nenum MRLTypes {\n  // Runtime defined MultiLocation. Allows for XCM versions 2 and 3\n  XcmVersionedLocation = 'XcmVersionedLocation',\n  // MRL payload (V2) that defines the destination MultiLocation and a\n  // fee for the relayer\n  XcmRoutingUserActionWithFee = 'XcmRoutingUserActionWithFee',\n  // Wrapper object for the MRL payload\n  VersionedUserAction = 'VersionedUserAction',\n}\n\n// Parachain IDs of each parachain\nenum Parachain {\n  MoonbaseBeta = 888,\n  // Insert additional parachain IDs\n}\n\n// List of parachains that use ethereum (20) accounts\nconst ETHEREUM_ACCOUNT_PARACHAINS = [Parachain.MoonbaseBeta];\n\n// A function that creates a SCALE encoded payload to use with\n// transferTokensWithPayload\nasync function createMRLPayload(\n  parachainId: Parachain,\n  account: string,\n  fee: u256\n): Promise&lt;Uint8Array&gt; {\n  // Create a multilocation object based on the target parachain's account\n  // type\n  const isEthereumStyle = ETHEREUM_ACCOUNT_PARACHAINS.includes(parachainId);\n  const multilocation = {\n    V4: {\n      parents: 1,\n      interior: {\n        X2: [\n          { Parachain: parachainId },\n          isEthereumStyle\n            ? { AccountKey20: { key: account } }\n            : { AccountId32: { id: account } },\n        ],\n      },\n    },\n  };\n\n  // Creates an API for Moonbeam that defines MRL's special types\n  const wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n  const api = await ApiPromise.create({\n    provider: wsProvider,\n    types: {\n      [MRLTypes.XcmRoutingUserActionWithFee]: {\n        destination: MRLTypes.XcmVersionedLocation,\n        fee: 'U256',\n      },\n      [MRLTypes.VersionedUserAction]: {\n        _enum: { V2: MRLTypes.XcmRoutingUserActionWithFee },\n      },\n    },\n  });\n\n  // Format multilocation object as a Polkadot.js type\n  const versionedLocation = api.createType(\n    MRLTypes.XcmVersionedLocation,\n    multilocation\n  );\n  const userAction = api.createType(MRLTypes.XcmRoutingUserActionWithFee, {\n    destination: versionedLocation,\n    fee,\n  });\n\n  // Wrap and format the MultiLocation object into the precompile's input type\n  const versionedUserAction = api.createType(MRLTypes.VersionedUserAction, {\n    V2: userAction,\n  });\n\n    // Disconnect the API\n    api.disconnect();\n\n  // SCALE encode resultant precompile formatted objects\n  return versionedUserAction.toU8a();\n}\n</code></pre>"},{"location":"builders/ethereum/precompiles/interoperability/gmp/#restrictions","title":"Restrictions","text":"<p>The GMP precompile is currently in its early stages. There are many restrictions, and it only supports a \u201chappy path\u201d into parachains. Here are some restrictions that you should be aware of:</p> <ul> <li>There is currently no fee mechanism. Relayers that run the forwarding of liquidity on Moonbeam to a parachain will be subsidizing transactions. This may change in the future</li> <li>The precompile does not check to ensure that the destination chain supports the token that is being sent to it. Incorrect multilocations may result in loss of funds</li> <li>Errors in constructing a multilocation will result in reverts, which will trap tokens and result in a loss of funds</li> <li>There is currently no recommended path backward, from parachains to other chains like Ethereum. There is additional protocol-level work that must be done before a one-click method can be realized</li> <li>Due to a restriction with the ERC-20 XC-assets, the only way to send tokens from a parachain back through Moonbeam is to have xcGLMR on the origin parachain and use it as a fee asset when sending tokens back  </li> </ul>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/","title":"Ethereum MainNet Precompiled Contracts","text":""},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#introduction","title":"Introduction","text":"<p>Precompiled contracts in Ethereum are contracts that include complex cryptographic computations, but do not require the overhead of the EVM. These precompiles can be used within the EVM to handle specific common operations such as hashing and signature schemes.</p> <p>The following precompiles are currently included: ecrecover, sha256, ripemd-160, Bn128Add, Bn128Mul, Bn128Pairing, the identity function, and modular exponentiation.</p> <p>These precompiles are natively available on Ethereum and, to maintain Ethereum compatibility, they are also available on Moonbeam.</p> <p>In this guide, you will learn how to use and/or verify these precompiles.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>You need to install Node.js (for this example, you can use v16.x) and the npm package manager. You can download directly from Node.js or in your terminal:</p> UbuntuMacOS <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n\nsudo apt install -y nodejs\n</code></pre> <pre><code># You can use homebrew (https://docs.brew.sh/Installation)\nbrew install node\n\n# Or you can use nvm (https://github.com/nvm-sh/nvm)\nnvm install node\n</code></pre> <p>You can verify that everything is installed correctly by querying the version for each package:</p> <pre><code>node -v\n</code></pre> <pre><code>npm -v\n</code></pre> <p>As of writing this guide, the versions used were 15.2.1 and 7.0.8, respectively. You will also need to install the Web3 package by executing:</p> <pre><code>npm install --save web3\n</code></pre> <p>To verify the installed version of Web3, you can use the <code>ls</code> command:</p> <pre><code>npm ls web3\n</code></pre> <p>As of writing this guide, the version used was 1.3.0. You will be also using Remix, connecting it to the Moonbase Alpha TestNet via MetaMask.</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#verify-signatures-with-ecrecover","title":"Verify Signatures with ECRECOVER","text":"<p>The main function of this precompile is to verify the signature of a message. In general terms, you feed <code>ecrecover</code> the transaction's signature values and it returns an address. The signature is verified if the address returned is the same as the public address that sent the transaction.</p> <p>The following will be a small example to showcase how to leverage this precompiled function. You'll need to retrieve the transaction's signature values (<code>v</code>, <code>r</code>, <code>s</code>). Therefore, you'll sign and retrieve the signed message where these values are:</p> <pre><code>const { Web3 } = require('web3');\n\n// Provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\n// Address and Private Key\nconst address = '0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b';\nconst pk1 = '99B3C12287537E38C90A9219D4CB074A89A16E9CDB20BF85728EBD97C343E342';\nconst msg = web3.utils.sha3('supercalifragilisticexpialidocious');\n\nasync function signMessage(pk) {\n  try {\n    // Sign and get Signed Message\n    const smsg = await web3.eth.accounts.sign(msg, pk);\n    console.log(smsg);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nsignMessage(pk1);\n</code></pre> <p>This code will return the following object in the terminal:</p> <pre><code>{\n  message: '0xc2ae6711c7a897c75140343cde1cbdba96ebbd756f5914fde5c12fadf002ec97',\n  messageHash: '0xc51dac836bc7841a01c4b631fa620904fc8724d7f9f1d3c420f0e02adf229d50',\n  v: '0x1b',\n  r: '0x44287513919034a471a7dc2b2ed121f95984ae23b20f9637ba8dff471b6719ef',\n  s: '0x7d7dc30309a3baffbfd9342b97d0e804092c0aeb5821319aa732bc09146eafb4',\n  signature: '0x44287513919034a471a7dc2b2ed121f95984ae23b20f9637ba8dff471b6719ef7d7dc30309a3baffbfd9342b97d0e804092c0aeb5821319aa732bc09146eafb41b'\n}\n</code></pre> <p>With the necessary values, you can go to Remix to test the precompiled contract. Note that this can also be verified with the Web3.js library, but in this case, you can go to Remix to be sure that it is using the precompiled contract on the blockchain. The Solidity code you can use to verify the signature is the following:</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract ECRECOVER {\n    address addressTest = 0x12Cb274aAD8251C875c0bf6872b67d9983E53fDd;\n    bytes32 msgHash =\n        0xc51dac836bc7841a01c4b631fa620904fc8724d7f9f1d3c420f0e02adf229d50;\n    uint8 v = 0x1b;\n    bytes32 r =\n        0x44287513919034a471a7dc2b2ed121f95984ae23b20f9637ba8dff471b6719ef;\n    bytes32 s =\n        0x7d7dc30309a3baffbfd9342b97d0e804092c0aeb5821319aa732bc09146eafb4;\n\n    function verify() public view returns (bool) {\n        // Use ECRECOVER to verify address\n        return (ecrecover(msgHash, v, r, s) == (addressTest));\n    }\n}\n</code></pre> <p>Using the Remix compiler and deployment and with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>verify()</code> method that returns true if the address returned by <code>ecrecover</code> is equal to the address used to sign the message (related to the private key and needs to be manually set in the contract).</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#hashing-with-sha256","title":"Hashing with SHA256","text":"<p>This hashing function returns the SHA256 hash from the given data. To test this precompile, you can use this SHA256 Hash Calculator tool to calculate the SHA256 hash of any string you want. In this case, you'll do so with <code>Hello World!</code>. You can head directly to Remix and deploy the following code, where the calculated hash is set for the <code>expectedHash</code> variable:</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract Hash256 {\n    bytes32 public expectedHash =\n        0x7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069;\n\n    function calculateHash() internal pure returns (bytes32) {\n        string memory word = \"Hello World!\";\n        bytes32 hash = sha256(bytes(word));\n\n        return hash;\n    }\n\n    function checkHash() public view returns (bool) {\n        return (calculateHash() == expectedHash);\n    }\n}\n</code></pre> <p>Once the contract is deployed, you can call the <code>checkHash()</code> method that returns true if the hash returned by <code>calculateHash()</code> is equal to the hash provided.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#hashing-with-ripemd-160","title":"Hashing with RIPEMD160","text":"<p>This hashing function returns a RIPEMD160 hash from the given data. To test this precompile, you can use this RIPEMD160 Hash Calculator tool to calculate the RIPEMD160 hash of any string. In this case, you'll do so again with <code>Hello World!</code>. You'll reuse the same code as before, but use the <code>ripemd160</code> function. Note that it returns a <code>bytes20</code> type variable:</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract HashRipmd160 {\n    bytes20 public expectedHash = hex\"8476ee4631b9b30ac2754b0ee0c47e161d3f724c\";\n\n    function calculateHash() internal pure returns (bytes20) {\n        string memory word = \"Hello World!\";\n        bytes20 hash = ripemd160(bytes(word));\n\n        return hash;\n    }\n\n    function checkHash() public view returns (bool) {\n        return (calculateHash() == expectedHash);\n    }\n}\n</code></pre> <p>With the contract deployed, you can call the <code>checkHash()</code> method that returns true if the hash returned by <code>calculateHash()</code> is equal to the hash provided.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#bn128add","title":"BN128Add","text":"<p>The BN128Add precompile implements a native elliptic curve point addition. It returns an elliptic curve point representing <code>(ax, ay) + (bx, by)</code> such that <code>(ax, ay)</code> and <code>(bx, by)</code> are valid points on the curve BN256.</p> <p>Currently there is no BN128Add support in Solidity, so it needs to be called with inline assembly. The following sample code can be used to call this precompile.</p> <pre><code>pragma solidity &gt;=0.4.21;\n\ncontract Precompiles {\n    function callBn256Add(\n        bytes32 ax,\n        bytes32 ay,\n        bytes32 bx,\n        bytes32 by\n    ) public returns (bytes32[2] memory result) {\n        bytes32[4] memory input;\n        input[0] = ax;\n        input[1] = ay;\n        input[2] = bx;\n        input[3] = by;\n        assembly {\n            let success := call(gas, 0x06, 0, input, 0x80, result, 0x40)\n            switch success\n            case 0 {\n                revert(0, 0)\n            }\n        }\n    }\n}\n</code></pre> <p>Using the Remix compiler and deployment and with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>callBn256Add(bytes32 ax, bytes32 ay, bytes32 bx, bytes32 by)</code> method to return the result of the operation.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#bn128mul","title":"BN128Mul","text":"<p>The BN128Mul precompile implements a native elliptic curve multiplication with a scalar value. It returns an elliptic curve point representing <code>scalar * (x, y)</code> such that <code>(x, y)</code> is a valid curve point on the curve BN256.</p> <p>Currently there is no BN128Mul support in Solidity, so it needs to be called with inline assembly. The following sample code can be used to call this precompile.</p> <pre><code>pragma solidity &gt;=0.4.21;\n\ncontract Precompiles {\n    function callBn256ScalarMul(\n        bytes32 x,\n        bytes32 y,\n        bytes32 scalar\n    ) public returns (bytes32[2] memory result) {\n        bytes32[3] memory input;\n        input[0] = x;\n        input[1] = y;\n        input[2] = scalar;\n        assembly {\n            let success := call(gas, 0x07, 0, input, 0x60, result, 0x40)\n            switch success\n            case 0 {\n                revert(0, 0)\n            }\n        }\n    }\n}\n</code></pre> <p>Using the Remix compiler and deployment and with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>callBn256ScalarMul(bytes32 x, bytes32 y, bytes32 scalar)</code> method to return the result of the operation.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#bn128pairing","title":"BN128Pairing","text":"<p>The BN128Pairing precompile implements elliptic curve pairing operation to perform zkSNARK verification. For more information, check out the EIP-197 standard.</p> <p>Currently there is no BN128Pairing support in Solidity, so it needs to be called with inline assembly. The following sample code can be used to call this precompile.</p> <pre><code>pragma solidity &gt;=0.4.21;\n\ncontract Precompiles {\n    function callBn256Pairing(\n        bytes memory input\n    ) public returns (bytes32 result) {\n        // input is a serialized bytes stream of (a1, b1, a2, b2, ..., ak, bk) from (G_1 x G_2)^k\n        uint256 len = input.length;\n        require(len % 192 == 0);\n        assembly {\n            let memPtr := mload(0x40)\n            let success := call(\n                gas(),\n                0x08,\n                0,\n                add(input, 0x20),\n                len,\n                memPtr,\n                0x20\n            )\n            switch success\n            case 0 {\n                revert(0, 0)\n            }\n            default {\n                result := mload(memPtr)\n            }\n        }\n    }\n}\n</code></pre> <p>Using the Remix compiler and deployment and with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>function callBn256Pairing(bytes memory input)</code> method to return the result of the operation.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#the-identity-function","title":"The Identity Function","text":"<p>Also known as datacopy, this function serves as a cheaper way to copy data in memory.</p> <p>Currently there is no Identity Function support in Solidity, so it needs to be called with inline assembly. The following sample code (adapted to Solidity), can be used to call this precompiled contract:</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract Identity {\n    bytes public memoryStored;\n\n    function callDatacopy(bytes memory data) public returns (bytes memory) {\n        bytes memory result = new bytes(data.length);\n        assembly {\n            let len := mload(data)\n            if iszero(\n                call(\n                    gas(),\n                    0x04,\n                    0,\n                    add(data, 0x20),\n                    len,\n                    add(result, 0x20),\n                    len\n                )\n            ) {\n                invalid()\n            }\n        }\n\n        memoryStored = result;\n\n        return result;\n    }\n}\n</code></pre> <p>You can use this Web3 Type Converter tool to get bytes from any string, as this is the input of the <code>callDataCopy()</code> method.</p> <p>With the contract deployed, you can call the <code>callDataCopy()</code> method and verify if <code>memoryStored</code> matches the bytes that you pass in as an input of the function.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#modular-exponentiation","title":"Modular Exponentiation","text":"<p>This precompile calculates the remainder when an integer <code>b</code> (base) is raised to the <code>e</code>-th power (the exponent), and is divided by a positive integer <code>m</code> (the modulus).</p> <p>The Solidity compiler does not support it, so it needs to be called with inline assembly. The following code was simplified to show the functionality of this precompile:</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract ModularCheck {\n    uint public checkResult;\n\n    // Function to Verify ModExp Result\n    function verify(uint _base, uint _exp, uint _modulus) public {\n        checkResult = modExp(_base, _exp, _modulus);\n    }\n\n    function modExp(\n        uint256 _b,\n        uint256 _e,\n        uint256 _m\n    ) public returns (uint256 result) {\n        assembly {\n            // Free memory pointer\n            let pointer := mload(0x40)\n            // Define length of base, exponent and modulus. 0x20 == 32 bytes\n            mstore(pointer, 0x20)\n            mstore(add(pointer, 0x20), 0x20)\n            mstore(add(pointer, 0x40), 0x20)\n            // Define variables base, exponent and modulus\n            mstore(add(pointer, 0x60), _b)\n            mstore(add(pointer, 0x80), _e)\n            mstore(add(pointer, 0xa0), _m)\n            // Store the result\n            let value := mload(0xc0)\n            // Call the precompiled contract 0x05 = bigModExp\n            if iszero(call(not(0), 0x05, 0, pointer, 0xc0, value, 0x20)) {\n                revert(0, 0)\n            }\n            result := mload(value)\n        }\n    }\n}\n</code></pre> <p>You can try this in Remix. Use the function <code>verify()</code>, passing the base, exponent, and modulus. The function will store the value in the <code>checkResult</code> variable.</p>"},{"location":"builders/ethereum/precompiles/utility/eth-mainnet/#p256-verify","title":"P256 Verify","text":"<p>The P256Verify Precompile adds support for RIP-7212, signature verification for Secp256r1 elliptic curve. This precompile adds a WASM implementation of the signature verification and is intended to be replaced by a native runtime function call once available.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\ncontract P256Verify {\n    function verify(\n        bytes32 msg_hash,\n        bytes32[2] memory signature,\n        bytes32[2] memory public_key\n    ) public view returns (bool) {\n        bool output;\n\n        bytes memory args = abi.encodePacked(\n            msg_hash,\n            signature[0],\n            signature[1],\n            public_key[0],\n            public_key[1]\n        );\n\n        bool success;\n        assembly {\n            success := staticcall(not(0), 0x100, add(args, 32), mload(args), output, 0x20)\n        }\n        require(success, \"p256verify precompile call failed\");\n\n        return output;\n    }\n}\n</code></pre> <p>The file below contains two different test cases: one with a valid signature test and a second with an invalid signature test.</p> p256verifywithtests.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\ncontract P256Verify {\n    function verify(\n        bytes32 msg_hash,\n        bytes32[2] memory signature,\n        bytes32[2] memory public_key\n    ) public view returns (bool) {\n        bool output;\n\n        bytes memory args = abi.encodePacked(\n            msg_hash,\n            signature[0],\n            signature[1],\n            public_key[0],\n            public_key[1]\n        );\n\n        bool success;\n        assembly {\n            success := staticcall(not(0), 0x100, add(args, 32), mload(args), output, 0x20)\n        }\n        require(success, \"p256verify precompile call failed\");\n\n        return output;\n    }\n\n    function test() public {\n        bytes32[2] memory msg_hashes;\n        bytes32[2][2] memory signatures;\n        bytes32[2][2] memory public_keys;\n        bool[2] memory expected_result;\n\n        // Case 1 (valid)\n        msg_hashes[0] = hex\"b5a77e7a90aa14e0bf5f337f06f597148676424fae26e175c6e5621c34351955\";\n        signatures[0][0] = hex\"289f319789da424845c9eac935245fcddd805950e2f02506d09be7e411199556\";\n        signatures[0][1] = hex\"d262144475b1fa46ad85250728c600c53dfd10f8b3f4adf140e27241aec3c2da\";\n        public_keys[0][0] = hex\"3a81046703fccf468b48b145f939efdbb96c3786db712b3113bb2488ef286cdc\";\n        public_keys[0][1] = hex\"ef8afe82d200a5bb36b5462166e8ce77f2d831a52ef2135b2af188110beaefb1\";\n        expected_result[0] = true;\n\n        // Case 2 (invalid)\n        msg_hashes[1] = hex\"d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b\";\n        signatures[1][0] = hex\"6162630000000000000000000000000000000000000000000000000000000000\";\n        signatures[1][1] = hex\"6162630000000000000000000000000000000000000000000000000000000000\";\n        public_keys[1][0] = hex\"6162630000000000000000000000000000000000000000000000000000000000\";\n        public_keys[1][1] = hex\"6162630000000000000000000000000000000000000000000000000000000000\";\n        expected_result[0] = false;\n\n        for (uint256 i = 0; i &lt; expected_result.length; i++) {\n            bool result = verify(msg_hashes[i], signatures[i], public_keys[i]);\n            if (expected_result[i]) {\n                require(result, \"Expected success\");\n            } else {\n                require(!result, \"Expected failure\");\n            }\n        }\n    }\n}\n</code></pre> <p>Using the Remix compiler and deployment and with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>verify</code> method with the following parameters: </p> Valid SignatureInvalid Signature Parameter Value <code>msg_hash</code> <code>0xb5a77e7a90aa14e0bf5f337f06f597148676424fae26e175c6e5621c34351955</code> <code>signature</code> <code>[\"0x289f319789da424845c9eac935245fcddd805950e2f02506d09be7e411199556\", \"0xd262144475b1fa46ad85250728c600c53dfd10f8b3f4adf140e27241aec3c2da\"]</code> <code>public_key</code> <code>[\"0x3a81046703fccf468b48b145f939efdbb96c3786db712b3113bb2488ef286cdc\", \"0xef8afe82d200a5bb36b5462166e8ce77f2d831a52ef2135b2af188110beaefb1\"]</code> Expected Result <code>true</code> Parameter Value <code>msg_hash</code> <code>0xd182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b</code> <code>signature</code> <code>[\"0x6162630000000000000000000000000000000000000000000000000000000000\", \"0x6162630000000000000000000000000000000000000000000000000000000000\"]</code> <code>public_key</code> <code>[\"0x6162630000000000000000000000000000000000000000000000000000000000\", \"0x6162630000000000000000000000000000000000000000000000000000000000\"]</code> Expected Result <code>false</code> <p>You'll receive two booleans in response; the first one indicates whether the signature was valid, and the second indicates whether the call to the P256Verify precompile was successful. The second boolean should always return true; the first is the one to check to see if the signature is valid. </p>"},{"location":"builders/ethereum/precompiles/utility/non-specific/","title":"Non-Network Specific Precompiled Smart Contracts","text":""},{"location":"builders/ethereum/precompiles/utility/non-specific/#introduction","title":"Introduction","text":"<p>A precompiled contract, or precompile, is a set of programmed functionalities hard-coded into the blockchain client. Precompiles perform computationally heavy tasks, such as cryptographic processes like hashing. Moving these functionalities to the blockchain client serves the dual purpose of making the computation more efficient than using a traditional smart contract and ensuring everyone has access to the complete and accurate set of processes and algorithms required to operate correctly.</p> <p>Precompile functionality is bundled and shared under a smart contract address, which allows interactions similar to those of a traditional smart contract. Some precompiled contracts are not specific to Ethereum or Moonbeam, but are supported for use in your Moonbeam application. </p> <p>The nonspecific precompiles currently included in this category are the <code>ECRecoverPublicKey</code> and <code>SHA3FIPS256</code> precompiles. </p> <p>In the next section, you will learn more about the functionalities included in these precompiles.  </p>"},{"location":"builders/ethereum/precompiles/utility/non-specific/#retrieve-a-public-key-with-ecrecoverpublickey","title":"Retrieve a Public Key with ECRecoverPublicKey","text":"<p>The primary function of the <code>ECRecoverPublicKey</code> precompile is to recover the public key used to create a digital signature from a given message hash and signature. This precompile is similar to ECRecover, with the exception of returning the public key of the account that signed the message rather than the account address. </p> <p>In the following sections, you will learn how to use the <code>ECRecoverPublicKey</code> precompile.</p>"},{"location":"builders/ethereum/precompiles/utility/non-specific/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>You need to install Node.js (for this example, you can use v16.x) and the npm package manager. You can download directly from Node.js or in your terminal:</p> UbuntuMacOS <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n\nsudo apt install -y nodejs\n</code></pre> <pre><code># You can use homebrew (https://docs.brew.sh/Installation)\nbrew install node\n\n# Or you can use nvm (https://github.com/nvm-sh/nvm)\nnvm install node\n</code></pre> <p>You can verify that everything is installed correctly by querying the version for each package:</p> <pre><code>node -v\n</code></pre> <pre><code>npm -v\n</code></pre> <p>The versions used in this example are v20.15.0 (Node.js) and 10.7.0 (npm). You will also need to install the Web3 package by executing:</p> <pre><code>npm install --save web3\n</code></pre> <p>To verify the installed version of Web3, you can use the <code>ls</code> command:</p> <pre><code>npm ls web3\n</code></pre> <p>This example uses version 4.11.1. You will also use Remix, connecting it to the Moonbase Alpha TestNet via MetaMask.</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/ethereum/precompiles/utility/non-specific/#retrieve-transaction-signature-values","title":"Retrieve Transaction Signature Values","text":"<p>To use the <code>ECRecoverPublicKey</code> precompile, you must first sign a message to create and retrieve the message hash and transaction signature values (<code>v</code>, <code>r</code>, <code>s</code>) to pass as arguments in the contract call. Always use security best practices when handling private keys. </p> <p>Create a new file called <code>signMessage.js</code> in your project directory:</p> <pre><code>touch signMessage.js\n</code></pre> <p>Open <code>signMessage.js</code> in your code editor and add the following script to initialize Web3 with Moonbase Alpha TestNet, sign and hash the message, and return the signature values:</p> signMessage.js<pre><code>const { Web3 } = require('web3');\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\n// Address and private key\nconst address = 'INSERT_RECEIVER_ADDRESS';\nconst pk1 =\n  'INSERT_SENDER_PRIVATE_KEY';\nconst msg = web3.utils.sha3('supercooltestmessage');\n\nasync function signMessage(pk) {\n  try {\n    // Sign and get signed message\n    const smsg = await web3.eth.accounts.sign(msg, pk);\n    console.log(smsg);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nsignMessage(pk1);\n</code></pre> <p>Return to your terminal command line to run the script with this command:</p> <pre><code>node signMessage.js\n</code></pre> <p>This code will return the following object in the terminal:</p> node signMessage.js {   message: '0x5836e21a51f25aad199e2e0feb5ca19673ed56b3811285f5124d7a8171d75851',   messageHash: '0xa69b720d0293b9e8f4e471afb80f9d410b825abe5ce524e7d5755fd2a00bf9de',   v: '0x1b',   r: '0xb7d4783ee3b34d6fbc419d5b7bc67002c511322c5c71b49a7d78a8b7e9c5b30a',   s: '0x4e5939eaef3917b1cb09af9e632cc9a727b64191b7ee40a6ae34f6fdde60a371',   signature: '0xb7d4783ee3b34d6fbc419d5b7bc67002c511322c5c71b49a7d78a8b7e9c5b30a4e5939eaef3917b1cb09af9e632cc9a727b64191b7ee40a6ae34f6fdde60a3711b' } <p>Save these values as you will need them in the next section.</p>"},{"location":"builders/ethereum/precompiles/utility/non-specific/#test-ecrecoverpublickey-contract","title":"Test ECRecoverPublicKey Contract","text":"<p>You can now visit Remix to test the precompiled contract. Note that you could also use the Web3.js library, but in this case, you can go to Remix to ensure it is using the precompiled contract on the blockchain. The Solidity code you can use to retrieve the public key is the following:</p> RecoverPublicKey.sol<pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity &gt;=0.8.2 &lt;0.9.0;\n\ncontract RecoverPublicKey {\n    function recoverPublicKey(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public view returns (bytes memory) {\n        address precompileAddress = 0x0000000000000000000000000000000000000402;\n        (bool success, bytes memory publicKey) = precompileAddress.staticcall(\n            abi.encodeWithSignature(\n                \"ECRecoverPublicKey(bytes32,uint8,bytes32,bytes32)\",\n                hash,\n                v,\n                r,\n                s\n            )\n        );\n        require(success, \"ECRecoverPublicKey failed\");\n        return publicKey;\n    }\n}\n</code></pre> <p>Using the Remix compiler and deployment and with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>recoverPublicKey()</code> method which returns the public key for the account that signed the message. You can now use this public key value for other cryptographic functions and verifications.</p> <p></p>"},{"location":"builders/ethereum/precompiles/utility/non-specific/#create-a-hash-with-sha3fips256","title":"Create a Hash with SHA3FIPS256","text":"<p>SHA3-256 is part of the SHA-3 family of cryptographic hashes codified in FIPS202 that produces an output 256 bits in length. Although the name is similar to SHA256, the SHA-3 family is built with an entirely different algorithm and accordingly produces a different hash output than SHA256 for the same input. You can verify this yourself using this SHA3-256 Hash Calculator tool. After calculating the SHA3-256 output, change the algorithm in the drop-down selector to SHA256 and take note of the resulting output.</p> <p>Currently there is no SHA3-256 support in Solidity, so it needs to be called with inline assembly. The following sample code can be used to call this precompile.</p> <pre><code>pragma solidity ^0.7.0;\n\ncontract Precompiles {\n    function sha3fips(bytes memory data) public view returns (bytes32) {\n        bytes32[1] memory h;\n        assembly {\n            if iszero(\n                staticcall(not(0), 0x400, add(data, 32), mload(data), h, 32)\n            ) {\n                invalid()\n            }\n        }\n        return h[0];\n    }\n}\n</code></pre> <p>Using Remix with MetaMask pointing to Moonbase Alpha, you can deploy the contract and call the <code>sha3fips(bytes memory data)</code> method to return the encoded string of the data parameter.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/ethereum/precompiles/utility/registry/","title":"Precompile Registry on Moonbeam","text":""},{"location":"builders/ethereum/precompiles/utility/registry/#introduction","title":"Introduction","text":"<p>The Precompile Registry serves as a single source of truth for the available precompiles on Moonbeam. The Precompile Registry can be used to determine if an address corresponds to a precompile and whether or not a precompile is active or deprecated. This is particularly useful when there are upstream changes within the Substrate and Polkadot ecosystems that result in backward-incompatible changes to precompiles. Developers can design an exit strategy to ensure their dApp recovers gracefully in these scenarios.</p> <p>The Precompile Registry also serves an additional purpose, as it allows any user to set \"dummy code\" (<code>0x60006000fd</code>) for precompiles, which makes precompiles callable from Solidity. This is necessary as precompiles on Moonbeam, by default, don't have bytecode. The \"dummy code\" can bypass checks in Solidity that ensure contract bytecode exists and is non-empty.</p> <p>The Registry Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000815\n</code></pre> <pre><code>0x0000000000000000000000000000000000000815\n</code></pre> <pre><code>0x0000000000000000000000000000000000000815\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/utility/registry/#the-solidity-interface","title":"The Precompile Registry Solidity Interface","text":"<p><code>PrecompileRegistry.sol</code> is a Solidity interface that allows developers to interact with the precompile's methods.</p> PrecompileRegistry.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Precompile Registry contract's address.\naddress constant PRECOMPILE_REGISTRY_ADDRESS = 0x0000000000000000000000000000000000000815;\n\n/// @dev The Precompile Registry contract's instance.\nPrecompileRegistry constant PRECOMPILE_REGISTRY_CONTRACT = PrecompileRegistry(PRECOMPILE_REGISTRY_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Precompile Registry\n/// @dev Interface to the set of available precompiles.\ninterface PrecompileRegistry {\n    /// @dev Query if the given address is a precompile. Note that deactivated precompiles\n    /// are still considered precompiles and will return `true`.\n    /// @param a: Address to query\n    /// @return output Is this address a precompile?\n    /// @custom:selector 446b450e\n    function isPrecompile(address a) external view returns (bool);\n\n    /// @dev Query if the given address is an active precompile. Will return false if the\n    /// address is not a precompile or if this precompile is deactivated.\n    /// @param a: Address to query\n    /// @return output Is this address an active precompile?\n    /// @custom:selector 6f5e23cf\n    function isActivePrecompile(address a) external view returns (bool);\n\n    /// @dev Update the account code of a precompile address.\n    /// As precompiles are implemented inside the Runtime, they don't have a bytecode, and\n    /// their account code is empty by default. However in Solidity calling a function of a\n    /// contract often automatically adds a check that the contract bytecode is non-empty.\n    /// For that reason a dummy code (0x60006000fd) can be inserted at the precompile address\n    /// to pass that check. This function allows any user to insert that code to precompile address\n    /// if they need it.\n    /// @param a: Address of the precompile.\n    /// @custom:selector 48ceb1b4\n    function updateAccountCode(address a) external;\n}\n</code></pre> <p>The interface includes the following functions:</p> isPrecompile(address a) - returns a boolean indicating whether a given address is a precompile or not. Returns <code>true</code> for active and deprecated precompiles ParametersReturns <ul> <li><code>a</code> - address to check if it is a precompile</li> </ul> <ul> <li><code>bool</code> whether the address is a precompile (active or deprecated)</li> </ul> isActivePrecompile(address a) - returns a boolean indicating whether a given address is an active precompile or not. Returns <code>false</code> if a precompile has been deprecated ParametersReturns <ul> <li><code>a</code> - address to check if it is an active precompile</li> </ul> <ul> <li><code>bool</code> whether the address is an active precompile</li> </ul> updateAccountCode(address a) - updates a given precompile's bytecode with dummy code (<code>0x60006000fd</code>) given the address of the precompile. Precompiles, by default, don't have bytecode associated with them. This function can be used to add dummy bytecode to bypass requirements in Solidity that check if a contract's bytecode is not empty before its functions can be called ParametersReturns <ul> <li><code>a</code> - address of the precompile to update with dummy bytecode</li> </ul> <p>None.</p>"},{"location":"builders/ethereum/precompiles/utility/registry/#interact-with-precompile-registry-interface","title":"Interact with the Precompile Registry Solidity Interface","text":"<p>The following sections will cover how to interact with the Registry Precompile from Remix and Ethereum libraries, such as Ethers.js and Web3.py.</p> <p>The examples in this guide will be on Moonbase Alpha. To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/ethereum/precompiles/utility/registry/#use-remix","title":"Use Remix to Interact with the Precompile Registry","text":"<p>To quickly get started with Remix, the Precompile Registry contract has been loaded from GitHub. You can also create a new file in Remix and manually paste in the contents of the <code>PrecompileRegistry.sol</code> contract.</p> <p></p> <p>Then you can take the following steps to compile, deploy, and interact with the Precompile Registry:</p> <ol> <li> <p>From the Compile tab, click on Compile PrecompileRegistry.sol to compile the contract.  A green checkmark will appear upon successfully compiling the contract</p> <p></p> </li> <li> <p>From the Deploy and run transactions tab, you can load the Precompile Registry using its address:</p> <ol> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down and you've connected MetaMask to Moonbase Alpha</li> <li>Ensure PrecompileRegistry is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the Precompile in the At Address field</li> <li>Provide the address of the Precompile Registry for Moonbase Alpha: <code>0x0000000000000000000000000000000000000815</code> and click At Address</li> <li>The Precompile Registry will appear in the list of Deployed Contracts</li> </ol> <p></p> </li> <li> <p>You can interact with any of the precompile's methods. Under Deployed Contracts, expand the Precompile Registry to view the list of methods. For example, you can use the isPrecompile function to check if an address is a precompile</p> <p></p> </li> </ol>"},{"location":"builders/ethereum/precompiles/utility/registry/#use-ethereum-libraries","title":"Use Ethereum Libraries to Interact with the Precompile Registry","text":"<p>To interact with the Precompile Registry's Solidity interface with an Ethereum library, you'll need the Precompile Registry's ABI.</p> Precompile Registry ABI <pre><code>[\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isActivePrecompile\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isPrecompile\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"updateAccountCode\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    }\n]\n</code></pre> <p>Once you have the ABI, you can interact with the Registry using the Ethereum library of your choice. Generally speaking, you'll take the following steps:</p> <ol> <li>Create a provider</li> <li>Create a contract instance of the Precompile Registry</li> <li>Interact with the Precompile Registry's functions</li> </ol> <p>Remember</p> <p>The following snippets are for demo purposes only. Never store your private keys in a JavaScript or Python file.</p> Ethers.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport ABI from './precompileRegistryABI.js'; // Import Precompile Registry ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n// Create interface for the Precompile Registry\nconst precompileRegistry = new ethers.Contract(\n  '0x0000000000000000000000000000000000000815',\n  ABI,\n  signer\n);\n\n// Interact with the Precompile Registry\nconst isActivePrecompile = async () =&gt; {\n  const proxyPrecompile = '0x000000000000000000000000000000000000080b';\n\n  // Check if the Proxy Precompile is a precompile\n  const isPrecompile = await precompileRegistry.isPrecompile(proxyPrecompile);\n  // Should return 'Address is a precompile: true'\n  console.log(`Address is a precompile: ${isPrecompile}`);\n\n  // Check if the Proxy Precompile is an active precompile\n  const isActivePrecompile = await precompileRegistry.isActivePrecompile(\n    proxyPrecompile\n  );\n  // Should return 'Address is an active precompile: true'\n  console.log(`Address is an active precompile: ${isActivePrecompile}`);\n};\n\nisActivePrecompile();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_PRECOMPILE_REGISTRY_ABI\"  # Paste or import the Precompile Registry ABI\nprivate_key = \"INSERT_PRIVATE_KEY\"\n\n# Create provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create interface for the Precompile Registry\nprecompile_registry = web3.eth.contract(\n    address=\"0x0000000000000000000000000000000000000815\", abi=abi\n)\n\n\n# Interact with the Precompile Registry\ndef is_active_precompile():\n    proxy_precompile = \"0x000000000000000000000000000000000000080b\"\n\n    # Check if the Proxy Precompile is a precompile\n    is_precompile = precompile_registry.functions.isPrecompile(proxy_precompile).call()\n    # Should return 'Address is a precompile: true'\n    print(\"Address is a precompile: \", is_precompile)\n\n    # Check if the Proxy Precompile is an active precompile\n    is_active_precompile = precompile_registry.functions.isActivePrecompile(\n        proxy_precompile\n    ).call()\n    # Should return 'Address is an active precompile: true'\n    print(\"Address is an active precompile: \", is_active_precompile)\n\n\nis_active_precompile()\n</code></pre>"},{"location":"builders/ethereum/precompiles/utility/relay-data-verifier/","title":"Interacting with the Relay Data Verifier Precompile","text":""},{"location":"builders/ethereum/precompiles/utility/relay-data-verifier/#introduction","title":"Introduction","text":"<p>Polkadot relies on state proofs to guarantee data integrity at a particular time. A state proof is a concise, cryptographic data structure representing a specific subset of transactions or state data within a trie. It consists of a set of hashes that form a path from the target data to the root hash stored in the block header.</p> <p>A client can independently reconstruct the root hash and compare it with the original stored in the block header by providing a state proof. If the reconstructed root hash matches the original, it confirms the target data's authenticity, validity, and inclusion within the blockchain.</p> <p>Polkadot's unique architecture and parachain block validation process means blockchains like Moonbeam have the relay chain storage root hash in their state. Consequently, Moonbeam can provide a mechanism to verify a relay chain state by checking the proof against the stored storage root hash.</p> <p>Moonbeam's relay data verifier precompiled contract provides an easy way for smart contracts to programmatically build functions that rely on verifying relay chain state in contract calls. Consequently, no oracles are needed to feed relay chain data to Moonbeam. This functionality is readily available at the following contract addresses:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000819\n</code></pre> <pre><code>0x0000000000000000000000000000000000000819\n</code></pre> <pre><code>0x0000000000000000000000000000000000000819\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/utility/relay-data-verifier/#the-relay-data-verifier-solidity-interface","title":"The Relay Data Verifier Solidity Interface","text":"<p><code>RelayDataVerifier.sol</code> is a Solidity interface that allows developers to interact with the precompile's methods.</p> RelayDataVerifier.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The RelayDataVerifier contract's address.\naddress constant RELAY_DATA_VERIFIER_ADDRESS = 0x0000000000000000000000000000000000000819;\n\n/// @dev The RelayDataVerifier contract's instance.\nRelayDataVerifier constant RELAY_DATA_VERIFIER_CONTRACT = RelayDataVerifier(\n    RELAY_DATA_VERIFIER_ADDRESS\n);\n\n/// @author The Moonbeam Team\n/// @title Relay Proof Verifier Interface\n/// @dev The interface that Solidity contracts use to interact with the Relay Proof Verifier\n/// precompile.\n/// A typical workflow to verify relay chain data is the following:\n/// 1. Moonbeam RPC Call: Call `latestRelayBlockNumber` function to get the latest relay\n///    block number tracked by the chain in `pallet-storage-root`.\n/// 2. Relay RPC Call: Call `chain_getBlockHash(blockNumber)` RPC method to get the relay block hash\n///    for the block number obtained in step 1.\n/// 3. Relay RPC Call: Call `state_getReadProof(keys, at)` RPC method where `at`\n///    is the relay block hash obtained in step 2 to get the 'ReadProof` of the entries.\n/// 4. Moonbeam RPC Call: Submit an ethereum transaction (directly or through a SC) to call the\n///    `verifyEntry` or `verifyEntries` function to verify the data against the relay block\n///    number. The call data contain the relay block number obtained in step 1, and the read\n///    proof generated in step 3, along with the key/s to verify.\n/// @custom:address 0x0000000000000000000000000000000000000819\ninterface RelayDataVerifier {\n    /// @dev ReadProof struct returned by the `state_getReadProof` RPC method.\n    struct ReadProof {\n        // The block hash against which the proof is generated\n        bytes32 at;\n        /// The storage proof\n        bytes[] proof;\n    }\n\n    /// @dev Verifies a storage entry in the Relay Chain using a relay block number and a storage\n    /// proof. This function takes a relay block number, a storage proof, and the key of the storage\n    /// entry to verify. It returns the value associated with the key if the verification is\n    /// successful.\n    /// @custom:selector 27001faa\n    /// @param relayBlockNumber The relay block number against which the entry is being verified.\n    /// @param readProof The storage proof used to verify the entry.\n    /// @param key The key of the storage entry to verify.\n    /// @return value The value associated with the key, returned as a bytes array.\n    function verifyEntry(\n        uint32 relayBlockNumber,\n        ReadProof calldata readProof,\n        bytes calldata key\n    ) external returns (bytes memory value);\n\n    /// @dev Verifies a set of entries in the Relay Chain and returns the corresponding values.\n    /// This function takes a relay block number, a storage proof, and an array of keys for the\n    /// storage entries to verify. It returns an array of values associated with the keys, in the\n    /// same order as the keys.\n    /// @custom:selector 2da33a45\n    /// @param relayBlockNumber The relay block number for which the data is being verified.\n    /// @param readProof The storage proof used to verify the data.\n    /// @param keys The keys of the storage entries to verify.\n    /// @return values The values associated with the keys, returned in the same order as the keys.\n    function verifyEntries(\n        uint32 relayBlockNumber,\n        ReadProof calldata readProof,\n        bytes[] calldata keys\n    ) external returns (bytes[] memory values);\n\n    /// @dev Returns the latest relay block number that has a storage root stored on-chain.\n    /// @custom:selector aed36869\n    /// @return relayBlockNumber the lastest relay block number\n    function latestRelayBlockNumber()\n        external\n        view\n        returns (uint32 relayBlockNumber);\n}\n</code></pre> <p>The interface includes the following functions:</p> latestRelayBlockNumber() \u2014 retrieves the most recent relay chain block that has its storage root stored on the blockchain itself ParametersReturns <p>None</p> <p>The latest relay block number that has a storage root stored on-chain.</p> verifyEntry(uint32 relayBlockNumber, ReadProof calldata readProof, bytes callData key) \u2014 verifies a storage entry in the relay chain using a relay block number, a storage proof, and the storage key. It returns the value associated with the key if the verification is successful ParametersReturns <ul> <li><code>relayBlockNumber</code> - the relay block number for which the data is being verified. The latest relay block number can be obtained from the <code>latestRelayBlockNumber()</code> function</li> <li><code>readProof</code> - a struct defined in the precompile contract, containing the storage proof used to verify the data. The <code>ReadProof</code> struct is defined as:   <pre><code>struct ReadProof {\n    // The block hash against which the proof is generated\n    bytes32 at;\n    /// The storage proof\n    bytes[] proof;\n}\n</code></pre></li> <li><code>key</code> - the storage key for the generated proof</li> </ul> <p>When performing a static call on the <code>verifyEntry</code> function, you can view the returned value associated with the key in hexadecimal format.</p> <pre><code>'0x01000000040000000100000000000000f88ce384dca20000000000000000000000370589030a0000000000000000000000203d88792d0000000000000000000000000000000000000000000000000080'\n</code></pre> verifyEntries(uint32 relayBlockNumber, ReadProof calldata readProof, bytes[] callData keys) \u2014 verifies a set of entries in the relay chain and returns the corresponding values. This function takes a relay block number, a storage proof, and an array of storage keys to verify. It returns an array of values associated with the keys, in the same order as the keys ParametersReturns <ul> <li><code>relayBlockNumber</code> - the relay block number for which the data is being verified. The latest relay block number can be obtained from the <code>latestRelayBlockNumber()</code> function</li> <li><code>readProof</code> - a struct defined in the precompile contract, containing the storage proof used to verify the data. The <code>ReadProof</code> struct is defined as: <pre><code>struct ReadProof {\n    // The block hash against which the proof is generated\n    bytes32 at;\n    /// The storage proof\n    bytes[] proof;\n}\n</code></pre></li> <li><code>keys</code> - the storage keys for the generated proof</li> </ul> <p>When performing a static call on the <code>verifyEntries</code> function, you can view an array containing the corresponding values mapped to their respective keys, represented in hexadecimal format.</p> <pre><code>['0x01000000040000000100000000000000f88ce384dca20000000000000000000000370589030a0000000000000000000000203d88792d0000000000000000000000000000000000000000000000000080']\n</code></pre>"},{"location":"builders/ethereum/precompiles/utility/relay-data-verifier/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":"<p>A typical workflow to verify relay chain data involves the following steps:</p> <ol> <li>Moonbeam RPC call - call the <code>latestRelayBlockNumber</code> function to get the latest relay block number tracked by the chain in the <code>pallet-storage-root</code></li> <li>Relay RPC call - call the <code>chain_getBlockHash(blockNumber)</code> RPC method to get the relay block hash for the block number obtained in step one</li> <li>Relay RPC call - call the <code>state_getReadProof(keys, at)</code> RPC method to retrieve the storage proof, where <code>at</code> is the relay block hash obtained in step two, and <code>keys</code> is an array of strings which contains the keys for target storage items. For <code>@polkadot/api</code>, it can be obtained via <code>api.query.module.key()</code> function</li> <li>Moonbeam RPC call - submit an Ethereum transaction to call the <code>verifyEntry</code> or <code>verifyEntries</code> function to verify the data against the relay block number. The call data should contain the relay block number obtained in step one, the read proof generated in step three, and the key(s) to verify</li> </ol> <p>The following sections will cover how to interact with the Relay Data Verifier Precompile using Ethereum libraries, such as Ethers.js and Web3.py. The examples in this guide will be on Moonbase Alpha.</p>"},{"location":"builders/ethereum/precompiles/utility/relay-data-verifier/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>Create or have an account on Moonbase Alpha to test out the different features in the precompile</li> <li>The account will need to be funded with <code>DEV</code> tokens.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/utility/relay-data-verifier/#using-ethereum-libraries","title":"Using Ethereum Libraries","text":"<p>To interact with the Solidity interface using an Ethereum library, you'll need the precompile's ABI (Application Binary Interface). The ABI for the Relay Chain Data Verifier Precompile is as follows:</p> Relay Data Verifier Precompile ABI <pre><code>[\n  {\n    inputs: [],\n    name: 'latestRelayBlockNumber',\n    outputs: [\n      {\n        internalType: 'uint32',\n        name: 'relayBlockNumber',\n        type: 'uint32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint32',\n        name: 'relayBlockNumber',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'bytes32',\n            name: 'at',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'proof',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct RelayDataVerifier.ReadProof',\n        name: 'readProof',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes[]',\n        name: 'keys',\n        type: 'bytes[]',\n      },\n    ],\n    name: 'verifyEntries',\n    outputs: [\n      {\n        internalType: 'bytes[]',\n        name: 'values',\n        type: 'bytes[]',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint32',\n        name: 'relayBlockNumber',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'bytes32',\n            name: 'at',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'proof',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct RelayDataVerifier.ReadProof',\n        name: 'readProof',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'key',\n        type: 'bytes',\n      },\n    ],\n    name: 'verifyEntry',\n    outputs: [\n      {\n        internalType: 'bytes',\n        name: 'value',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> <p>Once you have the ABI, you can interact with the precompile using the Ethereum library of your choice, such as Ethers.js or Web3.py. The general steps are as follows:</p> <ol> <li>Create a provider</li> <li>Create a contract instance of the precompile</li> <li>Interact with the precompile's functions</li> </ol> <p>The provided code example demonstrates how to use the Ethers.js library to interact with the Moonbase Alpha network and its relay chain, verifying a data entry using the <code>verifyEntry</code> function.</p> <p>Note</p> <p>The code snippets presented in the following sections are not meant for production environments. Please make sure you adapt it for each use case.</p> Ethers.jsWeb3.py <pre><code>// For reading local ABI file\nimport * as fs from 'fs';\n// Import Ethers library, to interact with Moonbeam networks\nimport { ethers } from 'ethers';\n// Import Polkadot library, to interact with relay chain\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst abi = JSON.parse(fs.readFileSync('./RelayChainDataVerifierABI.json'));\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst precompileAddress = '0x0000000000000000000000000000000000000819';\nconst moonbeamURL = 'https://rpc.api.moonbase.moonbeam.network';\nconst relayURL = 'wss://relay.api.moonbase.moonbeam.network';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(moonbeamURL);\nconst signer = new ethers.Wallet(privateKey, provider);\nconst precompileContract = new ethers.Contract(precompileAddress, abi, signer);\n\nasync function run() {\n  // Create provider for relay chain\n  const wsProvider = new WsProvider(relayURL);\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Get the storage key for a random account on relay chain\n  const key = api.query.system.account.key(\n    '5CBATpb3yvEM4mhX9Dw3tyuqiWKhq9YBG6ugSbodRUSbodoU'\n  );\n  // Find the latest available relay chain block number from Moonbeam\n  const blockNum = await precompileContract.latestRelayBlockNumber();\n\n  // Get the block hash and storage proof from relay chain\n  const blockHash = await api.rpc.chain.getBlockHash(blockNum);\n  const proof = await api.rpc.state.getReadProof([key], blockHash);\n\n  // This tx will be rejected if the verification failed\n  const receipt = await precompileContract.verifyEntry(blockNum, proof, key);\n  await receipt.wait();\n  console.log(receipt.hash);\n}\n\nawait run();\n</code></pre> <pre><code># Import packages\nfrom eth_account import Account\nfrom substrateinterface import SubstrateInterface\nfrom web3 import Web3\n\n# Initialize variables\nabi = INSERT_ABI\n\nprivateKey = \"INSERT_PRIVATE_KEY\"\nprecompileAddress = \"0x0000000000000000000000000000000000000819\"\nmoonbeamURL = \"https://rpc.api.moonbase.moonbeam.network\"\nrelayURL = \"wss://relay.api.moonbase.moonbeam.network\"\n\n# Create provider for Moonbeam network\nweb3 = Web3(Web3.HTTPProvider(moonbeamURL))\naccount = Account.from_key(privateKey)\nprecompileContract = web3.eth.contract(address=precompileAddress, abi=abi)\n\n# Create provider for relay chain\nsubstrate = SubstrateInterface(url=relayURL)\n\n# Get storage key\nkey = substrate.generate_storage_hash(\n    storage_module=\"System\",\n    storage_function=\"Account\",\n    params=[\"5CBATpb3yvEM4mhX9Dw3tyuqiWKhq9YBG6ugSbodRUSbodoU\"],\n)\n\n# Find the latest available relay chain block number from Moonbeam\nblockNum = precompileContract.functions.latestRelayBlockNumber().call()\n\n# Get the block hash from relay chain\nblockHash = substrate.get_block_hash(blockNum)\n\n# Get the storage proof from relay chain\nresponse = substrate.rpc_request(\"state_getReadProof\", [[key], blockHash])\nproof = response[\"result\"]\n\n# Call smart contract\ntx = precompileContract.functions.verifyEntry(blockNum, proof, key).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account.address),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account.address)\n        ),\n    }\n)\ntx_create = web3.eth.account.sign_transaction(tx, privateKey)\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n</code></pre>"},{"location":"builders/ethereum/precompiles/ux/batch/","title":"Interacting with the Batch Precompile","text":""},{"location":"builders/ethereum/precompiles/ux/batch/#introduction","title":"Introduction","text":"<p>The batch precompiled contract on Moonbeam allows developers to combine multiple EVM calls into one.</p> <p>Currently, having users interact with multiple contracts would require multiple transaction confirmations in the user's wallet. An example would be approving a smart contract's access to a token, then transferring it. With the batch precompile, developers can enhance user experience with batched transactions as it minimizes the number of transactions a user is required to confirm to one. Additionally, gas fees can be reduced since batching avoids multiple base gas fees (the initial 21000 units of gas spent to begin a transaction).</p> <p>The precompile interacts directly with Substrate's EVM pallet. The caller of the batch function will have their address act as the <code>msg.sender</code> for all subtransactions, but unlike delegate calls, the target contract will still affect its own storage. It is effectively the same as if the user signed multiple transactions, but with only one confirmation.</p> <p>The precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000808\n</code></pre> <pre><code>0x0000000000000000000000000000000000000808\n</code></pre> <pre><code>0x0000000000000000000000000000000000000808\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#the-batch-interface","title":"The Batch Solidity Interface","text":"<p><code>Batch.sol</code> is a Solidity interface that allows developers to interact with the precompile's three methods.</p> <p>The interface includes the following functions:</p> batchSome(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) - performs multiple calls, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, following subcalls will still be attempted Parameters <ul> <li><code>to</code> - address[] array of addresses to direct subtransactions to, where each entry is a subtransaction</li> <li><code>value</code> - uint256[] array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all the following subtransactions will default to a value of 0</li> <li><code>callData</code> - bytes[] array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all of the following subtransactions will include no call data</li> <li><code>gasLimit</code> - uint64[] array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the to array, all of the following subtransactions will have all remaining gas forwarded</li> </ul> batchSomeUntilFailure(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) - performs multiple calls, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, no following subcalls will be executed Parameters <ul> <li><code>to</code> - address[] array of addresses to direct subtransactions to, where each entry is a subtransaction</li> <li><code>value</code> - uint256[] array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all the following subtransactions will default to a value of 0</li> <li><code>callData</code> - bytes[] array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all of the following subtransactions will include no call data</li> <li><code>gasLimit</code> - uint64[] array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the to array, all of the following subtransactions will have all remaining gas forwarded</li> </ul> batchAll(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) - performs multiple calls atomically, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, all subcalls will revert Parameters <ul> <li><code>to</code> - address[] array of addresses to direct subtransactions to, where each entry is a subtransaction</li> <li><code>value</code> - uint256[] array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all the following subtransactions will default to a value of 0</li> <li><code>callData</code> - bytes[] array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all of the following subtransactions will include no call data</li> <li><code>gasLimit</code> - uint64[] array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the to array, all of the following subtransactions will have all remaining gas forwarded</li> </ul> <p>The interface also includes the following required events:</p> <ul> <li>SubcallSucceeded(uint256 index) - emitted when subcall of the given index succeeds</li> <li>SubcallFailed(uint256 index) - emitted when a subcall of the given index  fails</li> </ul>"},{"location":"builders/ethereum/precompiles/ux/batch/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/ethereum/precompiles/ux/batch/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>Create or have two accounts on Moonbase Alpha to test out the different features in the batch precompile</li> <li>At least one of the accounts will need to be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/ux/batch/#example-contract","title":"Example Contract","text":"<p>The contract <code>SimpleContract.sol</code> will be used as an example of batching contract interactions, but in practice, any contract can be interacted with.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.30;\n\ncontract SimpleContract {\n    mapping(uint256 =&gt; string) public messages;\n\n    function setMessage(uint256 id, string calldata message) external {\n        messages[id] = message;\n    }\n}\n</code></pre>"},{"location":"builders/ethereum/precompiles/ux/batch/#remix-set-up","title":"Remix Set Up","text":"<p>You can interact with the batch precompile using Remix. You'll need a copy of <code>Batch.sol</code> and <code>SimpleContract.sol</code>. To add the precompile to Remix and follow along with the tutorial, you will need to:</p> <ol> <li>Click on the File explorer tab</li> <li>Paste the <code>Batch.sol</code> contract into a Remix file named Batch.sol</li> <li>Paste the <code>SimpleContract.sol</code> contract into a Remix file named SimpleContract.sol</li> </ol>"},{"location":"builders/ethereum/precompiles/ux/batch/#compile-the-contract","title":"Compile the Contract","text":"<p>Next, you will need to compile both files in Remix:</p> <ol> <li>Make sure that you have the Batch.sol file open</li> <li>Click on the Compile tab, second from top</li> <li>To compile the contract, click on Compile Batch.sol</li> </ol> <p></p> <p>If the interface was compiled successfully, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#access-the-precompile","title":"Access the Precompile","text":"<p>Instead of deploying the batch precompile, you will access the interface given the address of the precompiled contract:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note the precompiled contract is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT dropdown. Once you select Injected Provider - Metamask, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure Batch - Batch.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract, there is no need to deploy any code. Instead we are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the batch precompile: <code>0x0000000000000000000000000000000000000808</code> and click At Address</li> </ol> <p></p> <p>The BATCH precompile will appear in the list of Deployed Contracts.</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#deploy-example-contract","title":"Deploy Example Contract","text":"<p>On the other hand, <code>SimpleContract.sol</code> will be deployed as a new contract. Before starting this section, repeat the compilation step with the <code>SimpleContract.sol</code> file.</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT dropdown. Once you select Injected Provider - Metamask, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure SimpleContract - SimpleContract.sol is selected in the CONTRACT dropdown</li> <li>Click Deploy</li> <li>Confirm the MetaMask transaction that appears by clicking Confirm</li> </ol> <p></p> <p>The SIMPLECONTRACT contract will appear in the list of Deployed Contracts.</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#send-native-currency-via-precompile","title":"Send Native Currency via Precompile","text":"<p>Sending native currency with the batch precompile is more involved than pressing a few buttons in Remix or MetaMask. For this example, you will be using the batchAll function to send native currency atomically.</p> <p>Transactions have a value field to specify the amount of native currency being sent with it. In Remix, this is represented by the VALUE input in the DEPLOY &amp; RUN TRANSACTIONS tab. However, for the batch precompile, this data is provided within the value array input of the batch functions.</p> <p>Try transferring native currency to two wallets of your choice via the batch precompile on Moonbase Alpha:</p> <ol> <li>Make sure that you have at least 0.5 DEV in your connected wallet</li> <li>Expand the batch contract under Deployed Contracts</li> <li>Expand the batchAll function</li> <li>For the to input, insert your addresses in the following format: <code>[\"INSERT_ADDRESS_1\", \"INSERT_ADDRESS_2\"]</code>, where the first address corresponds to the first wallet of your choice and the second address corresponds to the second wallet of your choice</li> <li>For the value input, insert the amount you wish to transfer in Wei for each address. For example, <code>[\"100000000000000000\", \"200000000000000000\"]</code> will transfer 0.1 DEV to the first address and 0.2 DEV to the second address</li> <li>For both of the remaining callData and gasLimit inputs, insert <code>[]</code>. Call data and gas limit are not a concern for transferring native currency</li> <li>Press transact</li> <li>Press Confirm in the MetaMask extension to confirm the transaction</li> </ol> <p></p> <p>Once the transaction is complete, be sure to check both of the accounts' balances, either in MetaMask or in a block explorer. Congratulations! You've now sent a batched transfer via the batch precompile.</p> <p>Note</p> <p>Typically if you wanted to send the native currency to or through a contract, you would have to set the value within the overall transaction object and interact with a payable function. However, since the batch precompile interacts directly with Substrate code, this is not a typical Ethereum transaction and is thus not necessary.</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#find-a-contract-interactions-call-data","title":"Find a Contract Interaction's Call Data","text":"<p>Visual interfaces like Remix and handy libraries like Ethers.js hide the way that Ethereum transactions interact with Solidity smart contracts. The name and input types of a function are hashed into a function selector and the input data is encoded. These two pieces are then combined and sent as the transaction's call data. To send a subtransaction within a batch transaction, the sender needs to know its call data beforehand.</p> <p>Try finding a transaction's call data using Remix:</p> <ol> <li>Expand the <code>SimpleContract.sol</code> contract under Deployed Contracts</li> <li>Expand the setMessage function</li> <li>Enter the input of the function. For this example, id will be <code>1</code> and message will be <code>\"moonbeam\"</code></li> <li>Instead of sending the transaction, click the copy button next to the transact button to copy the call data</li> </ol> <p></p> <p>Now you have the transaction's call data! Considering the example values of <code>1</code> and <code>\"moonbeam\"</code>, we can keep an eye out for their encoded values in the call data:</p> <pre><code>0x648345c8                                                        // function selector\n0000000000000000000000000000000000000000000000000000000000000001  // 1 id\n0000000000000000000000000000000000000000000000000000000000000040  // 64 string offset\n0000000000000000000000000000000000000000000000000000000000000008  // 8 length in bytes\n6d6f6f6e6265616d000000000000000000000000000000000000000000000000  // \"moonbeam\" in bytes\n</code></pre> <p>The call data can be broken into five lines, where:</p> <ul> <li>The first line is the function selector</li> <li>The second line is equal to 1, which is the id that was provided</li> <li>What's left has to do with the message input. These last three lines are tricky, since strings are a dynamic type with a dynamic length. The third line refers to an offset to define where the string's data starts. The fourth line refers to the string's length, in this case 8 because \"moonbeam\" is 8 bytes long . Finally, the fifth line is \"moonbeam\" in hexadecimal format (8 ASCII characters are 16 hexadecimal characters) left aligned and with zeros for padding</li> </ul>"},{"location":"builders/ethereum/precompiles/ux/batch/#function-interaction-via-precompile","title":"Function Interaction via Precompile","text":"<p>This section's example will be using the batchAll function that will ensure the transactions are resolved atomically. Keep in mind that there are also two other batch functions that can either continue subtransactions despite errors or halt subsequent subtransactions but not revert previous ones.</p> <p>Interacting with a function is very similar to sending a native currency, since they are both transactions. However, call data is required to properly provide input to functions and a sender may desire to limit the amount of gas spent in each subtransaction.</p> <p>The <code>callData</code> and <code>gasLimit</code> fields are more relevant for subtransactions that interact with contracts. For each function in the batch interface, the <code>callData</code> input is an array where each index corresponds to the call data for each recipient of the subtransaction, that is, each <code>to</code> input. If the size of the <code>callData</code> array is less than the <code>to</code> array, the remaining subtransactions will have no call data (functions with no inputs). The <code>gasLimit</code> input is an array that corresponds to the amount of gas that each can spend for each subtransaction. If its value at an index is 0 or the index is the size of the array or greater (and smaller than the <code>to</code> array's size), all of the remaining gas from the previous subtransaction is forwarded.</p> <p>To use the precompile to send an atomic batch transaction, take the following steps:</p> <ol> <li>Copy the <code>SimpleContract.sol</code> contract's address with the copy button on the right side of its header. Be sure to also have the call data from the previous section</li> <li>Expand the batch contract under Deployed Contracts</li> <li>Expand the batchAll function</li> <li>For the to input, insert the address of the <code>SimpleContract.sol</code> contract that you previously copied in the following format: <code>[\"INSERT_SIMPLE_CONTRACT_ADDRESS\"]</code></li> <li>For the value input, since <code>SimpleContract.sol</code> does not require any native currency to be paid to it, insert <code>[\"0\"]</code> for 0 Wei</li> <li>For the callData input, insert your call data from the previous section in the following format: <code>[\"INSERT_CALL_DATA\"]</code></li> <li>For the gasLimit input, insert <code>[]</code>. You can put in a gas limit value, but it is optional</li> <li>Press transact</li> <li>Press Confirm in the MetaMask extension to confirm the transaction</li> </ol> <p></p> <p>If you used the same call data as the tutorial, check to make sure that the transaction has been successful:</p> <ol> <li>Expand the <code>SimpleContract.sol</code> contract under Deployed Contracts</li> <li>To the right of the messages button, insert <code>1</code></li> <li>Press the blue messages button</li> </ol> <p></p> <p>The phrase \"moonbeam\" should appear underneath it. Congratulations! You have interacted with a function with the batch precompile.</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#combining-subtransactions","title":"Combining Subtransactions","text":"<p>So far, transferring native currency and interacting with functions have been separate, but they can be intertwined.</p> <p>The following four strings can be combined as inputs for a batch transaction. They will transact 1 DEV to the public Gerald (<code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code>) account, and interact with a predeployed <code>SimpleContract.sol</code> contract twice. Here is a break-down:</p> <p>There are three subtransactions, so there are three addresses in the <code>to</code> input array. The first is the public Gerald account, the next two are a predeployed <code>SimpleContract.sol</code> contract. You can replace the last two with your own instance of <code>SimpleContract.sol</code> if you wish. Or, replace only one: you can interact with multiple contracts in a single message.</p> <pre><code>[\n  \"0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b\",\n  \"0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39\", \n  \"0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39\"\n]\n</code></pre> <p>There will also be three values for the <code>value</code> array. The first address in the <code>to</code> input array has to do with sending 1 DEV, so 1 DEV in Wei is within the array. The following two values are 0 because the function that their subtransactions are interacting with do not accept or require native currency.  </p> <pre><code>[\"1000000000000000000\", \"0\", \"0\"]\n</code></pre> <p>You will need three values for the <code>callData</code> array. Since transferring native currency does not require call data, the string is simply blank. The second and third values in the array correspond to invocations of setMessage that set messages to ids 5 and 6.</p> <pre><code>[\n  \"0x\", \n  \"0x648345c8000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000009796f752061726520610000000000000000000000000000000000000000000000\", \n  \"0x648345c800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000e61206d6f6f6e6265616d2070726f000000000000000000000000000000000000\"\n]\n</code></pre> <p>The final input is for <code>gas_input</code>. This array will be left empty to forward all remaining gas to each subtransaction.</p> <pre><code>[]\n</code></pre> <p>Try sending a batched transaction with these inputs in Remix the same way you batched a function call.</p> <p>And that's it! You've successfully interacted with the ERC-20 precompile using MetaMask and Remix!</p>"},{"location":"builders/ethereum/precompiles/ux/batch/#ethereum-development-libraries","title":"Ethereum Development Libraries","text":"<p>If you have followed the Ethers.js tutorial on Moonbeam, you may find it difficult to find the call data for a function. The answer is hidden within Ether's <code>Interface</code> object, where the encodeFunctionData function allows you to input your function name and inputs to receive the resultant call data.</p> <p>Note</p> <p>The code snippets presented in the following sections are not meant for production environments. Please make sure you adapt it for each use-case.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>// Import the contract ABI\nconst { abi } = require('./INSERT_ABI_PATH');\n\n// Use ABI to create an interface\nconst yourContractInterface = new ethers.Interface(abi);\n\n// Find call data for the setMessage function\nconst callData = yourContractInterface.encodeFunctionData(\n  'INSERT_FUNCTION_NAME',\n  [\n    'INSERT_INPUT_1',\n    'INSERT_INPUT_2',\n    // ...\n  ]\n);\n</code></pre> <pre><code>// Import the contract ABI\nconst { abi } = require('./INSERT_ABI_PATH');\n\n// Find call data for the setMessage function\nconst callData = web3.eth.abi.encodeFunctionCall(abi, [\n  'INSERT_INPUT_1',\n  'INSERT_INPUT_2',\n  // ...\n]);\n</code></pre> <pre><code># Import the ABI and bytecode\nfrom compile import abi, bytecode\n\n# Create contract instance\nyour_contract = web3.eth.contract(abi=abi, bytecode=bytecode)\n\n# Encode the contract call\ncall_data = your_contract.encodeABI(\n    fn_name=\"INSERT_FUNCTION_NAME\", args=[\"INSERT_INPUT_1\", \"INSERT_INPUT_2\", ...]\n)\n</code></pre> <p>Afterwards, you should be all set to interact with the batch precompile as one typically would with a contract in Ethers.</p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/","title":"Interacting with the Call Permit Precompile","text":""},{"location":"builders/ethereum/precompiles/ux/call-permit/#introduction","title":"Introduction","text":"<p>The Call Permit Precompile on Moonbeam allows a user to sign a permit, an EIP-712 signed message, for any EVM call and it can be dispatched by anyone or any smart contract. It is similar to the ERC-20 Permit Solidity Interface, except it applies to any EVM call instead of approvals only.</p> <p>When the call permit is dispatched, it is done so on behalf of the user who signed the permit and the user or contract that dispatches the permit is responsible for paying transaction fees. As such, the precompile can be used to perform gas-less transactions.</p> <p>For example, Alice signs a call permit and Bob dispatches it and performs the call on behalf of Alice. Bob pays for the transaction fees and as such, Alice doesn't need to have any of the native currency to pay for the transaction, unless the call includes a transfer.</p> <p>The Call Permit Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x000000000000000000000000000000000000080a\n</code></pre> <pre><code>0x000000000000000000000000000000000000080a\n</code></pre> <pre><code>0x000000000000000000000000000000000000080a\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#the-call-permit-interface","title":"The Call Permit Solidity Interface","text":"<p><code>CallPermit.sol</code> is a Solidity interface that allows developers to interact with the precompile's three methods.</p> <p>The interface includes the following functions:</p> dispatch(address from, address to, uint256 value, bytes data, uint64[] gaslimit, uint256 deadline, uint8 v, bytes32 r, bytes32 s) - dispatches a call on the behalf of another user with a EIP-712 permit. This function can be called by anyone or any smart contract. The transaction will revert if the permit is not valid or if the dispatched call reverts or errors (such as out of gas). If successful, the nonce of the signer is increased to prevent this permit to be replayed Parameters <ul> <li><code>from</code> - address of the signer of the permit. The call will be dispatched on behalf of this address</li> <li><code>to</code> - address the call is made to</li> <li><code>value</code> - uint256 value being transferred from the <code>from</code> account</li> <li><code>data</code> - bytes containing the call data, or action to be executed</li> <li><code>gasLimit</code> - uint64[] gas limit the dispatched call requires. Providing an argument for this parameter prevents the dispatcher from manipulating the gas limit</li> <li><code>deadline</code> - uint256 time in UNIX seconds after which the permit will no longer be valid. In JavaScript, you can get the current time in UNIX seconds by running <code>console.log(Math.floor(Date.now() / 1000))</code> in a JavaScript script or a browser console</li> <li><code>v</code> - uint8 recovery ID of the signature. The last one byte of the concatenated signature</li> <li><code>r</code> - bytes32 first 32 bytes of the concatenated signature</li> <li><code>s</code> - bytes32 second 32 bytes of the concatenated signature</li> </ul> nonces(address owner) - returns the current nonce for given owner Parameters <ul> <li><code>owner</code> - address of the account to query the nonce for</li> </ul> DOMAIN_SEPARATOR() - returns the EIP-712 domain separator which is used to avoid replay attacks. It follows the EIP-2612 implementation Parameters <p>None.</p> <p>The domain separator is defined in the EIP-712 standard and is calculated as:</p> <pre><code>keccak256(PERMIT_DOMAIN, name, version, chain_id, address)\n</code></pre> <p>The parameters of the hash can be broken down as follows:</p> <ul> <li>PERMIT_DOMAIN - is the <code>keccak256</code> of <code>EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)</code></li> <li>name - is the name of the signing domain and must be <code>'Call Permit Precompile'</code> exactly</li> <li>version - is the version of the signing domain. For this case version is set to <code>1</code></li> <li>chainId - is the chain ID of the network</li> <li>verifyingContract - is the address of the contract that will verify the signature. In this case, the Call Permit Precompile address</li> </ul> <p>When <code>dispatch</code> is called, the permit needs to be verified before the call is dispatched. The first step is to compute the domain separator. The calculation can be seen in Moonbeam's implementation or you can check out a practical example in OpenZeppelin's EIP712 contract.</p> <p>From there, a hash of the signature and the given arguments is generated which guarantees that the signature can only be used for the call permit. It uses a given nonce to ensure the signature is not subject to a replay attack. It is similar to OpenZeppelin's <code>ERC20Permit</code> contract, except the <code>PERMIT_TYPEHASH</code> is for a call permit, and the arguments match that of the dispatch function plus the nonce.</p> <p>The domain separator and the hash struct can be used to build the final hash of the fully encoded message. A practical example is shown in OpenZeppelin's EIP712 contract.</p> <p>With the final hash and the v, r, and s values, the signature can be verified and recovered. If successfully verified, the nonce will increase by one and the call will be dispatched.</p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#setup-the-example-contract","title":"Setup the Contracts","text":"<p>For this example, you'll learn how to sign a call permit that updates a message in a simple example contract, <code>SetMessage.sol</code>. Before you can generate the call permit signature, you'll need to deploy the contract and define the <code>dispatch</code> function arguments for the call permit.</p> <p>Once you've setup the example contract, then you can setup the Call Permit Precompile contract.</p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>Create or have two accounts on Moonbase Alpha to test out the different features in the Call Permit Precompile</li> <li>At least one of the accounts will need to be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#example-contract","title":"Example Contract","text":"<p>The <code>SetMessage.sol</code> contract will be used as an example of using a call permit, but in practice, any contract can be interacted with.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.7;\n\ncontract SetMessage {\n    string storedMessage;\n\n    function set(string calldata x) public {\n        storedMessage = x;\n    }\n\n    function get() public view returns (string memory) {\n        return storedMessage;\n    }\n}\n</code></pre>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#remix-set-up","title":"Remix Set Up","text":"<p>You can use Remix to compile the example contract and deploy it. You'll need a copy of <code>SetMessage.sol</code> and <code>CallPermit.sol</code>. To add the contracts to Remix, you can take the following steps:</p> <ol> <li>Click on the File explorer tab</li> <li>Paste the <code>SetMessage.sol</code> contract into a Remix file named <code>SetMessage.sol</code></li> <li>Paste the <code>CallPermit.sol</code> contract into a Remix file named <code>CallPermit.sol</code></li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#compile-deploy-example-contract","title":"Compile &amp; Deploy the Example Contract","text":"<p>First you'll need to compile the example contract:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile SetMessage.sol</li> </ol> <p></p> <p>Then you can deploy it:</p> <ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure SetMessage.sol is selected in the CONTRACT dropdown</li> <li>Click Deploy</li> <li>MetaMask will pop up and you'll need to Confirm the transaction</li> </ol> <p></p> <p>The contract will appear under the list of Deployed Contracts on the left side panel. Copy the contract address as you will need to use it to generate the call permit signature in the next section.</p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#compile-access-call-permit","title":"Compile &amp; Access the Call Permit Precompile","text":"<p>First you'll need to compile the Call Permit Precompile contract:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile CallPermit.sol</li> </ol> <p></p> <p>Then instead of deploying the contract, you'll just need to access it given the address of the precompile:</p> <ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure CallPermit.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the Call Permit Precompile for Moonbase Alpha: <code>0x000000000000000000000000000000000000080a</code> and click At Address</li> <li>The Call Permit Precompile will appear in the list of Deployed Contracts</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#generate-call-permit-signature","title":"Generate Call Permit Signature","text":"<p>In order to interact with the Call Permit Precompile, you have to have or generate a signature to dispatch the call permit with. There are several ways you can generate the signature, this guide will show you two different ways to generate it: in the browser using the MetaMask extension and JSFiddle and using MetaMask's <code>@metamask/eth-sig-util</code> npm package.</p> <p>Regardless of which method you choose to generate the signature, the following steps will be taken:</p> <ol> <li>The <code>message</code> will be created and includes some of the data that is needed to create the call permit. It includes the arguments that will be passed into the <code>dispatch</code> function and the nonce of the signer</li> <li>A JSON structure of the data the user needs to sign will be assembled for the call permit and include all of the types for the <code>dispatch</code> arguments and the nonce. This will result in the <code>CallPermit</code> type and will be saved as the <code>primaryType</code></li> <li>The domain separator will be created using <code>\"Call Permit Precompile\"</code> exactly for the name, the version of your DApp or platform, the chain ID of the network the signature is to be used on, and the address of the contract that will verify the signature</li> <li>All of the assembled data, the <code>types</code>, <code>domain</code>, <code>primaryType</code> and <code>message</code>, will be signed using MetaMask (either in the browser or through the MetaMask's JavaScript signing library)</li> <li>The signature will be returned and you can use Ethers.js <code>Signature.from</code> method to return the <code>v</code>, <code>r</code>, and <code>s</code> values of the signature</li> </ol>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#call-permit-arguments","title":"The Call Permit Arguments","text":"<p>As seen in the Call Permit Interface section, the <code>dispatch</code> function takes the following parameters: <code>from</code>, <code>to</code>, <code>value</code>, <code>data</code>, <code>gasLimit</code>, <code>deadline</code>, <code>v</code>, <code>r</code>, and <code>s</code>.</p> <p>In order to get the signature arguments (<code>v</code>, <code>r</code>, and <code>s</code>), you'll need to sign a message containing the arguments for the remainder of the aforementioned parameters, plus the nonce of the signer.</p> <ul> <li><code>from</code> - the address of the account you want to sign the call permit with</li> <li><code>to</code> - the contract address for the <code>SetMessage.sol</code> contract</li> <li><code>value</code> - can be <code>0</code> for this example as you'll just be setting a message instead of transferring any funds</li> <li><code>data</code> - you can send any message you would like, you'll just need the hex representation of the message you want to set using the <code>SetMessage.sol</code> contract. This will contain the function selector of the <code>set</code> function and the string of the message. For this example, you can send <code>hello world</code>. To do so, you can use this hex representation:      <pre><code>0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000\n</code></pre></li> <li><code>gasLimit</code> - <code>100000</code> will be enough to send the dispatched call</li> <li><code>deadline</code> - you can get the current time in UNIX seconds by running <code>console.log(Math.floor(Date.now() / 1000))</code> in a JavaScript script or a browser console. Once you have the current time, you can add additional time in seconds to represent when the call permit will expire</li> </ul> <p>The nonce of the signer will also be needed. If this is your first time signing a call permit the nonce will be <code>0</code>. You can also check the nonce in Remix:</p> <ol> <li>Expand the call permit contract</li> <li>Next to the nonces function, enter the address of the signer and click on nonces</li> <li>The result will be returned directly under the function</li> </ol> <p></p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#use-the-browser","title":"Use the Browser","text":"<p>To get started, you can open JSFiddle or another JavaScript playground in the browser. First, you'll need to add Ethers.js as it will be used to get the <code>v</code>, <code>r</code>, and <code>s</code> values of the signature:</p> <ol> <li>Click on Resources</li> <li>Start to type in <code>ethers</code> and the dropdown should populate matching libraries. Choose ethers</li> <li>Click on the + button</li> </ol> <p>The CDN for Ethers.js will appear in the list of libraries under Resources.</p> <p></p> <p>In the Javascript code box, copy and paste the following JavaScript snippet, making sure to replace the <code>to</code> variables (and any other variables as you see fit):</p> <pre><code>const main = async () =&gt; {\n  await window.ethereum.enable();\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts',\n  });\n\n  const from = accounts[0];\n  const to = 'INSERT_TO_ADDRESS';\n  const value = 0;\n  const data =\n    '0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000';\n  const gaslimit = 100000;\n  const nonce = 'INSERT_SIGNERS_NONCE';\n  const deadline = 'INSERT_DEADLINE';\n\n  const createPermitMessageData = function () {\n    const message = {\n      from: from,\n      to: to,\n      value: value,\n      data: data,\n      gaslimit: gaslimit,\n      nonce: nonce,\n      deadline: deadline,\n    };\n\n    const typedData = JSON.stringify({\n      types: {\n        EIP712Domain: [\n          {\n            name: 'name',\n            type: 'string',\n          },\n          {\n            name: 'version',\n            type: 'string',\n          },\n          {\n            name: 'chainId',\n            type: 'uint256',\n          },\n          {\n            name: 'verifyingContract',\n            type: 'address',\n          },\n        ],\n        CallPermit: [\n          {\n            name: 'from',\n            type: 'address',\n          },\n          {\n            name: 'to',\n            type: 'address',\n          },\n          {\n            name: 'value',\n            type: 'uint256',\n          },\n          {\n            name: 'data',\n            type: 'bytes',\n          },\n          {\n            name: 'gaslimit',\n            type: 'uint64',\n          },\n          {\n            name: 'nonce',\n            type: 'uint256',\n          },\n          {\n            name: 'deadline',\n            type: 'uint256',\n          },\n        ],\n      },\n      primaryType: 'CallPermit',\n      domain: {\n        name: 'Call Permit Precompile',\n        version: '1',\n        chainId: 1287,\n        verifyingContract: '0x000000000000000000000000000000000000080a',\n      },\n      message: message,\n    });\n\n    return {\n      typedData,\n      message,\n    };\n  };\n\n  const method = 'eth_signTypedData_v4';\n  const messageData = createPermitMessageData();\n  const params = [from, messageData.typedData];\n\n  web3.currentProvider.sendAsync(\n    {\n      method,\n      params,\n      from,\n    },\n    function (err, result) {\n      if (err) return console.dir(err);\n      if (result.error) {\n        alert(result.error.message);\n        return console.error('ERROR', result);\n      }\n      console.log('Signature:' + JSON.stringify(result.result));\n\n      const ethersSignature = ethers.Signature.from(result.result);\n      const formattedSignature = {\n        r: ethersSignature.r,\n        s: ethersSignature.s,\n        v: ethersSignature.v,\n      };\n      console.log(formattedSignature);\n    }\n  );\n};\n\nmain();\n</code></pre> <p>To run the code, click Run at the top of the page (or you can also use <code>control</code> and <code>s</code>). MetaMask should pop up and prompt you to connect an account. Make sure to choose the account you want to sign the message with. Then go ahead and sign the message.</p> <p></p> <p>Once you've signed the message, go back to JSFiddle and if the console isn't already open, go ahead and open it to see the signature values include the <code>v</code>, <code>r</code>, and <code>s</code>, values. Copy these values as you'll need them when interacting with the Call Permit Precompile in the following sections.</p> <p></p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#use-metamasks-signing-library","title":"Use MetaMask's JS Signing Library","text":"<p>To generate the call permit signature using JavaScript and MetaMask's <code>@metamask/eth-sig-util</code> npm package, you'll first need to create a project locally. You can do so with the following commands:</p> <pre><code>mkdir call-permit-example &amp;&amp; cd call-permit-example &amp;&amp; touch getSignature.js\nnpm init -y\n</code></pre> <p>You should now have a file where you can create the script to get the signature along with a <code>package.json</code> file. Open the <code>package.json</code> file, and below the <code>\"dependencies\"</code> section, add:</p> <pre><code>\"type\": \"module\"\n</code></pre> <p>Next, you can install the MetaMask signing library and Ethers.js:</p> <pre><code>npm i @metamask/eth-sig-util ethers\n</code></pre> <p>Note</p> <p>Never reveal your private keys as they give direct access to your funds. The following steps are for demonstration purposes only.</p> <p>In the <code>getSignature.js</code> file, you can copy the following code snippet:</p> <pre><code>import { ethers } from 'ethers';\nimport { signTypedData, SignTypedDataVersion } from '@metamask/eth-sig-util';\n\nconst from = 'INSERT_FROM_ADDRESS';\nconst to = 'INSERT_TO_ADDRESS';\nconst value = 0;\nconst data =\n  '0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000';\nconst gaslimit = 100000;\nconst nonce = 'INSERT_SIGNERS_NONCE';\nconst deadline = 'INSERT_DEADLINE';\n\nconst createPermitMessageData = () =&gt; {\n  const message = {\n    from: from,\n    to: to,\n    value: value,\n    data: data,\n    gaslimit: gaslimit,\n    nonce: nonce,\n    deadline: deadline,\n  };\n\n  const typedData = {\n    types: {\n      EIP712Domain: [\n        { name: 'name', type: 'string' },\n        { name: 'version', type: 'string' },\n        { name: 'chainId', type: 'uint256' },\n        { name: 'verifyingContract', type: 'address' },\n      ],\n      CallPermit: [\n        { name: 'from', type: 'address' },\n        { name: 'to', type: 'address' },\n        { name: 'value', type: 'uint256' },\n        { name: 'data', type: 'bytes' },\n        { name: 'gaslimit', type: 'uint64' },\n        { name: 'nonce', type: 'uint256' },\n        { name: 'deadline', type: 'uint256' },\n      ],\n    },\n    primaryType: 'CallPermit',\n    domain: {\n      name: 'Call Permit Precompile',\n      version: '1',\n      chainId: 1287,\n      verifyingContract: '0x000000000000000000000000000000000000080a',\n    },\n    message: message,\n  };\n\n  return {\n    typedData,\n    message,\n  };\n};\n\nconst messageData = createPermitMessageData();\n\n// For demo purposes only. Never store your private key in a JavaScript/TypeScript file\nconst signature = signTypedData({\n  privateKey: Buffer.from('INSERT_FROM_ACCOUNT_PRIVATE_KEY', 'hex'),\n  data: messageData.typedData,\n  version: SignTypedDataVersion.V4,\n});\n\nconsole.log(`Transaction successful with hash: ${signature}`);\n\nconst ethersSignature = ethers.Signature.from(signature);\nconst formattedSignature = {\n  r: ethersSignature.r,\n  s: ethersSignature.s,\n  v: ethersSignature.v,\n};\nconsole.log(formattedSignature);\n</code></pre> <p>To run the script, use the following command:</p> <pre><code>node getSignature.js\n</code></pre> <p>In the console, you should see the concatenated signature along with the values for the signature including the <code>v</code>, <code>r</code>, and <code>s</code> values. Copy these values as you'll need them when interacting with the Call Permit Precompile in the following sections.</p> node getSignature.js Transaction successful with hash: 0x76c23a766ad2135095e56a5d799794a6a9f84ed7a9da9759daa592d58632419948d111bdd46079013aa6a2c733c7a608fa05295b0ec5d8ab6a8bfbca01b3bd291c {   r: \"0x76c23a766ad2135095e56a5d799794a6a9f84ed7a9da9759daa592d586324199\",   s: \"0x48d111bdd46079013aa6a2c733c7a608fa05295b0ec5d8ab6a8bfbca01b3bd29\",   _vs: \"0xc8d111bdd46079013aa6a2c733c7a608fa05295b0ec5d8ab6a8bfbca01b3bd29\",   recoveryParam: 1,   v: 28,   yParityAndS: \"0xc8d111bdd46079013aa6a2c733c7a608fa05295b0ec5d8ab6a8bfbca01b3bd29\",   compact: \"0x76c23a766ad2135095e56a5d799794a6a9f84ed7a9da9759daa592d586324199c8d111bdd46079013aa6a2c733c7a608fa05295b0ec5d8ab6a8bfbca01b3bd29\" }"},{"location":"builders/ethereum/precompiles/ux/call-permit/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":"<p>Now that you have generated the call permit signature you will be able to test out calling the <code>dispatch</code> function of the Call Permit Precompile.</p>"},{"location":"builders/ethereum/precompiles/ux/call-permit/#dispatch-a-call","title":"Dispatch a Call","text":"<p>When you send the <code>dispatch</code> function, you'll need the same arguments as you used to sign the call permit. To get started, go back to the Deploy and Run tab in Remix and under the Deployed Contracts section expand the call permit contract. Make sure that you're connected to the account that you want to consume the call permit and pay the transaction fees with. Then take the following steps:</p> <ol> <li>For the from field, enter the account address you used to sign the call permit with</li> <li>Copy and paste the contract address of <code>SetMessage.sol</code></li> <li>Enter <code>0</code> for the value field</li> <li>Enter the hex representation of the function selector for the <code>set</code> function and the string you want to set as the message for the <code>SetMessage.sol</code> contract. For this example, <code>hello world</code> can be used:      <pre><code>0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000\n</code></pre></li> <li>Enter <code>100000</code> for the gasLimit field</li> <li>Enter the <code>deadline</code> you used when signing the call permit</li> <li>Copy the <code>v</code> value you should have retrieved while generating the call permit signature and paste it into the v field</li> <li>Copy the <code>r</code> value you should have retrieved while generating the call permit signature and paste it into the r field</li> <li>Copy the <code>s</code> value you should have retrieved while generating the call permit signature and paste it into the s field</li> <li>Click transact to send the transaction</li> <li>MetaMask should pop-up and you can confirm the transaction</li> </ol> <p></p> <p>Once the transaction goes through, you can verify that the message was updated to <code>hello world</code>. To do so, you can:</p> <ol> <li>Expand the <code>SetMessage.sol</code> contract</li> <li>Click on get</li> <li>The result will appear below the function, and it should show <code>hello world</code></li> </ol> <p></p> <p>Congratulations! You've successfully generated a call permit signature and used it to dispatch a call on behalf of the call permit signer.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/","title":"Native Token ERC-20 Precompile","text":""},{"location":"builders/ethereum/precompiles/ux/erc20/#introduction","title":"Introduction","text":"<p>The native token ERC-20 precompiled contract on Moonbeam allows developers to interact with the native protocol token through an ERC-20 interface. Although GLMR and MOVR are not ERC-20 tokens, now you can interact with them as if they were native ERC-20s!</p> <p>One of the main benefits of this precompile is that it removes the necessity of having a wrapped representation of the protocol token as an ERC-20 smart contract, such as WETH on Ethereum. Furthermore, it prevents having multiple wrapped representations of the same protocol token. Consequently, DApps that need to interact with the protocol token via an ERC-20 interface can do so without needing a separate smart contract.</p> <p>Under the hood, the ERC-20 precompile executes specific Substrate actions related to the Substrate balances pallet, which is coded in Rust. The balances pallet provides functionality for handling the various types of balances on Moonbeam, setting the free balance, transferring balances, and more.</p> <p>This guide will show you how to interact with DEV tokens, the native protocol tokens for the Moonbase Alpha TestNet, via the ERC-20 precompile. You can also follow and adapt this guide to learn how to use GLMR or MOVR as an ERC-20 token.</p> <p>The precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000802\n</code></pre> <pre><code>0x0000000000000000000000000000000000000802\n</code></pre> <pre><code>0x0000000000000000000000000000000000000802\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#the-erc20-interface","title":"The ERC-20 Solidity Interface","text":"<p>The <code>ERC20.sol</code> interface on Moonbeam follows the EIP-20 Token Standard which is the standard API interface for tokens within smart contracts. The standard defines the required functions and events that a token contract must implement to be interoperable with different applications.</p> <p>The interface includes the following functions:</p> name() - read-only function that returns the name of the token Parameters <p>None.</p> symbol() - read-only function that returns the symbol of the token Parameters <p>None.</p> decimals() - read-only function that returns the decimals of the token Parameters <p>None.</p> totalSupply() - read-only function that returns the total number of tokens in existence Parameters <p>None.</p> balanceOf(address who) - read-only function that returns the balance of the specified address Parameters <ul> <li><code>who</code> - address of the account to query the balance of</li> </ul> allowance(address owner, address spender) - read-only function that checks and returns the amount of tokens that a spender is allowed to spend on behalf of the owner Parameters <ul> <li><code>owner</code> - address of the account that owns the tokens</li> <li><code>spender</code> - address of the account allowed to spend the tokens</li> </ul> transfer(address to, uint256 value) - transfers a given amount of tokens to a specified address and returns <code>true</code> if the transfer was successful Parameters <ul> <li><code>to</code> - address of the recipient</li> <li><code>value</code> - uint256 amount of tokens to transfer</li> </ul> approve(address spender, uint256 value) - approves the provided address to spend a specified amount of tokens on behalf of <code>msg.sender</code>. Returns <code>true</code> if successful Parameters <ul> <li><code>spender</code> - address to be approved to spend the tokens</li> <li><code>value</code> - uint256 amount of tokens to be approved for spending</li> </ul> transferFrom(address from, address to, uint256 value) - transfers tokens from one given address to another given address and returns <code>true</code> if successful Parameters <ul> <li><code>from</code> - address to transfer tokens from</li> <li><code>to</code> - address to transfer tokens to</li> <li><code>value</code> - uint256 amount of tokens to transfer</li> </ul> <p>Note</p> <p>The ERC-20 standard does not specify the implications of multiple calls to <code>approve</code>. Changing an allowance with this function numerous times enables a possible attack vector. To avoid incorrect or unintended transaction ordering, you can first reduce the <code>spender</code> allowance to <code>0</code> and then set the desired allowance afterward. For more details on the attack vector, you can check out the ERC-20 API: An Attack Vector on Approve/TransferFrom Methods overview.</p> <p>The interface also includes the following required events:</p> <ul> <li>Transfer(address indexed from, address indexed to, uint256 value) - emitted when a transfer has been performed</li> <li>Approval(address indexed owner, address indexed spender, uint256 value) - emitted when an approval has been registered</li> </ul> <p>Note</p> <p>The ERC-20 precompile does not include <code>deposit</code> and <code>withdraw</code> functions and subsequent events that are expected from a wrapped token contract, such as WETH.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/ethereum/precompiles/ux/erc20/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>Create or have two accounts on Moonbase Alpha to test out the different features in the ERC-20 precompile</li> <li>At least one of the accounts will need to be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/ethereum/precompiles/ux/erc20/#add-token-to-metamask","title":"Add Token to MetaMask","text":"<p>If you want to interact with Moonbase Alpha DEV tokens like you would with an ERC-20 in MetaMask, you can create a custom token using the precompile address.</p> <p>To get started, open up MetaMask and make sure you are connected to Moonbase Alpha and:</p> <ol> <li>Switch to the Assets tab</li> <li>Click on Import tokens</li> </ol> <p></p> <p>Now, you can create a custom token:</p> <ol> <li>Enter the precompile address for the token contract address - <code>0x0000000000000000000000000000000000000802</code>. As soon as you enter the address, the Token Symbol and Token Decimal fields should automatically populate. If they don't you can enter <code>DEV</code> for the symbol and <code>18</code> for the decimal places</li> <li>Click Add Custom Token</li> </ol> <p></p> <p>MetaMask will prompt you to import the tokens. You can review the token details and click Import Tokens to import DEV tokens into your wallet.</p> <p></p> <p>And that's it! You've successfully added the DEV token as a custom ERC-20 token on the Moonbase Alpha TestNet.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#remix-set-up","title":"Remix Set Up","text":"<p>You can interact with the ERC-20 precompile using Remix. To add the precompile to Remix, you will need to:</p> <ol> <li>Get a copy of <code>ERC20.sol</code></li> <li>Paste the file contents into a Remix file named <code>IERC20.sol</code></li> </ol>"},{"location":"builders/ethereum/precompiles/ux/erc20/#compile-the-contract","title":"Compile the Contract","text":"<p>Next, you will need to compile the interface in Remix:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Compile the interface by clicking on Compile IERC20.sol</li> </ol> <p></p> <p>If the interface was compiled successfully, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#access-the-contract","title":"Access the Contract","text":"<p>Instead of deploying the ERC-20 precompile, you will access the interface given the address of the precompiled contract:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note the precompiled contract is already deployed</li> <li>Make sure Injected Web3 is selected in the ENVIRONMENT dropdown. Once you select Injected Web3, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure IERC20 - IERC20.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract, there is no need to deploy any code. Instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the ERC-20 precompile: <code>0x0000000000000000000000000000000000000802</code> and click At Address</li> </ol> <p></p> <p>The IERC20 precompile will appear in the list of Deployed Contracts.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#get-basic-token-information","title":"Get Basic Token Information","text":"<p>The ERC-20 interface allows you to quickly obtain token information, including the token's total supply, name, symbol, and decimal places. You can get this information by following these steps:</p> <ol> <li>Expand the IERC20 contract under Deployed Contracts</li> <li>Click decimals to get the decimal places of the Moonbase Alpha native protocol token</li> <li>Click name to get the name of the token</li> <li>Click symbol to get the symbol of the token</li> <li>Click totalSupply to obtain the total supply of tokens in existence on Moonbase Alpha</li> </ol> <p></p> <p>The response for each call will be displayed under the corresponding function.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#get-account-balance","title":"Get Account Balance","text":"<p>You can check the balance of any address on Moonbase Alpha by calling the <code>balanceOf</code> function and passing in an address:</p> <ol> <li>Expand the balanceOf function</li> <li>Enter an address you would like to check the balance of for the owner</li> <li>Click call</li> </ol> <p></p> <p>Your balance will be displayed under the <code>balanceOf</code> function.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#approve-a-spend","title":"Approve a Spend","text":"<p>To approve a spend, you'll need to provide an address for the spender and the number of tokens  that the spender is allowed to spend. The spender can be an externally owned account or a smart contract. For this example, you can approve the spender to spend 1 DEV token. To get started, please follow these steps:</p> <ol> <li>Expand the approve function</li> <li>Enter the address of the spender. You should have created two accounts before starting, so you can use the second account as the spender</li> <li>Enter the amount of tokens the spender can spend for the value. For this example, you can allow the spender to spend 1 DEV token in Wei units (<code>1000000000000000000</code>)</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click View full transaction details to review the amount to be sent and the address of the spender</li> <li>If everything looks ok, you can click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction has successfully gone through, you'll notice that the balance of your account hasn't changed. This is because you have only approved the spend for the given amount, and the spender hasn't spent the funds. In the next section, you will use the <code>allowance</code> function to verify that the spender is able to spend 1 DEV token on your behalf.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#get-allowance-of-spender","title":"Get Allowance of Spender","text":"<p>To check that the spender received the allowance approved in the Approve a Spend section, you can:</p> <ol> <li>Expand the allowance function</li> <li>Enter your address for the owner</li> <li>Enter the address of the spender that you used in the previous section</li> <li>Click call</li> </ol> <p></p> <p>Once the call is complete, the allowance of the spender will be displayed, which should be equivalent to 1 DEV token (<code>1000000000000000000</code>).</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#send-transfer","title":"Send Transfer","text":"<p>To do a standard transfer and send tokens from your account directly to another account, you can call the <code>transfer</code> function by following these steps:</p> <ol> <li>Expand the transfer function</li> <li>Enter the address to send DEV tokens to. You should have created two accounts before starting, so you can use the second account as the recipient</li> <li>Enter the amount of DEV tokens to send. For this example, you can send 1 DEV token (<code>1000000000000000000</code>)</li> <li>Click transact</li> <li>MetaMask will pop up, you can review the transaction details, and if everything looks good, click Confirm</li> </ol> <p></p> <p>Once the transaction is complete, you can check your balance using the <code>balanceOf</code> function or by looking at MetaMask, and notice that this time your balance decreased by 1 DEV token. You can also use the <code>balanceOf</code> function to ensure that the recipients balance has increased by 1 DEV token as expected.</p>"},{"location":"builders/ethereum/precompiles/ux/erc20/#send-transferfrom","title":"Send Transfer From Specific Account","text":"<p>So far, you should have approved an allowance of 1 DEV token for the spender and sent 1 DEV token via the standard <code>transfer</code> function. The <code>transferFrom</code> function varies from the standard <code>transfer</code> function as it allows you to define the address to which you want to send the tokens. So you can specify an address that has an allowance or your address as long as you have funds. For this example, you will use the spender's account to initiate a transfer of the allowed funds from the owner to the spender. The spender can send the funds to any account, but you can send the funds from the owner to the spender for this example.</p> <p>First, you need to switch to the spender's account in MetaMask. Once you switch to the spender's account, you'll notice that the selected address in Remix under the Accounts tab is now the spender's.</p> <p></p> <p>Next, you can initiate and send the transfer, to do so:</p> <ol> <li>Expand the transferFrom function</li> <li>Enter your address as the owner in the from field</li> <li>Enter the recipient address, which should be the spender's address, in the to field</li> <li>Enter the amount of DEV tokens to send. Again, the spender is currently only allowed to send 1 DEV token, so enter <code>1000000000000000000</code></li> <li>Click transact</li> </ol> <p></p> <p>Once the transaction is complete, you can check the balance of the owner and spender using the <code>balanceOf</code> function. The spender's balance should have increased by 1 DEV token, and their allowance should now be depleted. To verify that the spender no longer has an allowance, you can call the <code>allowance</code> function, passing in the owner and spender's addresses. You should receive a result of 0.</p> <p></p> <p>And that's it! You've successfully interacted with the ERC-20 precompile using MetaMask and Remix!</p>"},{"location":"builders/ethereum/verify-contracts/api-verification/","title":"API-based Contract Verification","text":""},{"location":"builders/ethereum/verify-contracts/api-verification/#introduction","title":"Introduction","text":"<p>Verifying smart contracts greatly improves their transparency and security.  Smart contracts deployed on Moonbeam networks can be verified through API-based tools, including Moonscan API and Sourcify.</p> <p>This page will outline the steps for using these API-based tools for verifying smart contracts, or retrieving verification status and metadata of smart contracts on Moonbeam networks.</p>"},{"location":"builders/ethereum/verify-contracts/api-verification/#using-moonscan-api","title":"Using Moonscan API","text":"<p>Moonscan is an official fork of Etherscan that can be used to view and search on-chain data, and comes with a suite of developer tools and analytics to interact with data on Moonbeam networks.</p> <p>The Etherscan API provides a variety of endpoints for verifying smart contracts, retrieving verified contract ABI and source code, and interacting with verified contracts on Moonbeam networks.</p>"},{"location":"builders/ethereum/verify-contracts/api-verification/#generating-an-etherscan-api-key","title":"Generating an Etherscan API Key","text":"<p>Before using the Moonscan API, you need to generate an Etherscan API key. Please follow the instructions in the key generation section of the Etherscan plug-in verification page, as the API keys generated are used for both.</p>"},{"location":"builders/ethereum/verify-contracts/api-verification/#moonscan-public-api-url","title":"Moonscan Public API URL","text":"<p>The Moonscan API URL for Moonbeam networks is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>https://api-moonbeam.moonscan.io/api\n</code></pre> <pre><code>https://api-moonriver.moonscan.io/api\n</code></pre> <pre><code>https://api-moonbase.moonscan.io/api\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#verify-source-code","title":"Verify Source Code","text":"<p>To verify a deployed contract's source code using the Moonscan API, you must form a POST request containing all the relevant contract creation information, and send the request to Moonscan's REST API. The following is sample code using JavaScript and Axios, an HTTP client:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>// Submit Source Code for Verification\nconst response = await axios.post(\n  'https://api-moonbeam.moonscan.io/api',\n  {\n    apikey: 'INSERT_API_KEY',\n    module: 'contract',\n    action: 'verifysourcecode',\n    contractAddress: 'INSERT_CONTRACT_ADDRESS',\n    sourceCode: 'INSERT_SOURCE_CODE', // flattened if necessary\n    codeformat: 'solidity-single-file', // or you can use \"solidity-standard-json-input\"\n    contractname: 'INSERT_CONTRACT_NAME', // if codeformat = solidity-standard-json-input, then enter contractname as ex: erc20.sol:erc20\n    compilerversion: 'INSERT_COMPILER_VERSION', // see https://etherscan.io/solcversions for list of support versions\n    optimizationUsed: 0, // 0 = no optimization, 1 = optimization was used (applicable when codeformat=solidity-single-file)\n    runs: 200, // set to 200 as default unless otherwise (applicable when codeformat=solidity-single-file)\n    constructorArguments: 'INSERT_CONSTRUCTOR_ARGUMENTS', // if applicable\n    evmversion: 'INSERT_EVM_VERSION', // options: homestead, tangerineWhistle, spuriousDragon, byzantium, constantinople, petersburg, istanbul (applicable when codeformat=solidity-single-file)\n    licenseType: 1, // valid codes 1-14 where 1=No License ... 14=Business Source License 1.1, see https://etherscan.io/contract-license-types\n    libraryname1: 'INSERT_LIBRARY_NAME', // if applicable, enter the name of the first library used, i.e. SafeMath (up to 10 libraries can be used)\n    libraryaddress1: 'INSERT_LIBRARY_ADDRESS', // if applicable, enter the address of the first library used\n    libraryname2: 'INSERT_LIBRARY_NAME', // if applicable, enter the name of the second library used\n    libraryaddress2: 'INSERT_LIBRARY_ADDRESS', // if applicable, enter the address of the second library used\n    // ...\n  },\n  { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }\n);\n\nif (response.data.status == '1') {\n  // 1 = submission success, use the guid returned (response.data.result) to check the status of your submission\n  // average time of processing is 30-60 seconds\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n  // response.data.result is the GUID receipt for the submission, you can use this guid for checking the verification status\n} else {\n  // 0 = error\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n}\n</code></pre> <pre><code>// Submit Source Code for Verification\nconst response = await axios.post(\n  'https://api-moonriver.moonscan.io/api', \n  {\n    apikey: 'INSERT_API_KEY',\n    module: 'contract',\n    action: 'verifysourcecode',\n    contractAddress: 'INSERT_CONTRACT_ADDRESS',\n    sourceCode: 'INSERT_SOURCE_CODE', // flattened if necessary\n    codeformat: 'solidity-single-file', // or you can use \"solidity-standard-json-input\"\n    contractname: 'INSERT_CONTRACT_NAME', // if codeformat = solidity-standard-json-input, then enter contractname as ex: erc20.sol:erc20\n    compilerversion: 'INSERT_COMPILER_VERSION', // see https://etherscan.io/solcversions for list of support versions\n    optimizationUsed: 0, // 0 = no optimization, 1 = optimization was used (applicable when codeformat=solidity-single-file)\n    runs: 200, // set to 200 as default unless otherwise (applicable when codeformat=solidity-single-file)\n    constructorArguments: 'INSERT_CONSTRUCTOR_ARGUMENTS', // if applicable\n    evmversion: 'INSERT_EVM_VERSION', // options: homestead, tangerineWhistle, spuriousDragon, byzantium, constantinople, petersburg, istanbul (applicable when codeformat=solidity-single-file)\n    licenseType: 1, // valid codes 1-14 where 1=No License ... 14=Business Source License 1.1, see https://etherscan.io/contract-license-types\n    libraryname1: 'INSERT_LIBRARY_NAME', // if applicable, enter the name of the first library used, i.e. SafeMath (up to 10 libraries can be used)\n    libraryaddress1: 'INSERT_LIBRARY_ADDRESS', // if applicable, enter the address of the first library used\n    libraryname2: 'INSERT_LIBRARY_NAME', // if applicable, enter the name of the second library used\n    libraryaddress2: 'INSERT_LIBRARY_ADDRESS', // if applicable, enter the address of the second library used\n    // ...\n  },\n  { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }\n);\n\nif (response.data.status == '1') {\n  // 1 = submission success, use the guid returned (response.data.result) to check the status of your submission\n  // average time of processing is 30-60 seconds\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n  // response.data.result is the GUID receipt for the submission, you can use this guid for checking the verification status\n} else {\n  // 0 = error\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n}\n</code></pre> <pre><code>// Submit Source Code for Verification\nconst response = await axios.post(\n  'https://api-moonbase.moonscan.io/api', \n  {\n    apikey: 'INSERT_API_KEY',\n    module: 'contract',\n    action: 'verifysourcecode',\n    contractAddress: 'INSERT_CONTRACT_ADDRESS',\n    sourceCode: 'INSERT_SOURCE_CODE', // flattened if necessary\n    codeformat: 'solidity-single-file', // or you can use \"solidity-standard-json-input\"\n    contractname: 'INSERT_CONTRACT_NAME', // if codeformat = solidity-standard-json-input, then enter contractname as ex: erc20.sol:erc20\n    compilerversion: 'INSERT_COMPILER_VERSION', // see https://etherscan.io/solcversions for list of support versions\n    optimizationUsed: 0, // 0 = no optimization, 1 = optimization was used (applicable when codeformat=solidity-single-file)\n    runs: 200, // set to 200 as default unless otherwise (applicable when codeformat=solidity-single-file)\n    constructorArguments: 'INSERT_CONSTRUCTOR_ARGUMENTS', // if applicable\n    evmversion: 'INSERT_EVM_VERSION', // options: homestead, tangerineWhistle, spuriousDragon, byzantium, constantinople, petersburg, istanbul (applicable when codeformat=solidity-single-file)\n    licenseType: 1, // valid codes 1-14 where 1=No License ... 14=Business Source License 1.1, see https://etherscan.io/contract-license-types\n    libraryname1: 'INSERT_LIBRARY_NAME', // if applicable, enter the name of the first library used, i.e. SafeMath (up to 10 libraries can be used)\n    libraryaddress1: 'INSERT_LIBRARY_ADDRESS', // if applicable, enter the address of the first library used\n    libraryname2: 'INSERT_LIBRARY_NAME', // if applicable, enter the name of the second library used\n    libraryaddress2: 'INSERT_LIBRARY_ADDRESS', // if applicable, enter the address of the second library used\n    // ...\n  },\n  { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }\n);\n\nif (response.data.status == '1') {\n  // 1 = submission success, use the guid returned (response.data.result) to check the status of your submission\n  // average time of processing is 30-60 seconds\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n  // response.data.result is the GUID receipt for the submission, you can use this guid for checking the verification status\n} else {\n  // 0 = error\n  console.log(\n    response.data.status +\n      '; ' +\n      response.data.message +\n      '; ' +\n      response.data.result\n  );\n}\n</code></pre> <p>Upon successful submission, a GUID will be returned as a part of the result. This GUID can be used to check for the submission status.</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://api-moonbeam.moonscan.io/api\n  ?module=contract\n  &amp;action=checkverifystatus\n  &amp;guid=INSERT_GUID_FROM_RESPONSE\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonriver.moonscan.io/api\n  ?module=contract\n  &amp;action=checkverifystatus\n  &amp;guid=INSERT_GUID_FROM_RESPONSE\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonbase.moonscan.io/api\n  ?module=contract\n  &amp;action=checkverifystatus\n  &amp;guid=INSERT_GUID_FROM_RESPONSE\n  &amp;apikey=INSERT_API_KEY\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#retrieve-contract-abi-for-verified-contracts","title":"Retrieve Contract ABI for Verified Contracts","text":"<p>Once your contract is verified on Moonscan, you can use the following endpoint to retrieve the contract ABI:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://api-moonbeam.moonscan.io/api\n  ?module=contract\n  &amp;action=getabi\n  &amp;address=INSERT_CONTRACT_ADDRESS\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonriver.moonscan.io/api\n  ?module=contract\n  &amp;action=getabi\n  &amp;address=INSERT_CONTRACT_ADDRESS\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonbase.moonscan.io/api\n  ?module=contract\n  &amp;action=getabi\n  &amp;address=INSERT_CONTRACT_ADDRESS\n  &amp;apikey=INSERT_API_KEY\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#retrieve-contract-source-code-for-verified-contracts","title":"Retrieve Contract Source Code for Verified Contracts","text":"<p>Once your contract is verified on Moonscan, you can use the following endpoint to retrieve the contract source code:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://api-moonbeam.moonscan.io/api\n  ?module=contract\n  &amp;action=getsourcecode\n  &amp;address=INSERT_CONTRACT_ADDRESS\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonriver.moonscan.io/api\n  ?module=contract\n  &amp;action=getsourcecode\n  &amp;address=INSERT_CONTRACT_ADDRESS\n  &amp;apikey=INSERT_API_KEY\n</code></pre> <pre><code>curl https://api-moonbase.moonscan.io/api\n  ?module=contract\n  &amp;action=getsourcecode\n  &amp;address=INSERT_CONTRACT_ADDRESS\n  &amp;apikey=INSERT_API_KEY\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#using-sourcify-api","title":"Using Sourcify API","text":"<p>Sourcify is a multi-chain decentralized automated contract verification service, and maintains a public repository of contract metadata. Sourcify also provides a public server API for verification, and checking if a contract is verified, and a repository API for retrieving metadata files.</p>"},{"location":"builders/ethereum/verify-contracts/api-verification/#sourcify-public-server-url","title":"Sourcify Public Server URL","text":"<p>Soucify API endpoints can be accessed through the following public servers:</p> ProductionStaging <pre><code>https://sourcify.dev/server\n</code></pre> <pre><code>https://staging.sourcify.dev/server\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#moonbeam-network-chain-ids","title":"Moonbeam Network Chain ID's","text":"<p>Sourcify uses chain ID's to identify the target network(s) for the request. The chain ID's of Moonbeam networks are as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>1284\n</code></pre> <pre><code>1285\n</code></pre> <pre><code>1287\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#full-vs-partial-match","title":"Perfect vs. Partial Match","text":"<p>Sourcify supports two types of verification match results.</p> <p>Full matches (sometimes referred as perfect matches) refer to the cases when the bytecode of the deployed contract is byte-by-byte the same as compilation output of the given source code files under the compilation settings defined in the metadata file.</p> <p>Partial matches refer to cases when the deployed bytecode of the onchain contract match the bytecode resulting from the recompilation with the metadata and the source files except the metadata hash. For partial matches, the deployed contract and the given source code and metadata are functionally the same, but there are differences in source code comments, variable names, or other metadata fields such as source paths.</p>"},{"location":"builders/ethereum/verify-contracts/api-verification/#verify-contract","title":"Verify Contract","text":"<p>A POST request is used to verify a contract on Sourcify. The following is sample code using JavaScript:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>// Submit Contract Source Code and Metadata for Verification\nconst response = await axios.post('https://sourcify.dev/server/verify', {\n  address: 'INSERT_CONTRACT_ADDRESS',\n  chain: 1284, // chain ID of Moonbeam\n  files: {\n    'metadata-1.json': 'INSERT_JSON_FILE', // metadata file for contract file 1\n    'metadata-2.json': 'INSERT_JSON_FILE', // metadata file for contract file 2\n    'file1-name.sol': 'INSERT_SOL_FILE', // contract source file 1\n    'file2-name.sol': 'INSERT_SOL_FILE', // contract source file 2\n    //...\n  },\n  chosenContract: 1, // (optional) index of the contract, if the provided files contain multiple metadata files\n});\n\nif (result.status == 'perfect') {\n  // perfect match\n  console.log(result.status + ';' + result.address);\n} else if (result.status == 'partial') {\n  // partial match\n  console.log(result.status + ';' + result.address);\n} else {\n  // non-matching\n  console.log(result.status + ';' + result.address);\n}\n</code></pre> <pre><code>// Submit Contract Source Code and Metadata for Verification\nconst response = await axios.post('https://sourcify.dev/server/verify', {\n  address: 'INSERT_CONTRACT_ADDRESS',\n  chain: 1285, // chain ID of Moonriver\n  files: {\n    'metadata-1.json': 'INSERT_JSON_FILE', // metadata file for contract file 1\n    'metadata-2.json': 'INSERT_JSON_FILE', // metadata file for contract file 2\n    'file1-name.sol': 'INSERT_SOL_FILE', // contract source file 1\n    'file2-name.sol': 'INSERT_SOL_FILE', // contract source file 2\n    //...\n  },\n  chosenContract: 1, // (optional) index of the contract, if the provided files contain multiple metadata files\n});\n\nif (result.status == 'perfect') {\n  // perfect match\n  console.log(result.status + ';' + result.address);\n} else if (result.status == 'partial') {\n  // partial match\n  console.log(result.status + ';' + result.address);\n} else {\n  // non-matching\n  console.log(result.status + ';' + result.address);\n}\n</code></pre> <pre><code>// Submit Contract Source Code and Metadata for Verification\nconst response = await axios.post('https://sourcify.dev/server/verify', {\n  address: 'INSERT_CONTRACT_ADDRESS',\n  chain: 1287, // chain ID of Moonbase Alpha\n  files: {\n    'metadata-1.json': 'INSERT_JSON_FILE', // metadata file for contract file 1\n    'metadata-2.json': 'INSERT_JSON_FILE', // metadata file for contract file 2\n    'file1-name.sol': 'INSERT_SOL_FILE', // contract source file 1\n    'file2-name.sol': 'INSERT_SOL_FILE', // contract source file 2\n    //...\n  },\n  chosenContract: 1, // (optional) index of the contract, if the provided files contain multiple metadata files\n});\n\nif (result.status == 'perfect') {\n  // perfect match\n  console.log(result.status + ';' + result.address);\n} else if (result.status == 'partial') {\n  // partial match\n  console.log(result.status + ';' + result.address);\n} else {\n  // non-matching\n  console.log(result.status + ';' + result.address);\n}\n</code></pre> <p>Alternatively, you can also use the Sourcify hosted GUI to submit a contract for verification.  </p>"},{"location":"builders/ethereum/verify-contracts/api-verification/#check-verification-status-by-address-and-chain-id","title":"Check Verification Status by Address and Chain ID","text":"<p>Sourcify provides endpoints for checking the verification status of contracts on multiple EVM chains at once. This can be done through URL parameters, by specifying the contract addresses and the chain ID's of the networks.  </p> <p>There are two variations of this endpoint, one for perfect matching and one for partial matching:</p> Perfect MatchPartial Match <pre><code>curl https://sourcify.dev/server/check-by-addresses\n  ?addresses={INSERT_ADDRESS_1, INSERT_ADDRESS_2, ...}\n  &amp;chainIds={INSERT_CHAIN_ID_1, INSERT_CHAIN_ID_2, ...}\n</code></pre> <pre><code>curl https://sourcify.dev/server/check-all-by-addresses\n  ?addresses={INSERT_ADDRESS_1, INSERT_ADDRESS_2, ...}\n  &amp;chainIds={INSERT_CHAIN_ID_1, INSERT_CHAIN_ID_2, ...}\n</code></pre> <p>An example response will be a JSON object of the following structure:</p> <pre><code>[\n    {\n        \"address\": \"address1\",\n        \"status\": \"perfect\",\n        \"chainIds\": [\n            \"chainId1\",\n            \"chaindId2\"\n        ]\n    },\n    {\n        \"address\": \"address2\",\n        \"status\": \"partial\",\n        \"chainIds\": [\n            \"chaindId2\"\n        ]\n    }\n]\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#retrieve-contract-source-files-for-verified-contracts","title":"Retrieve Contract Source Files for Verified Contracts","text":"<p>You can also retrieve the source files of verified contracts from the Sourcify repository.</p> <p>There are two variations of this endpoint, one for the source files of perfect matches:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://sourcify.dev/server/files/1284/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>curl https://sourcify.dev/server/files/1285/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>curl https://sourcify.dev/server/files/1287/INSERT_CONTRACT_ADDRESS\n</code></pre> <p>And one for the source files of both perfect and partial matches:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>curl https://sourcify.dev/server/files/any/1284/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>curl https://sourcify.dev/server/files/any/1285/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>curl https://sourcify.dev/server/files/any/1287/INSERT_CONTRACT_ADDRESS\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/api-verification/#using-sourcify-with-foundry","title":"Using Sourcify with Foundry","text":"<p>Foundry's Forge tool has built-in support for Sourcify verification similar to how it has built-in support for Etherscan. The example in this section of the guide will use the <code>MyToken.sol</code> contract that was created in the Using Foundry to Deploy to Moonbeam guide.</p> <p>A Foundry project that uses Sourcify must have their compiler emit metadata files. This can be configured in the <code>foundry.toml</code> file:</p> <pre><code>[profile.default]\n# Input your custom or default config options here\nextra_output_files = [\"metadata\"]\n</code></pre> <p>If you have already deployed the example contract, you can verify it with the <code>verify-contract</code> command. Before you can verify the contract, you will need to ABI-encode the constructor arguments. To do so for the example contract, you can run the following command:</p> <pre><code>cast abi-encode \"constructor(uint256)\" 100\n</code></pre> <p>The result should be <code>0x0000000000000000000000000000000000000000000000000000000000000064</code>. You can then verify the contract using the following command:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>forge verify-contract --chain-id 1284 \\\n--constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\n--verifier sourcify INSERT_CONTRACT_ADDRESS src/MyToken.sol:MyToken \n</code></pre> <pre><code>forge verify-contract --chain-id 1285 \\\n--constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\n--verifier sourcify INSERT_CONTRACT_ADDRESS src/MyToken.sol:MyToken \n</code></pre> <pre><code>forge verify-contract --chain-id 1287 \\\n--constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\n--verifier sourcify INSERT_CONTRACT_ADDRESS src/MyToken.sol:MyToken \n</code></pre> forge verify-contract --chain-id 1287 \\ --constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\ --verifier sourcify 0x10DBedae73396699Ac2a4EB7A448d79348429d src/MyToken.sol:MyToken Submitting verification for [MyToken] \"0x10DBedae73396699Ac2a4EB7A448d79348429d\" \u2022 Submitting verification for [MyToken] \"0x10DBedae73396699Ac2a4EB7A448d79348429d\" \u2022 Contract source code already verified. Storage Timestamp: 2025-09-04 00:09:50.076Z <p>If you wanted to deploy the example contract and verify at the same time, then you would use the following command:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>forge create --rpc-url INSERT_RPC_API_ENDPOINT \\\n--constructor-args 100 \\\n--verify --verifier sourcify \\\n--private-key INSERT_YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken  \n</code></pre> <pre><code>forge create --rpc-url INSERT_RPC_API_ENDPOINT \\\n--constructor-args 100 \\\n--verify --verifier sourcify \\\n--private-key INSERT_YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken  \n</code></pre> <pre><code>forge create --rpc-url https://rpc.api.moonbase.moonbeam.network \\\n--constructor-args 100 \\\n--verify --verifier sourcify \\\n--private-key INSERT_YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken\n</code></pre>  forge create --rpc-url https://rpc.api.moonbase.moonbeam.network \\ --constructor-args 100 \\ --verify --verifier sourcify --private-key YOUR_PRIVATE_KEY \\ src/MyToken.sol:MyToken [:] Compiling... [:] Compiling 1 files with 0.8.14 [:] Solc 0.8.14 finished in 264.52ms Compiler run successful Deployer: 0x0394c0EdFcCA370B20622721985B577850B0eb75 Deployed to: 0x6A489374557354CE325D4F4a0Dd8F1CB98c1592 Transaction hash: 0x3ab6002497ca35971d2025b0a7d544f703de465513327d4b640886354d11f612 Starting contract verification... Waiting for etherscan to detect contract deployment... Submitting verification for [MyToken] \"0x6A489374557354CE325D4F4a0Dd8F1CB98c1592\" \u2022 Submitting verification for [MyToken] \"0x6A489374557354CE325D4F4a0Dd8F1CB98c1592\" \u2022 Contract source code already verified. Storage Timestamp: 2025-09-04 00:06:03.787Z"},{"location":"builders/ethereum/verify-contracts/block-explorers/","title":"Verify Smart Contracts using Block Explorers","text":""},{"location":"builders/ethereum/verify-contracts/block-explorers/#introduction","title":"Introduction","text":"<p>Verifying smart contracts on a block explorer is a great way to improve the transparency and security of deployed smart contracts on Moonbeam. Users can directly view the source code for verified smart contracts, and for some block explorers, they can also directly interact with the contract's public methods through the block explorer's interface.</p> <p>This page will outline the steps for verifying smart contracts on Moonbeam networks through block explorers.</p>"},{"location":"builders/ethereum/verify-contracts/block-explorers/#deploying-the-contract","title":"Deploying the Contract","text":"<p>In order to verify a smart contract on a block explorer, the contract must first be deployed on the target network. This tutorial will be about deploying the smart contract to Moonbase Alpha, but it can be adapted for Moonbeam or Moonriver.</p> <p>You can check out this page for a tutorial on deploying smart contracts using Ethereum libraries on Moonbeam. You may also use a developer tool such as Remix, Hardhat, or another tool if preferred, to deploy the smart contract to Moonbeam.</p> <p>This tutorial will use the same contract as the above deployment tutorial for the contract verification example.</p> <p>The contract used is a simple incrementer, arbitrarily named <code>Incrementer.sol</code>. The Solidity code is the following:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre>"},{"location":"builders/ethereum/verify-contracts/block-explorers/#collecting-information-for-contract-verification","title":"Collecting Information for Contract Verification","text":"<p>You will need to collect some information related to the contract's compiler and deployment in order to verify it successfully.</p> <ol> <li>Take note of the Solidity compiler version used to compile and deploy the contract. The Solidity compiler version can usually be selected or specified in the deployment tool used</li> <li> <p>Take note of any SPDX license identifier used at the beginning of the Solidity source file (this example uses an MIT license):</p> <pre><code>// SPDX-License-Identifier: MIT\n</code></pre> </li> <li> <p>(Optional) If optimization is enabled during compilation, take note of the value of the optimization runs parameter</p> </li> <li>(Optional) If the contract constructor method accepts arguments, take note of the ABI-encoded form of the constructor arguments</li> <li>After deployment, take note of the deployed contract address of the smart contract. The deployment address of the contract can be found either in the console output if using a command-line-based tool such as Hardhat, or an Ethereum library, or it can be copied from the GUI in tools such as Remix IDE</li> </ol> <p></p> <p></p>"},{"location":"builders/ethereum/verify-contracts/block-explorers/#verifying-the-contract","title":"Verify the Contract","text":"<p>The next step will be verifying the smart contract in an EVM-compatible explorer for the Moonbeam network that you deployed to.</p>"},{"location":"builders/ethereum/verify-contracts/block-explorers/#moonscan","title":"Moonscan","text":"<p>Take the following steps to verify the contract on Moonscan:</p> <ol> <li>Go to the Verify &amp; Publish Contract Source Code page of Moonscan</li> <li>Fill in the contract's deployed address in the first field, including the <code>0x</code> prefix</li> <li>Select the compiler type. For the current <code>Incrementer.sol</code> example, select Solidity (Single file)</li> <li>After selecting the compiler type, select the compiler version used to compile the contract. If the compiler version used was a nightly commit, uncheck the box under the field to select the nightly version</li> <li>Select the open-source license used. For the current <code>Incrementer.sol</code> example, select the option MIT License (MIT). If there was none used, select No License (None)</li> <li>Click the Continue button at the bottom of the form to continue on to the next page</li> </ol> <p></p> <p>On the second page, the Contract Address, Compiler, and Constructor Arguments fields should be prefilled. Fill in the rest of the information:</p> <ol> <li>Copy and paste the entirety of the contract's content into the text field labeled as such</li> <li>(Optional) Select Yes for Optimization if it was enabled during compilation, and fill in the number of runs under Misc Settings/Runs(Optimizer)</li> <li>(Optional) Add contract libraries and their addresses, if any were used in the contract</li> <li>(Optional) Check any other optional fields that may apply to your contract, and fill them out accordingly</li> <li>Click on the CAPTCHA at the bottom and the Verify and Publish button to confirm and begin verification</li> </ol> <p></p> <p>After a short wait, the result of verification will be displayed in the browser, and a success result page will display the contract's ABI-encoded constructor arguments, the contract name, bytecode, and ABI.</p> <p></p>"},{"location":"builders/ethereum/verify-contracts/block-explorers/#smart-contract-flattening","title":"Smart Contract Flattening","text":"<p>For verifying smart contracts that are made up of multiple files, the process is slightly different and requires some pre-processing to combine all the dependencies of the target smart contract into a single Solidity file.</p> <p>This pre-processing is usually referred to as smart contract flattening. There are a number of tools that can be used to flatten a multi-part smart contract into a single Solidity file, such as Hardhat's Flatten task. Please refer to the respective smart contract flattening tool's documentation for more detailed instructions on its usage.</p> <p>After flattening the multi-part smart contract, it can be verified using the new flattened Solidity file on a block explorer in the same way that a single-file smart contract is verified, as described in this tutorial.</p>"},{"location":"builders/ethereum/verify-contracts/block-explorers/#verify-multi-part-smart-contract-on-moonscan","title":"Verify Multi-Part Smart Contract on Moonscan","text":"<p>For verifying on Moonscan, there is a built-in feature to process multi-part smart contracts.</p> <p>Select Solidity (Multi-part files) under Compiler Type (step 3 of the above example). Then, on the next page, select and upload all the different Solidity files that the contract consists of, including their nested dependency contract files.</p> <p></p> <p>Aside from that, the process is largely the same as verifying single-file contracts on Moonscan.</p>"},{"location":"builders/ethereum/verify-contracts/etherscan-plugins/","title":"Verify Smart Contracts with Etherscan Plugins","text":""},{"location":"builders/ethereum/verify-contracts/etherscan-plugins/#introduction","title":"Introduction","text":"<p>Verifying smart contracts is a great way of improving the transparency and security of contracts deployed on Moonbeam. Hardhat and Foundry integrate with Etherscan's contract verification service to automate the process of verifying contracts by locally detecting which contracts to verify and which Solidity libraries are required, if any.</p> <p>The Hardhat plugin integrates seamlessly into your Hardhat project. Foundry also has Etherscan capabilities, but they are built into its Forge tool instead of being included in a separate plugin.</p> <p>This guide will show you how to use both plugins to verify smart contracts deployed on Moonbase Alpha. This guide can also be adapted for Moonbeam and Moonriver.</p>"},{"location":"builders/ethereum/verify-contracts/etherscan-plugins/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>MetaMask installed and connected to the Moonbase Alpha TestNet</li> <li>An account funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>An Etherscan API key</li> <li>Git installed and configured</li> </ul>"},{"location":"builders/ethereum/verify-contracts/etherscan-plugins/#generating-an-etherscan-api-key","title":"Generating an Etherscan API Key","text":"<p>To verify contracts on Moonscan for any Moonbeam network, you\u2019ll need an Etherscan API key. Because Moonscan is part of Etherscan\u2019s ecosystem, a single key works across all supported networks.</p> <p>To create an Etherscan account and generate your key, follow these steps:</p> <ol> <li>Click Sign In</li> <li>Select Click to sign up and then register your new account</li> </ol> <p></p> <p>Once you have an account and are signed in, you will then be able to create an API key.</p> <ol> <li>Select API Dashboard from the left side menu</li> <li>To add a new key, click the + Add button</li> </ol> <p></p> <p>You will then be prompted to enter in an AppName for your API key and once you enter a name and click Continue it will appear in your list of API keys.</p>"},{"location":"builders/ethereum/verify-contracts/etherscan-plugins/#using-the-hardhat-verify-plugin","title":"Using the Hardhat Etherscan Plugin","text":"<p>The example in this section of the guide will be based off of the <code>Box.sol</code> contract that was created in the Using Hardhat to Deploy To Moonbeam guide.</p> <p>To get started with the Hardhat Etherscan plugin, you will need to first install the plugin library:</p> <pre><code>npm install --save-dev @nomicfoundation/hardhat-verify\n</code></pre> <p>You can add your Etherscan API key to the <code>hardhat.config.js</code> file.</p> <p>From within your Hardhat project, open your <code>hardhat.config.js</code> file. You'll need to import the <code>hardhat-verify</code> plugin, your Etherscan API key, and add the config for Etherscan:</p> <pre><code>require('@nomicfoundation/hardhat-verify');\n\nmodule.exports = {\n  networks: {\n    moonbeam: { ... },\n    moonriver: { ... },\n    moonbaseAlpha: { ... }\n  },\n  etherscan: {\n    apiKey: {\n      moonbeam: 'INSERT_ETHERSCAN_API_KEY',\n      moonriver: 'INSERT_ETHERSCAN_API_KEY',\n      moonbaseAlpha: 'INSERT_ETHERSCAN_API_KEY', \n    },\n  },\n};\n</code></pre> <p>To verify the contract, you will run the <code>verify</code> command and pass in the address of the deployed contract and the network where it's deployed:</p> <pre><code>npx hardhat verify --network moonbase INSERT_CONTRACT_ADDRESS\n</code></pre> <p>In your terminal you should see the source code for your contract was successfully submitted for verification. If the verification was successful, you should see Successfully verified contract and there will be a link to the contract code on Moonscan for Moonbase Alpha.</p> npx hardhat verify --network moonbase 0x5d73ecDB4652173b881893235B64F1a0BdE22dD6 Successfully submitted source code for contract contracts/Box.sol:Box at 0x5d73ecDB4652173b881893235B64F1a0BdE22dD6 for verification on the block explorer. Waiting for verification result... Successfully verified contract Box on Etherscan. https://moonbase.moonscan.io/address/0x5d73ecDB4652173b881893235B64F1a0BdE22dD6#code <p>If you're verifying a contract that has constructor arguments, you'll need to run the above command and add the constructor arguments used to deploy the contract at the end of the command. For example:</p> <pre><code>npx hardhat verify --network moonbase INSERT_CONTRACT_ADDRESS INSERT_CONSTRUCTOR_ARGS\n</code></pre> <p>Please refer to the Hardhat Verify documentation for help with additional use cases such as:</p> <ul> <li>complex arguments</li> <li>libraries with undetectable addresses</li> <li>using multiple API keys</li> <li>using the <code>verify</code> command programmatically</li> <li>determining the correct constructor arguments</li> </ul>"},{"location":"builders/ethereum/verify-contracts/etherscan-plugins/#using-foundry-to-verify","title":"Using Foundry to Verify","text":"<p>The example in this section of the guide will use the <code>MyToken.sol</code> contract that was created in the Using Foundry to Deploy to Moonbeam guide. </p> <p>In addition to the Foundry project, you will need an Etherscan API key to verify your contract. </p> <p>If you have already deployed the example contract, you can verify it with the <code>verify-contract</code> command. Before you can verify the contract, you will need to ABI-encode the constructor arguments. To do so for the example contract, you can run the following command:</p> <pre><code>cast abi-encode \"constructor(uint256)\" 100\n</code></pre> <p>The result should be <code>0x0000000000000000000000000000000000000000000000000000000000000064</code>. You can then verify the contract using the following command:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>forge verify-contract --chain-id 1284 \\\nYOUR_CONTRACT_ADDRESS \\\n--constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\nsrc/MyToken.sol:MyToken \\\n--etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY\n</code></pre> <pre><code>forge verify-contract --chain-id 1285 \\\nYOUR_CONTRACT_ADDRESS \\\n--constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\nsrc/MyToken.sol:MyToken \\\n--etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY\n</code></pre> <pre><code>forge verify-contract --chain-id 1287 \\\nYOUR_CONTRACT_ADDRESS \\\n--constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\\nsrc/MyToken.sol:MyToken \\\n--etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY\n</code></pre> forge verify-contract --chain-id 1284 \\ YOUR_CONTRACT_ADDRESS \\ --constructor-args 0x0000000000000000000000000000000000000000000000000000000000000064 \\ src/MyToken.sol:MyToken \\ --etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY Submitting verification for [src/MyToken. sol:MyToken] Ok(\"0\u00d75A05EBOA18ee616bb5dac2C4D0a48991a83533d2\" ) . Submitted contract for verification:         Response:'OK'         GUID:'f7iwagu9vspdrdfirbie1wp16cmuvfk3zvcsix9ey21t3a8ttt'         URL: https: //moonbase.moonscan.io/address/0\u00d75a05eb0a18ee616bb5dac2c4d0a48991a83533d2 Waiting for verification result... Contract successfully verified. <p>If you wanted to deploy the example contract and verify at the same time, then you would use the following command:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>forge create --rpc-url INSERT_RPC_API_ENDPOINT \\\n--constructor-args 100 \\\n--etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY \\\n--verify --private-key YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken\n</code></pre> <pre><code>forge create --rpc-url INSERT_RPC_API_ENDPOINT \\\n--constructor-args 100 \\\n--etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY \\\n--verify --private-key YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken\n</code></pre> <pre><code>forge create --rpc-url https://rpc.api.moonbase.moonbeam.network \\\n--constructor-args 100 \\\n--etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY \\\n--verify --private-key YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken\n</code></pre> forge create --rpc-url INSERT_RPC_API_ENDPOINT \\ --constructor-args 100 \\ --etherscan-api-key INSERT_YOUR_ETHERSCAN_API_KEY \\ --verify --private-key YOUR_PRIVATE_KEY \\ src/MyToken.sol:MyToken Compiling... No files changed, compilation skipped Deployer: 0x0394c0EdFcCA370B20622721985B577850B0eb 75 Deployed to: 0d21b2653f61b5B5399A677D377D52D07C7668f67 Transaction hash: 0x80fff772b930f425ed3568f0b3d8844e5297691c78807c7b393c85910b7717 Starting contract verification... Waiting for etherscan to detect contract deployment... Submitting verification for [src/MyToken.sol:MyToken]Ok(\"0x21b265361b5B5399A677D377D52D07C7668f67\"). Submitted contract for verification:         Response:'OK'         GUID:'ebbliyrquc5itkavvhvmilanzu5rdqusikImgraanepjm8gpq'         URL: https: //moonbase.moonscan.io/address/0x21b2653f61b55399a677d377d52d07c7668f67 Waiting for verification result... Contract successfully verified."},{"location":"builders/get-started/endpoints/","title":"Network Endpoints","text":""},{"location":"builders/get-started/endpoints/#public-endpoints","title":"Public Endpoints","text":"<p>Moonbeam-based networks have two endpoints available for users to connect to: one for HTTPS and one for WSS.</p> <p>The endpoints in this section are for development purposes only and are not meant to be used in production applications.</p> <p>If you are looking for an API provider suitable for production use, you can check out the Endpoint Providers section of this guide.</p>"},{"location":"builders/get-started/endpoints/#moonbeam","title":"Moonbeam","text":"HTTPSWSS Provider RPC URL Limits OnFinality <pre><code>https://moonbeam.api.onfinality.io/public</code></pre> 40 req/sec UnitedBloc <pre><code>https://moonbeam.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonbeam.public.curie.radiumblock.co/http</code></pre> 200 req/sec 1RPC <pre><code>https://1rpc.io/glmr</code></pre> 10k req/day Provider RPC URL Limits OnFinality <pre><code>wss://moonbeam.api.onfinality.io/public-ws</code></pre> 40 req/sec UnitedBloc <pre><code>wss://moonbeam.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonbeam.public.curie.radiumblock.co/ws</code></pre> 200 req/sec 1RPC <pre><code>wss://1rpc.io/glmr</code></pre> 10k req/day"},{"location":"builders/get-started/endpoints/#moonriver","title":"Moonriver","text":"HTTPSWSS Provider RPC URL Limits OnFinality <pre><code>https://moonriver.api.onfinality.io/public</code></pre> 40 req/sec UnitedBloc <pre><code>https://moonriver.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonriver.public.curie.radiumblock.co/http</code></pre> 200 req/sec Provider RPC URL Limits OnFinality <pre><code>wss://moonriver.api.onfinality.io/public-ws</code></pre> 40 req/sec UnitedBloc <pre><code>wss://moonriver.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonriver.public.curie.radiumblock.co/ws</code></pre> 200 req/sec"},{"location":"builders/get-started/endpoints/#moonbase-alpha","title":"Moonbase Alpha","text":"HTTPSWSS Provider RPC URL Limits OnFinality <pre><code>https://moonbeam-alpha.api.onfinality.io/public</code></pre> 40 req/sec Moonbeam Foundation <pre><code>https://rpc.api.moonbase.moonbeam.network</code></pre> 25 req/sec UnitedBloc <pre><code>https://moonbase.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonbase.public.curie.radiumblock.co/http</code></pre> 200 req/sec Provider RPC URL Limits OnFinality <pre><code>wss://moonbeam-alpha.api.onfinality.io/public-ws</code></pre> 40 req/sec Moonbeam Foundation <pre><code>wss://wss.api.moonbase.moonbeam.network</code></pre> 25 req/sec UnitedBloc <pre><code>wss://moonbase.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonbase.public.curie.radiumblock.co/ws</code></pre> 200 req/sec"},{"location":"builders/get-started/endpoints/#relay-chain","title":"Relay Chain","text":"<p>To connect to the Moonbase Alpha relay chain, you can use the following WS Endpoint:</p> Provider RPC URL OpsLayer <pre><code>wss://relay.api.moonbase.moonbeam.network</code></pre>"},{"location":"builders/get-started/endpoints/#endpoint-providers","title":"RPC Endpoint Providers","text":"<p>You can create your own endpoint suitable for development or production use using any of the following API providers:</p> <ul> <li>1RPC</li> <li>Chainstack</li> <li>dRPC NodeCloud</li> <li>Dwellir</li> <li>GetBlock</li> <li>OnFinality</li> <li>UnitedBloc</li> </ul>"},{"location":"builders/get-started/endpoints/#1rpc","title":"1RPC","text":"<p>1RPC is a free and private RPC relay that protects user privacy by preventing data collection, user tracking, phishing attempts from other parties. It tunnels user requests via distributed relays to other RPC providers whilst preventing the tracking of user metadata such as IP address, device information and wallet linkability with secure enclave technology.</p> <p>1RPC is created to be an open initiative from the blockchain infrastructure community. They are motivated by a common good mission to help build a better Web3 and encourage anyone who values user privacy to join this open collaboration.</p> <p>Head over to 1RPC official site to set it up!</p> <p></p>"},{"location":"builders/get-started/endpoints/#chainstack","title":"Chainstack","text":"<p>Chainstack, the Web3 infrastructure provider, offers free and paid endpoints for Moonbeam. The free Developer plan starts with 3 million monthly requests and 25 requests per second (RPS). You can easily scale with the paid plans.</p> <p>To start with a free Developer plan endpoint, sign up using an email or any social account, like GitHub or X (Twitter).</p> <ol> <li>Visit Chainstack</li> <li>Sign up</li> <li>Deploy a Moonbeam node</li> </ol> <p></p>"},{"location":"builders/get-started/endpoints/#drpc","title":"dRPC NodeCloud","text":"<p>dRPC.org offers public and paid Moonbeam RPC endpoints, providing an efficient, low-latency connection to blockchain nodes. The paid tiers include higher request limits, lower latency, and advanced analytics for optimized performance.</p> <p>How to use dRPC:</p> <ol> <li>Sign up or log in at dRPC.org</li> <li>In the dashboard, create an API key</li> <li>Click the key and select the desired endpoint</li> </ol> <p>For 24/7 support, join dRPC's Discord.</p>"},{"location":"builders/get-started/endpoints/#dwellir","title":"Dwellir","text":"<p>Dwellir is a blockchain operation service that ensures global scalability, low latency, and a 99.99% uptime guarantee, providing fast and reliable node operations wherever your business stands. The public endpoint service is geographically distributed bare metal servers globally. As the service is public, there are no sign-up or API keys to manage.</p> <p>To get started with a developer endpoint or dedicated node, you'll need to contact us:</p> <ol> <li>Visit Dwellir</li> <li>Submit your email and your node request</li> </ol> <p></p>"},{"location":"builders/get-started/endpoints/#getblock","title":"GetBlock","text":"<p>GetBlock is a service that provides instant API access to Moonbeam and Moonriver and is available through shared and dedicated nodes. Dedicated nodes provide access to a private server with fast speeds and without rate limits. Shared nodes provide a free API/add-on based endpoint for you to get started quickly.</p> <p>To get started with GetBlock, you can go to the GetBlock registration page and sign up for a new account. Then, from your account Dashboard, you can view and manage your existing endpoints for multiple protocols, and also create new ones.</p> <p>Creating a new API/add-on based endpoint is simple, all you have to do is:</p> <ol> <li>Fill the information for the desired protocol from the list of available blockchains</li> <li>Choose the network you want your endpoint to point to (Mainnet, Testnet, etc)</li> <li>Select JSON-RPC from the API/Add-on dropdown</li> <li>Click the Get button at the far right and you're all set to go! </li> </ol> <p></p>"},{"location":"builders/get-started/endpoints/#onfinality","title":"OnFinality","text":"<p>OnFinality provides a free API key based endpoint for customers in place of a public endpoint. Additionally, OnFinality offers paid tiers of service that offer increased rate limits and higher performance than those offered by the free tier. You also receive more in depth analytics of the usage of your application.</p> <p>To create a custom OnFinality endpoint, go to OnFinality and sign up, or if you already have signed up you can go ahead and log in. From the OnFinality Dashboard, you can:</p> <ol> <li>Click on API Service</li> <li>Select the network from the dropdown</li> <li>Your custom API endpoint will be generated automatically</li> </ol> <p></p>"},{"location":"builders/get-started/endpoints/#unitedbloc","title":"UnitedBloc","text":"<p>UnitedBloc is a collective of community collators from both Moonbeam and Moonriver. To provide value for the community, they offer public RPC services for the Moonbeam, Moonriver, and Moonbase Alpha networks.</p> <p>The public endpoint service is served by eight geographically distributed bare metal servers globally balanced via GeoDNS and regionally load balanced with NGINX. As the service is public, there are no sign-up or API keys to manage.</p> <p>The collators involved in this initiative are:</p> <ul> <li>Blockshard (CH)</li> <li>BloClick (ES)</li> <li>BrightlyStake (IN)</li> <li>CertHum (US)</li> <li>GPValidator (PT)</li> <li>Hetavalidation (AU)</li> <li>Legend (AE)</li> <li>PathrockNetwork (DE)</li> <li>Polkadotters (CZ)</li> <li>SIK | crifferent.de (DE)</li> <li>StakeBaby (GR)</li> <li>StakeSquid (GE)</li> <li>TrueStaking (US)</li> </ul> <p>They also provide a public Grafana dashboard with some cool metrics.</p> <p>Check the public endpoints section to get the relevant URL. You can contact them via their Telegram channel, or read more about their initiative on their blogpost page.</p>"},{"location":"builders/get-started/endpoints/#lazy-loading-with-RPC-Endpoint-Providers","title":"Lazy Loading with RPC Endpoint Providers","text":"<p>Lazy loading lets a Moonbeam node operate while downloading network state in the background, eliminating the need to wait for full synchronization before use. To spin up a Moonbeam node with lazy loading, you'll need to either download the Moonbeam release binary or compile the binary. You can activate lazy loading with the following flag:</p> <p><code>--lazy-loading-remote-rpc 'INSERT-RPC-URL'</code></p> <p>Lazy loading is highly resource-intensive, requiring many RPC requests to function. To avoid being throttled, it's recommended that you use a dedicated endpoint (i.e., an endpoint with an API key) rather than a public endpoint. You will likely be rate-limited if you use lazy loading with a public endpoint. Upon spooling up a node with this feature, you'll see output like the following:</p> [Lazy loading \ud83c\udf17]     You are now running the Moonbeam client in lazy loading mode, where data is retrieved     from a live RPC node on demand.     Using remote state from: https://moonbeam.unitedbloc.com     Forking from block: 8482853     To ensure the client works properly, please note the following:         1. *Avoid Throttling*: Ensure that the backing RPC node is not limiting the number of         requests, as this can prevent the lazy loading client from functioning correctly;         2. *Be Patient*: As the client may take approximately 20 times longer than normal to         retrieve and process the necessary data for the requested operation.     The service will start in 10 seconds..."},{"location":"builders/get-started/endpoints/#overriding-state-with-lazy-loading","title":"Overriding State with Lazy Loading","text":"<p>By default, you won't see detailed logging in the terminal. To override this setting and show lazy loading logs, you can add the following flag to your command to start the Moonbeam node: <code>-l debug</code>. You can further customize your use of the lazy loading functionality with the following optional parameters:</p> <ul> <li><code>--lazy-loading-block</code> - specifies a block hash from which to start loading data. If not provided, the latest block will be used</li> <li><code>--lazy-loading-delay-between-requests</code> - the delay (in milliseconds) between RPC requests when using lazy loading. This parameter controls the amount of time to wait between consecutive RPC requests. This can help manage request rate and avoid overwhelming the server. Default value is <code>100</code> milliseconds</li> <li><code>--lazy-loading-max-retries-per-request</code> - the maximum number of retries for an RPC request when using lazy loading. Default value is <code>10</code> retries</li> <li><code>--lazy-loading-runtime-override</code> - path to a WASM file to override the runtime when forking. If not provided, it will fetch the runtime from the block being forked</li> <li><code>--lazy-loading-state-overrides</code> - path to a JSON file containing state overrides to be applied when forking</li> </ul>"},{"location":"builders/get-started/endpoints/#simple-storage-item-override","title":"Simple Storage Item Override","text":"<p>The state overrides file should define the respective pallet, storage item, and value that you seek to override as follows:</p> <pre><code>[\n {\n     \"pallet\": \"System\",\n     \"storage\": \"SelectedCandidates\",\n     \"value\": \"0x04f24ff3a9cf04c71dbc94d0b566f7a27b94566cac\"\n }\n]\n</code></pre>"},{"location":"builders/get-started/endpoints/#override-an-accounts-free-balance","title":"Override an Account's Free Balance","text":"<p>To override the balance of a particular account, you can override the account storage item of the system pallet for the respective account as follows:</p> <pre><code>[\n  {\n    \"pallet\": \"System\",\n    \"storage\": \"Account\",\n    \"key\": \"TARGET_ADDRESS\",\n    \"value\": \"0x460c000002000000010000000600000069e10de76676d0800000000000000000040a556b0e032de12000000000000000004083a09e15c74c1b0100000000000000000000000000000000000000000000080\"\n  }\n]\n</code></pre> Details about overriding account balances <p>Overriding an account balance, as shown above, can be a complex process. However, this guide will break it down into steps that are easy to follow. Before making any changes, you should obtain the existing value corresponding to the key (i.e., the account in this case). You can go to Chain State on Polkadot.js Apps and query the System pallet by providing the account you'd like to query. Upon submitting the query, you'll get back a readable account structure like so:</p> <pre><code>{\n  nonce: 3,142\n  consumers: 2\n  providers: 1\n  sufficients: 6\n  data: {\n    free: 1,278,606,392,142,175,328,676\n    reserved: 348,052,500,000,000,000,000\n    frozen: 20,413,910,106,633,175,872\n    flags: 170,141,183,460,469,231,731,687,303,715,884,105,728\n  }\n}\n</code></pre> <p>While this is useful as a reference, the information you're looking for is the encoded storage key, which is accessible even without submitting the chain state query. In this instance, the encoded storage key corresponding to the system pallet and the selected account <code>0x3B939FeaD1557C741Ff06492FD0127bd287A421e</code> is:</p> <pre><code>0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9b882fedb4f75b055c709ec5b66b5d9933b939fead1557c741ff06492fd0127bd287a421e\n</code></pre> <p>Note that this encoded storage key will change alongside any input changes, such as a different account being queried. Then, head over the Raw Storage tab on Polkadot.js Apps. Input the above storage key and submit the query. The response is the SCALE encoded account struct, a part of which contains the free balance information to be modified as part of this example: </p> <pre><code>0x460c0000020000000100000006000000a4d92a6a4e6b3a5045000000000000000040a556b0e032de12000000000000004083a09e15c74c1b010000000000000000000000000000000000000000000080\n</code></pre> <p>There is quite a bit of data encoded in the value field because it is a complex struct comprised of multiple values. The struct is comprised of:</p> <pre><code>struct AccountInfo {\n    nonce: u32,             // Transaction count\n    consumers: u32,         // Number of consumers \n    providers: u32,         // Number of providers\n    sufficients: u32,       // Number of sufficients\n    data: AccountData {     // The balance info\n        free: u128,         // Free balance\n        reserved: u128,     // Reserved balance\n        frozen: u128,       // Frozen balance\n        flags: u128         // Account flags\n    }\n}\n</code></pre> <p>You can associate each part of the SCALE encoded struct with the corresponding piece of Alice's account information that it represents:</p> <pre><code>0x460c0000        // nonce (u32): 3,142 \n02000000          // consumers (u32): 2\n01000000          // providers (u32): 1  \n06000000          // sufficients (u32): 6\n\na4d92a6a4e6b3a5045000000000000000  \n// free (u128): 1,278,606,392,142,175,328,676\n\n40a556b0e032de1200000000000000000  \n// reserved (u128): 348,052,500,000,000,000,000  \n\n4083a09e15c74c1b01000000000000000  \n// frozen (u128): 20,413,910,106,633,175,872\n\n00000000000000000000000000000080   \n// flags (u128): 170,141,183,460,469,231,731,687,303,715,884,105,728\n</code></pre> <p>Remember that the values are little endian encoded. To convert the hexadecimal little endian encoded values to decimal, you can use Substrate Utilities converter, using the Balance to Hex (Little Endian) converter.</p> <p>In this example, the existing free balance of <code>1,278,606,392,142,175,328,676</code> Wei or approximately <code>1278.60</code> DEV is <code>a4d92a6a4e6b3a5045</code>. The following example will change the value to <code>500,000</code> DEV, which is <code>500,000,000,000,000,000,000,000</code> Wei or <code>0x000080d07666e70de169</code> encoded as a hexadecimal little endian value. When properly padded to fit into the SCALE encoded storage value, it becomes <code>69e10de76676d08000000000000000000</code>, such that the table now looks like:</p> <pre><code>0x460c0000        // nonce (u32): 3,142 \n02000000          // consumers (u32): 2\n01000000          // providers (u32): 1  \n06000000          // sufficients (u32): 6\n\n69e10de76676d08000000000000000000\n// free (u128): 500,000,000,000,000,000,000,000\n\n40a556b0e032de1200000000000000000  \n// reserved (u128): 348,052,500,000,000,000,000  \n\n4083a09e15c74c1b01000000000000000  \n// frozen (u128): 20,413,910,106,633,175,872\n\n00000000000000000000000000000080   \n// flags (u128): 170,141,183,460,469,231,731,687,303,715,884,105,728\n</code></pre> <p>Therefore, the SCALE encoded override value is as follows:</p> <pre><code>0x460c000002000000010000000600000069e10de76676d0800000000000000000040a556b0e032de12000000000000000004083a09e15c74c1b0100000000000000000000000000000000000000000000080\n</code></pre> <p>You can now specify the SCALE encoded override value in your <code>state-overrides.json</code> file as follows:</p> <pre><code>[\n  {\n    \"pallet\": \"System\",\n    \"storage\": \"Account\",\n    \"key\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"value\": \"0x460c000002000000010000000600000069e10de76676d0800000000000000000040a556b0e032de12000000000000000004083a09e15c74c1b0100000000000000000000000000000000000000000000080\"\n  }\n]\n</code></pre> <p>To run lazy loading with the balance state override, you can use the following command: </p> <pre><code>--lazy-loading-remote-rpc 'INSERT_RPC_URL' --lazy-loading-state-overrides ./state-overrides.json\n</code></pre>"},{"location":"builders/get-started/endpoints/#override-an-erc-20-token-balance","title":"Override an ERC-20 Token Balance","text":"<p>To override an ERC-20 token balance, identify the storage slot in the EVM\u2019s AccountStorages where the <code>balanceOf</code> data for the given token contract and account is stored. This storage slot is determined by the token contract\u2019s H160 address and the corresponding H256 storage key. Once you have this slot, specify the new balance value in the <code>state-overrides.json</code> file to implement the override.</p> <p>In the example below, we override the token balance of the Wormhole USDC Contract (<code>0x931715FEE2d06333043d11F658C8CE934aC61D0c</code>) for the account <code>0x3b939fead1557c741ff06492fd0127bd287a421e</code> to $5,000 USDC. Since Wormhole USDC uses 6 decimal places, $5,000 corresponds to <code>5000000000</code> in integer form, which is <code>0x12a05f200</code> in hexadecimal.</p> <pre><code>[\n    {\n        \"pallet\": \"EVM\",\n        \"storage\": \"AccountStorages\",\n        \"key\": [\n            \"0x931715FEE2d06333043d11F658C8CE934aC61D0c\",\n            \"0x8c9902c0f94ae586c91ba539eb52087d3dd1578da91158308d79ff24a8d4f342\"\n        ],\n        \"value\": \"0x000000000000000000000000000000000000000000000000000000012a05f200\"\n    }\n]\n</code></pre> <p>You can calculate the exact storage slot to override for your own account with the following script:</p> <pre><code>import { ethers } from 'ethers';\n\nfunction getBalanceSlot(accountAddress) {\n  // Convert address to bytes32 and normalize\n  const addr = ethers.zeroPadValue(accountAddress, 32);\n\n  // CAUTION! The storage slot used here is 5, which\n  // is specific to Wormhole contracts\n  // The storage slot index for other tokens may vary\n  const packedData = ethers.concat([\n    addr,\n    ethers.zeroPadValue(ethers.toBeHex(5), 32),\n  ]);\n\n  // Calculate keccak256\n  return ethers.keccak256(packedData);\n}\n\n// Example usage\nconst address = 'INSERT_ADDRESS';\nconsole.log(getBalanceSlot(address));\n</code></pre> <p>You can apply the same process for other ERC-20 token contracts. The following sections demonstrate overrides for the <code>0x3B939FeaD1557C741Ff06492FD0127bd287A421e</code> account with various ERC-20 tokens. Remember to update the H160 token contract address whenever you switch to a different token. Also, you will need to recalculate the H256 storage slot for each distinct account whose balance you want to override.</p> Example: Override Wormhole BTC Token Balance <pre><code>[\n    {\n        \"pallet\": \"EVM\",\n        \"storage\": \"AccountStorages\",\n        \"key\": [\n            \"0xE57eBd2d67B462E9926e04a8e33f01cD0D64346D\",\n            \"0x8c9902c0f94ae586c91ba539eb52087d3dd1578da91158308d79ff24a8d4f342\"\n        ],\n        \"value\": \"0x000000000000000000000000000000000000000000000000000000012a05f200\"\n    }\n]\n</code></pre> Example: Override Wormhole ETH Token Balance <pre><code>[\n    {\n        \"pallet\": \"EVM\",\n        \"storage\": \"AccountStorages\",\n        \"key\": [\n            \"0xab3f0245B83feB11d15AAffeFD7AD465a59817eD\",\n            \"0x8c9902c0f94ae586c91ba539eb52087d3dd1578da91158308d79ff24a8d4f342\"\n        ],\n        \"value\": \"0x000000000000000000000000000000000000000000000000000000012a05f200\"\n    }\n]\n</code></pre> Example: Override WELL Token Balance <p>Because the WELL token does not use a proxy implementation contract, the storage slot calculation differs. Instead of slot <code>5</code>, the balance mapping resides at slot <code>1</code>. You can determine the exact storage slot to override the WELL token balance for your own account using the following script:</p> <pre><code>import { ethers } from 'ethers';\n\nfunction getBalanceSlot(accountAddress) {\n  // Convert address to bytes32 and normalize\n  const addr = ethers.zeroPadValue(accountAddress, 32);\n\n  // Caution! The storage slot index used here is 1\n  // The storage slot index for other tokens may vary\n  const packedData = ethers.concat([\n    addr,\n    ethers.zeroPadValue(ethers.toBeHex(1), 32),\n  ]);\n\n  // Calculate keccak256\n  return ethers.keccak256(packedData);\n}\n\n// Example usage\nconst address = 'INSERT_ADDRESS';\nconsole.log(getBalanceSlot(address));\n</code></pre> <p>Thus, the storage override would be:</p> <pre><code>[\n    {\n        \"pallet\": \"EVM\",\n        \"storage\": \"AccountStorages\",\n        \"key\": [\n            \"0x511aB53F793683763E5a8829738301368a2411E3\",\n            \"0x728d3daf4878939a6bb58cbc263f39655bb57ea15db7daa0b306f3bf2c3f1227\"\n        ],\n        \"value\": \"0x000000000000000000000000000000000000000000000000000000012a05f200\"\n    }\n]\n</code></pre>"},{"location":"builders/get-started/endpoints/#tracing-providers","title":"Tracing RPC Endpoint Providers","text":"<p>Tracing RPC endpoints allow you to access non-standard RPC methods, such as those that belong to Geth's <code>debug</code> and <code>txpool</code> APIs and OpenEthereum's <code>trace</code> module. To see a list of the supported non-standard RPC methods on Moonbeam for debugging and tracing, please refer to the Debug API &amp; Trace Module guide.</p> <p>The following providers provide tracing RPC endpoints:</p> <ul> <li>OnFinality</li> </ul>"},{"location":"builders/get-started/endpoints/#onfinality-tracing","title":"OnFinality","text":"<p>OnFinality's Trace API can be used to quickly get started tracing and debugging transactions on Moonbeam and Moonriver. It is only available to users on their Growth and Ultimate plans.</p> <p>To use the Trace API, you simply call the trace method of your choice from your private RPC endpoint. For a list of the supported networks and trace methods, please check out OnFinality's Trace API documentation.</p> <p>Please note that if you are tracing historic blocks, it is recommended to use your own dedicated trace node to backfill any data, and then once you're caught up, you can switch to using the Trace API. You can check out the How to Deploy a Trace Node for Moonbeam on OnFinality post for more information on how to spin up your own dedicated trace node.</p>"},{"location":"builders/get-started/explorers/","title":"Block Explorers","text":""},{"location":"builders/get-started/explorers/#introduction","title":"Introduction","text":"<p>Block explorers can be thought of as search engines for the blockchain. They allow users to search for information such as balances, contracts, and transactions. More advanced block explorers even offer indexing capabilities, which enable them to provide a complete set of information, such as ERC-20 tokens in the network. They might even offer API services to access it via external services.</p> <p>Moonbeam provides two different kinds of explorers: ones to query the Ethereum API and others  dedicated to the Substrate API. All EVM-based transactions are accessible via the Ethereum API, while the Substrate API can be relied upon for Substrate-native functions such as governance and staking. The Substrate API also includes information about the EVM-based transactions, but only limited information is shown.</p>"},{"location":"builders/get-started/explorers/#quick-links","title":"Quick Links","text":"MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node Block Explorer Type URL Moonscan EVM https://moonbeam.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=Moonbeam Subscan Substrate https://moonbeam.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Moonscan EVM https://moonriver.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=Moonriver Subscan Substrate https://moonriver.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Moonscan EVM https://moonbase.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=MoonbaseAlpha Subscan Substrate https://moonbase.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Expedition EVM https://moonbeam-explorer.netlify.app/?network=MoonbeamDevNode Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer"},{"location":"builders/get-started/explorers/#ethereum-api","title":"Ethereum API","text":""},{"location":"builders/get-started/explorers/#Moonscan","title":"Moonscan","text":"<p>Moonscan is the primary Ethereum API block explorer for Moonbeam-based networks. Built by the Etherscan team, Moonscan provides a powerful, intuitive, and feature-rich experience. In addition to its comprehensive transaction and block data, Moonscan provides a number of statistics and charts, such as average gas price, daily transactions, and block size charts.</p> <p>Other Moonscan features include:</p> <ul> <li>Collator leaderboard ranking collators by performance</li> <li>Contract source code verification, accessible both via a web interface and an API</li> <li>Ability to read and write state data of verified smart contracts</li> <li>Token approvals where you can view and revoke any of your prior token approvals</li> <li>Adding token information and creating a profile for ERC-20s, ERC-721s, and ERC-1155s deployed to Moonbeam-based networks. The profile can include links to your project, social media, price data, and other information pertaining to your token</li> </ul> <p></p>"},{"location":"builders/get-started/explorers/#expedition","title":"Expedition","text":"<p>A Moonbeam-themed version of the Expedition explorer can be found in this link. It is a basic JSON-RPC based explorer.</p> <p>By default, the explorer is connected to Moonbeam. However, you can switch to Moonriver or Moonbase Alpha, or connect it to a local dev node by following the next steps:</p> <ol> <li>Click on the network text, where you'll be able to select between all different networks, including a Moonbeam Development Node running on <code>http://127.0.0.1:9944</code></li> <li>In the case you want to connect to a specific RPC URL, select Add Custom Chain and enter the URL. For example, <code>http://localhost:9937</code></li> </ol> <p></p>"},{"location":"builders/get-started/explorers/#substrate-api","title":"Substrate API","text":""},{"location":"builders/get-started/explorers/#subscan","title":"Subscan","text":"<p>Subscan is the primary Substrate API block explorer for Moonbeam-based networks. Subscan is capable of parsing standard or custom modules. For example, this is useful to display information regarding the Staking, Governance, and EVM pallets (or modules). The code is all open-source and can be found in the Subscan Essentials GitHub repo.</p> <p></p>"},{"location":"builders/get-started/explorers/#polkadotjs","title":"Polkadot.js","text":"<p>While not a full-featured block explorer, Polkadot.js Apps is a convenient option especially for users running local development nodes to view events and query transaction hashes. Polkadot.js Apps uses the WebSocket endpoint to interact with the Network. You can easily connect to Moonbeam, Moonriver, or Moonbase Alpha.</p> <p></p> <p>To connect it to a Moonbeam development node, you can follow the steps in the Connecting Polkadot.js Apps to a Local Moonbeam Node section of the Getting Started with a Moonbeam Development Node guide. The default port for this is <code>9944</code>.</p> <p></p>"},{"location":"builders/get-started/quick-start/","title":"Quick Start Guide for Developing on Moonbeam","text":""},{"location":"builders/get-started/quick-start/#overview","title":"Quick Overview","text":"<p>Moonbeam is a fully Ethereum-compatible smart contract platform on Polkadot. As such, you can interact with Moonbeam via the Ethereum API and Substrate API.</p> <p>Although Moonbeam is a Substrate-based platform, it uses a unified accounts system, which replaces Substrate-style accounts and keys with Ethereum-style accounts and keys. As a result, you can interact with your Moonbeam account with MetaMask, Ledger, and other Ethereum-compatible wallets by simply adding Moonbeam's network configurations. Similarly, you can develop on Moonbeam using Ethereum libraries and development environments.</p>"},{"location":"builders/get-started/quick-start/#moonbeam-networks","title":"Moonbeam Networks","text":"<p>To get started developing on Moonbeam, it's important to be aware of the various networks within the Moonbeam ecosystem.</p> Network Network Type Relay Chain Native Asset Symbol Native Asset Decimals Moonbeam MainNet Polkadot GLMR 18 Moonriver MainNet Kusama MOVR 18 Moonbase Alpha TestNet Alphanet relay (Westend-based) DEV 18 Moonbeam Development Node Local TestNet None DEV 18 <p>Note</p> <p>A Moonbeam development node doesn't have a relay chain as its purpose is to be your own personal development environment where you can get started developing quickly without the overhead of a relay chain.</p>"},{"location":"builders/get-started/quick-start/#network-configurations","title":"Network Configurations","text":"<p>When working with developer tools, depending on the tool, you might need to configure Moonbeam to interact with the network. To do so, you can use the following information:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node Variable Value Chain ID <pre><code>1284</code></pre> Public RPC URLs <pre><code>https://rpc.api.moonbeam.network</code></pre> <pre><code>https://moonbeam.unitedbloc.com</code></pre> Public WSS URLs <pre><code>wss://wss.api.moonbeam.network</code></pre> Variable Value Chain ID <pre><code>1285</code></pre> Public RPC URLs <pre><code>https://rpc.api.moonriver.moonbeam.network</code></pre> <pre><code>https://moonriver.unitedbloc.com</code></pre> Public WSS URLs <pre><code>wss://wss.api.moonriver.moonbeam.network</code></pre> Variable Value Chain ID <pre><code>1287</code></pre> Public RPC URLs <pre><code>https://rpc.api.moonbase.moonbeam.network</code></pre> Public WSS URLs <pre><code>wss://wss.api.moonbase.moonbeam.network</code></pre> Variable Value Chain ID <pre><code>1281</code></pre> Local RPC URL <pre><code>http://127.0.0.1:9944</code></pre> Local WSS URL <pre><code>ws://127.0.0.1:9944</code></pre> <p>Note</p> <p>You can create your own endpoint suitable for development or production from one of the supported RPC providers.</p>"},{"location":"builders/get-started/quick-start/#explorers","title":"Block Explorers","text":"<p>Moonbeam provides two different kinds of explorers: ones to query the Ethereum API, and others dedicated to the Substrate API. All EVM-based transactions are accessible via the Ethereum API whereas the Substrate API can be relied upon for Substrate-native functions such as governance, staking, and some information about EVM-based transactions. For more information on each explorer, please check out the Block Explorers page.</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node Block Explorer Type URL Moonscan EVM https://moonbeam.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=Moonbeam Subscan Substrate https://moonbeam.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Moonscan EVM https://moonriver.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=Moonriver Subscan Substrate https://moonriver.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Moonscan EVM https://moonbase.moonscan.io/ Expedition EVM https://moonbeam-explorer.netlify.app/?network=MoonbaseAlpha Subscan Substrate https://moonbase.subscan.io/ Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer Block Explorer Type URL Expedition EVM https://moonbeam-explorer.netlify.app/?network=MoonbeamDevNode Polkadot.js Substrate https://polkadot.js.org/apps/#/explorer"},{"location":"builders/get-started/quick-start/#testnet-tokens","title":"Funding TestNet Accounts","text":"<p>To get started developing on one of the TestNets, you'll need to fund your account with DEV tokens to send transactions. Please note that DEV tokens have no real value and are for testing purposes only.</p> TestNet Where To Get Tokens From Moonbase Alpha The Moonbase Alpha Faucet website.  The faucet dispenses 1.1 DEV tokens every 24 hours Moonbeam Development Node Any of the ten pre-funded accounts that come with your  development node"},{"location":"builders/get-started/quick-start/#development-tools","title":"Development Tools","text":"<p>As Moonbeam is a Substrate-based chain that is fully Ethereum-compatible, you can use Substrate-based tools and Ethereum-based tools.</p>"},{"location":"builders/get-started/quick-start/#javascript","title":"JavaScript Tools","text":"EthereumSubstrate Tool Type Ethers.js Library Hardhat Dev Environment Remix Dev Environment Tool Type Polkadot.js API Library"},{"location":"builders/get-started/quick-start/#python","title":"Python Tools","text":"EthereumSubstrate Tool Type Web3.py Library Tool Type Py Substrate Interface Library"},{"location":"builders/get-started/token-profile/","title":"Add Token Information on Moonscan","text":""},{"location":"builders/get-started/token-profile/#introduction","title":"Introduction","text":"<p>This tutorial will guide you through the process of adding a profile for your ERC-20, ERC-721, or ERC-1155 tokens to Moonscan.</p> <p>\u200b\u200bMoonscan is a block explorer and analytics platform for EVM-compatible chains. It is an integration of Moonbeam and Etherscan, and it allows users and developers to have access to developer tools and network statistics that provide granular insights into the EVM of Moonriver and Moonbeam.</p> <p>Developers can create a profile for their tokens on Moonriver and Moonbeam. The profile captures basic information about the project behind the token, social media links, links to price data, and other information pertaining to the project\u2019s token sales.</p> <p></p> <p>This tutorial will show you how to create a profile on Moonscan of a sample ERC-20 token, called DemoToken (DEMO), deployed to Moonriver. These instructions can be adapted for any of the Moonbeam-based networks, as well as for an ERC-721 or ERC-1155 token.</p>"},{"location":"builders/get-started/token-profile/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have the following:</p> <ul> <li>A Moonscan Account</li> </ul> <p>You will need to verify ownership of the token contract address later on in this guide. You can either do this manually or automatically, but if you choose to do it automatically you'll also need the following:</p> <ul> <li>Access to the account that deployed the token contract, so you can sign messages as the owner</li> <li>MetaMask installed and connected to the network where the token is deployed to</li> </ul>"},{"location":"builders/get-started/token-profile/#getting-started","title":"Getting Started","text":"<p>To get started, you'll need to make sure that you are logged into your Moonscan account. Once you\u2019re signed into your account, you can go to the token page of the token you want to add a profile for. For ERC-20s, you can search the name of the token in the search bar. Or for any token, you can manually enter in the URL.</p> MoonbeamMoonriverMoonbase Alpha <pre><code>https://moonscan.io/token/INSERT_CONTRACT_ADDRESS\n</code></pre> <pre><code>https://moonriver.moonscan.io/token/INSERT_CONTRACT_ADDRESS \n</code></pre> <pre><code>https://moonbase.moonscan.io/token/INSERT_CONTRACT_ADDRESS\n</code></pre> <p>Next to Social Profiles, you can click on Update.</p> <p></p> <p>You\u2019ll be taken to the Token Update Application Form.</p> <p>If you haven\u2019t verified your contract source code yet, you will need to do so before you can proceed to the next step. If you have already verified your contract, you can skip ahead to the Verifying Address Ownership section.</p>"},{"location":"builders/get-started/token-profile/#verifying-contract-source-code","title":"Verifying Contract Source Code","text":"<p>You can verify your contract source code a couple of ways. You can directly verify it from Moonscan, or if you developed the contract with Hardhat or Foundry, you can also use their corresponding Etherscan integrations.</p> <p>To verify your contract source code directly from Moonscan, you can click on the tool link.</p> <p></p> <p>You\u2019ll be taken to the Verify &amp; Publish Contract Source Code page where you can enter in details about the contract and how it was compiled.</p> <ol> <li>Enter the token contract address</li> <li>Select the Compiler Type from the dropdown</li> <li>Choose the Compile Version you used</li> <li>Then select an Open Source License Type</li> <li>Review and click the I agree to the terms of service checkbox</li> <li>Click Continue</li> </ol> <p></p> <p>You\u2019ll be taken to the next page where you can enter in the contract source code and specify additional settings and arguments used.</p> <ol> <li>Contract Address and Compiler should already be filled in. If you enabled optimization, you can update the Optimization dropdown</li> <li>Enter in a flattened version of the contract source code. To flatten the contract, you can use the Flattener Remix plugin</li> <li>Update the Constructor Arguments, Contract Library Address, and Misc Settings sections if needed</li> <li>Click I\u2019m not a robot</li> <li>Finally, click Verify and Publish</li> </ol> <p></p> <p>Now that your contract source code has been verified, you can move on to the next step, verifying that you\u2019re the contract address owner.</p>"},{"location":"builders/get-started/token-profile/#verifying-address-ownership","title":"Verifying Address Ownership","text":"<p>From the Token Update Application Form page, you should see a message at the top of the screen that states you need to verify the contract address owner. To get started with this process, you can click on the tool link.</p> <p></p> <p>You\u2019ll be taken to the Verify Address Ownership page, where you can choose to sign the message verifying your ownership either manually or by connecting to Web3. If you wish to verify ownership manually, you\u2019ll need the message signature hash. Otherwise, if you connect to Web3, the hash will be calculated for you.</p> <p></p>"},{"location":"builders/get-started/token-profile/#sign-message-manually","title":"Sign Message Manually","text":"<p>If you wish to verify ownership manually, you\u2019ll need the message signature hash. If you have calculated the hash yourself, you can click Sign Message Manually, enter the Message Signature Hash, and click Verify Ownership.</p> <p></p>"},{"location":"builders/get-started/token-profile/#connect-to-web3","title":"Connect to Web3","text":"<p>You can easily calculate the message signature hash using MetaMask. You will need to have the account you deployed the contract with loaded into MetaMask. Then you can click on Connect to Web3 and MetaMask will pop-up.</p> <ol> <li>Select the account to connect with, which should be the account you used to deploy the contract</li> <li>Connect to the account</li> </ol> <p></p> <p>Back on the Verify Address Ownership page, you can take the following steps</p> <ol> <li>Click Sign with Web3</li> <li>MetaMask will pop-up and you can Sign the message</li> </ol> <p></p> <p>Once you\u2019ve signed the message, you can then click Click to Proceed. You should now see that the Message Signature Hash has been automatically populated for you. All you have left to do is click Verify Ownership.</p> <p></p>"},{"location":"builders/get-started/token-profile/#creating-the-profile","title":"Creating the Profile","text":"<p>Now you can start filling in the necessary information to build the token profile, including project information, social media links, price data links, and more. You should make sure that all the links provided are working and are safe to visit before submitting.</p> <p>At a minimum you will need to fill in the following information:</p> <ul> <li>Request Type</li> <li>Token Contract Address</li> <li>Requester Name</li> <li>Requester Email Address</li> <li>Official Project Website</li> <li>Official Project Email Address</li> <li>Link to download a 32x32 png icon logo</li> <li>Project Description</li> </ul> <p>All of the other fields are optional. Once you\u2019ve filled in the information, you can click Submit at the bottom of the page.</p> <p></p> <p>And that\u2019s it! You\u2019ve successfully created and submitted a profile for your token on Moonscan! The Moonscan team will review your submission as soon as possible and provide you with further instructions as needed.</p>"},{"location":"builders/get-started/networks/moonbase/","title":"Get Started with Moonbase Alpha","text":""},{"location":"builders/get-started/networks/moonbase/#network-endpoints","title":"Network Endpoints","text":"<p>Moonbase Alpha has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.</p> <p>If you're looking for your own endpoints suitable for production use, you can check out the Endpoint Providers section of our documentation. Otherwise, to get started quickly you can use one of the following public HTTPS or WSS endpoints.</p> HTTPSWSS Provider RPC URL Limits OnFinality <pre><code>https://moonbeam-alpha.api.onfinality.io/public</code></pre> 40 req/sec Moonbeam Foundation <pre><code>https://rpc.api.moonbase.moonbeam.network</code></pre> 25 req/sec UnitedBloc <pre><code>https://moonbase.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonbase.public.curie.radiumblock.co/http</code></pre> 200 req/sec Provider RPC URL Limits OnFinality <pre><code>wss://moonbeam-alpha.api.onfinality.io/public-ws</code></pre> 40 req/sec Moonbeam Foundation <pre><code>wss://wss.api.moonbase.moonbeam.network</code></pre> 25 req/sec UnitedBloc <pre><code>wss://moonbase.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonbase.public.curie.radiumblock.co/ws</code></pre> 200 req/sec"},{"location":"builders/get-started/networks/moonbase/#relay-chain","title":"Relay Chain","text":"<p>To connect to the Moonbase Alpha relay chain, you can use the following WS Endpoint:</p> Provider RPC URL OpsLayer <pre><code>wss://relay.api.moonbase.moonbeam.network</code></pre>"},{"location":"builders/get-started/networks/moonbase/#quick-start","title":"Quick Start","text":"<p>For the Ethers.js library, define the provider by using <code>ethers.JsonRpcProvider(providerURL, {object})</code> and setting the provider URL to Moonbase Alpha:</p> <pre><code>const ethers = require('ethers'); // Load Ethers library\n\nconst providerURL = 'https://rpc.api.moonbase.moonbeam.network';\n// Define provider\nconst provider = new ethers.JsonRpcProvider(providerURL, {\n    chainId: 1287,\n    name: 'moonbase-alphanet'\n});\n</code></pre> <p>Any Ethereum wallet should be able to generate a valid address for Moonbeam (for example, MetaMask).</p>"},{"location":"builders/get-started/networks/moonbase/#chain-id","title":"Chain ID","text":"<p>Moonbase Alpha TestNet chain ID is: <code>1287</code>, which is <code>0x507</code> in hex.</p>"},{"location":"builders/get-started/networks/moonbase/#block-explorers","title":"Block Explorers","text":"<p>For Moonbase Alpha, you can use any of the following block explorers:</p> <ul> <li>Ethereum API (Etherscan Equivalent) \u2014 Moonscan</li> <li>Ethereum API JSON-RPC based \u2014 Moonbeam Basic Explorer</li> <li>Substrate API \u2014 Subscan or Polkadot.js Apps</li> </ul> <p>For more information on each of the available block explorers, please head to the Block Explorers section of the documentation.</p>"},{"location":"builders/get-started/networks/moonbase/#connect-metamask","title":"Connect MetaMask","text":"<p>If you already have MetaMask installed, you can easily connect MetaMask to the Moonbase Alpha TestNet:</p> Connect MetaMask <p>Note</p> <p>MetaMask will popup asking for permission to add Moonbase Alpha as a custom network. Once you approve permissions, MetaMask will switch your current network to Moonbase Alpha.</p> <p>If you do not have MetaMask installed, or would like to follow a tutorial to get started, please check out the Interacting with Moonbeam using MetaMask guide.</p>"},{"location":"builders/get-started/networks/moonbase/#configuration","title":"Configuration","text":"<p>Please note the following gas configuration parameters. These values are subject to change in future runtime upgrades.</p> Variable Value Minimum gas price 0.03125 Gwei Target block time 6 seconds Block gas limit 60,000,000 Transaction gas limit 52,000,000"},{"location":"builders/get-started/networks/moonbase/#get-tokens","title":"Get Tokens","text":"<p>To start building on Moonbase Alpha, you can get DEV tokens from the Moonbase Alpha Faucet. For specific amounts, you can always reach out directly to us via our community channels.</p> <p>To request DEV tokens from the faucet, you can enter your address on the Moonbase Alpha Faucet website. The faucet dispenses 1.1 DEV tokens every 24 hours.</p> <p></p> <p>Note</p> <p>Moonbase Alpha DEV tokens have no value. Please don't spam the faucet with unnecessary requests.</p>"},{"location":"builders/get-started/networks/moonbase/#Demo-DApps","title":"Demo DApps","text":"<p>There are a variety of DApps deployed to Moonbase Alpha enabling you to experiment with various apps and integrations. You can also acquire a variety of test tokens through the Moonbase ERC20 Minter or Moonbeam Uniswap DApps. For example, Moonbeam Uniswap can help you acquire cross-chain assets such as xcUNIT or xcKarura for testing XCM related functions. In the below table, you'll find each sample DApp, its associated URL, and GitHub repository.</p>"},{"location":"builders/get-started/networks/moonbase/#quick-links","title":"Quick Links","text":"DApp Description Repository Moonbase ERC-20 Minter ERC-20 Faucet https://github.com/papermoonio/moonbase-mintableERC20 Moonbeam Uniswap Uniswap V2 Fork https://github.com/papermoonio/moonbeam-uniswap <p>|        MoonLotto Lottery        |   TheGraph Demo    | Interface, Subgraph | | Moonbeam WalletConnect | WalletConnect Demo |            https://github.com/papermoonio/moonbeam-walletconnect-demo             | |              MoonGas              | Gas Price Tracker  |                    https://github.com/albertov19/moonbeam-gas-station                     |</p> <p>Note</p> <p>These DApps are intended for demonstration purposes only and may be incomplete or unsuitable for production deployments.</p>"},{"location":"builders/get-started/networks/moonbase/#moonbase-erc20-minter","title":"Moonbase ERC20 Minter","text":"<p>The Moonbase ERC-20 Minter enables you to mint a variety of ERC-20 test tokens corresponding to the 8 planets of the solar system, and Pluto. To mint tokens, first press Connect MetaMask in the upper right hand corner. Then scroll to the Mint Tokens section and the choose desired ERC-20 contract. Press Submit Tx and confirm the transaction in MetaMask. Each mint will grant you 100 tokens, and you can mint tokens for each contract once per hour.</p> <p></p>"},{"location":"builders/get-started/networks/moonbase/#moonbeam-uniswap","title":"Moonbeam Uniswap","text":"<p>Moonbeam Uniswap is a fork of Uniswap-V2 deployed to Moonbase Alpha. Notably, Moonbeam Uniswap allows developers to easily make a swap to acquire cross-chain assets such as xcKarura or xcUNIT for XCM testing purposes. To perform your first swap, take the following steps:</p> <ol> <li>Press Select a token</li> <li>Connect your MetaMask wallet and ensure you're on the Moonbase Alpha network</li> <li>Press Choose a List on the prompt</li> <li>Select Moon Menu</li> <li>Search for or select your desired asset from the list then continue with the swap</li> </ol> <p></p> <p>Note</p> <p>If you see only a partial list of assets under Moon Menu, your browser may have cached an older version of Moon Menu. Clearing the cache and re-adding Moon Menu will resolve this.</p>"},{"location":"builders/get-started/networks/moonbase/#moonlotto-lottery","title":"MoonLotto Lottery","text":"<p>MoonLotto is a simple lottery game on Moonbase Alpha derived from The Graph's Example Subgraph.  Purchasing a ticket costs 1 DEV and a winner is chosen each half hour if there are at least 10 participants. MoonLotto.sol holds the contract logic for the lottery. To participate, take the following steps:</p> <ol> <li>Connect your MetaMask wallet and ensure you're on the Moonbase Alpha network</li> <li>Enter the address of the recipient of lotto ticket or check I want to buy a ticket for my address</li> <li>Press Submit on MetaMask and confirm the transaction in MetaMask</li> </ol> <p></p>"},{"location":"builders/get-started/networks/moonbase/#moonbeam-walletconnect","title":"Moonbeam WalletConnect","text":"<p>Moonbeam WalletConnect shows how easy it is to integrate WalletConnect into your DApps and unlock support for a great variety of crypto wallets. Be sure to check out the demo app repository to see exactly how the WalletConnect integration works. To get started, you can take the following steps:</p> <ol> <li>Press Connect Wallet</li> <li>Scan the QR code using a wallet compatible with WalletConnect</li> </ol> <p></p>"},{"location":"builders/get-started/networks/moonbase/#moongas","title":"MoonGas","text":"<p>MoonGas is a convenient dashboard for viewing the minimum, maximum, and average gas price of transactions in the prior block across all Moonbeam networks. Note, these statistics can fluctuate widely by block and occasionally include outlier values. You can check out the repository for MoonGas.</p> <p>You'll notice that the minimum gas price for Moonbeam is 31.25 Gwei, while the minimum for Moonriver is 0.3125 Gwei and Moonbase Alpha is 0.03125 Gwei. This difference stems from the 100 to 1 re-denomination of GLMR and thus the 31.25 Gwei minimum on Moonbeam corresponds to a 0.3125 Gwei minimum on Moonriver and a 0.03125 Gwei on Moonbase.</p> <p></p>"},{"location":"builders/get-started/networks/moonbeam-dev/","title":"Getting Started with a Local Moonbeam Development Node","text":""},{"location":"builders/get-started/networks/moonbeam-dev/#introduction","title":"Introduction","text":"<p>A Moonbeam development node is your own personal development environment for building and testing applications on Moonbeam. For Ethereum developers, it is comparable to the Hardhat Network. It enables you to get started quickly and easily without the overhead of a relay chain. You can spin up your node with the <code>--sealing</code> option to author blocks instantly, manually, or at a custom interval after transactions are received. By default, a block will be created when a transaction is received, which is similar to the default behavior of Hardhat Network's instamine feature.</p> <p>If you follow this guide to the end, you will have a Moonbeam development node running in your local environment with 10 prefunded accounts.</p> <p>Note</p> <p>This tutorial was created using the v0.49.2 tag of Moonbase Alpha. The Moonbeam platform and the Frontier components it relies on for Substrate-based Ethereum compatibility are still under very active development. The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#spin-up-a-node","title":"Spin Up a Moonbeam Development Node","text":"<p>There are two ways to get started running a Moonbeam node. You can use Docker to run a pre-built binary or you can compile the binary locally and set up a development node yourself. Using Docker is a quick and convenient way to get started, as you won't have to install Substrate and all the dependencies, and you can skip the node-building process as well. It does require you to install Docker. On the other hand, if you decide you want to go through the process of building your development node, it could take roughly 30 minutes or longer to complete, depending on your hardware.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#getting-started-with-docker","title":"Spin Up a Node with Docker","text":"<p>Using Docker enables you to spin up a node in a matter of seconds. Once you have Docker installed, you can take the following steps to spin up your node:</p> <ol> <li> <p>Execute the following command to download the latest Moonbeam image:</p> <pre><code>docker pull moonbeamfoundation/moonbeam:v0.49.2\n</code></pre> <p>The tail end of the console log should look like this:</p> <p> docker pull moonbeamfoundation/moonbeam:v0.49.2 v0.49.2: Pulling from moonbeamfoundation/moonbeam      b0a0cf830b12: Pull complete      fbff687640dd: Pull complete      58ea427410e2: Pull complete      811ba55e6e61: Pull complete      4316d5f1b914: Pull complete      128693ce218e: Pull complete      a3ac90b88463: Pull complete      Digest: sha256:86421aca2381265cd2e5283cb98705e24be0bc92a73937363f79d9d6e0d62088      Status: Downloaded newer image for moonbeamfoundation/moonbeam:v0.49.2      docker.io/moonbeamfoundation/moonbeam:v0.49.2    </p> </li> <li> <p>Spin up a Moonbeam development node by running the following Docker command, which will launch the node in instant seal mode for local testing so that blocks are authored instantly as transactions are received:</p> UbuntuMacOSWindows <pre><code>docker run --rm --name moonbeam_development --network host \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--dev --rpc-external\n</code></pre> <pre><code>docker run --rm --name moonbeam_development -p 9944:9944 \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--dev --rpc-external\n</code></pre> <pre><code>docker run --rm --name moonbeam_development -p 9944:9944 ^\nmoonbeamfoundation/moonbeam:v0.49.2 ^\n--dev --rpc-external\n</code></pre> <p>For Apple Silicon users</p> <p>If the Docker commands fail or behave unexpectedly on Apple Silicon, enable Use Rosetta for x86_64/amd64 emulation on Apple Silicon in Docker Desktop settings and use the <code>amd64</code> platform for both pull and run commands:</p> <pre><code>docker pull --platform=linux/amd64 moonbeamfoundation/moonbeam:v0.49.2\n</code></pre> <pre><code>docker run --rm --platform=linux/amd64 --name moonbeam_development -p 9944:9944 \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--dev --rpc-external\n</code></pre> <p>If performance is still insufficient, consider spinning up a node with a binary file.</p> </li> </ol> <p>If successful, you should see an output showing an idle state waiting for blocks to be authored:</p> docker run --rm --name moonbeam_development --network host \\      moonbeamfoundation/moonbeam:v0.49.2 \\      --dev --rpc-external    CLI parameter `--execution` has no effect anymore and will be removed in the future!      2025-07-10 09:04:26 Moonbeam Parachain Collator      2025-07-10 09:04:26 \u270c\ufe0f  version 0.49.2      2025-07-10 09:04:26 \u2764\ufe0f  by PureStake, 2019-2025      2025-07-10 09:04:26 \ud83d\udccb Chain specification: Moonbase Development Testnet      2025-07-10 09:04:26 \ud83c\udff7  Node name: black-and-white-sticks-9174      2025-07-10 09:04:26 \ud83d\udc64 Role: AUTHORITY      2025-07-10 09:04:26 \ud83d\udcbe Database: RocksDb at /tmp/substrateO3YeRz/chains/moonbase_dev/db/full      2025-07-10 09:04:26 \ud83d\udd28 Initializing Genesis block/state (state: 0xf7c4\u20265c0f, header-hash: 0x42bd\u20263b5b)      2025-07-10 09:04:26 Using default protocol ID \"sup\" because none is configured in the chain specs      2025-07-10 09:04:26 \ud83c\udff7  Local node identity is: 12D3KooWLcpczme2JeBEfLqmjqkzYVKTGKhhGmwSzHjRXGBVhDX7      2025-07-10 09:04:26 \ud83d\udcbb Operating system: linux      2025-07-10 09:04:26 \ud83d\udcbb CPU architecture: x86_64      2025-07-10 09:04:26 \ud83d\udcbb Target environment: gnu      2025-07-10 09:04:26 \ud83d\udcbb CPU: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz      2025-07-10 09:04:26 \ud83d\udcbb CPU cores: 12      2025-07-10 09:04:26 \ud83d\udcbb Memory: 7946MB      2025-07-10 09:04:26 \ud83d\udcbb Kernel: 6.4.16-linuxkit      2025-07-10 09:04:26 \ud83d\udcbb Linux distribution: Debian GNU/Linux 12 (bookworm)      2025-07-10 09:04:26 \ud83d\udcbb Virtual machine: yes      2025-07-10 09:04:26 \ud83d\udce6 Highest known block at #0      2025-07-10 09:04:26 Running JSON-RPC server: addr=0.0.0.0:9944, allowed origins=[\"*\"]      2025-07-10 09:04:26 \ud83c\udfc1 CPU score: 1.14 GiBs      2025-07-10 09:04:26 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615      2025-07-10 09:04:26 \ud83c\udfc1 Memory score: 10.41 GiBs      2025-07-10 09:04:26 \ud83c\udfc1 Disk score (seq. writes): 987.96 MiBs      2025-07-10 09:04:26 \ud83c\udfc1 Disk score (rand. writes): 363.65 MiBs      2025-07-10 09:04:26 Development Service Ready      2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0xa083\u2026f354), finalized #0 (0xa083\u2026f354), \u2b07 0 \u2b06 0      2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0xa083\u2026f354), finalized #0 (0xa083\u2026f354), \u2b07 0 \u2b06 0    <p>For more information on some of the flags and options used in the example, check out Flags and Options. If you want to see a complete list of all of the flags, options, and subcommands, open the help menu by running:</p> <pre><code>docker run --rm --name moonbeam_development \\\nmoonbeamfoundation/moonbeam \\\n--help\n</code></pre> <p>To continue with the tutorial, the next section is not necessary, as you've already spun up a node with Docker. You can skip ahead to the Configure your Moonbeam Development Node section.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#getting-started-with-the-binary-file","title":"Spin Up a Node with a Binary File","text":"<p>As an alternative to using Docker, you can spin up a node using the Moonbeam binary. This method is more time-consuming. Depending on your hardware, the process could take around 30 minutes to complete.</p> <p>Note</p> <p>If you know what you are doing, you can directly download the precompiled binaries attached to each release on the Moonbeam release page. These will not work in all systems. For example, the binaries only work with x86-64 Linux with specific versions of dependencies. The safest way to ensure compatibility is to compile the binary on the system where it will be run.</p> <p>To build the binary file, you can take the following steps:</p> <ol> <li> <p>Clone a specific tag of the Moonbeam repo, which you can find on the Moonbeam GitHub repository:</p> <pre><code>git clone -b v0.49.2 https://github.com/moonbeam-foundation/moonbeam\ncd moonbeam\n</code></pre> <p>Note</p> <p>Spaces in the installation file path will cause a compilation error.</p> </li> <li> <p>Check if Rust is installed. If Rust is installed, skip the next two steps. Otherwise, install Rust and its prerequisites via Rust's recommended method by executing:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> </li> <li> <p>Update your PATH environment variable by running:</p> <pre><code>source $HOME/.cargo/env\n</code></pre> </li> <li> <p>Build the development node by running:</p> <p>Note</p> <p>If you are using Ubuntu 20.04 or 22.04, then you will need to make sure these additional dependencies have been installed before building the binary:</p> <pre><code>apt install clang protobuf-compiler libprotobuf-dev pkg-config libssl-dev -y \n</code></pre> <p>For MacOS users, these dependencies can be installed via Homebrew:</p> <pre><code>brew install llvm\nbrew install protobuf\n</code></pre> <pre><code>cargo build --release\n</code></pre> <p>Here is what the tail end of the build output should look like:</p> <p> Compiling try-runtime-cli v0.9.0 (https://github.com/paritytech/substrate?branch=rococo-v1#401c24e8)      Compiling frame-benchmarking-cli v3.0.0 (https://github.com/paritytech/substrate?branch=rococo-v1#401c24e8)      Compiling cumulus-client-cli v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Compiling moonbeam-rpc-txpool v0.6.0 (/home/purestake/moonbeam/client/rpc/txpool)      Compiling moonbeam-rpc-debug v0.1.0 (/home/purestake/moonbeam/client/rpc/debug)      Compiling moonbeam-rpc-trace v0.6.0 (/home/purestake/moonbeam/client/rpc/trace)      Compiling cumulus-client-network v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Compiling cumulus-client-consensus-relay-chain v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Compiling polkadot-test-service v0.8.29 (https://github.com/paritytech/polkadot?branch=rococo-v1#b64741e6)      Compiling cumulus-client-collator v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Compiling cumulus-client-service v0.1.0 (https://github.com/paritytech/cumulus?branch=rococo-v1#9d89ed65)      Finished release [optimized] target(s) in 31m 17s    </p> </li> </ol> <p>Note</p> <p>The initial build will take a while. Depending on your hardware, you should expect approximately 30 minutes for the build process to finish.</p> <p>Then, you will want to run the node in development mode using the following command:</p> <pre><code>./target/release/moonbeam --dev\n</code></pre> <p>Note</p> <p>For people not familiar with Substrate, the <code>--dev</code> flag is a way to run a Substrate-based node in a single-node developer configuration for testing purposes. When you run your node with the <code>--dev</code> flag, your node is started in a fresh state, and its state does not persist.</p> <p>You should see an output that looks like the following, showing an idle state waiting for blocks to be produced:</p> ./target/release/moonbeam --dev  2025-07-10 09:04:26 Moonbeam Parachain Collator      2025-07-10 09:04:26 \u270c\ufe0f  version 0.49.2      2025-07-10 09:04:26 \u2764\ufe0f  by PureStake, 2019-2025      2025-07-10 09:04:26 \ud83d\udccb Chain specification: Moonbase Development Testnet      2025-07-10 09:04:26 \ud83c\udff7  Node name: black-and-white-sticks-9174      2025-07-10 09:04:26 \ud83d\udc64 Role: AUTHORITY      2025-07-10 09:04:26 \ud83d\udcbe Database: RocksDb at /tmp/substrateO3YeRz/chains/moonbase_dev/db/full      2025-07-10 09:04:26 \ud83d\udd28 Initializing Genesis block/state (state: 0x7c34\u202699c5, header-hash: 0xa083\u2026f354)      2025-07-10 09:04:26 Using default protocol ID \"sup\" because none is configured in the chain specs      2025-07-10 09:04:26 \ud83c\udff7  Local node identity is: 12D3KooWLcpczme2JeBEfLqmjqkzYVKTGKhhGmwSzHjRXGBVhDX7      2025-07-10 09:04:26 \ud83d\udcbb Operating system: linux      2025-07-10 09:04:26 \ud83d\udcbb CPU architecture: x86_64      2025-07-10 09:04:26 \ud83d\udcbb Target environment: gnu      2025-07-10 09:04:26 \ud83d\udcbb CPU: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz      2025-07-10 09:04:26 \ud83d\udcbb CPU cores: 12      2025-07-10 09:04:26 \ud83d\udcbb Memory: 7946MB      2025-07-10 09:04:26 \ud83d\udcbb Kernel: 6.4.16-linuxkit      2025-07-10 09:04:26 \ud83d\udcbb Linux distribution: Debian GNU/Linux 12 (bookworm)      2025-07-10 09:04:26 \ud83d\udcbb Virtual machine: yes      2025-07-10 09:04:26 \ud83d\udce6 Highest known block at #0      2025-07-10 09:04:26 Running JSON-RPC server: addr=0.0.0.0:9944, allowed origins=[\"*\"]      2025-07-10 09:04:26 \ud83c\udfc1 CPU score: 1.14 GiBs      2025-07-10 09:04:26 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615      2025-07-10 09:04:26 \ud83c\udfc1 Memory score: 10.41 GiBs      2025-07-10 09:04:26 \ud83c\udfc1 Disk score (seq. writes): 987.96 MiBs      2025-07-10 09:04:26 \ud83c\udfc1 Disk score (rand. writes): 363.65 MiBs      2025-07-10 09:04:26 Development Service Ready      2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0xa083\u2026f354), finalized #0 (0xa083\u2026f354), \u2b07 0 \u2b06 0      2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0xa083\u2026f354), finalized #0 (0xa083\u2026f354), \u2b07 0 \u2b06 0    <p>For more information on some of the flags and options used in the example, check out the Flags and Options. If you want to see a complete list of all of the flags, options, and subcommands, open the help menu by running:</p> <pre><code>./target/release/moonbeam --help\n</code></pre>"},{"location":"builders/get-started/networks/moonbeam-dev/#configure-moonbeam-dev-node","title":"Configure Your Moonbeam Development Node","text":"<p>Now that you know how to get a standard Moonbeam development node up and running, you may be wondering how you can configure it. The following sections will cover some common configurations you can use when you spin up your node.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#node-flags","title":"Common Flags to Configure Your Node","text":"<p>Flags do not take an argument. To use a flag, add it to the end of a command. For example:</p> <pre><code>./target/release/moonbeam --dev\n</code></pre> <ul> <li><code>--dev</code> - specifies the development chain</li> <li><code>--tmp</code> - runs a temporary node in which all of the configuration will be deleted at the end of the process</li> <li><code>--rpc-external</code> - listen to all RPC and WebSocket interfaces</li> </ul>"},{"location":"builders/get-started/networks/moonbeam-dev/#node-options","title":"Common Options to Configure Your Node","text":"<p>Options accept an argument to the right of the option. For example:</p> <pre><code>./target/release/moonbeam --dev --sealing 6000\n</code></pre> <ul> <li><code>-l &lt;log pattern&gt;</code> or <code>--log &lt;log pattern&gt;</code> - sets a custom logging filter. The syntax for the log pattern is <code>&lt;target&gt;=&lt;level&gt;</code>. For example, to print all of the JSON-RPC logs, the command would look like this: <code>-l json=trace</code></li> <li><code>--sealing &lt;interval&gt;</code> - when blocks should be sealed in the dev service. Accepted arguments for interval: <code>instant</code>, <code>manual</code>, or a number representing the timer interval in milliseconds (for example, <code>6000</code> will have the node produce blocks every 6 seconds). The default is `instant``. Please refer to the Configure Block Production section below for more information</li> <li><code>--rpc-port &lt;port&gt;</code> - sets the unified port for HTTP and WS connections. Accepts a port as the argument. Default is 9944</li> <li><code>--ws-port &lt;port&gt;</code> - deprecated as of client v0.33.0, use <code>--rpc-port</code> for HTTP and WS connections instead - sets the WebSockets RPC server TCP port. As of client v0.30.0, it sets the unified port for both HTTP and WS connections. Accepts a port as the argument</li> <li><code>--rpc-max-connections &lt;connections&gt;</code> - specifies the combined HTTP and WS connection limit. The default is 100 connections</li> <li><code>--ws-max-connections &lt;connections&gt;</code> - deprecated as of client v0.33.0, use <code>--rpc-max-connections</code> to limit the HTTP and WS connections instead - this flag adjusts the combined HTTP and WS connection limit. The default is 100 connections</li> <li><code>--rpc-cors &lt;origins&gt;</code> - specifies the browser origins allowed to access the HTTP and WS RPC servers. The origins can be a comma-separated list of the origins to allow access, or you can also specify <code>null</code>. When running a development node, the default is to allow all origins</li> </ul> <p>For a complete list of flags and options, spin up your Moonbeam development node with <code>--help</code> added to the end of the command.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#configure-block-production","title":"Configure Block Production","text":"<p>By default, your Moonbeam development node is spun up in instant seal mode, which instantly authors blocks as transactions are received. However, you can specify when blocks should be authored or sealed by using the <code>--sealing</code> option.</p> <p>The <code>--sealing</code> flag accepts any of the following arguments:</p> <ul> <li><code>instant</code> - as we already covered, this is the default option in which blocks are authored as soon as a transaction is received</li> <li><code>manual</code> - allows you to produce blocks manually. If a transaction is received, a block will not be produced until you manually create one</li> <li>an interval in milliseconds - authors a block on a specific time interval. For example, if you set it to <code>6000</code>, you will have the node produce blocks every 6 seconds</li> </ul> <p>The flag should be appended to the start-up command in the following format:</p> <pre><code>--sealing &lt;interval&gt;\n</code></pre> <p>If you choose <code>manual</code>, you'll need to manually create the blocks yourself, which can be done with the <code>engine_createBlock</code> JSON-RPC method:</p> <pre><code>engine_createBlock(createEmpty: *bool*, finalize: *bool*, parentHash?: *BlockHash*)\n</code></pre> <p>For example, you can use the following snippet to manually create a block using Ethers.js, an Ethereum library that makes it easy to interact with JSON-RPC methods:</p> <pre><code>import { ethers } from 'ethers';\n\nconst produceBlock = async () =&gt; {\n  // Connect to the Ethereum node (if applicable, replace the URL with your node's address)\n  const provider = new ethers.JsonRpcProvider(\n    'http://127.0.0.1:9944'\n  );\n\n  // Set the custom JSON-RPC method and parameters\n  const method = 'engine_createBlock';\n  const params = [true, true, null];\n\n  try {\n    // Send the custom JSON-RPC call\n    const result = await provider.send(method, params);\n  } catch (error) {\n    // Handle any errors that may occur\n    console.error('Error:', error.message);\n  }\n};\n\nproduceBlock();\n</code></pre> <p>Note</p> <p>If you're unfamiliar with Ethers, please refer to the Ethers.js documentation page to learn more.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#pre-funded-development-accounts","title":"Prefunded Development Accounts","text":"<p>Moonbeam has a unified accounts system, which enables users to have an Ethereum-styled H160 account that can interact with the Substrate API and the Ethereum API. As a result, you can interact with your account through Polkadot.js Apps or MetaMask (or any other EVM wallet). In addition, you can also use other development tools, such as Remix and Hardhat.</p> <p>Your Moonbeam development node comes with ten prefunded Ethereum-styled accounts for development. The addresses are derived from Substrate's canonical development mnemonic:</p> <pre><code>bottom drive obey lake curtain smoke basket hold race lonely fit walk\n</code></pre> Development account addresses and private keys <ul> <li> <p>Alith:</p> <ul> <li>Public Address: <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>Private Key: <code>0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133</code></li> </ul> </li> <li> <p>Baltathar:</p> <ul> <li>Public Address: <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>Private Key: <code>0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b</code></li> </ul> </li> <li> <p>Charleth:</p> <ul> <li>Public Address: <code>0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</code></li> <li>Private Key: <code>0x0b6e18cafb6ed99687ec547bd28139cafdd2bffe70e6b688025de6b445aa5c5b</code></li> </ul> </li> <li> <p>Dorothy:</p> <ul> <li>Public Address: <code>0x773539d4Ac0e786233D90A233654ccEE26a613D9</code></li> <li>Private Key: <code>0x39539ab1876910bbf3a223d84a29e28f1cb4e2e456503e7e91ed39b2e7223d68</code></li> </ul> </li> <li> <p>Ethan:</p> <ul> <li>Public Address: <code>0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB</code></li> <li>Private Key: <code>0x7dce9bc8babb68fec1409be38c8e1a52650206a7ed90ff956ae8a6d15eeaaef4</code></li> </ul> </li> <li> <p>Faith:</p> <ul> <li>Public Address: <code>0xC0F0f4ab324C46e55D02D0033343B4Be8A55532d</code></li> <li>Private Key: <code>0xb9d2ea9a615f3165812e8d44de0d24da9bbd164b65c4f0573e1ce2c8dbd9c8df</code></li> </ul> </li> <li> <p>Goliath:</p> <ul> <li>Public Address: <code>0x7BF369283338E12C90514468aa3868A551AB2929</code></li> <li>Private Key: <code>0x96b8a38e12e1a31dee1eab2fffdf9d9990045f5b37e44d8cc27766ef294acf18</code></li> </ul> </li> <li> <p>Heath: </p> <ul> <li>Public Address: <code>0x931f3600a299fd9B24cEfB3BfF79388D19804BeA</code></li> <li>Private Key: <code>0x0d6dcaaef49272a5411896be8ad16c01c35d6f8c18873387b71fbc734759b0ab</code></li> </ul> </li> <li> <p>Ida: </p> <ul> <li>Public Address: <code>0xC41C5F1123ECCd5ce233578B2e7ebd5693869d73</code></li> <li>Private Key: <code>0x4c42532034540267bf568198ccec4cb822a025da542861fcb146a5fab6433ff8</code></li> </ul> </li> <li> <p>Judith: </p> <ul> <li>Public Address: <code>0x2898FE7a42Be376C8BC7AF536A940F7Fd5aDd423</code></li> <li>Private Key: <code>0x94c49300a58d576011096bcb006aa06f5a91b34b4383891e8029c21dc39fbb8b</code></li> </ul> </li> </ul> <p>Also included with the development node is an additional prefunded account used for testing purposes:</p> <ul> <li>Gerald:<ul> <li>Public Address: <code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code></li> <li>Private Key: <code>0x99b3c12287537e38c90a9219d4cb074a89a16e9cdb20bf85728ebd97c343e342</code></li> </ul> </li> </ul> <p>You can connect any of these accounts to MetaMask, Talisman, Polkadot.js Apps, etc., using their private keys.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#access-your-development-node","title":"Development Node Endpoints","text":"<p>You can access your Moonbeam development node using the following RPC and WSS endpoints:</p> HTTPWSS <pre><code>http://127.0.0.1:9944\n</code></pre> <pre><code>ws://127.0.0.1:9944\n</code></pre>"},{"location":"builders/get-started/networks/moonbeam-dev/#block-explorers","title":"Block Explorers","text":"<p>For a Moonbeam development node, you can use any of the following block explorers:</p> <ul> <li>Substrate API \u2014 Polkadot.js Apps on WS port <code>9944</code></li> <li>Ethereum API JSON-RPC-based \u2014 Moonbeam Basic Explorer on HTTP port <code>9944</code></li> </ul>"},{"location":"builders/get-started/networks/moonbeam-dev/#debug-trace-txpool-apis","title":"Debug, Trace, and TxPool APIs","text":"<p>You can also gain access to some non-standard RPC methods by running a tracing node, which allows developers to inspect and debug transactions during runtime. Tracing nodes use a different Docker image than a standard Moonbeam development node.</p> <p>To learn how to run a Moonbeam development tracing node, check out the Run a Tracing Node guide, and be sure to switch to the Moonbeam Development Node tab throughout the instructions. Then, to access the non-standard RPC methods with your tracing node, check out the Debug &amp; Trace guide.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#purging-your-node","title":"Purge a Development Node","text":"<p>If you want to remove data associated with your node, you can purge it. The instructions for purging a node are different depending on how you initially spun up your node.</p>"},{"location":"builders/get-started/networks/moonbeam-dev/#purge-docker-node","title":"Purge a Node Spun Up with Docker","text":"<p>If you spun up your node using Docker along with the <code>-v</code> flag to specify a mounted directory for your container, you will need to purge that directory. To do so, you can run the following command:</p> <pre><code>sudo rm -rf /var/lib/alphanet-data/*\n</code></pre> <p>If you followed the instructions in this guide and did not use the <code>-v</code> flag, you can stop and remove the Docker container. The associated data will be removed along with it. To do so, you can run the following command:</p> <pre><code>sudo docker stop `CONTAINER_ID` &amp;&amp; docker rm `CONTAINER_ID`\n</code></pre>"},{"location":"builders/get-started/networks/moonbeam-dev/#purge-binary-node","title":"Purge a Node Spun up with a Binary File","text":"<p>When running a node via the binary file, data is stored in a local directory, typically located in <code>~/.local/shared/moonbeam/chains/development/db</code>. If you want to start a fresh instance of the node, you can either delete the content of the folder or run the following command inside the <code>moonbeam</code> folder:</p> <pre><code>./target/release/moonbeam purge-chain --dev -y\n</code></pre> <p>This will remove the data folder. Note that all chain data is now lost. To learn more about all of the available <code>purge-chain</code> commands, you can check out the Purging Binary Data section of our documentation.</p>"},{"location":"builders/get-started/networks/moonbeam/","title":"Get Started with Moonbeam","text":""},{"location":"builders/get-started/networks/moonbeam/#network-endpoints","title":"Network Endpoints","text":"<p>Moonbeam has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.</p> <p>If you're looking for your own endpoints suitable for production use, you can check out the Endpoint Providers section of our documentation. Otherwise, to get started quickly you can use one of the following public HTTPS or WSS endpoints:</p> HTTPSWSS Provider RPC URL Limits OnFinality <pre><code>https://moonbeam.api.onfinality.io/public</code></pre> 40 req/sec UnitedBloc <pre><code>https://moonbeam.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonbeam.public.curie.radiumblock.co/http</code></pre> 200 req/sec 1RPC <pre><code>https://1rpc.io/glmr</code></pre> 10k req/day Provider RPC URL Limits OnFinality <pre><code>wss://moonbeam.api.onfinality.io/public-ws</code></pre> 40 req/sec UnitedBloc <pre><code>wss://moonbeam.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonbeam.public.curie.radiumblock.co/ws</code></pre> 200 req/sec 1RPC <pre><code>wss://1rpc.io/glmr</code></pre> 10k req/day"},{"location":"builders/get-started/networks/moonbeam/#quick-start","title":"Quick Start","text":"<p>Before getting started, make sure you've retrieved your own endpoint and API key from one of the custom Endpoint Providers. For the Ethers.js library, define the provider by using <code>ethers.JsonRpcProvider(providerURL, {object})</code> and setting the provider URL to Moonbeam:</p> <pre><code>const ethers = require('ethers'); // Load Ethers library\n\nconst providerURL = 'INSERT_RPC_API_ENDPOINT'; // Insert your RPC URL here\n\n// Define provider\nconst provider = new ethers.JsonRpcProvider(providerURL, {\n    chainId: 1284,\n    name: 'moonbeam'\n});\n</code></pre> <p>Any Ethereum wallet should be able to generate a valid address for Moonbeam (for example, MetaMask).</p>"},{"location":"builders/get-started/networks/moonbeam/#chain-id","title":"Chain ID","text":"<p>Moonbeam chain ID is: <code>1284</code>, or <code>0x504</code> in hex.</p>"},{"location":"builders/get-started/networks/moonbeam/#block-explorers","title":"Block Explorers","text":"<p>For Moonbeam, you can use any of the following block explorers:</p> <ul> <li>Ethereum API (Etherscan Equivalent) \u2014 Moonscan</li> <li>Ethereum API JSON-RPC based \u2014 Moonbeam Basic Explorer</li> <li>Substrate API \u2014 Subscan or Polkadot.js Apps</li> </ul> <p>For more information on each of the available block explorers, please head to the Block Explorers section of the documentation.</p>"},{"location":"builders/get-started/networks/moonbeam/#connect-metamask","title":"Connect MetaMask","text":"<p>If you already have MetaMask installed, you can easily connect MetaMask to Moonbeam:</p> Connect MetaMask <p>Note</p> <p>MetaMask will popup asking for permission to add Moonbeam as a custom network. Once you approve permissions, MetaMask will switch your current network to Moonbeam.</p> <p>If you do not have MetaMask installed, or would like to follow a tutorial to get started, please check out the Interacting with Moonbeam using MetaMask guide.</p>"},{"location":"builders/get-started/networks/moonbeam/#configuration","title":"Configuration","text":"<p>Please note the following gas configuration parameters. These values are subject to change in future runtime upgrades.</p> Variable Value Minimum gas price 31.25 Gwei Target block time 6 seconds Block gas limit 60,000,000 Transaction gas limit 52,000,000"},{"location":"builders/get-started/networks/moonriver/","title":"Get Started with Moonriver","text":""},{"location":"builders/get-started/networks/moonriver/#network-endpoints","title":"Network Endpoints","text":"<p>Moonriver has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.</p> <p>If you're looking for your own endpoints suitable for production use, you can check out the Endpoint Providers section of our documentation. Otherwise, to get started quickly you can use one of the following public HTTPS or WSS endpoints:</p> HTTPSWSS Provider RPC URL Limits OnFinality <pre><code>https://moonriver.api.onfinality.io/public</code></pre> 40 req/sec UnitedBloc <pre><code>https://moonriver.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>https://moonriver.public.curie.radiumblock.co/http</code></pre> 200 req/sec Provider RPC URL Limits OnFinality <pre><code>wss://moonriver.api.onfinality.io/public-ws</code></pre> 40 req/sec UnitedBloc <pre><code>wss://moonriver.unitedbloc.com</code></pre> 32 req/sec RadiumBlock <pre><code>wss://moonriver.public.curie.radiumblock.co/ws</code></pre> 200 req/sec"},{"location":"builders/get-started/networks/moonriver/#quick-start","title":"Quick Start","text":"<p>Before getting started, make sure you've retrieved your own endpoint and API key from one of the custom Endpoint Providers. For the Ethers.js library, define the provider by using <code>ethers.JsonRpcProvider(providerURL, {object})</code> and setting the provider URL to Moonriver:</p> <pre><code>const ethers = require('ethers'); // Load Ethers library\n\nconst providerURL = 'INSERT_RPC_API_ENDPOINT'; // Insert your RPC URL here\n\n// Define provider\nconst provider = new ethers.JsonRpcProvider(providerURL, {\n    chainId: 1285,\n    name: 'moonriver'\n});\n</code></pre> <p>Any Ethereum wallet should be able to generate a valid address for Moonbeam (for example, MetaMask).</p>"},{"location":"builders/get-started/networks/moonriver/#chain-id","title":"Chain ID","text":"<p>Moonriver chain ID is: <code>1285</code>, or <code>0x505</code> in hex.</p>"},{"location":"builders/get-started/networks/moonriver/#block-explorers","title":"Block Explorers","text":"<p>For Moonriver, you can use any of the following block explorers:</p> <ul> <li>Ethereum API (Etherscan Equivalent) \u2014 Moonscan</li> <li>Ethereum API JSON-RPC based \u2014 Moonbeam Basic Explorer</li> <li>Substrate API \u2014 Subscan or Polkadot.js Apps</li> </ul> <p>For more information on each of the available block explorers, please head to the Block Explorers section of the documentation.</p>"},{"location":"builders/get-started/networks/moonriver/#connect-metamask","title":"Connect MetaMask","text":"<p>If you already have MetaMask installed, you can easily connect MetaMask to Moonriver:</p> Connect MetaMask <p>Note</p> <p>MetaMask will popup asking for permission to add Moonriver as a custom network. Once you approve permissions, MetaMask will switch your current network to Moonriver.</p> <p>If you do not have MetaMask installed, or would like to follow a tutorial to get started, please check out the Interacting with Moonbeam using MetaMask guide.</p>"},{"location":"builders/get-started/networks/moonriver/#configuration","title":"Configuration","text":"<p>Please note the following gas configuration parameters. These values are subject to change in future runtime upgrades.</p> Variable Value Minimum gas price 0.3125 Gwei Target block time 6 seconds Block gas limit 60,000,000 Transaction gas limit 52,000,000"},{"location":"builders/integrations/indexers/covalent/","title":"Getting Started with the GoldRush API","text":""},{"location":"builders/integrations/indexers/covalent/#introduction","title":"Introduction","text":"<p>GoldRush, formerly known as Covalent, is a hosted blockchain data solution providing access to historical and current on-chain data for 100+ supported blockchains, including Moonbeam, Moonriver, and Moonbase Alpha. GoldRush maintains a full archival copy of every supported blockchain, meaning every balance, transaction, log event, and NFT asset data is available from the genesis block. This data is available via:</p> <ul> <li>Unified API - incorporate blockchain data into your app with a familiar REST API</li> </ul> <p>This guide will cover all of the details needed to get started with the Foundational API and how to access the API endpoints for Moonbeam using curl commands and JavaScript and Python snippets.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/indexers/covalent/#unified-api-overview","title":"Unified API Overview","text":"<p>GoldRush's Unified API is a powerful but easy-to-use REST API that offers visibility to assets across all blockchain networks. It features a consistent request and response object format across networks. For example, a user can fetch all the token balances for a wallet address across any supported blockchain by changing the unique blockchain name or ID path parameter in the request URL. GoldRush's Unified API can offer more data flexibility than JSON-RPC interfaces, which are typically limited to queries on a specific block. It also allows queries on multiple objects and batch exports of data.</p>"},{"location":"builders/integrations/indexers/covalent/#querying-the-unified-api","title":"Querying the Unified API","text":"<p>It's easy to get started querying the Unified API after you've secured a GoldRush API Key. Make sure you have your API Key which begins with <code>cqt_</code> or <code>ckey_</code>. </p> <p>You can interact with any of the API methods in the web interface of the GoldRush docs. To try out the token balances API, head to the token balances docs and take the following steps:</p> <ol> <li>Paste in your API key</li> <li>Enter the desired <code>chainName</code>, such as <code>moonbeam-moonbase-alpha</code> for Moonbase Alpha. Reference the Quick Start section if you're unsure what the chainName should be for your desired network</li> <li>Enter the address you wish to check the token balances of</li> <li>Press Send</li> </ol> <p></p>"},{"location":"builders/integrations/indexers/covalent/#quick-start","title":"Quick Start","text":"<p>If you're familiar with GoldRush and ready to dive in, you need the chainID and network name to get started.</p> MoonbeamMoonriverMoonbase Alpha Parameter Value <code>chainName</code> <code>moonbeam-mainnet</code> <code>chainID</code> <code>1284</code> Parameter Value <code>chainName</code> <code>moonbeam-moonriver</code> <code>chainID</code> <code>1285</code> Parameter Value <code>chainName</code> <code>moonbeam-moonbase-alpha</code> <code>chainID</code> <code>1287</code>"},{"location":"builders/integrations/indexers/covalent/#fundamentals-of-the-unified-api","title":"Fundamentals of the Unified API","text":"<ul> <li>The GoldRush API is RESTful and it is designed around the main resources that are available through the web interface</li> <li>The current version of the API is version 1</li> <li>The default return format for all endpoints is JSON</li> <li>All requests require authentication; you will need an API Key to use the GoldRush API</li> <li>The cost of an API call is denominated in credits and varies depending on the particular call. Upon creating an API key, you're given a substantial amount of free credits to get started (25,000 at the time of writing). You can track your usage of these free credits on the GoldRush Dashboard</li> <li>Note that free development API keys are rate limited to <code>4</code> requests per second. Subscribers to a professional plan can make up to <code>50</code> requests per second.</li> <li>The root URL of the API is: <code>https://api.covalenthq.com/v1/</code></li> <li>All requests are done over HTTPS (calls over plain HTTP will fail)</li> <li>The refresh rate of the APIs is real-time: 30s or two blocks, and batch 30m or 40 blocks</li> </ul>"},{"location":"builders/integrations/indexers/covalent/#types-of-endpoints","title":"Types of Endpoints","text":"<p>The GoldRush API has three classes of endpoints:</p> <ul> <li>Class A \u2014 endpoints that return enriched blockchain data applicable to all blockchain networks, eg: balances, transactions, log events, etc</li> <li>Class B \u2014 endpoints that are for a specific protocol on a blockchain, e.g. Uniswap is Ethereum-only and is not applicable to other blockchain networks</li> <li>Class C \u2014 endpoints that are community-built and maintained but powered by GoldRush infrastructure</li> </ul>"},{"location":"builders/integrations/indexers/covalent/#sample-supported-endpoints","title":"Sample Supported Endpoints","text":"<p>For a full list of supported endpoints, refer to the GoldRush API reference. A subset of the supported endpoints include:</p> <ul> <li>Token balances- get all token balances (native, ERC-20, ERC-721, ERC-1155) with current market prices for an address</li> <li>Native token balances- retrieve native token balance for an address</li> <li>Get a transaction- fetch and render a single transaction with decoded log events</li> <li>Transaction summary- retrieve key wallet activity data for an address</li> <li>Earliest transactions- get the earliest transactions for an address</li> <li>Recent transactions- fetch the most recent transactions for an address</li> <li>Paginated transactions- get paginated transactions for an address</li> <li>Bulk time bucket transactions- fetch all transactions in 15-minute time buckets</li> <li>Block transactions- get all transactions in a specific block</li> <li>ERC-20 token transfers- fetch transfer history of a specific ERC-20 token for an address</li> <li>Cross-chain activity- locate chains on which an address is active</li> <li>Token approvals- get a list of token approvals for an address</li> <li>NFT approvals- retrieve NFT approvals for an address</li> </ul>"},{"location":"builders/integrations/indexers/covalent/#unified-api-methods","title":"Unified API Methods","text":"<p>For more information on each of the methods of the Unified API and for an interactive interface to try out each of the methods, be sure to check out the GoldRush docs.  </p>"},{"location":"builders/integrations/indexers/covalent/#balances","title":"Balances","text":"Token Balances <p>The token balances endpoint retrieves native tokens, fungible (ERC-20) tokens, and non-fungible (ERC-721 &amp; ERC-1155) tokens associated with a given address. The returned data includes current market prices and additional token metadata.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to check the token balances of</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x569BE8d8b04538318e1722f6e375FD381D2da865/balances_v2/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x569be8d8b04538318e1722f6e375fd381d2da865\",\n    \"updated_at\": \"2024-10-08T23:34:58.401269473Z\",\n    \"next_update_at\": \"2024-10-08T23:39:58.401269913Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"contract_decimals\": 18,\n        \"contract_name\": \"Mainnet2021\",\n        \"contract_ticker_symbol\": \"MN21\",\n        \"contract_address\": \"0xb59c01231fd65fb2da1e23a52abb946e2e13b333\",\n        \"supports_erc\": [\n          \"erc20\"\n        ],\n        \"logo_url\": \"https://logos.covalenthq.com/tokens/1287/0xb59c01231fd65fb2da1e23a52abb946e2e13b333.png\",\n        \"balance\": \"999999\",\n        \"quote_rate\": null,\n        \"quote\": 0,\n        \"pretty_quote\": \"$0.00\"\n      },\n      {\n        \"contract_decimals\": 18,\n        \"contract_name\": \"Dev\",\n        \"contract_ticker_symbol\": \"DEV\",\n        \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n        \"supports_erc\": [\n          \"erc20\"\n        ],\n        \"logo_url\": \"https://www.datocms-assets.com/86369/1669924256-moonbeam-1.png\",\n        \"balance\": \"88335963638628211482\",\n        \"quote_rate\": 0,\n        \"quote\": 0,\n        \"pretty_quote\": \"$0.00\"\n      }\n    ],\n    \"pagination\": null\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Native Token Balances <p>The native token balances endpoint retrieves the native token balance for a given address in a streamlined manner. </p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to check the token balances of</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x569BE8d8b04538318e1722f6e375FD381D2da865/balances_native/ \\\n  --header 'Authorization: Bearer INSERT-API-KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x569be8d8b04538318e1722f6e375fd381d2da865\",\n    \"updated_at\": \"2024-10-09T00:15:57.758041451Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"contract_decimals\": 18,\n        \"contract_name\": \"Dev\",\n        \"contract_ticker_symbol\": \"DEV\",\n        \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n        \"supports_erc\": [\n          \"erc20\"\n        ],\n        \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\",\n        \"block_height\": 8959160,\n        \"balance\": \"88335963638628211482\",\n        \"quote_rate\": null,\n        \"quote\": null,\n        \"pretty_quote\": null\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get ERC-20 Token Transfers for Address <p>Get ERC-20 Token Transfers for Address is used to fetch the transfer-in and transfer-out of a token along with historical prices from an address, when provided both a wallet address and an ERC-20 token contract address</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> <li><code>contractAddress</code> string - the ERC-20 token contract to query</li> </ul> <pre><code>curl --request GET \\\n  --url 'https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/transfers_v2/?contract-address=0x37822de108AFFdd5cDCFDaAa2E32756Da284DB85' \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T02:02:58.842706507Z\",\n    \"next_update_at\": \"2024-10-09T02:07:58.842707047Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2022-04-29T17:41:36Z\",\n        \"block_height\": 2075113,\n        \"tx_hash\": \"0x7271982923345160707c397e412db1a75ceaa458fc1a5dc2c638dd60e58e60d2\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": \"0x37822de108affdd5cdcfdaaa2e32756da284db85\",\n        \"value\": \"0\",\n        \"gas_offered\": 35009,\n        \"gas_spent\": 32693,\n        \"gas_price\": 2500000000,\n        \"fees_paid\": \"81732500000000\",\n        \"transfers\": [\n          {\n            \"tx_hash\": \"0x7271982923345160707c397e412db1a75ceaa458fc1a5dc2c638dd60e58e60d2\",\n            \"from_address\": \"0x0000000000000000000000000000000000000000\",\n            \"to_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n            \"contract_name\": \"Mercury\",\n            \"contract_ticker_symbol\": \"MERC\",\n            \"contract_address\": \"0x37822de108affdd5cdcfdaaa2e32756da284db85\",\n            \"transfer_type\": \"IN\",\n            \"delta\": \"100000000000000000000\"\n          }\n        ]\n      },\n      {\n        \"block_signed_at\": \"2021-10-13T19:06:30Z\",\n        \"block_height\": 954752,\n        \"tx_hash\": \"0x7fb19c6b0ccf1dd87610c59a9cdc2f298ce6b39b32b396f900f1bf3c8f034b6b\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": \"0x8a1932d6e26433f3037bd6c3a40c816222a6ccd4\",\n        \"value\": \"0\",\n        \"gas_offered\": 369444,\n        \"gas_spent\": 99165,\n        \"gas_price\": 1000000000,\n        \"fees_paid\": \"99165000000000\",\n        \"transfers\": [\n          {\n            \"tx_hash\": \"0x7fb19c6b0ccf1dd87610c59a9cdc2f298ce6b39b32b396f900f1bf3c8f034b6b\",\n            \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n            \"to_address\": \"0x573db48e758cbc07a99afe67b8b7b23f671902c0\",\n            \"contract_name\": \"Mercury\",\n            \"contract_ticker_symbol\": \"MERC\",\n            \"contract_address\": \"0x37822de108affdd5cdcfdaaa2e32756da284db85\",\n            \"transfer_type\": \"OUT\",\n            \"delta\": \"10000000000000000000000\"\n          }\n        ]\n      }\n    ],\n    \"pagination\": {\n      \"has_more\": false,\n      \"page_number\": 0,\n      \"page_size\": 100,\n      \"total_count\": null\n    }\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre>"},{"location":"builders/integrations/indexers/covalent/#transactions","title":"Transactions","text":"Get a transaction <p>Get a transaction is used fetch and render a single transaction including its decoded log events. </p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>txHash</code> string - the transaction hash</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/transaction_v2/0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T00:33:57.799418189Z\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-09-27T22:23:54Z\",\n        \"block_height\": 8816296,\n        \"block_hash\": \"0x2f89cd5009b3c69de1eb4edf678a5dfb6c2366cb7da6945783a443133b3df44e\",\n        \"tx_hash\": \"0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60\",\n        \"tx_offset\": 1,\n        \"successful\": true,\n        \"miner_address\": \"0xd34fedcefbaacbd74bd3d0bb80b3a67e6b2defb7\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"from_address_label\": null,\n        \"to_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n        \"to_address_label\": null,\n        \"value\": \"0\",\n        \"value_quote\": null,\n        \"pretty_value_quote\": null,\n        \"gas_metadata\": {\n          \"contract_decimals\": 18,\n          \"contract_name\": \"Dev\",\n          \"contract_ticker_symbol\": \"DEV\",\n          \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n          \"supports_erc\": [\n            \"erc20\"\n          ],\n          \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\"\n        },\n        \"gas_offered\": 169164,\n        \"gas_spent\": 110096,\n        \"gas_price\": 31250000,\n        \"fees_paid\": \"13762000000000\",\n        \"gas_quote\": null,\n        \"pretty_gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"explorers\": [\n          {\n            \"label\": null,\n            \"url\": \"https://moonbase-blockscout.testnet.moonbeam.network/tx/0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60\"\n          }\n        ],\n        \"log_events\": [\n          {\n            \"block_signed_at\": \"2024-09-27T22:23:54Z\",\n            \"block_height\": 8816296,\n            \"tx_offset\": 1,\n            \"log_offset\": 1,\n            \"tx_hash\": \"0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60\",\n            \"raw_log_topics\": [\n              \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n              \"0x0000000000000000000000003b939fead1557c741ff06492fd0127bd287a421e\",\n              \"0x0000000000000000000000004b8c667590e6a28497ea4be5facb7e9869a64eae\"\n            ],\n            \"sender_contract_decimals\": 12,\n            \"sender_name\": \"xcUNIT\",\n            \"sender_contract_ticker_symbol\": \"xcUNIT\",\n            \"sender_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n            \"sender_address_label\": null,\n            \"sender_logo_url\": \"https://logos.covalenthq.com/tokens/1287/0xffffffff1fcacbd218edc0eba20fc2308c778080.png\",\n            \"supports_erc\": [\n              \"erc20\"\n            ],\n            \"sender_factory_address\": null,\n            \"raw_log_data\": \"0x000000000000000000000000000000000000000000000000000000e8d4a51000\",\n            \"decoded\": {\n              \"name\": \"Transfer\",\n              \"signature\": \"Transfer(indexed address from, indexed address to, uint256 value)\",\n              \"params\": [\n                {\n                  \"name\": \"from\",\n                  \"type\": \"address\",\n                  \"indexed\": true,\n                  \"decoded\": true,\n                  \"value\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\"\n                },\n                {\n                  \"name\": \"to\",\n                  \"type\": \"address\",\n                  \"indexed\": true,\n                  \"decoded\": true,\n                  \"value\": \"0x4b8c667590e6a28497ea4be5facb7e9869a64eae\"\n                },\n                {\n                  \"name\": \"value\",\n                  \"type\": \"uint256\",\n                  \"indexed\": false,\n                  \"decoded\": true,\n                  \"value\": \"1000000000000\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ],\n    \"pagination\": null\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get transaction summary for address <p>Get transaction summary for address retrieves key wallet activity data, including the first and most recent transactions, and total transaction count. It enables quick analysis of wallet age, inactive periods, and overall Web3 engagement levels.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/transactions_summary/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T00:48:11.969915467Z\",\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"total_count\": 3066,\n        \"latest_transaction\": {\n          \"block_signed_at\": \"2024-10-04T19:41:48Z\",\n          \"tx_hash\": \"0x0923932a55c4366288cfc7a970e1d04895551d11f64d8f183877e8f6c19360bc\",\n          \"tx_detail_link\": \"https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/transaction_v2/0x0923932a55c4366288cfc7a970e1d04895551d11f64d8f183877e8f6c19360bc/\"\n        },\n        \"earliest_transaction\": {\n          \"block_signed_at\": \"2021-05-27T18:13:12Z\",\n          \"tx_hash\": \"0xc94e0072477e2543d17662317d40e4785ac6bb327c2a7483021167684b8584f3\",\n          \"tx_detail_link\": \"https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/transaction_v2/0xc94e0072477e2543d17662317d40e4785ac6bb327c2a7483021167684b8584f3/\"\n        }\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get earliest transactions for address (v3) <p>Get earliest transactions for address retrieves the earliest transactions involving an address.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/bulk/transactions/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T01:12:17.851277100Z\",\n    \"next_update_at\": \"2024-10-09T01:17:17.851280680Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2021-05-27T18:13:12Z\",\n        \"block_height\": 6971,\n        \"tx_hash\": \"0xc94e0072477e2543d17662317d40e4785ac6bb327c2a7483021167684b8584f3\",\n        \"from_address\": \"0xc10dc91c62c4854ffc0997776d495da3d8c79730\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"1044522000000000\",\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"log_events\": [\n          {\n            \"sender_name\": \"Mercury\",\n            \"sender_contract_ticker_symbol\": \"MERC\",\n            \"sender_address\": \"0x37822de108affdd5cdcfdaaa2e32756da284db85\",\n            \"decoded\": {\n              \"name\": \"Transfer\",\n              \"params\": [\n                {\n                  \"name\": \"from\",\n                  \"value\": \"0x0000000000000000000000000000000000000000\"\n                },\n                {\n                  \"name\": \"to\",\n                  \"value\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\"\n                },\n                {\n                  \"name\": \"value\",\n                  \"value\": \"100000000000000000000000\"\n                }\n              ]\n            }\n          }\n        ]\n      },\n      {\n        \"block_signed_at\": \"2021-05-27T18:13:24Z\",\n        \"block_height\": 6972,\n        \"tx_hash\": \"0xc37137133cbb8b0810943a6625a7193b5b18d72b5e21a78103243f482c269e71\",\n        \"from_address\": \"0xc10dc91c62c4854ffc0997776d495da3d8c79730\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"1044486000000000\",\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"log_events\": [\n          {\n            \"sender_name\": \"Venus\",\n            \"sender_contract_ticker_symbol\": \"VEN\",\n            \"sender_address\": \"0xcdf746c5c86df2c2772d2d36e227b4c0203cba25\",\n            \"decoded\": {\n              \"name\": \"Transfer\",\n              \"params\": [\n                {\n                  \"name\": \"from\",\n                  \"value\": \"0x0000000000000000000000000000000000000000\"\n                },\n                {\n                  \"name\": \"to\",\n                  \"value\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\"\n                },\n                {\n                  \"name\": \"value\",\n                  \"value\": \"100000000000000000000000\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get recent transactions for address (v3) <p>Get recent transactions for address retrieves the most recent transactions involving an address.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/transactions_v3/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T01:16:10.410076422Z\",\n    \"next_update_at\": \"2024-10-09T01:21:10.410077022Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-10-04T19:41:48Z\",\n        \"block_height\": 8901780,\n        \"tx_hash\": \"0x0923932a55c4366288cfc7a970e1d04895551d11f64d8f183877e8f6c19360bc\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"120825750000000\",\n        \"gas_offered\": 1010593,\n        \"gas_spent\": 966606,\n        \"gas_price\": 31250000,\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null\n      },\n      {\n        \"block_signed_at\": \"2024-09-27T22:23:54Z\",\n        \"block_height\": 8816296,\n        \"tx_hash\": \"0xbbf16145833d6c906cd2e01254fabe17c59da711df9efacaacf50fc8453a2c60\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n        \"value\": \"0\",\n        \"fees_paid\": \"13762000000000\",\n        \"gas_offered\": 169164,\n        \"gas_spent\": 110096,\n        \"gas_price\": 31250000,\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"log_events\": [\n          {\n            \"sender_name\": \"xcUNIT\",\n            \"sender_contract_ticker_symbol\": \"xcUNIT\",\n            \"sender_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n            \"decoded\": {\n              \"name\": \"Transfer\",\n              \"params\": [\n                {\n                  \"name\": \"from\",\n                  \"value\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\"\n                },\n                {\n                  \"name\": \"to\",\n                  \"value\": \"0x4b8c667590e6a28497ea4be5facb7e9869a64eae\"\n                },\n                {\n                  \"name\": \"value\",\n                  \"value\": \"1000000000000\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get paginated transactions for address (v3) <p>Get paginated transactions for address (v3) fetches the transactions involving an address and the specified page, starting from a 0 index.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> <li><code>page</code> integer - the requested page, 0-indexed. </li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/transactions_v3/page/2/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T01:37:36.277434751Z\",\n    \"next_update_at\": \"2024-10-09T01:42:36.277435481Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2021-06-08T18:22:00Z\",\n        \"block_height\": 93135,\n        \"tx_hash\": \"0x802eab122522f1ae23b911e8045d9de128acaa5c790d5df0c389240f23b7e17d\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"1416680000000000\",\n        \"gas_offered\": 1455080,\n        \"gas_spent\": 1416680,\n        \"gas_price\": 1000000000,\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null\n      },\n      {\n        \"block_signed_at\": \"2021-06-08T18:21:48Z\",\n        \"block_height\": 93134,\n        \"tx_hash\": \"0xe82d29e37e8d324a22ed9ce70d0c85258c420cf98cc4161c35f4edb7c9ba09c0\",\n        \"from_address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n        \"to_address\": null,\n        \"value\": \"0\",\n        \"fees_paid\": \"1712047000000000\",\n        \"gas_offered\": 1750447,\n        \"gas_spent\": 1712047,\n        \"gas_price\": 1000000000,\n        \"gas_quote\": null,\n        \"gas_quote_rate\": null\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get bulk time bucket transactions for address (v3) <p>Get bulk time bucket transactions for address (v3) is used to fetch all transactions including their decoded log events in a 15-minute time bucket interval.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> <li><code>timeBucket</code> integer - The 0-indexed 15-minute time bucket. E.g. 8 9 Oct 2024 01:49 GMT = 1728420540 (Unix time). 1728420540/900 = 1920467 timeBucket.</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/bulk/transactions/0x28a2B98793Fd1E20Fd79824cd29D36D3eB9A8F0E/1920467/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x28a2b98793fd1e20fd79824cd29d36d3eb9a8f0e\",\n    \"updated_at\": \"2024-10-09T01:47:40.617173773Z\",\n    \"next_update_at\": \"2024-10-09T01:52:40.617176953Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"complete\": true,\n    \"current_bucket\": 1920467,\n    \"links\": {\n      \"prev\": \"https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/bulk/transactions/0x28a2b98793fd1e20fd79824cd29d36d3eb9a8f0e/1920466/\",\n      \"next\": \"https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/bulk/transactions/0x28a2b98793fd1e20fd79824cd29d36d3eb9a8f0e/1920468/\"\n    },\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-10-08T20:48:42Z\",\n        \"block_height\": 8957260,\n        \"tx_hash\": \"0x587f0121ea9c51b93e1915a20370f0a2f004adee99d00ef8d1c0f9cc681a9772\",\n        \"from_address\": \"0x28a2b98793fd1e20fd79824cd29d36d3eb9a8f0e\",\n        \"to_address\": \"0x916b54696a70588a716f899be1e8f2a5ffd5f135\",\n        \"value\": \"0\",\n        \"gas_offered\": 582957,\n        \"gas_spent\": 551928,\n        \"gas_price\": 31250000,\n        \"fees_paid\": \"68991000000000\",\n        \"log_events\": [\n          {\n            \"sender_address\": \"0x916b54696a70588a716f899be1e8f2a5ffd5f135\",\n            \"decoded\": {\n              \"name\": \"SessionStarted\",\n              \"signature\": \"SessionStarted(indexed uint64 chainId, indexed uint64 blockHeight, uint64 deadline)\",\n              \"params\": [\n                {\n                  \"name\": \"chainId\",\n                  \"type\": \"uint64\",\n                  \"value\": \"1\"\n                },\n                {\n                  \"name\": \"blockHeight\",\n                  \"type\": \"uint64\",\n                  \"value\": \"20923350\"\n                },\n                {\n                  \"name\": \"deadline\",\n                  \"type\": \"uint64\",\n                  \"value\": \"8957360\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get all transactions in a block by page (v3) <p>Get all transactions in a block by page (v3) is used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>blockHeight</code> integer - the request block height. Also accepts the <code>latest</code> keyword</li> <li><code>page</code> integer - the requested page, 0-indexed.</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/block/8960094/transactions_v3/page/0/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T01:54:34.371150099Z\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"links\": {\n      \"prev\": null,\n      \"next\": null\n    },\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-10-09T01:51:42Z\",\n        \"block_height\": 8960094,\n        \"block_hash\": \"0x2a9cda3cfd23dffbe064932991568cae601d178717743eabc326222123d7ad44\",\n        \"tx_hash\": \"0x4abfef674580260d3c837e1dc5b17b8bf809e620518e40d3731c6c1cfa5346d9\",\n        \"tx_offset\": 0,\n        \"successful\": true,\n        \"miner_address\": \"0xeda33e2b5ffb97bb8b901b71b87e5791556fd46b\",\n        \"from_address\": \"0xf5e8a439c599205c1ab06b535de46681aed1007a\",\n        \"from_address_label\": null,\n        \"to_address\": \"0x21e612506ab4792a5d22466c0b529bb9afe4e42b\",\n        \"to_address_label\": null,\n        \"value\": \"0\",\n        \"value_quote\": null,\n        \"pretty_value_quote\": null,\n        \"gas_metadata\": {\n          \"contract_decimals\": 18,\n          \"contract_name\": \"Dev\",\n          \"contract_ticker_symbol\": \"DEV\",\n          \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n          \"supports_erc\": [\n            \"erc20\"\n          ],\n          \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\"\n        },\n        \"gas_offered\": 505088,\n        \"gas_spent\": 184528,\n        \"gas_price\": 1200000000,\n        \"fees_paid\": \"221433600000000\",\n        \"gas_quote\": null,\n        \"pretty_gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"explorers\": [\n          {\n            \"label\": null,\n            \"url\": \"https://moonbase-blockscout.testnet.moonbeam.network/tx/0x4abfef674580260d3c837e1dc5b17b8bf809e620518e40d3731c6c1cfa5346d9\"\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> Get all transactions in a block (v3) <p>Get all transactions in a block (v3) is used to used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions. It takes a blockhash as a parameter and it does not accept a page parameter.</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>blockHash</code> integer - the request block hash</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-moonbase-alpha/block_hash/0x2a9cda3cfd23dffbe064932991568cae601d178717743eabc326222123d7ad44/transactions_v3/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T01:58:08.816101489Z\",\n    \"chain_id\": 1287,\n    \"chain_name\": \"moonbeam-moonbase-alpha\",\n    \"items\": [\n      {\n        \"block_signed_at\": \"2024-10-09T01:51:42Z\",\n        \"block_height\": 8960094,\n        \"block_hash\": \"0x2a9cda3cfd23dffbe064932991568cae601d178717743eabc326222123d7ad44\",\n        \"tx_hash\": \"0x4abfef674580260d3c837e1dc5b17b8bf809e620518e40d3731c6c1cfa5346d9\",\n        \"tx_offset\": 0,\n        \"successful\": true,\n        \"miner_address\": \"0xeda33e2b5ffb97bb8b901b71b87e5791556fd46b\",\n        \"from_address\": \"0xf5e8a439c599205c1ab06b535de46681aed1007a\",\n        \"from_address_label\": null,\n        \"to_address\": \"0x21e612506ab4792a5d22466c0b529bb9afe4e42b\",\n        \"to_address_label\": null,\n        \"value\": \"0\",\n        \"value_quote\": null,\n        \"pretty_value_quote\": null,\n        \"gas_metadata\": {\n          \"contract_decimals\": 18,\n          \"contract_name\": \"Dev\",\n          \"contract_ticker_symbol\": \"DEV\",\n          \"contract_address\": \"0x0000000000006d6f6f6e626173652d616c706861\",\n          \"supports_erc\": [\n            \"erc20\"\n          ],\n          \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\"\n        },\n        \"gas_offered\": 505088,\n        \"gas_spent\": 184528,\n        \"gas_price\": 1200000000,\n        \"fees_paid\": \"221433600000000\",\n        \"gas_quote\": null,\n        \"pretty_gas_quote\": null,\n        \"gas_quote_rate\": null,\n        \"explorers\": [\n          {\n            \"label\": null,\n            \"url\": \"https://moonbase-blockscout.testnet.moonbeam.network/tx/0x4abfef674580260d3c837e1dc5b17b8bf809e620518e40d3731c6c1cfa5346d9\"\n          }\n        ]\n      }\n    ],\n    \"pagination\": null\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre>"},{"location":"builders/integrations/indexers/covalent/#cross-chain","title":"Cross Chain","text":"Get cross-chain activity for address <p>Get cross-chain activity for address is used to locate chains which an address is active on with a single API call</p> ParametersExample RequestExample Response <ul> <li><code>walletAddress</code> string - the address you wish to query</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/address/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/activity/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updated_at\": \"2024-10-09T02:08:22.594362014Z\",\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"items\": [\n      {\n        \"name\": \"matic-mainnet\",\n        \"chain_id\": \"137\",\n        \"is_testnet\": false,\n        \"label\": \"Polygon Mainnet\",\n        \"category_label\": \"Polygon\",\n        \"logo_url\": \"https://www.datocms-assets.com/86369/1677870347-property-1-polygon-zkevm-icon-white.svg\",\n        \"color_theme\": {\n          \"hex\": \"#8247E5\",\n          \"css_rgb\": \"rgb(130 71 229)\"\n        },\n        \"last_seen_at\": \"2024-06-26T09:50:16Z\"\n      },\n      {\n        \"name\": \"moonbeam-mainnet\",\n        \"chain_id\": \"1284\",\n        \"is_testnet\": false,\n        \"label\": \"Moonbeam Mainnet\",\n        \"category_label\": \"Moonbeam\",\n        \"logo_url\": \"https://www.datocms-assets.com/86369/1669924204-moonbeam.svg\",\n        \"color_theme\": {\n          \"hex\": \"#54CBC8\",\n          \"css_rgb\": \"rgb(84 203 200)\"\n        },\n        \"last_seen_at\": \"2024-10-04T01:11:42Z\"\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre>"},{"location":"builders/integrations/indexers/covalent/#security","title":"Security","text":"Get token approvals for address <p>Get token approvals for address is used to get a list of approvals across all token contracts categorized by spenders for a wallet\u2019s assets</p> ParametersExample RequestExample Response <ul> <li><code>chainName</code> string - e.g. <code>moonbeam-mainnet</code>, <code>moonbeam-moonriver</code>, or <code>moonbeam-moonbase-alpha</code> </li> <li><code>walletAddress</code> string - the address you wish to query</li> </ul> <pre><code>curl --request GET \\\n  --url https://api.covalenthq.com/v1/moonbeam-mainnet/approvals/0x3B939FeaD1557C741Ff06492FD0127bd287A421e/ \\\n  --header 'Authorization: Bearer INSERT_API_KEY'\n</code></pre> <pre><code>{\n  \"data\": {\n    \"address\": \"0x3b939fead1557c741ff06492fd0127bd287a421e\",\n    \"updated_at\": \"2024-10-09T02:11:10.587740726Z\",\n    \"quote_currency\": \"USD\",\n    \"chain_id\": 1284,\n    \"chain_name\": \"moonbeam-mainnet\",\n    \"items\": [\n      {\n        \"token_address\": \"0xffffffff1fcacbd218edc0eba20fc2308c778080\",\n        \"token_address_label\": \"xcDOT\",\n        \"ticker_symbol\": \"xcDOT\",\n        \"contract_decimals\": 10,\n        \"logo_url\": \"https://logos.covalenthq.com/tokens/1284/0xffffffff1fcacbd218edc0eba20fc2308c778080.png\",\n        \"quote_rate\": 4.169,\n        \"balance\": \"1655341603\",\n        \"balance_quote\": 0.6901119142907,\n        \"pretty_balance_quote\": \"$0.69\",\n        \"spenders\": [\n          {\n            \"spender_address\": \"0xbc7e02c4178a7df7d3e564323a5c359dc96c4db4\",\n            \"spender_address_label\": \"Stella stDOT\",\n            \"allowance\": \"UNLIMITED\",\n            \"value_at_risk_quote\": 0.6901119142907,\n            \"pretty_value_at_risk_quote\": \"$0.69\",\n            \"risk_factor\": \"LOW RISK\"\n          }\n        ]\n      },\n      {\n        \"token_address\": \"0x818ec0a7fe18ff94269904fced6ae3dae6d6dc0b\",\n        \"token_address_label\": \"USD Coin\",\n        \"ticker_symbol\": \"USDC\",\n        \"contract_decimals\": 6,\n        \"logo_url\": \"https://logos.covalenthq.com/tokens/1284/0x818ec0a7fe18ff94269904fced6ae3dae6d6dc0b.png\",\n        \"quote_rate\": 0.09,\n        \"balance\": \"1\",\n        \"balance_quote\": 0,\n        \"pretty_balance_quote\": \"$0.00\",\n        \"spenders\": [\n          {\n            \"spender_address\": \"0x70085a09d30d6f8c4ecf6ee10120d1847383bb57\",\n            \"spender_address_label\": null,\n            \"allowance\": \"UNLIMITED\",\n            \"value_at_risk_quote\": 0,\n            \"pretty_value_at_risk_quote\": \"$0.00\",\n            \"risk_factor\": \"LOW RISK\"\n          }\n        ]\n      }\n    ]\n  },\n  \"error\": false,\n  \"error_message\": null,\n  \"error_code\": null\n}\n</code></pre> <p>The GoldRush API offers many additional methods, including NFT, price, Bitcoin, and utility methods. Be sure to check out the GoldRush API for more information on each of these methods.  </p>"},{"location":"builders/integrations/indexers/covalent/#api-parameters-and-resources","title":"API Parameters and Resources","text":""},{"location":"builders/integrations/indexers/covalent/#api-parameters","title":"API Parameters","text":"MoonbeamMoonriverMoonbase Alpha Parameter Value Response Formats JSON, CSV Real-Time Data Latency 2 blocks Batch Data Latency 30 minutes API Free Tier Limit of 4 RPS API Premium Tier Limit of 50 RPS Parameter Value Response Formats JSON, CSV Real-Time Data Latency 2 blocks Batch Data Latency 30 minutes API Free Tier Limit of 4 RPS API Premium Tier Limit of 50 RPS Parameter Value Response Formats JSON, CSV Real-Time Data Latency 2 blocks Batch Data Latency 30 minutes API Free Tier Limit of 4 RPS API Premium Tier Limit of 50 RPS"},{"location":"builders/integrations/indexers/covalent/#api-resources","title":"API Resources","text":"<ul> <li>API Reference and In-Browser Endpoint Demo</li> <li>GoldRush Quickstart</li> <li>Written Guides</li> </ul>"},{"location":"builders/integrations/indexers/covalent/#how-to-use-the-unified-api","title":"How to Use the Unified API","text":"<p>First, make sure you have your API Key which begins with <code>cqt_</code> or <code>ckey_</code>. Once you have your API key, you can access any of the supported endpoints. To get information for a specific network, you must provide the chain ID.</p>"},{"location":"builders/integrations/indexers/covalent/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started with the GoldRush API, you will need to have the following:</p> <ul> <li>A free GoldRush API Key</li> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/integrations/indexers/covalent/#using-curl","title":"Using Curl","text":"<p>One of the supported endpoints is the token holders endpoint, which returns a list of all the token holders of a particular token. For this example, you can check the token holders for the ERTH token. The contract address for the ERTH token on Moonbase Alpha is <code>0x08B40414525687731C23F430CEBb424b332b3d35</code>.</p> <p>Try running the command below in a terminal window after replacing the placeholder with your API key.</p> <pre><code>curl https://api.covalenthq.com/v1/1287/tokens/\\\n0x08B40414525687731C23F430CEBb424b332b3d35/token_holders/ \\\n-u INSERT_YOUR_API_KEY:\n</code></pre> <p>Note</p> <p>The colon <code>:</code> after the API key is required to skip the password prompt.</p> <p>Unless you already owned some ERTH tokens, your address will be missing from that list. Head over to the Moonbase Alpha ERC-20 Faucet to generate some ERTH tokens for yourself. Now repeat the same GoldRush API request as above. The GoldRush API updates in real-time, so you should now see your address in the list of token holders for the ERTH token.</p>"},{"location":"builders/integrations/indexers/covalent/#using-javascript","title":"Using Javascript","text":"<p>Copy and paste the below code block into your preferred environment or JSFiddle. After setting the API key, set the address constant. Remember for Moonbase Alpha the chain ID is <code>1287</code>.</p> Using FetchUsing Async <pre><code>// Set your API key\nconst apiKey = 'INSERT_YOUR_API_KEY';\n\nfunction getData() {\n  const address = '0xFEC4f9D5B322Aa834056E85946A32c35A3f5aDD8'; // example\n  const chainId = '1287'; // Moonbase Alpha TestNet chain ID\n  const url = new URL(\n    `https://api.covalenthq.com/v1/${chainId}/address/${address}/balances_v2/`\n  );\n\n  url.search = new URLSearchParams({\n    key: apiKey,\n  });\n\n  // Use fetch API to get Covalent data\n  fetch(url)\n    .then((resp) =&gt; resp.json())\n    .then(function (data) {\n      const result = data.data;\n\n      console.log(result);\n      return result;\n    });\n}\n\ngetData();\n</code></pre> <pre><code>// Set your API key\nconst apiKey = 'INSERT_YOUR_API_KEY';\nconst address = '0xFEC4f9D5B322Aa834056E85946A32c35A3f5aDD8'; // Example\nconst chainId = '1287'; // Moonbase Alpha TestNet chain ID\nconst url = new URL(\n  `https://api.covalenthq.com/v1/${chainId}/address/${address}/balances_v2/`\n);\n\nurl.search = new URLSearchParams({\n  key: apiKey,\n});\n\nasync function getData() {\n  const response = await fetch(url);\n  const result = await response.json();\n  console.log(result);\n  return result;\n}\n\ngetData();\n</code></pre> <p>The balances endpoint returns a list of all ERC-20 and NFT token balances, including ERC-721 and ERC-1155 balances, along with their current spot prices (if available).</p> <p></p>"},{"location":"builders/integrations/indexers/covalent/#using-python","title":"Using Python","text":"<p>GoldRush doesn\u2019t have an official API wrapper. To query the API directly, you will have to use the Python requests library. Install requests into your environment from the command line with <code>pip install requests</code>. Then import it and use it in your code. Use the HTTP verbs get methods to return the information from the API. Copy and paste the below code block into your preferred environment and run it. The output should look similar to the screenshot above, however the formatting may vary depending on your environment.</p> <pre><code>import requests\n\ndef fetch_wallet_balance(address):\n    api_url = \"https://api.covalenthq.com\"\n    endpoint = f\"/v1/1287/address/{address}/balances_v2/\"\n    url = api_url + endpoint\n    response = requests.get(url, auth=(\"INSERT_YOUR_API_KEY\", \"\"))\n    print(response.json())\n    return response.json()\n\n# Example address request\nfetch_wallet_balance(\"0xFEC4f9D5B322Aa834056E85946A32c35A3f5aDD8\")\n</code></pre> <p>Note</p> <p>The second parameter of <code>auth</code> is empty because no password is required\u2014your API key is all that's needed.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/indexers/subquery/","title":"Indexing Moonbeam with SubQuery","text":""},{"location":"builders/integrations/indexers/subquery/#introduction","title":"Introduction","text":"<p>SubQuery is a data aggregation layer that operates between the layer-1 blockchains (such as Moonbeam and Polkadot) and DApps. This service unlocks blockchain data and transforms it into a queryable state so that it can be used in intuitive applications. It allows DApp developers to focus on their core use case and front end without needing to waste time on building a custom back end for data processing.</p> <p>SubQuery supports indexing the Ethereum Virtual Machine (EVM) and Substrate data for any of the Moonbeam networks. A key advantage of using SubQuery is that you can flexibly collect query data across both Moonbeam's EVM and Substrate code with a single project and tool, and then query this data using GraphQL.</p> <p>For example, SubQuery can filter and query EVM logs and transactions in addition to Substrate data sources. SubQuery introduces more advanced filters than other indexers, allowing filtering of non-contract transactions, transaction senders, contracts, and indexed log arguments, so developers can build a wide variety of projects that cater to their specific data needs.</p> <p>This quick-start guide will show you how to create a SubQuery project and configure it to index Substrate and EVM data on Moonbeam.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/indexers/subquery/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Later on in this guide, you have the option of deploying your project to a locally running SubQuery node. To do so, you need to have the following installed on your system:</p> <ul> <li>Docker</li> <li>Docker Compose</li> </ul> <p>Note</p> <p>If Docker Compose was installed for Linux via the <code>sudo apt install docker-compose</code> command, you might run into some errors later on in the guide. Please be sure to follow the instructions for Linux from the official Install Docker Compose guide.</p>"},{"location":"builders/integrations/indexers/subquery/#create-a-project","title":"Create a Project","text":"<p>To get started, you'll need to create a SubQuery project:</p> <ol> <li> <p>Globally install the SubQuery CLI:</p> npmyarn <pre><code>npm install -g @subql/cli\n</code></pre> <pre><code>yarn global add @subql/cli\n</code></pre> </li> </ol> <p>Note</p> <p>Using yarn to install <code>@subql/cli</code> is discouraged due to its poor dependency management, which can result in various errors.</p> <ol> <li> <p>Initialize your SubQuery project using the following command:</p> <pre><code>subql init PROJECT_NAME\n</code></pre> </li> <li> <p>You'll be prompted to answer a series of questions:</p> <ol> <li> <p>For the Select a network family question, although Moonbeam is EVM compatible, the Moonbeam templates are under the Polkadot family, so you can choose Polkadot.</p> <p>  subql init moonbeam-demo ? Select a network family    EVM Networks   Algorand   Cosmos   Concordium   NEAR &gt; Polkadot   Stellar </p> </li> <li> <p>The next screen will prompt you to Select a network. You can choose between Moonbeam and Moonriver.</p> <p>Note</p> <p>To build a project on Moonbase Alpha, you can select either network and adapt it later on.</p> <p>  subql init moonbeam-demo ? Select a network family Polkadot ? Select a network    Humanode   HydraDX   Integritee Shell   Interlay   Karura   Khala   KILT Spiritnet   Kusama   Kylin &gt; Moonbeam   Moonriver   Nodle   OriginTrail   Parallel   Parallel Heiko   Polkadex   Polkadot   Quartz   Shiden   Kusama Asset Hub (Statemine) (Move up and down to reveal more choices) </p> </li> <li> <p>You'll be prompted to Select a template project. Depending on the network you chose in the prior step, the template options may vary.</p> MoonbeamMoonriver Template Description <code>moonbeam-evm-starter</code> A starter EVM project that indexes ERC-20 <code>Transfer</code> events and <code>approve</code> calls <code>moonbeam-substrate-evm-starter</code> A starter Substrate and EVM project that indexes ERC-20 <code>Transfer</code> events and calls to the Staking Pallet's <code>joinCandidates</code> and <code>executeLeaveCandidates</code> extrinsics <code>Moonbeam-starter</code> A starter Substrate project that indexes balance transfers through the Balances Pallet Template Description <code>moonriver-evm-starter</code> A starter EVM project that indexes ERC-20 <code>Transfer</code> events and <code>approve</code> calls <code>Moonriver-starter</code> A starter Substrate project that indexes balance transfers through the Balances Pallet <p>  subql init moonbeam-demo ? Select a network family Polkadot ? Select a network Moonbeam ? Select a template project  &gt; moonbeam-evm-starter   moonbeam-substrate-evm-starter   Moonbeam-starter   Other                         Enter a custom git endpoint </p> </li> <li> <p>You'll be prompted to add additional information, such as the RPC endpoint, the project's author, and the description of the project. For these, you can just hit enter and accept the default or customize them as you see fit.</p> <p>Note</p> <p>To avoid hitting the rate limits of public RPC endpoints, it is recommended to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>  subql init moonbeam-demo ? Select a network family Polkadot ? Select a network Moonbeam ? Select a template project Moonbeam-starter RPC endpoint: [wss://moonbeam.api.onfinality.io/public-ws]: Author [SubQuery Team]: Description [This project can be used as a starting p...]: Preparing project... done moonbeam-demo is ready </p> </li> </ol> </li> <li> <p>After you've gone through all of the prompts, the starter project will be cloned. You'll just need to install dependencies from within the project directory:</p> npmyarn <pre><code>cd PROJECT_NAME &amp;&amp; npm install\n</code></pre> <pre><code>cd PROJECT_NAME &amp;&amp; yarn install\n</code></pre> </li> </ol>"},{"location":"builders/integrations/indexers/subquery/#configure-the-network","title":"Configure the Network","text":"<p>The template projects already come pre-configured for the network selected while initializing your project. However, if you're working off of an existing project or want to configure your project for Moonbase Alpha instead of Moonbeam or Moonriver, you can update the network configurations in the <code>project.ts</code> file.</p> <p>The <code>network</code> configuration is as follows for each network:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>network: {\n  chainId: \n    '0xfe58ea77779b7abda7da4ec526d14db9b1e9cd40a217c34892af80a9b332b76d',\n  endpoint: ['INSERT_RPC_API_ENDPOINT'],\n  chaintypes: {\n    file: ./dist/chaintypes.js,\n  },\n},\n</code></pre> <pre><code>network: {\n  chainId: '0x401a1f9dca3da46f5c4091016c8a2f26dcea05865116b286f60f668207d1474b',\n  endpoint: ['INSERT_RPC_API_ENDPOINT'],\n  chaintypes: {\n    file: ./dist/chaintypes.js,\n  },\n},\n</code></pre> <pre><code>network: {\n  chainId: '0x91bc6e169807aaa54802737e1c504b2577d4fafedd5a02c10293b1cd60e39527',\n  endpoint: ['https://rpc.api.moonbase.moonbeam.network'],\n  chaintypes: {\n    file: ./dist/chaintypes.js,\n  },\n},\n</code></pre> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/integrations/indexers/subquery/#modify-the-graphql-schema","title":"Modify the GraphQL Schema","text":"<p>In the <code>schema.graphql</code> file, you can use GraphQL entities to define the shape of your data. Once you've edited the GraphQL schema for your needs, you'll need to generate the required GraphQL models. To do so, you can run the following command:</p> npmyarn <pre><code>npm run codegen\n</code></pre> <pre><code>yarn codegen\n</code></pre>  npm run codegen &gt; moonbeam-demo@0.0.4 codegen &gt; subql codegen ============================== ---------Subql Codegen--------- ============================== Project manifest generated to /home/papermoon/moonbeam-demo/project.yaml * Schema Transfer generated ! * Schema Account generated ! * Models index generated ! * Types index generated ! <p>The generated models will be created in the <code>src/types/models</code> directory. These models will be used in the mapping handlers that process the indexed data.</p> <p>Note</p> <p>If you make changes to the <code>schema.graphql</code> file, you'll need to regenerate your types.</p>"},{"location":"builders/integrations/indexers/subquery/#index-substrate-data","title":"Index Substrate Data","text":"<p>The <code>project.ts</code> file is the entry point into your indexer; it defines what type of data to index and the mapping functions that are responsible for handling and processing the indexed data.</p> <p>To index Substrate data, you'll need to ensure that the type of the <code>project</code> is <code>SubstrateProject</code>.</p> <pre><code>const project: SubstrateProject = { ... }\n</code></pre>"},{"location":"builders/integrations/indexers/subquery/#the-substrate-data-source","title":"The Substrate Data Source","text":"<p>In the <code>project.dataSources</code> array, you'll define the Substrate data source and the data to be indexed. The format of the data source is as follows:</p> <pre><code>datasources: [\n  {\n    kind: 'substrate/Runtime',\n    startBlock: INSERT_START_BLOCK,\n    endBlock: INSERT_END_BLOCK,\n    mapping: {\n      file: './dist/index.js',\n      handlers: [\n        {\n          kind: 'INSERT_HANDLER_KIND',\n          handler: 'INSERT_HANDLER_FUNCTION_NAME',\n          filter: {\n            'INSERT_FILTER_TYPE': 'INSERT_FILTER',\n          },\n        },\n      ],\n    },\n  },\n],\n</code></pre> <p>Each property can be defined as follows:</p> <ul> <li><code>kind</code>: The kind of data source that you'll use, which for Substrate data is the <code>substrate/Runtime</code> source.</li> <li><code>startBlock</code> (optional): The block from which the indexer will start processing blocks.</li> <li><code>endBlock</code> (optional): After this block, the indexer will stop processing blocks.</li> <li><code>mapping</code>: The data to be indexed and the handlers for the data.<ul> <li><code>file</code>: The entry path for the mapping.</li> <li><code>handlers</code>: The handlers for specific kinds of data.<ul> <li><code>kind</code>: The kind of handler. For Substrate data, there are three kinds: <code>substrateBlockHandler</code>, <code>substrate/EventHandler</code>, and <code>substrate/CallHandler</code>.</li> <li><code>handler</code>: The name of the handler function that will process this data.</li> <li><code>filter</code> (optional): The filter type and data that will trigger a mapping handler. For example, what block, event, or extrinsic to index.</li> </ul> </li> </ul> </li> </ul>"},{"location":"builders/integrations/indexers/subquery/#substrate-mapping-handlers","title":"Substrate Mapping Handlers","text":"<p>Using only certain handlers and filters will improve your indexer's efficiency. The handlers available for Substrate data are as follows:</p> <ul> <li> <p>The block handler is used to index block data and is called once for every block. As such, this type of handler will slow your project down significantly and should only be used if absolutely necessary. The supported filters for the block handler are: <code>specVersion</code>, <code>modulo</code>, and <code>timestamp</code>.</p> Filter Description Example <code>specVersion</code> Filters the blocks that fall into a spec version range <code>specVersion: [null, 2000]</code> <code># Indexes blocks with a spec</code> <code>version between 0 - 2000</code> <code>modulo</code> Filters the blocks at an interval <code>modulo: 50 # Indexes every 50 blocks</code> <code>timestamp</code> Filters the blocks at a time interval (in UTC).  Accepts a valid cron expression <code>timestamp: '*5/ * * * *'</code> <code># Indexes blocks every 5 minutes</code> </li> <li> <p>The event handler is used to index certain Substrate events that are part of the runtime. The supported filters for the event handler are: <code>module</code> and <code>method</code>.</p> Filter Description Example <code>module</code> Filters the pallet (module) that the event belongs to <code>module: 'balances'</code> <code>method</code> Filters the event <code>method: 'Transfer'</code> </li> <li> <p>The call handler is used to index certain Substrate extrinsics. The supported filters for the call handler are: <code>module</code>, <code>method</code>, <code>success</code>, and <code>isSigned</code>.</p> Filter Description Example <code>module</code> Filters the pallet (module) that extrinsic belongs to <code>module: 'balances'</code> <code>method</code> Filters the extrinsic <code>method: 'Transfer'</code> <code>success</code> Filters extrinsics based on outcome <code>success: true</code> <code>isSigned</code> Filters extrinsics based on whether they're signed <code>isSigned: true</code> </li> </ul>"},{"location":"builders/integrations/indexers/subquery/#index-ethereum-data","title":"Index Ethereum Data","text":"<p>The <code>project.ts</code> file is the entry point into your indexer; it defines what type of data to index and the mapping functions that are responsible for handling and processing the indexed data.</p> <p>To index Substrate data, you'll need to ensure that the type of the <code>project</code> is <code>SubstrateProject&lt;FrontierEvmDatasource&gt;</code>.</p> <pre><code>const project: SubstrateProject&lt;FrontierEvmDatasource&gt; = { ... }\n</code></pre>"},{"location":"builders/integrations/indexers/subquery/#the-evm-data-source","title":"The EVM Data Source","text":"<p>In the <code>project.dataSources</code> array, you'll define the EVM data source and the data to be indexed. The EVM data source is powered by a data processor specifically made to work with Moonbeam\u2019s implementation of Frontier. It allows you to reference specific ABI resources used by the processor to parse arguments and the smart contract address that the events are from or the call is made to. In general, it acts as middleware that can provide extra filtering and data transformation.</p> <p>The format of the data source is as follows:</p> <pre><code>datasources: [\n  {\n    kind: 'substrate/FrontierEvm',\n    startBlock: INSERT_START_BLOCK,\n    endBlock: INSERT_END_BLOCK,\n    processor: {\n      file: './node_modules/@subql/frontier-evm-processor/dist/bundle.js',\n      options: {\n        abi: '',\n        address: '',\n      },\n    },\n    assets: ''\n    mapping: {\n      file: './dist/index.js',\n      handlers: [\n        {\n          kind: 'INSERT_HANDLER_KIND',\n          handler: 'INSERT_HANDLER_FUNCTION_NAME',\n          filter: {\n            'INSERT_FILTER_TYPE': 'INSERT_FILTER',\n          },\n        },\n      ],\n    },\n  },\n],\n</code></pre> <p>Each property can be defined as follows:</p> <ul> <li><code>kind</code>: The kind of data source that you'll use, which for EVM data is the <code>substrate/FrontierEVM</code> source.</li> <li><code>startBlock</code> (optional): The block from which the indexer will start processing blocks.</li> <li><code>endBlock</code> (optional): After this block, the indexer will stop processing blocks.</li> <li><code>processor</code>: The Frontier EVM data processor configuration.<ul> <li><code>file</code>: The file where the data processor code lives.</li> <li><code>options</code> (optional): The processor options specific to the Frontier EVM processor.<ul> <li><code>abi</code> (optional): The ABI that is used to parse arguments. The <code>abi</code> value must be a key in the <code>assets</code> configuration.</li> <li><code>address</code> (optional): The contract address where the event is emitted from or the call is made to. Using <code>null</code> will capture contract creation calls.</li> </ul> </li> <li><code>assets</code> (optional): An object of external asset ABI files.</li> </ul> </li> <li><code>mapping</code>: The data to be indexed and the handlers for the data.<ul> <li><code>file</code>: The entry path for the mapping.</li> <li><code>handlers</code>: The handlers for specific kinds of data.<ul> <li><code>kind</code>: The kind of handler. For EVM data, there are two kinds: <code>substrate/FrontierEvmCall</code> and <code>substrate/FrontierEvmEvent</code>.</li> <li><code>handler</code>: The name of the handler function that will process this data.</li> <li><code>filter</code> (optional): The filter type and data that will trigger a mapping handler. For example, what block, event, or extrinsic to index.</li> </ul> </li> </ul> </li> </ul>"},{"location":"builders/integrations/indexers/subquery/#evm-mapping-handlers","title":"Frontier EVM Mapping Handlers","text":"<p>Using only certain handlers and filters will improve your indexer's efficiency. The handlers available for EVM data are as follows:</p> <ul> <li> <p>The Frontier EVM call handler is used to index transactions that are formatted based on Ethers <code>TransactionResponse</code> type, but varies slightly. For information on the exact changes, please refer to SubQuery's documentation. The supported filters for the call handler are: <code>function</code> and <code>from</code>.</p> Filter Description Example <code>function</code> Filters the call by function signature or selector <code>function: '0x095ea7b3'</code> <code>function: 'approve(address to,uint256 value)'</code> <code>from</code> Filters the call by the address that sent the transaction <code>from: '0x6bd193ee6d2104f14f94e2ca6efefae561a4334b'</code> </li> <li> <p>The Frontier EVM event handler is used to index certain EVM events. The supported filter for the event handler is: <code>topics</code>.</p> Filter Description Example <code>topics</code> Filters the event log by topics, which follows the Ethereum JSON-RPC log filters <code>topics: 'Transfer(address indexed from,address indexed to,uint256 value)'</code> </li> </ul>"},{"location":"builders/integrations/indexers/subquery/#run-your-indexer","title":"Run Your Indexer","text":"<p>To run your indexer locally using Docker, you can take the following steps:</p> <ol> <li> <p>Build your project:</p> npmyarn <pre><code>npm run build\n</code></pre> <pre><code>yarn build\n</code></pre> <p>  npm run build &gt; moonbeam-demo@0.0.4 build &gt; subql build Project manifest generated to /home/papermoon/moonbeam-demo/project.yaml Building and packing code ... Done! </p> <p>Note</p> <p>If you make changes to the <code>project.ts</code> file, you'll need to rebuild your project.</p> </li> <li> <p>Start up the Docker container for your indexer:</p> npmyarn <pre><code>npm run start:docker\n</code></pre> <pre><code>yarn start:docker\n</code></pre> <p> t found at block 171198 subquery-node_1  | 2025-04-07T04:29:52.601Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171203 subquery-node_1  | 2025-04-07T04:29:52.663Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.701Z &lt;benchmark&gt; INFO INDEXING: 3148.19 blocks/s. Target height: 5,105,255. Current height: 171,205. Estimated time remaining: 0 days 00 hours 26 mins subquery-node_1  | 2025-04-07T04:29:52.710Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.717Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.739Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.750Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.765Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.780Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.807Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.826Z &lt;sandbox-#3&gt; INFO New transfer event found at block 171205 subquery-node_1  | 2025-04-07T04:29:52.864Z &lt;sandbox-#3&gt; INFO New transfer event </p> </li> <li> <p>Head to <code>http://localhost:3000</code> to open the GraphQL playground and submit queries. You can open up the DOCS or SCHEMA tab on the playground as a reference when creating your queries.</p> <p>Note</p> <p>It may take a few minutes before the GraphQL server is ready. You'll be able to access the playground after you see the following log:</p> <pre><code>substrate-demo-graphql-engine-1  | &lt;subql-query&gt; INFO Started playground at `http://localhost:3000`\n</code></pre> <p></p> </li> </ol> <p>And that's it! For a step-by-step tutorial on how to use the <code>moonbeam-substrate-evm-starter</code> template project, you can refer to SubQuery's Moonbeam (EVM) Quick Start documentation.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/indexers/subsquid/","title":"Indexing Moonbeam with SQD (formerly Subsquid)","text":""},{"location":"builders/integrations/indexers/subsquid/#introduction","title":"Introduction","text":"<p>SQD (formerly Subsquid) is a data network that allows rapid and cost-efficient retrieval of blockchain data from 100+ chains using SQD\u2019s decentralized data lake and open-source SDK. In very simple terms, SQD can be thought of as an ETL (extract, transform, and load) tool with a GraphQL server included. It enables comprehensive filtering, pagination, and even full-text search capabilities.</p> <p>SQD has native and full support for both Ethereum Virtual Machine (EVM) and Substrate data. Since Moonbeam is a Substrate-based smart contact platform that is EVM-compatible, SQD can be used to index both EVM and Substrate-based data. SQD offers a Substrate Archive and Processor and an EVM Archive and Processor. The Substrate Archive and Processor can be used to index both Substrate and EVM data. This allows developers to extract on-chain data from any of the Moonbeam networks and process EVM logs as well as Substrate entities (events, extrinsics, and storage items) in one single project and serve the resulting data with one single GraphQL endpoint. If you exclusively want to index EVM data, it is recommended to use the EVM Archive and Processor.</p> <p>This quick-start guide will show you how to create Substrate and EVM projects with SQD and configure it to index data on Moonbeam.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/indexers/subsquid/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started with SQD, you'll need to have the following:</p> <ul> <li>Node.js version 16 or newer</li> <li>Docker</li> <li>Squid CLI</li> </ul> <p>Note</p> <p>The Squid template is not compatible with <code>yarn</code>, so you'll need to use <code>npm</code> instead.</p>"},{"location":"builders/integrations/indexers/subsquid/#index-substrate-calls-events","title":"Index Substrate Data on Moonbeam","text":"<p>To get started indexing Substrate data on Moonbeam, you'll need to create a SQD project and configure it for Moonbeam by taking the following steps:</p> <ol> <li> <p>Create a SQD project based on the Substrate template by running:</p> <pre><code>sqd init INSERT_SQUID_NAME --template substrate\n</code></pre> <p>For more information on getting started with this template, please check out the Quickstart: Substrate chains guide on SQD's documentation site.</p> </li> <li> <p>Navigate into the root directory of your Squid project and install dependencies by running:  </p> <pre><code>npm ci\n</code></pre> </li> <li> <p>To configure your SQD project to run on Moonbeam, you'll need to update the <code>typegen.json</code> file. The <code>typegen.json</code> file is responsible for generating TypeScript interface classes for your data. Depending on the network you're indexing data on, the <code>specVersions</code> value in the <code>typegen.json</code> file should be configured as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>\"specVersions\": \"https://v2.archive.subsquid.io/metadata/moonbeam\",\n</code></pre> <pre><code>\"specVersions\": \"https://v2.archive.subsquid.io/metadata/moonriver\",\n</code></pre> <pre><code>\"specVersions\": \"https://v2.archive.subsquid.io/metadata/moonbase\",\n</code></pre> </li> <li> <p>Modify the <code>src/processor.ts</code> file, which is where Squids instantiate the processor, configure it, and attach handler functions. The processor fetches historical on-chain data from an Archive, which is a specialized data lake. You'll need to configure your processor to pull data from the Archive that corresponds to the network you are indexing data on:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>const processor = new SubstrateBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_API_ENDPOINT',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonbeam-mainnet'\n  archive: lookupArchive('moonbeam', {type: 'Substrate', release: 'ArrowSquid'}),\n})\n</code></pre> <pre><code>const processor = new SubstrateBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_API_ENDPOINT',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonriver-mainnet'\n  archive: lookupArchive('moonriver', {type: 'Substrate', release: 'ArrowSquid'}),\n})\n</code></pre> <pre><code>const processor = new SubstrateBatchProcessor();\nprocessor.setDataSource({\n  chain: 'https://rpc.api.moonbase.moonbeam.network',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonbase-testnet'\n  archive: lookupArchive('moonbase', {type: 'Substrate', release: 'ArrowSquid'}),\n})\n</code></pre> <p>Note</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> </li> <li> <p>There's one more quick change to make to the template. The SQD Substrate template is configured to process Substrate account types, but Moonbeam uses Ethereum-style accounts. The <code>getTransferEvents</code> function in the <code>src/main.ts</code> file will iterate through the events ingested by <code>processor.ts</code> and store the relevant <code>transfer</code> events in the database. In the <code>getTransferEvents</code> function, remove the ss58 encoding of the <code>from</code> and <code>to</code> fields. In an unmodified Substrate template, the <code>from</code> and <code>to</code> fields are ss58 encoded as shown:</p> <pre><code>from: ss58.codec('kusama').encode(rec.from),\nto: ss58.codec('kusama').encode(rec.to),\n</code></pre> <p>After removing the ss58 encoding, the respective lines are:</p> <pre><code>from: rec.from, \nto: rec.to, \n</code></pre> </li> </ol> <p>And that's all you have to do to configure your SQD project to index Substrate data on Moonbeam! Now you can update the <code>schema.graphql</code>, <code>typegen.json</code>, <code>src/main.ts</code>, and <code>src/processor.ts</code> files to index the data you need for your project! Next, take the steps in the Run your Indexer section to run your indexer and query your Squid.</p>"},{"location":"builders/integrations/indexers/subsquid/#index-ethereum-contracts","title":"Index Ethereum Data on Moonbeam","text":"<p>To get started indexing EVM data on Moonbeam, you'll need to create a SQD project and configure it for Moonbeam by taking the following steps:</p> <ol> <li> <p>You can create a SQD project for EVM data by using the generic EVM template or you can use the ABI template for indexing data related to a specific contract:</p> EVMABI <pre><code>sqd init INSERT_SQUID_NAME --template evm\n</code></pre> <pre><code>sqd init INSERT_SQUID_NAME --template abi\n</code></pre> <p>For more information on getting started with both of these templates, please check out the following SQD docs:</p> <ul> <li>Quickstart: EVM chains</li> <li>Quickstart: generate from ABI</li> </ul> </li> <li> <p>Navigate into the root directory of your Squid project and install dependencies by running:</p> <pre><code>npm ci\n</code></pre> </li> <li> <p>Modify the <code>src/processor.ts</code> file, which is where Squids instantiate the processor, configure it, and attach handler functions. The processor fetches historical on-chain data from an Archive, which is a specialized data lake. You'll need to configure your processor to pull data from the Archive that corresponds to the network you are indexing data on:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>const processor = new EvmBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_API_ENDPOINT',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonbeam-mainnet'\n  archive: lookupArchive('moonbeam', { type: 'EVM' })\n})\n</code></pre> <pre><code>const processor = new EvmBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_API_ENDPOINT',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonriver-mainnet'\n  archive: lookupArchive('moonriver', { type: 'EVM' }),\n})\n</code></pre> <pre><code>const processor = new EvmBatchProcessor();\nprocessor.setDataSource({\n  chain: 'https://rpc.api.moonbase.moonbeam.network',\n  // Resolves to 'https://v2.archive.subsquid.io/network/moonbase-testnet'\n  archive: lookupArchive('moonbase', { type: 'EVM' }),\n})\n</code></pre> <p>Note</p> <p>To configure your project for Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> </li> </ol> <p>And that's all you have to do to configure your SQD project to index EVM data on Moonbeam! Now you can update the <code>schema.graphql</code>, <code>src/main.ts</code>, and <code>src/processor.ts</code> files to index the data you need for your project! Continue with the steps in the following section to run your indexer and query your Squid.</p>"},{"location":"builders/integrations/indexers/subsquid/#run-your-indexer","title":"Run Your Indexer","text":"<p>These steps apply to both Substrate and EVM indexers. Running your SQD indexer after you've properly configured it takes only a few steps:  </p> <ol> <li> <p>Launch Postgres by running:</p> <pre><code>sqd up\n</code></pre> </li> <li> <p>Inspect and run the processor:</p> <pre><code>sqd process\n</code></pre> </li> <li> <p>Open a separate terminal window in the same directory, then start the GraphQL server:</p> <pre><code>sqd serve\n</code></pre> </li> <li> <p>You can query your template Substrate or EVM Squid with the below sample queries. If you've modified the template Squid to index different data, you'll need to modify this query accordingly</p> Substrate IndexerEVM Indexer <pre><code>query MyQuery {\n  accountsConnection(orderBy: id_ASC) {\n    totalCount\n  }\n}\n</code></pre> <pre><code>query MyQuery {\n  burns(orderBy: value_DESC) {\n    address\n    block\n    id\n    txHash\n    value\n  }\n}\n</code></pre> </li> </ol> <p>For additional examples and workflows, refer to the SQD documentation.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/oracles/api3/","title":"Use API3 To Request Off-Chain Data on Moonbeam","text":""},{"location":"builders/integrations/oracles/api3/#introduction","title":"Introduction","text":"<p>API3 is a decentralized solution for delivering traditional API services to smart contract platforms in an easily accessible and scalable way. It is governed by a Decentralized Autonomous Organization (DAO), the API3 DAO. API3 enables developers to access off-chain resources from within their smart contracts without worrying about security implications. API3 makes this possible through Airnodes, which are first-party oracles, and on-chain data feeds sourced from these oracles.</p> <p>Developers can use Airnode to request off-chain data inside their smart contracts on Moonbeam networks. An Airnode is a first-party oracle that pushes off-chain API data to your on-chain contract. Airnode lets API providers easily run their own first-party oracle nodes. That way, they can provide data to any on-chain dApp interested in their services, all without an intermediary.</p> <p>An on-chain smart contract requests the RRP (Request Response Protocol) contract (<code>AirnodeRrpV0.sol</code>) that adds the request to the event logs. The Airnode then accesses the event logs, fetches the API data, and performs a callback to the requester with the requested data.</p> <p></p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/oracles/api3/#calling-an-airnode","title":"Request Off-Chain Data From an Airnode","text":"<p>Requesting off-chain data essentially involves triggering an Airnode and getting its response through your smart contract. The smart contract in this case would be the requester contract, which will make a request to the desired off-chain Airnode and then capture its response.</p> <p>The requester calling an Airnode primarily focuses on two tasks:</p> <ul> <li>Making the request</li> <li>Accepting and decoding the response</li> </ul> <p></p> <p>Here is an example of a basic requester contract to request data from an Airnode:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@api3/airnode-protocol/contracts/rrp/requesters/RrpRequesterV0.sol\";\nimport \"@openzeppelin/contracts@4.9.5/access/Ownable.sol\";\n\n// A Requester that will return the requested data by calling the specified Airnode.\ncontract Requester is RrpRequesterV0, Ownable {\n    mapping(bytes32 =&gt; bool) public incomingFulfillments;\n    mapping(bytes32 =&gt; int256) public fulfilledData;\n\n    // Make sure you specify the right _rrpAddress for your chain while deploying the contract.\n    constructor(address _rrpAddress) RrpRequesterV0(_rrpAddress) {}\n\n    // To receive funds from the sponsor wallet and send them to the owner.\n    receive() external payable {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    // The main makeRequest function that will trigger the Airnode request.\n    function makeRequest(\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        bytes calldata parameters\n\n    ) external {\n        bytes32 requestId = airnodeRrp.makeFullRequest(\n            airnode,                        // airnode address\n            endpointId,                     // endpointId\n            sponsor,                        // sponsor's address\n            sponsorWallet,                  // sponsorWallet\n            address(this),                  // fulfillAddress\n            this.fulfill.selector,          // fulfillFunctionId\n            parameters                      // encoded API parameters\n        );\n        incomingFulfillments[requestId] = true;\n    }\n\n    function fulfill(bytes32 requestId, bytes calldata data)\n        external\n        onlyAirnodeRrp\n    {\n        require(incomingFulfillments[requestId], \"No such request made\");\n        delete incomingFulfillments[requestId];\n        int256 decodedData = abi.decode(data, (int256));\n        fulfilledData[requestId] = decodedData;\n    }\n\n    // To withdraw funds from the sponsor wallet to the contract.\n    function withdraw(address airnode, address sponsorWallet) external onlyOwner {\n        airnodeRrp.requestWithdrawal(\n        airnode,\n        sponsorWallet\n        );\n    }\n}\n</code></pre> <p>You can also try deploying the example contract on Remix.</p>"},{"location":"builders/integrations/oracles/api3/#contract-addresses","title":"Contract Addresses","text":"<p>The <code>_rrpAddress</code> is the main <code>airnodeRrpAddress</code>. The RRP contracts have already been deployed on-chain. The addresses for the <code>_rrpAddress</code> on Moonbeam networks are as follows:</p> MoonbeamMoonriverMoonbase Alpha Contract Addresses AirnodeRrpV0 <code>0xa0AD79D995DdeeB18a14eAef56A549A04e3Aa1Bd</code> Contract Addresses AirnodeRrpV0 <code>0xa0AD79D995DdeeB18a14eAef56A549A04e3Aa1Bd</code> Contract Addresses AirnodeRrpV0 <code>0xa0AD79D995DdeeB18a14eAef56A549A04e3Aa1Bd</code>"},{"location":"builders/integrations/oracles/api3/#request-params","title":"Request Parameters","text":"<p>The <code>makeRequest()</code> function expects the following parameters to make a valid request:</p> <ul> <li><code>airnode</code> - specifies the Airnode address</li> <li><code>endpointId</code> - specifies which endpoint to be used</li> <li><code>sponsor</code> and <code>sponsorWallet</code> - specifies which wallet will be used to fulfill the request</li> <li><code>parameters</code> - specifies the API and Reserved Parameters (see Airnode ABI specifications for how these are encoded). Parameters can be encoded off-chain using the <code>@airnode-abi</code> library</li> </ul>"},{"location":"builders/integrations/oracles/api3/#response-params","title":"Response Parameters","text":"<p>The callback to the requester contract contains two parameters:</p> <ul> <li><code>requestId</code> - first acquired when making the request and passed here as a reference to identify the request for which the response is intended</li> <li><code>data</code> - in case of a successful response, this is the requested data encoded and contains a timestamp in addition to other response data. Decode it using the <code>decode()</code> function from the <code>abi</code> object</li> </ul> <p>Note</p> <p>Sponsors should not fund a <code>sponsorWallet</code> with more than they can trust the Airnode with, as the Airnode controls the private key to the <code>sponsorWallet</code>. The deployer of such Airnode undertakes no custody obligations, and the risk of loss or misuse of any excess funds sent to the <code>sponsorWallet</code> remains with the sponsor.</p>"},{"location":"builders/integrations/oracles/api3/#dapis","title":"dAPIs: API3 Data Feeds","text":"<p>dAPIs are continuously updated streams of off-chain data, such as the latest cryptocurrency, stock, and commodity prices. They can power decentralized applications such as DeFi lending, synthetic assets, stablecoins, derivatives, NFTs, and more.</p> <p>The data feeds are continuously updated by first-party oracles using signed data. DApp owners can read the on-chain value of any dAPI in real-time.</p> <p>Because they are composed of first-party data feeds, dAPIs offer security, transparency, cost-efficiency, and scalability in a turnkey package.</p> <p></p> <p>To learn more about how dAPIs work, please refer to API3's documentation.</p>"},{"location":"builders/integrations/oracles/api3/#subscribing-to-dapis","title":"Subscribe to dAPIs","text":"<p>The API3 Market lets users access dAPIs on Moonbeam, Moonriver, and the Moonbase Alpha TestNet (currently labeled as the Moonbeam TestNet).</p> <p>From the API3 Market home page, you can search for a given chain. After selecting the chain, you can view the list of available dAPIs and click on one for more information. For example, you can click on the <code>USDT/USD</code> pair available for Moonbeam to view the parameters of the dAPI, including the deviation and the heartbeat.</p> <p>The supported parameters for dAPIs are:</p> Deviation Heartbeat 0.25% 24 hours 0.5% 24 hours 1% 24 hours 5% 24 hours <p></p>"},{"location":"builders/integrations/oracles/api3/#select-a-dapi","title":"Configure and Activate a dAPI","text":"<p>Once you've selected a dAPI to interact with, check the expiration date and update the parameters as needed. You can update the parameters and extend the subscription by purchasing a new configuration. If the dAPI has been activated and the configurations listed will work for you, you can skip ahead to the next section to learn how to interact with the dAPI.</p> <p>To purchase a plan with new configurations, click on Purchase new plan and take the following steps:</p> <ol> <li>Select your parameters</li> <li>Click on Connect Wallet</li> </ol> <p></p> <p>Once connected, you'll be able to purchase your new plan. Click on Purchase and sign the transaction. After the transaction has been confirmed, you will be able to see the updated configuration for the dAPI.</p>"},{"location":"builders/integrations/oracles/api3/#get-data","title":"Get Data from a dAPI","text":"<p>To interact with a dAPI, you'll need to get the proxy address for it. Click on the Integrate button from the dAPI details page. Then, on the integration page, copy the proxy address.</p> <p></p> <p>With the proxy address in hand, you'll be able to integrate the dAPI into a smart contract. Here's an example of a basic contract that reads from a dAPI:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts@4.9.5/access/Ownable.sol\";\nimport \"@api3/contracts/api3-server-v1/proxies/interfaces/IProxy.sol\";\n\ncontract DataFeedReaderExample is Ownable {\n    // The proxy contract address obtained from the API3 Market UI\n    address public proxyAddress;\n\n    // Updating the proxy contract address is a security-critical\n    // action. In this example, only the owner is allowed to do so\n    function setProxyAddress(address _proxyAddress) public onlyOwner {\n        proxyAddress = _proxyAddress;\n    }\n\n    function readDataFeed()\n        external\n        view\n        returns (int224 value, uint256 timestamp)\n    {\n        // Use the IProxy interface to read a dAPI via its\n        // proxy contract\n        (value, timestamp) = IProxy(proxyAddress).read();\n        // If you have any assumptions about `value` and `timestamp`,\n        // make sure to validate them after reading from the proxy\n    }\n}\n</code></pre> <p>The example contract contains two functions:</p> <ul> <li><code>setProxyAddress()</code> - used to set the address of the dAPI proxy contract</li> <li><code>readDataFeed()</code> - a <code>view</code> function that returns the latest price of the set dAPI</li> </ul> <p>Try deploying it on Remix!</p>"},{"location":"builders/integrations/oracles/api3/#additional-resources","title":"Additional Resources","text":"<p>Here are some additional developer resources:</p> <ul> <li>API3 Market</li> <li>API3 Docs</li> <li>API3 DAO GitHub</li> <li>API3 Medium</li> <li>API3 YouTube</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/oracles/dia/","title":"Introduction to DIA Oracles","text":""},{"location":"builders/integrations/oracles/dia/#introduction","title":"Introduction","text":"<p>DIA offers customizable oracles that are tailored to each dApp\u2019s needs. Each oracle can be customized in several ways, including data sources, data cleansing filters, pricing and computational methodologies, update mechanisms, and more. This ensures that the data and oracle remain robust and resilient to market conditions and provide a global market price as well as specific individual or cross-chain market prices.</p> <p>By collecting billions of raw trades directly from over 90 sources, including CEXs, DEXs, and NFT marketplaces, DIA enables full transparency, customization, and control throughout the entire value stack. DIA's data and oracle suite comprise price feeds for 20,000+ assets, including cryptocurrencies, NFT collections, and liquid-staked tokens, as well as random number generation and other data feed types.</p> <p>You can visit DIA's documentation to learn how to Request a Custom Oracle.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/oracles/dia/#token-price-feeds","title":"Token Price Feeds","text":"<p>DIA token price feeds provide smart contracts with real-time price information for 3,000+ cryptocurrencies, sourced transparently from 90+ trusted, high-volume DEXs and CEXs.</p>"},{"location":"builders/integrations/oracles/dia/#moonbeam-demo-price-oracles","title":"Moonbeam Demo Price Oracles","text":"<p>DIA has deployed the following demo oracles for the Moonbeam community, which provide a limited selection of cryptocurrency price feeds with predefined configuration settings:</p> Network Contract Address Moonbeam <code>0x1f1BAe8D7a2957CeF5ffA0d957cfEDd6828D728f</code> Moonriver <code>0x11f74b94afb5968119c98ea277a2b73208bb39ab</code> Moonbase Alpha <code>0xe23d8713aa3a0a2c102af772d2467064821b8d46</code> <p>The demo oracle contracts deployed to Moonbeam are the DIA Key-Value Oracle Contract V2. The contract is structured as follows:</p> <pre><code>pragma solidity 0.7.4;\n\ncontract DIAOracleV2 {\n    mapping (string =&gt; uint256) public values;\n    address oracleUpdater;\n\n    event OracleUpdate(string key, uint128 value, uint128 timestamp);\n    event UpdaterAddressChange(address newUpdater);\n\n    constructor() {\n        oracleUpdater = msg.sender;\n    }\n\n    function setValue(string memory key, uint128 value, uint128 timestamp) public {\n        require(msg.sender == oracleUpdater);\n        uint256 cValue = (((uint256)(value)) &lt;&lt; 128) + timestamp;\n        values[key] = cValue;\n        emit OracleUpdate(key, value, timestamp);\n    }\n\n    function getValue(string memory key) external view returns (uint128, uint128) {\n        uint256 cValue = values[key];\n        uint128 timestamp = (uint128)(cValue % 2**128);\n        uint128 value = (uint128)(cValue &gt;&gt; 128);\n        return (value, timestamp);\n    }\n\n    function updateOracleUpdaterAddress(address newOracleUpdaterAddress) public {\n      require(msg.sender == oracleUpdater);\n        oracleUpdater = newOracleUpdaterAddress;\n        emit UpdaterAddressChange(newOracleUpdaterAddress);\n    }\n}\n</code></pre> <p>Note</p> <p>DIA demo oracles are not intended for use in production environments. Developers can request a dedicated, production-ready oracle with custom price feeds and configuration settings. To start the request process, you can check out the Request a Custom Oracle documentation.</p>"},{"location":"builders/integrations/oracles/dia/#price-feeds","title":"Included Price Feeds","text":"<p>The price feeds included with the demo oracles are:</p> <ul> <li>DIA/USD</li> <li>BTC/USD</li> <li>USDC/USD</li> </ul>"},{"location":"builders/integrations/oracles/dia/#how-to-access-dia-oracles","title":"How to Access DIA Oracles","text":"<p>The steps for accessing a price value on DIA oracles are as follows:</p> <ol> <li>Access your oracle smart contract on Moonbeam.</li> <li>Call <code>getValue(pair_name)</code> with <code>pair_name</code> being the full pair name, such as <code>BTC/USD</code>. You can use the Read Contract functionality under the Contract tab of the contract on Moonscan to execute this call.</li> </ol> <p>The response contains two values:</p> <ul> <li>The current asset price in USD with a fix-comma notation of 8 decimals.</li> <li>The UNIX timestamp of the last oracle update.</li> </ul> <p>You can find DIA's oracle integration samples in Solidity and Vyper languages by visiting the Fetch Price Data guide on DIA's documentation site.</p>"},{"location":"builders/integrations/oracles/dia/#supported-token-api-endpoints","title":"Supported Token API Endpoints","text":"<p>DIA also supports Rest and GraphQL endpoints to return cryptocurrency price data. You can visit the DIA documentation to see all API endpoints.</p> <p>For example, you can use the following JavaScript scripts to access the BTC/USD price feed:</p> RestGraphQL <pre><code>const axios = require('axios');\n\nconst options = {\n  method: 'GET',\n  url: 'https://api.diadata.org/v1/assetQuotation/Bitcoin/0x0000000000000000000000000000000000000000',\n  headers: { 'Content-Type': 'application/json' },\n};\n\naxios\n  .request(options)\n  .then(function (response) {\n    console.log(response.data);\n  })\n  .catch(function (error) {\n    console.error(error);\n  });\n</code></pre> <pre><code>const axios = require('axios');\n\nconst url = 'https://api.diadata.org/graphql/query';\n\nconst query = `\n  {\n    GetFeed(\n      Filter: \"mair\",\n      BlockSizeSeconds: 480,\n      BlockShiftSeconds: 480,\n      StartTime: 1690449575,\n      EndTime: 1690535975,\n      FeedSelection: [\n        {\n          Address: \"0x0000000000000000000000000000000000000000\",\n          Blockchain:\"Bitcoin\",\n          Exchangepairs:[],\n        },\n      ],\n    )\n    {\n      Name\n      Time\n      Value\n      Pools\n      Pairs\n    }\n  }`;\n\nconst data = {\n  query: query,\n};\n\naxios\n  .post(url, data)\n  .then((response) =&gt; {\n    console.log(response.data);\n  })\n  .catch((error) =&gt; {\n    console.error('Request failed:', error.message);\n  });\n</code></pre> <p>You can refer to DIA's documentation on Rest API endpoints and the GraphQL Endpoint for information on the parameters and return data.</p>"},{"location":"builders/integrations/oracles/dia/#nft-floor-price-feeds","title":"NFT Floor Price Feeds","text":"<p>DIA NFT floor price feeds provide smart contracts with real-time price information for 18,000+ NFT collections, sourced on-chain with 100% transparency from multiple cross-chain NFT marketplaces.</p> <p>Please refer to DIA's documentation to find out how you can request a custom NFT oracle for NFTs on Moonbeam.</p>"},{"location":"builders/integrations/oracles/dia/#random-number-generation","title":"Random Number Generation","text":"<p>DIA xRandom provides smart contracts with unpredictable and unbiased random numbers, facilitating the development of on-chain use cases such as lotteries, prediction markets, NFT launches, and more.</p> <p>DIA leverages the Drand public randomness beacon, and updates its oracle with round numbers, randomness and a signature. Drand runs distributed nodes to produce their randomness beacon. Drand uses Pedersen's DKG (Distributed Key Generation) protocol to create collective private and public keys. Participants in their League of Entropy then generate randomness in rounds and broadcast it together with its signature.</p> <p>To learn more about Drand\u2019s randomness beacon, watch the On-Chain Randomness Oracle | DIA Developer Tutorial and read Drand\u2019s documentation.</p>"},{"location":"builders/integrations/oracles/dia/#moonbeam-demo-randomness-oracle","title":"Moonbeam Demo Randomness Oracle","text":"<p>DIA has deployed a demo oracle on Moonbase Alpha, which can be accessed at the following address:</p> <pre><code>0x48d351ab7f8646239bbade95c3cc6de3ef4a6cec\n</code></pre> <p>The DIA randomness smart contract is structured as follows:</p> <pre><code>pragma solidity ^0.8.30;\n\ncontract DIARandomOracle {\n  struct Random {\n    string randomness;\n    string signature;\n    string previousSignature;\n  }\n\n  mapping(uint256 =&gt; Random) public values;\n  uint256 public lastRound = 0;\n  address public oracleUpdater;\n  event OracleUpdate(string key, uint128 value, uint128 timestamp);\n  event UpdaterAddressChange(address newUpdater);\n\n  constructor() {\n      oracleUpdater = msg.sender;\n  }\n\n  function setRandomValue(\n    uint256 _round,\n    string memory _randomness,\n    string memory _signature,\n    string memory _previousSignature\n  ) public {\n    require(msg.sender == oracleUpdater, \"not a updater\");\n    require(lastRound &lt; _round, \"old round\");\n    lastRound = _round;\n    values[_round] = Random(_randomness, _signature, _previousSignature);\n  }\n\n  function getValue(uint256 _round) external view returns (Random memory) {\n    return values[_round];\n  }\n\n  function updateOracleUpdaterAddress(address newOracleUpdaterAddress)\n    public\n  {\n    require(msg.sender == oracleUpdater, \"not a updater\");\n    oracleUpdater = newOracleUpdaterAddress;\n    emit UpdaterAddressChange(newOracleUpdaterAddress);\n  }\n\n  function getRandomValueFromRound(uint256 _round)\n    external\n    view\n    returns (string memory)\n  {\n    return values[_round].randomness;\n  }\n\n  function getRandomValueFromRoundWithSignature(uint256 _round)\n    external\n    view\n    returns (Random memory)\n  {\n    return values[_round];\n  }\n\n    function getLastRound() public view returns (uint256) {\n    return lastRound;\n  }\n}\n</code></pre> <p>Note</p> <p>DIA demo oracles are not intended for use in production environments. Developers can request a dedicated, production-ready randomness oracle. To start the request process, you can contact the integrations team on Telegram.</p>"},{"location":"builders/integrations/oracles/dia/#how-to-use-the-dia-randomness-oracle","title":"How to Use the DIA Randomness Oracle","text":"<p>The steps for accessing a published random value are as follows:</p> <ol> <li>Access your randomness oracle smart contract on Moonbeam.</li> <li>Call <code>getLastRound()</code>to obtain the ID of the latest published round. You can use the Read Contract functionality under the Contract tab of the contract on Moonscan to execute this call.</li> <li>Call <code>getRandomValueFromRound(uint256 _round)</code> using the obtained round ID. Again, you can use Moonscan to quickly execute this call.</li> </ol> <p>The response contains the randomness value.</p> <p>The signature can also be requested by calling <code>getRandomValueFromRoundWithSignature(uint256 _round)</code>, which returns a tuple containing the randomness value, the signature, and the previous signature.</p> <p>To learn how to deploy a randomness-consuming contract on Moonbeam, please refer to the Deploying a Randomness Consuming Smart Contract on EVM chains with DIA xRandom Oracle video tutorial.</p>"},{"location":"builders/integrations/oracles/dia/#resources","title":"Resources","text":"<ul> <li>X</li> <li>Discord</li> <li>Website</li> <li>Docs</li> <li>Explore data</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/integrations/oracles/supra/","title":"Supra Oracles","text":""},{"location":"builders/integrations/oracles/supra/#introduction","title":"Introduction","text":"<p>Supra is a novel, high-throughput oracle and intralayer: a vertically integrated toolkit of cross-chain solutions (data oracles, asset bridge, automation network, and more) that interlink all blockchains, public (L1s and L2s) or private (enterprises), including Moonbeam.</p> <p>Supra provides decentralized oracle price feeds that can be used for on-chain and off-chain use cases such as spot and perpetual DEXes, lending protocols, and payment protocols.</p> <p>This page provides everything you need to know to get started with Supra on Moonbeam.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/integrations/oracles/supra/#price-feeds","title":"How to use Supra's Price Feeds","text":"<p>Supra uses a pull model as a customized approach that publishes price data upon request. It combines Web2 and Web3 methods to achieve low latency when sending data from Supra to destination chains. The process involves the following steps:</p> <ol> <li>Web2 methods are used to retrieve price data from Supra.</li> <li>Smart contracts are utilized for cryptographically verifying and writing the latest price data on-chain, where it lives on immutable ledgers, using Supra's Pull Oracle V1.</li> <li>Once the data has been written on-chain, the most recently published price feed data will be available in Supra's Storage contract.</li> </ol> <p>The addresses for Supra's contracts on Moonbeam are as follows:</p> MoonbeamMoonbase Alpha Contract Address Pull Oracle 0x2FA6DbFe4291136Cf272E1A3294362b6651e8517 Storage 0xD02cc7a670047b6b012556A88e275c685d25e0c9 Contract Address Pull Oracle 0xaa2f56843Cec7840F0C106F0202313d8d8CB13d6 Storage 0x4591d1B110ad451d8220d82252F829E8b2a91B17 <p>Note</p> <p>Moonriver is not supported at this time.</p>"},{"location":"builders/integrations/oracles/supra/#list-of-available-price-feeds","title":"List of Available Price Feeds","text":"<p>To view a complete list of the available data pairs provided by Supra, please check out their data feeds catalog on their documentation site.</p> <p>To interact with any of these data pairs, you'll need to take note of the pair's Pair ID.</p>"},{"location":"builders/integrations/oracles/supra/#try-it-out","title":"Try It Out","text":"<p>Try out a basic example of how to fetch price data using Supra's pull model by following the steps mentioned in the previous section or by referencing the Supra documentation.</p>"},{"location":"builders/integrations/oracles/supra/#connect-with-supra","title":"Connect with Supra","text":"<p>Still looking for answers? Supra's got them! Check out all the ways you can reach the Supra team:</p> <ul> <li>Visit Supra's websites at supraoracles.com.</li> <li>Read their docs.</li> <li>Chat with them on Telegram.</li> <li>Follow them on X.</li> <li>Join their Discord.</li> <li>Check out their Youtube.</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/interoperability/mrl/","title":"Moonbeam Routed Liquidity","text":""},{"location":"builders/interoperability/mrl/#introduction","title":"Introduction","text":"<p>Moonbeam Routed Liquidity (MRL) refers to a use case in which liquidity in any blockchain ecosystem that Moonbeam is connected to can be routed to Polkadot parachains. This is possible because of multiple components that work together:</p> <ul> <li>General Message Passing (GMP) - technology connecting multiple blockchains, including Moonbeam. With it, developers can pass messages with arbitrary data, and tokens can be sent across non-parachain blockchains through chain-agnostic GMP protocols</li> <li>Cross-Consensus Message Passing (XCM) - Polkadot's flavor of GMP. Main technology driving cross-chain interactions between Polkadot and its parachains, including Moonbeam</li> <li>XCM-Enabled ERC-20s - also referred to as local XC-20s, are all of the ERC-20 tokens that exist on Moonbeam's EVM that are XCM-enabled out of the box</li> <li>GMP Precompile - a precompiled contract that acts as an interface between a message passed from Wormhole GMP protocol and XCM</li> </ul> <p>These components are combined to offer seamless liquidity routing into parachains through Moonbeam. Liquidity can be routed to parachains using either the GMP Precompile or traditional smart contracts that interact with XCM-related precompiles, like the X-Tokens Precompile.</p> <p>GMP protocols typically move assets in a lock/mint or burn/mint fashion. This liquidity exists on Moonbeam normally as ERC-20 tokens. All ERC-20s on Moonbeam are now XCM-enabled, meaning they can now exist as XC-20s in any other parachain, as long as they are registered on the other parachain. XCM-enabled ERC-20s are referred to as local XC-20s on Moonbeam.</p> <p>MRL is currently available through Wormhole-connected chains, but nothing stops a parachain team from implementing a similar pathway through a different GMP provider.</p> <p>This guide will primarily cover the process of integrating with Wormhole's SDKs and interfaces so that your parachain can access liquidity from non-parachain blockchains through Moonbeam. It will also cover the requirements to get started and the tokens available through Wormhole.</p>"},{"location":"builders/interoperability/mrl/#prerequisites","title":"Prerequisites","text":"<p>To begin an MRL integration with your parachain, you will first need to:</p> <ul> <li>Establish a cross-chain integration with Moonbeam via HRMP channels so assets can be sent from Moonbeam to your parachain</li> <li>Register Moonbeam\u2019s asset on your parachain. This is required due to a temporary drawback of pallets that send XCM messages for asset transfer, making Moonbeam\u2019s native gas asset the only asset that can be used as a cross-chain fee on the way back</li> <li>Register the local XC-20 token(s) you want routed to your parachain<ul> <li>Allow these local XC-20 token(s) to be used for XCM fees</li> </ul> </li> <li>Allow users to send the <code>Transact</code> XCM instruction (via <code>polkadotXcm.Send</code> or with the XCM Transactor Pallet), which enables remote EVM calls, allowing accounts on a remote parachain to interact with the bridging smart contracts on Moonbeam</li> </ul>"},{"location":"builders/interoperability/mrl/#mrl-through-wormhole","title":"MRL Through Wormhole","text":"<p>While MRL intends to encompass many different GMP providers, Wormhole is the first built for the public.After you have completed all of the prerequisites, to receive liquidity through Wormhole, you'll need to:</p> <ul> <li>Notify the Moonbeam team of your desire to integrate into the MRL program so that we can help you with the technical implementation</li> <li>Connect with the Wormhole team and other MRL-dependent frontends to finalize technical details and sync announcements. They will likely need the following information:<ul> <li>Parachain ID</li> <li>The account type that your parachain uses (i.e., AccountId32 or AccountKey20)</li> <li>The addresses and names of the tokens that you have registered</li> <li>An endpoint that a Wormhole Connect frontend can use</li> <li>Why do you want your parachain to be connected through Wormhole Connect?</li> </ul> </li> </ul>"},{"location":"builders/interoperability/mrl/#sending-tokens-through-wormhole","title":"Send Tokens Through Wormhole to a Parachain","text":"<p>MRL provides a one-click solution that allows you to define a multilocation as the final destination for your assets arriving from any Wormhole chain with a Wormhole Connect integration.</p> <p>To send tokens through Wormhole and MRL, user interfaces will use a mixture of the Wormhole TokenBridge and Moonbeam\u2019s GMP Precompile.</p> <p>Users transferring liquidity will invoke the <code>transferTokensWithPayload</code> method on the origin chain's deployment of the Wormhole TokenBridge smart contract, which implements the <code>ITokenBridge.sol</code> interface to send tokens to the GMP Precompile. This function requires a bytes payload, formatted as a SCALE-encoded multilocation object wrapped within another precompile-specific versioned type. To learn how to build this payload, please refer to the Building the Payload for Wormhole section of the GMP Precompile documentation.</p> <p>Wormhole relies on a set of distributed nodes that monitor the state on several blockchains. In Wormhole, these nodes are referred to as Guardians. The Guardian's role is to observe messages and sign the corresponding payloads. If 2/3rds of Wormhole's signing Guardians validate a particular message, the message becomes approved and can be received on other chains.</p> <p>The Guardian signatures and the message form a proof called a Verified Action Approval (VAA). These VAAs are delivered to their destinations by relayers within the Wormhole network. On the destination chain, the VAA is used to perform an action. In this case, the VAA is passed into the <code>wormholeTransferERC20</code> function of the GMP Precompile, which processes the VAA through the Wormhole bridge contract (which mints the tokens) and relays the tokens to a parachain using XCM messages. Please note that as a parachain integrating MRL, you will likely not need to implement or use the GMP Precompile.</p> <p>A relayer's only job is to pass the transactions approved by Wormhole Guardians to the destination chain. MRL is supported by some relayers already, but anyone can run one. Furthermore, users can manually execute their transaction in the destination chain when bridging through Wormhole and avoid relayers altogether.</p> <p></p>"},{"location":"builders/interoperability/mrl/#sending-tokens-back-through-wormhole","title":"Send Tokens From a Parachain Back Through Wormhole","text":"<p>To send tokens from a parachain back through Wormhole to a destination chain, a user must send a transaction, preferably using the <code>utility.batchAll</code> extrinsic, which will batch a token transfer and a remote execution action into a single transaction. For example, a batch with a <code>xTokens.transferMultiassets</code> call and a <code>polkadotXcm.send</code> call with the <code>Transact</code> instruction.</p> <p>The reason for batching is to offer a one-click solution. Nevertheless, for now, the user must also own xcGLMR (representation of GLMR) on the parachain. There are two main reasons as to why:</p> <ul> <li>Local XC-20s (XCM-enabled ERC-20s) can't be used to pay for XCM execution on Moonbeam. This was a design decision, as it was preferred to treat them as ERC-20s and utilize the native <code>transfer</code> function of the ERC-20 interface. Consequently, XCM instructions handling the XC-20s are only limited to moving funds from one account to another and don't understand the Holding Register that is inherent to the XCM flow</li> <li>Currently, XCM-related pallets limit XCM messages' ability to send tokens with different reserve chains. Consequently, you can't send an XC-20 and set the fee token to be the native parachain token</li> </ul> <p>Note that as of late 2024, the X-Tokens precompile now uses the Polkadot XCM pallet under the hood, replacing the X-Tokens pallet. Parachains using a different pallet must implement their own solution to transfer reserve and non-reserve assets in a single message.</p> <p>As an example, a brief overview of the entire process of sending MRL tokens from a parachain back through Wormhole to a destination chain is as follows:</p> <ol> <li>Send a batch transaction using the <code>batchAll</code> extrinsic of the Utility pallet that contains the following two calls.<ul> <li><code>xTokens.transferMultiassets</code> - sends xcGLMR and the local XC-20 to the user\u2019s Computed Origin account. The Computed Origin account is a keyless account on Moonbeam that an account on another parachain has control of via XCM</li> <li><code>polkadotXcm.send</code> - with the <code>Transact</code> instruction. Sends a remote EVM call via XCM to the Batch Precompile on Moonbeam, which batches the following two calls into a single remote EVM transaction using the <code>ethereumXcm.transact</code> extrinsic:<ul> <li><code>approve</code> (of the local XC-20 contract) - approves the Wormhole relayer to transfer the local XC-20</li> <li><code>transferTokensWithRelay</code> (of the relayer contract) - calls the <code>transferTokensWithPayload</code> function of the Wormhole TokenBridge smart contract on Moonbeam to transfer the tokens cross-chain, which broadcasts the message for the Wormhole Guardians to pick up</li> </ul> </li> </ul> </li> <li>The Guardian Network will pick up on the Wormhole transaction and sign it</li> <li>A Wormhole relayer will relay the tokens to the destination chain and destination account</li> </ol> <p></p> <p>Now that you have a general idea of the game plan, you can begin implementing it. The example in this guide will show you how to transfer assets from a parachain to Moonbase Alpha and back through Wormhole to the destination chain, but this guide can be adapted for Moonbeam.</p>"},{"location":"builders/interoperability/mrl/#calculate-computed-origin-account","title":"Calculate the Computed Origin Account","text":"<p>To send tokens back through Wormhole, you'll need to calculate the user's Computed Origin account (previously referred to as a multilocation-derivative account) on Moonbeam. This can be done off-chain using the <code>calculate-multilocation-derivative-account.ts</code> script from the xcm-tools repository. For more details, you can refer to the Computed Origins guide.</p> <p>Alternatively, the <code>multilocationToAddress</code> function of the XCM Utilities Precompile can also be used.</p>"},{"location":"builders/interoperability/mrl/#create-a-project","title":"Create a Project","text":"<p>You'll need to create a new project directory for the files you'll be building in this guide. Take the following steps to set up your project:</p> <ol> <li> <p>Create a new directory and change into the directory</p> <pre><code>mkdir wormhole-mrl-demo &amp;&amp; cd wormhole-mrl-demo\n</code></pre> </li> <li> <p>Create a <code>package.json</code> file:</p> <pre><code>npm init -y\n</code></pre> </li> <li> <p>Install packages that you'll need to build the remote EVM calls and the XCM extrinsics</p> <pre><code>npm i @polkadot/api ethers\n</code></pre> </li> <li> <p>Create the files that you'll need for this guide:</p> <ul> <li><code>build-transfer-multiassets-call.js</code> - for creating the <code>xTokens.transferMultiassets</code> extrinsic that transfers assets cross-chain. This contains the logic for the first call of the batch transaction</li> <li><code>build-remote-calldata.js</code> - for creating the encoded calldata that approves the Wormhole relayer to transfer the local XC-20 and initiates the transfer via the Wormhole TokenBridge contract. This is required for the second call of the batch transaction</li> <li><code>build-remote-evm-call.js</code> - to create the <code>polkadotXcm.send</code> extrinsic that executes the remote EVM call. This contains the logic for the second call of the batch transaction</li> <li><code>send-batch-transaction.js</code> - for assembling and sending the batch transaction for the asset transfer and the remote EVM call</li> </ul> <pre><code>touch build-transfer-multiassets.js build-remote-calldata.js \\\nbuild-remote-evm-call.js send-batch-transaction.js\n</code></pre> </li> <li> <p>Create a directory and files for the ABIs of each of the contracts you'll be working within this guide:</p> <pre><code>mkdir abi &amp;&amp; touch abi/ERC20.js abi/TokenRelayer.js abi/Batch.js\n</code></pre> ERC-20 Interface ABI ERC20.js<pre><code>export default [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'owner',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'spender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'value',\n        type: 'uint256',\n      },\n    ],\n    name: 'Approval',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'from',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'to',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'value',\n        type: 'uint256',\n      },\n    ],\n    name: 'Transfer',\n    type: 'event',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'owner',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: 'spender',\n        type: 'address',\n      },\n    ],\n    name: 'allowance',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'spender',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'to',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'from',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: 'to',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> TokenBridge Relayer ABI TokenRelayer.js<pre><code>export default [\n  {\n    inputs: [\n      {\n        internalType: 'uint16',\n        name: 'targetChainId',\n        type: 'uint16',\n      },\n      {\n        internalType: 'address',\n        name: 'token',\n        type: 'address',\n      },\n      {\n        internalType: 'uint8',\n        name: 'decimals',\n        type: 'uint8',\n      },\n    ],\n    name: 'calculateRelayerFee',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: 'feeInTokenDenomination',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'token',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: 'toNativeTokenAmount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint16',\n        name: 'targetChain',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes32',\n        name: 'targetRecipient',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'uint32',\n        name: 'batchId',\n        type: 'uint32',\n      },\n    ],\n    name: 'transferTokensWithRelay',\n    outputs: [\n      {\n        internalType: 'uint64',\n        name: 'messageSequence',\n        type: 'uint64',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: 'toNativeTokenAmount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint16',\n        name: 'targetChain',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes32',\n        name: 'targetRecipient',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'uint32',\n        name: 'batchId',\n        type: 'uint32',\n      },\n    ],\n    name: 'wrapAndTransferEthWithRelay',\n    outputs: [\n      {\n        internalType: 'uint64',\n        name: 'messageSequence',\n        type: 'uint64',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n];\n</code></pre> Batch Precompile ABI Batch.js<pre><code>export default [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'index',\n        type: 'uint256',\n      },\n    ],\n    name: 'SubcallFailed',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'index',\n        type: 'uint256',\n      },\n    ],\n    name: 'SubcallSucceeded',\n    type: 'event',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address[]',\n        name: 'to',\n        type: 'address[]',\n      },\n      {\n        internalType: 'uint256[]',\n        name: 'value',\n        type: 'uint256[]',\n      },\n      {\n        internalType: 'bytes[]',\n        name: 'callData',\n        type: 'bytes[]',\n      },\n      {\n        internalType: 'uint64[]',\n        name: 'gasLimit',\n        type: 'uint64[]',\n      },\n    ],\n    name: 'batchAll',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address[]',\n        name: 'to',\n        type: 'address[]',\n      },\n      {\n        internalType: 'uint256[]',\n        name: 'value',\n        type: 'uint256[]',\n      },\n      {\n        internalType: 'bytes[]',\n        name: 'callData',\n        type: 'bytes[]',\n      },\n      {\n        internalType: 'uint64[]',\n        name: 'gasLimit',\n        type: 'uint64[]',\n      },\n    ],\n    name: 'batchSome',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address[]',\n        name: 'to',\n        type: 'address[]',\n      },\n      {\n        internalType: 'uint256[]',\n        name: 'value',\n        type: 'uint256[]',\n      },\n      {\n        internalType: 'bytes[]',\n        name: 'callData',\n        type: 'bytes[]',\n      },\n      {\n        internalType: 'uint64[]',\n        name: 'gasLimit',\n        type: 'uint64[]',\n      },\n    ],\n    name: 'batchSomeUntilFailure',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> </li> </ol>"},{"location":"builders/interoperability/mrl/#build-transfer-multiassets","title":"Build the Transfer Multiassets Extrinsic","text":"<p>You can begin to tackle the <code>xTokens.transferMultiassets</code> extrinsic, which accepts four parameters:</p> <ul> <li><code>assets</code> - defines the multilocation and amount of xcDEV (xcGLMR for Moonbeam) and the local XC-20 to send to Moonbase Alpha, with the xcDEV positioned as the first asset and the local XC-20 as the second</li> <li><code>feeItem</code> - set to the index of the xcDEV asset, which in this case is <code>0</code>, so that DEV is used to pay for the execution fees in Moonbase Alpha</li> <li><code>dest</code> - a multilocation that defines the Computed Origin account that you calculated in the previous section on Moonbase Alpha</li> <li><code>destWeightLimit</code> - the weight to be purchased to pay for XCM execution on the destination chain</li> </ul> <p>You can find more information on each parameter in the X-Tokens Precompile page documentation.</p> <p>In the <code>build-transfer-multiassets-call.js</code> file, you'll build the <code>xTokens.transferMultiassets</code> extrinsic and export it.</p> build-transfer-multiassets-call.js<pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\n// Input data\nconst originChainProviderWsURL = 'INSERT_ORIGIN_CHAIN_WSS_URL';\nconst computedOriginAccount = 'INSERT_COMPUTED_ORIGIN_ADDRESS';\nconst localXC20Address = 'INSERT_LOCAL_XC20_ADDRESS';\nconst transferAmount = 'INSERT_AMOUNT_TO_TRANSFER';\n\n// Transfer multiassets parameters\nconst assets = {\n  V4: [\n    {\n      // xcDEV\n      id: {\n        parents: 1,\n        interior: {\n          X2: [\n            { Parachain: 1000 }, // Parachain ID\n            { PalletInstance: 3 }, // Index of the Balances Pallet\n          ],\n        },\n      },\n      fun: {\n        Fungible: '100000000000000000', // 0.1 DEV as an estimation for XCM and EVM transaction fee\n      },\n    },\n    {\n      // Local XC-20 token\n      id: {\n        parents: 1,\n        interior: {\n          X3: [\n            { Parachain: 1000 }, // Parachain ID\n            { PalletInstance: 48 }, // Index of the ERC-20 XCM Bridge Pallet\n            {\n              AccountKey20: {\n                key: localXC20Address,\n              },\n            },\n          ],\n        },\n      },\n      fun: {\n        Fungible: transferAmount,\n      },\n    },\n  ],\n};\nconst feeItem = 0;\nconst destination = {\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { Parachain: 1000 },\n        { AccountKey20: { key: computedOriginAccount } },\n      ],\n    },\n  },\n};\nconst weightLimit = 'Unlimited';\n\nexport const getTransferMultiassetsCall = async () =&gt; {\n  // Create origin chain API provider\n  const originChainProvider = new WsProvider(originChainProviderWsURL);\n  const originChainAPI = await ApiPromise.create({\n    provider: originChainProvider,\n  });\n\n  // Create the transferMultiasset extrinsic\n  const transferMultiassets = originChainAPI.tx.xTokens.transferMultiassets(\n    assets,\n    feeItem,\n    destination,\n    weightLimit\n  );\n\n  originChainAPI.disconnect();\n\n  return transferMultiassets;\n};\n</code></pre> <p>To modify the code for Moonbeam, you'll use the following configurations:</p> Parameter Value Parachain ID 2004 Balances Pallet Index 10 ERC-20 XCM Bridge Pallet Index 110"},{"location":"builders/interoperability/mrl/#build-the-remote-evm-call","title":"Build the Remote EVM Call","text":"<p>To generate the second call of the batch transaction, the <code>polkadotXcm.send</code> extrinsic, you'll need to create the EVM transaction and then assemble the XCM instructions that execute said EVM transaction.</p> <p>For now, you'll focus on generating the calldata for the EVM transaction. For this, you'll construct a transaction that interacts with the Batch Precompile so that two transactions can happen in one. This is helpful because this EVM transaction has to approve both a Wormhole relayer to relay the local XC-20 token and the relay action itself.</p> <p>To create the batch transaction and wrap it in a remote EVM call to be executed on Moonbeam, you'll need to take the following steps:</p> <ol> <li> <p>Create contract instances of the local XC-20, the Wormhole relayer, and the Batch Precompile. For this, you'll need the ABI for each contract and the address of a Wormhole relayer. You can use the xLabs relayer:</p> MoonbeamMoonbase Alpha <pre><code>0xcafd2f0a35a4459fa40c0517e17e6fa2939441ca\n</code></pre> <pre><code>0x9563a59c15842a6f322b10f69d1dd88b41f2e97b\n</code></pre> </li> <li> <p>Use Ether's <code>encodeFunctionData</code> function to get the encoded call data for the two calls in the batch transaction: the <code>approve</code> transaction and the <code>transferTokensWithRelay</code> transaction</p> </li> <li>Combine the two transactions into a batch transaction and use Ether's <code>encodeFunctionData</code> to get the encoded call data for the batch transaction</li> <li>Use the encoded call data for the batch transaction to create the remote EVM call via the <code>ethereumXcm.transact</code> extrinsic, which accepts the <code>xcmTransaction</code> as the parameter. For more information, please refer to the Remote EVM Calls documentation</li> </ol> <p>In the <code>build-remote-calldata.js</code> file, add the following code:</p> build-remote-calldata.js<pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { ethers } from 'ethers';\nimport batchABI from './abi/Batch.js';\nimport erc20ABI from './abi/ERC20.js';\nimport tokenRelayerABI from './abi/TokenRelayer.js';\n\nconst localXC20Address = 'INSERT_LOCAL_XC20_ADDRESS';\nconst transferAmount = 'INSERT_AMOUNT_TO_TRANSFER';\nconst xLabsRelayer = '0x9563a59c15842a6f322b10f69d1dd88b41f2e97b';\nconst destinationChainId = 'INSERT_DESTINATION_CHAIN_ID';\nconst computedOriginAccount = 'INSERT_COMPUTED_ORIGIN_ADDRESS';\n// The recipient address on the destination chain needs to be formatted in 32 bytes\n// You'll pad the address to the left with zeroes. Add the destination address below\n// without the 0x\nconst destinationAddress =\n  '0x000000000000000000000000' + 'INSERT_DESTINATION_ADDRESS';\n\n// Create contract instances\nconst batchInterface = new ethers.Interface(batchABI);\nconst localXC20Interface = new ethers.Interface(erc20ABI);\nconst tokenRelayer = new ethers.Contract(\n  xLabsRelayer,\n  tokenRelayerABI,\n  new ethers.JsonRpcProvider('https://rpc.api.moonbase.moonbeam.network')\n);\n\n// Get the encoded calldata for the approve transaction\nconst approve = localXC20Interface.encodeFunctionData('approve', [\n  xLabsRelayer, // Spender\n  transferAmount, // Amount\n]);\n\n// Get the encoded calldata for the transferTokensWithRelay transaction.\n// Use wrapAndTransferEthWithRelay if the token is GLMR\nconst transferTokensWithRelay = tokenRelayer.interface.encodeFunctionData(\n  'transferTokensWithRelay',\n  [\n    localXC20Address, // Token\n    transferAmount, // Amount to be transferred\n    0, // Amount to swap into native assets on the target chain\n    destinationChainId, // Target chain ID, like Ethereum MainNet or Fantom\n    destinationAddress, // Target recipient address\n    0, // Batch ID for Wormhole message batching\n  ]\n);\n\nconst encodedBatchAllCall = batchInterface.encodeFunctionData('batchAll', [\n  [localXC20Address, xLabsRelayer], // Addresses to call\n  [0, 0], // Value to send for each call\n  [approve, transferTokensWithRelay], // Call data for each call\n  [], // Gas limit for each call\n]);\n\nexport const getTransactCall = async () =&gt; {\n  // Create Moonbeam API provider\n  const moonbeamProvider = new WsProvider(\n    'wss://wss.api.moonbase.moonbeam.network'\n  );\n  const moonbeamAPI = await ApiPromise.create({ provider: moonbeamProvider });\n\n  // Create the extrinsic for the remote EVM call\n  const transact = moonbeamAPI.tx.ethereumXcm.transact({\n    V2: {\n      gasLimit: 350000n,\n      action: {\n        Call: '0x0000000000000000000000000000000000000808',\n      },\n      value: 0n,\n      input: encodedBatchAllCall,\n    },\n  });\n\n  const txWeight = (await transact.paymentInfo(computedOriginAccount)).weight;\n\n  moonbeamAPI.disconnect();\n\n  return { transact, txWeight };\n};\n</code></pre>"},{"location":"builders/interoperability/mrl/#build-xcm-message-for-remote-evm-call","title":"Build the XCM Message for the Remote EVM Call","text":"<p>Next, you'll need to create the extrinsic to send the remote EVM call to Moonbeam. To do so, you'll want to send an XCM message such that the <code>Transact</code> XCM instruction gets successfully executed. The most common method to do this is through <code>polkadotXcm.send</code> with the <code>WithdrawAsset</code>, <code>BuyExecution</code>, and <code>Transact</code> instructions. <code>RefundSurplus</code> and <code>DepositAsset</code> can also be used to ensure no assets get trapped, but they are technically optional.</p> <p>In the <code>build-remote-evm-call.js</code> file, add the following code:</p> build-remote-evm-call.js<pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { getTransactCall } from './build-batch-evm-call.js';\n\nconst originChainProviderWsURL = 'INSERT_ORIGIN_CHAIN_WSS_URL';\nconst computedOriginAccount = 'INSERT_COMPUTED_ORIGIN_ADDRESS';\n\nexport const getPolkadotXcmCall = async () =&gt; {\n  // Create origin chain API provider\n  const originChainProvider = new WsProvider(originChainProviderWsURL);\n  const originChainAPI = await ApiPromise.create({\n    provider: originChainProvider,\n  });\n\n  // Get the weight required to execute the Transact calldata\n  const { transact, txWeight } = await getTransactCall();\n\n  // Create the extrinsic for the remote EVM call\n  const sendXcm = originChainAPI.tx.polkadotXcm.send(\n    { V4: { parents: 1, interior: { X1: [{ Parachain: 1000 }] } } },\n    {\n      V4: [\n        {\n          // Withdraw DEV asset (0.06) from the target account\n          WithdrawAsset: [\n            {\n              id: {\n                parents: 0,\n                interior: { X1: [{ PalletInstance: 3 }] },\n              },\n              fun: { Fungible: 60000000000000000n },\n            },\n          ],\n        },\n        {\n          // Buy execution with the DEV asset\n          BuyExecution: {\n            fees: {\n              id: {\n                parents: 0,\n                interior: { X1: [{ PalletInstance: 3 }] },\n              },\n              fun: { Fungible: 60000000000000000n },\n            },\n            weightLimit: 'Unlimited',\n          },\n        },\n        {\n          Transact: {\n            originKind: 'SovereignAccount',\n            requireWeightAtMost: {\n              refTime: txWeight.refTime,\n              proofSize: txWeight.proofSize,\n            },\n            call: {\n              encoded: transact.method.toHex(),\n            },\n          },\n        },\n        {\n          RefundSurplus: {},\n        },\n        {\n          DepositAsset: {\n            // Note that this must be AllCounted and not All, since All has too high of a gas requirement\n            assets: { Wild: { AllCounted: 1 } },\n            beneficiary: {\n              parents: 0,\n              interior: {\n                X1: [{ AccountKey20: { key: computedOriginAccount } }],\n              },\n            },\n          },\n        },\n      ],\n    }\n  );\n\n  return sendXcm;\n};\n</code></pre>"},{"location":"builders/interoperability/mrl/#build-batch-extrinsic","title":"Build the Batch Extrinsic","text":"<p>To ensure that both the <code>xTokens.transferMultiassets</code> and the <code>polkadotXcm.send</code> transactions are sent together, you can batch them together using <code>utility.batchAll</code>. This helps ensure that the asset transfer happens before the EVM transaction, which is a necessary distinction. Unfortunately, this is subject to change with future XCM updates.</p> <p>In the <code>send-batch-transaction.js</code> file, add the following code:</p> send-batch-transaction.js<pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { getTransferMultiassetsCall } from './build-transfer-multiassets-call.js';\nimport { getPolkadotXcmCall } from './build-remote-evm-call.js';\n\nconst originChainProviderWsURL = 'INSERT_ORIGIN_CHAIN_WSS_URL';\n\nconst sendBatchTransaction = async () =&gt; {\n  // Create origin chain API provider\n  const originChainProvider = new WsProvider(originChainProviderWsURL);\n  const originChainAPI = await ApiPromise.create({\n    provider: originChainProvider,\n  });\n\n  // Create the batch transaction\n  const batchTransaction = originChainAPI.tx.utility.batchAll([\n    await getTransferMultiassetsCall(),\n    await getPolkadotXcmCall(),\n  ]);\n\n  // Create a keyring instance to sign the transaction\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'ethereum' });\n  const account = keyring.addFromUri(privateKey);\n\n  // Send the batch transaction\n  const transaction = await batchTransaction.signAndSend(account, ({ status }) =&gt; {\n    if (status.isInBlock) console.log(`Transaction sent!`);\n  });\n\n  originChainAPI.disconnect();\n\n  return transaction;\n};\n\nsendBatchTransaction();\n</code></pre> <p>If you want to see an example project that fully implements this, an example is available in a GitHub repository.</p> <p>It's important to note that not every parachain will have X-Tokens and the other pallets implemented in a way that will allow this path. Substrate-based chains are very flexible, to the point where a standard doesn't exist. If you believe your parachain does not support this path, please provide an alternative solution in the Moonbeam forum and to the Wormhole team.</p>"},{"location":"builders/interoperability/mrl/#tokens-available-through-wormhole","title":"Tokens Available Through Wormhole","text":"<p>While Wormhole has the technical capability to bridge any token across chains, relayers will not support every token for fees. The ERC-20 assets that can be bridged through Wormhole's MRL solution depend on the tokens the xLabs relayer takes in. The tokens that are available to Moonbeam and Moonbase Alpha are listed in the table below:</p> MoonbeamMoonbase Alpha Token Name Symbol Decimals Address Wrapped AVAX wAVAX 18 0xd4937A95BeC789CC1AE1640714C61c160279B22F Wrapped Bitcoin wBTC 8 0xE57eBd2d67B462E9926e04a8e33f01cD0D64346D Wrapped BNB wBNB 18 0xE3b841C3f96e647E6dc01b468d6D0AD3562a9eeb Celo Native Asset CELO 18 0xc1a792041985F65c17Eb65E66E254DC879CF380b Dai Stablecoin DAI 18 0x06e605775296e851FF43b4dAa541Bb0984E9D6fD Wrapped Ethereum wETH 18 0xab3f0245B83feB11d15AAffeFD7AD465a59817eD Wrapped Fantom wFTM 18 0x609AedD990bf45926bca9E4eE988b4Fb98587D3A Wrapped GLMR wGLMR 18 0xAcc15dC74880C9944775448304B263D191c6077F Wrapped Matic wMATIC 18 0x82DbDa803bb52434B1f4F41A6F0Acb1242A7dFa3 Wrapped SOL SOL 9 0x99Fec54a5Ad36D50A4Bba3a41CAB983a5BB86A7d Sui SUI 9 0x484eCCE6775143D3335Ed2C7bCB22151C53B9F49 Tether USD USDT 6 0xc30E9cA94CF52f3Bf5692aaCF81353a27052c46f USDC (Wormhole) USDC 6 0x931715FEE2d06333043d11F658C8CE934aC61D0c Token Name Symbol Decimals Address Wrapped Avax wAVAX 18 0x2E8afeCC19842229358f3650cc3F091908dcbaB4 Wrapped BNB wBNB 18 0x6097E80331B0c6aF4F74D7F2363E70Cb2Fd078A5 Celo Native Asset CELO 18 0x3406a9b09adf0cb36DC04c1523C4b294C6b79513 Dai Stablecoin DAI 18 0xc31EC0108D8e886be58808B4C2C53f8365f1885D Wrapped Ether wETH 18 0xD909178CC99d318e4D46e7E66a972955859670E1 Wrapped Ether (Wormhole) wETH 18 0xd27d8883E31FAA11B2613b14BE83ad8951C8783C Wrapped Fantom wFTM 18 0x566c1cebc6A4AFa1C122E039C4BEBe77043148Ee Wrapped Matic wMATIC 18 0xD2888f015BcB76CE3d27b6024cdEFA16836d0dbb Sui SUI 9 0x2ed4B5B1071A3C676664E9085C0e3826542C1b27 USDC USDC 6 0x6533CE14804D113b1F494dC56c5D60A43cb5C3b5 <p>Please take the time to verify that these assets are still Wormhole assets on Moonbeam by using the Wormhole asset verifier.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/interoperability/protocols/axelar/","title":"Axelar Network","text":""},{"location":"builders/interoperability/protocols/axelar/#introduction","title":"Introduction","text":"<p>Axelar delivers secure cross-chain communication for Web3. Axelar's infrastructure enables dApp users to interact with any asset or application, on any connected chain, with one click. Powered by a permissionless Proof-of-Stake validator set, Axelar network allows dApps to pass arbitrary messages across chains using Turing-complete calls.</p> <p>Axelar is a full-stack transport layer that supports asset transfer, General Message Passing and composability of programs. It securely connects all blockchain ecosystems, applications, assets and users to deliver Web3 interoperability. Axelar is composed of a decentralized network of validators, secure gateway contracts, uniform translation, routing architecture, and a suite of protocols and application programming interfaces (APIs). Take a look at the Tech Stack Diagram for more details.</p> <p></p> <p>The Axelar APIs provide a rich suite for developing Web3 applications, ensuring that developers have the tools they need for building. With these tools and APIs, developers can use the Axelar network and its APIs to write dApps that can be easily deployed across all Axelar-connected ecosystems.  </p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/interoperability/protocols/axelar/#getting-started","title":"Getting Started","text":"<p>There are a couple of resources to get you started building cross-chain applications with Axelar:</p> <ul> <li>Developer documentation - for technical guides</li> <li>Squid - a bridging UI used to transfer assets across chains</li> </ul> <p>There is also a block explorer available to track your cross-chain transfers and more:</p> <ul> <li>Axelarscan for MainNet</li> <li>Axelarscan for TestNet</li> </ul>"},{"location":"builders/interoperability/protocols/axelar/#contracts","title":"Contracts","text":"<p>See the list of Axelar contracts deployed to Moonbeam, and the networks connected to Moonbeam through Axelar.</p> <ul> <li> <p>MainNet Contracts - Moonbeam</p> </li> <li> <p>TestNet Contracts - Moonbase Alpha</p> </li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/interoperability/protocols/hyperlane/","title":"Hyperlane Protocol","text":""},{"location":"builders/interoperability/protocols/hyperlane/#introduction","title":"Introduction","text":"<p>Hyperlane is a security-modular cross-chain communication protocol for Web3. Hyperlane enables dApp users to interact with any asset or application, on any connected chain, with one click. It supports general asset transfer as well as custom cross-chain messaging.  </p> <p>Using Interchain Security Modules (ISMs), Hyperlane allows developers to configure the method by which messages are sent and validated across chains. Hyperlane is composed of validators, relayers, and watchtowers. Validators will watch for and confirm cross-chain messages. Relayers spend the gas to send messages across chains. Watchtowers perform checks to ensure that validators are good-faith actors, securing the protocol. Take a look at the tech stack diagram and their protocol documentation for more details.</p> <p></p> <p>The Hyperlane APIs provide a rich suite for developing Web3 applications, ensuring that developers have the tools they need for building. With these tools and APIs, developers can use the Hyperlane protocol and its APIs to write dApps that can be easily deployed across all Hyperlane-connected ecosystems.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/interoperability/protocols/hyperlane/#getting-started","title":"Getting Started","text":"<p>There are a couple of resources to get you started building cross-chain applications with Hyperlane:</p> <ul> <li>Developer documentation - for technical guides</li> <li>Hyperlane Explorer - to track cross-chain transfers</li> </ul>"},{"location":"builders/interoperability/protocols/hyperlane/#contracts","title":"Contracts","text":"<p>See the list of Hyperlane contracts deployed to Moonbeam, and the networks connected to Moonbeam through Hyperlane.</p> <ul> <li>MainNet and TestNet Contracts</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/interoperability/protocols/layerzero/","title":"LayerZero Protocol","text":""},{"location":"builders/interoperability/protocols/layerzero/#introduction","title":"Introduction","text":"<p>LayerZero delivers secure omnichain interoperability for Web3. It consists of an Oracle actor and a Relayer actor that work separately to provide secure messages from one chain to another. LayerZero's infrastructure enables dApp users to interact with any asset or application, on any connected chain, with one click.</p> <p>LayerZero is a transport layer that enables asset transfer with low-level communication primitives. DApps that utilize LayerZero are known as User Applications, whose messages are relayed across chains by a Relayer, and whose messages are verified on the destination chain by an Oracle's block headers. Take a look at the tech stack diagram below and their conceptual documentation for more details.</p> <p></p> <p>The LayerZero APIs provide a rich suite for developing Web3 applications, ensuring that developers have the tools they need for building. With these tools and APIs, developers can use the LayerZero protocol and its APIs to write dApps that can be easily deployed across all LayerZero-connected ecosystems.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/interoperability/protocols/layerzero/#getting-started","title":"Getting Started","text":"<p>There are a couple of resources to get you started building cross-chain applications with LayerZero:</p> <ul> <li>Developer documentation - for technical guides</li> <li>Stargate - a bridging UI that uses LayerZero, built by the Stargate team</li> </ul>"},{"location":"builders/interoperability/protocols/layerzero/#contracts","title":"Contracts","text":"<p>See the list of LayerZero contracts deployed to Moonbeam, and the networks connected to Moonbeam through LayerZero.</p> <ul> <li> <p>MainNet Contracts - Moonbeam</p> </li> <li> <p>TestNet Contracts - Moonbase Alpha</p> </li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/interoperability/protocols/wormhole/","title":"Wormhole Network","text":""},{"location":"builders/interoperability/protocols/wormhole/#introduction","title":"Introduction","text":"<p>Wormhole is a protocol that validates and secures cross-chain communication for Web3, through messages known as verifiable action approvals (VAAs). Wormhole's infrastructure enables dApp users to interact with any asset or application, on any connected chain, with one click. Powered by a multi-signature schemed protocol and 19 signing Guardians, Wormhole allows dApps to pass arbitrary messages across chains.</p> <p>Wormhole consists of multiple modular swap-in components that can be leveraged independently and supports an increasing number of composable applications built by numerous teams. Building xDapps on top of their protocol allows for quick cross-chain asset transfers and cross-chain logic to deliver maximal Web3 interoperability. Wormhole's architecture includes a signing Guardian network, bridging smart contracts, and relayers. Take a look at the tech stack diagram for more details.</p> <p></p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"builders/interoperability/protocols/wormhole/#getting-started","title":"Getting Started","text":"<p>There are a couple of resources to get you started building cross-chain applications with Wormhole:</p> <ul> <li>Developer documentation - for technical guides</li> <li>Portal - a bridging UI used to transfer assets across chains</li> </ul>"},{"location":"builders/interoperability/protocols/wormhole/#contracts","title":"Contracts","text":"<p>See the list of Wormhole contracts deployed to Moonbeam, and the networks connected to Moonbeam through Wormhole.</p> <ul> <li>MainNet Contracts - Moonbeam</li> </ul>"},{"location":"builders/interoperability/protocols/wormhole/#setting-up-a-specialized-relayer-with-the-relayer-engine","title":"Setting up a Specialized Relayer With the Relayer Engine","text":"<p>In this section, you will deploy a basic Wormhole connected smart contract and spin up a specialized relayer to send messages across chains.</p> <p>First, some context. VAAs, or verifiable action approvals, are Wormhole\u2019s version of validated cross-chain messages. If 13 out of Wormhole's 19 signing Guardians validate a particular message, the message becomes approved and can be received on other chains. Adjacent to the guardian network (which act as the validators of Wormhole\u2019s protocol) are the network spies. They don\u2019t do any validation work. Instead, they watch the guardian network and act as an interface to allow users and applications to see what VAAs have been approved.</p> <p>The relayer\u2019s role is to pay for the destination chain\u2019s execution, and in many protocols, in turn a relayer is paid by the user. Wormhole does not have general relayers available yet, so Wormhole\u2019s architecture requires dApp developers to create and maintain their own specialized relayers (instead of having a relayer that can execute for many different smart contracts). A developer would have to design their own system if they wished to have the contract caller pay for gas on the destination chain. This might seem like a greater amount of work, but it allows for more fine-tuning of how messages are handled. For example, a relayer could send the same message to multiple chains at the same time, known as multicasting.</p>"},{"location":"builders/interoperability/protocols/wormhole/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>Docker installed</li> <li>Have an account be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>Have the same account be funded with native currency from a Wormhole connected EVM of your choice. Faucets are in the table below</li> </ul>"},{"location":"builders/interoperability/protocols/wormhole/#deploying-the-wormhole-contract-with-remix-on-moonbase-alpha","title":"Deploying the Wormhole Contract with Remix on Moonbase Alpha","text":"<p>To send a cross-chain message, in this guide, you will need to deploy and use a smart contract. Every chain connected to Wormhole will have some sort of implementation of the Wormhole core bridge, whose purpose is to publish and verify VAAs. Each implementation of the core bridge contract (one per chain) is watched by every guardian in the guardian network, which is how they know when to start validating a message.  </p> <p>Unlike other cross-chain protocols, Wormhole doesn\u2019t provide a parent smart contract to inherit from for users to build off of. This is because Wormhole\u2019s first chain, Solana, doesn\u2019t have typical inheritance in their smart contracts like Solidity provides. To keep the design experience similar on each chain, Wormhole has their Solidity developers interact directly with the Wormhole core bridge smart contract on EVM chains.  </p> <p>The smart contract that you will be deploying today is stored in a Git repository that is forked from Wormhole\u2019s relayer engine repository. It sends a string from one chain to another, and stores strings when received through Wormhole's protocol. To deploy the script, either copy and paste the contract into Remix or open up this Remix gist link.  </p> <p>First things first, the code in this smart contract is simplified in certain areas (like security). When writing a smart contract for production, review the Wormhole documentation for a better understanding of standards. To be clear, do not use the following smart contract in production.</p> <ol> <li>Go to the Solidity Compiler tab</li> <li>Press the Compile button</li> <li>Then, go to the Deploy &amp; Run Transactions tab of Remix</li> <li>Set the environment to Injected Web3. This will use MetaMask as the Web3 provider. Ensure that your MetaMask is connected to the Moonbase Alpha network</li> </ol> <p></p> <p>To deploy on each chain, you will need the local instance of the Wormhole core bridge and the chain ID of the chain mentioned. All of this data has been provided for a select few TestNets in the table below. You can find other networks\u2019 endpoints on Wormhole\u2019s supported networks documentation. Keep in mind that you should only use EVMs for this demonstration, since the smart contract and relayer designed for this demonstration only supports EVMs.</p> Network &amp; Faucet Core Bridge Address Wormhole Chain ID Polygon Mumbai 0x0CBE91CF822c73C2315FB05100C2F714765d5c20 5 Avalanche Fuji 0x7bbcE28e64B3F8b84d876Ab298393c38ad7aac4C 6 Fantom TestNet 0x1BB3B4119b7BA9dfad76B0545fb3F531383c3bB7 10 Sepolia 0x4a8bc80Ed5a4067f1CCf107057b8270E0cC11A78 10002 Moonbase Alpha 0xa5B7D85a8f27dd7907dc8FdC21FA5657D5E2F901 16 <ol> <li>Ensure that the contract chosen is SimpleGeneralMessage</li> <li>Open up the deploy menu with the arrow button</li> <li>Input the relevant chain ID in the _CHAINID input</li> <li>Input the relevant core bridge address in the WORMHOLE_CORE_BRIDGE_ADDRESS input</li> <li>Press the transact button to start a deployment transaction</li> <li>Press the Confirm button in MetaMask to deploy</li> </ol> <p>Once the contract has been deployed on Moonbase Alpha make sure to copy down its address and repeat the process with one of any of the other EVM TestNets that are connected to Wormhole so that you can send a message across chains. Remember that you will have to change your network in MetaMask to deploy to the right network.</p>"},{"location":"builders/interoperability/protocols/wormhole/#whitelisting-moonbase-alphas-connected-contract","title":"Whitelisting Moonbase Alpha\u2019s Connected Contract","text":"<p>At this point, you should have the same smart contracts deployed twice. One on Moonbase Alpha, and another on another EVM chain.  </p> <p>Wormhole recommends including a whitelisting system in their connected contracts, which you will have to use in <code>SimpleGeneralMessage</code> before attempting to send a cross-chain message.</p> <p>To add a whitelisted contract, you must invoke the <code>addTrustedAddress(bytes32 sender, uint16 _chainId)</code> function, which requires a bytes32 formatted address and a chain ID. You can find the chain ID in the table above and on Wormhole\u2019s documentation.</p> <pre><code>function addTrustedAddress(bytes32 sender, uint16 _chainId) external {\n    myTrustedContracts[sender][_chainId] = true;\n}\n</code></pre> <p>Note that the <code>sender</code> parameter is a <code>bytes32</code> type instead of an <code>address</code> type. Wormhole\u2019s VAAs provide emitter (origin) addresses in the form of <code>bytes32</code>, so they are stored and checked as <code>bytes32</code>. To convert an <code>address</code> type to <code>bytes32</code>, you will need to pad an additional 24 zeros. This is because an <code>address</code> value is 20 bytes, less than the 32 for <code>bytes32</code>. Every byte has 2 hexadecimal characters, so:</p> <pre><code>zeros to add = (32 bytes - 20 bytes) * 2 hexadecimal characters\nzeros to add = 24\n</code></pre> <p>For example, if your connected contract\u2019s address was <code>0xaf108eF646c8214c9DD9C13CBC5fadf964Bbe293</code>, you would input the following into Remix:</p> <pre><code>0x000000000000000000000000af108ef646c8214c9dd9c13cbc5fadf964bbe293\n</code></pre> <p>Now use Remix to ensure that your two connected contracts trust each other. You will have to do this on both contracts that you have deployed if you intend to send messages back and forth. To switch between contracts on different chains, connect to the destination network through MetaMask.</p> <ol> <li>Make sure that you are in the Injected Provider environment</li> <li>Ensure that you are on the right account</li> <li>Also check that the contract is still SimpleGeneralMessage</li> <li>Finally, take the address of the destination contract, and paste it into the At Address input</li> </ol> <p></p> <p>To add trusted remote addresses:</p> <ol> <li>Find the addTrustedAddress function within the deployed contract and open it</li> <li>When you are on Moonbase Alpha, set the sender as the properly formatted (padded with 24 zeros) address of the contract you deployed on the other EVM TestNet</li> <li>Set the _chainId as the Wormhole chain ID of the chain that the other contract is deployed on. Afterwards, transact and confirm in MetaMask</li> </ol> <p>When you are on the alternate EVM TestNet, set the sender as the properly formatted (padded with 24 zeros) address of the contract you deployed on Moonbase Alpha. Set the _chainId as Moonbase Alpha\u2019s Wormhole chain ID (16). Finally, transact and confirm in MetaMask.</p> <p></p> <p>In this section you should have sent two transactions on two chains to whitelist addresses in both contracts. Afterwards, you should be allowed to send messages between the connected contracts.</p>"},{"location":"builders/interoperability/protocols/wormhole/#running-wormhole-guardian-spy","title":"Running a Wormhole Guardian Network Spy","text":"<p>Now you will run a TestNet relayer for Wormhole! This walkthrough is based off of Wormhole\u2019s relayer-engine GitHub repository, which as of time of writing, is on commit <code>cc0aad4</code>. It\u2019s in relatively active development, which can cause great changes in the structure of the folders.</p> <p>Clone the fork of the relayer-engine that has been prepared specifically for interacting with <code>SimpleGeneralMessage</code>. Docker and npm are required to run this relayer, so be sure to install them to your device.  </p> <p>First things first: the setup. Use the npm package manager to install dependencies (like ethers and the relayer engine itself) using the command line.  </p> <pre><code>npm install\ncd plugins/simplegeneralmessage_plugin\nnpm install \n</code></pre> <p>Once that\u2019s finished, take a look around at the different folders. There are three folders: <code>src</code>, <code>relay-engine-config</code>, and <code>plugins</code>. The <code>src</code> folder contains the script that acts as the starting point for the entire application, so it includes setup. The <code>relay-engine-config</code> include JSON configuration files that are specific to the <code>SimpleGeneralMessage</code> smart contract. The <code>plugins</code> folder contains the plugin that has logic pertaining to relaying for the <code>SimpleGeneralMessage</code> smart contract.  </p> <p>Before going into detail about how to run anything or how any of the plugin scripts work, you need to understand the different components of the relayer and what the relayer does.</p> <p>The relayer filters and receives VAAs from the guardian network and does \"something\" with it. In this case, the relayer will filter messages approved by the Guardians that originate from your deployed connected contracts, then parse the VAA, then determine its destination, and finally attempt to execute a function called <code>processMyMessage(bytes32 VAA)</code> at the destination. It is important to understand that other relayers from other actors can receive this VAA and that other relayers can execute any VAA in any way they see fit.</p> <p>From a technical standpoint, the implementation of this relayer has four parts.</p> <ol> <li>A non-validating spy node that watches the Wormhole guardian network for all VAAs</li> <li>A component known as a listener, which receives the output of the spy node, filters out which ones are relevant to the relayer, and packages them into workflow objects</li> <li>A Redis database that stores the workflow objects that the listener outputs</li> <li>A component known as an executor, which pops workflows off the database and processes them in some way (in this case, sends a transaction on the destination chain)</li> </ol> <p>Starting from scratch, this can be a lot. Fortunately, Wormhole provides a <code>relayer-engine</code> package to help with the setup.</p> <p>It\u2019s best to tackle the configuration and setup of these four components in order, so start with the spy node. The spy node uses Docker, so ensure that Docker is active before attempting to start the node. The command to start the Docker container is long, so to simplify things, it has been added as an npm script to the repository's parent directory. Just run:</p> <pre><code>npm run testnet-spy\n</code></pre> <p>First, you should see a few logs from the startup of the Docker container. Then, a lot of logs should be spamming the console. These are all the VAAs that are going through the Wormhole TestNet, and there are a lot! Don\u2019t worry, you won\u2019t have to decipher any of these logs: the code can do that for you. Leave this running in the background and get another terminal instance to move on to the next step.</p> npm run testnet-spy @wormhole-foundation/example-relayer-project@0.0.1 testnet-spy docker run --platform=linux/amd64 -p 7073:7073 --entrypoint /guardiand ghcr.io/wormhole-foundation/guardiand:latest spy --nodeKey /node.key --spyRPC \"[::]:7073\" --network /wormhole/testnet/2/1 --bootstrap /dns4/t-guardian-01.testnet.xlabs.xyz/udp/8999/quic/p2p/12D3KooWCW3LGUtkCVkHZmVSZHzL3C4WRKWfqAiJPz1NR7dT9Bxh INFO  wormhole-spy    spy/spy.go:322  status server listening on [::]:6060 INFO  wormhole-spy    spy/spy.go:270  spy server listening    {\"addr\": \"[::]:7073\"} INFO  wormhole-spy    common/nodekey.go:16    No node key found, generating a new one...  {\"path\": \"/node.key\"} INFO  wormhole-spy.supervisor supervisor/supervisor_processor.go:41   supervisor processor started INFO  wormhole-spy    spy/spy.go:413  Started internal services INFO  wormhole-spy.root.p2p   p2p/p2p.go:276  Connecting to bootstrap peers   {\"bootstrap_peers\": \"/dns4/t-guardian-01.testnet.xlabs.xyz/udp/8999/quic-v1/p2p/12D3KooWCW3LGUtkCVkHZmVSZHzL3C4WRKWfqAiJPz1NR7dT9Bxh\"} INFO  wormhole-spy.root.p2p   p2p/p2p.go:345  Subscribing pubsub topic    {\"topic\": \"/wormhole/testnet/2/1/broadcast\"} INFO  dht/RtRefreshManager    rtrefresh/rt_refresh_manager.go:322 starting refreshing cpl 0 with key CIQAAAAEGIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA (routing table size was 0) INFO  wormhole-spy.root.p2p   p2p/p2p.go:387  Connected to bootstrap peers    {\"num\": 1} INFO  wormhole-spy.root.p2p   p2p/p2p.go:389  Node has been started   {\"peer_id\": \"12D3KooWJmUftCbuZH9rAF6Zzq9dhDhQ5yQrdwEVhiY8PXN3KtTG\", \"addrs\": \"[/ip4/127.0.0.1/udp/8999/quic-v1 /ip4/172.17.0.2/udp/8999/quic-v1 /ip6/::1/udp/8999/quic-v1]\"} 2024-08-01T23:03:51.193Z INFO    wormhole-spy    spy/spy.go:371  Received signed VAA {\"vaa\": \"AQAAAAABAICa9rr2B5VTAg6tcYu/5DCkzbKVC5xG2CT0EZ681BP0Mxmb9RwTvSENT7Cr1GZ8LRmXbW7W0kZVELN+hhAh5boAZqwUVgAAAAAAGuEB+u2sWFHjK5sjtflBGowrrEquPtTde4Ed0acupKpxAAAAAASqMYIBQVVXVgAAAAAACT4b8wAAJxCYq1BJcB42Joc35zEoMLG3u4ARJg==\"}"},{"location":"builders/interoperability/protocols/wormhole/#setting-up-the-listener-component","title":"Setting up the Listener Component","text":"<p>Now to break down the custom code and configurable component of the relayer. The listener component, aptly named, listens to the spy node for relevant messages. To define what the relevant messages are, you must edit a config file.</p> <p>In <code>plugins/simplegeneralmessage_plugin/config/devnet.json</code>, there exists an array named <code>spyServiceFilters</code>. Each object within this array whitelists a contract\u2019s VAAs as relevant to the relayer. The object contains a <code>chainId</code> (a Wormhole chain ID) and an <code>emitterAddress</code>. For example, in the image below, the first object will watch for VAAs sent by <code>0x428097dCddCB00Ab65e63AB9bc56Bb48d106ECBE</code> on Moonbase Alpha (Wormhole chain ID is 16).</p> <p>Be sure to edit the <code>spyServiceFilters</code> array so that the relayer listens to the two contracts that you deployed.</p> <pre><code>\"spyServiceFilters\": [\n    {\n        \"chainId\": 16,\n        \"emitterAddress\": \"0x428097dCddCB00Ab65e63AB9bc56Bb48d106ECBE\"\n    },\n    {\n        \"chainId\": 10,\n        \"emitterAddress\": \"0x5017Fd40aeA8Ab94693bE41b3bE4e90F45860bA4\"\n    }\n]\n</code></pre> <p>In the <code>simplegeneralmessage_plugin</code> folder, open up <code>src/plugin.ts</code>. This file contains plugin code for both the listener and executor components of the relayer, but the comments should make it obvious which functions are relevant to which component. Snippets of the file are shown below and you should be following along, but in case you aren\u2019t, the entire file can be accessed in its GitHub repository.</p> <p>Look at the <code>getFilters()</code> function below. Notice something familiar? The <code>spyServiceFilters</code> object is injected into the plugin class that <code>getFilters()</code> is part of. Note that no filtering is being done, this is only the preparation of the filters. The actual filtering of VAAs occurs within the <code>relayer-engine</code> package, which uses this <code>getFilters()</code> function to understand what to filter.</p> <p>If a developer wanted to add additional logic to the filters, they could here, but for your purposes, simply listing some hard-coded addresses is fine.</p> <pre><code> // How the relayer injects the VAA filters.\n // This is the default implementation provided by the dummy plugin.\n getFilters(): ContractFilter[] {\n   if (this.pluginConfig.spyServiceFilters) {\n     return this.pluginConfig.spyServiceFilters;\n   }\n   this.logger.error('Contract filters not specified in config');\n   throw new Error('Contract filters not specified in config');\n }\n</code></pre> <p>After filtering, the listener needs to write to the Redis database with workflow data in the <code>consumeEvent(vaa, stagingArea)</code> function below.</p> <p>A workflow is just data that the executor needs from the listener to do a proper execution with. In this case, the only information that is being added to the workflow is the time at which the VAA was received and the parsed data in the VAA itself. If a developer wanted to add more relevant information to the workflow, they could do so in the <code>workflowData</code> object.</p> <p>The <code>nextStagingArea</code> object is a way for consumed events (filtered VAAs) to affect each other. For example, if a developer wanted to package two VAAs together into one workflow, they wouldn\u2019t return a <code>workflowData</code> every time.  </p> <pre><code> // Receives VAAs and returns workflows.\n  async consumeEvent(\n    vaa: ParsedVaaWithBytes,\n    stagingArea: StagingAreaKeyLock,\n  ): Promise&lt;\n    | {\n      workflowData: WorkflowPayload;\n      workflowOptions?: WorkflowOptions;\n    }\n    | undefined\n  &gt; {\n    this.logger.debug(`VAA hash: ${vaa.hash.toString('base64')}`);\n\n    return {\n      workflowData: {\n        vaa: vaa.bytes.toString('base64'),\n      },\n    };\n  }\n</code></pre> <p>That\u2019s all that\u2019s necessary for the listener component. Fortunately, most of the code is hidden from the user within the <code>relayer-engine</code> package.</p> <p>If you recall the list of components, the third is the Redis database component. Most of the code that has to do with the database is hidden from the user, since the <code>relayer-engine</code> package will write &amp; read from it, then inject any relevant data back into the plugin code. To run the Redis database, simply run the following command in the parent directory:  </p> <pre><code>npm run redis\n</code></pre>"},{"location":"builders/interoperability/protocols/wormhole/#setting-up-the-executor-component","title":"Setting up the Executor Component","text":"<p>Finally, you must handle the executor component. Recall that the executor component takes workflow data from the Redis database and does some sort of execution action with that data. For most relayers, this execution will involve an on-chain transaction, since a relayer acts as a trustless oracle for VAAs.</p> <p>The <code>relayer-engine</code> package helps handle the wallets for the plugin. Currently, the package only supports Solana and EVM wallets, but with further development more chains will be supported. But it\u2019s not impossible to integrate NEAR or Algorand into the relayer, since you would just have to write your own wallet handling system in addition to the one already provided by the package.</p> <p>To work with the built-in wallet handling system provided by the package, open the file at <code>relayer-engine-config/executor.json.example</code>. This example script is provided to show you how to format your private keys (the current key is provided by Wormhole).</p> <p>Rename the example file to <code>executor.json</code>. In the <code>privateKeys</code> object of <code>executor.json</code>, replace the content of each array with your private key. The account of the private key entries will be the one that pays for execution fees in the relayer\u2019s executor component.</p> <p>Please manage your keys with care, as exposing them can result in loss of funds. While <code>executor.json</code> is ignored by git in this repository, please be sure that the wallet you are using for TestNet has no MainNet funds just to be safe.</p> <pre><code>{\n   \"privateKeys\": {\n       \"16\": [\n           \"0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d\"\n       ],\n       \"2\": [\n           \"0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d\"\n       ],\n       \"5\": [\n           \"0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d\"\n       ],\n       \"6\": [\n           \"0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d\"\n       ],\n       \"10\": [\n           \"0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d\"\n       ],\n\n   }\n}\n</code></pre> <p>Remove any entries from the <code>privateKeys</code> object if their key belongs to a chain that you are not using.  </p> <p>If you are using a chain that wasn\u2019t listed in the EVM TestNet table above, you will have to add your own array. The key for this array should be the Wormhole chain ID of the other EVM that you chose to deploy on before. For example, if you deployed on the Fantom TestNet, you would add the following object, since the Wormhole chain ID of the Fantom TestNet is <code>10</code>.</p> <pre><code>\"10\": [\n    \"INSERT_YOUR_PRIVATE_KEY\"\n]\n</code></pre> <p>Now that the wallets are sorted out for the executor, look at the code of the executor itself, which is in the <code>plugins/simplegeneralmessage_plugin/src/plugin.ts</code> file. If you haven\u2019t been following along, the entire file can be accessed in its GitHub repository.</p> <p>The <code>handleWorkflow(workflow, providers, execute)</code> function is where all of the logic is, though there are some helper functions underneath it. This is the function that the <code>relayer-engine</code> package invokes when there is a workflow in the Redis database that\u2019s to be used. Notice the three parameters that are injected into the function: <code>workflow</code>, <code>providers</code>, and <code>execute</code>.</p> <ul> <li>The <code>workflow</code> object provides the data that was stored in the database during the listener component\u2019s execution of the <code>consumeEvent(vaa, stagingArea)</code> function. In this case, only the VAA and time it was received was stored in the database, which are stored in the local <code>payload</code> variable</li> <li>The <code>providers</code> object injects Ethers and other chains\u2019 providers, which might be helpful for querying on-chain data or doing other blockchain related actions. As mentioned before, the only providers that are currently supported by the package are Solana and EVMs. The <code>providers</code> object isn\u2019t used in this implementation</li> <li>The <code>execute</code> object currently has two functions in it: <code>onEVM(options)</code> and <code>onSolana(options)</code>. These functions require a Wormhole chain ID and a callback function that has a wallet object injected into it. The wallet included is based off of the private key that was configured in the <code>executor.json</code> file</li> </ul> <p>The first substantial thing this function does is parse the workflow object, then parse its VAA with some helper functions. Afterwards, it takes the parsed VAA payload, converts it into a hexadecimal format, and uses the Ethers utility to ABI-decode the payload into its separate values that were defined way-back-when in the smart contract.</p> <p>With the data that was decoded by Ethers, it\u2019s possible to figure out to which contract and which chain the payload is being sent to, since that data was packaged into the message. The function checks if the specified destination chain ID belongs to an EVM, and will execute using the <code>execute.onEVM(options)</code> function mentioned before. Otherwise, it logs an error since this system doesn\u2019t expect to interact with non-EVM chains for simplicity.</p> <pre><code>// Consumes a workflow for execution\nasync handleWorkflow(\n  workflow: Workflow,\n  providers: Providers,\n  execute: ActionExecutor\n): Promise&lt;void&gt; {\n  this.logger.info(`Workflow ${workflow.id} received...`);\n\n  const { vaa } = this.parseWorkflowPayload(workflow);\n  const parsed = wh.parseVaa(vaa);\n  this.logger.info(`Parsed VAA. seq: ${parsed.sequence}`);\n\n  // Here we are parsing the payload so that we can send it to the right recipient\n  const hexPayload = parsed.payload.toString('hex');\n  let [recipient, destID, sender, message] =\n    ethers.utils.defaultAbiCoder.decode(\n      ['bytes32', 'uint16', 'bytes32', 'string'],\n      '0x' + hexPayload\n    );\n  recipient = this.formatAddress(recipient);\n  sender = this.formatAddress(sender);\n  const destChainID = destID as ChainId;\n  this.logger.info(\n    `VAA: ${sender} sent \"${message}\" to ${recipient} on chain ${destID}.`\n  );\n\n  // Execution logic\n  if (wh.isEVMChain(destChainID)) {\n    // This is where you do all of the EVM execution.\n    // Add your own private wallet for the executor to inject in \n    // relayer-engine-config/executor.json\n    await execute.onEVM({\n      chainId: destChainID,\n      f: async (wallet, chainId) =&gt; {\n        const contract = new ethers.Contract(recipient, abi, wallet.wallet);\n        const result = await contract.processMyMessage(vaa);\n        this.logger.info(result);\n      },\n    });\n  } else {\n    // The relayer plugin has a built-in Solana wallet handler, which you could use\n    // here. NEAR &amp; Algorand are supported by Wormhole, but they're not supported by\n    // the relayer plugin. If you want to interact with NEAR or Algorand you'd have\n    // to make your own wallet management system, that's all\n    this.logger.error(\n      'Requested chainID is not an EVM chain, which is currently unsupported.'\n    );\n  }\n};\n</code></pre> <p>In the callback function, it creates a contract object with the Ethers package. The ABI that it imports is exported from the <code>SimpleGeneralMessage</code> contract\u2019s compilation, so this code is assuming that the recipient of the message specified in the VAA is or inherits from a <code>SimpleGeneralMessage</code> contract.</p> <p>Then, the code attempts to execute the <code>processMyMessage(bytes32 VAA)</code> function with the VAA, which was previously defined as the function that messages are relayed to. Recall that this function name was arbitrarily chosen for the smart contract because the relayer could specify any function to call. That freedom is expressed in the ability for a developer to change this relayer\u2019s code!</p> <pre><code>await execute.onEVM({\n  chainId: destChainID,\n  f: async (wallet, chainId) =&gt; {\n    const contract = new ethers.Contract(recipient, abi, wallet.wallet);\n    const result = await contract.processMyMessage(vaa);\n    this.logger.info(result);\n  },\n});\n</code></pre> <p>The final piece is to check <code>relayer-engine-config/common.json</code>. This config file controls the execution of the entire relayer. Ensure that the TestNet EVMs that you are using are listed within the <code>supportedChains</code> object of this file. The plugin will not run properly if it\u2019s not listed. If a chain that you are using is not listed, you will have to import the data from Wormhole\u2019s developer documentation into the config file in a format like below.</p> <p>There are also additional configurations for the relayer. For example, the <code>mode</code> string is set to <code>\"BOTH\"</code> to ensure that both the listener and executor plugins are used, but a developer could decide to run only one if they wanted. Additionally, there are multiple log levels to specify, such as <code>\"error\"</code> for just error messages. For this demo, however, just leave the configuration settings as is.</p> <pre><code> \"mode\": \"BOTH\",\n \"logLevel\": \"debug\",\n ...\n    {\n        \"chainId\": 16,\n        \"chainName\": \"Moonbase Alpha\",\n        \"nodeUrl\": \"https://rpc.api.moonbase.moonbeam.network\",\n        \"bridgeAddress\": \"0xa5B7D85a8f27dd7907dc8FdC21FA5657D5E2F901\",\n        \"tokenBridgeAddress\": \"0xbc976D4b9D57E57c3cA52e1Fd136C45FF7955A96\"\n    },\n</code></pre> <p>That\u2019s it for the configuration! Now to run it. In your terminal instance (one that isn\u2019t running the spy node), navigate to the parent folder. Run the following command:</p> <pre><code>npm run start\n</code></pre> <p>You should see something similar to the logs below in the console.</p> warn | GlobalStorage: You are starting a relayer without a namespace, which could cause issues if you run multiple relayers using the same Redis instance info | main: Running as both executor and listener debug | executorHarness: Finished gathering worker infos. info | Fantom Testnet-0-worker: Spawned info | Moonbase Alpha-0-worker: Spawned info | listenerHarness: Initializing spy listener... info | spyEventSource: Initializing spy listener for plugin SimpleGeneralMessagePlugin... debug | missedVaaFetching: Grouping emitter keys from plugins... debug | listenerHarness: End of listener harness run function warn | koa deprecated Support for generators will be removed in v3. See the documentation for examples of how to convert old middleware https://github.com/koajs/koa/blob/master/docs/migration.md node_modules/relayer-engine/relayer-engine/lib/index.js:138:9 info | spyEventSource: SimpleGeneralMessagePlugin subscribing to spy with raw filters: [{\"chainId\":2,\"emitterAddress\":\"0xfB7327Fe26aD52b693E38232E5D97F4892623075\"},{\"chainId\":5,\"emitterAddress\":\"0xfB7327Fe26aD52b693E38232E5D97F4892623075\"},{\"chainId\":6,\"emitterAddress\":\"0xfB7327Fe26aD52b693E38232E5D97F4892623075\"},{\"chainId\":16,\"emitterAddress\":\"0x428097dCddCB00Ab65e63AB9bc56Bb48d106ECBE\"},{\"chainId\":10,\"emitterAddress\":\"0x5017Fd40aeA8Ab94693bE41b3bE4e90F45860bA4\"}] debug | spyEventSource: SimpleGeneralMessagePlugin using transformed filters: [{\"emitterFilter\":{\"chainId\":2,\"emitterAddress\":\"000000000000000000000000fb7327fe26ad52b693e38232e5d97f4892623075\"}},{\"emitterFilter\":{\"chainId\":5,\"emitterAddress\":\"000000000000000000000000fb7327fe26ad52b693e38232e5d97f4892623075\"}},{\"emitterFilter\":{\"chainId\":6,\"emitterAddress\":\"000000000000000000000000fb7327fe26ad52b693e38232e5d97f4892623075\"}},{\"emitterFilter\":{\"chainId\":16,\"emitterAddress\":\"000000000000000000000000428097dcddcb00ab65e63ab9bc56bb48d106ecbe\"}},{\"emitterFilter\":{\"chainId\":10,\"emitterAddress\":\"0000000000000000000000005017fd40aea8ab94693be41b3be4e90f45860ba4\"}}] debug | missedVaaFetching: Starting nextVaaFetchingWorker... debug | missedVaaFetching: Pessimistically fetching next vaa for all emitters registered by plugins info | spyEventSource: connected to spy service, listening for transfer signed VAAs info | MetricsServer: Prometheus metrics running on port 3001 info | ApiServer: Api running on port 3000 debug | missedVaaFetching: nextVaaFetchingWorker loop completed, sleeping 300000000 ms..."},{"location":"builders/interoperability/protocols/wormhole/#send-message-from-moonbase","title":"Sending a Cross-Chain Message from Moonbase with Wormhole","text":"<p>Now, to send a cross-chain message, you just need to call the <code>sendMessage(string memory message, address destAddress, uint16 destChainId)</code> function.</p> <p>Use the Remix interface. This example is going to send a cross-chain message to the Fantom TestNet, but you can substitute the <code>destChainId</code> for whichever EVM you desire. Check the following things:</p> <ol> <li>The environment is Injected Provider on network 1287 (Moonbase Alpha)</li> <li>You have substantial funds in your wallet from the faucet to cover the transaction gas cost on both the origin and destination chains</li> <li>Put a short message of your choice in the message input of the sendMessage section (in this case, \"this is a message\")</li> <li>Put the address of your instance of SimpleGeneralMessage on destination chain in the destAddress input</li> <li>Put the destination chain\u2019s Wormhole chain ID in the destChainId input of the sendMessage section</li> <li>Once this is all done, transact the execution and confirm it in MetaMask</li> </ol> <p></p> <p>After a few seconds to a minute, cross-chain messages should be properly relayed through the relayer that you are hosting on your local machine.  </p> debug | spyEventSource: 7iWtnE4whSBtCxmUA87FUQkCLhy92gHW/qIg6/vTMNM= debug | spyEventSource: 10 info | missedVaafetching: Fetching missed vas for 10: 0000000000000000000000001fd6d0beaf150526a6e48dbde8484a73a280a45, from 1 to 2 debug | SimpleGeneralMessagePlugin: VAA hash: 7iWtnE4whSBtCmUA87FUQkCLhy92gHW/qIg6/VTMNM= info | leventHarness: Received workflow data from plugin SimpleGeneralMessagePlugin, adding workflow. debug | GlobalStorage: Updating emitter record last seen sequence. debug | GlobalStorage: Found emitterRecord debug | executorHarness: New workflow found info | executorHarness: Starting workflow. info | SimpleGeneralMessagePlugin: Workflow 10/0000000000000000000000001d6d0beaf150526a648dbde8484a73a280a45/2/ee25 a received. info | SimpleGeneralMessagePlugin: Parsed VAA. seq: 2 info | SimpleGeneralMessagePlugin: VAA: 0x0394c0edf cca370b20622721985b577850b@eb75 sent \"this is a message\" to exa8add 09e4fcf1b5edc588c54bee137cb35e61f5b on chain 16. debug | GlobalStorage: Updated emitter record. Key SimpleGeneralMessagePlugin:10:0000000000000000000000001d6d0beaf150 52f6a648dbde8484a73a280a45, {\"lastSeenSequence\":2,\"time\":\"2023-03-14T21:38:11.780Z\"} info | Moonbase Alpha-0-worker: Relaying action for plugin SimpleGeneralMessagePlugin, debug | executorHarness: No new workflows found. info | SimpleGeneralMessagePlugin: [object Object] info | Moonbase Alpha-0-worker: Action SimpleGeneralMessagePlugin completed info | executorHarness: Finished executing workflow."},{"location":"builders/interoperability/protocols/wormhole/#moonbeam-routed-liquidity-integration","title":"Moonbeam Routed Liquidity Integration","text":"<p>Wormhole will provide liquidity to parachains through the Moonbeam Routed Liquidity (MRL) program. This program allows one-click transfers of liquidity from Wormhole connected chains into parachain wallets by sending liquidity through Moonbeam networks. MRL utilizes the GMP Precompile, whose documentation explains how cross-chain messages should be constructed to properly use the precompile.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/interoperability/xcm/overview/","title":"Cross-Consensus Messaging (XCM)","text":""},{"location":"builders/interoperability/xcm/overview/#introduction","title":"Introduction","text":"<p>Polkadot's architecture allows parachains to natively interoperate with each other, enabling cross-blockchain transfers of any type of data or asset.</p> <p>To do so, a Cross-Consensus Message (XCM) format defines a language around how the message transfer between two interoperating blockchains should be performed. XCM is not specific to Polkadot, as it aims to be a generic and extensible language between different consensus systems.</p> <p>This page is a brief introduction and overview of XCM and other related elements. More information can be found in Polkadot's Wiki.</p> <p>If you want to jump to more XCM-related content, feel free to check out the following pages:</p> <ul> <li>Core XCM Concepts - learn topics related to XCM Instructions, Multilocations, and XCM Fees</li> <li>XC Registration - go through the process of Opening an XCM Channel with Moonbeam and how to Register Polkadot Native Assets as XC-20s</li> <li>XC-20s - read an Overview of this Moonbeam-only asset class and learn how to Interact with XC-20s and how to Send them via XCM</li> <li>Remote Execution via XCM - grasp all concepts related to remote execution via XCM, starting with a High-Level Overview, then Computed Origins and wrapping up with Remote Calls via XCM and Remote EVM Calls via XCM</li> <li>XCM SDK - learn how to Use Moonbeam's XCM SDK</li> <li>XCM Debugging and Tools - learn how to test some XCM scenarios by  Sending and Executing Generic XCM Messages, or how to use the XCM Utilities Precompile to access XCM_related utility functions directly within the EVM</li> </ul>"},{"location":"builders/interoperability/xcm/overview/#general-xcm-definitions","title":"General XCM Definitions","text":"<ul> <li>XCM \u2014 stands for Cross-Consensus Message. It is a general way for consensus systems to communicate with each other</li> <li>VMP \u2014 stands for Vertical Message Passing, one of the transport methods for XCMs. It allows parachains to exchange messages with the relay chain. UMP (Upward Message Passing) enables parachains to send messages to their relay chain, while DMP (Downward Message Passing) enables the relay chain to pass messages down to one of their parachains</li> <li>XCMP \u2014 stands for Cross-Consensus Message Passing, one of the transport methods for XCMs. It allows parachains to exchange messages with other parachains on the same relay chain</li> <li> <p>HRMP \u2014 stands for Horizontal Relay-routed Message Passing, a stop-gap protocol while a full XCMP implementation is launched. It has the same interface as XCMP, but messages are stored on the relay chain</p> </li> <li> <p>Sovereign account \u2014  an account each chain in the ecosystem has, one for the relay chain and the other for other parachains. It is calculated as the <code>blake2</code> hash of a specific word and parachain ID concatenated (<code>blake2(para+ParachainID)</code> for the Sovereign account in the relay chain, and <code>blake2(sibl+ParachainID)</code> for the Sovereign account in other parachains), truncating the hash to the correct length. The account is owned by root and can only be used through SUDO (if available) or governance (referenda). The Sovereign account typically signs XCM messages in other chains in the ecosystem</p> </li> <li> <p>Multilocation \u2014  a way to specify a point in the entire relay chain/parachain ecosystem relative to a given origin. For example, it can be used to specify a specific parachain, asset, account, or even a pallet inside a parachain. In general terms, a multilocation is defined with a <code>parents</code> and an <code>interior</code>:</p> <ul> <li><code>parents</code> - refers to how many \"hops\" into a parent blockchain you need to take from a given origin</li> <li><code>interior</code> - refers to how many fields you need to define the target point. </li> </ul> <p>For example, to target a parachain with ID <code>1000</code> from another parachain, the multilocation would be <code>{ \"parents\": 1, \"interior\": { \"X1\": [{ \"Parachain\": 1000 }]}}</code></p> </li> </ul>"},{"location":"builders/interoperability/xcm/overview/#xcm-transport-protocols","title":"Cross-Chain Transport Protocols via XCM","text":"<p>XCM implements two cross-consensus or transport protocols for acting on XCM messages between its constituent parachains, Moonbeam being one of them:</p> <ul> <li> <p>Vertical Message Passing (VMP) \u2014 once a project is onboarded as a parachain, it automatically has a bi-directional communication channel with the relay chain. Therefore, there is no need for chain registration. VMP is divided into two kinds of message-passing transport protocols:</p> <ul> <li>Upward Message Passing (UMP) \u2014 allows parachains to send messages to their relay chain, for example, from Moonbeam to Polkadot</li> <li>Downward Message Passing (DMP) \u2014 allows the relay chain to pass messages down to one of their parachains, for example, from Polkadot to Moonbeam</li> </ul> </li> <li> <p>Cross-Chain Message Passing (XCMP) \u2014 allows two parachains to exchange messages as long as they are connected to the same relay chain. Cross-chain transactions are resolved using a simple queuing mechanism based on a Merkle tree to ensure fidelity. Collators exchange messages between parachains, while the relay chain validators will verify that the message transmission happened</p> </li> </ul> <p>Note</p> <p>Currently, while XCMP is being developed, a stop-gap protocol is implemented called Horizontal Relay-routed Message Passing (HRMP), in which the messages are stored in and read from the relay chain. This will be deprecated in the future for the full XCMP implementation.</p> <p></p>"},{"location":"builders/interoperability/xcm/overview/#channel-registration","title":"Establishing Cross-Chain Communication","text":"<p>Before two chains can start communicating, a messaging channel must be opened. Channels are unidirectional, meaning that a channel from chain A to chain B will only pass messages from A to B. Therefore, two channels must be opened to send messages back and forth.</p> <p>A channel for XCMs between the relay chain and parachain is automatically opened when a connection is established. However, when parachain A wants to open a communication channel with parachain B, parachain A must send an open channel extrinsic to its network. This extrinsic is an XCM as well!</p> <p>Even though parachain A has expressed its intentions of opening an XCM channel with parachain B, the latter has not signaled to the relay chain its intentions to receive messages from parachain A. Therefore, to have an established channel, parachain B must send an extrinsic (an XCM) to the relay chain. The accepting channel extrinsic is similar to the previous one. However, the encoded call data only includes the new method (accept channel) and the parachain ID of the sender (parachain A in this example). Once both parachains have agreed, the channel is opened within the following epoch.</p> <p>To learn more about the channel registration process, please refer to the How to Establish an XC Integration with Moonbeam guide.</p> <p></p> <p>Once the channel is established, cross-chain messages can be sent between parachains. For asset transfers, assets need to be registered before being transferred through XCMs, either by being baked into the runtime as a constant or through a pallet. Moonbeam relies on a Substrate pallet to handle asset registration without the need for runtime upgrades, making the process a lot simpler.</p> <p>To learn how to register an asset on Moonbeam and the information necessary to add Moonbeam assets to another chain, please refer to the How to Register Cross-Chain Assets guide.</p>"},{"location":"builders/interoperability/xcm/overview/#moonbeam-and-xcm","title":"XCM on Moonbeam","text":"<p>As Moonbeam is a parachain within the Polkadot ecosystems, one of the most direct implementations of XCM is to enable asset transfer from Polkadot and other parachains from/to Moonbeam. This allows users to bring their tokens to Moonbeam and all its dApps.</p> <p>To this end, Moonbeam has introduced XC-20s, which expand on Moonbeam's unique Ethereum compatibility features. XC-20s allow Polkadot native assets to be represented via a standard ERC-20 interface through a precompiled contract. When these assets are registered on Moonbeam, they can be set as XCM execution fee assets. Consequently, when a user transfers such an asset to Moonbeam, a small part of the amount will be used to cover the XCM execution fees.</p> <p>In addition, ERC-20s that are deployed to Moonbeam can be sent to other chains in the Polkadot ecosystem via XCM. Consequently, from a developer's perspective, XC-20s are ERC-20 tokens with the added benefit of being an XCM cross-chain asset, and dApps can easily support them through a familiar ERC-20 interface.</p> <p></p> <p>To send XC-20s across the Polkadot ecosystem from Moonbeam, developers need to use the Polkadot XCM Pallet for transfers via the Substrate API and the X-Tokens Precompile or the XCM Precompile for transfers via the Ethereum API.</p> <p>Another unique feature of Moonbeam is the ability to initiate XCM actions from EVM smart contracts or to call its EVM through XCM messages via remote execution. This unlocks a new set of possibilities, where contracts on Moonbeam can access parachain-specific functionalities via XCM, or other parachain ecosystems can use EVM smart contracts on Moonbeam to expand their functions.</p> <p>The following sections provide a high-level overview of the main use cases mentioned before.</p>"},{"location":"builders/interoperability/xcm/overview/#transfers-moonbeam-polkadot","title":"XCM Transfers between Moonbeam &amp; Polkadot","text":"<p>As Moonbeam is a parachain within the Polkadot ecosystem, a straightforward implementation of XCM + VMP is DOT transfers from/to Polkadot/Moonbeam. To this end, DOT was registered as xcDOT on Moonbeam.</p> <p>Alice (Polkadot) wants to transfer a certain amount of DOT from Polkadot to her account on Moonbeam, named Alith. Therefore, she initiates an XCM that expresses her intentions. For such transfers, Moonbeam owns a Sovereign account on Polkadot.</p> <p>Consequently, the XCM message execution on Polkadot will transfer the amount of DOT to Moonbeam's Sovereign account on Polkadot. Once the assets are deposited, the second part of the message is sent to Moonbeam.</p> <p>Moonbeam will locally execute the action the XCM message is programmed to do. In this case, it is to mint and transfer the same amount of xcDOT to the account defined by Alice, which in this case is Alith. The fee to execute the XCM in the target parachain is paid in the asset being transferred (xcDOT for this example).</p> <p></p> <p>Note the following:</p> <ul> <li>The Alice and Alith accounts can be different. For example, Polkadot's accounts are SR25519 (or ED25519), while Moonbeam's are ECDSA (Ethereum-styled) accounts. They can also have different owners</li> <li>There is a certain degree of trust where one chain relies on the other to execute its part of the XCM message. This is programmed at a runtime level so that it can be easily verified</li> <li>For this example, xcDOT is a wrapped representation of the original DOT being held in Moonbeam's Sovereign account on Polkadot. xcDOT can be transferred within Moonbeam at any time, and they can be redeemed for DOT on a 1:1 basis as well (minus some fees)</li> </ul> <p>Alith deposited her xcDOT in a liquidity pool. Next, Charleth acquires some xcDOT by swapping against that liquidity pool, and he wants to transfer some xcDOT to Charley's Polkadot account. Therefore, he initiates an XCM that expresses his intentions.</p> <p>Consequently, the XCM message execution on Moonbeam will burn the number of xcDOT. Once the assets are burned, the second part of the message is sent to Polkadot.</p> <p>Polkadot will execute the action the XCM message is programmed to do locally. In this case, it is to transfer the same amount of xcDOT burned from the Moonbeam Sovereign account to the account defined by Charleth, which in this case is Charley.</p> <p></p>"},{"location":"builders/interoperability/xcm/overview/#transfers-moonbeam-other-parachains","title":"XCM Transfers between Moonbeam &amp; Other Parachains","text":"<p>Since Moonbeam is a parachain within the Polkadot ecosystem, a straightforward implementation of XCM and XCMP asset transfers from and to Moonbeam and other parachains. This section gives a high-level overview of the main differences compared to XCMs from Polkadot/Moonbeam.</p> <p>The first requirement is that a bidirectional channel between the parachains must exist, and the asset being transferred must be registered in the target parachain. Only when both conditions are met can XCMs be sent between parachains.</p> <p>Then, when Alith (Moonbeam) transfers a certain amount of GLMR from Moonbeam to another account (Alice) in a target parachain, tokens are sent to a Sovereign Account owned by that target parachain on Moonbeam.</p> <p>As the XCM message is executed in the target parachain, it is expected that this will mint and transfer the same amount of xcGLMR (cross-chain GLMR) to the account defined by Alith, which in this case is Alice. The fee to execute the XCM in the target parachain is paid in the transferred asset (xcGLMR for this example).</p> <p></p> <p>As explained in the previous section, the process is similar for xcGLMR to move back to Moonbeam. First, the XCM message execution burns the number of xcGLMR returned to Moonbeam. Once burned, the remnant part of the message is sent to Moonbeam via the relay chain. Moonbeam will locally execute the XCM message's and transfer GLMR (the same amount of burned xcGLMR) from the target parachain Sovereign account to the specified address.</p>"},{"location":"builders/interoperability/xcm/overview/#execution-chains-moonbeam","title":"Remote Execution between Other Chains &amp; Moonbeam","text":"<p>As mentioned before, XCM also enables remote execution from/to Moonbeam to other chains in the Polkadot ecosystem.</p> <p>Similarly to the other use cases, it is necessary for XCM-specific channels to be established before remote execution can happen between the chains. Channels are general-purpose, so they can be used for both asset transfers and remote execution.</p> <p>Another important component is the asset for which the remote execution fees are paid. On Moonbeam, when an XC-20 is registered, it can be set as an XCM execution fee asset. Consequently, when transferring that XC-20 to Moonbeam, the XCM execution fee is deducted from the amount being transferred. For remote execution, users can include a small amount of tokens in the XCM message to cover XCM execution fees.</p> <p>Alice (Polkadot) wants to perform a certain remote action through a smart contract on Moonbeam. Therefore, she initiates an XCM that expresses her intentions; she must have previously funded the XCM execution account she owns on Moonbeam with either GLMR or xcDOT.</p> <p>Moonbeam will locally execute the action the XCM message is programmed to do. In this case, it is to withdraw the asset decided by Alice for the XCM execution fee and buy some execution time on Moonbeam to execute the smart contract call on Moonbeam's EVM.</p> <p>You can read more about the flow in detail on the Remote Execution page.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/","title":"Send, Execute, and Test XCM Messages","text":""},{"location":"builders/interoperability/xcm/send-execute-xcm/#introduction","title":"Introduction","text":"<p>XCM messages are comprised of a series of instructions that are executed by the Cross-Consensus Virtual Machine (XCVM). Combinations of these instructions result in predetermined actions, such as cross-chain token transfers. You can create your own custom XCM messages by combining various XCM instructions.</p> <p>Pallets such as Polkadot XCM and XCM Transactor provide functions with a predefined set of XCM instructions to either send XC-20s or remotely execute on other chains via XCM. However, to get a better understanding of the results from combining different XCM instructions, you can build and execute custom XCM messages locally on Moonbeam (only available on Moonbase Alpha). You can also send custom XCM messages to another chain (which will start with the <code>DescendOrigin</code> instruction). Nevertheless, for the XCM message to be successfully executed, the target chain needs to be able to understand the instructions.</p> <p>To execute or send a custom XCM message, you can either use the Polkadot XCM Pallet directly or through the Ethereum API with the XCM Utilities Precompile. In this guide, you'll learn how to use both methods to execute and send custom-built XCM messages locally on Moonbase Alpha.</p> <p>This guide assumes that you are familiar with general XCM concepts, such as general XCM terminology and XCM instructions. For more information, you can check out the XCM Overview documentation.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#polkadot-xcm-pallet-interface","title":"Polkadot XCM Pallet Interface","text":""},{"location":"builders/interoperability/xcm/send-execute-xcm/#extrinsics","title":"Extrinsics","text":"<p>The Polkadot XCM Pallet includes the following relevant extrinsics (functions):</p> execute(message, maxWeight) \u2014 supported on Moonbase Alpha only - executes a custom XCM message on the source chain ParametersPolkadot.js API Example <ul> <li><code>message</code> - the SCALE-encoded versioned XCM message to be executed</li> <li><code>maxWeight</code> - the maximum weight allowed to be consumed, which is defined by specifying the:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst message = { V4: [INSERT_XCM_INSTRUCTIONS] };\nconst maxWeight = { refTime: INSERT_REF_TIME, proofSize: INSERT_PROOF_SIZE };\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.polkadotXcm.execute(message, maxWeight);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\n\nmain();\n</code></pre> send(dest, message) \u2014 supported on Moonbase Alpha only - sends a custom XCM message to a destination chain. For the XCM message to be successfully executed, the target chain needs to be able to understand the instructions in the message ParametersPolkadot.js API Example <ul> <li><code>dest</code> - the XCM versioned multilocation representing a chain in the ecosystem where the XCM message is being sent to (the target chain)</li> <li><code>message</code> - the SCALE-encoded versioned XCM message to be executed</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst dest = { V4: { parents: INSERT_PARENTS, interior: INSERT_INTERIOR } };\nconst message = { V4: [INSERT_XCM_INSTRUCTIONS] };\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.polkadotXcm.send(dest, message);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#storage-methods","title":"Storage Methods","text":"<p>The Polkadot XCM Pallet includes the following relevant read-only storage methods:</p> assetTraps(hash) \u2014 returns the existing number of times an asset has been trapped given a hash of the asset ParametersReturnsPolkadot.js API Example <p><code>hash</code> - (optional) the Blake2-256 hash of the <code>Asset</code></p> <p>The number of times an asset has been trapped. If the hash was omitted, it returns an array of all of the hashes and the number of times each asset has been trapped.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the value\n// If hash was provided:\n10\n\n// If hash was omitted:\n[\n  [\n    0xf7d4341888be30c6a842a77c52617423e8109aa249e88779019cf731ed772fb7\n  ],\n  10\n],\n...\n</code></pre> <pre><code>\n</code></pre> palletVersion() \u2014 returns current pallet version from storage ParametersReturnsPolkadot.js API Example <p>None</p> <p>A number representing the current version of the pallet.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n0\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const palletVersion = await api.query.polkadotXcm.palletVersion();\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this guide, you will need the following:</p> <ul> <li>Your account must be funded with DEV tokens.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#execute-an-xcm-message-locally","title":"Execute an XCM Message Locally","text":"<p>This section of the guide covers the process of building a custom XCM message to be executed locally (i.e., in Moonbeam) via two different methods: the <code>execute</code> function of the Polkadot XCM Pallet and the <code>xcmExecute</code> function of the XCM Utilities Precompile. This functionality provides a playground for you to experiment with different XCM instructions and see firsthand the results of these experiments. This also comes in handy to determine the fees associated with a given XCM message on Moonbeam.</p> <p>In the following example, you'll transfer DEV tokens from one account to another on Moonbase Alpha. To do so, you'll be building an XCM message that contains the following XCM instructions, which are executed locally (in this case, on Moonbase Alpha):</p> <ul> <li><code>WithdrawAsset</code> - removes assets and places them into the holding register</li> <li><code>DepositAsset</code> - removes the assets from the holding register and deposits the equivalent assets to a beneficiary account</li> </ul> <p>Note</p> <p>Typically, when you send an XCM message cross-chain to a target chain, the <code>BuyExecution</code> instruction is needed to pay for remote execution. However, for local execution, this instruction is not necessary as you are already getting charged via the extrinsic call.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#execute-an-xcm-message-with-polkadotjs-api","title":"Execute an XCM Message with the Polkadot.js API","text":"<p>In this example, you'll execute a custom XCM message locally on Moonbase Alpha using the Polkadot.js API to interact directly with the Polkadot XCM Pallet.</p> <p>The <code>execute</code> function of the Polkadot XCM Pallet accepts two parameters: <code>message</code> and <code>maxWeight</code>. You can start assembling these parameters by taking the following steps:</p> <ol> <li> <p>Build the <code>WithdrawAsset</code> instruction, which will require you to define:</p> <ul> <li>The multilocation of the DEV token on Moonbase Alpha</li> <li>The amount of DEV tokens to transfer</li> </ul> <pre><code>const instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 100000000000000000n }, // 0.1 DEV\n    },\n  ],\n};\n</code></pre> </li> <li> <p>Build the <code>DepositAsset</code> instruction, which will require you to define:</p> <ul> <li>The asset identifier for DEV tokens. You can use the <code>WildAsset</code> format, which allows for wildcard matching, to identify the asset</li> <li>The multilocation of the beneficiary account on Moonbase Alpha</li> </ul> <pre><code>const instr2 = {\n  DepositAsset: {\n    assets: {\n      Wild: {\n        AllCounted: 1,\n      },\n    },\n    beneficiary: {\n      parents: 0,\n      interior: {\n        X1: [\n          {\n            AccountKey20: {\n              key: '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0',\n            },\n          },\n        ],\n      },\n    },\n  },\n};\n</code></pre> </li> <li> <p>Combine the XCM instructions into a versioned XCM message:</p> <pre><code>const message = { V4: [instr1, instr2] };\n</code></pre> </li> <li> <p>Specify the <code>maxWeight</code>, which includes a value for <code>refTime</code> and <code>proofSize</code> that you will need to define. You can get both of these values by providing the XCM message as a parameter to the <code>queryXcmWeight</code> method of the <code>xcmPaymentApi</code> runtime call. </p> <pre><code>const maxWeight = { refTime: 7250000000n, proofSize: 19374n };\n</code></pre> </li> </ol> <p>Now that you have the values for each of the parameters, you can write the script for the execution. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The Moonbase Alpha endpoint URL to create the provider</li> <li>The values for each of the parameters of the <code>execute</code> function</li> </ul> </li> <li>Create a Keyring instance that will be used to send the transaction</li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>polkadotXcm.execute</code> extrinsic with the <code>message</code> and <code>maxWeight</code></li> <li>Send the transaction using the <code>signAndSend</code> extrinsic and the Keyring instance you created in the second step</li> </ol> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a JavaScript file.</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\n// 1. Provide input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 100000000000000000n }, // 0.1 DEV\n    },\n  ],\n};\nconst instr2 = {\n  DepositAsset: {\n    assets: {\n      Wild: {\n        AllCounted: 1,\n      },\n    },\n    beneficiary: {\n      parents: 0,\n      interior: {\n        X1: [\n          {\n            AccountKey20: {\n              key: '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0',\n            },\n          },\n        ],\n      },\n    },\n  },\n};\nconst message = { V4: [instr1, instr2] };\nconst maxWeight = { refTime: 7250000000n, proofSize: 19374n };\n\nconst executeXcmMessage = async () =&gt; {\n  // 2. Create Keyring instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'ethereum' });\n  const alice = keyring.addFromUri(privateKey);\n\n  // 3. Create Substrate API provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 4. Craft the extrinsic\n  const tx = api.tx.polkadotXcm.execute(message, maxWeight);\n\n  // 5. Send the transaction\n  const txHash = await tx.signAndSend(alice);\n  console.log(`Submitted with hash ${txHash}`);\n\n  api.disconnect();\n};\n\nexecuteXcmMessage();\n</code></pre> <p>Note</p> <p>You can view an example of the above script, which sends 1 DEV to Bob's account on Moonbase Alpha, on Polkadot.js Apps using the following encoded calldata: <code>0x1c030408000400010403001300008a5d784563010d010204000103003cd0a705a2dc65e5b1e1205896baa2be8a07c6e007803822b001ba2e0100</code>.</p> <p>Once the transaction is processed, the 0.1 DEV tokens should be withdrawn from Alice's account along with the associated XCM fees, and the destination account should have received 0.1 DEV tokens in their account. A <code>polkadotXcm.Attempted</code> event will be emitted with the outcome.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#test-an-xcm-message-with-the-dry-run-api","title":"Test an XCM Message with the Dry Run API","text":"<p>The XCM Dry Run API is an easy and convenient way to test the integrity of your XCM message without incurring any transaction fees. The XCM Dry Run API can be accessed from the Runtime Calls tab of the Developer section of Polkadot.js Apps.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#dry-run-call-api-method","title":"Dry Run Call API Method","text":"<p>This method takes as a parameter the origin and the call data and returns an execution result, actual weight, and event data.  </p> <pre><code>const testAccount = api.createType(\n  'AccountId20',\n  '0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798'\n);\nconst callData =\n  '0x1c030408000400010403001300008a5d784563010d010204000103003cd0a705a2dc65e5b1e1205896baa2be8a07c6e007803822b001ba2e0100';\nconst callDataU8a = hexToU8a(callData);\n\nconst result = await api.call.dryRunApi.dryRunCall(\n  { system: { Signed: testAccount } },\n  callDataU8a\n);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { hexToU8a } from '@polkadot/util';\n\nconst main = async () =&gt; {\n  try {\n    // Construct API provider\n    const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n    const api = await ApiPromise.create({ provider: wsProvider });\n\n    console.log('Connected to the API. Preparing dry run call...');\n\n    // Create a test account (you should replace this with an actual account)\n    const testAccount = api.createType(\n      'AccountId20',\n      '0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798'\n    );\n\n    // The call data (replace with your actual call data)\n    const callData =\n      '0x1c030408000400010403001300008a5d784563010d010204000103003cd0a705a2dc65e5b1e1205896baa2be8a07c6e007803822b001ba2e0100'; // Your hex-encoded call data\n\n    // Convert hex to Uint8Array\n    const callDataU8a = hexToU8a(callData);\n\n    // Perform the dry run call\n    const result = await api.call.dryRunApi.dryRunCall(\n      { system: { Signed: testAccount } }, // origin\n      callDataU8a // call\n    );\n\n    console.log(\n      'Dry run XCM result:',\n      JSON.stringify(result.toJSON(), null, 2)\n    );\n\n    // Disconnect the API\n    await api.disconnect();\n    console.log('Disconnected from the API.');\n  } catch (error) {\n    console.error('An error occurred:', error);\n  }\n};\n\nmain().catch(console.error);\n</code></pre> <p>Upon calling the XCM Dry Run API, the method will tell you whether the call would be successful and returns the event data that would be emitted if the call were actually submitted on chain. You can view the initial output of the <code>dryRunCall</code> below.</p> View the complete output <pre><code>Dry run XCM result: {\n  \"ok\": {\n    \"executionResult\": {\n      \"ok\": {\n        \"actualWeight\": {\n          \"refTime\": 7301615000,\n          \"proofSize\": 20928\n        },\n        \"paysFee\": \"Yes\"\n      }\n    },\n    \"emittedEvents\": [\n      {\n        \"index\": \"0x030b\",\n        \"data\": [\n          \"0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798\",\n          \"0x0000000000000000016345785d8a0000\"\n        ]\n      },\n      {\n        \"index\": \"0x0300\",\n        \"data\": [\n          \"0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0\",\n          \"0x0000000000000000016345785d8a0000\"\n        ]\n      },\n      {\n        \"index\": \"0x030a\",\n        \"data\": [\n          \"0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0\",\n          \"0x0000000000000000016345785d8a0000\"\n        ]\n      },\n      {\n        \"index\": \"0x1c00\",\n        \"data\": [\n          {\n            \"complete\": {\n              \"used\": {\n                \"refTime\": 7250000000,\n                \"proofSize\": 19374\n              }\n            }\n          }\n        ]\n      }\n    ],\n    \"localXcm\": {\n      \"v4\": [\n        {\n          \"withdrawAsset\": [\n            {\n              \"id\": {\n                \"parents\": 0,\n                \"interior\": {\n                  \"x1\": [\n                    {\n                      \"palletInstance\": 3\n                    }\n                  ]\n                }\n              },\n              \"fun\": {\n                \"fungible\": \"0x0000000000000000016345785d8a0000\"\n              }\n            }\n          ]\n        },\n        {\n          \"depositAsset\": {\n            \"assets\": {\n              \"wild\": {\n                \"allCounted\": 1\n              }\n            },\n            \"beneficiary\": {\n              \"parents\": 0,\n              \"interior\": {\n                \"x1\": [\n                  {\n                    \"accountKey20\": {\n                      \"network\": null,\n                      \"key\": \"0x3cd0a705a2dc65e5b1e1205896baa2be8a07c6e0\"\n                    }\n                  }\n                ]\n              }\n            }\n          }\n        }\n      ]\n    } // Additional events returned here\n      // Omitted for clarity \n</code></pre>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#dry-run-xcm-api-method","title":"Dry Run XCM API Method","text":"<p>The <code>dryRunXCM</code> method of the XCM Dry Run API takes a full XCM message as a parameter instead of an encoded call, as well as the origin of the message.</p> <p><code>dryRunXCM</code> takes as a parameter the origin and the XCM message and returns an execution result, actual weight, and event data.  </p> <pre><code>// Define the origin\nconst origin = { V4: { parents: 1, interior: 'Here' } };\n\nconst message = []; // Insert XCM Message Here\n\n// Perform the dry run XCM call\nconst result = await api.call.dryRunApi.dryRunXcm(origin, message);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { hexToU8a } from '@polkadot/util';\n\nconst main = async () =&gt; {\n  try {\n    // Construct API provider\n    const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n    const api = await ApiPromise.create({ provider: wsProvider });\n    console.log('Connected to the API. Preparing dry run XCM call...');\n\n    // Define the origin\n    const origin = { V4: { parents: 1, interior: 'Here' } };\n    const amountToSend = 1000000000000;\n\n    const message = {\n      V4: [\n        {\n          WithdrawAsset: [\n            {\n              id: { parents: 1, interior: 'Here' },\n              fun: { Fungible: amountToSend },\n            },\n          ],\n        },\n        {\n          BuyExecution: {\n            fees: {\n              id: { parents: 1, interior: 'Here' },\n              fun: { Fungible: amountToSend },\n            },\n            weightLimit: { Unlimited: null },\n          },\n        },\n        {\n          DepositAsset: {\n            assets: { Wild: { AllOf: { id: { parents: 1, interior: 'Here' } } } },\n            maxAssets: 1,\n            beneficiary: {\n              parents: 0,\n              interior: {\n                X1: [\n                  {\n                    AccountKey20: {\n                      network: null,\n                      key: hexToU8a('0x3B939FeaD1557C741Ff06492FD0127bd287A421e')\n                    }\n                  }\n                ]\n              }\n            }\n          }\n        }\n      ],\n    };\n\n    // Perform the dry run XCM call\n    const result = await api.call.dryRunApi.dryRunXcm(origin, message);\n\n    console.log(\n      'Dry run XCM result:',\n      JSON.stringify(result.toJSON(), null, 2)\n    );\n\n    await api.disconnect();\n    console.log('Disconnected from the API.');\n  } catch (error) {\n    console.error('An error occurred:', error);\n  }\n};\n\nmain().catch(console.error);\n</code></pre> <p>Upon calling the XCM Dry Run API, the method will tell you whether the call would be successful and returns the event data that would be emitted if the XCM were to be actually submitted on chain. You can view the initial output of the <code>dryRunXCM</code> below.</p> View the complete output <pre><code>Dry run XCM result: {\n  \"ok\": {\n    \"executionResult\": {\n      \"complete\": {\n        \"used\": {\n          \"refTime\": 76473048000,\n          \"proofSize\": 222483\n        }\n      }\n    },\n    \"emittedEvents\": [\n      {\n        \"index\": \"0x1d03\",\n        \"data\": [\n          \"0x1fcacbd218edc0eba20fc2308c778080\",\n          \"0x506172656E740000000000000000000000000000\",\n          1000000000000\n        ]\n      },\n      {\n        \"index\": \"0x1d01\",\n        \"data\": [\n          \"0x1fcacbd218edc0eba20fc2308c778080\",\n          \"0x3B939FeaD1557C741Ff06492FD0127bd287A421e\",\n          959944978002\n        ]\n      },\n      {\n        \"index\": \"0x1d01\",\n        \"data\": [\n          \"0x1fcacbd218edc0eba20fc2308c778080\",\n          \"0x6d6F646c70632f74727372790000000000000000\",\n          40055021998\n        ]\n      }\n    ], // Additional events returned here\n      // Omitted for clarity \n</code></pre>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#execute-xcm-utils-precompile","title":"Execute an XCM Message with the XCM Utilities Precompile","text":"<p>In this section, you'll use the <code>xcmExecute</code> function of the XCM Utilities Precompile, which is only supported on Moonbase Alpha, to execute an XCM message locally. The XCM Utilities Precompile is located at the following address:</p> <pre><code>0x000000000000000000000000000000000000080C\n</code></pre> <p>Under the hood, the <code>xcmExecute</code> function of the XCM Utilities Precompile calls the <code>execute</code> function of the Polkadot XCM Pallet, which is a Substrate pallet that is coded in Rust. The benefit of using the XCM Utilities Precompile to call <code>xcmExecute</code> is that you can do so via the Ethereum API and use Ethereum libraries like Ethers.js.</p> <p>The <code>xcmExecute</code> function accepts two parameters: the SCALE encoded versioned XCM message to be executed and the maximum weight to be consumed.</p> <p>First, you'll learn how to generate the encoded calldata, and then you'll learn how to use the encoded calldata to interact with the XCM Utilities Precompile.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#generate-encoded-calldata","title":"Generate the Encoded Calldata of an XCM Message","text":"<p>To get the encoded calldata of the XCM message, you can create a script similar to the one you created in the Execute an XCM Message with the Polkadot.js API section. Instead of building the message and sending the transaction, you'll build the message to get the encoded calldata. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The Moonbase Alpha endpoint URL to create the provider</li> <li>The values for each of the parameters of the <code>execute</code> function as defined in the Execute an XCM Message with the Polkadot.js API section</li> </ul> </li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>polkadotXcm.execute</code> extrinsic with the <code>message</code> and <code>maxWeight</code></li> <li>Use the transaction to get the encoded calldata</li> </ol> <p>The entire script is as follows:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\n// 1. Provide input data\nconst moonbeamAccount = 'INSERT_ADDRESS';\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 100000000000000000n },\n    },\n  ],\n};\nconst instr2 = {\n  DepositAsset: {\n    assets: { Wild: { AllCounted: 1 } },\n    beneficiary: {\n      parents: 0,\n      interior: {\n        X1: [\n          {\n            AccountKey20: {\n              key: moonbeamAccount,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\nconst message = { V4: [instr1, instr2] };\nconst maxWeight = { refTime: 7250000000n, proofSize: 19374n };\n\nconst getEncodedXcmMessage = async () =&gt; {\n  // 2. Create Substrate API provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Craft the extrinsic\n  const tx = api.tx.polkadotXcm.execute(message, maxWeight);\n\n  // 4. Get the encoded XCM message\n  // By using index 0, you'll get just the encoded XCM message.\n  // If you wanted to get the maxWeight, you could use index 1\n  const encodedXcmMessage = tx.args[0].toHex();\n  console.log(`Encoded Calldata for XCM Message: ${encodedXcmMessage}`);\n\n  api.disconnect();\n};\n\ngetEncodedXcmMessage();\n</code></pre>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#execute-xcm-message","title":"Execute the XCM Message","text":"<p>Now that you have the SCALE encoded XCM message, you can use the following code snippets to programmatically call the <code>xcmExecute</code> function of the XCM Utilities Precompile using your Ethereum library of choice. Generally speaking, you'll take the following steps:</p> <ol> <li>Create a provider and signer</li> <li>Create an instance of the XCM Utilities Precompile to interact with</li> <li>Define parameters required for the <code>xcmExecute</code> function, which will be the encoded calldata for the XCM message and the maximum weight to use to execute the message. You can set the <code>maxWeight</code> to be <code>400000000n</code>, which corresponds to the <code>refTime</code>. The <code>proofSize</code> will automatically be set to the default, which is 64KB</li> <li>Execute the XCM message</li> </ol> <p>Remember</p> <p>The following snippets are for demo purposes only. Never store your private keys in a JavaScript or Python file.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport abi from './xcmUtilsABI.js'; // Import the XCM Utilities Precompile ABI\n\nconst privateKey = 'INSERT_YOUR_PRIVATE_KEY';\nconst xcmUtilsAddress = '0x000000000000000000000000000000000000080C';\n\n/* Create Ethers provider and signer */\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n/* Create contract instance of the XCM Utilities Precompile */\nconst xcmUtils = new ethers.Contract(\n  xcmUtilsAddress,\n  abi,\n  signer\n);\n\nconst executeXcmMessageLocally = async () =&gt; {\n  /* Define parameters required for the xcmExecute function */\n  const encodedCalldata = 'INSERT_ENCODED_CALLDATA';\n  const maxWeight = '400000000';\n\n  /* Execute the custom XCM message */\n  const tx = await xcmUtils.xcmExecute(encodedCalldata, maxWeight);\n  await tx.wait();\n  console.log(`Transaction receipt: ${tx.hash}`);\n};\n\nexecuteXcmMessageLocally();\n</code></pre> <pre><code>import { Web3 } from 'web3'; // Import Web3 library\nimport abi from './xcmUtilsABI.js'; // Import the XCM Utilities Precompile ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst accountFrom = web3.eth.accounts.privateKeyToAccount(privateKey).address;\nconst xcmUtilsAddress = '0x000000000000000000000000000000000000080C';\n\n/* Create Web3 provider */\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n/* Create contract instance of the XCM Utilities Precompile */\nconst xcmUtils = new web3.eth.Contract(\n  abi,\n  xcmUtilsAddress,\n  { from: accountFrom } // 'from' is necessary for gas estimation\n);\n\nconst executeXcmMessageLocally = async () =&gt; {\n  /* Define parameters required for the xcmExecute function */\n  const encodedCalldata = 'INSERT_ENCODED_CALLDATA';\n  const maxWeight = '400000000';\n\n  /* Send the custom XCM message */\n  // Craft the extrinsic\n  const tx = await xcmUtils.methods.xcmExecute(encodedCalldata, maxWeight);\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: xcmUtilsAddress,\n      data: tx.encodeABI(),\n      gas: await tx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom),\n    },\n    privateKey\n  );\n  // Send the signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(`Transaction receipt: ${sendTx.transactionHash}`);\n};\n\nexecuteXcmMessageLocally();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_XCM_UTILS_ABI\"  # Paste or import the XCM Utils ABI\n# This is for demo purposes, never store your private key in plain text\nprivate_key = \"INSERT_PRIVATE_KEY\"\n# The wallet address that corresponds to your private key\naddress = \"INSERT_ADDRESS\"\nxcm_utils_address = \"0x000000000000000000000000000000000000080C\"\n\n## Create Web3 provider ##\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n## Create contract instance of the XCM Utilities Precompile ##\nxcm_utils = web3.eth.contract(\n    # XCM Utilities Precompile address\n    address=xcm_utils_address,\n    abi=abi,\n)\n\n\ndef execute_xcm_message_locally():\n    ## Define parameters required for the xcmExecute function ##\n    encoded_calldata = \"INSERT_ENCODED_CALLDATA\"\n    max_weight = 400000000\n\n    ## Execute the custom XCM message ##\n    # Craft the extrinsic\n    tx = xcm_utils.functions.xcmExecute(encoded_calldata, max_weight).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n    # Sign transaction\n    signedTx = web3.eth.account.sign_transaction(tx, private_key)\n    # Send tx\n    hash = web3.eth.send_raw_transaction(signedTx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Transaction receipt: { receipt.transactionHash.hex() }\")\n\n\nexecute_xcm_message_locally()\n</code></pre> <p>And that's it! You've successfully used the Polkadot XCM Pallet and the XCM Utilities Precompile to execute a custom XCM message locally on Moonbase Alpha!</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#send-xcm-message","title":"Send an XCM Message Cross-Chain","text":"<p>This section of the guide covers the process of sending a custom XCM message cross-chain (i.e., from Moonbeam to a target chain, such as the relay chain) via two different methods: the <code>send</code> function of the Polkadot XCM Pallet and the <code>xcmSend</code> function of the XCM Utilities Precompile.</p> <p>For the XCM message to be successfully executed, the target chain needs to be able to understand the instructions in the message. If it doesn't, you'll see a <code>Barrier</code> filter on the destination chain. For security reasons, the XCM message is prepended with the <code>DescendOrigin</code> instruction to prevent XCM execution on behalf of the origin chain Sovereign account. The example in this section will not work for the reasons mentioned above, it is purely for demonstration purposes.</p> <p>In the following example, you'll be building an XCM message that contains the following XCM instructions, which will be executed in the Alphanet relay chain:</p> <ul> <li><code>WithdrawAsset</code> - removes assets and places them into the holding register</li> <li><code>BuyExecution</code> - takes the assets from holding to pay for execution fees. The fees to pay are determined by the target chain</li> <li><code>DepositAsset</code>- removes the assets from the holding register and deposits the equivalent assets to a beneficiary account</li> </ul> <p>Together, the intention of these instructions is to transfer the native asset of the relay chain, which is UNIT for the Alphanet relay chain, from Moonbase Alpha to an account on the relay chain. This example is for demonstration purposes only to show you how a custom XCM message could be sent cross-chain. Please keep in mind that the target chain needs to be able to understand the instructions in the message to execute them.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#send-xcm-message-with-polkadotjs-api","title":"Send an XCM Message with the Polkadot.js API","text":"<p>In this example, you'll send a custom XCM message from your account on Moonbase Alpha to the relay chain using the Polkadot.js API to interact directly with the Polkadot XCM Pallet.</p> <p>The <code>send</code> function of the Polkadot XCM Pallet accepts two parameters: <code>dest</code> and <code>message</code>. You can start assembling these parameters by taking the following steps:</p> <ol> <li> <p>Build the multilocation of the relay chain token, UNIT, for the <code>dest</code>:</p> <pre><code>const dest = { V4: { parents: 1, interior: null } };\n</code></pre> </li> <li> <p>Build the <code>WithdrawAsset</code> instruction, which will require you to define:</p> <ul> <li>The multilocation of the UNIT token on the relay chain</li> <li>The amount of UNIT tokens to withdraw</li> </ul> <pre><code>const instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n  ],\n};\n</code></pre> </li> <li> <p>Build the <code>BuyExecution</code> instruction, which will require you to define:</p> <ul> <li>The multilocation of the UNIT token on the relay chain</li> <li>The amount of UNIT tokens to buy for execution</li> <li>The weight limit</li> </ul> <pre><code>const instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n    { Unlimited: null },\n  ],\n};\n</code></pre> </li> <li> <p>Build the <code>DepositAsset</code> instruction, which will require you to define:</p> <ul> <li>The asset identifier for UNIT tokens. You can use the <code>WildAsset</code> format, which allows for wildcard matching, to identify the asset</li> <li>The multilocation of the beneficiary account on the relay chain</li> </ul> <pre><code>const instr3 = {\n  DepositAsset: {\n    assets: { Wild: 'All' },\n    beneficiary: {\n      parents: 1,\n      interior: {\n        X1: [\n          {\n            AccountId32: {\n              id: relayAccount,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\n</code></pre> </li> <li> <p>Combine the XCM instructions into a versioned XCM message:</p> <pre><code>const message = { V4: [instr1, instr2, instr3] };\n</code></pre> </li> </ol> <p>Now that you have the values for each of the parameters, you can write the script to send the XCM message. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The Moonbase Alpha endpoint URL to create the provider</li> <li>The values for each of the parameters of the <code>send</code> function</li> </ul> </li> <li>Create a Keyring instance that will be used to send the transaction</li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>polkadotXcm.send</code> extrinsic with the <code>dest</code> and <code>message</code></li> <li>Send the transaction using the <code>signAndSend</code> extrinsic and the Keyring instance you created in the second step</li> </ol> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a JavaScript file.</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady, decodeAddress } from '@polkadot/util-crypto';\n\n// 1. Input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\n// You can use the decodeAddress function to ensure that your address is properly\n// decoded. If it isn't decoded, it will decode it and if it is, it will ignore it\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst relayAccount = decodeAddress('INSERT_ADDRESS');\nconst dest = { V4: { parents: 1, interior: null } };\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n  ],\n};\nconst instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n    { Unlimited: null },\n  ],\n};\nconst instr3 = {\n  DepositAsset: {\n    assets: { Wild: 'All' },\n    beneficiary: {\n      parents: 1,\n      interior: {\n        X1: [\n          {\n            AccountId32: {\n              id: relayAccount,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\nconst message = { V4: [instr1, instr2, instr3] };\n\nconst sendXcmMessage = async () =&gt; {\n  // 2. Create Keyring instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'ethereum' });\n  const alice = keyring.addFromUri(privateKey);\n\n  // 3. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 4. Create the extrinsic\n  const tx = api.tx.polkadotXcm.send(dest, message);\n\n  // 5. Send the transaction\n  const txHash = await tx.signAndSend(alice);\n  console.log(`Submitted with hash ${txHash}`);\n\n  api.disconnect();\n};\n\nsendXcmMessage();\n</code></pre> <p>Note</p> <p>You can view an example of the above script, which sends 1 UNIT to Bob's relay chain account, on Polkadot.js Apps using the following encoded calldata: <code>0x1c00040100040c0004010000070010a5d4e813010000070010a5d4e8000d0100010101000c36e9ba26fa63c60ec728fe75fe57b86a450d94e7fee7f9f9eddd0d3f400d67</code>.</p> <p>Once the transaction is processed, a <code>polkadotXcm.sent</code> event is emitted with the details of the sent XCM message.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#send-xcm-utils-precompile","title":"Send an XCM Message with the XCM Utilities Precompile","text":"<p>In this section, you'll use the <code>xcmSend</code> function of the XCM Utilities Precompile, which is only supported on Moonbase Alpha, to send an XCM message cross-chain. The XCM Utilities Precompile is located at the following address:</p> Moonbase Alpha <pre><code>0x000000000000000000000000000000000000080C\n</code></pre> <p>Under the hood, the <code>xcmSend</code> function of the XCM Utilities Precompile calls the <code>send</code> function of the Polkadot XCM Pallet, which is a Substrate pallet that is coded in Rust. The benefit of using the XCM Utilities Precompile to call <code>xcmSend</code> is that you can do so via the Ethereum API and use Ethereum libraries like Ethers.js. For the XCM message to be successfully executed, the target chain needs to be able to understand the instructions in the message.</p> <p>The <code>xcmSend</code> function accepts two parameters: the multilocation of the destination and the SCALE encoded versioned XCM message to be sent.</p> <p>First, you'll learn how to generate the encoded calldata for the XCM message, and then you'll learn how to use the encoded calldata to interact with the XCM Utilities Precompile.</p>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#generate-encoded-calldata","title":"Generate the Encoded Calldata of an XCM Message","text":"<p>To get the encoded calldata of the XCM message, you can create a script similar to the one you created in the Send an XCM Message with the Polkadot.js API section. Instead of building the message and sending the transaction, you'll build the message to get the encoded calldata. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The Moonbase Alpha endpoint URL to create the provider</li> <li>The values for each of the parameters of the <code>send</code> function as defined in the Send an XCM Message with the Polkadot.js API section</li> </ul> </li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>polkadotXcm.execute</code> extrinsic with the <code>message</code> and <code>maxWeight</code></li> <li>Use the transaction to get the encoded calldata</li> </ol> <p>The entire script is as follows:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\nimport { decodeAddress } from '@polkadot/util-crypto';\n\n// 1. Input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\n// You can use the decodeAddress function to ensure that your address is properly\n// decoded. If it isn't decoded, it will decode it and if it is, it will ignore it\nconst relayAccount = decodeAddress('INSERT_ADDRESS');\nconst dest = { V4: { parents: 1, interior: null } };\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n  ],\n};\nconst instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 1, interior: null },\n      fun: { Fungible: 1000000000000n }, // 1 UNIT\n    },\n    { Unlimited: null },\n  ],\n};\nconst instr3 = {\n  DepositAsset: {\n    assets: { Wild: 'All' },\n    beneficiary: {\n      parents: 1,\n      interior: {\n        X1: [\n          {\n            AccountId32: {\n              id: relayAccount,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\nconst message = { V4: [instr1, instr2, instr3] };\n\nconst generateEncodedXcmMessage = async () =&gt; {\n  // 2. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Create the extrinsic\n  const tx = api.tx.polkadotXcm.send(dest, message);\n\n  // 4. Get the encoded XCM message\n  // By using index 1, you'll get just the encoded XCM message.\n  // If you wanted to get the dest, you could use index 0\n  const encodedXcmMessage = tx.args[1].toHex();\n  console.log(`Encoded Calldata for XCM Message: ${encodedXcmMessage}`);\n\n  api.disconnect();\n};\n\ngenerateEncodedXcmMessage();\n</code></pre>"},{"location":"builders/interoperability/xcm/send-execute-xcm/#send-xcm-message","title":"Send the XCM Message","text":"<p>Before you can send the XCM message, you'll also need to build the multilocation of the destination. For this example, you'll target the relay chain with Moonbase Alpha as the origin chain:</p> <pre><code>const dest = [\n  1, // Parents: 1 \n  [] // Interior: Here\n];\n</code></pre> <p>Now that you have the SCALE encoded XCM message and the destination multilocation, you can use the following code snippets to programmatically call the <code>xcmSend</code> function of the XCM Utilities Precompile using your Ethereum library of choice. Generally speaking, you'll take the following steps:</p> <ol> <li>Create a provider and signer</li> <li>Create an instance of the XCM Utilities Precompile to interact with</li> <li>Define parameters required for the <code>xcmSend</code> function, which will be the destination and the encoded calldata for the XCM message</li> <li>Send the XCM message</li> </ol> <p>Remember</p> <p>The following snippets are for demo purposes only. Never store your private keys in a JavaScript or Python file.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport abi from './xcmUtilsABI.js'; // Import the XCM Utilities Precompile ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst xcmUtilsAddress = '0x000000000000000000000000000000000000080C';\n\n/* Create Ethers provider and signer */\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n/* Create contract instance of the XCM Utilities Precompile */\nconst xcmUtils = new ethers.Contract(\n  xcmUtilsAddress,\n  abi,\n  signer\n);\n\nconst sendXcm = async () =&gt; {\n  /* Define parameters required for the xcmSend function */\n  const encodedCalldata = 'INSERT_ENCODED_CALLDATA';\n  const dest = [\n    1, // Parents: 1 \n    [] // Interior: Here\n  ];\n\n  /* Send the custom XCM message */\n  const tx = await xcmUtils.xcmSend(dest, encodedCalldata);\n  await tx.wait();\n  console.log(`Transaction receipt: ${tx.hash}`);\n};\n\nsendXcm();\n</code></pre> <pre><code>import { Web3 } from 'web3'; // Import Web3 library\nimport abi from './xcmUtilsABI.js'; // Import the XCM Utilities Precompile ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst accountFrom = web3.eth.accounts.privateKeyToAccount(privateKey).address;\nconst xcmUtilsAddress = '0x000000000000000000000000000000000000080C';\n\n/* Create Web3 provider */\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n/* Create contract instance of the XCM Utilities Precompile */\nconst xcmUtils = new web3.eth.Contract(\n  abi,\n  xcmUtilsAddress,\n  { from: accountFrom } // 'from' is necessary for gas estimation\n);\n\nconst sendXcm = async () =&gt; {\n  /* Define parameters required for the xcmSend function */\n  const encodedCalldata = 'INSERT_ENCODED_CALLDATA';\n  const dest = [\n    1, // Parents: 1\n    [], // Interior: Here\n  ];\n\n  /* Send the custom XCM message */\n  // Craft the extrinsic\n  const tx = await xcmUtils.methods.xcmSend(dest, encodedCalldata);\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: xcmUtilsAddress,\n      data: tx.encodeABI(),\n      gas: await tx.estimateGas(),\n      gasPrice: await web3.eth.getGasPrice(),\n      nonce: await web3.eth.getTransactionCount(accountFrom),\n    },\n    privateKey\n  );\n  // Send the signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(`Transaction receipt: ${sendTx.transactionHash}`);\n};\n\nsendXcm();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_XCM_UTILS_ABI\"  # Paste or import the XCM Utils ABI\n# This is for demo purposes, never store your private key in plain text\nprivate_key = \"INSERT_PRIVATE_KEY\"\n# The wallet address that corresponds to your private key\naddress = \"INSERT_ADDRESS\"\nxcm_utils_address = \"0x000000000000000000000000000000000000080C\"\n\n## Create Web3 provider ##\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n## Create contract instance of the XCM Utilities Precompile ##\nxcm_utils = web3.eth.contract(\n    # XCM Utilities Precompile address\n    address=xcm_utils_address,\n    abi=abi,\n)\n\n\ndef send_xcm():\n    ## Define parameters required for the xcmSend function ##\n    encoded_calldata = \"INSERT_ENCODED_CALLDATA\"\n    xcm_dest = [1, []]  # Parents: 1  # Interior: Here\n\n    ## Send the custom XCM message ##\n    # Craft the extrinsic\n    tx = xcm_utils.functions.xcmSend(xcm_dest, encoded_calldata).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n    # Sign transaction\n    signed_tx = web3.eth.account.sign_transaction(tx, private_key)\n    # Send tx\n    hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Transaction receipt: { receipt.transactionHash.hex() }\")\n\n\nsend_xcm()\n</code></pre> <p>And that's it! You've successfully used the Polkadot XCM Pallet and the XCM Utilities Precompile to send a message from Moonbase Alpha to another chain!</p>"},{"location":"builders/interoperability/xcm/xcm-utils/","title":"Interacting with the XCM Utilities Precompile","text":""},{"location":"builders/interoperability/xcm/xcm-utils/#xcmutils-precompile","title":"Introduction","text":"<p>The XCM Utilities Precompile contract gives developers XCM-related utility functions directly within the EVM. This allows for easier transactions and interactions with other XCM-related precompiles.</p> <p>Similar to other precompile contracts, the XCM Utilities Precompile is located at the following addresses:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x000000000000000000000000000000000000080C\n</code></pre> <pre><code>0x000000000000000000000000000000000000080C\n</code></pre> <pre><code>0x000000000000000000000000000000000000080C\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/interoperability/xcm/xcm-utils/#xcmutils-solidity-interface","title":"The XCM Utilities Solidity Interface","text":"<p>XcmUtils.sol is an interface to interact with the precompile.</p> <p>Note</p> <p>The precompile will be updated in the future to include additional features. Feel free to suggest additional utility functions in the Discord.</p> <p>The interface includes the following functions:</p> <ul> <li>multilocationToAddress(Multilocation memory multilocation) \u2014 read-only function that returns the Computed Origin account from a given multilocation</li> <li>weightMessage(bytes memory message) \u2014 read-only function that returns the weight that an XCM message will consume on the chain. The message parameter must be a SCALE encoded XCM versioned XCM message</li> <li> <p>getUnitsPerSecond(Multilocation memory multilocation) \u2014 read-only function that gets the units per second for a given asset in the form of a <code>Multilocation</code>. The multilocation must describe an asset that can be supported as a fee payment, such as an external XC-20, or else this function will revert. </p> <p>Note</p> <p>Note that this function still returns units per second data but units per second has been deprecated and replaced by the calculation of relative price. See XC asset registration for more details.</p> </li> <li> <p>xcmExecute(bytes memory message, uint64 maxWeight) - available on Moonbase Alpha only -  executes a custom XCM message given the SCALE encoded versioned message to be executed and the maximum weight to be consumed. This function cannot be called from a smart contract due to the nature of the <code>Transact</code> instruction</p> </li> <li>xcmSend(Multilocation memory dest, bytes memory message) - available on Moonbase Alpha only - sends a custom XCM message given the multilocation of the destination chain to send the message to and the SCALE encoded versioned message to be sent</li> </ul> <p>The <code>Multilocation</code> struct in the XCM Utilities Precompile is built the same as the XCM Transactor Precompile's <code>Multilocation</code>.</p>"},{"location":"builders/interoperability/xcm/xcm-utils/#using-the-xcmutils-precompile","title":"Using the XCM Utilities Precompile","text":"<p>The XCM Utilities precompile allows users to read data off of the Ethereum JSON-RPC instead of having to go through a Polkadot library. The functions are more for convenience, and less for smart contract use cases.</p> <p>For <code>multilocationToAddress</code>, one example use case is being able to allow transactions that originate from other parachains by whitelisting their Computed Origin addresses. A user can whitelist a multilocation by calculating and storing an address. EVM transactions can originate from other parachains via remote EVM calls.  </p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\nimport \"https://github.com/moonbeam-foundation/moonbeam/blob/master/precompiles/xcm-utils/XcmUtils.sol\";\n\ncontract MultilocationWhitelistExample {\n    XcmUtils xcmutils = XcmUtils(0x000000000000000000000000000000000000080C);\n    mapping(address =&gt; bool) public whitelistedAddresses;\n\n    modifier onlyWhitelisted(address addr) {\n        _;\n        require(whitelistedAddresses[addr], \"Address not whitelisted!\");\n        _;\n    }\n\n    function addWhitelistedMultilocation(\n        XcmUtils.Multilocation calldata externalMultilocation\n    ) external onlyWhitelisted(msg.sender) {\n        address derivedAddress = xcmutils.multilocationToAddress(\n            externalMultilocation\n        );\n        whitelistedAddresses[derivedAddress] = true;\n    }\n\n    ...\n}\n</code></pre> <p>To check out an example of how to use the <code>xcmExecute</code> function to execute a custom XCM message locally, please refer to the Create and Execute Custom XCM Messages guide.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/","title":"XCM Instructions","text":""},{"location":"builders/interoperability/xcm/core-concepts/instructions/#introduction","title":"Introduction","text":"<p>XCM messages contain a series of actions and instructions that are executed by the Cross-Consensus Virtual Machine (XCVM). An action (for example, transferring a token from one blockchain to another) consists of instructions that the XCVM partly executes in the origin and destination chains.</p> <p>For example, an XCM message that transfers DOT from Polkadot to Moonbeam will include the following XCM instructions (in that order), some of which are executed on Polkadot and some of which are executed on Moonbeam:</p> <ol> <li>TransferReserveAsset \u2014 executed in Polkadot</li> <li>ReserveAssetDeposited \u2014 executed in Moonbeam</li> <li>ClearOrigin \u2014 executed in Moonbeam</li> <li>BuyExecution \u2014 executed in Moonbeam</li> <li>DepositAsset \u2014 executed in Moonbeam</li> </ol> <p>Building the instructions for an XCM message from scratch is not an easy task. Consequently, there are wrapper functions and pallets that developers can leverage to use XCM features. The Polkadot XCM and XCM Transactor Pallets provide functions with a predefined set of XCM instructions to either send XC-20s or remotely execute on other chains via XCM.</p> <p>If you're interested in experimenting with different combinations of instructions, you can use the Polkadot XCM Pallet to execute and send custom XCM messages.</p> <p>This guide provides an overview of some of the most commonly used XCM instructions, including those in the above example.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#buy-execution","title":"Buy Execution","text":"<p>The <code>BuyExecution</code> instruction typically gets executed in the target chain. It takes assets from the holding register, a temporary position in the Cross-Consensus Virtual Machine (XCVM), to pay for execution fees. The target chain determines the fees to pay.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#clear-origin","title":"Clear Origin","text":"<p>The <code>ClearOrigin</code> instruction gets executed in the target chain. It clears the origin of the XCM author, thereby ensuring that later XCM instructions cannot command the authority of the author.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#deposit-asset","title":"Deposit Asset","text":"<p>The <code>DepositAsset</code> instruction gets executed in the target chain. It removes the assets from the holding register, a temporary position in the Cross-Consensus Virtual Machine (XCVM), and sends them to a destination account on the target chain.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#descend-origin","title":"Descend Origin","text":"<p>The <code>DescendOrigin</code> instruction gets executed in the target chain. It mutates the origin on the target chain to match the origin on the source chain, ensuring execution on the target chain occurs on behalf of the same entity initiating the XCM message on the source chain.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#initiate-reserve-withdraw","title":"Initiate Reserve Withdraw","text":"<p>The <code>InitiateReserveWithdraw</code> instruction gets executed in the source chain. It removes the assets from the holding register, a temporary position in the Cross-Consensus Virtual Machine (XCVM), (essentially burning them), and sends an XCM message to the reserve chain starting with the <code>WithdrawAsset</code> instruction.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#refund-surplus","title":"Refund Surplus","text":"<p>The <code>RefundSurplus</code> instruction typically gets executed in the target chain after the XCM is processed. This instruction will take any leftover assets from the <code>BuyExecution</code> instruction and put the assets into the holding register, a temporary position in the Cross-Consensus Virtual Machine (XCVM).</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#reserve-asset-deposited","title":"Reserve Asset Deposited","text":"<p>The <code>ReserveAssetDeposited</code> instruction gets executed in the target chain. It takes a representation of the assets received in the Sovereign account and places them into the holding register, a temporary position in the Cross-Consensus Virtual Machine (XCVM).</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#set-appendix","title":"Set Appendix","text":"<p>The <code>SetAppendix</code> instruction gets executed in the target chain. It sets the appendix register, which holds code that should be run after the current execution is finished.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#transfer-reserve-asset","title":"Transfer Reserve Asset","text":"<p>The <code>TransferReserveAsset</code> instruction gets executed in the reserve chain. It moves assets from the origin account and deposits them into a destination account on the target chain. It then sends an XCM message to the target chain with the <code>ReserveAssetDeposited</code> instruction, followed by the XCM instructions that are to be executed.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#transact","title":"Transact","text":"<p>The <code>Transact</code> instruction gets executed in the target chain. It dispatches encoded call data from a given origin, allowing for the execution of specific operations or functions on the target chain.</p>"},{"location":"builders/interoperability/xcm/core-concepts/instructions/#withdraw-asset","title":"Withdraw Asset","text":"<p>The <code>WithdrawAsset</code> instruction can be executed in either the source or target chain. It removes assets and places them into the holding register, a temporary position in the Cross-Consensus Virtual Machine (XCVM).</p>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/","title":"Multilocations","text":""},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#introduction","title":"Introduction","text":"<p>A multilocation defines a specific point in the entire relay chain/parachain ecosystem relative to a given origin. It can be used to target a specific parachain, asset, account, or even a pallet inside a parachain.</p> <p>Multilocations follow a hierarchical structure, in which some locations are encapsulated within others. For example, a relay chain encapsulates all of the parachains that are connected to it. Similarly, a parachain encapsulates all of the pallets, accounts, and assets that exist within it.</p> <p></p>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#defining-a-multilocation","title":"Defining a Multilocation","text":"<p>A multilocation contains two parameters:</p> <ul> <li><code>parents</code> - refers to how many \"hops\" up into a parent blockchain you need to take from a given origin. From the perspective of a parachain within the relay chain ecosystem, there can only be one parent, so the value for <code>parents</code> can only ever be <code>0</code> to represent the parachain or <code>1</code> to represent the relay chain. When defining universal locations that consider other consensus systems like Ethereum, <code>parents</code> can have higher values</li> <li><code>interior</code> - refers to how many fields you need to define the target point. From the relay chain, you can drill down to target a specific parachain, or account, asset, or pallet on that parachain. Since this downward movement can be more complex, Junctions are used to represent the steps needed to reach the target location and are defined by <code>XN</code>, where <code>N</code> is the number of Junctions required. If no Junctions are required to define the target point, its value would be <code>Here</code> as opposed to <code>X1</code></li> </ul> <p>For example, if you are targeting the relay chain specifically, you'll use <code>Here</code> since you aren't defining an account on the relay chain, a parachain, or a specific point within a parachain.</p> <p>On the flip side, if you're targeting an account on the relay chain, or a parachain, or a specific point within a parachain, you'll use one or more Junctions, as needed.</p>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#junctions","title":"Junctions","text":"<p>A Junction can be any of the following:</p> <ul> <li> <p><code>Parachain</code> - describes a parachain using the parachain's ID</p> <pre><code>{ Parachain: INSERT_PARACHAIN_ID }\n</code></pre> </li> <li> <p><code>AccountId32</code> - describes a 32-byte Substrate-style account. Accepts an optional <code>network</code> parameter, which can be one of the following: <code>Any</code>, <code>Named</code>, <code>Polkadot</code>, or <code>Kusama</code></p> <pre><code>{ AccountId32: { id: INSERT_ADDRESS, network: INSERT_NETWORK } }\n</code></pre> </li> <li> <p><code>AccountIndex64</code> - describes a 64-bit (8-byte) index for an account. Accepts an optional <code>network</code> parameter, which can be one of the following: <code>Any</code>, <code>Named</code>, <code>Polkadot</code>, or <code>Kusama</code></p> <pre><code>{ AccountIndex64: { index: INSERT_ACCOUNT_INDEX, network: INSERT_NETWORK } }\n</code></pre> </li> <li> <p><code>AccountKey20</code> - describes a 20-byte Ethereum-style account, as is used in Moonbeam. Accepts an optional <code>network</code> parameter, which can be one of the following: <code>Any</code>, <code>Named</code>, <code>Polkadot</code>, or <code>Kusama</code></p> <pre><code>{ AccountKey20: { key: INSERT_ADDRESS, network: INSERT_NETWORK } }\n</code></pre> </li> <li> <p><code>PalletInstance</code> - describes the index of a pallet on the target chain</p> <pre><code>{ PalletInstance: INSERT_PALLET_INSTANCE_INDEX }\n</code></pre> </li> <li> <p><code>GeneralIndex</code> - describes a nondescript index that can be used to target data stored in a key-value format</p> <pre><code>{ GeneralIndex: INSERT_GENERAL_INDEX }\n</code></pre> </li> <li> <p><code>GeneralKey</code> - describes a nondescript key that can be used to target more complex data structures. This requires you to specify the <code>data</code> and the <code>length</code> of the data</p> <pre><code>{ GeneralKey: { length: INSERT_LENGTH_OF_DATA, data: [INSERT_DATA] } }\n</code></pre> </li> <li> <p><code>OnlyChild</code> - describes the child of a location if there is only a one-to-one relation between the parent and child. This is currently not used except as a fallback when deriving context</p> </li> <li> <p><code>Plurality</code> - describes multiple elements that meet specific conditions or share common characteristics. This requires you to specify the Body ID and the Body Part that the Junction represents</p> <pre><code>{ Plurality: { id: INSERT_BODY_ID, part: INSERT_BODY_PART } }\n</code></pre> </li> </ul> <p>When using Junctions, you'll use <code>XN</code>, where <code>N</code> is the number of Junctions required to reach the target location. For example, if you're targeting an account on Moonbeam from a parachain, <code>parents</code> needs to be set to <code>1</code>, and you'll need to define two Junctions, the <code>Parachain</code> and the <code>AccountKey20</code>, so you'll use <code>X2</code>, which is an array that will contain each Junction:</p> <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2004 },\n      { AccountKey20: { key: 'INSERT_MOONBEAM_ADDRESS' } },\n    ],\n  },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#example-multilocations","title":"Example Multilocations","text":""},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-moonbeam-from-parachain","title":"Target Moonbeam from Another Parachain","text":"<p>To target a Moonbeam-based chain from another parachain, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 2004 }],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 2023 }],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 1000 }],\n  },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-account-moonbeam-from-parachain","title":"Target an Account on Moonbeam from Another Parachain","text":"<p>To target a specific account on a Moonbeam-based chain from another parachain, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2004 },\n      { AccountKey20: { key: 'INSERT_MOONBEAM_ADDRESS' } },\n    ],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2023 },\n      { AccountKey20: { key: 'INSERT_MOONBEAM_ADDRESS' } },\n    ],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 1000 },\n      { AccountKey20: { key: 'INSERT_MOONBEAM_ADDRESS' } },\n    ],\n  },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-moonbeam-native-asset-from-parachain","title":"Target Moonbeam's Native Asset from Another Parachain","text":"<p>To target the native asset of a Moonbeam-based chain from another parachain, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2004 },\n      { PalletInstance: 10 }, // Index of the Balances Pallet on Moonbeam\n    ],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 2023 },\n      { PalletInstance: 10 }, // Index of the Balances Pallet on Moonriver\n    ],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X2: [\n      { Parachain: 1000 },\n      { PalletInstance: 3 }, // Index of the Balances Pallet on Moonbase Alpha\n    ],\n  },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-moonbeam-from-relay","title":"Target Moonbeam from the Relay Chain","text":"<p>To target a Moonbeam-based chain from the relay chain, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 0,\n  interior: {\n    X1: [{ Parachain: 2004 }],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 0,\n  interior: {\n    X1: [{ Parachain: 2023 }],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 0,\n  interior: {\n    X1: [{ Parachain: 1000 }],\n  },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-relay-from-moonbeam","title":"Target the Relay Chain from Moonbeam","text":"<p>To target the relay chain from a Moonbeam-based chain, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: Here,\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: Here,\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: Here,\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-account-relay-from-moonbeam","title":"Target an Account on the Relay Chain from Moonbeam","text":"<p>To target a specific account on the relay chain, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: { X1: { AccountId32: { id: INSERT_RELAY_ADDRESS } } },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: { X1: { AccountId32: { id: INSERT_RELAY_ADDRESS } } },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: { X1: { AccountId32: { id: INSERT_RELAY_ADDRESS } } },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#target-parachain-from-moonbeam","title":"Target Another Parachain from Moonbeam","text":"<p>To target another parachain (for example, a parachain that has an ID of 1234) from Moonbeam, you would use the following multilocation:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 1234 }],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 1234 }],\n  },\n};\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X1: [{ Parachain: 1234 }],\n  },\n};\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/multilocations/#location-to-account-api","title":"Location to Account API","text":"<p>The Location to Account API is an easy way to convert a multilocation into an <code>AccountID20</code> address. The Location to Account API can be accessed from the Runtime Calls tab of the Developer section of Polkadot.js Apps. The <code>convertLocation</code> method of the Location to Account API takes a multilocation as a parameter and returns an <code>AccountID20</code> address.</p> <pre><code>// Query the locationToAccountApi using convertLocation method\nconst result =\n  await api.call.locationToAccountApi.convertLocation(multilocation);\nconsole.log('Conversion result:', result.toHuman());\n</code></pre> <p>You can view the complete script below.</p> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Define the multilocation parameter\n  const multilocation = {\n    V4: {\n      parents: 1,\n      interior: 'Here',\n    },\n  };\n\n  // Query the locationToAccountApi using convertLocation method\n  const result =\n    await api.call.locationToAccountApi.convertLocation(multilocation);\n  console.log('Conversion result:', result.toHuman());\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain().catch(console.error);\n</code></pre> <p>The method will return the <code>AccountID20</code> address corresponding to the provided multilocation as follows:</p> <pre><code>Conversion result: { Ok: '0x506172656E740000000000000000000000000000' }\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/sovereign-accounts/","title":"Overview of Sovereign Accounts","text":""},{"location":"builders/interoperability/xcm/core-concepts/sovereign-accounts/#introduction","title":"Introduction","text":"<p>In Polkadot-based ecosystems, a sovereign account is a unique, keyless account controlled by a blockchain\u2019s runtime through XCM rather than an individual or organization. These accounts are used to store assets when transferring tokens cross-chain. For example, if you send a reserve tokens transfer from a parachain to Moonbeam, the originating parachain locks those tokens in Moonbeam\u2019s sovereign account on the source chain, while a wrapped representation of those tokens is minted on Moonbeam.</p> <p>Sovereign accounts play a central role in reserve-backed transfers, where one chain (the \u201creserve\u201d) holds the real assets and other chains hold derivative tokens. When tokens move across chains, the reserve (or origin) chain locks or unlocks the underlying asset, and derivative tokens are minted or burned on the destination chain.</p>"},{"location":"builders/interoperability/xcm/core-concepts/sovereign-accounts/#calculating-sovereign","title":"Calculating a Parachain Sovereign Account","text":"<p>You can calculate a parachain\u2019s sovereign account on a given relay chain using the xcm-tools repository. This is especially useful when you need to verify where underlying tokens are locked or to fund a parachain\u2019s sovereign account directly.</p> <ol> <li>Clone or navigate to the xcm-tools repository</li> <li>Use the <code>calculate-sovereign-account</code> script, specifying the Parachain ID with the <code>--p</code> flag and the relay chain with the <code>--r</code> flag (default is <code>polkadot</code>; other accepted values are <code>kusama</code> or <code>moonbase</code>)</li> </ol> <p>The parachain ID you need can be found on the respective relay chain\u2019s Polkadot.js Apps Parachains page. The Parachains page can be accessed under the Network dropdown.</p> <p>For example, to calculate the sovereign account address for parachain <code>1000</code> on the Moonbase Alpha testnet:</p> <pre><code>yarn calculate-sovereign-account --p 1000 --r moonbase\n</code></pre> <p>Running the script will generate output like the following:</p> yarn calculate-sovereign-account --p 1000 --r moonbase yarn run v1.22.22 $ ts-node 'scripts/calculate-sovereign-account.ts' --p 1000 --r moonbase Sovereign Account Address on Relay: 0x70617261e8030000000000000000000000000000000000000000000000000000 Sovereign Account Address on other Parachains (Generic): 0x7369626ce8030000000000000000000000000000000000000000000000000000 Sovereign Account Address on Moonbase Alpha: 0x7369626ce8030000000000000000000000000000 <p>The relay address is how the Polkadot or Kusama relay chain references the sovereign account. Generic parachain address is typically used for referencing this parachain\u2019s sovereign account from other parachains. The Moonbase Alpha address is the corresponding sovereign account in the H160 EVM address format used by Moonbase Alpha.</p>"},{"location":"builders/interoperability/xcm/core-concepts/sovereign-accounts/#learn-more","title":"Learn More","text":"<p>Sovereign accounts form the backbone of reserve-backed transfers, enabling safe custody of assets for minting wrapped tokens across Polkadot\u2019s ecosystem. By combining sovereign accounts with the XCM framework, parachains can interoperate seamlessly\u2014locking and unlocking assets in a transparent, trust-minimized way. For more information about how sovereign accounts facilitate cross-chain transfers with XCM, be sure to check out the Send XC-20s section.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/","title":"XCM Fees on Moonbeam","text":""},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#introduction","title":"Introduction","text":"<p>XCM aims to be a language that communicates ideas between consensus systems. Sending an XCM message consists of a series of instructions that are executed in both the origin and the destination chains. The combination of XCM instructions results in actions such as token transfers. In order to process and execute each XCM instruction, there are typically associated fees that must be paid.</p> <p>However, XCM is designed to be general, extensible, and efficient so that it remains valuable and future-proof throughout a growing ecosystem. As such, the generality applies to concepts including payments of fees for XCM execution. In Ethereum, fees are baked into the transaction protocol, whereas in the Polkadot ecosystem, each chain has the flexibility to define how XCM fees are handled.</p> <p>This guide will cover aspects of fee payment, such as who is responsible for paying XCM execution fees, how it is paid for, and how the fees are calculated on Moonbeam.</p> <p>Note</p> <p>The following information is provided for general information purposes only. The weight and extrinsic base cost might have changed since the time of writing. Please ensure you check the actual values, and never use the following information for production apps.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#payment-of-fees","title":"Payment of Fees","text":"<p>Generally speaking, the fee payment process can be described as follows:</p> <ol> <li>Some assets need to be provided</li> <li>The exchange of assets for computing time (or weight) must be negotiated</li> <li>The XCM operations will be performed as instructed, with the provided weight limit or funds available for execution</li> </ol> <p>Each chain can configure what happens with the XCM fees and in which tokens they can be paid (either the native reserve token or an external one). For example:</p> <ul> <li>Polkadot and Kusama - the fees are paid in DOT or KSM (respectively) and given to the validator of the block</li> <li>Moonbeam and Moonriver - the XCM execution fees can be paid in the reserve asset (GLMR or MOVR, respectively), but also in assets originated in other chains if they are registered as an XCM execution asset. When XCM execution (token transfers or remote execution) is paid in the native chain reserve asset (GLMR or MOVR), 100% is burned. When XCM execution is paid in a foreign asset, the fee is sent to the Treasury</li> </ul> <p>Consider the following scenario: Alice has some DOT on Polkadot, and she wants to transfer it to Alith on Moonbeam. She sends an XCM message with a set of XCM instructions that will retrieve a given amount of DOT from her account on Polkadot and mint them as xcDOT into Alith's account. Part of the instructions are executed on Polkadot, and the other part is executed on Moonbeam.</p> <p>How does Alice pay Moonbeam to execute these instructions and fulfill her request? Her request is fulfilled through a series of XCM instructions that are included in the XCM message, which enables her to buy execution time minus any related XCM execution fees. The execution time is used to issue and transfer xcDOT, a representation of DOT on Moonbeam. This means that when Alice sends some DOT to Alith's account on Moonbeam, she'll receive a 1:1 representation of her DOT as xcDOT minus any XCM execution fees. Note that in this scenario, XCM execution fees are paid in xcDOT and sent to the treasury.</p> <p>The exact process for Alice's transfer is as follows:</p> <ol> <li>Assets are sent to an account on Polkadot that is owned by Moonbeam, known as the Sovereign account. After the assets are received, an XCM message is sent to Moonbeam</li> <li>The XCM message in Moonbeam will:<ol> <li>Mint the corresponding asset representation</li> <li>Buy the corresponding execution time</li> <li>Use that execution time to deposit the representation (minus fees) to the destination account</li> </ol> </li> </ol>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#xcm-instructions","title":"XCM Instructions","text":"<p>An XCM message is comprised of a series of XCM instructions. As a result, different combinations of XCM instructions result in different actions. For example, to move DOT to Moonbeam, the following XCM instructions are used:</p> <p>When DOT is transferred from Polkadot to Moonbeam, the following XCM instructions are executed in sequence:</p> <ol> <li> <p><code>TransferReserveAsset</code> - executes on Polkadot, moving the DOT from the sender and depositing it into Moonbeam\u2019s Sovereign account on Polkadot</p> </li> <li> <p><code>ReserveAssetDeposited</code> - executes on Moonbeam, minting the corresponding ERC-20 representation of DOT (xcDOT) on Moonbeam</p> </li> <li> <p><code>ClearOrigin</code> - executes on Moonbeam, clearing any origin data\u2014previously set to Polkadot\u2019s Sovereign account</p> </li> <li> <p><code>BuyExecution</code> - executes on Moonbeam, determining the execution fees. Here, a portion of the newly minted xcDOT is used to pay the cost of XCM</p> </li> <li> <p><code>DepositAsset</code> - executes on Moonbeam, delivering the xcDOT to the intended recipient\u2019s account on Moonbeam</p> </li> </ol> <p>To check how the instructions for an XCM message are built to transfer self-reserve assets to a target chain, such as DOT to Moonbeam, you can refer to the X-Tokens Open Runtime Module Library repository (as an example). You'll want to take a look at the <code>transfer_self_reserve_asset</code> function. You'll notice it calls <code>TransferReserveAsset</code> and passes in <code>assets</code>, <code>dest</code>, and <code>xcm</code> as parameters. In particular, the <code>xcm</code> parameter includes the <code>BuyExecution</code> and <code>DepositAsset</code> instructions. If you then head over to the Polkadot GitHub repository, you can find the <code>TransferReserveAsset</code> instruction. The XCM message is constructed by combining the <code>ReserveAssetDeposited</code> and <code>ClearOrigin</code> instructions with the <code>xcm</code> parameter, which as mentioned includes the <code>BuyExecution</code> and <code>DepositAsset</code> instructions.</p> <p>In scenarios where you want to move an asset back to its reserve chain, such as sending xcDOT from Moonbeam to Polkadot, Moonbeam uses the following set of XCM instructions:</p> <ol> <li> <p><code>WithdrawAsset</code> \u2013 executes on Moonbeam, taking the specified token (xcDOT) from the sender</p> </li> <li> <p><code>InitiateReserveWithdraw</code> \u2013 executes on Moonbeam, which, burns the token on Moonbeam (removing the wrapped representation), and sends an XCM message to Polkadot, indicating the tokens should be released there </p> </li> <li> <p><code>WithdrawAsset</code> \u2013 executes on Polkadot, removing the tokens from Moonbeam\u2019s Sovereign account on Polkadot</p> </li> <li> <p><code>ClearOrigin</code> \u2013 gets executed on Polkadot. Clears any origin data (e.g., the Sovereign account on Moonbeam)</p> </li> <li> <p><code>BuyExecution</code> \u2013 Polkadot determines the execution fees and uses part of the DOT being transferred to pay for them</p> </li> <li> <p><code>DepositAsset</code> \u2013 finally, the native DOT tokens are deposited into the specified Polkadot account</p> </li> </ol> <p>To check how the instructions for an XCM message are built to transfer reserve assets to a target chain, such as xcDOT to Polkadot, you can refer to the X-Tokens Open Runtime Module Library repository. You'll want to take a look at the <code>transfer_to_reserve</code> function. You'll notice that it calls <code>WithdrawAsset</code>, then <code>InitiateReserveWithdraw</code> and passes in <code>assets</code>, <code>dest</code>, and <code>xcm</code> as parameters. In particular, the <code>xcm</code> parameter includes the <code>BuyExecution</code> and <code>DepositAsset</code> instructions. If you then head over to the Polkadot GitHub repository, you can find the <code>InitiateReserveWithdraw</code> instruction. The XCM message is constructed by combining the <code>WithdrawAsset</code> and <code>ClearOrigin</code> instructions with the <code>xcm</code> parameter, which as mentioned includes the <code>BuyExecution</code> and <code>DepositAsset</code> instructions.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#rel-chain-xcm-fee-calc","title":"Relay Chain XCM Fee Calculation","text":"<p>Substrate has introduced a weight system that determines how heavy or, in other words, how expensive from a computational cost perspective an extrinsic is. One unit of weight is defined as one picosecond of execution time. When it comes to paying fees, users will pay a transaction fee based on the weight of the call that is being made, in addition to factors such as network congestion.</p> <p>The following sections will break down how to calculate XCM fees for Polkadot and Kusama. It's important to note that Kusama, in particular, uses benchmarked data to determine the total weight costs for XCM instructions and that some XCM instructions might include database reads and writes, which add weight to the call.</p> <p>There are two databases available in Polkadot and Kusama: RocksDB (which is the default) and ParityDB, both of which have their own associated weight costs for each network.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#polkadot","title":"Polkadot","text":"<p>The total weight costs on Polkadot take into consideration database reads and writes in addition to the weight required for a given instruction. Polkadot uses benchmarked weights for instructions, and database read-and-write operations. The breakdown of weight costs for the database operations can be found on the respective repository files for RocksDB (default) and ParityDB.  </p> <p>Now that you are aware of the weight costs for database reads and writes on Polkadot, you can calculate the weight cost for a given instruction using the base weight for instructions.</p> <p>On Polkadot, the benchmarked base weights are broken up into two categories: fungible and generic. Fungible weights are for XCM instructions that involve moving assets, and generic weights are for everything else. You can view the current weights for fungible assets and generic assets directly in the Polkadot Runtime code.</p> <p>With the instruction weight cost established, you can calculate the cost of each instruction in DOT.</p> <p>In Polkadot, the <code>ExtrinsicBaseWeight</code> is set to <code>126,045,000</code> which is mapped to 1/10th of a cent. Where 1 cent is <code>10^10 / 100</code>.</p> <p>Therefore, to calculate the cost of executing an XCM instruction, you can use the following formula:</p> <pre><code>XCM-DOT-Cost = XCMInstrWeight * DOTWeightToFeeCoefficient\n</code></pre> <p>Where <code>DOTWeightToFeeCoefficient</code> is a constant (map to 1 cent), and can be calculated as:</p> <pre><code>DOTWeightToFeeCoefficient = 10^10 / ( 10 * 100 * DOTExtrinsicBaseWeight )\n</code></pre> <p>Now, you can begin to calculate the final fee in DOT, using <code>DOTWeightToFeeCoefficient</code> as a constant and <code>TotalWeight</code> as the variable:</p> <pre><code>XCM-Planck-DOT-Cost = TotalWeight * DOTWeightToFeeCoefficient\nXCM-DOT-Cost = XCM-Planck-DOT-Cost / DOTDecimalConversion\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#kusama","title":"Kusama","text":"<p>The total weight costs on Kusama take into consideration database reads and writes in addition to the weight required for a given instruction. The breakdown of weight costs for the database operations can be found on the respective repository files for RocksDB (default) and ParityDB. </p> <p>On Kusama, the benchmarked base weights are broken up into two categories: fungible and generic. Fungible weights are for XCM instructions that involve moving assets, and generic weights are for everything else. You can view the current weights for fungible assets and generic assets directly in the Kusama Runtime code.</p> <p>With the instruction weight cost established, you can calculate the cost of the instruction in KSM with the <code>ExtrinsicBaseWeight</code> and the weight fee mapping.</p> <p>To calculate the cost of executing an XCM instruction, you can use the following formula:</p> <pre><code>XCM-KSM-Cost = XCMInstrWeight * KSMWeightToFeeCoefficient\n</code></pre> <p>Where <code>KSMWeightToFeeCoefficient</code> is a constant (map to 1 cent), and can be calculated as:</p> <pre><code>KSMWeightToFeeCoefficient = 10^12 / ( 10 * 3000 * KSMExtrinsicBaseWeight )\n</code></pre> <p>Now, you can begin to calculate the final fee in KSM, using <code>KSMWeightToFeeCoefficient</code> as a constant and <code>TotalWeight</code> as the variable:</p> <pre><code>XCM-Planck-KSM-Cost = TotalWeight * KSMWeightToFeeCoefficient\nXCM-KSM-Cost = XCM-Planck-KSM-Cost / KSMDecimalConversion\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#moonbeam-xcm-fee-calc","title":"Moonbeam-based Networks XCM Fee Calculation","text":"<p>Substrate has introduced a weight system that determines how heavy or, in other words, how expensive an extrinsic is from a computational cost perspective. One unit of weight is defined as one picosecond of execution time. When it comes to paying fees, users will pay a transaction fee based on the weight of the call being made, and each parachain can decide how to convert weight to fee. For example, this may account for additional costs related to transaction size and storage.</p> <p>For all Moonbeam-based networks, the generic XCM instructions are benchmarked, while the fungible XCM instructions still use a fixed amount of weight per instruction. Consequently, the total weight cost of the benchmarked XCM instructions considers the number of database reads and writes in addition to the weight required for a given instruction. The Polkadot SDK has a breakdown of the relevant RocksDB database weights.</p> <p>Now you can calculate the weight cost for both fungible and generic XCM instructions using the base weight for instruction and the extra database reads and writes if applicable.</p> <p>For example, the <code>WithdrawAsset</code> instruction is part of the fungible XCM instructions. Therefore, it is not benchmarked, and the total weight cost of the <code>WithdrawAsset</code> instruction is <code>200,000,000</code>, except for when transferring local XC-20s. The total weight cost for the <code>WithdrawAsset</code> instruction for local XC-20s is based on converting Ethereum gas to Substrate weight.</p> <p>The <code>BuyExecution</code> instruction is generic and therefore has a predefined benchmarked weight. You can view its current base weight in the Moonbeam runtime source code. In addition to the base weight, the instruction performs four database reads, which are added to calculate the total weight.</p> <p>You can find all the weight values for all the XCM instructions in the following table, which apply to all Moonbeam-based networks:</p> Benchmarked Instructions Non-Benchmarked Instructions Generic XCM Instructions Fungible XCM Instructions <p>The following sections will break down how to calculate XCM fees for Moonbeam-based networks. There are two main scenarios:</p> <ul> <li>Fees paid in the reserve token (native tokens like GLMR, MOVR, or DEV)</li> <li>Fees paid in external assets (XC-20s)</li> </ul>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#moonbeam-reserve-assets","title":"Fee Calculation for Reserve Assets","text":"<p>For each XCM instruction, the weight units are converted to balance units as part of the fee calculation. The amount of Wei per weight unit for each of the Moonbeam-based networks is as follows:</p> Moonbeam Moonriver Moonbase Alpha 1,250,000 12,500 12,500 <p>This means that on Moonbeam, for example, the formula to calculate the cost of one XCM instruction in the reserve asset is as follows:</p> <pre><code>XCM-Wei-Cost = XCMInstrWeight * WeiPerWeight\nXCM-GLMR-Cost = XCM-Wei-Cost / 10^18\n</code></pre> <p>Therefore, the actual calculation for fungible instructions, for example, is:</p> <pre><code>XCM-Wei-Cost = 200000000 * 1250000\nXCM-GLMR-Cost = 250000000000000 / 10^18\n</code></pre> <p>The total cost is <code>0.00025 GLMR</code> for an XCM instruction on Moonbeam.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#fee-calc-external-assets","title":"Fee Calculation for External Assets","text":"<p>Moonbeam charges fees for external assets based on the weight of the call. Weight is a struct that contains two fields, <code>refTime</code> and <code>proofSize</code>. <code>refTime</code> refers to the amount of computational time that can be used for execution. <code>proofSize</code> refers to the size of the PoV (Proof of Validity) of the Moonbeam block that gets submitted to the Polkadot Relay Chain for validation. Since both <code>refTime</code> and <code>proofSize</code> are integral components of determining a weight, it is impossible to obtain an accurate weight value with just one of these values.</p> <p>You can query the <code>refTime</code> and <code>proofSize</code> of an XCM instruction with the <code>queryXcmWeight</code> method of the <code>xcmPaymentApi</code>. You can do this programmatically or by visiting the Runtime Calls tab of Polkadot.js Apps. The <code>queryXcmWeight</code> method takes an XCM version and instruction has a parameter and returns the corresponding <code>refTime</code> and <code>proofSize</code> values.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#weight-to-gas-mapping","title":"Weight to Gas Mapping","text":"<p>For calls that are derived from EVM operations, such as the <code>DepositAsset</code> instruction which relies on the EVM operation <code>MintInto</code>, you can calculate their respective weight values by multiplying the gas limit by weight multipliers. For <code>refTime</code>, you'll need to multiply the gas limit by <code>25000</code> and for <code>proofSize</code> you'll need to multiply the gas limit by <code>8</code>.  A chart is included below for convenience. </p> Weight Type Multiplier Value Ref Time 25,000 Proof Size 8 <p>To determine the total weight for Alice's transfer of DOT to Moonbeam, you'll need the weight for each of the four XCM instructions required for the transfer. Note that while the first three instructions have specific <code>refTime</code> and <code>proofSize</code> values corresponding to these instructions that can be retrieved via <code>queryXcmWeight</code> method of the <code>xcmPaymentApi</code>, <code>DepositAsset</code> relies on the EVM operation <code>MintInto</code> and a <code>WeightPerGas</code> conversion of <code>25,000</code> per gas. The <code>refTime</code> of <code>DepositAsset</code> can thus be calculated as: </p> <pre><code>155000 gas * 25000 weight per gas = 3875000000\n</code></pre> <p>And the <code>proofSize</code> of <code>DepositAsset</code> can be calculated as:</p> <pre><code>155000 gas * 8 weight per gas = 1240000\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#weight-to-asset-fee-conversion","title":"Weight to Asset Fee Conversion","text":"<p>Once you have the sum of the <code>refTime</code> and <code>proofSize</code> values, you can easily retrieve the required commensurate fee amount. The <code>queryWeightToAssetFee</code> method of the <code>xcmPaymentApi</code> takes a <code>refTime</code>, <code>proofSize</code>, and asset multilocation as parameters and returns the commensurate fee. By providing the amounts obtained above of <code>4,428,242,000</code> <code>refTime</code> and <code>1,259,056</code> <code>proofSize</code>, and the asset multilocation for DOT, we get a fee amount of <code>88,920,522</code> Plank, which is the smallest unit in Polkadot. We can convert this to DOT by dividing by <code>10^10</code> which gets us a DOT fee amount of <code>0.008892</code> DOT. </p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#xcm-payment-api-exanded-examples","title":"XCM Payment API Expanded Examples","text":"<p>The XCM Payment API methods provide various helpful ways to calculate fees, evaluate acceptable fee payment currencies, and more. Remember that in addition to accessing this via API, you can also interact with the XCM Payment API via the Runtime Calls tab of Polkadot.js Apps.</p>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#query-acceptable-fee-payment-assets","title":"Query Acceptable Fee Payment Assets","text":"<p>This function takes the XCM Version as a parameter and returns a list of acceptable fee assets in multilocation form. </p> <pre><code>const allowedAssets =\n  await api.call.xcmPaymentApi.queryAcceptablePaymentAssets(3);\nconsole.log(allowedAssets);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  const allowedAssets =\n    await api.call.xcmPaymentApi.queryAcceptablePaymentAssets(4);\n  console.log(allowedAssets);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#weight-to-asset-fee-conversion","title":"Weight to Asset Fee Conversion","text":"<p>This method converts a weight into a fee for the specified asset. It takes as parameters a weight and an asset multilocation and returns the respective fee amount.</p> <pre><code>const fee = await api.call.xcmPaymentApi.queryWeightToAssetFee(\n  {\n    refTime: 10_000_000_000n,\n    proofSize: 0n,\n  },\n  {\n    V3: {\n      Concrete: { parents: 1, interior: 'Here' },\n    },\n  }\n);\n\nconsole.log(fee);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  const fee = await api.call.xcmPaymentApi.queryWeightToAssetFee(\n    {\n      refTime: 10_000_000_000n,\n      proofSize: 0n,\n    },\n    {\n      V3: {\n        Concrete: { parents: 1, interior: 'Here' },\n      },\n    }\n  );\n\n  console.log(fee);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/core-concepts/weights-fees/#query-xcm-weight","title":"Query XCM Weight","text":"<p>This method takes an XCM message as a parameter and returns the weight of the message. </p> <pre><code>const message = { V3: [instr1, instr2] };\n\nconst theWeight = await api.call.xcmPaymentApi.queryXcmWeight(message);\nconsole.log(theWeight);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  const amountToSend = BigInt(1 * 10 ** 12); // Sending 1 token (assuming 12 decimal places)\n  const assetMultiLocation = {\n    parents: 0,\n    interior: { X1: { PalletInstance: 3 } },\n  }; // The asset's location (adjust PalletInstance as needed)\n  const recipientAccount = '0x1234567890abcdef1234567890abcdef12345678'; // The recipient's account on the destination chain\n\n  // 2. XCM Destination (e.g., Parachain ID 2000)\n  const dest = { V3: { parents: 1, interior: { X1: { Parachain: 2000 } } } };\n\n  // 3. XCM Instruction 1: Withdraw the asset from the sender\n  const instr1 = {\n    WithdrawAsset: [\n      {\n        id: { Concrete: assetMultiLocation },\n        fun: { Fungible: amountToSend },\n      },\n    ],\n  };\n\n  // 4. XCM Instruction 2: Deposit the asset into the recipient's account on the destination chain\n  const instr2 = {\n    DepositAsset: {\n      assets: { Wild: 'All' }, // Sending all withdrawn assets (in this case, 1 token)\n      beneficiary: {\n        parents: 0,\n        interior: { X1: { AccountKey20: { key: recipientAccount } } },\n      },\n    },\n  };\n\n  // 5. Build the XCM Message\n  const message = { V3: [instr1, instr2] };\n\n  const theWeight = await api.call.xcmPaymentApi.queryXcmWeight(message);\n  console.log(theWeight);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/computed-origins/","title":"Computed Origin Accounts","text":""},{"location":"builders/interoperability/xcm/remote-execution/computed-origins/#introduction","title":"Introduction","text":"<p>The Computed Origin, previously referred to as the multilocation-derivative account, is an account computed when executing remote calls via XCM.</p> <p>Computed origins are keyless (the private key is unknown). Consequently, Computed Origins can only be accessed through XCM extrinsics from the origin account. In other words, the origin account is the only account that can initiate transactions on your Computed Origin account, and if you lose access to your origin account, you\u2019ll also lose access to your Computed Origin account.</p> <p>The Computed Origin is calculated from the origin that is being used to execute the XCM in the destination chain. By default, this is the Sovereign account of the source chain in the destination chain. This origin can be mutated by the <code>DescendOrigin</code> XCM instruction. However, the destination chain can decide whether or not to use the newly mutated origin for the execution of the XCM. On Moonbeam, the Computed Origin account is used to execute the XCM.</p> <p>Moonbeam-based networks follow the Computed Origins standard set by Polkadot, that is, through a <code>blake2</code> hash of a data structure that depends on the origin of the XCM message. However, because Moonbeam uses Ethereum-styled accounts, Computed Origins are truncated to 20 bytes.</p>"},{"location":"builders/interoperability/xcm/remote-execution/computed-origins/#origin-conversion","title":"The Origin Conversion","text":"<p>The origin conversion for a remote call happens when the <code>Transact</code> instruction gets executed. The new origin on the target chain is the one that pays for the fees for XCM execution on the target chain.</p> <p>For example, from the relay chain, the <code>DescendOrigin</code> instruction is natively injected by the XCM Pallet. In the case of Moonbase Alpha's relay chain (based on Westend), it has the following format (a multilocation junction):</p> <pre><code>{\n  DescendOrigin: {\n    X1: {\n      AccountId32: {\n        network: { westend: null },\n        id: decodedAddress,\n      },\n    },\n  },\n}\n</code></pre> <p>Where the <code>decodedAddress</code> corresponds to the address of the account who signed the transaction on the relay chain (in a decoded 32-byte format). You can make sure that your address is properly decoded by using the following snippet, which will decode an address if needed and ignore it if not:</p> <pre><code>import { decodeAddress } from '@polkadot/util-crypto';\nconst decodedAddress = decodeAddress('INSERT_ADDRESS');\n</code></pre> <p>When the XCM instruction gets executed in Moonbeam (Moonbase Alpha in this example), the origin will have mutated to the following multilocation:</p> <pre><code>{\n  DescendOrigin: {\n    parents: 1,\n    interior: {\n      X1: {\n        AccountId32: {\n          network: { westend: null },\n          id: decodedAddress,\n        },\n      },\n    },\n  },\n}\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/computed-origins/#calculate-computed-origin","title":"How to Calculate the Computed Origin","text":"<p>You can easily calculate the Computed Origin account through the <code>calculate-multilocation-derivative-account</code> or the <code>calculate-remote-origin</code> script in the xcm-tools repository.</p> <p>The script accepts the following inputs:</p> <ul> <li><code>--ws-provider</code> or <code>-w</code> - corresponds to the endpoint to use to fetch the Computed Origin. This should be the endpoint for the target chain</li> <li><code>--address</code> or <code>--a</code> - specifies the source chain address that is sending the XCM message</li> <li><code>--para-id</code> or <code>--p</code> - (optional) specifies the parachain ID of the origin chain of the XCM message. It is optional, as the XCM message might come from the relay chain (no parachain ID). Or parachains can act as relay chains for other parachains</li> <li><code>--parents</code> - (optional) corresponds to the parents value of the source chain in relation to the target chain. If you're calculating the Computed Origin account for an account on the relay chain, this value would be <code>1</code>. If left out, the parents value defaults to <code>0</code></li> </ul> <p>To use the script, you can take the following steps:</p> <ol> <li>Clone the xcm-tools repo</li> <li>Run <code>yarn</code> to install the necessary packages</li> <li> <p>Run the script</p> <pre><code>yarn calculate-multilocation-derivative-account \\\n--ws-provider INSERT_RPC_ENDPOINT \\\n--address INSERT_ORIGIN_ACCOUNT \\\n--para-id INSERT_ORIGIN_PARACHAIN_ID_IF_APPLIES \\\n--parents INSERT_PARENTS_VALUE_IF_APPLIES\n</code></pre> </li> </ol> <p>You can also calculate the Computed Origin account using the <code>multilocationToAddress</code> function of the XCM Utilities Precompile.</p>"},{"location":"builders/interoperability/xcm/remote-execution/computed-origins/#calculate-the-computed-origin-on-moonbeam","title":"Calculate the Computed Origin on a Moonbeam-based Network","text":"<p>For example, to calculate the Computed Origin on Moonbase Alpha for Alice's relay chain account, which is <code>5DV1dYwnQ27gKCKwhikaw1rz1bYdvZZUuFkuduB4hEK3FgDT</code>, you would use the following command to run the script:</p> <pre><code>yarn calculate-multilocation-derivative-account \\\n--ws-provider wss://wss.api.moonbase.moonbeam.network \\\n--address 5DV1dYwnQ27gKCKwhikaw1rz1bYdvZZUuFkuduB4hEK3FgDT \\\n--parents 1\n</code></pre> <p>Note</p> <p>For Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>The returned output includes the following values:</p> Name Value Origin Chain Encoded Address <code>5DV1dYwnQ27gKCKwhikaw1rz1bYdvZZUuFkuduB4hEK3FgDT</code> Origin Chain Decoded Address <code>0x3ec5f48ad0567c752275d87787954fef72f557b8bfa5eefc88665fa0beb89a56</code> Multilocation Received in Destination Chain <code>{\"parents\":1,\"interior\":{\"x1\":{\"accountId32\":{\"network\": {\"westend\":null},\"id\":\"0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0afb2e78fdbbbf4ce26c2556c\"}}}}</code> Computed Origin Account (32 bytes) <code>0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0afb2e78fdbbbf4ce26c2556c</code> Computed Origin Account (20 bytes) <code>0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0</code> <p>Consequently, for this example, Alice's Computed Origin account on Moonbase Alpha is <code>0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0</code>. Note that Alice is the only person who can access this account through a remote transact from the relay chain, as she is the owner of its private keys and the Computed Origin account is keyless.</p>"},{"location":"builders/interoperability/xcm/remote-execution/overview/","title":"Remote Execution via XCM","text":""},{"location":"builders/interoperability/xcm/remote-execution/overview/#introduction","title":"Introduction","text":"<p>The Cross-Consensus Message (XCM) format defines how messages can be sent between interoperable blockchains. This format opens the door to sending an XCM message that executes an arbitrary set of bytes in a Moonbeam-based network, the relay chain, or other parachains in the Polkadot/Kusama ecosystems.</p> <p>Remote execution via XCM opens a new set of possibilities for cross-chain interactions, from chains executing actions on other chains to users performing remote actions without switching chains.</p> <p>This page covers the fundamentals of XCM remote execution. If you want to learn how to perform remote execution via XCM, please refer to the Remote Execution via the Substrate API or the Remote Execution via the Ethereum API guides.</p>"},{"location":"builders/interoperability/xcm/remote-execution/overview/#execution-origin","title":"Execution Origin","text":"<p>Generally speaking, all transactions have an origin, which is where a call comes from. Ethereum transactions have only one origin type, the <code>msg.sender</code>, which is the account that initiated the transaction.</p> <p>Substrate-based transactions are more complex, as they can have different origins with different privilege levels. This is similar to having an EVM smart contract call with a specific <code>require</code> statement in which the call must come from an allowed address. In contrast, these privilege levels are programmed in the Substrate-based runtime itself.</p> <p>Origins are super important across different components of the Substrate runtime and, hence, the Moonbeam runtime. For example, they define the authority level they inherit in the on-chain governance implementation.</p> <p>During the execution of an XCM message, the origin defines the context in which the XCM is being executed. By default, the XCM is executed by the source chain's Sovereign account in the destination chain. This Polkadot-specific property of having remote origins that are calculated when executing XCM is known as Computed Origins (formerly known as Multilocation Derivative Accounts).</p> <p>Depending on the destination chain's configuration, including the <code>DescendOrigin</code> XCM instruction can mutate the origin from which the XCM message is executed. This property is significant for remote XCM execution, as the action being executed considers the context of the newly mutated origin and not the source chain's Sovereign account.</p>"},{"location":"builders/interoperability/xcm/remote-execution/overview/#xcm-instructions-remote-execution","title":"XCM Instructions for Remote Execution","text":"<p>The core XCM instructions required to perform remote execution on Moonbeam (as an example) via XCM are the following:</p> <ul> <li><code>DescendOrigin</code> - (optional) gets executed in Moonbeam. Mutates the origin to create a new Computed Origin that represents a keyless account controlled via XCM by the sender in the source chain</li> <li><code>WithdrawAsset</code> - gets executed in Moonbeam. Takes funds from the Computed Origin</li> <li><code>BuyExecution</code> - gets executed in Moonbeam. Uses the funds taken by the previous XCM instruction to pay for the XCM execution, including the remote call</li> <li><code>Transact</code> - gets executed in Moonbeam. Executes the arbitrary bytes provided in the XCM instruction</li> </ul> <p>The XCM instructions detailed above can be complemented by other XCM instructions to handle certain scenarios, like failure on execution, more accurately. One example is the inclusion of <code>SetAppendix</code>, <code>RefundSurplus</code>, and <code>Deposit</code>.</p>"},{"location":"builders/interoperability/xcm/remote-execution/overview/#general-remote-execution-via-xcm-flow","title":"General Remote Execution via XCM Flow","text":"<p>A user initiates a transaction in the source chain through a pallet that builds the XCM with at least the required XCM instructions for remote execution. The transaction is executed in the source chain, which sends an XCM message with the given instructions to the destination chain.</p> <p>The XCM message arrives at the destination chain, which executes it. It is executed with the source chain's Sovereign account as a Computed Origin by default. One example that uses this type of origin is when chains open or accept an HRMP channel on the relay chain.</p> <p>If the XCM message included a <code>DescendOrigin</code> instruction, the destination chain may mutate the origin to calculate a new Computed Origin (as is the case with Moonbeam-based networks).</p> <p>Next, <code>WithdrawAsset</code> takes funds from the Computed Origin (either a Sovereign account or mutated), which are then used to pay for the XCM execution through the <code>BuyExecution</code> XCM instruction. Note that on both instructions, you need to specify which asset you want to use. In addition, you must include the bytes to be executed in the amount of execution to buy.</p> <p>Lastly, <code>Transact</code> executes an arbitrary set of bytes that correspond to a pallet and function in the destination chain. You have to specify the type of origin to use (typically <code>SovereignAccount</code>) and the weight required to execute the bytes (similar to gas in the Ethereum realm).</p> <p></p>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/","title":"Remote EVM Calls Through XCM","text":""},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#introduction","title":"Introduction","text":"<p>The XCM Transactor Pallet provides a simple interface to perform remote cross-chain calls through XCM. However, this does not consider the possibility of doing remote calls to Moonbeam's EVM, only to Substrate-specific pallets (functionalities).</p> <p>Moonbeam's EVM is only accessible through the Ethereum Pallet. Among many other things, this pallet handles certain validations of transactions before getting them into the transaction pool. Then, it performs another validation step before inserting a transaction from the pool into a block. Lastly, it provides the interface through a <code>transact</code> function to execute a validated transaction. All these steps follow the same behavior as an Ethereum transaction in terms of structure and signature scheme.</p> <p>However, calling the Ethereum Pallet directly through an XCM <code>Transact</code> is not feasible. Mainly because the dispatcher account for the remote EVM call (referred to as <code>msg.sender</code> in Ethereum) does not sign the XCM transaction on the Moonbeam side. The XCM extrinsic is signed in the origin chain, and the XCM executor dispatches the call, through the <code>Transact</code> instruction, from a known caller linked to the sender in the origin chain. In this context, the Ethereum Pallet will not be able to verify the signature and, ultimately, validate the transaction.</p> <p>To this end, the Ethereum XCM Pallet was introduced. It acts as a middleware between the XCM <code>Transact</code> instruction and the Ethereum Pallet, as special considerations need to be made when performing EVM calls remotely through XCM. The pallet performs the necessary checks and validates the transaction. Next, the pallet calls the Ethereum Pallet to dispatch the transaction to the EVM. Due to how the EVM is accessed, there are some differences between regular and remote EVM calls.</p> <p>The happy path for both regular and remote EVM calls through XCM is portrayed in the following diagram:</p> <p></p> <p>This guide will go through the differences between regular and remote EVM calls. In addition, it will show you how to perform remote EVM calls through the extrinsic exposed by the Ethereum XCM pallet.</p> <p>Note</p> <p>Remote EVM calls are done through the XCM Transactor Pallet. Therefore, it is recommended to get familiar with XCM Transactor concepts before trying to perform remote EVM calls through XCM.</p> <p>Note that remote calls to Moonbeam's EVM through XCM are still being actively developed. In addition, developers must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, it is essential to test XCM features on a TestNet before moving to a production environment.</p>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#differences-regular-remote-evm","title":"Differences between Regular and Remote EVM Calls through XCM","text":"<p>As explained in the introduction, the paths that regular and remote EVM calls take to get to the EVM are quite different. The main reason behind this difference is the dispatcher of the transaction.</p> <p>A regular EVM call has an apparent sender who signs the Ethereum transaction with its private key. The signature, of ECDSA type, can be verified with the signed message and the <code>r-s</code> values that are produced by the signing algorithm. Ethereum signatures use an additional variable called <code>v</code>, which is the recovery identifier.</p> <p>With remote EVM calls, the signer signs an XCM transaction in another chain. Moonbeam receives that XCM message, which follows the conventional remote execution via XCM form:</p> <ul> <li><code>DescendOrigin</code> (optional)</li> <li><code>WithdrawAsset</code></li> <li><code>BuyExecution</code></li> <li><code>Transact</code></li> </ul> <p>XCM execution happens through a Computed Origin account mechanism, which by default uses the source chain's Sovereign account in the destination chain. If <code>DescendOrigin</code> is included, Moonbeam will mutate the origin of the XCM call to a keyless account that a user from the source chain can control remotely via XCM. The remote EVM call is dispatched from that keyless account (or a related proxy). Therefore, because the transaction is not signed, it does not have the real <code>v-r-s</code> values of the signature, but <code>0x1</code> instead.</p> <p>Since remote EVM calls do not have the actual <code>v-r-s</code> values of the signature, there could be collision problems with the EVM transaction hash, as it is calculated as the keccak256 hash of the signed transaction blob. In consequence, if two accounts with the same nonce submit the same transaction object, they will end up with the same EVM transaction hash. Therefore, all remote EVM transactions use a global nonce that is attached to the Ethereum XCM Pallet.</p> <p>Another significant difference is in terms of the gas price. The fee for remote EVM calls is charged at an XCM execution level. Consequently, the gas price at an EVM level is zero, and the EVM will not charge for the execution itself. This can also be seen in the receipt of a remote EVM call transaction. Accordingly, the XCM message must be configured so that the <code>BuyExecution</code> buys enough weight to cover the gas cost.</p> <p>The last difference is in terms of the gas limit. Ethereum uses a gas-metered system to moderate the amount of execution that can be done in a block. On the contrary, Moonbeam uses a weight-based system in which each call is characterized by the time it takes to execute in a block. Each unit of weight corresponds to one picosecond of execution time.</p> <p>As of runtime 2900, the configuration of the XCM queue suggests that XCM messages should be executable within the following weight units:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>125,000,000,000 (0.125 seconds of block execution time)\n</code></pre> <pre><code>500,000,000,000 (0.5 seconds of block execution time)\n</code></pre> <pre><code>500,000,000,000 (0.5 seconds of block execution time)\n</code></pre> <p>Note</p> <p>Prior to runtime 2900, the weight limit of XCM messages across all networks was <code>20,000,000,000</code> weight units (this is, <code>0.02</code> seconds of block execution time).</p> <p>Suppose the XCM message can't be executed due to the lack of execution time in a given block, and the weight requirement exceeds the above limits. In that case, the XCM message will be marked as <code>overweight</code> and only be executable through democracy.</p> <p>The maximum weight limit per XCM message constrains the gas limit available for remote EVM calls through XCM. For all Moonbeam-based networks, there is a ratio of <code>25,000</code> units of gas per unit of weight (<code>WEIGHT_REF_TIME_PER_SECOND</code> / <code>GAS_PER_SECOND</code>). Considering that you need some XCM message weight to execute the XCM instructions, a remote EVM call might consume\u00a02,000,000,000\u00a0units. The following equation can be used to determine the maximum gas units for a remote EVM call:</p> <pre><code>Maximum Gas Units = (Maximum Weight Units - Remote EVM Weight Units) / 25,000\n</code></pre> <p>Therefore, the maximum gas limit you can provide for a remote EVM call can be calculated:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>Maximum Gas Units = (125,000,000,000 - 2,000,000,000) / 25,000\nMaximum Gas Units = 4,920,000\n</code></pre> <pre><code>Maximum Gas Units = (500,000,000,000 - 2,000,000,000) / 25,000\nMaximum Gas Units = 19,920,000\n</code></pre> <pre><code>Maximum Gas Units = (500,000,000,000 - 2,000,000,000) / 25,000\nMaximum Gas Units = 19,920,000\n</code></pre> <p>Note</p> <p>These values are subject to change in the future.</p> <p>In summary, these are the main differences between regular and remote EVM calls:</p> <ul> <li>Remote EVM calls use a global nonce (owned by the Ethereum XCM Pallet) instead of a nonce per account</li> <li>The <code>v-r-s</code> values of the signature for remote EVM calls are <code>0x1</code>. The sender can't be retrieved from the signature through standard methods (for example, through ECRECOVER). Nevertheless, the <code>from</code> is included in both the transaction receipt and when getting the transaction by hash (using the Ethereum JSON-RPC)</li> <li>The gas price for all remote EVM calls is zero. The EVM execution is charged at an XCM execution level and not at an EVM level</li> <li>The current maximum gas limit you can set for a remote EVM call is different, as outlined above</li> </ul>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#ethereum-xcm-pallet-interface","title":"Ethereum XCM Pallet Interface","text":""},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#extrinsics","title":"Extrinsics","text":"<p>The Ethereum XCM Pallet provides the following extrinsics (functions) that can be called by the <code>Transact</code> instruction to access Moonbeam's EVM through XCM:</p> transact(xcmTransaction) \u2014 function to remotely call the EVM through XCM. Only callable through the execution of an XCM message ParametersPolkadot.js API Example <ul> <li><code>xcmTransaction</code> - the Ethereum transaction details of the call that will be dispatched. The <code>xcmTransaction</code> structure, which is versioned, contains the following:<ul> <li><code>gasLimit</code> - the gas limit for the Ethereum transaction</li> <li><code>action</code> - the action to be executed, which provides two options: <code>Call</code> and <code>Create</code>. The current implementation of the Ethereum XCM Pallet does not support the <code>CREATE</code> operation. Therefore, you can't deploy a smart contract through remote EVM calls. For <code>Call</code>, you'll need to specify the contract address you're interacting with</li> <li><code>value</code> - the amount of native tokens to send</li> <li><code>input</code> - the encoded call data of the contract interaction</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst xcmTransaction = {\n  V2: {\n    gasLimit: INSERT_GAS_LIMIT,\n    action: { Call: 'INSERT_CONTRACT_ADDRESS_TO_CALL' },\n    value: INSERT_VALUE,\n    input: 'INSERT_CONTRACT_CALL_DATA',\n  },\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.ethereumXcm.transact(xcmTransaction);\n};\n\nmain();      \n</code></pre> <p>Note</p> <p>In the following sections, you'll learn exactly how to get the Ethereum transaction call data and build an XCM message using this extrinsic.</p> transactThroughProxy(transactAs, xcmTransaction) \u2014 function to remotely call the EVM through XCM and be dispatched from a given account with known keys (the <code>msg.sender</code>) ParametersPolkadot.js API Example <ul> <li><code>xcmTransaction</code> - the Ethereum transaction details of the call that will be dispatched. The <code>xcmTransaction</code> structure, which is versioned, contains the following:<ul> <li><code>gasLimit</code> - the gas limit for the Ethereum transaction</li> <li><code>action</code> - the action to be executed, which provides two options: <code>Call</code> and <code>Create</code>. The current implementation of the Ethereum XCM Pallet does not support the <code>CREATE</code> operation. Therefore, you can't deploy a smart contract through remote EVM calls. For <code>Call</code>, you'll need to specify the contract address you're interacting with</li> <li><code>value</code> - the amount of native tokens to send</li> <li><code>input</code> - the encoded call data of the contract interaction</li> </ul> </li> <li><code>xcmTransactAs</code> - the account from which the remote EVM call will be dispatched (the <code>msg.sender</code>). This account needs to have set the Computed Origin account as a proxy of type <code>any</code> on Moonbeam, or the remote EVM call will fail. Transaction fees are still paid by the Computed Origin account</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst xcmTransaction = {\n  V2: {\n    gasLimit: INSERT_GAS_LIMIT,\n    action: { Call: 'INSERT_CONTRACT_ADDRESS_TO_CALL' },\n    value: INSERT_VALUE,\n    input: 'INSERT_CONTRACT_CALL_DATA',\n  },\n};\nconst xcmTransactAs = 'INSERT_COMPUTED_ORIGIN_PROXY_ADDRESS';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.ethereumXcm.transactThroughProxy(\n    xcmTransaction,\n    xcmTransactAs\n  );\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#build-remote-evm-call-xcm","title":"Building a Remote EVM Call Through XCM","text":"<p>This guide covers building an XCM message for remote EVM calls using the XCM Pallet from the relay chain to Moonbase Alpha. More specifically, it will use the <code>transact</code> function. The steps to use the <code>transactThroughProxy</code> function are identical. However, you'll need to provide the <code>transactAs</code> account and ensure that this account has set the Computed Origin account as a proxy of type <code>any</code> on Moonbase Alpha.</p> <p>Note</p> <p>When using <code>transactThroughProxy</code>, the EVM call is dispatched by the <code>transactAs</code> account you provide, acting as the <code>msg.sender</code>, as long as this account has set the Computed Origin account as a proxy of type <code>any</code> in the Moonbeam-based network you are using. However, transaction fees are still paid by the Computed Origin account, so you need to ensure it has enough funds to cover them.</p> <p>The process for building and performing the remote execution can be summarized as follows:</p> <ol> <li>Calculate the call data for the EVM call that will be performed on Moonbase Alpha</li> <li>Use the EVM call data to generate the call data for the <code>transact</code> extrinsic of the Ethereum XCM Pallet on Moonbase Alpha</li> <li>Build the XCM message on the relay chain, which will include the <code>WithdrawAsset</code>, <code>BuyExecution</code>, and <code>Transact</code> instructions. In the <code>Transact</code> instruction, you'll use the Ethereum XCM <code>transact</code> call data</li> <li>Using Alice's account on the relay chain, you'll send the XCM message via the <code>send</code> extrinsic of the XCM Pallet</li> <li>Alice's Computed Origin account on Moonbase Alpha will dispatch the EVM call data</li> </ol>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#ethereumxcm-check-prerequisites","title":"Checking Prerequisites","text":"<p>To be able to send the call from the relay chain, you need the following:</p> <ul> <li>An account on the relay chain with funds (UNIT) to pay for the transaction fees. You can acquire some xcUNIT by swapping for DEV tokens (Moonbase Alpha's native token) on Moonbeam-Swap, a demo Uniswap-V2 clone on Moonbase Alpha, and then send them to the relay chain. Additionally, you can contact us on Discord to get some UNIT tokens directly</li> <li>The address of your Computed Origin account. Please refer to the Computed Origin guide to learn how to calculate your Computed Origin address</li> <li>To fund your Computed Origin account. The account must have enough DEV tokens (or GLMR/MOVR for Moonbeam/Moonriver) to cover the cost of the XCM execution of the remote EVM call. Note that this is the account from which the remote EVM call will be dispatched (the <code>msg.sender</code>). Consequently, the account must satisfy whatever conditions are required for the EVM call to be executed correctly. For example, hold any relevant ERC-20 token if you are doing an ERC-20 transfer</li> </ul> <p>Note</p> <p>Suppose you are using the <code>transactThroughProxy</code> function. In that case, the <code>transactAs</code> account must satisfy whatever conditions are required for the EVM call to be executed correctly, as it acts as the <code>msg.sender</code>. However, the Computed Origin account is the one that needs to hold the DEV tokens (or GLMR/MOVR for Moonbeam/Moonriver) to cover the cost of the XCM execution of the remote EVM call.</p>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#ethereumxcm-transact-data","title":"Ethereum XCM Transact Call Data","text":"<p>Before you send the XCM message from the relay chain to Moonbase Alpha, you need to get the encoded call data that will be dispatched through the execution of the <code>Transact</code> XCM instruction.</p> <p>In this example, you'll be interacting with the <code>transact</code> function of the Ethereum XCM Pallet, which accepts an <code>xcmTransaction</code> as a parameter.</p> <p>The <code>xcmTransaction</code> parameter requires you to define the <code>gasLimit</code>, <code>action</code>, <code>value</code>, and <code>input</code>.</p> <p>For the action to be executed, you'll be performing a contract interaction with a simple incrementer contract, which is located at <code>0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8</code>. You'll be calling the <code>increment</code> function, which has no input argument and will increase the value of the <code>number</code> by one. It will also store the block's timestamp in which the function is executed to the <code>timestamp</code> variable.</p> <p>The encoded call data for the <code>increment</code> function is <code>0xd09de08a</code>, which is the function selector and is the first eight hexadecimal characters (or 4 bytes) of the keccak256 hash of <code>increment()</code>. If you choose to interact with a function that has input parameters, they also need to be encoded. The easiest way to get the encoded call data is to emulate a transaction either in Remix or Moonscan. Then, in Metamask, check the HEX DATA: 4 BYTES selector under the HEX tab to get the call data. You don't need to sign the transaction.</p> <p>Now that you have the encoded contract interaction data, you can determine the gas limit for this call using the <code>eth_estimateGas</code> JSON-RPC method. For this example, you can set the gas limit to <code>155000</code>.</p> <p>For the value, you can set it to <code>0</code> since this particular interaction does not need DEV (or GLMR/MOVR for Moonbeam/Moonriver). For an interaction that requires DEV, you'll need to modify this value accordingly.</p> <p>Now that you have all of the components required for the <code>xcmTransaction</code> parameter, you can build it:</p> <pre><code>const xcmTransaction = {\n  V2: {\n    gasLimit: 155000,\n    action: { Call: '0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8' },\n    value: 0,\n    input: '0xd09de08a',\n  },\n};\n</code></pre> <p>Next, you can write the script to get the encoded call data for the transaction. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The Moonbase Alpha endpoint URL to create the provider</li> <li>The value for the <code>xcmTransaction</code> parameter of the <code>transact</code> function</li> </ul> </li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>ethereumXcm.transact</code> extrinsic with the <code>xcmTransaction</code> value</li> <li>Get the encoded call data for the extrinsic. You don't need to sign and send the transaction</li> </ol> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\n// 1. Input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst xcmTransaction = {\n  V2: {\n    gasLimit: 155000,\n    action: { Call: '0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8' },\n    value: 0,\n    input: '0xd09de08a',\n  },\n};\n\nconst getEncodedCalldata = async () =&gt; {\n  // 2. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Create the extrinsic\n  const tx = api.tx.ethereumXcm.transact(xcmTransaction);\n\n  // 4. Get the encoded call data\n  const encodedCall = tx.method.toHex();\n  console.log(`Encoded Calldata: ${encodedCall}`);\n\n  api.disconnect();\n};\n\ngetEncodedCalldata();\n</code></pre> <p>Note</p> <p>You can view an example of the output of the above script on Polkadot.js Apps using the following encoded call data: <code>0x260001785d02000000000000000000000000000000000000000000000000000000000000a72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8000000000000000000000000000000000000000000000000000000000000000010d09de08a00</code>.</p> <p>You'll use the encoded call data in the <code>Transact</code> instruction in the following section.</p>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#estimate-weight-required-at-most","title":"Estimate Weight Required at Most","text":"<p>When using the <code>Transact</code> instruction, you'll need to define the <code>requireWeightAtMost</code> field, which is the required weight for the transaction. This field accepts two arguments: the <code>refTime</code> and <code>proofSize</code>. The <code>refTime</code> is the amount of computational time that can be used for execution, and the <code>proofSize</code> is the amount of storage in bytes that can be used.</p> <p>To get an estimate for the <code>refTime</code> and <code>proofSize</code>, you can use the <code>paymentInfo</code> method of the Polkadot.js API. Since these weights are required for the <code>Transact</code> call data, you can extend the script from the previous section to add in the call to <code>paymentInfo</code>.</p> <p>The <code>paymentInfo</code> method accepts the same parameters you would normally pass to the <code>.signAndSend</code> method, which is the sending account and, optionally, some additional values such as a nonce or signer.</p> <p>To modify the encoded call data script, you'll need to add Alice's Computed Origin address and use it to call the <code>tx.paymentInfo</code> method.</p> Modified script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\n// 1. Input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst xcmTransaction = {\n  V2: {\n    gasLimit: 155000,\n    action: { Call: '0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8' },\n    value: 0,\n    input: '0xd09de08a',\n  },\n};\n\nconst getEncodedCalldata = async () =&gt; {\n  // 2. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 3. Create the extrinsic\n  const tx = api.tx.ethereumXcm.transact(xcmTransaction);\n\n  // 4. Estimate the required weight\n  const alice = '0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0';\n  const info = await tx.paymentInfo(alice);\n  console.log(`Required Weight: ${info.weight}`);\n\n  api.disconnect();\n};\n\ngetEncodedCalldata();\n</code></pre> <p>The script, at the time of writing, returns an estimate of <code>3900000000</code> for <code>refTime</code> and <code>9687</code> for <code>proofSize</code>.</p>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#build-xcm-remote-evm","title":"Building the XCM for Remote XCM Execution","text":"<p>Now that you've generated the call data for the EVM call, you're going to use the XCM Pallet on the relay chain to perform the remote execution. To do so, you'll use the <code>send</code> function, which accepts two parameters:</p> <ul> <li><code>dest</code> - the XCM versioned multilocation representing a chain in the ecosystem where the XCM message is being sent to (the target chain)</li> <li><code>message</code> - the SCALE-encoded versioned XCM message to be executed</li> </ul> <p>You can start assembling these parameters by taking the following steps:</p> <ol> <li> <p>Build the multilocation of the destination, which is Moonbase Alpha:</p> <pre><code>const dest = { V4: { parents: 0, interior: { X1: [{ Parachain: 1000 }] } } };\n</code></pre> </li> <li> <p>Build the <code>WithdrawAsset</code> instruction, which will require you to define:</p> <ul> <li>The multilocation of the DEV token on Moonbase Alpha</li> <li>The amount of DEV tokens to withdraw</li> </ul> <pre><code>const instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 10000000000000000n }, // 0.01 DEV\n    },\n  ],\n};\n</code></pre> </li> <li> <p>Build the <code>BuyExecution</code> instruction, which will require you to define:</p> <ul> <li>The multilocation of the DEV token on Moonbase Alpha</li> <li>The amount of DEV tokens to buy for execution</li> <li>The weight limit</li> </ul> <pre><code>const instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 10000000000000000n }, // 0.01 DEV\n    },\n    { Unlimited: null },\n  ],\n};\n</code></pre> </li> <li> <p>Build the <code>Transact</code> instruction, which will require you to define:</p> <ul> <li>The origin kind</li> <li>The required weight for the transaction, which you calculated in the Estimate Weight Required at Most section</li> <li>The encoded call data, which you generated in the Ethereum XCM Transact Call Data section</li> </ul> <pre><code>const instr3 = {\n  Transact: {\n    originKind: 'SovereignAccount',\n    requireWeightAtMost: { refTime: 3900000000n, proofSize: 9687n },\n    call: {\n      encoded:\n        '0x260001785d02000000000000000000000000000000000000000000000000000000000000a72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8000000000000000000000000000000000000000000000000000000000000000010d09de08a00',\n    },\n  },\n};\n</code></pre> </li> <li> <p>Combine the XCM instructions into a versioned XCM message:</p> <pre><code>const message = { V4: [instr1, instr2, instr3] };\n</code></pre> </li> </ol> <p>Now that you have the values for each of the parameters, you can write the script for the execution. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The relay chain endpoint URL to create the provider</li> <li>The values for each of the parameters of the <code>send</code> function</li> </ul> </li> <li>Create a Keyring instance that will be used to send the transaction</li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>xcmPallet.send</code> extrinsic with the <code>dest</code> and <code>message</code> values</li> <li>Send the transaction using the <code>signAndSend</code> extrinsic and the Keyring instance you created in the second step</li> </ol> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a JavaScript file.</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\n// 1. Input data\nconst providerWsURL =\n  'wss://relay.api.moonbase.moonbeam.network';\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst dest = { V4: { parents: 0, interior: { X1: [{ Parachain: 1000 }] } } };\nconst instr1 = {\n  WithdrawAsset: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 10000000000000000n }, // 0.01 DEV\n    },\n  ],\n};\nconst instr2 = {\n  BuyExecution: [\n    {\n      id: { parents: 0, interior: { X1: [{ PalletInstance: 3 }] } },\n      fun: { Fungible: 10000000000000000n }, // 0.01 DEV\n    },\n    { Unlimited: null },\n  ],\n};\nconst instr3 = {\n  Transact: {\n    originKind: 'SovereignAccount',\n    requireWeightAtMost: { refTime: 3900000000n, proofSize: 9687n },\n    call: {\n      encoded:\n        '0x260001785d02000000000000000000000000000000000000000000000000000000000000a72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8000000000000000000000000000000000000000000000000000000000000000010d09de08a00',\n    },\n  },\n};\nconst message = { V4: [instr1, instr2, instr3] };\n\nconst sendXcmMessage = async () =&gt; {\n  // 2. Create Keyring instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'sr25519' });\n  const alice = keyring.addFromUri(privateKey);\n\n  // 3. Create Substrate API Provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 4. Create the extrinsic\n  const tx = api.tx.xcmPallet.send(dest, message);\n\n  // 5. Send the transaction\n  const txHash = await tx.signAndSend(alice);\n  console.log(`Submitted with hash ${txHash}`);\n\n  api.disconnect();\n};\n\nsendXcmMessage();\n</code></pre> <p>Note</p> <p>You can view an example of the output of the above script on Polkadot.js Apps using the following encoded call data: <code>0x630004000100a10f040c000400010403001300008a5d784563011300010403001300008a5d784563010006010300286bee007901260001581501000000000000000000000000000000000000000000000000000000000000a72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8000000000000000000000000000000000000000000000000000000000000000010d09de08a00</code>.</p> <p>Once the transaction is processed, you can check the relevant extrinsics and events in the relay chain and Moonbase Alpha.</p> <p>In the relay chain, the extrinsic is <code>xcmPallet.send</code>, and the associated event is <code>xcmPallet.Sent</code> (among others related to the fee). In Moonbase Alpha, the XCM execution happens within the <code>parachainSystem.setValidationData</code> extrinsic, and there are multiple associated events that can be highlighted:</p> <ul> <li>parachainSystem.DownwardMessagesReceived \u2014 event that signals that a message from the relay chain was received. With the current XCM implementation, messages from other parachains will show the same event</li> <li>balances.Withdraw \u2014 event related to the withdrawing of tokens to pay for the execution of the call. Note that the <code>who</code> address is the Computed Origin account calculated before</li> <li>ethereum.Executed \u2014 event associated with the execution of the remote EVM call. It provides the <code>from</code>, <code>to</code>, <code>transactionHash</code> (calculated with the non-standard signature and global pallet nonce), and the <code>exitReason</code>. Currently, some common EVM errors, like out of gas, will show <code>Reverted</code> in the exit reason</li> <li>polkadotXcm.AssetsTrapped \u2014 event that is emitted when part of the tokens withdrawn from the account (for fees) are not used. Generally, when there are leftover tokens in the registry that are not allocated to an account. These tokens are temporarily burned and can be retrieved through a democracy proposal. A combination of both <code>RefundSurplus</code> and <code>DepositAsset</code> XCM instructions can prevent assets from getting trapped</li> </ul> <p>To verify that the remote EVM call through XCM was successful, you can head to the contract's page in Moonscan and verify the new value for the number and its timestamp.</p>"},{"location":"builders/interoperability/xcm/remote-execution/remote-evm-calls/#remote-evm-call-txhash","title":"Remote EVM Call Transaction by Hash","text":"<p>As mentioned before, there are some differences between regular and remote XCM EVM calls. Some main differences can be seen when retrieving the transaction by its hash using the Ethereum JSON-RPC.</p> <p>To do so, you first need to retrieve the transaction hash you want to query. For this example, you can use the transaction hash from the previous section, which is 0x753588d6e59030eeffd31aabccdd0fb7c92db836fcaa8ad71512cf3a7d0cb97f. Open the terminal, and execute the following command:</p> <pre><code>curl --location --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"eth_getTransactionByHash\",\n    \"params\": [\"0x753588d6e59030eeffd31aabccdd0fb7c92db836fcaa8ad71512cf3a7d0cb97f\"]\n  }\n'\n</code></pre> <p>If the JSON-RPC request is sent correctly, the response should look like this:</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"result\": {\n        \"hash\": \"0x753588d6e59030eeffd31aabccdd0fb7c92db836fcaa8ad71512cf3a7d0cb97f\",\n        \"nonce\": \"0x129\",\n        \"blockHash\": \"0xeb8222567e434215f472f0c53f68a606c77ea8f475e5fbc3a5b715db6cce8887\",\n        \"blockNumber\": \"0x46c268\",\n        \"transactionIndex\": \"0x0\",\n        \"from\": \"0xdd2399f3b5ca0fc584c4637283cda4d73f6f87c0\",\n        \"to\": \"0xa72f549a1a12b9b49f30a7f3aeb1f4e96389c5d8\",\n        \"value\": \"0x0\",\n        \"gasPrice\": \"0x0\",\n        \"maxFeePerGas\": \"0x0\",\n        \"maxPriorityFeePerGas\": \"0x0\",\n        \"gas\": \"0x25d78\",\n        \"input\": \"0xd09de08a\",\n        \"creates\": null,\n        \"raw\": \"0x02eb820507820129808083025d7894a72f549a1a12b9b49f30a7f3aeb1f4e96389c5d88084d09de08ac0010101\",\n        \"publicKey\": \"0x14745b9075ac0f0426c61c9a2895f130ea6f3b964e8f49cefdb4e2d248306f19396361d877f8b9ad60a94a5ec28325a1b9baa2ae59e7a9f6fe1731caec130ab4\",\n        \"chainId\": \"0x507\",\n        \"standardV\": \"0x1\",\n        \"v\": \"0x1\",\n        \"r\": \"0x1\",\n        \"s\": \"0x1\",\n        \"accessList\": [],\n        \"type\": \"0x2\"\n    },\n    \"id\": 1\n}\n</code></pre> <p>Note that the <code>v-r-s</code> values are set to <code>0x1</code>, and the gas price-related fields are set to <code>0x0</code>. In addition, the <code>nonce</code> field corresponds to a global nonce of the Ethereum XCM Pallet, and not the transaction count of the dispatcher account.</p> <p>Note</p> <p>You might be able to find some transaction hash collisions in the Moonbase Alpha TestNet, as early versions of remote EVM calls through XCM did not use a global nonce of the Ethereum XCM Pallet.</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/","title":"Using the XCM Transactor Pallet for Remote Execution","text":""},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#introduction","title":"Introduction","text":"<p>XCM messages are comprised of a series of instructions that are executed by the Cross-Consensus Virtual Machine (XCVM). Combinations of these instructions result in predetermined actions such as cross-chain token transfers and, more interestingly, remote cross-chain execution. Remote execution involves executing operations or actions on one blockchain from another blockchain while maintaining the integrity of the sender's identity and permissions.</p> <p>Typically, XCM messages are sent from the root origin (that is, SUDO or through governance), which is not ideal for projects that want to leverage remote cross-chain calls via a simple transaction. The XCM Transactor Pallet makes it easy to transact on a remote chain through either the Sovereign account, which should only be allowed through governance, or a Computed Origin account via a simple transaction from the source chain.</p> <p>This guide will show you how to use the XCM Transactor Pallet to send XCM messages from a Moonbeam-based network to other chains in the ecosystem. In addition, you'll also learn how to use the XCM Transactor Precompile to perform the same actions via the Ethereum API.</p> <p>Note that there are still limitations to what you can remotely execute through XCM messages.</p> <p>Developers must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, it is essential to test XCM features on a TestNet before moving to a production environment.</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcm-transactor-pallet-interface","title":"XCM Transactor Pallet Interface","text":""},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#extrinsics","title":"Extrinsics","text":"<p>The XCM Transactor Pallet provides the following extrinsics (functions):</p> hrmpManage(action, fee, weightInfo) - manages HRMP operations related to opening, accepting, and closing an HRMP channel <p>On Moonbeam or Moonriver, this function must be executed via governance through the General Admin or the Root Track. On Moonbase Alpha or a Moonbeam development node, this function can also be executed via sudo.</p> ParametersPolkadot.js API Example <ul> <li><code>action</code> - the action to execute. Can be either <code>InitOpen</code>, <code>Accept</code>, <code>Close</code>, or <code>Cancel</code></li> <li><code>fee</code> - the asset to be used for fees. This contains the <code>currency</code> and the <code>feeAmount</code>:<ul> <li><code>currency</code> -  defines how you are specifying the token to use to pay for the fees, which can be either of the following:<ul> <li><code>AsCurrencyId</code> - the currency ID of the asset to use for the fees. The currency ID can be either:<ul> <li><code>SelfReserve</code> - uses the native asset</li> <li><code>ForeignAsset</code> - uses an external XC-20. It requires you to specify the asset ID of the XC-20</li> <li><code>LocalAssetReserve</code> - deprecated - use Local XC-20s instead via the <code>Erc20</code> currency type</li> <li><code>Erc20</code> - uses a local XC-20. It requires you to specify the contract address of the local XC-20</li> </ul> </li> <li><code>AsMultiLocation</code> - the XCM versioned multilocation for the asset to use for the fees</li> </ul> </li> <li><code>feeAmount</code> - (optional) the amount to use for fees</li> </ul> </li> <li><code>weightInfo</code> - the weight information to be used. The <code>weightInfo</code> structure contains the following:<ul> <li><code>transactRequiredWeightAtMost</code> \u2014 the weight required to perform the execution of the <code>Transact</code> call.  The <code>transactRequiredWeightAtMost</code> structure contains the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> <li><code>overallWeight</code> \u2014 (optional) the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> can be defined as either:<ul> <li><code>Unlimited</code> - allows an unlimited amount of weight that can be purchased</li> <li><code>Limited</code> - limits the amount of weight that can be purchased by defining the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> </ul> </li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst action = 'InitOpen'; // Or 'Accept', 'Close', or 'Cancel'\nconst fee = {\n  currency: {\n    AsCurrencyId: { ForeignAsset: INSERT_ASSET_ID },\n  },\n  feeAmount: INSERT_FEE_AMOUNT,\n};\nconst weightInfo = {\n  transactRequiredWeightAtMost: {\n    refTime: INSERT_REF_TIME,\n    proofSize: INSERT_PROOF_SIZE,\n  },\n  overallWeight: { Unlimited: null },\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.hrmpManage(action, fee, weightInfo);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\nmain();\n</code></pre> removeFeePerSecond(assetLocation) \u2014 remove the fee per second information for a given asset in its reserve chain <p>On Moonbeam or Moonriver, this function must be executed via governance through the General Admin or the Root Track. On Moonbase Alpha or a Moonbeam development node, this function can also be executed via sudo.</p> ParametersPolkadot.js API Example <ul> <li><code>assetLocation</code> - the XCM versioned multilocation of the asset to remove the fee per second information for</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst assetLocation = {\n  V4: {\n    parents: INSERT_PARENTS,\n    interior: INSERT_INTERIOR,\n  },\n};;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.removeFeePerSecond(assetLocation);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\nmain();\n</code></pre> removeTransactInfo(location) \u2014 remove the transact information for a given chain <p>On Moonbeam or Moonriver, this function must be executed via governance through the General Admin or the Root Track. On Moonbase Alpha or a Moonbeam development node, this function can also be executed via sudo.</p> ParametersPolkadot.js API Example <ul> <li><code>location</code> - the XCM versioned multilocation of a given chain that you wish to remove the transact information for</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst assetLocation = {\n  V4: {\n    parents: INSERT_PARENTS,\n    interior: INSERT_INTERIOR,\n  },\n};;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.removeTransactInfo(assetLocation);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\nmain();\n</code></pre> setFeePerSecond(assetLocation, feePerSecond) \u2014 sets the fee per second for a given asset on its reserve chain. The fee per second information typically relates to the cost of executing XCM instructions <p>On Moonbeam or Moonriver, this function must be executed via governance through the General Admin or the Root Track. On Moonbase Alpha or a Moonbeam development node, this function can also be executed via sudo.</p> ParametersPolkadot.js API Example <ul> <li><code>assetLocation</code> - the XCM versioned multilocation of the asset to remove the fee per second information for</li> <li><code>feePerSecond</code> - the number of token units per second of XCM execution that will be charged to the sender of the extrinsic when executing XCM instructions</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst assetLocation = {\n  V4: {\n    parents: INSERT_PARENTS,\n    interior: INSERT_INTERIOR,\n  },\n};\nconst feePerSecond = INSERT_FEE_PER_SECOND;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.setFeePerSecond(assetLocation, feePerSecond);\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\n\nmain();\n</code></pre> setTransactInfo(location, transactExtraWeight, maxWeight) \u2014 sets the transact information for a given chain. The transact information typically includes details about the weight required for executing XCM instructions as well as the maximum weight allowed for remote XCM execution on the target chain <p>On Moonbeam or Moonriver, this function must be executed via governance through the General Admin or the Root Track. On Moonbase Alpha or a Moonbeam development node, this function can also be executed via sudo.</p> ParametersPolkadot.js API Example <ul> <li><code>location</code> - the XCM versioned multilocation of a given chain that you wish to set the transact information for</li> <li><code>transactExtraWeight</code> \u2014 the weight to cover execution fees of the XCM instructions (<code>WithdrawAsset</code>, <code>BuyExecution</code>, and <code>Transact</code>), which is estimated to be at least 10% over what the remote XCM instructions execution uses. The <code>transactExtraWeight</code> structure contains the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> <li><code>maxWeight</code> \u2014 maximum weight units allowed for the remote XCM execution. The <code>maxWeight</code> structure also contains <code>refTime</code> and <code>proofSize</code></li> <li><code>transactExtraWeightSigned</code> \u2014 (optional) the weight to cover execution fees of the XCM instructions (<code>DescendOrigin</code>, <code>WithdrawAsset</code>, <code>BuyExecution</code>, and <code>Transact</code>), which is estimated to be at least 10% over what the remote XCM instructions execution uses. The <code>transactExtraWeightSigned</code> structure also contains <code>refTime</code> and <code>proofSize</code></li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst location = INSERT_MULTILOCATION;\nconst transactExtraWeight = {\n  refTime: INSERT_REF_TIME,\n  proofSize: INSERT_PROOF_SIZE,\n};\nconst maxWeight = {\n  refTime: INSERT_REF_TIME,\n  proofSize: INSERT_PROOF_SIZE,\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.setTransactInfo(\n    location,\n    transactExtraWeight,\n    maxWeight\n  );\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\n\nmain();\n</code></pre> transactThroughSigned(destination, fee, call, weightInfo, refund) \u2014 sends an XCM message with instructions to remotely execute a call in the destination chain. The remote call will be signed and executed by a new account that the destination parachain must compute. Moonbeam-based networks follow the Computed Origins standard set by Polkadot ParametersPolkadot.js API Example <ul> <li><code>dest</code> - the XCM versioned multilocation for a chain in the ecosystem where the XCM message is being sent to (the target chain)</li> <li><code>fee</code> - the asset to be used for fees. This contains the <code>currency</code> and the <code>feeAmount</code>:<ul> <li><code>currency</code> -  defines how you are specifying the token to use to pay for the fees, which can be either of the following:<ul> <li><code>AsCurrencyId</code> - the currency ID of the asset to use for the fees. The currency ID can be either:<ul> <li><code>SelfReserve</code> - uses the native asset</li> <li><code>ForeignAsset</code> - uses an external XC-20. It requires you to specify the asset ID of the XC-20</li> <li><code>LocalAssetReserve</code> - deprecated - use Local XC-20s instead via the <code>Erc20</code> currency type</li> <li><code>Erc20</code> - uses a local XC-20. It requires you to specify the contract address of the local XC-20</li> </ul> </li> <li><code>AsMultiLocation</code> - the XCM versioned multilocation for the asset to use for the fees</li> </ul> </li> <li><code>feeAmount</code> - (optional) the amount to use for fees</li> </ul> </li> <li><code>call</code> - encoded call data of the call that will be executed in the target chain</li> <li><code>weightInfo</code> - the weight information to be used. The <code>weightInfo</code> structure contains the following:<ul> <li><code>transactRequiredWeightAtMost</code> \u2014 the weight required to perform the execution of the <code>Transact</code> call.  The <code>transactRequiredWeightAtMost</code> structure contains the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> <li><code>overallWeight</code> \u2014 (optional) the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> can be defined as either:<ul> <li><code>Unlimited</code> - allows an unlimited amount of weight that can be purchased</li> <li><code>Limited</code> - limits the amount of weight that can be purchased by defining the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> </ul> </li> </ul> </li> <li><code>refund</code> - a boolean indicating whether or not to add the <code>RefundSurplus</code> and <code>DepositAsset</code> instructions to the XCM message to refund any leftover fees </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst dest = {\n  V4: {\n    parents: INSERT_PARENTS,\n    interior: INSERT_INTERIOR,\n  },\n};\nconst fee = {\n  currency: {\n    AsCurrencyId: { ForeignAsset: INSERT_ASSET_ID },\n  },\n  feeAmount: INSERT_FEE_AMOUNT,\n};\nconst call = 'INSERT_ENCODED_CALL_DATA';\nconst weightInfo = {\n  transactRequiredWeightAtMost: {\n    refTime: INSERT_REF_TIME,\n    proofSize: INSERT_PROOF_SIZE,\n  },\n  overallWeight: { Unlimited: null },\n};\nconst refund = INSERT_BOOLEAN_FOR_REFUND;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.transactThroughSigned(\n    dest,\n    fee,\n    call,\n    weightInfo,\n    refund\n  );\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\n\nmain();      \n</code></pre> <p>Note</p> <p>In the following sections, you'll learn exactly how to retrieve all of the arguments needed to build and send an XCM message using this extrinsic.</p> transactThroughSovereign(dest, feePayer, fee, call, originKind, weightInfo, refund) \u2014 sends an XCM message with instructions to remotely execute a given call at the given destination. The remote call will be signed by the origin parachain Sovereign account (who pays the fees), but the transaction is dispatched from a given origin. The XCM Transactor Pallet calculates the fees for the remote execution and charges the given account the estimated amount in the corresponding XC-20 token ParametersPolkadot.js API Example <ul> <li><code>dest</code> - the XCM versioned multilocation for a chain in the ecosystem where the XCM message is being sent to (the target chain)</li> <li><code>feePayer</code> - (optional) the address that will pay for the remote XCM execution in the corresponding XC-20 token. If you don't specify the <code>feePayer</code>, the XCM execution fees will be paid by the Sovereign account on the destination chain</li> <li><code>fee</code> - the asset to be used for fees. This contains the <code>currency</code> and the <code>feeAmount</code>:<ul> <li><code>currency</code> -  defines how you are specifying the token to use to pay for the fees, which can be either of the following:<ul> <li><code>AsCurrencyId</code> - the currency ID of the asset to use for the fees. The currency ID can be either:<ul> <li><code>SelfReserve</code> - uses the native asset</li> <li><code>ForeignAsset</code> - uses an external XC-20. It requires you to specify the asset ID of the XC-20</li> <li><code>LocalAssetReserve</code> - deprecated - use Local XC-20s instead via the <code>Erc20</code> currency type</li> <li><code>Erc20</code> - uses a local XC-20. It requires you to specify the contract address of the local XC-20</li> </ul> </li> <li><code>AsMultiLocation</code> - the XCM versioned multilocation for the asset to use for the fees</li> </ul> </li> <li><code>feeAmount</code> - (optional) the amount to use for fees</li> </ul> </li> <li><code>call</code> - encoded call data of the call that will be executed in the target chain</li> <li><code>originKind</code> \u2014 dispatcher of the remote call in the destination chain. There are four types of dispatchers available: <code>Native</code>, <code>SovereignAccount</code>, <code>Superuser</code>, or <code>Xcm</code></li> <li><code>weightInfo</code> - the weight information to be used. The <code>weightInfo</code> structure contains the following:<ul> <li><code>transactRequiredWeightAtMost</code> \u2014 the weight required to perform the execution of the <code>Transact</code> call.  The <code>transactRequiredWeightAtMost</code> structure contains the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> <li><code>overallWeight</code> \u2014 (optional) the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> can be defined as either:<ul> <li><code>Unlimited</code> - allows an unlimited amount of weight that can be purchased</li> <li><code>Limited</code> - limits the amount of weight that can be purchased by defining the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used</li> </ul> </li> </ul> </li> </ul> </li> <li><code>refund</code> - a boolean indicating whether or not to add the <code>RefundSurplus</code> and <code>DepositAsset</code> instructions to the XCM message to refund any leftover fees </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst dest = {\n  V4: {\n    parents: INSERT_PARENTS,\n    interior: INSERT_INTERIOR,\n  },\n};\nconst fee = {\n  currency: {\n    AsCurrencyId: { ForeignAsset: INSERT_ASSET_ID },\n  },\n  feeAmount: INSERT_FEE_AMOUNT,\n};\nconst feePayer = 'INSERT_ADDRESS_RESPONSIBLE_FOR_FEES';\nconst call = 'INSERT_ENCODED_CALL_DATA';\nconst originKind = 'INSERT_ORIGIN_KIND';\nconst weightInfo = {\n  transactRequiredWeightAtMost: {\n    refTime: INSERT_REF_TIME,\n    proofSize: INSERT_PROOF_SIZE,\n  },\n  overallWeight: { Unlimited: null },\n};\nconst refund = INSERT_BOOLEAN_FOR_REFUND;\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const tx = api.tx.xcmTransactor.transactThroughSovereign(\n    dest,\n    feePayer,\n    fee,\n    call,\n    originKind,\n    weightInfo,\n    refund\n  );\n  const txHash = await tx.signAndSend('INSERT_ACCOUNT_OR_KEYRING');\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#storage-methods","title":"Storage Methods","text":"<p>The XCM Transactor Pallet includes the following read-only storage method:</p> destinationAssetFeePerSecond(location) - returns the fee per second for a given asset ParametersReturnsPolkadot.js API Example <ul> <li><code>location</code> - (optional) the XCM versioned multilocation for a specific destination asset</li> </ul> <p>A number representing the value for fee per second of the given asset. This value may be returned in a different format depending on the chain and how they store their data. You can use the <code>@polkadot/util</code> library for a variety of conversions, for example, to convert a hex value to a big integer using the <code>hexToBigInt</code> method.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n10000000000000\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst location = {\n  parents: INSERT_PARENTS,\n  interior: INSERT_INTERIOR,\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const feePerSecond =\n    await api.query.xcmTransactor.destinationAssetFeePerSecond(location);\n\n  if (feePerSecond.isSome) {\n    const data = feePerSecond.unwrap();\n    console.log(data.toJSON());\n  }\n};\n\nmain();\n</code></pre> palletVersion() \u2014 returns current pallet version from storage ParametersReturnsPolkadot.js API Example <p>None</p> <p>A number representing the current version of the pallet.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n0\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const palletVersion = await api.query.xcmTransactor.palletVersion();\n};\n\nmain();\n</code></pre> transactInfoWithWeightLimit(location) \u2014 returns the transact information for a given multilocation ParametersReturnsPolkadot.js API Example <ul> <li><code>location</code> - (optional) the XCM versioned multilocation for a specific destination asset</li> </ul> <p>The transact information object.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n{\n  transactExtraWeight: { refTime: 3000000000, proofSize: 131072 },\n  maxWeight: { refTime: 20000000000, proofSize: 131072 },\n  transactExtraWeightSigned: { refTime: 4000000000, proofSize: 131072 },\n}\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst location = {\n  parents: INSERT_PARENTS,\n  interior: INSERT_INTERIOR,\n};\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n  const transactInfoWithWeightLimit =\n    await api.query.xcmTransactor.transactInfoWithWeightLimit(location);\n\n  if (transactInfoWithWeightLimit.isSome) {\n    const data = transactInfoWithWeightLimit.unwrap();\n    console.log(data.toJSON());\n  }\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#constants","title":"Pallet Constants","text":"<p>The XCM Transactor Pallet includes the following read-only functions to obtain pallet constants:</p> baseXcmWeight() - returns the base XCM weight required for execution, per XCM instruction ReturnsPolkadot.js API Example <p>The base XCM weight object.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n{ refTime: 200000000, proofSize: 0 }\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const baseXcmWeight = api.consts.xcmTransactor.baseXcmWeight;\n  console.log(baseXcmWeight.toJSON());\n};\n\nmain();\n</code></pre> selfLocation() - returns the multilocation of the chain ReturnsPolkadot.js API Example <p>The self-location multilocation object.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n{ parents: 0, interior: { here: null } }\n</code></pre> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('INSERT_WSS_ENDPOINT'),\n  });\n\n  const selfLocation = api.consts.xcmTransactor.selfLocation;\n  console.log(selfLocation.toJSON());\n};\n\nmain();\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcm-instructions-for-remote-execution","title":"XCM Instructions for Remote Execution","text":"<p>The relevant XCM instructions to perform remote execution through XCM are, but are not limited to:</p> <ul> <li><code>DescendOrigin</code> - gets executed in the target chain. It mutates the origin on the target chain to match the origin on the source chain, ensuring execution on the target chain occurs on behalf of the same entity initiating the XCM message on the source chain</li> <li><code>WithdrawAsset</code> - gets executed in the target chain. Removes assets and places them into a holding register</li> <li><code>BuyExecution</code> - gets executed in the target chain. Takes the assets from holding to pay for execution fees. The fees to pay are determined by the target chain</li> <li><code>Transact</code> - gets executed in the target chain. Dispatches encoded call data from a given origin, allowing for the execution of specific operations or functions</li> </ul>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcmtransactor-transact-through-signed","title":"Transact through a Computed Origin Account","text":"<p>This section covers building an XCM message for remote execution using the XCM Transactor Pallet, specifically with the <code>transactThroughSigned</code> function. This function uses a Computed Origin account on the destination chain to dispatch the remote call.</p> <p>The example in this section uses a destination parachain that is not publicly available, so you won't be able to follow along exactly. You can modify the example as needed for your own use case.</p> <p>Note</p> <p>You need to ensure that the call you are going to execute remotely is allowed in the destination chain!</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcmtransactor-signed-check-prerequisites","title":"Checking Prerequisites","text":"<p>To be able to send the extrinsics in this section, you need to have:</p> <ul> <li>An account in the origin chain with funds</li> <li>Funds in the Computed Origin account on the target chain. To learn how to calculate the address of the Computed Origin account, please refer to the How to Calculate the Computed Origin documentation</li> </ul> <p>For this example, the following accounts will be used:</p> <ul> <li>Alice's account in the origin parachain (Moonbase Alpha): <code>0x44236223aB4291b93EEd10E4B511B37a398DEE55</code></li> <li>Her Computed Origin address in the target parachain (Parachain 888): <code>0x5c27c4bb7047083420eddff9cddac4a0a120b45c</code></li> </ul>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#xcm-transact-through-signed","title":"Building the XCM","text":"<p>Since you'll be interacting with the <code>transactThroughSigned</code> function of the XCM Transactor Pallet, you'll need to assemble the values for the <code>dest</code>, <code>fee</code>, <code>call</code>, <code>weightInfo</code>, and <code>refund</code> parameters. To do so, you can take the following steps:</p> <ol> <li> <p>Define the destination multilocation, which will target parachain 888</p> <pre><code>const privateKey = 'INSERT_PRIVATE_KEY';\nconst dest = {\n  V4: {\n    parents: 1,\n    interior: { X1: [{ Parachain: 888 }] },\n  },\n</code></pre> </li> <li> <p>Define the <code>fee</code> information, which will require you to define the currency and set the fee amount</p> External XC-20sLocal XC-20s <pre><code>const fee = {\n  currency: {\n    AsCurrencyId: { ForeignAsset: 35487752324713722007834302681851459189n },\n  },\n  feeAmount: 50000000000000000n,\n};\n</code></pre> <pre><code>const fee = {\n  currency: {\n    AsCurrencyId: { Erc20: { contractAddress: ERC_20_ADDRESS} },\n  },\n  feeAmount: 50000000000000000n,\n};\n</code></pre> </li> <li> <p>Define the <code>call</code> that will be executed in the destination chain, which is the encoded call data of the pallet, method, and input to be called. It can be constructed in Polkadot.js Apps (which must be connected to the destination chain) or using the Polkadot.js API. For this example, the inner call is a simple balance transfer of 1 token of the destination chain to Alice's account there</p> <pre><code>const call = '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\n</code></pre> </li> <li> <p>Set the <code>weightInfo</code>, which includes the weight specific to the inner call (<code>transactRequiredWeightAtMost</code>) and the optional overall weight of the transact plus XCM execution (<code>overallWeight</code>). For each parameter, you can follow these guidelines:</p> <ul> <li>For <code>transactRequiredAtMost</code>, you can set <code>refTime</code> to <code>1000000000</code> weight units and <code>proofSize</code> to <code>40000</code></li> <li>For <code>overallWeight</code>, the value must be the total of <code>transactRequiredWeightAtMost</code> plus the weight needed to cover the execution costs for the XCM instructions in the destination chain. If you do not provide this value, the pallet will use the element in storage (if it exists) and add it to <code>transactRequiredWeightAtMost</code>. For this example, you can set the <code>overallWeight</code> to <code>Unlimited</code>, which removes the need to know how much weight the destination chain will require to execute the XCM</li> </ul> <pre><code>const weightInfo = {\n  transactRequiredWeightAtMost: { refTime: 1000000000n, proofSize: 40000n },\n  overallWeight: { Unlimited: null },\n};\n</code></pre> <p>Note</p> <p>For accurate estimates of the <code>refTime</code> and <code>proofSize</code> figures for <code>transactRequiredAtMost</code>, you can use the <code>paymentInfo</code> method of the Polkadot.js API.</p> </li> <li> <p>To refund any leftover XCM fees, you can set the <code>refund</code> value to <code>true</code>. Otherwise, set it to <code>false</code></p> <pre><code>const refund = true;\n</code></pre> </li> </ol>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#sending-the-xcm","title":"Sending the XCM","text":"<p>Now that you have the values for each of the parameters, you can write the script for the transaction. You'll take the following steps:</p> <ol> <li>Provide the input data for the call. This includes:<ul> <li>The Moonbase Alpha endpoint URL to create the provider</li> <li>The values for each of the parameters of the <code>transactThroughSigned</code> function</li> </ul> </li> <li>Create a Keyring instance that will be used to send the transaction</li> <li>Create the Polkadot.js API provider</li> <li>Craft the <code>xcmTransactor.transactThroughSigned</code> extrinsic with the <code>dest</code>, <code>fee</code>, <code>call</code>, <code>weightInfo</code>, and <code>refund</code> values</li> <li>Send the transaction using the <code>signAndSend</code> extrinsic and the Keyring instance you created in the second step</li> </ol> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a JavaScript file.</p> <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api'; // Version 10.13.1\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\n// 1. Provide input data\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst dest = {\n  V4: {\n    parents: 1,\n    interior: { X1: [{ Parachain: 888 }] },\n  },\n};\nconst fee = {\n  currency: {\n    AsCurrencyId: { ForeignAsset: 35487752324713722007834302681851459189n },\n  },\n  feeAmount: 50000000000000000n,\n};\nconst call = '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\nconst weightInfo = {\n  transactRequiredWeightAtMost: { refTime: 1000000000n, proofSize: 40000n },\n  overallWeight: { Unlimited: null },\n};\nconst refund = true;\n\nconst transactThroughSigned = async () =&gt; {\n  // 2. Create Keyring instance\n  await cryptoWaitReady();\n  const keyring = new Keyring({ type: 'ethereum' });\n  const alice = keyring.addFromUri(privateKey);\n\n  // 3. Create Substrate API provider\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  // 4. Craft the extrinsic\n  const tx = api.tx.xcmTransactor.transactThroughSigned(\n    dest,\n    fee,\n    call,\n    weightInfo,\n    refund\n  );\n\n  // 5. Send the transaction\n  const txHash = await tx.signAndSend(alice);\n  console.log(`Submitted with hash ${txHash}`);\n\n  api.disconnect();\n};\n\ntransactThroughSigned();\n</code></pre> <p>Note</p> <p>You can view an example of the above script, which sends one token to Alice's Computed Origin account on parachain 888, on Polkadot.js Apps using the following encoded calldata: <code>0x210604010100e10d00017576e5e612ff054915d426c546b1b21a010000c52ebca2b10000000000000000007c030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d02286bee02710200010001</code>.</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-pallet/#transact-through-computed-origin-fees","title":"XCM Transact through Computed Origin Fees","text":"<p>When transacting through the Computed Origin account, the transaction fees are paid by the same account from which the call is dispatched, which is a Computed Origin account in the destination chain. Consequently, the Computed Origin account must hold the necessary funds to pay for the entire execution. Note that the destination token, for which fees are paid, does not need to be registered as an XC-20 in the origin chain.</p> <p>To estimate the amount of tokens Alice's Computed Origin account will need to execute the remote call, you need to check the transact information specific to the destination chain. You can use the following script to get the transact information for parachain 888:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api'; // Version 10.13.1\n\nconst providerWsURL = 'wss://wss.api.moonbase.moonbeam.network';\n\nconst location = { parents: 1, interior: { X1: [{ Parachain: 888 }] } };\n\nconst main = async () =&gt; {\n  const substrateProvider = new WsProvider(providerWsURL);\n  const api = await ApiPromise.create({ provider: substrateProvider });\n\n  const transactInfoWithWeightLimit =\n    await api.query.xcmTransactor.transactInfoWithWeightLimit(location);\n\n  if (transactInfoWithWeightLimit.isSome) {\n    const data = transactInfoWithWeightLimit.unwrap();\n    const transactExtraWeightSigned =\n      data.toJSON().transactExtraWeightSigned.refTime;\n    console.log(transactExtraWeightSigned);\n  }\n\n  api.disconnect();\n};\n\nmain();\n</code></pre> <p>The response shows that the <code>transactExtraWeightSigned</code> is <code>400,000,000</code>. This weight is needed to execute the four XCM instructions for this remote call in that specific destination chain. Next, you need to find out how much the destination chain charges per weight of XCM execution in reference to the asset's price. Previously, this was done by sourcing a units per second value. However, this method has been replaced by calculating a relative price. Relative price refers to how many units of the foreign asset correspond to one unit of the native token (GLMR or MOVR) from a value (i.e., price) perspective. For example, if the foreign asset is worth $5 and GLMR is worth $0.25, the relative price would be 0.05. However, we must scale the result to 18 decimals to correspond to the Wei units used. In this case, the relative price would be <code>50000000000000000</code>.</p> <p>You can calculate the relative price with a script in the XCM Tools repo. The script is also reproduced below: </p> Calculate Relative Price <pre><code>import axios from 'axios';\nimport chalk from 'chalk';\n\n// CoinGecko IDs for the networks\nconst NETWORK_IDS = {\n  GLMR: 'moonbeam',\n  MOVR: 'moonriver',\n};\n\nasync function calculateRelativePrice(\n  assetPrice: number,\n  network: 'GLMR' | 'MOVR'\n): Promise&lt;string&gt; {\n  try {\n    // Fetch the native token price from CoinGecko\n    const response = await axios.get(\n      `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[network]}&amp;vs_currencies=usd`\n    );\n\n    const nativeTokenPrice = response.data[NETWORK_IDS[network]].usd;\n\n    // Calculate relative price with 18 decimal places\n    // Formula: (nativeTokenPrice / assetPrice) * 10^18\n    // This gives us how many units of the asset we need to equal 1 unit of native token\n    const relativePrice = (nativeTokenPrice / assetPrice) * Math.pow(10, 18);\n\n    // Return as string to preserve precision\n    return relativePrice.toFixed(0);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Failed to calculate relative price: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\nfunction validateInput(\n  price: string,\n  network: string\n): { assetPrice: number; network: 'GLMR' | 'MOVR' } {\n  // Validate price\n  const assetPrice = parseFloat(price);\n  if (isNaN(assetPrice) || assetPrice &lt;= 0) {\n    throw new Error('Price must be a positive number');\n  }\n\n  // Validate network\n  const upperNetwork = network.toUpperCase() as 'GLMR' | 'MOVR';\n  if (!['GLMR', 'MOVR'].includes(upperNetwork)) {\n    throw new Error('Network must be either GLMR or MOVR');\n  }\n\n  return { assetPrice, network: upperNetwork };\n}\n\nfunction printUsage() {\n  console.log('\\nUsage:');\n  console.log('npx ts-node relative-price-calculator.ts &lt;price&gt; &lt;network&gt;');\n  console.log('\\nExample:');\n  console.log('npx ts-node relative-price-calculator.ts 0.25 GLMR');\n  console.log('\\nParameters:');\n  console.log('price   - The price of your asset in USD');\n  console.log('network - Either GLMR or MOVR');\n}\n\nasync function main() {\n  try {\n    // Get command line arguments\n    const [, , price, network] = process.argv;\n\n    // Check if help flag is passed\n    if (price === '--help' || price === '-h') {\n      printUsage();\n      return;\n    }\n\n    // Check if required arguments are provided\n    if (!price || !network) {\n      console.error('Error: Missing required arguments');\n      printUsage();\n      process.exit(1);\n    }\n\n    // Validate inputs\n    const { assetPrice, network: validNetwork } = validateInput(price, network);\n\n    console.log(\n      `\\nCalculating relative price for asset worth $${assetPrice} against ${validNetwork}...`\n    );\n    const relativePrice = await calculateRelativePrice(\n      assetPrice,\n      validNetwork\n    );\n    const nativeTokenPrice = (\n      await axios.get(\n        `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[validNetwork]}&amp;vs_currencies=usd`\n      )\n    ).data[NETWORK_IDS[validNetwork]].usd;\n\n    const decimalRatio = nativeTokenPrice / assetPrice;\n\n    console.log(`\\nResults:`);\n    console.log(`Asset Price: $${assetPrice}`);\n    console.log(`Network: ${validNetwork}`);\n    console.log(`Native Token Price (from CoinGecko): $${nativeTokenPrice}`);\n    console.log(`\\nRelative Price Analysis:`);\n    console.log(\n      `1 ${validNetwork} is equal to approximately ${decimalRatio.toFixed(\n        3\n      )} of your specified token.`\n    );\n    console.log(\n      `With 18 decimals, 1 ${validNetwork} or in WEI, 1000000000000000000 is equal to a relative price of ${relativePrice} units of your token`\n    );\n    console.log(chalk.bold(`\\nRelative Price: ${relativePrice}`));\n    console.log(\n      `\\nThe relative price you should specify in asset registration steps is ${relativePrice}\\n`\n    );\n  } catch (error) {\n    console.error('\\nError:', error instanceof Error ? error.message : error);\n    process.exit(1);\n  }\n}\n\nmain();\n</code></pre> <p>Note that the relative price value is related to the cost estimated in the relay chain XCM fee calculation section or to the one shown in the units per weight section if the target is another parachain. You'll need to find the correct value to ensure that the amount of tokens the Computed Origin account holds is correct. Calculating the associated XCM execution fee is as simple as multiplying the <code>transactExtraWeightSigned</code> times the <code>relativePrice</code> (for an estimation):</p> <pre><code>XCM-Wei-Token-Cost = transactExtraWeightSigned * relativePrice\nXCM-Token-Cost = XCM-Wei-Token-Cost / DecimalConversion\n</code></pre> <p>Therefore, the actual calculation for one XCM Transactor transact through derivative call is:</p> <pre><code>XCM-Wei-Token-Cost = 400000000 * 50000000000000000\nXCM-Token-Cost = 20000000000000 / 10^18\n</code></pre> <p>The cost of transacting through a Computed Origin is <code>0.00002 TOKEN</code>. Note that this does not include the cost of the call being remotely executed, only XCM execution fees.</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/","title":"Using the XCM Transactor Precompile for Remote Execution","text":"<p>XCM messages are comprised of a series of instructions that are executed by the Cross-Consensus Virtual Machine (XCVM). Combinations of these instructions result in predetermined actions such as cross-chain token transfers and, more interestingly, remote cross-chain execution. Remote execution involves executing operations or actions on one blockchain from another blockchain while maintaining the integrity of the sender's identity and permissions.</p> <p>Typically, XCM messages are sent from the root origin (that is, SUDO or through governance), which is not ideal for projects that want to leverage remote cross-chain calls via a simple transaction. The XCM Transactor Pallet makes it easy to transact on a remote chain through either the Sovereign account, which should only be allowed through governance, or a Computed Origin account via a simple transaction from the source chain.</p> <p>However, the XCM Transactor Pallet is coded in Rust and is normally not accessible from the Ethereum API side of Moonbeam. As such, Moonbeam introduced the XCM Transactor Precompile, which is a Solidity interface that allows you to interact directly with the Substrate pallet using the Ethereum API.</p> <p>This guide will show you how to use the XCM Transactor Precompile to send XCM messages from a Moonbeam-based network to other chains in the ecosystem.</p> <p>Note that there are still limitations to what you can remotely execute through XCM messages.</p> <p>Developers must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, it is essential to test XCM features on a TestNet before moving to a production environment.</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#precompile-address","title":"XCM Transactor Precompile Contract Address","text":"<p>There are several versions of the XCM Transactor Precompile. V1 will be deprecated in the near future, so all implementations must migrate to the newer interfaces.</p> <p>The XCM Transactor Precompiles are located at the following addresses:</p> MoonbeamMoonriverMoonbase Alpha Version Address V1 <pre><code>0x0000000000000000000000000000000000000806</code></pre> V2 <pre><code>0x000000000000000000000000000000000000080d</code></pre> V3 <pre><code>0x0000000000000000000000000000000000000817</code></pre> Version Address V1 <pre><code>0x0000000000000000000000000000000000000806</code></pre> V2 <pre><code>0x000000000000000000000000000000000000080d</code></pre> V3 <pre><code>0x0000000000000000000000000000000000000817</code></pre> Version Address V1 <pre><code>0x0000000000000000000000000000000000000806</code></pre> V2 <pre><code>0x000000000000000000000000000000000000080d</code></pre> V3 <pre><code>0x0000000000000000000000000000000000000817</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcmtrasactor-solidity-interface","title":"The XCM Transactor Solidity Interface","text":"<p>The XCM Transactor Precompile is a Solidity interface through which developers can interact with the XCM Transactor Pallet using the Ethereum API.</p> XcmTransactorV1.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The XcmTransactorV1 contract's address.\naddress constant XCM_TRANSACTOR_V1_ADDRESS = 0x0000000000000000000000000000000000000806;\n\n/// @dev The XcmTransactorV1 contract's instance.\nXcmTransactorV1 constant XCM_TRANSACTOR_V1_CONTRACT = XcmTransactorV1(\n    XCM_TRANSACTOR_V1_ADDRESS\n);\n\n/// @author The Moonbeam Team\n/// @title Xcm Transactor Interface\n/// @dev The interface through which solidity contracts will interact with xcm transactor pallet\n/// @custom:address 0x0000000000000000000000000000000000000806\ninterface XcmTransactorV1 {\n    // A multilocation is defined by its number of parents and the encoded junctions (interior)\n    struct Multilocation {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    /// Get index of an account in xcm transactor\n    /// @custom:selector 3fdc4f36\n    /// @param index The index of which we want to retrieve the account\n    /// @return owner The owner of the derivative index\n    ///\n    function indexToAccount(uint16 index) external view returns (address owner);\n\n    /// DEPRECATED, replaced by transactInfoWithSigned\n    /// Get transact info of a multilocation\n    /// @custom:selector d07d87c3\n    /// @param multilocation The location for which we want to know the transact info\n    /// @return transactExtraWeight The extra weight involved in the XCM message of using derivative\n    /// @return feePerSecond The amount of fee charged for a second of execution in the dest\n    /// @return maxWeight Maximum allowed weight for a single message in dest\n    ///\n    function transactInfo(Multilocation memory multilocation)\n        external\n        view\n        returns (\n            uint64 transactExtraWeight,\n            uint256 feePerSecond,\n            uint64 maxWeight\n        );\n\n    /// Get transact info of a multilocation\n    /// @custom:selector b689e20c\n    /// @param multilocation The location for which we want to know the transact info\n    /// @return transactExtraWeight The extra weight involved in the XCM message of using derivative\n    /// @return transactExtraWeightSigned The extra weight involved in the XCM message of using signed\n    /// @return maxWeight Maximum allowed weight for a single message in dest\n    ///\n    function transactInfoWithSigned(Multilocation memory multilocation)\n        external\n        view\n        returns (\n            uint64 transactExtraWeight,\n            uint64 transactExtraWeightSigned,\n            uint64 maxWeight\n        );\n\n    /// Get fee per second charged in its reserve chain for an asset\n    /// @custom:selector 906c9990\n    /// @param multilocation The asset location for which we want to know the fee per second value\n    /// @return feePerSecond The fee per second that the reserve chain charges for this asset\n    ///\n    function feePerSecond(Multilocation memory multilocation)\n        external\n        view\n        returns (uint256 feePerSecond);\n\n    /// Transact through XCM using fee based on its multilocation\n    /// @custom:selector 94a63c54\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param transactor The transactor to be used\n    /// @param index The index to be used\n    /// @param feeAsset The asset in which we want to pay fees.\n    /// It has to be a reserve of the destination chain\n    /// @param weight The weight we want to buy in the destination chain\n    /// @param innerCall The inner call to be executed in the destination chain\n    function transactThroughDerivativeMultilocation(\n        uint8 transactor,\n        uint16 index,\n        Multilocation memory feeAsset,\n        uint64 weight,\n        bytes memory innerCall\n    ) external;\n\n    /// Transact through XCM using fee based on its currencyId\n    /// @custom:selector 02ae072d\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param transactor The transactor to be used\n    /// @param index The index to be used\n    /// @param currencyId Address of the currencyId of the asset to be used for fees\n    /// It has to be a reserve of the destination chain\n    /// @param weight The weight we want to buy in the destination chain\n    /// @param innerCall The inner call to be executed in the destination chain\n    function transactThroughDerivative(\n        uint8 transactor,\n        uint16 index,\n        address currencyId,\n        uint64 weight,\n        bytes memory innerCall\n    ) external;\n\n    /// Transact through XCM using fee based on its multilocation through signed origins\n    /// @custom:selector 71d31587\n    /// @dev No token is burnt before sending the message. The caller must ensure the destination\n    /// is able to understand the DescendOrigin message, and create a unique account from which\n    /// dispatch the call\n    /// @param dest The destination chain (as multilocation) where to send the message\n    /// @param feeLocation The asset multilocation that indentifies the fee payment currency\n    /// It has to be a reserve of the destination chain\n    /// @param weight The weight we want to buy in the destination chain for the call to be made\n    /// @param call The call to be executed in the destination chain\n    function transactThroughSignedMultilocation(\n        Multilocation memory dest,\n        Multilocation memory feeLocation,\n        uint64 weight,\n        bytes memory call\n    ) external;\n\n    /// Transact through XCM using fee based on its erc20 address through signed origins\n    /// @custom:selector 42ca339d\n    /// @dev No token is burnt before sending the message. The caller must ensure the destination\n    /// is able to understand the DescendOrigin message, and create a unique account from which\n    /// dispatch the call\n    /// @param dest The destination chain (as multilocation) where to send the message\n    /// @param feeLocationAddress The ERC20 address of the token we want to use to pay for fees\n    /// only callable if such an asset has been BRIDGED to our chain\n    /// @param weight The weight we want to buy in the destination chain for the call to be made\n    /// @param call The call to be executed in the destination chain\n    function transactThroughSigned(\n        Multilocation memory dest,\n        address feeLocationAddress,\n        uint64 weight,\n        bytes memory call\n    ) external;\n\n    /// @dev Encode 'utility.as_derivative' relay call\n    /// @custom:selector ff86378d\n    /// @param transactor The transactor to be used\n    /// @param index: The derivative index to use\n    /// @param innerCall: The inner call to be executed from the derivated address\n    /// @return result The bytes associated with the encoded call\n    function encodeUtilityAsDerivative(uint8 transactor, uint16 index, bytes memory innerCall)\n        external\n        pure\n        returns (bytes memory result);\n}\n</code></pre> XcmTransactorV2.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.0;\n\n/// @dev The XcmTransactorV2 contract's address.\naddress constant XCM_TRANSACTOR_V2_ADDRESS = 0x000000000000000000000000000000000000080D;\n\n/// @dev The XcmTransactorV2 contract's instance.\nXcmTransactorV2 constant XCM_TRANSACTOR_V2_CONTRACT = XcmTransactorV2(\n    XCM_TRANSACTOR_V2_ADDRESS\n);\n\n/// @author The Moonbeam Team\n/// @title Xcm Transactor Interface\n/// The interface through which solidity contracts will interact with xcm transactor pallet\n/// @custom:address 0x000000000000000000000000000000000000080D\ninterface XcmTransactorV2 {\n    // A multilocation is defined by its number of parents and the encoded junctions (interior)\n    struct Multilocation {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    /// Get index of an account in xcm transactor\n    /// @custom:selector 3fdc4f36\n    /// @param index The index of which we want to retrieve the account\n    /// @return owner The owner of the derivative index\n    ///\n    function indexToAccount(uint16 index) external view returns (address owner);\n\n    /// Get transact info of a multilocation\n    /// @custom:selector b689e20c\n    /// @param multilocation The location for which we want to know the transact info\n    /// @return transactExtraWeight The extra weight involved in the XCM message of using derivative\n    /// @return transactExtraWeightSigned The extra weight involved in the XCM message of using signed\n    /// @return maxWeight Maximum allowed weight for a single message in dest\n    ///\n    function transactInfoWithSigned(Multilocation memory multilocation)\n        external\n        view\n        returns (\n            uint64 transactExtraWeight,\n            uint64 transactExtraWeightSigned,\n            uint64 maxWeight\n        );\n\n    /// Get fee per second charged in its reserve chain for an asset\n    /// @custom:selector 906c9990\n    /// @param multilocation The asset location for which we want to know the fee per second value\n    /// @return feePerSecond The fee per second that the reserve chain charges for this asset\n    ///\n    function feePerSecond(Multilocation memory multilocation)\n        external\n        view\n        returns (uint256 feePerSecond);\n\n    /// Transact through XCM using fee based on its multilocation\n    /// @custom:selector fe430475\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param transactor The transactor to be used\n    /// @param index The index to be used\n    /// @param feeAsset The asset in which we want to pay fees.\n    /// It has to be a reserve of the destination chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain\n    /// @param innerCall The inner call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message.\n    ///\n    function transactThroughDerivativeMultilocation(\n        uint8 transactor,\n        uint16 index,\n        Multilocation memory feeAsset,\n        uint64 transactRequiredWeightAtMost,\n        bytes memory innerCall,\n        uint256 feeAmount,\n        uint64 overallWeight\n    ) external;\n\n    /// Transact through XCM using fee based on its currency_id\n    /// @custom:selector 185de2ae\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param transactor The transactor to be used\n    /// @param index The index to be used\n    /// @param currencyId Address of the currencyId of the asset to be used for fees\n    /// It has to be a reserve of the destination chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain\n    /// @param innerCall The inner call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message.\n    function transactThroughDerivative(\n        uint8 transactor,\n        uint16 index,\n        address currencyId,\n        uint64 transactRequiredWeightAtMost,\n        bytes memory innerCall,\n        uint256 feeAmount,\n        uint64 overallWeight\n    ) external;\n\n    /// Transact through XCM using fee based on its multilocation through signed origins\n    /// @custom:selector d7ab340c\n    /// @dev No token is burnt before sending the message. The caller must ensure the destination\n    /// is able to understand the DescendOrigin message, and create a unique account from which\n    /// dispatch the call\n    /// @param dest The destination chain (as multilocation) where to send the message\n    /// @param feeLocation The asset multilocation that indentifies the fee payment currency\n    /// It has to be a reserve of the destination chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain for the call to be made\n    /// @param call The call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message.\n    function transactThroughSignedMultilocation(\n        Multilocation memory dest,\n        Multilocation memory feeLocation,\n        uint64 transactRequiredWeightAtMost,\n        bytes memory call,\n        uint256 feeAmount,\n        uint64 overallWeight\n    ) external;\n\n    /// Transact through XCM using fee based on its erc20 address through signed origins\n    /// @custom:selector b648f3fe\n    /// @dev No token is burnt before sending the message. The caller must ensure the destination\n    /// is able to understand the DescendOrigin message, and create a unique account from which\n    /// dispatch the call\n    /// @param dest The destination chain (as multilocation) where to send the message\n    /// @param feeLocationAddress The ERC20 address of the token we want to use to pay for fees\n    /// only callable if such an asset has been BRIDGED to our chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain for the call to be made\n    /// @param call The call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message.\n    function transactThroughSigned(\n        Multilocation memory dest,\n        address feeLocationAddress,\n        uint64 transactRequiredWeightAtMost,\n        bytes memory call,\n        uint256 feeAmount,\n        uint64 overallWeight\n    ) external;\n\n    /// @dev Encode 'utility.as_derivative' relay call\n    /// @custom:selector ff86378d\n    /// @param transactor The transactor to be used\n    /// @param index: The derivative index to use\n    /// @param innerCall: The inner call to be executed from the derivated address\n    /// @return result The bytes associated with the encoded call\n    function encodeUtilityAsDerivative(uint8 transactor, uint16 index, bytes memory innerCall)\n        external\n        pure\n        returns (bytes memory result);\n}\n</code></pre> XcmTransactorV3.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.0;\n\n/// @dev The XcmTransactorV3 contract's address.\naddress constant XCM_TRANSACTOR_V3_ADDRESS = 0x0000000000000000000000000000000000000817;\n\n/// @dev The XcmTransactorV3 contract's instance.\nXcmTransactorV3 constant XCM_TRANSACTOR_V3_CONTRACT = XcmTransactorV3(\n    XCM_TRANSACTOR_V3_ADDRESS\n);\n\n/// @author The Moonbeam Team\n/// @title Xcm Transactor Interface\n/// The interface through which solidity contracts will interact with xcm transactor pallet\n/// @custom:address 0x0000000000000000000000000000000000000817\ninterface XcmTransactorV3 {\n    // A multilocation is defined by its number of parents and the encoded junctions (interior)\n    struct Multilocation {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    // Support for Weights V2\n    struct Weight {\n        uint64 refTime;\n        uint64 proofSize;\n    }\n\n    /// Get index of an account in xcm transactor\n    /// @custom:selector 3fdc4f36\n    /// @param index The index of which we want to retrieve the account\n    /// @return owner The owner of the derivative index\n    ///\n    function indexToAccount(uint16 index) external view returns (address owner);\n\n    /// Get transact info of a multilocation\n    /// @custom:selector b689e20c\n    /// @param multilocation The location for which we want to know the transact info\n    /// @return transactExtraWeight The extra weight involved in the XCM message of using derivative\n    /// @return transactExtraWeightSigned The extra weight involved in the XCM message of using signed\n    /// @return maxWeight Maximum allowed weight for a single message in dest\n    ///\n    function transactInfoWithSigned(Multilocation memory multilocation)\n        external\n        view\n        returns (\n            Weight memory transactExtraWeight,\n            Weight memory transactExtraWeightSigned,\n            Weight memory maxWeight\n        );\n\n    /// Get fee per second charged in its reserve chain for an asset\n    /// @custom:selector 906c9990\n    /// @param multilocation The asset location for which we want to know the fee per second value\n    /// @return feePerSecond The fee per second that the reserve chain charges for this asset\n    ///\n    function feePerSecond(Multilocation memory multilocation)\n        external\n        view\n        returns (uint256 feePerSecond);\n\n    /// Transact through XCM using fee based on its multilocation\n    /// @custom:selector bdacc26b\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param transactor The transactor to be used\n    /// @param index The index to be used\n    /// @param feeAsset The asset in which we want to pay fees.\n    /// It has to be a reserve of the destination chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain\n    /// @param innerCall The inner call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message. If uint64:MAX is passed \n    /// through refTime field, Unlimited variant will be used. \n    /// @param refund Indicates if RefundSurplus instruction will be appended\n    function transactThroughDerivativeMultilocation(\n        uint8 transactor,\n        uint16 index,\n        Multilocation memory feeAsset,\n        Weight memory transactRequiredWeightAtMost,\n        bytes memory innerCall,\n        uint256 feeAmount,\n        Weight memory overallWeight,\n        bool refund\n    ) external;\n\n    /// Transact through XCM using fee based on its currency_id\n    /// @custom:selector ca8c82d8\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param transactor The transactor to be used\n    /// @param index The index to be used\n    /// @param currencyId Address of the currencyId of the asset to be used for fees\n    /// It has to be a reserve of the destination chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain\n    /// @param innerCall The inner call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message. If uint64:MAX is passed \n    /// through refTime field, Unlimited variant will be used. \n    /// @param refund Indicates if RefundSurplus instruction will be appended\n    function transactThroughDerivative(\n        uint8 transactor,\n        uint16 index,\n        address currencyId,\n        Weight memory transactRequiredWeightAtMost,\n        bytes memory innerCall,\n        uint256 feeAmount,\n        Weight memory overallWeight,\n        bool refund\n    ) external;\n\n    /// Transact through XCM using fee based on its multilocation through signed origins\n    /// @custom:selector 27b1d492\n    /// @dev No token is burnt before sending the message. The caller must ensure the destination\n    /// is able to understand the DescendOrigin message, and create a unique account from which\n    /// dispatch the call\n    /// @param dest The destination chain (as multilocation) where to send the message\n    /// @param feeLocation The asset multilocation that indentifies the fee payment currency\n    /// It has to be a reserve of the destination chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain for the call to be made\n    /// @param call The call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message. If uint64:MAX is passed \n    /// through refTime field, Unlimited variant will be used. \n    /// @param refund Indicates if RefundSurplus instruction will be appended\n    function transactThroughSignedMultilocation(\n        Multilocation memory dest,\n        Multilocation memory feeLocation,\n        Weight memory transactRequiredWeightAtMost,\n        bytes memory call,\n        uint256 feeAmount,\n        Weight memory overallWeight,\n        bool refund\n    ) external;\n\n    /// Transact through XCM using fee based on its erc20 address through signed origins\n    /// @custom:selector b18270cf\n    /// @dev No token is burnt before sending the message. The caller must ensure the destination\n    /// is able to understand the DescendOrigin message, and create a unique account from which\n    /// dispatch the call\n    /// @param dest The destination chain (as multilocation) where to send the message\n    /// @param feeLocationAddress The ERC20 address of the token we want to use to pay for fees\n    /// only callable if such an asset has been BRIDGED to our chain\n    /// @param transactRequiredWeightAtMost The weight we want to buy in the destination chain for the call to be made\n    /// @param call The call to be executed in the destination chain\n    /// @param feeAmount Amount to be used as fee.\n    /// @param overallWeight Overall weight to be used for the xcm message. If uint64:MAX is passed \n    /// through refTime field, Unlimited variant will be used. \n    /// @param refund Indicates if RefundSurplus instruction will be appended\n    function transactThroughSigned(\n        Multilocation memory dest,\n        address feeLocationAddress,\n        Weight memory transactRequiredWeightAtMost,\n        bytes memory call,\n        uint256 feeAmount,\n        Weight memory overallWeight,\n        bool refund\n    ) external;\n\n    /// @dev Encode 'utility.as_derivative' relay call\n    /// @custom:selector ff86378d\n    /// @param transactor The transactor to be used\n    /// @param index: The derivative index to use\n    /// @param innerCall: The inner call to be executed from the derivated address\n    /// @return result The bytes associated with the encoded call\n    function encodeUtilityAsDerivative(uint8 transactor, uint16 index, bytes memory innerCall)\n        external\n        pure\n        returns (bytes memory result);\n}\n</code></pre> <p>Note</p> <p>The XCM Transactor Precompile V1 will be deprecated in the near future, so all implementations must migrate to the newer interfaces.</p> <p>The interface varies slightly from version to version. You can find an overview of each version's interface below.</p> V2V3 <p>The V2 interface includes the following functions:</p> transactInfoWithSigned(Multilocation memory multilocation) \u2014 read-only function that returns the transact information for a given chain ParametersReturns <ul> <li><code>multilocation</code> - the multilocation of the chain to get the transact information for</li> </ul> <p>The transact information for:</p> <ul> <li>The three XCM instructions associated with the external call execution (<code>transactExtraWeight</code>)</li> <li>The extra weight information associated with the <code>DescendOrigin</code> XCM instruction for the transact through signed extrinsic (<code>transactExtraWeightSigned</code>)</li> <li>The maximum allowed weight for the message in the given chain</li> </ul> <pre><code>[ 173428000n, 0n, 20000000000n ]\n</code></pre> feePerSecond(Multilocation memory multilocation) \u2014 read-only function that returns units of tokens per second of the XCM execution that is charged as the XCM execution fee for a given asset. This is useful when, for a given chain, there are multiple assets that can be used for fee payment ParametersReturns <ul> <li><code>multilocation</code> - the multilocation of the asset to get the units per second value for</li> </ul> <p>The fee per second that the reserve chain charges for the given asset.</p> <pre><code>13764626000000n\n</code></pre> transactThroughSignedMultilocation(Multilocation memory dest, Multilocation memory feeLocation, uint64 transactRequiredWeightAtMost, bytes memory call, uint256 feeAmount, uint64 overallWeight) \u2014 sends an XCM message with instructions to remotely execute a call in the destination chain. The remote call will be signed and executed by a new account, called the Computed Origin account, that the destination parachain must compute. Moonbeam-based networks follow the Computed Origins standard set by Polkadot. You need to provide the asset multilocation of the token that is used for fee payment instead of the address of the XC-20 token Parameters <ul> <li><code>dest</code> - the multilocation of a chain in the ecosystem where the XCM message is being sent to (the target chain). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>feeLocation</code> - the multilocation of the asset to use for fee payment. The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>transactRequiredWeightAtMost</code> - the weight to buy in the destination chain for the execution of the call defined in the <code>Transact</code> instruction</li> <li><code>call</code> - the call to be executed in the destination chain, as defined in the <code>Transact</code> instruction </li> <li><code>feeAmount</code> - the amount to be used as a fee</li> <li><code>overallWeight</code> - the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> structure also contains <code>refTime</code> and <code>proofSize</code>. If you pass in the maximum value for a uint64 for the <code>refTime</code>, you'll allow for an unlimited amount of weight to be purchased, which removes the need to know exactly how much weight the destination chain requires to execute the XCM</li> </ul> transactThroughSigned(Multilocation memory dest, address feeLocationAddress, uint64 transactRequiredWeightAtMost, bytes memory call, uint256 feeAmount, uint64 overallWeight) \u2014 sends an XCM message with instructions to remotely execute a call in the destination chain. The remote call will be signed and executed by a new account, called the Computed Origin account, that the destination parachain must compute. Moonbeam-based networks follow the Computed Origins standard set by Polkadot. You need to provide the address of the XC-20 asset to be used for fee payment Parameters <ul> <li><code>dest</code> - the multilocation of a chain in the ecosystem where the XCM message is being sent to (the target chain). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>feeLocationAddress</code> - the XC-20 address of the asset to use for fee payment</li> <li><code>transactRequiredWeightAtMost</code> - the weight to buy in the destination chain for the execution of the call defined in the <code>Transact</code> instruction</li> <li><code>call</code> - the call to be executed in the destination chain, as defined in the <code>Transact</code> instruction </li> <li><code>feeAmount</code> - the amount to be used as a fee</li> <li><code>overallWeight</code> - the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> structure also contains <code>refTime</code> and <code>proofSize</code>. If you pass in the maximum value for a uint64 for the <code>refTime</code>, you'll allow for an unlimited amount of weight to be purchased, which removes the need to know exactly how much weight the destination chain requires to execute the XCM</li> </ul> <p>The V3 interface adds support for Weights V2, which updates the <code>Weight</code> type to represent proof size in addition to computational time. As such, this requires that <code>refTime</code> and <code>proofSize</code> be defined, where <code>refTime</code> is the amount of computational time that can be used for execution and <code>proofSize</code> is the amount of storage in bytes that can be used. </p> <p>The following struct was added to the XCM Transactor Precompile to support Weights V2:</p> <pre><code>struct Weight {\n    uint64 refTime;\n    uint65 proofSize;\n}\n</code></pre> <p>Additionally, support for the <code>RefundSurplus</code> and <code>DepositAsset</code> instructions was added. To append the <code>RefundSurplus</code> instruction to the XCM message, you can use the <code>refund</code> parameter, which will refund any leftover funds not used for the <code>Transact</code> if set to <code>true</code>.</p> <p>The V3 interface includes the following functions:</p> transactInfoWithSigned(Multilocation memory multilocation) \u2014 read-only function that returns the transact information for a given chain ParametersReturns <ul> <li><code>multilocation</code> - the multilocation of the chain to get the transact information for</li> </ul> <p>The transact information for:</p> <ul> <li>The three XCM instructions associated with the external call execution (<code>transactExtraWeight</code>)</li> <li>The extra weight information associated with the <code>DescendOrigin</code> XCM instruction for the transact through signed extrinsic (<code>transactExtraWeightSigned</code>)</li> <li>The maximum allowed weight for the message in the given chain</li> </ul> <pre><code>[ 173428000n, 0n, 20000000000n ]\n</code></pre> feePerSecond(Multilocation memory multilocation) \u2014 read-only function that returns units of token per second of the XCM execution that is charged as the XCM execution fee for a given asset. This is useful when, for a given chain, there are multiple assets that can be used for fee payment ParametersReturns <ul> <li><code>multilocation</code> - the multilocation of the asset to get the units per second value for</li> </ul> <p>The fee per second that the reserve chain charges for the given asset.</p> <pre><code>13764626000000n\n</code></pre> transactThroughSignedMultilocation(Multilocation memory dest, Multilocation memory feeLocation, Weight transactRequiredWeightAtMost, bytes memory call, uint256 feeAmount, Weight overallWeight, bool refund) \u2014 sends an XCM message with instructions to remotely execute a call in the destination chain. The remote call will be signed and executed by a new account, called the Computed Origin account, that the destination parachain must compute. Moonbeam-based networks follow the Computed Origins standard set by Polkadot. You need to provide the asset multilocation of the token that is used for fee payment instead of the address of the XC-20 token Parameters <ul> <li><code>dest</code> - the multilocation of a chain in the ecosystem where the XCM message is being sent to (the target chain). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>feeLocation</code> - the multilocation of the asset to use for fee payment. The multilocation must be formatted in a particular way, which is described in the following section</li> <li><code>transactRequiredWeightAtMost</code> - the weight to buy in the destination chain for the execution of the call defined in the <code>Transact</code> instruction. The <code>transactRequiredWeightAtMost</code> structure contains the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used It should be formatted as follows: <pre><code>[ INSERT_REF_TIME, INSERT_PROOF_SIZE ]\n</code></pre></li> </ul> </li> <li><code>call</code> - the call to be executed in the destination chain, as defined in the <code>Transact</code> instruction </li> <li><code>feeAmount</code> - the amount to be used as a fee</li> <li><code>overallWeight</code> - the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> structure also contains <code>refTime</code> and <code>proofSize</code>. If you pass in the maximum value for a uint64 for the <code>refTime</code>, you'll allow for an unlimited amount of weight to be purchased, which removes the need to know exactly how much weight the destination chain requires to execute the XCM</li> <li><code>refund</code> -  a boolean indicating whether or not to add the <code>RefundSurplus</code> and <code>DepositAsset</code> instructions to the XCM message to refund any leftover fees </li> </ul> transactThroughSigned(Multilocation memory dest, address feeLocationAddress, Weight transactRequiredWeightAtMost, bytes memory call, uint256 feeAmount, Weight overallWeight, bool refund) \u2014 sends an XCM message with instructions to remotely execute a call in the destination chain. The remote call will be signed and executed by a new account, called the Computed Origin account, that the destination parachain must compute. Moonbeam-based networks follow the Computed Origins standard set by Polkadot. You need to provide the address of the XC-20 asset to be used for fee payment Parameters <ul> <li><code>dest</code> - the multilocation of a chain in the ecosystem where the XCM message is being sent to (the target chain). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>feeLocationAddress</code> - the XC-20 address of the asset to use for fee payment</li> <li><code>transactRequiredWeightAtMost</code> - the weight to buy in the destination chain for the execution of the call defined in the <code>Transact</code> instruction. The <code>transactRequiredWeightAtMost</code> structure contains the following:<ul> <li><code>refTime</code> - the amount of computational time that can be used for execution</li> <li><code>proofSize</code> - the amount of storage in bytes that can be used It should be formatted as follows: <pre><code>[ INSERT_REF_TIME, INSERT_PROOF_SIZE ]\n</code></pre></li> </ul> </li> <li><code>call</code> - the call to be executed in the destination chain, as defined in the <code>Transact</code> instruction </li> <li><code>feeAmount</code> - the amount to be used as a fee</li> <li><code>overallWeight</code> - the total weight the extrinsic can use to execute all the XCM instructions, plus the weight of the <code>Transact</code> call (<code>transactRequiredWeightAtMost</code>). The <code>overallWeight</code> structure also contains <code>refTime</code> and <code>proofSize</code>. If you pass in the maximum value for a uint64 for the <code>refTime</code>, you'll allow for an unlimited amount of weight to be purchased, which removes the need to know exactly how much weight the destination chain requires to execute the XCM</li> <li><code>refund</code> -  a boolean indicating whether or not to add the <code>RefundSurplus</code> and <code>DepositAsset</code> instructions to the XCM message to refund any leftover fees </li> </ul>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcm-instructions-for-remote-execution","title":"XCM Instructions for Remote Execution","text":"<p>The relevant XCM instructions to perform remote execution through XCM are, but are not limited to:</p> <ul> <li><code>DescendOrigin</code> - gets executed in the target chain. It mutates the origin on the target chain to match the origin on the source chain, ensuring execution on the target chain occurs on behalf of the same entity initiating the XCM message on the source chain</li> <li><code>WithdrawAsset</code> - gets executed in the target chain. Removes assets and places them into a holding register</li> <li><code>BuyExecution</code> - gets executed in the target chain. Takes the assets from holding to pay for execution fees. The fees to pay are determined by the target chain</li> <li><code>Transact</code> - gets executed in the target chain. Dispatches encoded call data from a given origin, allowing for the execution of specific operations or functions</li> </ul>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#building-the-precompile-multilocation","title":"Building the Precompile Multilocation","text":"<p>In the XCM Transactor Precompile interface, the <code>Multilocation</code> structure is defined as follows:</p> <pre><code> struct Multilocation {\n    uint8 parents;\n    bytes[] interior;\n}\n</code></pre> <p>As with a standard multilocation, there are <code>parents</code> and <code>interior</code> elements. However, instead of defining the multilocation as an object, with Ethereum libraries, the struct is defined as an array, which contains a <code>uint8</code> for the <code>parents</code> as the first element and a bytes array for the <code>interior</code> as the second element.</p> <p>The normal values you would see for the <code>parents</code> element are:</p> Origin Destination Parents Value Parachain A Parachain A 0 Parachain A Relay Chain 1 Parachain A Parachain B 1 <p>For the <code>interior</code> element, the number of fields you need to drill down to in the target chain to reach the exact location of the target, such as the specific asset or account, represents the size of the bytes array:</p> Array Size Interior Value [] 0 Here [XYZ] 1 X1 [XYZ, ABC] 2 X2 [XYZ, ... N] N XN <p>Note</p> <p>Interior value <code>Here</code> is often used for the relay chain (either as a destination or to target the relay chain asset).</p> <p>Each field required to reach the exact location of the target needs to be defined as a hex string. The first byte (2 hexadecimal characters) corresponds to the selector of the field. For example:</p> Byte Value Selector Data Type 0x00 Parachain bytes4 0x01 AccountId32 bytes32 0x02 AccountIndex64 u64 0x03 AccountKey20 bytes20 0x04 PalletInstance byte 0x05 GeneralIndex u128 0x06 GeneralKey bytes[] <p>Next, depending on the selector and its data type, the following bytes correspond to the actual data being provided. Note that for <code>AccountId32</code>, <code>AccountIndex64</code>, and <code>AccountKey20</code>, the optional <code>network</code> field is appended at the end. For example:</p> Selector Data Value Represents Parachain \"0x00+000007E7\" Parachain ID 2023 AccountId32 \"0x01+AccountId32+00\" AccountId32, Network(Option) Null AccountId32 \"0x01+AccountId32+03\" AccountId32, Network Polkadot AccountKey20 \"0x03+AccountKey20+00\" AccountKey20, Network(Option) Null PalletInstance \"0x04+03\" Pallet Instance 3 <p>Note</p> <p>The <code>interior</code> data usually needs to be wrapped around quotes, or you might get an <code>invalid tuple value</code> error.</p> <p>The following code snippet goes through some examples of <code>Multilocation</code> structures, as they would need to be fed into the XCM Transactor Precompile functions:</p> <pre><code>// Multilocation targeting the relay chain asset from a parachain\n[\n  1, // parents = 1\n  [], // interior = here\n]\n\n// Multilocation targeting Moonbase Alpha DEV token from another parachain\n[\n  1, // parents = 1\n  [  // interior = X2 (the array has a length of 2)\n    \"0x00000003E8\", // Parachain selector + Parachain ID 1000 (Moonbase Alpha)\n    \"0x0403\", // Pallet Instance selector + Pallet Instance 3 (Balances Pallet)\n  ],\n]\n\n// Multilocation targeting aUSD asset on Acala\n[\n  1, // parents = 1\n  [  // interior = X2 (the array has a length of 2)\n    \"0x00000007D0\", // Parachain selector + Parachain ID 2000 (Acala)\n    \"0x060001\", // General Key selector + Asset Key\n  ],\n]\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcmtransactor-transact-through-signed","title":"Transact through a Computed Origin Account","text":"<p>This section covers building an XCM message for remote execution using the XCM Transactor Pallet, specifically with the <code>transactThroughSigned</code> function. This function uses a Computed Origin account on the destination chain to dispatch the remote call.</p> <p>The example in this section uses a destination parachain that is not publicly available, so you won't be able to follow along exactly. You can modify the example as needed for your own use case.</p> <p>Note</p> <p>You need to ensure that the call you are going to execute remotely is allowed in the destination chain!</p>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcmtransactor-signed-check-prerequisites","title":"Checking Prerequisites","text":"<p>To be able to send the extrinsics in this section, you need to have:</p> <ul> <li>An account in the origin chain with funds</li> <li>Funds in the Computed Origin account on the target chain. To learn how to calculate the address of the Computed Origin account, please refer to the How to Calculate the Computed Origin documentation</li> </ul> <p>For this example, the following accounts will be used:</p> <ul> <li>Alice's account in the origin parachain (Moonbase Alpha): <code>0x44236223aB4291b93EEd10E4B511B37a398DEE55</code></li> <li>Her Computed Origin address in the target parachain (Parachain 888): <code>0x5c27c4bb7047083420eddff9cddac4a0a120b45c</code></li> </ul>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#xcm-transact-through-signed","title":"Building the XCM","text":"<p>For this example, you'll interact with the <code>transactThroughSigned</code> function of the XCM Transactor Precompile V3. To use this function, you'll take these general steps:</p> <ol> <li>Create a provider using a Moonbase Alpha RPC endpoint</li> <li>Create a signer to send the transaction. This example uses a private key to create the signer and is for demo purposes only. Never store your private key in a JavaScript file</li> <li> <p>Create a contract instance of the XCM Transactor V3 Precompile using the address and ABI of the precompile</p> XCM Transactor V3 ABI <pre><code>[\n  {\n    inputs: [\n      {\n        internalType: 'uint8',\n        name: 'transactor',\n        type: 'uint8',\n      },\n      {\n        internalType: 'uint16',\n        name: 'index',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes',\n        name: 'innerCall',\n        type: 'bytes',\n      },\n    ],\n    name: 'encodeUtilityAsDerivative',\n    outputs: [\n      {\n        internalType: 'bytes',\n        name: 'result',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Multilocation',\n        name: 'multilocation',\n        type: 'tuple',\n      },\n    ],\n    name: 'feePerSecond',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: 'feePerSecond',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint16',\n        name: 'index',\n        type: 'uint16',\n      },\n    ],\n    name: 'indexToAccount',\n    outputs: [\n      {\n        internalType: 'address',\n        name: 'owner',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Multilocation',\n        name: 'multilocation',\n        type: 'tuple',\n      },\n    ],\n    name: 'transactInfoWithSigned',\n    outputs: [\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'transactExtraWeight',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'transactExtraWeightSigned',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'maxWeight',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint8',\n        name: 'transactor',\n        type: 'uint8',\n      },\n      {\n        internalType: 'uint16',\n        name: 'index',\n        type: 'uint16',\n      },\n      {\n        internalType: 'address',\n        name: 'currencyId',\n        type: 'address',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'transactRequiredWeightAtMost',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'innerCall',\n        type: 'bytes',\n      },\n      {\n        internalType: 'uint256',\n        name: 'feeAmount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'overallWeight',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bool',\n        name: 'refund',\n        type: 'bool',\n      },\n    ],\n    name: 'transactThroughDerivative',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint8',\n        name: 'transactor',\n        type: 'uint8',\n      },\n      {\n        internalType: 'uint16',\n        name: 'index',\n        type: 'uint16',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Multilocation',\n        name: 'feeAsset',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'transactRequiredWeightAtMost',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'innerCall',\n        type: 'bytes',\n      },\n      {\n        internalType: 'uint256',\n        name: 'feeAmount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'overallWeight',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bool',\n        name: 'refund',\n        type: 'bool',\n      },\n    ],\n    name: 'transactThroughDerivativeMultilocation',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Multilocation',\n        name: 'dest',\n        type: 'tuple',\n      },\n      {\n        internalType: 'address',\n        name: 'feeLocationAddress',\n        type: 'address',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'transactRequiredWeightAtMost',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'call',\n        type: 'bytes',\n      },\n      {\n        internalType: 'uint256',\n        name: 'feeAmount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'overallWeight',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bool',\n        name: 'refund',\n        type: 'bool',\n      },\n    ],\n    name: 'transactThroughSigned',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Multilocation',\n        name: 'dest',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Multilocation',\n        name: 'feeLocation',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'transactRequiredWeightAtMost',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'call',\n        type: 'bytes',\n      },\n      {\n        internalType: 'uint256',\n        name: 'feeAmount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'refTime',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'proofSize',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct XcmTransactorV3.Weight',\n        name: 'overallWeight',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bool',\n        name: 'refund',\n        type: 'bool',\n      },\n    ],\n    name: 'transactThroughSignedMultilocation',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> </li> <li> <p>Assemble the arguments for the <code>transactThroughSigned</code> function:</p> <ul> <li> <p><code>dest</code> - the multilocation of the destination, which is parachain 888:</p> <pre><code>const dest = [\n  1, // parents = 1\n  [  // interior = X1 (the array has a length of 1)\n    '0x0000000378', // Parachain selector + Parachain ID 888\n  ],\n];\n</code></pre> </li> <li> <p><code>feeLocationAddress</code> - the address of the XC-20 to use for fees, which is parachain 888's native asset:</p> <pre><code>const feeLocationAddress = '0xFFFFFFFF1AB2B146C526D4154905FF12E6E57675';\n</code></pre> </li> <li> <p><code>transactRequiredWeightAtMost</code> - the weight required to execute the call in the <code>Transact</code> instruction. You can get this information by using the <code>paymentInfo</code> method of the Polkadot.js API on the call</p> <pre><code>const transactRequiredWeightAtMost = [1000000000n, 5000n];\n</code></pre> </li> <li> <p><code>call</code> - the encoded call data of the pallet, method, and input to be called. It can be constructed in Polkadot.js Apps (which must be connected to the destination chain) or using the Polkadot.js API. For this example, the inner call is a simple balance transfer of 1 token of the destination chain to Alice's account there:</p> <pre><code>const call =\n  '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\n</code></pre> </li> <li> <p><code>feeAmount</code> - the amount to use for fees</p> <pre><code>const feeAmount = 50000000000000000n;\n</code></pre> </li> <li> <p><code>overallWeight</code> - the weight specific to the inner call (<code>transactRequiredWeightAtMost</code>) plus the weight needed to cover the execution costs for the XCM instructions in the destination chain: <code>DescendOrigin</code>, <code>WithdrawAsset</code>, <code>BuyExecution</code>, and <code>Transact</code>. It's important to note that each chain defines its own weight requirements. To determine the weight required for each XCM instruction on a given chain, please refer to the chain's documentation or reach out to a member of their team. Alternatively, you can pass in the maximum value for a uint64 for the <code>refTime</code> (the first index of the array). This will be interpreted as using an unlimited amount of weight, which removes the need to know exactly how much weight the destination chain requires to execute the XCM</p> <pre><code>const overallWeight = [18446744073709551615n, 10000n];\n</code></pre> </li> </ul> </li> <li> <p>Create the <code>transactThroughSigned</code> function, passing in the arguments</p> </li> <li>Sign and send the transaction</li> </ol> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\n\nconst abi = INSERT_ABI;\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n// Create contract instance\nconst xcmTransactorV3 = new ethers.Contract(\n  '0x0000000000000000000000000000000000000817',\n  abi,\n  signer\n);\n\n// Arguments for the transactThroughSigned function\nconst dest = [\n  1, // parents = 1\n  [\n    // interior = X1 (the array has a length of 1)\n    '0x0000000378', // Parachain selector + Parachain ID 888\n  ],\n];\nconst feeLocationAddress = '0xFFFFFFFF1AB2B146C526D4154905FF12E6E57675';\nconst transactRequiredWeightAtMost = [1000000000n, 5000n];\nconst call = '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\nconst feeAmount = 50000000000000000n;\nconst overallWeight = [2000000000n, 10000n];\nconst refund = true;\n\n// Sends 1 token to Alice's account on parachain 888\nasync function transactThroughSigned() {\n  // Creates, signs, and sends the transfer transaction\n  const transaction = await xcmTransactorV3.transactThroughSigned(\n    dest,\n    feeLocationAddress,\n    transactRequiredWeightAtMost,\n    call,\n    feeAmount,\n    overallWeight,\n    refund\n  );\n\n  // Waits for the transaction to be included in a block\n  await transaction.wait();\n  console.log(transaction);\n}\n\ntransactThroughSigned();\n</code></pre> <pre><code>import Web3 from 'web3'; // Import Web3 library\n\nconst abi = INSERT_ABI;\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Web3 provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n// Create contract instance\nconst xcmTransactorV3 = new web3.eth.Contract(\n  abi,\n  '0x0000000000000000000000000000000000000817',\n  { from: web3.eth.accounts.privateKeyToAccount(privateKey).address } // 'from' is necessary for gas estimation\n);\n\n// Arguments for the transactThroughSigned function\nconst dest = [\n  1, // parents = 1\n  [\n    // interior = X1 (the array has a length of 1)\n    '0x0000000378', // Parachain selector + Parachain ID 888\n  ],\n];\nconst feeLocationAddress = '0xFFFFFFFF1AB2B146C526D4154905FF12E6E57675';\nconst transactRequiredWeightAtMost = [1000000000n, 5000n];\nconst call = '0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d';\nconst feeAmount = 50000000000000000n;\nconst overallWeight = [2000000000n, 10000n];\nconst refund = true;\n\n// Sends 1 token to Alice's account on parachain 888\nasync function transactThroughSigned() {\n  // Create transaction\n  const transferTx = xcmTransactorV3.methods.transactThroughSigned(\n    dest,\n    feeLocationAddress,\n    transactRequiredWeightAtMost,\n    call,\n    feeAmount,\n    overallWeight,\n    refund\n  );\n\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: '0x000000000000000000000000000000000000080d',\n      data: transferTx.encodeABI(),\n      gas: await transferTx.estimateGas(),\n    },\n    privateKey\n  );\n\n  // Send signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(sendTx);\n}\n\ntransactThroughSigned();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_ABI\"  # Paste or import the XCM Transactor V3 ABI\nprivate_key = \"INSERT_PRIVATE_KEY\"  # This is for demo purposes, never store your private key in plain text\naddress = \"INSERT_ADDRESS\"  # The wallet address that corresponds to your private key\n\n# Create Web3 provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create contract instance\nxcm_transactor_v3 = web3.eth.contract(\n    address=\"0x0000000000000000000000000000000000000817\", abi=abi\n)\n\n# Arguments for the transactThroughSigned function\ndest = [\n    1,  # parents = 1\n    [\n        # interior = X1 (the array has a length of 1)\n        \"0x0000000378\",  # Parachain selector + Parachain ID 888\n    ],\n]\nfeeLocationAddress = \"0xFFFFFFFF1AB2B146C526D4154905FF12E6E57675\"\ntransactRequiredWeightAtMost = [1000000000, 5000]\ncall = \"0x030044236223ab4291b93eed10e4b511b37a398dee5513000064a7b3b6e00d\"\nfeeAmount = 50000000000000000\noverallWeight = [2000000000, 10000]\nrefund = True\n\n\n# Sends 1 xcUNIT to the relay chain using the transferMultiasset function\ndef transact_through_signed():\n    # Create transaction\n    transferTx = xcm_transactor_v3.functions.transactThroughSigned(\n        dest,\n        feeLocationAddress,\n        transactRequiredWeightAtMost,\n        call,\n        feeAmount,\n        overallWeight,\n        refund,\n    ).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n\n    # Sign transaction\n    signedTx = web3.eth.account.sign_transaction(transferTx, private_key)\n\n    # Send tx and wait for receipt\n    hash = web3.eth.send_raw_transaction(signedTx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Tx successful with hash: { receipt.transactionHash.hex() }\")\n\n\ntransact_through_signed()\n</code></pre>"},{"location":"builders/interoperability/xcm/remote-execution/substrate-calls/xcm-transactor-precompile/#transact-through-computed-origin-fees","title":"XCM Transact through Computed Origin Fees","text":"<p>When transacting through the Computed Origin account, the transaction fees are paid by the same account from which the call is dispatched, which is a Computed Origin account in the destination chain. Consequently, the Computed Origin account must hold the necessary funds to pay for the entire execution. Note that the destination token, for which fees are paid, does not need to be registered as an XC-20 in the origin chain.</p> <p>To estimate the amount of token Alice's Computed Origin account will need to have to execute the remote call, you need to check the transact information specific to the destination chain. You can use the following script to get the transact information for parachain 888:</p> <pre><code>import { ethers } from 'ethers'; // Import Ethers library\n\nconst abi = INSERT_ABI;\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers wallet &amp; contract instance\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\nconst xcmTransactorV3 = new ethers.Contract(\n  '0x0000000000000000000000000000000000000817',\n  abi,\n  signer\n);\n\n// Multilocation for parachain 888\nconst multilocation = [\n  1, // parents = 1\n  [  // interior = X1 (the array has a length of 1)\n    '0x0000000378', // Parachain selector + Parachain ID 888\n  ],\n];\n\nconst main = async () =&gt; {\n  const transactInfoWithSigned = await xcmTransactorV3.transactInfoWithSigned(\n    multilocation\n  );\n  console.log(transactInfoWithSigned);\n};\n\nmain();\n</code></pre> <p>The response shows that the <code>transactExtraWeightSigned</code> is <code>400,000,000</code>. This weight is needed to execute the four XCM instructions for this remote call in that specific destination chain. Next, you need to find out how much the destination chain charges per weight of XCM execution in reference to the asset's price. Previously, this was done by sourcing a units per second value. However, this method has been replaced by calculating a relative price. Relative price refers to how many units of the foreign asset correspond to one unit of the native token (GLMR or MOVR) from a value (i.e., price) perspective. For example, if the foreign asset is worth $5 and GLMR is worth $0.25, the relative price would be 0.05. However, we must scale the result to 18 decimals to correspond to the Wei units used. In this case, the relative price would be <code>50000000000000000</code>.</p> <p>You can calculate the relative price with a script in the XCM Tools repo. The script is also reproduced below: </p> Calculate Relative Price <pre><code>import axios from 'axios';\nimport chalk from 'chalk';\n\n// CoinGecko IDs for the networks\nconst NETWORK_IDS = {\n  GLMR: 'moonbeam',\n  MOVR: 'moonriver',\n};\n\nasync function calculateRelativePrice(\n  assetPrice: number,\n  network: 'GLMR' | 'MOVR'\n): Promise&lt;string&gt; {\n  try {\n    // Fetch the native token price from CoinGecko\n    const response = await axios.get(\n      `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[network]}&amp;vs_currencies=usd`\n    );\n\n    const nativeTokenPrice = response.data[NETWORK_IDS[network]].usd;\n\n    // Calculate relative price with 18 decimal places\n    // Formula: (nativeTokenPrice / assetPrice) * 10^18\n    // This gives us how many units of the asset we need to equal 1 unit of native token\n    const relativePrice = (nativeTokenPrice / assetPrice) * Math.pow(10, 18);\n\n    // Return as string to preserve precision\n    return relativePrice.toFixed(0);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Failed to calculate relative price: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\nfunction validateInput(\n  price: string,\n  network: string\n): { assetPrice: number; network: 'GLMR' | 'MOVR' } {\n  // Validate price\n  const assetPrice = parseFloat(price);\n  if (isNaN(assetPrice) || assetPrice &lt;= 0) {\n    throw new Error('Price must be a positive number');\n  }\n\n  // Validate network\n  const upperNetwork = network.toUpperCase() as 'GLMR' | 'MOVR';\n  if (!['GLMR', 'MOVR'].includes(upperNetwork)) {\n    throw new Error('Network must be either GLMR or MOVR');\n  }\n\n  return { assetPrice, network: upperNetwork };\n}\n\nfunction printUsage() {\n  console.log('\\nUsage:');\n  console.log('npx ts-node relative-price-calculator.ts &lt;price&gt; &lt;network&gt;');\n  console.log('\\nExample:');\n  console.log('npx ts-node relative-price-calculator.ts 0.25 GLMR');\n  console.log('\\nParameters:');\n  console.log('price   - The price of your asset in USD');\n  console.log('network - Either GLMR or MOVR');\n}\n\nasync function main() {\n  try {\n    // Get command line arguments\n    const [, , price, network] = process.argv;\n\n    // Check if help flag is passed\n    if (price === '--help' || price === '-h') {\n      printUsage();\n      return;\n    }\n\n    // Check if required arguments are provided\n    if (!price || !network) {\n      console.error('Error: Missing required arguments');\n      printUsage();\n      process.exit(1);\n    }\n\n    // Validate inputs\n    const { assetPrice, network: validNetwork } = validateInput(price, network);\n\n    console.log(\n      `\\nCalculating relative price for asset worth $${assetPrice} against ${validNetwork}...`\n    );\n    const relativePrice = await calculateRelativePrice(\n      assetPrice,\n      validNetwork\n    );\n    const nativeTokenPrice = (\n      await axios.get(\n        `https://api.coingecko.com/api/v3/simple/price?ids=${NETWORK_IDS[validNetwork]}&amp;vs_currencies=usd`\n      )\n    ).data[NETWORK_IDS[validNetwork]].usd;\n\n    const decimalRatio = nativeTokenPrice / assetPrice;\n\n    console.log(`\\nResults:`);\n    console.log(`Asset Price: $${assetPrice}`);\n    console.log(`Network: ${validNetwork}`);\n    console.log(`Native Token Price (from CoinGecko): $${nativeTokenPrice}`);\n    console.log(`\\nRelative Price Analysis:`);\n    console.log(\n      `1 ${validNetwork} is equal to approximately ${decimalRatio.toFixed(\n        3\n      )} of your specified token.`\n    );\n    console.log(\n      `With 18 decimals, 1 ${validNetwork} or in WEI, 1000000000000000000 is equal to a relative price of ${relativePrice} units of your token`\n    );\n    console.log(chalk.bold(`\\nRelative Price: ${relativePrice}`));\n    console.log(\n      `\\nThe relative price you should specify in asset registration steps is ${relativePrice}\\n`\n    );\n  } catch (error) {\n    console.error('\\nError:', error instanceof Error ? error.message : error);\n    process.exit(1);\n  }\n}\n\nmain();\n</code></pre> <p>Note that the relative price value is related to the cost estimated in the relay chain XCM fee calculation section or to the one shown in the units per weight section if the target is another parachain. You'll need to find the correct value to ensure that the amount of tokens the Computed Origin account holds is correct. Calculating the associated XCM execution fee is as simple as multiplying the <code>transactExtraWeightSigned</code> times the <code>relativePrice</code> (for an estimation):</p> <pre><code>XCM-Wei-Token-Cost = transactExtraWeightSigned * relativePrice\nXCM-Token-Cost = XCM-Wei-Token-Cost / DecimalConversion\n</code></pre> <p>Therefore, the actual calculation for one XCM Transactor transact through derivative call is:</p> <pre><code>XCM-Wei-Token-Cost = 400000000 * 50000000000000000\nXCM-Token-Cost = 20000000000000 / 10^18\n</code></pre> <p>The cost of transacting through a Computed Origin is <code>0.00002 TOKEN</code>. Note that this does not include the cost of the call being remotely executed, only XCM execution fees.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/","title":"How to Register Cross-Chain Assets via Governance","text":""},{"location":"builders/interoperability/xcm/xc-registration/assets/#introduction","title":"Introduction","text":"<p>For an asset to be transferred across chains via XCM, there needs to be an open channel between the two chains, and the asset needs to be registered on the destination chain. If a channel does not exist between the two chains, one will need to be opened. Please check out the XC Channel Registration guide for information on how to establish a channel between Moonbeam and another chain.</p> <p>This guide will show you how to register external XC-20s on Moonbeam and provide the information you need to register Moonbeam assets, including Moonbeam native assets (GLMR, MOVR, and DEV) and local XC-20s (XCM-enabled ERC-20s), on another chain.</p> <p>The examples in this guide use a CLI tool developed to ease the entire process, which you can find in the xcm-tools GitHub repository.</p> <pre><code>git clone https://github.com/Moonsong-Labs/xcm-tools &amp;&amp; \\\ncd xcm-tools &amp;&amp; \\\nyarn\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#register-xc-20s","title":"Register External XC-20s on Moonbeam","text":"<p>Registering External XC-20s on Moonbeam is a multi-step process that, at a high level, involves proposing the asset registration on the Moonbeam Community Forum and creating an on-chain governance proposal.</p> <p>If a channel between Moonbeam and the origin chain of the asset does not yet exist, one will need to be opened. You can batch the channel-related calls with the asset registration calls, so you only need to submit a single proposal. You must start by creating a couple of forum posts: an XCM Disclosure post and an XCM Proposal post.</p> <p>After you've collected feedback from community members, you can create a proposal to open a channel and register any assets. Please refer to the Establishing an XC Integration with Moonbeam guide for more information on opening a channel.</p> <p></p> <p>If a channel between the chains already exists, you'll need to create a forum post to register the asset, collect feedback, and then submit the proposal to register the asset.</p> <p></p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#create-a-forum-post","title":"Create a Forum Post","text":"<p>To create a forum post on the Moonbeam Community Forum, you'll need to make sure that you're adding the post to the correct category and adding relevant content. For general guidelines and a template to follow, please refer to the Moonbeam Community Forum Templates for XCM Integrations page.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#calculate-relative-price","title":"Calculate Relative Price","text":"<p>An asset's <code>relativePrice</code> refers to a <code>u128</code> value that indicates how many units of said asset (in its smallest denomination) equate to one unit\u2014i.e., <code>1 \u00d7 10^18 Wei</code>\u2014of the native token (GLMR or MOVR). This helps determine how much of your asset to use for fees initially quoted in the native token, particularly in cross-chain messaging (XCM).</p> <p>You can use the following script (also available as part of xcm-tools ) to calculate the correct <code>relativePrice</code> value for your asset.</p> Calculate Relative Price <pre><code>\n</code></pre> <p>Only three parameters are required to calculate the relative price of an asset: </p> <ul> <li>Asset Price (USD) - a positive number representing how much 1 unit (in human-readable form) of your asset costs in USD</li> <li>Asset Decimals - the number of decimal places your asset uses. For example, if your token has 12 decimals, specify 12</li> <li>Network - either GLMR (Moonbeam) or MOVR (Moonriver). This should correspond to the network that you're registering the asset on, and this determines which native token\u2019s USD price the script will fetch from CoinGecko</li> </ul> <p>First, ensure that you've installed the required dependencies by running:</p> <pre><code>yarn\n</code></pre> <p>Execute the script, making sure to provide the USD price of the asset you're registering, the number of decimals it has, and the network you're registering the asset on (either GLMR or MOVR):</p> <pre><code>yarn calculate-relative-price INSERT_ASSET_PRICE INSERT_DECIMALS GLMR\n</code></pre> <p>For example, if the asset you're registering has a USD price of $0.25 and 12 decimals and you're registering the asset on the Moonbeam network, you would run: </p> <pre><code>yarn calculate-relative-price 0.25 12 GLMR\n</code></pre> <p>This instructs the script to calculate how many smallest units of an asset (priced at $0.25, with 12 decimals) correspond to 1 GLMR token.</p> <p>Upon successful execution, the script prints the computed <code>relativePrice</code> as a <code>BigInt</code>. This value represents the scaled ratio between the asset\u2019s USD price and the native token\u2019s USD price, multiplied up to 18 decimals. You can then use this result in on-chain asset registration or fee calculation scenarios\u2014especially where a <code>u128</code> 18-decimal format is required.</p> <p>For additional info, usage details, or to see an example in action, you can invoke the help command by running: </p> <pre><code>yarn calculate-relative-price --help\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#generate-encoded-calldata-for-asset-registration","title":"Generate the Encoded Calldata for the Asset Registration","text":"<p>Submitting a governance proposal on Moonbeam requires two steps: first, submit a preimage that defines the actions to be executed, then use that preimage to submit the proposal. For more details, see the Governance on Moonbeam page. To submit a preimage for asset registration, you'll need the encoded calldata for both the <code>evmForeignAssets.createForeignAsset</code> and <code>xcmWeightTrader.addAsset</code> extrinsics. An existing asset's price can be updated with <code>xcmWeightTrader.editAsset</code>. </p> <p>Proposals must be submitted via the Fast General Admin track. A channel must be established before an asset can be registered. To get the encoded calldata for the <code>evmForeignAssets.createForeignAsset</code> extrinsic, you will need to provide the following arguments:</p> <ul> <li><code>assetId</code> - unique identifier of the asset, generated from the <code>calculate-external-asset-info.ts</code> script</li> <li><code>xcmLocation</code> - the multilocation of the asset relative to Moonbeam </li> <li><code>decimals</code> - the number of decimals of the asset</li> <li><code>symbol</code>  - the symbol of the asset. Remember that \"xc\" should be prepended to the symbol to indicate the asset is an XCM-enabled asset</li> <li><code>name</code> - the asset name</li> </ul> <p>Using the above information, you can generate the encoded call data for the <code>createForeignAsset</code> call either via the Polkadot API or on Polkadot.js Apps.</p> <p>You can generate this required calldata using the xcm-asset-registrator script as follows:</p> <pre><code>yarn register-asset --w wss://wss.api.moonbeam.network  \\\n--asset \"INSERT_MULTILOCATION\" \\\n--symbol \"INSERT_ASSET_SYMBOL\" \\\n--decimals INSERT_DECIMALS \\\n--name \"INSERT_ASSET_NAME\" \\\n--relative-price INSERT_RELATIVE_PRICE\n</code></pre> <p>Upon running the script with the relevant parameters, you'll see output like the following: </p> <p>The script will provide the encoded call data for each of the following calls:</p> <ul> <li>The <code>registerAsset</code> call</li> <li>The <code>setRelativePrice</code> call</li> <li>The <code>batch</code> call that combines all of the above</li> </ul> <p></p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#construct-the-add-asset-call","title":"Construct the Add Asset Call","text":"<p>If you've already used the xcm-asset-registrator script shown above, you can skip this section. This section dives into more detail about how the <code>xcmWeightTrader.addAsset</code> call is constructed. To get the encoded calldata for the <code>xcmWeightTrader.addAsset</code> extrinsic, you will need to provide the following arguments:</p> <ul> <li><code>xcmLocation</code> - the multilocation of the asset relative to Moonbeam </li> <li><code>relativePrice</code> - A numeric value (u128) representing the fraction of the native token\u2019s price that your asset\u2019s price constitutes, scaled to 18 decimals. This value calculates cross-chain fees by determining how many units of the non-native asset are required to cover XCM operation costs </li> </ul> <p>Using the above information, you can generate the encoded call data for the <code>addAsset</code> call either via the Polkadot API or on Polkadot.js Apps.</p> <p>To create a batch transaction that combines both the <code>xcmWeightTrader.addAsset</code> and the <code>evmForeignAssets.createForeignAsset</code> calls together, you can use the Polkadot API's <code>batch</code> method. As mentioned previously, the XCM asset registrator script can help you build and submit the required calls. </p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#submit-preimage-proposal","title":"Submit the Preimage and Proposal for Asset Registration","text":"<p>Your next task is to submit the preimage of your batched call containing both the <code>xcmWeightTrader.addAsset</code> and the <code>evmForeignAssets.createForeignAsset</code> by following the guidelines in the Submit a Democracy Proposal Guide.</p> <p>You do not need to go through governance for Moonbase Alpha, as Moonbase Alpha has sudo access. Instead, you can provide the output of the batch call data to the Moonbeam team, and they can submit the call with sudo. This will be a faster and easier process than going through governance. However, you may still wish to go through governance on Moonbase Alpha to prepare for Moonbeam's governance process.</p> <p>After submitting the preimage, you can submit the proposal by following the guidelines in the Submitting a Proposal section.</p> <p>If you prefer the script method and you're comfortable working with the scripts in the XCM tools repo, you can use the generic call proposer by passing in the requisite calls, including the acceptance and proposal of the XCM Channel, and the asset registration. The generic call proposer can help you assemble the multiple requisite calls as follows:</p> <pre><code>yarn generic-call-propose \\\n  --call INSERT_CALLDATA_INCOMING_XCM_CHANNEL \\\n  --call INSERT_CALLDATA_OUTGOING_XCM_CHANNEL \\\n  --call INSERT_CALLDATA_BATCH_ASSET_REGISTRATION \\\n  --ws-provider INSERT_WSS_PROVIDER\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#test-asset-registration","title":"Test the Asset Registration on Moonbeam","text":"<p>After your asset is registered, the team will provide the asset ID and the XC-20 precompile address. Your XC-20 precompile address is calculated by converting the asset ID decimal number to hex and prepending it with F's until you get a 40-hex character (plus the \u201c0x\u201d) address. For more information on how it is calculated, please refer to the Calculate External XC-20 Precompile Addresses section of the External XC-20 guide. After the asset is successfully registered, you can transfer tokens from your parachain to the Moonbeam-based network you are integrating with.</p> <p>Note</p> <p>Remember that Moonbeam-based networks use AccountKey20 (Ethereum-style addresses).</p> <p>For testing, please also provide your parachain WSS endpoint so that the Moonbeam dApp can connect to it. Lastly, please fund the corresponding account:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>AccountId: 5E6kHM4zFdH5KEJE3YEzX5QuqoETVKUQadeY8LVmeh2HyHGt\nHex:       0x5a071f642798f89d68b050384132eea7b65db483b00dbb05548d3ce472cfef48\n</code></pre> <pre><code>AccountId: 5E6kHM4zFdH5KEJE3YEzX5QuqoETVKUQadeY8LVmeh2HyHGt\nHex:       0x5a071f642798f89d68b050384132eea7b65db483b00dbb05548d3ce472cfef48\n</code></pre> <pre><code>AccountId: 5GWpSdqkkKGZmdKQ9nkSF7TmHp6JWt28BMGQNuG4MXtSvq3e\nHex:       0xc4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a063\n</code></pre> <p>Note</p> <p>For Moonbeam and Moonriver testing, please send $50 worth of tokens to the aforementioned account. In addition, provide an Ethereum-style account to send $50 worth of GLMR/MOVR for testing purposes.</p> <p>XC-20s are Substrate-based assets with an ERC-20 interface. This means they can be added to MetaMask and composed with any EVM DApp that exists in the ecosystem. The team can connect you with any DApp you find relevant for an XC-20 integration.</p> <p>If you need DEV tokens (the native token for Moonbase Alpha) to use your XC-20 asset, you can get some from the Moonbase Alpha Faucet, which dispenses 1.1 DEV tokens every 24 hours. If you need more, feel free to reach out to the team on Telegram or Discord.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#set-bytecode","title":"Set XC-20 Precompile Bytecode","text":"<p>Once your XC-20 has been registered on Moonbeam, you can set the XC-20's precompile bytecode. This is necessary because precompiles are implemented inside the Moonbeam runtime and, by default, do not have bytecode. In Solidity, when a contract is called, there are checks that require the contract bytecode to be non-empty. So, setting the bytecode as a placeholder bypasses these checks and allows the precompile to be called.</p> <p>You can use the Precompile Registry, which is a Solidity interface, to update the XC-20 precompile's bytecode to avoid any issues and ensure that the precompile is callable from Solidity. To do so, you'll use the Precompile Registry's <code>updateAccountCode</code> function.</p> <p>To get started, you'll need to calculate your XC-20's precompile address and have the Precompile Registry's ABI.</p> Precompile Registry ABI <pre><code>[\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isActivePrecompile\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isPrecompile\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"updateAccountCode\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    }\n]\n</code></pre> <p>Then, you can use the following scripts to set the dummy code for your XC-20's precompile.</p> <p>Remember</p> <p>The following snippets are for demo purposes only. Never store your private keys in a JavaScript or Python file.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>After running the script to set the bytecode, you should see <code>The XC-20 precompile's bytecode is: 0x60006000fd</code> printed to your terminal.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#register-moonbeam-assets-on-another-chain","title":"Register Moonbeam Assets on Another Chain","text":"<p>To enable cross-chain transfers of Moonbeam assets, including Moonbeam native assets (GLMR, MOVR, DEV) and local XC-20s (XCM-enabled ERC-20s) deployed on Moonbeam, between Moonbeam and another chain, you'll need to register the assets on the other chain. Since each chain stores cross-chain assets differently, the exact steps to register Moonbeam assets on another chain will vary depending on the chain. At the very least, you'll need to know the metadata and the multilocation of the assets on Moonbeam.</p> <p>There are additional steps aside from asset registration that will need to be taken to enable cross-chain integration with Moonbeam. For more information, please refer to the Establishing an XC Integration with Moonbeam guide.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#register-moonbeam-native-assets","title":"Register Moonbeam Native Assets on Another Chain","text":"<p>The metadata for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Name Glimmer Symbol GLMR Decimals 18 Existential deposit 1 (1 * 10^-18 GLMR) Variable Value Name Moonriver Symbol MOVR Decimals 18 Existential deposit 1 (1 * 10^-18 MOVR) Variable Value Name DEV Symbol DEV Decimals 18 Existential deposit 1 (1 * 10^-18 DEV) <p>The multilocation of Moonbeam native assets includes the parachain ID of the Moonbeam network and the pallet instance where Moonbeam assets live, which corresponds to the index of the Balances Pallet. The multilocation for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { \n          Parachain: 2004\n        },\n        {\n          PalletInstance: 10\n        }\n      ]\n    }\n  }\n}\n</code></pre> <pre><code>{\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { \n          Parachain: 2023\n        },\n        {\n          PalletInstance: 10\n        }\n      ]\n    }\n  }\n}\n</code></pre> <pre><code>{\n  V4: {\n    parents: 1,\n    interior: {\n      X2: [\n        { \n          Parachain: 1000\n        },\n        {\n          PalletInstance: 3\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#register-local-xc20","title":"Register Local XC-20s on Another Chain","text":"<p>The multilocation for local XC-20s include the parachain ID of Moonbeam, the pallet instance, and the address of the ERC-20. The pallet instance corresponds to the index of the ERC-20 XCM Bridge Pallet, as this is the pallet that enables any ERC-20 to be transferred via XCM.</p> <p>To be registered on other chains, local XC-20s must strictly comply with the standard ERC-20 interface as described in EIP-20. In particular, the <code>transfer</code> function must be as described in EIP-20:</p> <pre><code>function transfer(address _to, uint256 _value) public returns (bool success)\n</code></pre> <p>If the function selector of the <code>transfer</code> function deviates from the standard, the cross-chain transfer will fail.</p> <p>You can use the following multilocation to register a local XC-20:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>{\n  parents: 1,\n  interior: {\n    X3: [\n      { \n        Parachain: 2004\n      },\n      {\n        PalletInstance: 110\n      },\n      {\n        AccountKey20: {\n          key: 'INSERT_ERC20_ADDRESS'\n        }\n      }\n    ]\n  }\n}\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X3: [\n      { \n        Parachain: 2023\n      },\n      {\n        PalletInstance: 110\n      },\n      {\n        AccountKey20: {\n          key: 'INSERT_ERC20_ADDRESS'\n        }\n      }\n    ]\n  }\n}\n</code></pre> <pre><code>{\n  parents: 1,\n  interior: {\n    X3: [\n      { \n        Parachain: 1000\n      },\n      {\n        PalletInstance: 48\n      },\n      {\n        AccountKey20: {\n          key: 'INSERT_ERC20_ADDRESS'\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>Since local XC-20s are ERC-20s on Moonbeam, there are no deposits required to create an ERC-20 on Moonbeam. However, deposits may be required to register the asset on another parachain. Please consult with the parachain team you wish to register the asset with for more information.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#managing-xc-assets","title":"Managing XC Assets","text":"<p>After completing the registration process for an XC asset, you may need to periodically update asset details, such as the XCM multilocation details or asset price. This section will cover these topics.</p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#updating-foreign-asset-xcm-location","title":"Updating Foreign Asset XCM Location","text":"<p>You can update the multilocation of an asset with the <code>evmForeignAssets.changeXcmLocation</code> call, which takes as parameters the <code>assetId</code> and the new multilocation. You'll need to raise a governance proposal and submit the update under the General Admin track. If you're testing in Moonbase Alpha, you can ask the Moonbeam Team to submit the extrinsic using Sudo to speed up the process. You can also submit the requisite governance proposal on Moonbase Alpha. </p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#freezing-a--foreign-asset","title":"Freezing a Foreign Asset","text":"<p>You can freeze a foreign asset by calling <code>evmForeignAssets.freezeForeignAsset</code>, which takes as parameters the <code>assetId</code> and an <code>allowXcmDeposit</code> boolean. If set to true, XCM deposits from remote chains will still be allowed and mint tokens. If set to false, XCM deposits from remote chains will fail as no minting will be permitted. </p>"},{"location":"builders/interoperability/xcm/xc-registration/assets/#paying-xcm-fees-with-foreign-assets","title":"Paying XCM Fees with Foreign Assets","text":"<p>After you've registered the foreign asset via the <code>evmForeignAssets</code> and the <code>xcmWeightTrader</code> pallet, your asset will now be among the supported assets for paying XCM fees. To verify, you can query the <code>xcmWeightTrader</code> pallet and the <code>supportedAssets</code> chain state query. Toggle the Include Option slider off to see the complete list, or you can filter the list by the multilocation of your asset. </p>"},{"location":"builders/interoperability/xcm/xc-registration/forum-templates/","title":"Moonbeam Community Forum Templates for XCM Integrations","text":""},{"location":"builders/interoperability/xcm/xc-registration/forum-templates/#introduction","title":"Introduction","text":"<p>When starting an XCM integration on Moonriver or Moonbeam MainNet, there are two preliminary posts that must be made on the Moonbeam Community Forum so that the voting community has the chance to provide feedback. The two preliminary posts are an XCM disclosure and an XCM proposal. This step is not necessary when connecting to Moonbase Alpha.</p> <p>If only an asset is being registered, the cross-chain channel must already be established, and so only an XCM proposal post is required to register the asset.</p> <p>It is recommended that this be done five days before the actual proposal is submitted on chain to provide time for community feedback.</p>"},{"location":"builders/interoperability/xcm/xc-registration/forum-templates/#xcm-disclosure","title":"XCM Disclosures","text":"<p>The first post that should be made are the key disclosures within the XCM Disclosures category, which highlight key information that is important to a voter's decision. This post is only required when establishing an XCM integration; it is not necessary if the integration already exists and you only need to register an asset.</p> <p>Once you hit the New Topic button, a template is provided with the relevant information to be filled in. Please use either the Moonbeam/Moonriver tag, depending on the network you are integrating with.</p> <p>In the post, please provide the following information:</p> <ul> <li>Title - XCM Disclosure: YOUR_NETWORK_NAME</li> <li>Network Information \u2014 one sentence summarizing your network and relevant links to your website, Twitter, and other social channels</li> </ul> <p>You'll also need to provide answers to the following questions:</p> <ul> <li>Is the blockchain network's code open source? If so, please provide the GitHub link. If not, provide an explanation of why not</li> <li>Is SUDO disabled on the network? If SUDO is disabled, is the network controlled by a select group of addresses?  </li> <li>Has the integration of the network been tested completely on the Moonbase Alpha TestNet?  </li> <li>(For Moonbeam HRMP proposals only) Does your network have a Kusama deployment? If so, provide its network name and whether the Kusama deployment is integrated with Moonriver</li> <li>Is the blockchain network's code audited? If so, please provide:</li> <li>Auditor name(s)</li> <li>Dates of audit reports</li> <li>Links to audit reports</li> </ul>"},{"location":"builders/interoperability/xcm/xc-registration/forum-templates/#xcm-proposals","title":"XCM Proposals","text":"<p>The second post is a preliminary draft of the proposal in the XCM Proposals category. Once a proposal is submitted on-chain and available for voting, you must also add a description to it in either the Moonbeam Polkassembly or Moonriver Polkassembly.</p> <p>Once you hit the New Topic button, a template is provided with the relevant information to be filled in. Please use either the Moonbeam or Moonriver tag, depending on the network you are integrating with.</p> <p>In both the Moonbeam XCM Proposals forum post and in Polkassembly, add the following sections and information:</p> <ul> <li>Title \u2014 YOUR_NETWORK_NAME Proposal to Open Channel &amp; Register ASSET_NAME. If you're only registering an asset, you can use: YOUR_NETWORK_NAME Proposal to Register ASSET_NAME</li> <li>Introduction \u2014 one sentence summarizing the proposal</li> <li>Network Information \u2014 one sentence summarizing your network and relevant links to your website, Twitter, and other social channels</li> <li>Summary \u2014 brief description of the content of the proposal</li> <li>On-Chain Proposal Reference \u2014 include if it is a Moonbeam or Moonriver proposal, the proposal number, and the proposal hash</li> <li>Technical Details \u2014 provide technical information required for the community to understand the use cases and purpose of the proposal</li> <li>Additional Information \u2014 any additional information you would like the community to know</li> </ul>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/","title":"Self-Serve Asset Registration for Sibling Parachains","text":""},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#introduction","title":"Introduction","text":"<p>Registering your parachain's native tokens on Moonbeam or Moonriver lets your community enjoy ERC\u201120\u2013style UX and deep EVM integrations while retaining full on\u2011chain provenance. This guide shows sibling Polkadot parachain teams how to self\u2011register a foreign asset using the new <code>ForeignAssetOwnerOrigin</code> introduced in Moonbeam Runtime 3600.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#why-a-new-origin","title":"Why a New Origin?","text":"<p>Moonbeam introduced a new dedicated origin called <code>ForeignAssetOwnerOrigin</code>, which only permits an XCM message whose origin contains the asset's multilocation to execute calls in the <code>evm\u2011foreign\u2011assets</code> pallet. In practice, that means only the sovereign account of the parachain that owns the asset, or Moonbeam governance, can create, freeze, unfreeze, or relocate it. Alongside this, a configurable runtime constant called <code>ForeignAssetCreationDeposit</code> is reserved from the caller's sovereign account at creation time. The deposit discourages spam registrations.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#required-deposits","title":"Required Deposits","text":"<p>To prevent spam, a <code>ForeignAssetCreationDeposit</code> is required and locked for the lifetime of the asset. The deposit is funded from the sibling parachain's sovereign account on the Moonbeam network, which thus needs to be sufficiently funded to cover the asset deposit and the associated transaction fees. If the asset is destroyed through governance, the deposit is unreserved and returned to the original sovereign account.</p> <p>Deposits are network\u2011specific and can be adjusted by Moonbeam governance via the <code>parameters</code> pallet:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Foreign Asset Deposit 10,000 GLMR Variable Value Foreign Asset Deposit 1,000 MOVR Variable Value Foreign Asset Deposit 100 DEV"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#prerequisites","title":"Prerequisites","text":"<p>There are a few prerequisites to be aware of: </p> <ul> <li>The sibling parachain's sovereign account on Moonbeam must be sufficiently funded to cover the asset deposit and the transaction fees. It's recommended that you have an extra buffer of additional funds for any subsequent transactions. See this guide to calculating a sovereign account</li> <li>Your parachain should support XCM V4</li> <li>Your parachain needs bidirectional XCM channels with Moonbeam. See this guide for information on opening XCM channels with Moonbeam </li> </ul>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#assemble-your-asset-details","title":"Assemble Your Asset Details","text":"<p>Before you register your sibling-parachain token on Moonbeam, you'll need to gather four pieces of information:</p> <ul> <li><code>AssetID</code>: A deterministic <code>u128</code> derived from the token's <code>multilocation</code> (see below).</li> <li><code>Decimals</code>: How many decimal places the token uses (for example, <code>18</code>).</li> <li><code>Symbol</code>: A short ticker such as <code>xcTEST</code>. The ticker should be prepended with <code>xc</code>.</li> <li><code>Name</code>: A human-readable name such as <code>Test Token</code>.</li> </ul> <pre><code>const ASSET_ID = 42259045809535163221576417993425387648n;\nconst DECIMALS = 18n;\nconst SYMBOL   = \"xcTEST\";\nconst NAME     = \"Test Token\";\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#calculate-asset-id","title":"How to Calculate Asset ID","text":"<p>To generate a token's asset ID, you'll first need to know its multilocation. <code>assetLocation</code> is a SCALE\u2011encoded multilocation that pinpoints the existing token on your sibling parachain. There are various ways to define assets and your multilocation may including parachain ID, the pallet that manages assets there, and the local asset index. Because the extrinsic executes on Moonbeam, you describe the path from Moonbeam's perspective: first hop up one level to the Relay <code>(\"parents\": 1)</code>, then down into your parachain <code>(Parachain: &lt;paraId&gt;)</code>, the pallet, and the asset index. Moonbeam uses this to verify that the caller actually \"contains\" the asset before allowing any registration or updates. </p> <p>Once you've constructed your multilocation, keep it handy, as you'll need it in the next step. A typical asset multilocation looks like this:</p> <pre><code>{\n  \"parents\": 1,          // Up to Relay\n  \"interior\": {\n    \"X3\": [              // Down to sibling para asset\n      { \"Parachain\": 4 },\n      { \"PalletInstance\": 12 },\n      { \"GeneralIndex\": 15 }  // Arbitrary example values\n    ]\n  }\n}\n</code></pre> <p>The XCM tools repo has a helpful Calculate External Asset Info script that you can use to generate the asset ID programmatically. The script takes two parameters, namely, the multilocation of your asset and the target network (Moonbeam or Moonriver). Call the <code>calculate-external-asset-info.ts</code> helper script with your asset's multilocation and target network, as shown below, to easily generate its asset ID.</p> <pre><code>ts-node scripts/calculate-external-asset-info.ts \\\n  --asset '{\"parents\":1,\"interior\":{\"X3\":[{\"Parachain\":4},{\"PalletInstance\":12},{\"GeneralIndex\":15}]}}' \\\n  --network moonbeam\n</code></pre> <p>The script will return the <code>assetID</code> you are now ready to pass to <code>evmForeignAssets.createForeignAsset</code>.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#derive-the-xc-20-address","title":"Derive the XC-20 Address","text":"<p>Convert <code>assetID</code> to hex, left-pad it to 32 hex chars, and prepend eight <code>F</code>s as follows:</p> <pre><code>xc20Address = 0xFFFFFFFF + hex(assetId).padStart(32, '0')\n</code></pre> <p>The XC-20 address of xcDOT as an example can be calculated like so: </p> FormulaExample <pre><code>const xc20Address = `0xFFFFFFFF${hex(assetId).padStart(32, \"0\")}`;\n</code></pre> <pre><code>0xFFFFFFFF1FCACBD218EDC0EBA20FC2308C778080\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#generate-the-encoded-call-data","title":"Generate the Encoded Call Data","text":"<p>The snippet below shows how to build the call that needs to be sent to Moonbeam that creates the foreign asset. Save the resulting hex string because you will embed it inside a subsequent XCM <code>Transact</code> call dispatched from your sibling parachain.</p> <pre><code>import '@moonbeam-network/api-augment';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\nimport { blake2AsHex } from '@polkadot/util-crypto';\n\nconst moonbeam = await ApiPromise.create({\n  provider: new WsProvider(MOONBEAM_WSS),\n});\n\nconst tx = moonbeam.tx.evmForeignAssets.createForeignAsset(\n  ASSET_ID,\n  assetLocation,\n  DECIMALS,\n  SYMBOL,\n  NAME\n);\n\n// SCALE-encoded call data (includes call index 0x3800)\nconst encodedCall = tx.method.toHex();\nconsole.log('Encoded call data:', encodedCall);\n\n// Optional: 32-byte call hash (blake2_256)\nconsole.log('Call hash:', blake2AsHex(encodedCall));\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#dispatch-the-call-with-xcm-transact","title":"Dispatch the Call with XCM Transact","text":"<p>To register your asset, wrap the SCALE\u2011encoded <code>createForeignAsset</code> bytes in a single <code>Transact</code> instruction executed from your parachain's sovereign account. The basic structure of the call is outlined below:</p> <pre><code>Transact {\n  originKind: SovereignAccount,\n  requireWeightAtMost: &lt;weight&gt;,\n  call: &lt;encodedCall&gt;\n}\n</code></pre> <p>Send the transact instruction via <code>xcmPallet.send</code>, targeting parachain <code>2004</code> for Moonbeam (or <code>2023</code> for Moonriver). </p> <pre><code>xcmPallet.send(\n  dest: { Parachain: 2004 },\n  message: VersionedXcm::V4(INSERT_TRANSACT_INSTRUCTION)\n);\n</code></pre> <p>Finally, look for the following event emitted successfully on Moonbeam:</p> <pre><code>EvmForeignAssets.ForeignAssetCreated(assetId, location, creator)\n</code></pre> <p>Its presence confirms the XC-20 asset is live.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#managing-an-existing-foreign-asset","title":"Managing an Existing Foreign Asset","text":"<p>After a foreign asset has been created, the following extrinsics can be used to update it. Note that in the case of the sovereign account sending a call, the sovereign account and location must still be inside the origin. Otherwise, the only other authorized origin is <code>Root</code> from a Moonbeam governance action. </p> Extrinsic Who can call? Notes <code>changeXcmLocation</code> Sibling sovereign account or Moonbeam governance Requires deposit already reserved. <code>freezeForeignAsset</code> / <code>unfreezeForeignAsset</code> Sibling sovereign account or Moonbeam governance <code>freeze</code> optionally destroys the asset's metadata."},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#faqs","title":"FAQs","text":""},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#how-do-i-reclaim-the-deposit","title":"How do I reclaim the deposit?","text":"<p>Deposits remain reserved for the life of the asset. If the asset is destroyed through governance, the deposit is unreserved and returned to the original sovereign account.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#can-a-normal-eoa-register-an-asset","title":"Can a normal EOA register an asset?","text":"<p>No. Calls from non\u2011sovereign, non\u2011governance accounts fail with <code>BadOrigin</code>.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#what-happens-if-my-xcm-location-is-outside-my-origin","title":"What happens if my XCM location is outside my origin?","text":"<p>The call is rejected with <code>LocationOutsideOfOrigin</code>. Double\u2011check the <code>Parachain</code>, <code>PalletInstance</code>, and <code>GeneralIndex</code> fields.</p>"},{"location":"builders/interoperability/xcm/xc-registration/self-serve-asset-registration/#is-there-a-limit-to-how-many-assets-can-be-created","title":"Is there a limit to how many assets can be created?","text":"<p>Yes, there is a limit of <code>256</code> foreign assets per network (e.g., Moonbeam, Moonriver). Attempts beyond this return <code>TooManyForeignAssets</code>. If this threshold is approached, a revision can be made in a future runtime upgrade to lift this limit.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/","title":"How to Establish an XC Integration with Moonbeam","text":""},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#introduction","title":"Introduction","text":"<p>While Cross-Chain Message Passing (XCMP) is being developed, a stop-gap protocol has been implemented called Horizontal Relay-routed Message Passing (HRMP). It has the same interface and functionality as XCMP, but the messages are stored in and read from the relay chain. Whereas with XCMP, only the message's associated metadata is stored in the relay chain. Since all messages are passed via the relay chain with HRMP, it is much more demanding on resources. As such, HRMP will be phased out once XCMP is implemented.</p> <p>All XCMP channel integrations with Moonbeam are unidirectional, meaning messages flow only in one direction. If chain A initiates a channel to chain B, chain A will only be allowed to send messages to B, and B will not be able to send messages back to chain A. As such, chain B will also need to initiate a channel with chain A to send messages back and forth between the two chains.</p> <p>Once the XCMP (or HRMP) channels have been opened, the corresponding assets from both chains will need to be registered on the opposing chain before being able to be transferred. To find step-by-step details on how to register an asset, you can refer to the How to Register Cross-Chain Assets guide.</p> <p>This guide will cover the process of opening and accepting an HRMP channel between a parachain and a Moonbeam-based network. In addition, the guide provides the necessary steps to create a batch proposal that combines opening and accepting a channel and registering an asset on Moonbeam into a single proposal.</p> <p>All of the examples in this guide use a CLI tool developed to ease the entire process, which you can find in the xcm-tools GitHub repository.</p> <pre><code>git clone https://github.com/Moonsong-Labs/xcm-tools &amp;&amp; \\\ncd xcm-tools &amp;&amp; \\\nyarn\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#moonbase-alpha-xcm","title":"Moonbase Alpha XCM Integration Overview","text":"<p>The first step for a Moonriver/Moonbeam XCM integration is to integrate with the Moonbase Alpha TestNet through the Alphanet relay chain. Then a Moonriver integration must be completed before proceeding with Moonbeam (if applicable).</p> <p>The entire process of getting started with Moonbase Alpha can be summarized as follows:</p> <ol> <li>Sync a node with the Alphanet relay chain</li> <li>Calculate your parachain Sovereign account on the Alphanet relay chain</li> <li>Once your node is fully synced, please get in touch with the Moonbeam team on Telegram or Discord, so the team can onboard your parachain to the relay chain. Provide the following information for onboarding:</li> <li>The WASM/Genesis head hash</li> <li>Your parachain ID</li> <li>Your Sovereign account's address. The Moonbeam team will fund your Sovereign account at the relay chain level. This step is required to be able to create the HRMP channel</li> <li>The encoded call data to open an HRMP channel to your parachain, accept the incoming HRMP channel, and register the assets (if applicable). This will be executed through sudo</li> <li>Open an HRMP channel to Moonbase Alpha from your parachain (through sudo or via governance)</li> <li>Accept the HRMP channel from Moonbase Alpha (through sudo or via governance)</li> <li>(Optional) Register Moonbase Alpha's DEV token on your parachain</li> <li>For testing the XCM integration, please send some tokens to:</li> </ol> <pre><code>AccountId (Encoded): 5GWpSdqkkKGZmdKQ9nkSF7TmHp6JWt28BMGQNuG4MXtSvq3e\nDecoded (32-Bytes):  0xc4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a063\n</code></pre> <ol> <li>Test the XCM integration</li> </ol> <p></p> <p>Once all of these steps are completed and both teams have successfully tested asset transfers, your parachain token can be added to the Cross Chain Assets section of the Moonbeam DApp. If deposits and withdrawals work as expected, integration with Moonriver can begin.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#sync-a-node","title":"Sync a Node","text":"<p>To sync a node, you can use the Alphanet relay chain specs (note: the relay chain is Westend-based, and will probably take one day to sync).</p> <p>For reference, you can use Moonbase Alpha's spec file. You'll need to adapt it to your chain.</p> <p>There are also some snapshots for the Alphanet ecosystem relay chain you can use to quickly get started, these are provided by the community.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#calculate-and-fund-the-parachain-sovereign-account","title":"Calculate and Fund the Parachain Sovereign Account","text":"<p>You can calculate the Sovereign account information using a script from the xcm-tools repository. To run the script, you must provide the parachain ID and the name of the associated relay chain.</p> <p>You can find the parachain IDs that have already been used on the relay chain's Polkadot.js Apps page.</p> <p>The accepted values for the relay chain are <code>polkadot</code> (default), <code>kusama</code>, and <code>moonbase</code>.</p> <p>For example, Moonbase Alpha's Sovereign account for both the relay chain and other parachains can be obtained with the following:</p> <pre><code>yarn calculate-sovereign-account --p 1000 --r moonbase\n</code></pre> <p>Which should result in the following response:</p> <pre><code>Sovereign Account Address on Relay: 0x70617261e8030000000000000000000000000000000000000000000000000000\nSovereign Account Address on other Parachains (Generic): 0x7369626ce8030000000000000000000000000000000000000000000000000000\nSovereign Account Address on Moonbase Alpha: 0x7369626ce8030000000000000000000000000000\n</code></pre>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#moonriver-moonbeam","title":"Moonriver &amp; Moonbeam XCM Integration Overview","text":"<p>From a technical perspective, the process of creating an HRMP channel with Moonriver and Moonbeam is nearly identical. However, engagement with the Moonbeam community is crucial and required before a proposal will pass.</p> <p>Please check the HRMP channel guidelines that the community voted on for Moonriver and Moonbeam before starting.</p> <p>The process can be summarized in the following steps:</p> <ol> <li>Open (or ensure there is) an HRMP channel from your chain to Moonriver/Moonbeam. Optionally, register MOVR/GLMR</li> <li>Create two Moonbeam Community forum posts with some key information for the XCM integration:</li> <li>An XCM Disclosure post, where you'll provide some disclosures about the project, the code base, and social network channels</li> <li>An XCM Proposal post, where you'll provide some technical information about the proposal itself</li> <li> <p>Create a batch proposal on Moonbeam/Moonriver to:</p> </li> <li> <p>Accept the incoming HRMP channel</p> </li> <li>Propose the opening of an outgoing HRMP channel from Moonriver/Moonbeam</li> <li>Register the asset as an XC-20 token (if applicable)</li> </ol> <p>Proposals should be done in the General Admin Track from OpenGov. The normal enactment times are as follows:</p> <ul> <li>Moonriver - the Decision Period is approximately 14 days and the enactment time is at least 1 day</li> <li> <p>Moonbeam - the Decision Period is approximately 14 days and the enactment time is at least 1 day</p> </li> <li> <p>Accept the HRMP channel from Moonriver/Moonbeam on the connecting parachain</p> </li> <li>Exchange $50 worth of tokens for testing the XCM integration. Please send the tokens to:</li> </ul> <pre><code>AccountId (Encoded): 5E6kHM4zFdH5KEJE3YEzX5QuqoETVKUQadeY8LVmeh2HyHGt\nDecoded (32-Bytes):  0x5a071f642798f89d68b050384132eea7b65db483b00dbb05548d3ce472cfef48\n</code></pre> <ol> <li>Provide an Ethereum-styled address for MOVR/GLMR</li> <li>Test the XCM integration with the provided tokens</li> </ol> <p>An example of this process with a successful proposal on Moonbeam is depicted in the following diagram.</p> <p></p> <p>Once these steps are successfully completed, marketing efforts can be coordinated, and the new XC-20 on Moonriver/Moonbeam can be added to the Cross Chain Assets section of the Moonbeam DApp.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#create-forum-posts","title":"Create Forum Posts","text":"<p>To create forum posts on the Moonbeam Community Forum, you'll need to make sure that you're adding the posts to the correct category and adding relevant content. For general guidelines and templates to follow, please refer to the Moonbeam Community Forum Templates for XCM Integrations page.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#create-an-hrmp-channel","title":"Creating HRMP Channels","text":"<p>Before any messages can be sent from your parachain to Moonbeam, an HRMP channel must be opened. To create an HRMP channel, you'll need to send an XCM message to the relay chain that will request a channel be opened through the relay chain. The message will need to contain at least the following XCM instructions:</p> <ol> <li>WithdrawAsset - takes funds out of the Sovereign account (in the relay chain) of the origin parachain to a holding state</li> <li>BuyExecution - buys execution time from the relay chain to execute the XCM message</li> <li>Transact - provides the relay chain call data to be executed. In this case, the call will be an HRMP extrinsic</li> </ol> <p>Note</p> <p>You can add DepositAsset to refund the leftover funds after the execution. If this is not provided, no refunds will be made. In addition, you could also add a RefundSurplus after Transact to get any leftover funds not used for the Transact. But you'll have to calculate if it is worth paying the execution cost of the extra XCM instructions.</p> <p>To send these XCM messages to the relay chain, the Polkadot XCM Pallet is typically invoked. Moonbeam also has an XCM Transactor Pallet that simplifies the process into a call that abstracts the XCM messaging constructor.</p> <p>You could potentially generate the calldata for an HRMP action by using Polkadot.js Apps, but the xcm-tools GitHub repository can build it for you, and it is the recommended tool for this process.</p> <pre><code>git clone https://github.com/Moonsong-Labs/xcm-tools &amp;&amp; \\\ncd xcm-tools &amp;&amp; \\\nyarn\n</code></pre> <p>The xcm-tools repository has a specific script for HRMP interactions called <code>hrmp-channel-manipulator.ts</code>. This command generates encoded calldata for a specific HRMP action, as long as it is given the correct details. The script builds the XCM message with the DepositAsset XCM instruction but not with RefundSurplus.</p> <p>The encoded calldata is then used to submit a governance proposal that will execute the HRMP action. All HRMP-related proposals should be assigned to the General Admin Track.</p> <p>The <code>hrmp-channel-manipulator.ts</code> script is meant to be generic. It should work for any chain that includes the Polkadot XCM Pallet, although it will try to use the <code>hrmpManage</code> extrinsic of the XCM Transactor Pallet first. If the XCM Transactor Pallet doesn't exist on a chain, the <code>send</code> extrinsic of the Polkadot XCM Pallet will be used. Note that it expects the pallet name to be <code>polkadotXcm</code>, as the extrinsic will be built as <code>api.tx.polkadotXcm.send()</code>. For Moonbeam, the General Admin Track can't execute <code>polkadotXcm.send</code> calls, as such the <code>xcmTransactor.hrmpManage</code> extrinsic must be used.</p> <p>The following sections go through the steps of creating and accepting open channel requests in a Moonbeam-based network, but they can also be adapted to your parachain.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#accept-an-hrmp-channel-on-moonbeam","title":"Accept an HRMP Channel on Moonbeam","text":"<p>When a parachain receives an incoming HRMP channel open request from another parachain, it must signal to the relay chain that it accepts this channel before the channel can be used. This requires an XCM message to the relay chain with the Transact instruction calling the HRMP Pallet and <code>hrmpAcceptOpenChannel</code> extrinsic.</p> <p>Fortunately, the xcm-tools GitHub repository's <code>hrmp-channel-manipulator.ts</code> script can build the XCM for you!</p> <p>To use the script, you'll need to provide the following required arguments:</p> <ul> <li><code>--parachain-ws-provider</code> or <code>--w</code> - specifies the parachain WebSocket provider that will be issuing the requests</li> <li><code>--relay-ws-provider</code> or <code>--wr</code> - specifies the relay chain WebSocket provider that will be issuing the requests</li> <li><code>--hrmp-action</code> or <code>--hrmp</code> - accepts the following action to take, which can be any of the following: <code>accept</code>, <code>cancel</code>, <code>close</code>, and <code>open</code></li> <li><code>--target-para-id</code> or <code>-p</code> - the target parachain ID for the requests</li> </ul> <p>Running the following command will provide the encoded calldata to accept an open HRMP channel request on a Moonbeam network. Replace <code>YOUR_PARACHAIN_ID</code> with the ID of your parachain:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonbeam.network  \\\n--relay-ws-provider wss://rpc.polkadot.io \\\n--hrmp-action accept\n</code></pre> <pre><code>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonriver.moonbeam.network  \\\n--relay-ws-provider wss://kusama-rpc.polkadot.io \\\n--hrmp-action accept\n</code></pre> <pre><code>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonbase.moonbeam.network  \\\n--relay-ws-provider wss://relay.api.moonbase.moonbeam.network \\\n--hrmp-action accept\n</code></pre> <p>Note</p> <p>You can adapt the script for your parachain by changing the <code>parachain-ws-provider</code>.</p> <p>After running the script, you'll see output that looks like the following:</p> yarn hrmp-manipulator --target-para-id 3370 \\ --parachain-ws-provider wss://moonbeam.public.blastapi.io  \\ --relay-ws-provider wss://polkadot-rpc.publicnode.com \\ --hrmp-action accept yarn run v1.22.22 warning ../../../package.json: No license field $ ts-node 'scripts/hrmp-channel-manipulator.ts' --target-para-id 3370 --parachain-ws-provider wss://moonbeam.public.blastapi.io --relay-ws-provider wss://polkadot-rpc.publicnode.com --hrmp-action accept Genesis hash is: 0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3 Polkadot FeeAmount is: 10000000000 XCM Version is V4 Encoded Call Data for Tx is 0x6b09012a0d0000010401000100e40b5402000000000000000000000002286bee020004000100 \u2728  Done in 4.39s. <p>Running the script as shown above will return the encoded calldata to accept an HRMP channel. You can also use the script to create and submit a preimage and proposal on chain for the given HRMP action. For Moonbeam and Moonriver, the proposal must be submitted via the General Admin Track.</p> <p>Please refer to the README for a complete list of the arguments, including optional arguments, and examples on how to use the HRMP-manipulator script.</p> <p>If you plan to batch the transaction with other calls, copy the resultant calldata for later use when using the batch transactions script.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#open-an-hrmp-channel-from-moonbeam","title":"Open HRMP Channels from Moonbeam","text":"<p>Parachains need bidirectional HRMP channels before sending XCM to each other. The first step to establishing an HRMP channel is to create an open channel request. This requires an XCM message to the relay chain with the Transact instruction calling the HRMP Pallet and <code>hrmpInitOpenChannel</code> extrinsic.</p> <p>Fortunately, the xcm-tools GitHub repository's <code>hrmp-channel-manipulator.ts</code> script can build the XCM for you!</p> <p>To use the script, you'll need to provide the following required arguments:</p> <ul> <li><code>--parachain-ws-provider</code> or <code>--w</code> - specifies the parachain WebSocket provider that will be issuing the requests</li> <li><code>--relay-ws-provider</code> or <code>--wr</code> - specifies the relay chain WebSocket provider that will be issuing the requests</li> <li><code>--hrmp-action</code> or <code>--hrmp</code> - accepts the following action to take, which can be any of the following: <code>accept</code>, <code>cancel</code>, <code>close</code>, and <code>open</code></li> <li><code>--target-para-id</code> or <code>-p</code> - the target parachain ID for the requests</li> </ul> <p>Running the following command will provide the encoded calldata to create the HRMP channel request from a Moonbeam network. The maximum message size and capacity values can be obtained from the relay chain's Configuration Pallet and <code>activeConfig</code> extrinsic. Replace <code>YOUR_PARACHAIN_ID</code> with the ID of your parachain:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonbeam.network  \\\n--relay-ws-provider wss://rpc.polkadot.io \\\n--max-capacity 1000 --max-message-size 102400 \\\n--hrmp-action open\n</code></pre> <pre><code>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonriver.moonbeam.network  \\\n--relay-ws-provider wss://kusama-rpc.polkadot.io \\\n--max-capacity 1000 --max-message-size 102400 \\\n--hrmp-action open\n</code></pre> <pre><code>yarn hrmp-manipulator --target-para-id YOUR_PARACHAIN_ID \\\n--parachain-ws-provider wss://wss.api.moonbase.moonbeam.network  \\\n--relay-ws-provider wss://relay.api.moonbase.moonbeam.network \\\n--max-capacity 1000 --max-message-size 102400 \\\n--hrmp-action open\n</code></pre> <p>Note</p> <p>You can adapt the script for your parachain by changing the <code>parachain-ws-provider</code>.</p> <p>After running the script, you'll see output that looks like the following:</p> yarn hrmp-manipulator --target-para-id 3370 \\ --parachain-ws-provider wss://moonbeam.public.blastapi.io  \\ --relay-ws-provider wss://polkadot-rpc.publicnode.com \\ --max-capacity 1000 --max-message-size 102400 \\ --hrmp-action open yarn run v1.22.22 warning ../../../package.json: No license field $ ts-node 'scripts/hrmp-channel-manipulator.ts' --target-para-id 3370 --parachain-ws-provider wss://moonbeam.public.blastapi.io --relay-ws-provider wss://polkadot-rpc.publicnode.com --max-capacity 1000 --max-message-size 102400 --hrmp-action open Genesis hash is: 0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3 Polkadot FeeAmount is: 10000000000 XCM Version is V4 Encoded Call Data for Tx is 0x6b09002a0d0000e803000000900100010401000100e40b5402000000000000000000000002286bee020004000100 \u2728  Done in 4.25s. <p>Running the script as shown above will return the encoded calldata to open an HRMP channel. You can also use the script to create and submit a preimage and proposal on-chain for the given HRMP action. For Moonbeam and Moonriver, the proposal must be submitted via the General Admin Track.</p> <p>Please refer to the README for a complete list of the arguments, including optional arguments, and examples on how to use the HRMP-manipulator script.</p> <p>If you plan to batch the transaction with other calls, copy the resultant calldata for later use when using the batch transactions script.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#batch-actions-into-one","title":"Batch Actions Into One","text":"<p>The most efficient way to complete the XCM process on parachains is to batch all transactions together. The xcm-tools repository provides a script to batch extrinsic calls into a single call, thus requiring only a single transaction. This can be helpful if your parachain would like to open an HRMP channel and register an asset simultaneously. This should be used when proposing channel registration on a Moonbeam network.</p> <p>If you are registering an asset in addition to establishing a channel, please refer to the How to Register Cross-Chain Assets guide to learn how to generate the encoded calldata required for asset registration.</p> <p>The process of batching all of the transactions into one is depicted in the following diagram.</p> <p></p> <p>You will now use the encoded calldata outputs for opening a channel, accepting a channel, and registering an asset and insert them into the following command to send the batch proposal to democracy.</p> <p>You can add a <code>--call \"INSERT_CALL\"</code> for each call you want to batch. Replace the following values before running the command:</p> <ul> <li><code>OPEN_CHANNEL_CALL</code> is the SCALE encoded calldata for opening an HRMP channel from Moonbeam to your parachain</li> <li><code>ACCEPT_INCOMING_CALL</code> is the SCALE encoded calldata for accepting the channel request from your parachain</li> <li><code>REGISTER_ASSET_CALL</code> is the SCALE encoded calldata for registering a cross-chain asset. If you have more than one asset to be registered on Moonbeam, you can include additional registration SCALE encoded calldata with additional <code>--call</code> flags</li> </ul> MoonbeamMoonriverMoonbase Alpha <pre><code>yarn generic-call-propose -w wss://wss.api.moonbeam.network \\\n--call \"OPEN_CHANNEL_CALL\" \\\n--call \"ACCEPT_INCOMING_CALL\" \\\n--call \"REGISTER_ASSET_CALL\" \\\n</code></pre> <pre><code>yarn generic-call-propose -w wss://wss.api.moonriver.moonbeam.network \\\n--call \"OPEN_CHANNEL_CALL\" \\\n--call \"ACCEPT_INCOMING_CALL\" \\\n--call \"REGISTER_ASSET_CALL\" \\\n</code></pre> <pre><code>yarn generic-call-propose -w wss://wss.api.moonbase.moonbeam.network  \\\n--call \"OPEN_CHANNEL_CALL\" \\\n--call \"ACCEPT_INCOMING_CALL\" \\\n--call \"REGISTER_ASSET_CALL\" \\\n</code></pre> <p>Note</p> <p>You can readapt the script for your parachain by changing the <code>parachain-ws-provider</code>.</p> <p>With the encoded calldata, you can then submit the governance proposal. For Moonbeam and Moonriver, you must assign the proposal to the General Admin Track. It is recommended to become familiar with the OpenGov: Governance v2 process on Moonbeam-based networks.</p> <p>If you want to send the governance proposal directly from the CLI, you'll need to use these additional flags:</p> <pre><code>--account-priv-key YOUR_PRIVATE_KEY \\\n--send-preimage-hash true \\\n--send-proposal-as v2 \\\n--track '{ \"Origins\": \"GeneralAdmin\" }'\n</code></pre> <p>For Moonbase Alpha, you will not need to provide a private key or go through governance. Instead, you can use the <code>--sudo</code> flag and provide the output to the Moonbeam team so that the asset and channel can be added quickly through sudo.</p> <p>Feel free to check out the additional flags available for this script.</p>"},{"location":"builders/interoperability/xcm/xc-registration/xc-integration/#additional-flags-xcm-tools","title":"Additional Flags for XCM-Tools","text":"<p>The xcm-tools GitHub repository and most of its functions can be called with some additional flags that create some wrappers around the actions being taken. For example, you might want to wrap the send of the XCM message in sudo, or via a democracy proposal.</p> <p>The complete options that can be used with the script are as follows:</p> Flag Type Description account-priv-key string (Required for send-proposal-as, send-preimage-hash) The private key of the account to send a transaction with sudo boolean Whether to wrap the extrinsic calldata inside of a <code>sudo.sudo</code> extrinsic. If <code>account-priv-key</code> is present, it will attempt to send the transaction send-preimage-hash boolean Whether to submit the encoded calldata as a preimage and retrieve its hash send-proposal-as democracy/council-external/v2 Whether to send the encoded calldata through democracy or Council (Governance v1), or OpenGov (Governance v2) collective-threshold number (Required for council-external) The threshold for the Council deciding the proposal delay number (Required for v2) The number of blocks to delay an OpenGovV2 proposal's execution by track string (JSON encoded origin) (Required for v2) The JSON encoded origin for an OpenGovV2 proposal. For Moonbeam networks: \"Root\", \"WhitelistedCaller\", \"GeneralAdmin\", \"ReferendumCanceller\", \"ReferendumKiller\" at-block number Whether to wrap the extrinsic calldata inside of a <code>scheduler.schedule</code> extrinsic. The block in the future that the action should be scheduled to take place fee-currency string (multilocation) (Required for non-Moonbeam chains that use XCM Transactor) The multilocation of the relay chain's asset <p>Note</p> <p>The track option must be specified like so: <code>'{ \"Origins\": \"INSERT_ORIGIN\" }'</code>, where you can insert any of the following as the Origin: \"Root\", \"WhitelistedCaller\", \"GeneralAdmin\", \"ReferendumCanceller\", \"ReferendumKiller\".</p>"},{"location":"builders/interoperability/xcm/xc20/interact/","title":"Interact with XC-20s on Moonbeam","text":""},{"location":"builders/interoperability/xcm/xc20/interact/#introduction","title":"Introduction","text":"<p>As mentioned in the XC-20s Overview page, XC-20s are a unique asset class on Moonbeam. Although they are Substrate-native assets, they also have an ERC-20 interface and can be interacted with like any other ERC-20. Additionally, the ERC-20 Permit interface is available for all external XC-20s.</p> <p>This guide covers the XC-20 Solidity interfaces, including the standard ERC-20 interface and the ERC-20 Permit interface, and how to interact with external XC-20s using these interfaces.</p>"},{"location":"builders/interoperability/xcm/xc20/interact/#xc20s-solidity-interface","title":"XC-20s Solidity Interface","text":"<p>Both types of XC-20s have the standard ERC-20 interface. In addition, all external XC-20s also possess the ERC-20 Permit interface. The following two sections describe each of the interfaces separately.</p>"},{"location":"builders/interoperability/xcm/xc20/interact/#the-erc20-interface","title":"The ERC-20 Solidity Interface","text":"<p>As mentioned, you can interact with XC-20s via an ERC-20 interface. The ERC20.sol interface on Moonbeam follows the EIP-20 Token Standard, which is the standard API interface for tokens within smart contracts. The standard defines the required functions and events that a token contract must implement to be interoperable with different applications.</p> <p>The interface includes the following functions:</p> <ul> <li>name() \u2014 read-only function that returns the name of the token</li> <li>symbol() \u2014 read-only function that returns the symbol of the token</li> <li>decimals() \u2014 read-only function that returns the decimals of the token</li> <li>totalSupply() \u2014 read-only function that returns the total number of tokens in existence</li> <li>balanceOf(address who) \u2014 read-only function that returns the balance of the specified address</li> <li>allowance(address owner, address spender) \u2014  read-only function that checks and returns the amount of tokens that a spender is allowed to spend on behalf of the owner</li> <li>transfer(address to, uint256 value) \u2014 transfers a given amount of tokens to a specified address and returns <code>true</code> if the transfer was successful</li> <li>approve(address spender, uint256 value) \u2014 approves the provided address to spend a specified amount of tokens on behalf of <code>msg.sender</code>. Returns <code>true</code> if successful</li> <li>transferFrom(address from, address to, uint256 value) \u2014 transfers tokens from one given address to another given address and returns <code>true</code> if successful</li> </ul> <p>Note</p> <p>The ERC-20 standard does not specify the implications of multiple calls to <code>approve</code>. Changing an allowance with this function numerous times enables a possible attack vector. To avoid incorrect or unintended transaction ordering, you can first reduce the <code>spender</code> allowance to <code>0</code> and then set the desired allowance afterward. For more details on the attack vector, you can check out the ERC-20 API: An Attack Vector on Approve/TransferFrom Methods overview.</p> <p>The interface also includes the following required events:</p> <ul> <li>Transfer(address indexed from, address indexed to, uint256 value) - emitted when a transfer has been performed</li> <li>Approval(address indexed owner, address indexed spender, uint256 value) - emitted when an approval has been registered</li> </ul>"},{"location":"builders/interoperability/xcm/xc20/interact/#the-erc20-permit-interface","title":"The ERC-20 Permit Solidity Interface","text":"<p>External XC-20s also have the ERC-20 Permit interface. The Permit.sol interface on Moonbeam follows the EIP-2612 standard, which extends the ERC-20 interface with the <code>permit</code> function. Permits are signed messages that can be used to change an account's ERC-20 allowance. Note that local XC-20s can have also the Permit interface, but it is not a requirement for them to be XCM-ready.</p> <p>The standard ERC-20 <code>approve</code> function is limited in its design as the <code>allowance</code> can only be modified by the sender of the transaction, the <code>msg.sender</code>. This can be seen in OpenZeppelin's implementation of the ERC-20 interface, which sets the <code>owner</code> through the <code>msgSender</code> function, which ultimately sets it to <code>msg.sender</code>.</p> <p>Instead of signing the <code>approve</code> transaction, a user can sign a message, and that signature can be used to call the <code>permit</code> function to modify the <code>allowance</code>.  As such, it allows for gas-less token transfers. In addition, users no longer need to send two transactions to approve and transfer tokens. To see an example of the <code>permit</code> function, you can check out OpenZeppelin's implementation of the ERC-20 Permit extension.</p> <p>The Permit.sol interface includes the following functions:</p> <ul> <li>permit(address owner, address spender, uint256, value, uint256, deadline, uint8 v, bytes32 r, bytes32 s) - consumes an approval permit, which can be called by anyone</li> <li>nonces(address owner) - returns the current nonce for the given owner</li> <li>DOMAIN_SEPARATOR() - returns the EIP-712 domain separator, which is used to avoid replay attacks. It follows the EIP-2612 implementation</li> </ul> <p>The DOMAIN_SEPARATOR() is defined in the EIP-712 standard, and is calculated as:</p> <pre><code>keccak256(PERMIT_DOMAIN, name, version, chain_id, address)\n</code></pre> <p>The parameters of the hash can be broken down as follows:</p> <ul> <li>PERMIT_DOMAIN - is the <code>keccak256</code> of <code>EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)</code></li> <li>name - is the token name but with the following considerations:<ul> <li>If the token has a name defined, the name for the domain is <code>XC20: &lt;name&gt;</code>, where <code>&lt;name&gt;</code> is the token name</li> <li>If the token has no name defined, the name for the domain is <code>XC20: No name</code></li> </ul> </li> <li>version - is the version of the signing domain. For this case, version is set to <code>1</code></li> <li>chainId - is the chain ID of the network</li> <li>verifyingContract - is the XC-20 address</li> </ul> <p>Note</p> <p>Prior to runtime upgrade 1600, the name field did not follow the standard EIP-2612 implementation.</p> <p>The calculation of the domain separator can be seen in Moonbeam's EIP-2612 implementation, with a practical example shown in OpenZeppelin's <code>EIP712</code> contract.</p> <p>Aside from the domain separator, the <code>hashStruct</code> guarantees that the signature can only be used for the <code>permit</code> function with the given function arguments. It uses a given nonce to ensure the signature is not subject to a replay attack. The calculation of the hash struct can be seen in Moonbeam's EIP-2612 implementation, with a practical example shown in OpenZeppelin's <code>ERC20Permit</code> contract.</p> <p>The domain separator and the hash struct can be used to build the final hash of the fully encoded message. A practical example is shown in OpenZeppelin's <code>EIP712</code> contract.</p> <p>With the final hash and the <code>v</code>, <code>r</code>, and <code>s</code> values, the signature can be verified and recovered. If successfully verified, the nonce will increase by one and the allowance will be updated.</p>"},{"location":"builders/interoperability/xcm/xc20/interact/#interact-with-the-precompile-using-remix","title":"Interact with External XC-20s Using an ERC-20 Interface","text":"<p>This section of the guide will show you how to interact with XC-20s via the ERC-20 interface using Remix. Because local XC-20s are representations of regular ERC-20s, this section is focused on external XC-20s.</p> <p>To interact with external XC-20s, you'll need to first calculate the precompile address of the XC-20 asset you want to interact with. Then, you can interact with the ERC-20 interface as you would with any other ERC-20.</p> <p>You can adapt the instructions in this section to be used with the Permit.sol interface.</p>"},{"location":"builders/interoperability/xcm/xc20/interact/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To approve a spend or transfer external XC-20s via the ERC-20 interface, you will need:</p> <ul> <li>MetaMask installed and connected to the Moonbase Alpha TestNet</li> <li>Create or have two accounts on Moonbase Alpha</li> <li>At least one of the accounts will need to be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"builders/interoperability/xcm/xc20/interact/#calculate-xc20-address","title":"Calculate External XC-20 Precompile Addresses","text":"<p>Before you can interact with an external XC-20 via the ERC-20 interface, you need to derive the external XC-20's precompile address from the asset ID.</p> <p>The external XC-20 precompile address is calculated using the following:</p> <pre><code>address = '0xFFFFFFFF...' + DecimalToHex(AssetId)\n</code></pre> <p>Given the above calculation, the first step is to take the u128 representation of the asset ID and convert it to a hex value. You can use your search engine of choice to look up a simple tool for converting decimals to hex values. For asset ID <code>42259045809535163221576417993425387648</code>, the hex value is <code>1FCACBD218EDC0EBA20FC2308C778080</code>.</p> <p>External XC-20 precompiles can only fall between <code>0xFFFFFFFF00000000000000000000000000000000</code> and <code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code>.</p> <p>Since Ethereum addresses are 40 characters long, you will need to start with the initial eight <code>F</code>s and then prepend <code>0</code>s to the hex value until the address has 40 characters.</p> <p>The hex value that was already calculated is 32 characters long, so prepending eight <code>F</code>s to the hex value will give you the 40-character address you need to interact with the XC-20 precompile. For this example, the full address is <code>0xFFFFFFFF1FCACBD218EDC0EBA20FC2308C778080</code>.</p> <p>Now that you've calculated the external XC-20 precompile address, you can use the address to interact with the XC-20 like you would with any other ERC-20 in Remix.</p>"},{"location":"builders/interoperability/xcm/xc20/interact/#add-the-interface-to-remix","title":"Add &amp; Compile the Interface","text":"<p>You can interact with the ERC-20 interface using Remix. First, you will need to add the interface to Remix:</p> <ol> <li>Get a copy of ERC20.sol</li> <li>Paste the file contents into a Remix file named IERC20.sol</li> </ol> <p></p> <p>Once you have the ERC-20 interface loaded in Remix, you will need to compile it:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Compile the IERC20.sol file</li> </ol> <p></p> <p>If the interface was compiled successfully, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/interoperability/xcm/xc20/interact/#access-the-precompile","title":"Access the Precompile","text":"<p>Instead of deploying the ERC-20 precompile, you will access the interface given the address of the XC-20:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note that the precompiled contract is already deployed</li> <li>Make sure Injected Web3 is selected in the ENVIRONMENT dropdown. Once you select Injected Web3, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure IERC20 - IERC20.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract, there is no need to deploy any code. Instead, you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the XC-20. For local XC-20s, which you should have already calculated in the  Calculate External XC-20 Precompile Addresses section. For this example, you can use <code>0xFFFFFFFF1FCACBD218EDC0EBA20FC2308C778080</code> and click At Address</li> </ol> <p></p> <p>Note</p> <p>Optionally, you can checksum the XC-20 precompile address by going to your search engine of choice and searching for a tool to checksum the address. Once the address has been checksummed, you can use it in the At Address field instead.</p> <p>The IERC20 precompile for the XC-20 will appear in the list of Deployed Contracts. Now you can feel free to call any of the standard ERC-20 functions to get information about the XC-20 or transfer the XC-20.</p> <p></p> <p>To learn how to interact with each of the functions, you can check out the ERC-20 Precompile guide and modify it for interacting with the XC-20 Precompile.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/","title":"Overview of XC-20s","text":""},{"location":"builders/interoperability/xcm/xc20/overview/#introduction","title":"Introduction","text":"<p>The Cross-Consensus Message (XCM) format provides a universal way for blockchains to exchange messages and transfer assets. To extend this interoperability to the EVM, Moonbeam introduced XC-20s, ERC-20 tokens on Moonbeam that are fully compatible with XCM transfers.</p> <p>Any ERC-20 deployed on Moonbeam can be configured as an XC-20, making it accessible to any chain connected via XCM. This allows EVM-focused developers to work with familiar ERC-20 workflows while benefiting from Polkadot\u2019s native cross-chain functionality, all without needing Substrate-specific expertise.</p> <p>From a technical standpoint, local XC-20s are ERC-20 tokens originating on Moonbeam (including bridged tokens deemed native once issued on Moonbeam), whereas external XC-20s are wrapped representations of tokens whose canonical ledger exists on another parachain or the relay chain. In all cases, XC-20s function just like standard ERC-20s\u2014supporting common EVM-based use cases (such as DeFi, DEXs, and lending platforms)\u2014but with the added advantage of seamless cross-chain operability.</p> <p></p> <p>This page aims to cover the basics on XC-20s; if you want to learn how to interact with or transfer XC-20s, please refer to the Send XC-20s guide.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#types-of-xc-20s","title":"Types of XC-20s","text":"<p>There are two types of XC-20s: local and external.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#local-xc20s","title":"What are Local XC-20s?","text":"<p>Local XC-20s are all ERC-20s that exist on the EVM, and that can be transferred cross-chain through XCM. For local XC-20s to be transferred to another parachain, the asset must be registered on that chain. When transferring local XC-20s, the underlying tokens reside in the destination chain's Sovereign account on Moonbeam. A sovereign account is a keyless account governed by a blockchain runtime\u2014rather than an individual\u2014that can hold assets and interact with other chains. Local XC-20s must follow the ERC-20 interface outlined in this guide. They must implement the standard ERC-20 function signatures, including the correct function selector of the <code>transfer</code> function as described in EIP-20. However, additional functionality can still be added as long as it doesn\u2019t break the base methods. </p> <p>Creating a local XC-20 is equivalent to deploying a standard ERC-20 and enabling cross-chain features on any Moonbeam network.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#external-xc20s","title":"What are External XC-20s?","text":"<p>External XC-20s are cross-chain tokens originating from another parachain or the relay chain, and they are represented on Moonbeam as ERC-20 tokens. The original tokens remain locked in a Moonbeam sovereign account on their home chain, while the wrapped ERC-20 representation can be freely utilized on Moonbeam. When you transfer external XC-20s, the canonical assets remain in the sovereign account on their source chain, while the ERC-20 representation is what circulates on Moonbeam.</p> <p>External XC-20s all have xc prepended to their names to distinguish them as cross-chain assets. For example, DOT, native to the Polkadot relay chain, is known as xcDOT when represented as an XC-20 on Moonbeam.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#local-xc-20s-vs-external-xc-20s","title":"Local XC-20s vs External XC-20s","text":"<p>Local XC-20s are EVM-native ERC-20 tokens whose \u201chome\u201d (or reserve chain) is Moonbeam from a Polkadot perspective. This includes tokens originally bridged in from outside Polkadot (for example, Wormhole-wrapped ETH), because once they\u2019re issued on Moonbeam as ERC-20s, Polkadot views them as local to Moonbeam. When local XC-20s are transferred to another parachain, the tokens move into that chain\u2019s sovereign account on Moonbeam.</p> <p>External XC-20s, on the other hand, are ERC-20 representations of tokens whose canonical ledger remains on another parachain or the relay chain. Moonbeam holds the \u201cwrapped\u201d version, while the underlying tokens stay locked in Moonbeam\u2019s sovereign account on the originating chain.</p> <p>From a cross-chain transfer perspective, local and external XC-20s can be sent through Polkadot\u2019s XCM infrastructure using the Ethereum or Substrate API. Because the underlying asset is an ERC-20 with EVM bytecode following the EIP-20 token standard, both transfers initiated via the Substrate and Ehereum APIs generate EVM logs visible to EVM-based explorers such as Moonscan. In contrast, you can't send a regular ERC-20 transfer using the Substrate API. Aside from cross-chain transfers through XCM, all other XC-20 interactions (such as querying balances or adjusting allowances) must occur in the EVM.</p> <p>Cross-chain transfers of XC-20s are executed via the Polkadot XCM Pallet, which utilizes regular mint, burn, and transfer mechanisms of ERC-20s for the XCM asset flow. If you\u2019d like to learn how to send XC-20s using that pallet, refer to the Using the Polkadot XCM Pallet guide.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#asset-reserves","title":"Asset Reserves","text":"<p>When transferring tokens across chains in the Polkadot or Kusama ecosystems, each token has a \u201creserve\u201d chain that holds its canonical ledger\u2014the source of truth for minting, burning, and supply management. For XC-20s, understanding which chain is the reserve determines whether the asset is managed locally on Moonbeam or remotely on another chain.</p> <p>Regardless of where the reserve is located, XC-20s on Moonbeam are still ERC-20 tokens that developers and users can interact with in the EVM. However, from an XCM perspective, the reserve chain determines how the tokens are locked, unlocked, minted, or burned behind the scenes when performing cross-chain operations.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#local-reserve-assets","title":"Local Reserve Assets","text":"<p>A local reserve asset on Moonbeam is a token whose canonical ledger\u2014from an XCM perspective\u2014resides natively on Moonbeam. In other words, Moonbeam is the asset\u2019s home chain, where minting and burning take place. </p> <p>For example, Wormhole-wrapped ETH (wETH) is considered a local reserve asset on Moonbeam, even though Ethereum is the ultimate source of ETH. Once ETH is wrapped by Wormhole and enters the Polkadot ecosystem via Moonbeam, wETH can be transferred to other parachains through Moonbeam Routed Liquidity (MRL).</p> <p>The important caveat is that, on a purely Ethereum-level view, ETH remains governed by and minted on Ethereum. However, from an XCM standpoint, wETH on Moonbeam is treated as a local reserve asset, meaning the canonical supply of wETH (as far as Polkadot ecosystems are concerned) exists on Moonbeam.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#remote-reserve-assets","title":"Remote Reserve Assets","text":"<p>A remote reserve asset is a token whose canonical ledger\u2014the source of truth for minting and burning\u2014resides on a chain different from where it\u2019s currently in use. In the case of xcDOT on Moonbeam, the underlying DOT tokens representing the xcDOT remain locked in Moonbeam\u2019s sovereign account on the Polkadot relay chain, while xcDOT functions as a wrapped representation in Moonbeam\u2019s EVM environment.</p> <p>Users can hold and transact with xcDOT on Moonbeam (for DeFi, governance, and more), knowing that the underlying DOT is safely locked on the relay chain. At any point, the wrapped xcDOT can be redeemed for the original DOT, effectively burning the xcDOT and unlocking the corresponding DOT tokens on Polkadot.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#current-xc20-assets","title":"Current List of External XC-20s","text":"<p>The current list of available external XC-20 assets per network is as follows:</p> MoonbeamMoonriverMoonbase Alpha Origin Symbol XC-20 Address Polkadot xcDOT 0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080 Acala xcaUSD 0xfFfFFFFF52C56A9257bB97f4B2b6F7B2D624ecda Acala xcACA 0xffffFFffa922Fef94566104a6e5A35a4fCDDAA9f Acala xcLDOT 0xFFfFfFffA9cfFfa9834235Fe53f4733F1b8B28d4 Apillon xcNCTR 0xFfFFfFfF8A9736B44EbF188972725bED67BF694E Astar xcASTR 0xFfFFFfffA893AD19e540E172C10d78D4d479B5Cf Bifrost xcBNC 0xFFffffFf7cC06abdF7201b350A1265c62C8601d2 Bifrost xcBNCS 0xfFfffffF6aF229AE7f0F4e0188157e189a487D59 Bifrost xcFIL 0xfFFfFFFF6C57e17D210DF507c82807149fFd70B2 Bifrost xcvASTR 0xFffFffff55C732C47639231a4C4373245763d26E Bifrost xcvBNC 0xffFffFff31d724194b6A76e1d639C8787E16796b Bifrost xcvDOT 0xFFFfffFf15e1b7E3dF971DD813Bc394deB899aBf Bifrost xcvFIL 0xFffffFffCd0aD0EA6576B7b285295c85E94cf4c1 Bifrost xcvGLMR 0xFfFfFFff99dABE1a8De0EA22bAa6FD48fdE96F6c Bifrost xcvMANTA 0xFFfFFfFfdA2a05FB50e7ae99275F4341AEd43379 Centrifuge xcCFG 0xFFfFfFff44bD9D2FFEE20B25D1Cf9E78Edb6Eae3 Composable xcIBCMOVR 0xFfFfffFF3AFcd2cAd6174387df17180a0362E592 Composable xcIBCPICA 0xfFFFFfFFABe9934e61db3b11be4251E6e869cf59 Composable xcIBCIST 0xfFfFffff6A3977d5B65D1044FD744B14D9Cef932 Composable xcIBCBLD 0xFffFffff9664be0234ea4dc64558F695C4f2A9EE Composable xcIBCTIA 0xFFFfFfff644a12F6F01b754987D175F5A780A75B Composable xcIBCATOM 0xffFFFffF6807D5082ff2f6F86BdE409245e2D953 Darwinia xcRING 0xFfffFfff5e90e365eDcA87fB4c8306Df1E91464f DED xcDED 0xfFffFFFf5da2d7214D268375cf8fb1715705FdC6 Equilibrium xcEQ 0xFffFFfFf8f6267e040D8a0638C576dfBa4F0F6D6 Equilibrium xcEQD 0xFFffFfFF8cdA1707bAF23834d211B08726B1E499 HydraDX xcHDX 0xFFFfFfff345Dc44DDAE98Df024Eb494321E73FcC Interlay xcIBTC 0xFFFFFfFf5AC1f9A51A93F5C527385edF7Fe98A52 Interlay xcINTR 0xFffFFFFF4C1cbCd97597339702436d4F18a375Ab Manta xcMANTA 0xfFFffFFf7D3875460d4509eb8d0362c611B4E841 Nodle xcNODL 0xfffffffFe896ba7Cb118b9Fa571c6dC0a99dEfF1 OriginTrail Parachain xcNEURO 0xFfffffFfB3229c8E7657eABEA704d5e75246e544 Parallel xcPARA 0xFfFffFFF18898CB5Fe1E88E668152B4f4052A947 LAOS xcLAOS 0xfffFFffFdd704e8e824a5EEc47de88f5B9e13588 Moonriver MOVR.mr 0xFfffFffF54c47F43713fd9211724362697f1a302 Peaq xcPEAQ 0xFffFFFFFEC4908b74688a01374f789B48E9a3eab Pendulum xcPEN 0xffFFfFFf2257622F345E1ACDe0D4f46D7d1D77D0 Pendulum xcEURC.s 0xFfFfffFfa608Ec1332131289cBD8A97a0bB3D90F Phala xcPHA 0xFFFfFfFf63d24eCc8eB8a7b5D0803e900F7b6cED Polkadex xcPDEX 0xfFffFFFF43e0d9b84010b1b67bA501bc81e33C7A Polkadot Asset Hub xcPINK 0xfFfFFfFf30478fAFBE935e466da114E14fB3563d Polkadot Asset Hub xcSTINK 0xFffFffFf54c556bD1d0F64ec6c78f1B477525E56 Polkadot Asset Hub xcUSDC 0xFFfffffF7D2B0B761Af01Ca8e25242976ac0aD7D Polkadot Asset Hub xcUSDT 0xFFFFFFfFea09FB06d082fd1275CD48b191cbCD1d Polkadot Asset Hub xcWIFD 0xfffffffF2e1D1ac9eA1686255bEfe995B31abc96 Snowbridge DAI.e 0xfFfffFFf9DE12E6658C49B4834f9278f6A39f5d7 Snowbridge ETH.e 0xFFFfFFffaFF6dF83d0A1935dDA2e5F1F402C0c45 Snowbridge USDC.e 0xfffFFFFF166F84967F054AE95ab5764c38Cf3aEd Snowbridge USDT.e 0xFFffFfff7bc304425217b49E9598415C514ae81B Snowbridge WBTC.e 0xfFffFFFf1B4Bb1ac5749F73D866FfC91a3432c47 Snowbridge wstETH.e 0xFfFFFfFF5D5DEB44BF7278DEE5381BEB24CB6573 Snowbridge WETH.e 0xfFffFFFF86829AFE1521AD2296719DF3ACE8DED7 Subsocial xcSUB 0xfFfFffFf43B4560Bc0C451a3386E082bff50aC90 Unique xcUNQ 0xFffffFFFD58f77E6693CFB99EbE273d73C678DC2 Zeitgeist xcZTG 0xFFFFfffF71815ab6142E0E20c7259126C6B40612 <p>*You can check each Asset ID on Polkadot.js Apps</p> Origin Symbol XC-20 Address Kusama xcKSM 0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080 Bifrost xcBNC 0xFFfFFfFFF075423be54811EcB478e911F22dDe7D Bifrost xcvBNC 0xFFffffff3646A00f78caDf8883c5A2791BfCDdc4 Bifrost xcvKSM 0xFFffffFFC6DEec7Fc8B11A2C8ddE9a59F8c62EFe Bifrost xcvMOVR 0xfFfffFfF98e37bF6a393504b5aDC5B53B4D0ba11 Calamari xcKMA 0xffffffffA083189F870640B141AE1E882C2B5BAD Crab xcCRAB 0xFFFffFfF8283448b3cB519Ca4732F2ddDC6A6165 Crust-Shadow xcCSM 0xffFfFFFf519811215E05eFA24830Eebe9c43aCD7 Heiko xcHKO 0xffffffFF394054BCDa1902B6A6436840435655a3 Integritee xcTEER 0xFfFfffFf4F0CD46769550E5938F6beE2F5d4ef1e Karura xcKAR 0xFfFFFFfF08220AD2E6e157f26eD8bD22A336A0A5 Karura xcaSEED 0xFfFffFFfa1B026a00FbAA67c86D5d1d5BF8D8228 Khala xcPHA 0xffFfFFff8E6b63d9e447B6d4C45BDA8AF9dc9603 Kintsugi xcKINT 0xfffFFFFF83F4f317d3cbF6EC6250AeC3697b3fF2 Kintsugi xcKBTC 0xFFFfFfFfF6E528AD57184579beeE00c5d5e646F0 Kusama Asset Hub xcRMRK 0xffffffFF893264794d9d57E1E0E21E0042aF5A0A Kusama Asset Hub xcUSDT 0xFFFFFFfFea09FB06d082fd1275CD48b191cbCD1d Litmus xcLIT 0xfffFFfFF31103d490325BB0a8E40eF62e2F614C0 Mangata xcMGX 0xffFfFffF58d867EEa1Ce5126A4769542116324e9 Picasso xcPICA 0xFffFfFFf7dD9B9C60ac83e49D7E3E1f7A1370aD2 Robonomics xcXRT 0xFffFFffF51470Dca3dbe535bD2880a9CcDBc6Bd9 Shiden xcSDN 0xFFFfffFF0Ca324C842330521525E7De111F38972 Tinkernet xcTNKR 0xfFFfFffF683474B842852111cc31d470bD8f5081 Turing xcTUR 0xfFffffFf6448d0746f2a66342B67ef9CAf89478E Moonbeam GLMR.mb 0xFfFffFff1a49463978f19dfD6983f2fa1885C254 Moonbeam xcUSDC.mb 0xFFFFFFfF2215880E56fe63a96E54E073757C3092 Moonbeam xcUSDT.mb 0xFFFFFFFFc70260a3bf46A91cF87B6F5e6Abba712 Moonbeam whUSDC.mb 0xFfFfffff9E27Ab60FADFd33ABf71B39A7445f7eD <p>*You can check each Asset ID on Polkadot.js Apps</p> Origin Symbol XC-20 Address Relay Chain Alphanet xcUNIT 0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080 <p>*You can check each Asset ID on Polkadot.js Apps</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#list-xchain-assets","title":"Retrieve List of External XC-20s and Their Metadata","text":"<p>To fetch a list of the currently available external XC-20s along with their associated metadata, you can query the chain state using the Polkadot.js API. You'll take the following steps:</p> <ol> <li> <p>Create an API provider for the network you'd like to get the list of assets for. You can use the following WSS endpoints for each network:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>wss://wss.api.moonbeam.network\n</code></pre> <pre><code>wss://wss.api.moonriver.moonbeam.network\n</code></pre> <pre><code>wss://wss.api.moonbase.moonbeam.network\n</code></pre> </li> <li> <p>Query the <code>assets</code> pallet for all assets</p> </li> <li>Iterate over the list of assets to get all of the asset IDs along with their associated metadata</li> </ol> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst getXc20s = async () =&gt; {\n  try {\n    const substrateProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n    const api = await ApiPromise.create({ provider: substrateProvider });\n\n    const assets = await api.query.assets.asset.entries();\n\n    await Promise.all(\n      assets.map(async ([{ args: [id] }]) =&gt; {\n        try {\n          const metadata = await api.query.assets.metadata(id);\n          const humanMetadata = metadata.toHuman();\n\n          console.log(`\\nAsset ID: ${id}`);\n          console.log('Metadata:');\n          console.log('  Name:', humanMetadata.name);\n          console.log('  Symbol:', humanMetadata.symbol);\n          console.log('  Decimals:', humanMetadata.decimals);\n          console.log('  Deposit:', humanMetadata.deposit);\n          console.log('  IsFrozen:', humanMetadata.isFrozen);\n          console.log('-----');\n        } catch (error) {\n          console.error(`Error fetching metadata for asset ${id}:`, error);\n        }\n      })\n    );\n\n    await api.disconnect();\n  } catch (error) {\n    console.error('Error in getXc20s:', error);\n  }\n};\n\ngetXc20s().catch(console.error);\n</code></pre> <p>The result will display the asset ID along with some additional information for all of the registered external XC-20s.</p>"},{"location":"builders/interoperability/xcm/xc20/overview/#retrieve-local-xc20-metadata","title":"Retrieve Local XC-20 Metadata","text":"<p>Since local XC-20s are ERC-20s on Moonbeam that can be transferred via XCM to another parachain, you can interact with local XC-20s like you would an ERC-20. As long as you have the address and the ABI of the ERC-20, you can retrieve its metadata by interacting with its ERC-20 interface to retrieve the name, symbol, and decimals for the asset.</p> <p>The following is an example that retrieves the asset metadata for the Jupiter token on Moonbase Alpha:</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers';\n\nconst providerRPC = {\n  moonbase: {\n    name: 'moonbase',\n    rpc: 'https://rpc.api.moonbase.moonbeam.network', // Insert your RPC URL here\n    chainId: 1287, // 0x507 in hex,\n  },\n};\n\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n});\n\n// Replace with the address of the ERC-20 token\nconst tokenAddress = '0x9Aac6FB41773af877a2Be73c99897F3DdFACf576';\nconst tokenABI = [\n  'function name() view returns (string)',\n  'function symbol() view returns (string)',\n  'function decimals() view returns (uint8)',\n];\n\nconst tokenContract = new ethers.Contract(tokenAddress, tokenABI, provider);\nasync function getTokenMetadata() {\n  try {\n    const [name, symbol, decimals] = await Promise.all([\n      tokenContract.name(),\n      tokenContract.symbol(),\n      tokenContract.decimals(),\n    ]);\n    console.log(`Name: ${name}`);\n    console.log(`Symbol: ${symbol}`);\n    console.log(`Decimals: ${decimals}`);\n  } catch (error) {\n    console.error('Error fetching token metadata:', error);\n  }\n}\ngetTokenMetadata();\n</code></pre> <pre><code>import { Web3 } from 'web3';\n\n// Insert your RPC URL here\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network');\n\n// Replace with the address of the ERC-20 token\nconst tokenAddress = '0x9Aac6FB41773af877a2Be73c99897F3DdFACf576';\nconst tokenABI = [\n  // ERC-20 ABI\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [{ name: '', type: 'string' }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [{ name: '', type: 'string' }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [{ name: '', type: 'uint8' }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n];\nconst tokenContract = new web3.eth.Contract(tokenABI, tokenAddress);\nasync function getTokenMetadata() {\n  try {\n    const [name, symbol, decimals] = await Promise.all([\n      tokenContract.methods.name().call(),\n      tokenContract.methods.symbol().call(),\n      tokenContract.methods.decimals().call(),\n    ]);\n    console.log(`Name: ${name}`);\n    console.log(`Symbol: ${symbol}`);\n    console.log(`Decimals: ${decimals}`);\n  } catch (error) {\n    console.error('Error fetching token metadata:', error);\n  }\n}\ngetTokenMetadata();\n</code></pre> <pre><code>from web3 import Web3\n\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Replace with the address of the ERC-20 token\ntoken_address = \"0x9Aac6FB41773af877a2Be73c99897F3DdFACf576\"\ntoken_abi = [  # ERC-20 ABI\n    {\n        \"constant\": True,\n        \"inputs\": [],\n        \"name\": \"name\",\n        \"outputs\": [{\"name\": \"\", \"type\": \"string\"}],\n        \"payable\": False,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\",\n    },\n    {\n        \"constant\": True,\n        \"inputs\": [],\n        \"name\": \"symbol\",\n        \"outputs\": [{\"name\": \"\", \"type\": \"string\"}],\n        \"payable\": False,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\",\n    },\n    {\n        \"constant\": True,\n        \"inputs\": [],\n        \"name\": \"decimals\",\n        \"outputs\": [{\"name\": \"\", \"type\": \"uint8\"}],\n        \"payable\": False,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\",\n    },\n]\ntoken_contract = web3.eth.contract(address=token_address, abi=token_abi)\n\n\ndef get_token_metadata():\n    try:\n        name = token_contract.functions.name().call()\n        symbol = token_contract.functions.symbol().call()\n        decimals = token_contract.functions.decimals().call()\n        print(f\"Name: {name}\")\n        print(f\"Symbol: {symbol}\")\n        print(f\"Decimals: {decimals}\")\n    except Exception as e:\n        print(f\"Error fetching token metadata: {e}\")\n\n\nget_token_metadata()\n</code></pre>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/","title":"XCM Precompile","text":""},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#introduction","title":"Introduction","text":"<p>As a Polkadot parachain, Moonbeam has the inherent ability to communicate and exchange data with other connected parachains. This native cross-chain communication allows safe and fast token transfers leveraging the Cross-Consensus Message format (XCM for short), facilitating communication between different consensus systems.</p> <p>The communication protocol enabling token transfers is built on Substrate and runs on a lower level than the EVM, making it harder for EVM developers to access.</p> <p>Nevertheless, Moonbeam networks have an XCM Precompile that fills the gap between execution layers. This precompile exposes a smart contract interface that abstracts away the underlying complexities, making the execution of cross-chain token transfers as easy as any other smart contract call. </p> <p>This guide will show you how to interact with the XCM Interface precompile to execute cross-chain token transfers through the Ethereum API.</p> <p>The XCM Precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x000000000000000000000000000000000000081A\n</code></pre> <pre><code>0x000000000000000000000000000000000000081A\n</code></pre> <pre><code>0x000000000000000000000000000000000000081A\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#the-xcm-solidity-interface","title":"The XCM Solidity Interface","text":"<p>The <code>XCMInterface.sol</code> is a Solidity interface that allows developers to interact with the methods of <code>pallet-xcm</code>.</p> XCMInterface.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The XCM contract's address.\naddress constant XCM_CONTRACT_ADDRESS = 0x000000000000000000000000000000000000081A;\n\n/// @dev The XCM contract's instance.\nXCM constant XCM_CONTRACT = XCM(XCM_CONTRACT_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title XCM precompile Interface\n/// @dev The interface that Solidity contracts use to interact with the substrate pallet-xcm.\ninterface XCM {\n    // A location is defined by its number of parents and the encoded junctions (interior)\n    struct Location {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    // Support for Weights V2\n    struct Weight {\n        uint64 refTime;\n        uint64 proofSize;\n    }\n\n    // A way to represent fungible assets in XCM using Location format\n    struct AssetLocationInfo {\n        Location location;\n        uint256 amount;\n    }\n\n    // A way to represent fungible assets in XCM using address format\n    struct AssetAddressInfo {\n        address asset;\n        uint256 amount;\n    }\n\n    // The values start at `0` and are represented as `uint8`\n    enum TransferType {\n        Teleport,\n        LocalReserve,\n        DestinationReserve\n    }\n\n    /// @dev Function to send assets via XCM using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector 9ea8ada7\n    /// @param dest The destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on dest.\n    /// @param assets The combination (array) of assets to send in Location format.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    function transferAssetsLocation(\n        Location memory dest,\n        Location memory beneficiary,\n        AssetLocationInfo[] memory assets,\n        uint32 feeAssetItem\n    ) external;\n\n    /// @dev Function to send assets via XCM to a 20 byte-like parachain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector a0aeb5fe\n    /// @param paraId The para-id of the destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on paraId destination.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    function transferAssetsToPara20(\n        uint32 paraId,\n        address beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem\n    ) external;\n\n    /// @dev Function to send assets via XCM to a 32 byte-like parachain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector f23032c3\n    /// @param paraId The para-id of the destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on paraId destination.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    function transferAssetsToPara32(\n        uint32 paraId,\n        bytes32 beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem\n    ) external;\n\n    /// @dev Function to send assets via XCM to the relay chain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector 6521cc2c\n    /// @param beneficiary The actual account that will receive the tokens on the relay chain.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    function transferAssetsToRelay(\n        bytes32 beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem\n    ) external;\n\n    /// @dev Function to send assets through transfer_assets_using_type_and_then() pallet-xcm\n    /// extrinsic.\n    /// Important: in this selector RemoteReserve type (for either assets or fees) is not allowed.\n    /// If users want to send assets and fees (in Location format) with a remote reserve, \n    /// they must use the selector fc19376c.\n    /// @custom:selector 8425d893\n    /// @param dest The destination chain.\n    /// @param assets The combination (array) of assets to send in Location format.\n    /// @param assetsTransferType The TransferType corresponding to assets being sent.\n    /// @param remoteFeesIdIndex The index of the asset (inside assets array) to use as fees.\n    /// @param feesTransferType The TransferType corresponding to the asset used as fees.\n    /// @param customXcmOnDest The XCM message to execute on destination chain.\n    function transferAssetsUsingTypeAndThenLocation(\n        Location memory dest,\n        AssetLocationInfo[] memory assets,\n        TransferType assetsTransferType,\n        uint8 remoteFeesIdIndex,\n        TransferType feesTransferType,\n        bytes memory customXcmOnDest\n    ) external;\n\n    /// @dev Function to send assets through transfer_assets_using_type_and_then() pallet-xcm\n    /// extrinsic.\n    /// @custom:selector fc19376c\n    /// @param dest The destination chain.\n    /// @param assets The combination (array) of assets to send in Location format.\n    /// @param remoteFeesIdIndex The index of the asset (inside assets array) to use as fees.\n    /// @param customXcmOnDest The XCM message to execute on destination chain.\n    /// @param remoteReserve The remote reserve corresponding for assets and fees. They MUST\n    /// share the same reserve.\n    function transferAssetsUsingTypeAndThenLocation(\n        Location memory dest,\n        AssetLocationInfo[] memory assets,\n        uint8 remoteFeesIdIndex,\n        bytes memory customXcmOnDest,\n        Location memory remoteReserve\n    ) external;\n\n    /// @dev Function to send assets through transfer_assets_using_type_and_then() pallet-xcm\n    /// extrinsic.\n    /// Important: in this selector RemoteReserve type (for either assets or fees) is not allowed.\n    /// If users want to send assets and fees (in Address format) with a remote reserve, \n    /// they must use the selector aaecfc62.\n    /// @custom:selector 998093ee\n    /// @param dest The destination chain.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param assetsTransferType The TransferType corresponding to assets being sent.\n    /// @param remoteFeesIdIndex The index of the asset (inside assets array) to use as fees.\n    /// @param feesTransferType The TransferType corresponding to the asset used as fees.\n    /// @param customXcmOnDest The XCM message to execute on destination chain.\n    function transferAssetsUsingTypeAndThenAddress(\n        Location memory dest,\n        AssetAddressInfo[] memory assets,\n        TransferType assetsTransferType,\n        uint8 remoteFeesIdIndex,\n        TransferType feesTransferType,\n        bytes memory customXcmOnDest\n    ) external;\n\n    /// @dev Function to send assets through transfer_assets_using_type_and_then() pallet-xcm\n    /// extrinsic.\n    /// @custom:selector aaecfc62\n    /// @param dest The destination chain.\n    /// @param assets The combination (array) of assets to send in Address format.\n    /// @param remoteFeesIdIndex The index of the asset (inside assets array) to use as fees.\n    /// @param customXcmOnDest The XCM message to execute on destination chain.\n    /// @param remoteReserve The remote reserve corresponding for assets and fees. They MUST\n    /// share the same reserve.\n    function transferAssetsUsingTypeAndThenAddress(\n        Location memory dest,\n        AssetAddressInfo[] memory assets,\n        uint8 remoteFeesIdIndex,\n        bytes memory customXcmOnDest,\n        Location memory remoteReserve\n    ) external;\n}\n</code></pre> <p>The interface includes the necessary data structures along with the following functions:</p> transferAssetsToPara20(paraId, beneficiary, assets, feeAssetItem) \u2014 sends assets via XCM to a 20 byte-like parachain using the underlying <code>transfer_assets()</code> transaction included in the XCM pallet module ParametersExample <ul> <li><code>paraId</code> uint32 - the para-id of the destination chain</li> <li><code>beneficiary</code> address - the ECDSA-type account in the destination chain that will receive the tokens</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send in Address format</li> <li><code>feeAssetItem</code> uint32 - the index of the asset that will be used to pay fees</li> </ul> <ul> <li><code>paraId</code> - 888</li> <li><code>beneficiary</code> - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> </ul> transferAssetsToPara32(paraId, beneficiary, assets, feeAssetItem) \u2014 sends assets via XCM to a 32 byte-like parachain using the underlying <code>transfer_assets()</code> transaction included in the XCM pallet module ParametersExample <ul> <li><code>paraId</code> uint32 - the para-id of the destination chain</li> <li><code>beneficiary</code> bytes32 - the actual account that will receive the tokens on paraId destination</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send in Address format</li> <li><code>feeAssetItem</code> uint32 - the index of the asset that will be used to pay fees</li> </ul> <ul> <li><code>paraId</code> - 888</li> <li><code>beneficiary</code> - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> </ul> transferAssetsToRelay(beneficiary, assets, feeAssetItem) \u2014 sends assets via XCM to the relay chain using the underlying <code>transfer_assets()</code> transaction included in the XCM pallet module ParametersExample <ul> <li><code>beneficiary</code> bytes32 - the actual account that will receive the tokens on the relay chain</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send in Address format</li> <li><code>feeAssetItem</code> uint32 - the index of the asset that will be used to pay fees</li> </ul> <ul> <li><code>beneficiary</code> - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> </ul> transferAssetsLocation(dest, beneficiary, assets, feeAssetItem) \u2014 sends assets using the underlying <code>transfer_assets()</code> transaction included in the XCM pallet module ParametersExample <ul> <li><code>dest</code> Location memory - the destination chain</li> <li><code>beneficiary</code> Location memory - the account in the destination chain that will receive the tokens</li> <li><code>assets</code> AssetLocationInfo[] memory - an array of assets to send</li> <li><code>feeAssetItem</code> uint32 - the index of the asset that will be used to pay fees</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>beneficiary</code> - [0, [\"0x01f831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a0600\"]]</li> <li><code>assets</code> - [[[1, [\"0x010000000000000000000000000000000000000800\"]], 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> </ul> transferAssetsUsingTypeAndThenLocation(dest, assets, assetsTransferType, remoteFeesIdIndex, feesTransferType, customXcmOnDest) \u2014 sends assets through <code>transfer_assets_using_type_and_then()</code> pallet-xcm extrinsic. Important: RemoteReserve type (for either assets or fees) is prohibited. For sending assets and fees (in Location format) with a remote reserve, use the subsequent <code>transferAssetsUsingTypeAndThenLocation</code> which shares the same function name as this but takes a different set of parameters ParametersExample <ul> <li><code>dest</code> Location memory - the destination chain</li> <li><code>assets</code> AssetLocationInfo[] memory - an array of assets to send in Location format</li> <li><code>assetsTransferType</code> TransferType - the TransferType corresponding to assets being sent (Teleport = 0, LocalReserve = 1, DestinationReserve = 2)</li> <li><code>remoteFeesIdIndex</code> uint8 - the index of the asset (inside assets array) to use as fees</li> <li><code>feesTransferType</code> TransferType - the TransferType corresponding to the asset used as fees (Teleport = 0, LocalReserve = 1, DestinationReserve = 2)</li> <li><code>customXcmOnDest</code> bytes memory - the XCM message to execute on destination chain</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>assets</code> - [[[1, [\"0x010000000000000000000000000000000000000802\"]], 1000000000000000000]]</li> <li><code>assetsTransferType</code> - 0  </li> <li><code>remoteFeesIdIndex</code> - 0</li> <li><code>feesTransferType</code> - 1    </li> <li><code>customXcmOnDest</code> - 0x0408000400010403001300008a5d784563010d01020400010300f8234bedd9553e7668c4e0d60aced12e22bd2d45  </li> </ul> transferAssetsUsingTypeAndThenLocation(dest, assets, remoteFeesIdIndex, customXcmOnDest, remoteReserve) \u2014 sends assets through <code>transfer_assets_using_type_and_then()</code> pallet-xcm extrinsic. Important: The remote reserve must be shared between assets and fees ParametersExample <ul> <li><code>dest</code> Location memory - the destination chain</li> <li><code>assets</code> AssetLocationInfo[] memory - an array of assets to send in Location format</li> <li><code>remoteFeesIdIndex</code> uint8 - the index of the asset (inside assets array) to use as fees</li> <li><code>customXcmOnDest</code> bytes memory - the XCM message to execute on destination chain</li> <li><code>remoteReserve</code> Location memory - the remote reserve corresponding for assets and fees (must be shared)</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>assets</code> - [[[1, [\"0x010000000000000000000000000000000000000800\"]], 1000000000000000000]]</li> <li><code>remoteFeesIdIndex</code> - 0</li> <li><code>customXcmOnDest</code> - 0x0408000400010403001300008a5d784563010d01020400010300f8234bedd9553e7668c4e0d60aced12e22bd2d45  </li> <li><code>remoteReserve</code> - [1,[]]  </li> </ul> transferAssetsUsingTypeAndThenAddress(dest, assets, assetsTransferType, remoteFeesIdIndex, feesTransferType, customXcmOnDest) \u2014 sends assets through <code>transfer_assets_using_type_and_then()</code> pallet-xcm extrinsic. Important: RemoteReserve type (for either assets or fees) is not allowed. For sending assets and fees (in Address format) with a remote reserve, use the subsequent <code>transferAssetsUsingTypeAndThenAddress</code>, which shares the same name as this function but takes a different set of parameters ParametersExample <ul> <li><code>dest</code> Location memory - the destination chain</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send in Address format</li> <li><code>assetsTransferType</code> TransferType - the TransferType corresponding to assets being sent (Teleport = 0, LocalReserve = 1, DestinationReserve = 2)</li> <li><code>remoteFeesIdIndex</code> uint8 - the index of the asset (inside assets array) to use as fees</li> <li><code>feesTransferType</code> TransferType - the TransferType corresponding to the asset used as fees (Teleport = 0, LocalReserve = 1, DestinationReserve = 2)</li> <li><code>customXcmOnDest</code> bytes memory - the XCM message to execute on destination chain</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>assetsTransferType</code> - 0  </li> <li><code>remoteFeesIdIndex</code> - 0</li> <li><code>feesTransferType</code> - 1   </li> <li><code>customXcmOnDest</code> - 0x0408000400010403001300008a5d784563010d01020400010300f8234bedd9553e7668c4e0d60aced12e22bd2d45 </li> </ul> transferAssetsUsingTypeAndThenAddress(dest, assets, remoteFeesIdIndex, customXcmOnDest, remoteReserve) \u2014 sends assets through <code>transfer_assets_using_type_and_then()</code> pallet-xcm extrinsic. Important: The remote reserve must be shared between assets and fees ParametersExample <ul> <li><code>dest</code> Location memory - the destination chain</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send in Address format</li> <li><code>remoteFeesIdIndex</code> uint8 - the index of the asset (inside assets array) to use as fees</li> <li><code>customXcmOnDest</code> bytes memory - the XCM message to execute on destination chain</li> <li><code>remoteReserve</code> Location memory - the remote reserve corresponding for assets and fees (must be shared)</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000802\", 1000000000000000000]]</li> <li><code>remoteFeesIdIndex</code> - 0</li> <li><code>customXcmOnDest</code> - 0x0408000400010403001300008a5d784563010d01020400010300f8234bedd9553e7668c4e0d60aced12e22bd2d45</li> <li><code>remoteReserve</code> - [1,[]] </li> </ul>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow this tutorial, you must have your preferred EVM wallet configured and an account funded with native tokens. You can add Moonbeam to MetaMask wallet following this guide: Interacting with Moonbeam Using MetaMask.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#remix-set-up","title":"Remix Set Up","text":"<p>You can interact with the XCM Precompile using Remix. To add the precompile to Remix, you will need to:</p> <ol> <li>Get a copy of <code>XCMInterface.sol</code></li> <li>Paste the file contents into a Remix file named <code>XCMInterface.sol</code></li> </ol>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#compile-the-contract","title":"Compile the Contract","text":"<p>Next, you will need to compile the interface in Remix:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Compile the interface by clicking on Compile XcmInterface.sol</li> </ol> <p></p> <p>When the compilation is completed, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#access-the-contract","title":"Access the Contract","text":"<p>Instead of deploying the precompile, you will access the interface given the address of the precompiled contract:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note that the precompiled contracts are already accessible at their respective addresses. Therefore, there is no deployment step</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT dropdown. Once you select Injected Provider - Metamask, you may be prompted by MetaMask to connect your account to Remix if it's not already connected</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure XCM - XcmInterface.sol is selected in the CONTRACT dropdown. Given that it is a precompiled contract, there is no deployment step. Instead, you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the precompile: <code>0x000000000000000000000000000000000000081A</code> and click At Address</li> </ol> <p></p> <p>The XCM Interface precompile will appear in the list of Deployed Contracts.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#transfer-to-evm-chains","title":"Send Tokens Over to Another EVM-Compatible Appchain","text":"<p>To send tokens over to an account in another EVM-compatible appchain, please follow these steps:</p> <ol> <li>Expand the transferAssetsToPara20 function</li> <li>Enter the appchain ID (paraId)</li> <li>Enter the 20-byte (Ethereum-like) destination account (beneficiary)</li> <li>Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer</li> <li>Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is <code>0</code>, the second is <code>1</code>, and so on</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, wait a few blocks for the transfer to reach the destination chain and reflect the new balance.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#transfer-to-substrate-chains","title":"Send Tokens Over to a Substrate Appchain","text":"<p>To send tokens over to an account in a Substrate appchain, please follow these steps:</p> <ol> <li>Expand the transferAssetsToPara32 function</li> <li>Enter the appchain ID (<code>paraId</code>)</li> <li>Enter the sr25519-type destination account (beneficiary)</li> <li>Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer</li> </ol> <p>!!! note        There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p> <ol> <li>Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is <code>0</code>, the second is <code>1</code>, and so on</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, wait a few blocks for the transfer to reach the destination chain and reflect the new balance.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#transfer-to-relay-chain","title":"Send Tokens Over to the Relay Chain","text":"<p>To send tokens over to an account in the relay chain, please follow these steps:</p> <ol> <li>Expand the transferAssetsToRelay function</li> <li>Enter the sr25519-type destination account (beneficiary)</li> <li>Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer</li> </ol> <p>!!! note        There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p> <ol> <li>Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is <code>0</code>, the second is <code>1</code>, and so on</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, wait a few blocks for the transfer to reach the destination chain and reflect the new balance.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/eth-api/#transfer-locations","title":"Send Tokens Over Specific Locations","text":"<p>There are two methods that share names with closely related methods, <code>transferAssetsUsingTypeAndThenLocation</code> and <code>transferAssetsUsingTypeAndThenAddress</code>. However, these are not duplicates. For each function, there is one that accepts five parameters and another that accepts six. The function with five parameters can only be used when the remote reserve is shared between assets and fees. If the remote reserve is not shared between assets and fees, you can use the six parameter version of the method to specify the information needed.</p> <p>The following example will demonstrate <code>transferAssetsUsingTypeAndThenAddress</code> when the remote reverse is shared between assets and fees. To follow along with the tutorial, take the following steps:</p> <ol> <li>Expand the transferAssetsUsingTypeAndThenAddress function</li> <li>Enter the multilocation that specifies the destination chain. Note that any chain can be specified, regardless of its configuration or type</li> <li>Enter the combination array of assets to send in Address format</li> <li>Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is <code>0</code>, the second is <code>1</code>, and so on</li> <li>Enter the XCM message to be executed on destination chain. For more information about creating XCM call data see Send and Execute XCM Messages </li> <li>Enter the remote reserve, e.g. <code>[1,[]]</code></li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, wait a few blocks for the transfer to reach the destination chain and reflect the new balance.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/overview/","title":"Overview of XC-20 Transfers","text":""},{"location":"builders/interoperability/xcm/xc20/send-xc20s/overview/#introduction","title":"Introduction","text":"<p>Assets can move between parachains using XCM. Two main approaches exist:</p> <ul> <li>Asset teleporting \u2013 destroys tokens on the reserve chain and mints the same amount on the destination chain. Each chain holds the native asset as a reserve, similar to a burn-mint bridging mechanism. Because each chain can create tokens, a degree of trust is required</li> <li>Remote transfers \u2013 moves tokens from the reserve chain to a Sovereign account (an account on the reserve chain trustlessly controlled by the destination chain). The destination chain then mints a wrapped (also called \u201cvirtual\u201d or \u201ccross-chain\u201d) representation. This wrapped version is always interchangeable 1:1 with the original asset, functioning like a lock-mint and burn-unlock bridge. The chain where the asset originates is known as the reserve chain</li> </ul> <p></p> <p>Moonbeam currently uses remote transfers for XC-20 transfers.</p> <p>This page covers the fundamentals of XCM-based remote transfers. To learn how to perform XC-20 transfers, refer to the the XC-20 transfers via the Substrate API guide.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/overview/#xcm-instructions-for-asset-transfers","title":"XCM Instructions for Asset Transfers","text":"<p>The XCM Pallet and Precompile abstract much of the complexity involved in cross-chain asset transfers, automatically constructing the necessary XCM messages. Nevertheless, having a basic understanding of the underlying instructions can be useful. </p> <p>For reference, you can find the Polkadot XCM Pallet extrinsics for sending XC-20s in the Using the Polkadot XCM Pallet To Send XC-20s guide.</p> <p>The instructions in each XCM transfer vary depending on the asset and the transfer route. For example, returning a native token like xcDOT to its reserve chain (from Moonbeam to Polkadot) differs from sending DOT from Polkadot to Moonbeam. Below are examples of the instructions commonly involved in these token transfers.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/overview/#transfer-native-from-origin","title":"Instructions to Transfer a Reserve Asset from the Reserve Chain","text":"<p>When DOT is transferred from Polkadot to Moonbeam, the following XCM instructions are executed in sequence:</p> <ol> <li> <p><code>TransferReserveAsset</code> - executes on Polkadot, moving the DOT from the sender and depositing it into Moonbeam\u2019s Sovereign account on Polkadot</p> </li> <li> <p><code>ReserveAssetDeposited</code> - executes on Moonbeam, minting the corresponding ERC-20 representation of DOT (xcDOT) on Moonbeam</p> </li> <li> <p><code>ClearOrigin</code> - executes on Moonbeam, clearing any origin data\u2014previously set to Polkadot\u2019s Sovereign account</p> </li> <li> <p><code>BuyExecution</code> - executes on Moonbeam, determining the execution fees. Here, a portion of the newly minted xcDOT is used to pay the cost of XCM</p> </li> <li> <p><code>DepositAsset</code> - executes on Moonbeam, delivering the xcDOT to the intended recipient\u2019s account on Moonbeam</p> </li> </ol> <p>This process invokes <code>TransferReserveAsset</code> with <code>assets</code>, <code>dest</code>, and <code>xcm</code>parameters. Within the <code>xcm</code> parameter, you typically specify the <code>BuyExecution</code> and <code>DepositAsset</code> instructions. As shown in the <code>TransferReserveAsset</code> instruction, the flow also includes <code>ReserveAssetDeposited</code> and <code>ClearOrigin</code> to complete the transfer.</p> <p>For more information on constructing an XCM message for asset transfers, such as DOT to Moonbeam, refer to the Polkadot XCM Pallet guide.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/overview/#transfer-native-to-origin","title":"Instructions to Transfer a Reserve Asset back to the Reserve Chain","text":"<p>In scenarios where you want to move an asset back to its reserve chain, such as sending xcDOT from Moonbeam to Polkadot, Moonbeam uses the following set of XCM instructions:</p> <ol> <li> <p><code>WithdrawAsset</code> \u2013 executes on Moonbeam, taking the specified token (xcDOT) from the sender</p> </li> <li> <p><code>InitiateReserveWithdraw</code> \u2013 executes on Moonbeam, which, burns the token on Moonbeam (removing the wrapped representation), and sends an XCM message to Polkadot, indicating the tokens should be released there </p> </li> <li> <p><code>WithdrawAsset</code> \u2013 executes on Polkadot, removing the tokens from Moonbeam\u2019s Sovereign account on Polkadot</p> </li> <li> <p><code>ClearOrigin</code> \u2013 gets executed on Polkadot. Clears any origin data (e.g., the Sovereign account on Moonbeam)</p> </li> <li> <p><code>BuyExecution</code> \u2013 Polkadot determines the execution fees and uses part of the DOT being transferred to pay for them</p> </li> <li> <p><code>DepositAsset</code> \u2013 finally, the native DOT tokens are deposited into the specified Polkadot account</p> </li> </ol> <p>Steps 3 through 6 are automatically triggered by the <code>InitiateReserveWithdraw</code> instruction (step 2) and execute on Polkadot. Once <code>InitiateReserveWithdraw</code> is invoked on Moonbeam, the assembled XCM message instructs Polkadot to run those final instructions, completing the cross-chain transfer. In other words, while Moonbeam constructs the XCM instructions behind the scenes, they ultimately execute on Polkadot to complete the asset\u2019s return to its reserve chain.</p> <p>For more information on constructing an XCM message to transfer reserve assets to a target chain, such as xcDOT to Polkadot, you refer to the guide to the Polkadot XCM Pallet.</p> <p>Note</p> <p>The specific instructions may vary over time, but this overall flow remains consistent: the tokens are withdrawn from the user on Moonbeam, burned from the local representation, and unlocked on the reserve chain. At the end of the process, they become fully accessible again on their reserve chain.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/","title":"Using the Polkadot XCM Pallet To Send XC-20s","text":""},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#introduction","title":"Introduction","text":"<p>Note</p> <p>The Polkadot XCM Pallet replaces the deprecated XTokens Pallet. Accordingly, ensure that you are using the Polkadot XCM Pallet to interact with XC-20s.</p> <p>Manually crafting an XCM message for fungible asset transfers is a challenging task. Consequently, developers can leverage wrapper functions and pallets to use XCM features on Polkadot and Kusama. One example of such wrappers is the XCM Pallet, which provides different methods to transfer fungible assets via XCM.</p> <p>This guide will show you how to leverage the Polkadot XCM Pallet to send XC-20s from a Moonbeam-based network to other chains in the ecosystem (relay chain/parachains).</p> <p>Developers must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, testing XCM features on a TestNet is essential before moving to a production environment.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#nomenclature","title":"Nomenclature","text":"<p>Because there are various XCM-related pallets and precompiles with similar-sounding names, the following section will clarify the differences between each. </p> <ul> <li><code>PolkadotXCM</code> - this pallet (and the focus of this page) enables you to interact with XC-20s on Moonbeam, replacing the deprecated <code>XTokens</code> pallet </li> <li><code>pallet-xcm</code>- the general Polkadot XCM pallet allows you to interact with cross-chain assets. Moonbeam's <code>PolkadotXCM</code> pallet is essentially a wrapper of <code>pallet-xcm</code>. Because of this, you may see <code>PolkadotXCM</code> and <code>pallet-xcm</code> referred to interchangeably</li> <li><code>XTokens</code> - This pallet is now deprecated and replaced by <code>PolkadotXCM</code></li> <li><code>XCMInterface.sol</code> - This precompile is the solidity interface that replaces <code>XTokens.sol</code> and enables you to interact with the methods of <code>PolkadotXCM</code> from the EVM via a solidity interface</li> </ul>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#polkadotxcm-pallet-interface","title":"Polkadot XCM Pallet Interface","text":""},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#extrinsics","title":"Extrinsics","text":"<p>The Polkadot XCM Pallet provides the following extrinsics (functions):</p> forceDefaultXcmVersion(maybeXcmVersion) \u2014 sets a safe default XCM version for message encoding (admin origins only) Parameters <ul> <li><code>maybeXcmVersion</code> - the default XCM encoding version to be used when a destination's supported version is unknown. Can be either:<ul> <li>A version number</li> <li><code>None</code> to disable the default version setting</li> </ul> </li> </ul> transferAssets(dest, beneficiary, assets, feeAssetItem, weightLimit) \u2014 transfers assets from the local chain to a destination chain using reserve or teleport methods Parameters <ul> <li><code>dest</code> - the destination context for the assets. Typically specified as:<ul> <li><code>X2(Parent, Parachain(..))</code> for parachain to parachain transfers</li> <li><code>X1(Parachain(..))</code> for relay to parachain transfers</li> </ul> </li> <li><code>beneficiary</code> - the recipient location in the context of the destination. Generally an <code>AccountId32</code> value</li> <li><code>assets</code> - the assets to be transferred. Must:<ul> <li>Have the same reserve location or be teleportable to destination (excluding fee assets)</li> <li>Include assets for fee payment</li> </ul> </li> <li><code>feeAssetItem</code> - the index in the <code>assets</code> array indicating which asset should be used to pay fees</li> <li><code>weightLimit</code> - the weight limit for XCM fee purchase on the destination chain. Can be defined as:<ul> <li><code>Unlimited</code> - allows an unlimited amount of weight</li> <li><code>Limited</code> - specifies a maximum weight value</li> </ul> </li> </ul> <p>The transfer behavior varies based on asset type:</p> <ul> <li> <p>Local Reserve: </p> <ul> <li>Transfers assets to destination chain's sovereign account</li> <li>Sends XCM to mint and deposit reserve-based assets to beneficiary</li> </ul> </li> <li> <p>Destination Reserve:</p> <ul> <li>Burns local assets</li> <li>Notifies destination to withdraw reserves from this chain's sovereign account</li> <li>Deposits to beneficiary</li> </ul> </li> <li> <p>Remote Reserve:</p> <ul> <li>Burns local assets</li> <li>Sends XCM to move reserves between sovereign accounts</li> <li>Notifies destination to mint and deposit to beneficiary</li> </ul> </li> <li> <p>Teleport:</p> <ul> <li>Burns local assets</li> <li>Sends XCM to mint/teleport assets and deposit to beneficiary</li> </ul> </li> </ul> <p>As a reminder, the origin must be capable of both withdrawing the specified assets and executing XCM. If more weight is needed than specified in <code>weightLimit</code>, the operation will fail and teleported assets may be at risk</p> transferAssetsUsingTypeAndThen(dest, assets, assetsTransferType, remoteFeesId, feesTransferType, customXcmOnDest, weightLimit) \u2014 transfers assets with explicit transfer types and custom destination behavior Parameters <ul> <li><code>dest</code> - the destination context for the assets. Can be specified as:<ul> <li><code>[Parent, Parachain(..)]</code> for parachain to parachain transfers</li> <li><code>[Parachain(..)]</code> for relay to parachain transfers</li> <li><code>(parents: 2, (GlobalConsensus(..), ..))</code> for cross-bridge ecosystem transfers</li> </ul> </li> <li><code>assets</code> - the assets to be transferred. Must either:<ul> <li>Have the same reserve location</li> <li>Be teleportable to destination</li> </ul> </li> <li><code>assetsTransferType</code> - specifies how the main assets should be transferred:<ul> <li><code>LocalReserve</code> - transfers to sovereign account, mints at destination</li> <li><code>DestinationReserve</code> - burns locally, withdraws from sovereign account at destination</li> <li><code>RemoteReserve(reserve)</code> - burns locally, moves reserves through specified chain (typically Asset Hub)</li> <li><code>Teleport</code> - burns locally, mints/teleports at destination</li> </ul> </li> <li><code>remoteFeesId</code> - specifies which of the included assets should be used for fee payment</li> <li><code>feesTransferType</code> - specifies how the fee payment asset should be transferred (same options as <code>assetsTransferType</code>)</li> <li><code>customXcmOnDest</code> - XCM instructions to execute on the destination chain as the final step. Typically used to:<ul> <li>Deposit assets to beneficiary: <code>Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])</code></li> <li>Or perform more complex operations with the transferred assets</li> </ul> </li> <li><code>weightLimit</code> - the weight limit for XCM fee purchase on the destination chain. Can be defined as:<ul> <li><code>Unlimited</code> - allows an unlimited amount of weight</li> <li><code>Limited</code> - specifies a maximum weight value</li> </ul> </li> </ul> <p>A few reminders:</p> <ul> <li><code>BuyExecution</code> is used to purchase execution time using the specified <code>remoteFeesId</code> asset</li> <li>Fee payment asset can use a different transfer type than the main assets</li> <li>The origin must be capable of both withdrawing the specified assets and executing XCM</li> <li>If more weight is needed than specified in <code>weightLimit</code>, the operation will fail and transferred assets may be at risk</li> </ul>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#storage-methods","title":"Storage Methods","text":"<p>The Polkadot XCM Pallet includes the following read-only storage methods. Note, this is not an exhaustive list. To see the current available storage methods, check the Chain State of Polkadot.js Apps.</p> assetTraps(h256 hash) \u2014 returns the count of trapped assets for a given hash ParametersReturnsPolkadot.js API Example <ul> <li><code>hash</code>: <code>H256</code> - The hash identifier for the asset trap. When an asset is trapped, a unique hash identifier is assigned to it. You can omit this field to return information about all assets trapped</li> </ul> <p>Returns a <code>U32</code> (unsigned 32-bit integer) representing the number of times an asset has been trapped at this hash location. <pre><code>// Example return values showing hash \u2192 count mappings\n[\n  [[0x0140f264543926e689aeefed15a8379f6e75a8c6884b0cef0832bb913a343b53], 1],\n  [[0x0d14fd8859d8ff15dfe4d4002b402395129cdc4b69dea5575efa1dc205b96020], 425],\n  [[0x166f82439fd2b25b28b82224e82ad9f26f2da26b8257e047182a6a7031accc9a], 3]\n]\n</code></pre></p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://wss.api.moonbeam.network'),\n  });\n\n  const hash =\n    '0x166f82439fd2b25b28b82224e82ad9f26f2da26b8257e047182a6a7031accc9a';\n  const trapCount = await api.query.polkadotXcm.assetTraps(hash);\n\n  console.log('Trap count:', trapCount.toNumber());\n};\n\nmain();\n</code></pre> queryCounter() \u2014 the latest available query index ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u64</code> - The latest available query index</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://wss.api.moonbeam.network'),\n  });\n\n  const queryIndex = await api.query.polkadotXcm.queryCounter();\n\n  console.log('Query Index:', queryIndex.toNumber());\n};\n\nmain();\n</code></pre> safeXcmVersion() \u2014 default version to encode XCM when destination version is unknown ParametersReturnsPolkadot.js API Example <p>None</p> <p><code>u32</code> - default version to encode XCM when destination version is unknown</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://wss.api.moonbeam.network'),\n  });\n\n  const safeVersion = await api.query.polkadotXcm.safeXcmVersion();\n\n  console.log('Safe XCM Version:', safeVersion.toHuman());\n};\n\nmain();\n</code></pre> supportedVersion(XcmVersion, Multilocation) \u2014 returns the supported XCM version for a given location ParametersReturnsPolkadot.js API Example <ul> <li>version <code>u32</code>: XcmVersion - The version number to check</li> <li>location: MultiLocation - The location to check for version support</li> </ul> <p>Returns a mapping of locations to their supported XCM versions. Each entry contains a MultiLocation specifying the parachain location (including parent and interior information) and an XcmVersion number indicating the supported version</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({\n    provider: new WsProvider('wss://wss.api.moonbase.moonbeam.network'),\n  });\n\n  const testLocation = {\n    V4: {\n      parents: 1,\n      interior: 'Here',\n    },\n  };\n\n  const supportedVersion = await api.query.polkadotXcm.supportedVersion(\n    4, // Testing XCM v4\n    testLocation\n  );\n\n  console.log('Location:', JSON.stringify(testLocation, null, 2));\n  console.log('Supported Version:', supportedVersion.toHuman());\n};\n\nmain();\n</code></pre> palletVersion() \u2014 returns current pallet version from storage ParametersReturnsPolkadot.js API Example <p>None</p> <p>A number representing the current version of the pallet.</p> <pre><code>// If using Polkadot.js API and calling toJSON() on the unwrapped value\n0\n</code></pre> <pre><code> import { ApiPromise, WsProvider } from '@polkadot/api';\n\n const main = async () =&gt; {\n   const api = await ApiPromise.create({\n     provider: new WsProvider('wss://wss.api.moonbase.moonbeam.network'),\n   });\n   const palletVersion = await api.query.polkadotXcm.palletVersion();\n   console.log(\"The pallet version is \" + palletVersion);\n };\n\n main();\n</code></pre>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#constants","title":"Pallet Constants","text":"<p>There are no constants part of the Polkadot XCM pallet.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#build-with-PolkadotXCM-pallet","title":"Building an XCM Message with the Polkadot XCM Pallet","text":"<p>This guide covers the process of building an XCM message using the Polkadot XCM Pallet, specifically the <code>transferAssets</code> function.</p> <p>Note</p> <p>Each parachain can allow and forbid specific methods from a pallet. Consequently, developers must ensure that they use methods that are allowed, or the transaction will fail with an error similar to <code>system.CallFiltered</code>.</p> <p>You'll be transferring xcUNIT tokens, which are the XC-20 representation of the Alphanet relay chain token, UNIT. You can adapt this guide for any other XC-20.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#polkadotxcm-check-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with the examples in this guide, you need to have the following:</p> <ul> <li>An account with funds.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li> <p>Some xcUNIT tokens. You can swap DEV tokens (Moonbase Alpha's native token) for xcUNITs on Moonbeam-Swap, a demo Uniswap-V2 clone on Moonbase Alpha</p> <p>Note</p> <p>You can adapt this guide to transfer another external XC-20 or a local XC-20. For external XC-20s, you'll need the asset ID and the number of decimals the asset has. For local XC-20s, you'll need the contract address.</p> <p></p> </li> </ul> <p>To check your xcUNIT balance, you can add the XC-20's precompile address to MetaMask with the following address:</p> <pre><code>0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080\n</code></pre>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#polkadotxcm-transfer-assets-function","title":"Polkadot XCM Transfer Assets Function","text":"<p>In this example, you'll build an XCM message to transfer xcUNIT from Moonbase Alpha back to the Alphanet relay chain through the <code>transferAssets</code> function of the Polkadot XCM Pallet using the Polkadot.js API.</p> <p>To perform a limited reserve transfer using the <code>polkadotXcm</code> pallet, follow these steps:</p> <ol> <li> <p>Install the required dependencies: <code>@polkadot/api</code> for blockchain interaction, <code>@polkadot/util</code> for utility functions, and <code>@polkadot/util-crypto</code> for cryptographic functions.</p> </li> <li> <p>Set up your network connection by creating a WebSocket provider using the Moonbase Alpha endpoint: <code>wss://wss.api.moonbase.moonbeam.network</code>. Initialize the Polkadot API with this provider.</p> </li> <li> <p>Configure your account using the Ethereum format. Create a keyring instance for Ethereum addresses, then add your account using your private key. Remember to prepend the private key with <code>0x</code>, which is omitted when exporting your keys from MetaMask </p> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a JavaScript file.</p> </li> <li> <p>Prepare the destination address by converting the SS58 format address to raw bytes using the <code>decodeAddress</code> function. If the destination SS58 address is already in hexadecimal format, no conversion is needed </p> </li> <li> <p>Construct the XCM transfer transaction with: the relay chain as the destination (parent chain with <code>parents: 1</code>), beneficiary (using <code>AccountId32</code> format), assets (amount with 12 decimals), fee asset item (0), and weight limit ('Unlimited').</p> Define the destination, beneficiary, and asset <pre><code> // dest\n      {\n        V4: {\n          parents: 1,\n          interior: {\n            Here: null\n          }\n        }\n      },\n      // beneficiary\n      {\n        V4: {\n          parents: 1,                   \n          interior: {\n            X1: [                        \n              {\n                AccountId32: {\n                  id: Array.from(beneficiaryRaw),\n                  network: null\n                }\n              }\n            ]\n          }\n        }\n      },\n      // assets\n      {\n        V4: [                           \n          {\n            fun: {                      \n              Fungible: 1000000000000n \n            },\n            id: {                       \n              parents: 1,\n              interior: {\n                Here: null              \n              }\n            }\n          }\n        ]\n      },\n      0,           // feeAssetItem\n      'Unlimited'  // weightLimit\n    );\n</code></pre> </li> <li> <p>Submit your transaction and implement monitoring logic with error handling </p> </li> <li> <p>Once the transaction is finalized, the script will automatically exit. Any errors during the process will be logged to the console for troubleshooting</p> </li> </ol> View the full script <pre><code>import { ApiPromise, WsProvider, Keyring } from '@polkadot/api';\nimport { decodeAddress } from '@polkadot/util-crypto';\n\nconst main = async () =&gt; {\n  // Setup provider and API\n  const wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Setup account with ethereum format\n  const keyring = new Keyring({ type: 'ethereum' });\n  const account = keyring.addFromUri('INSERT_PRIVATE_KEY');\n\n  // Convert the SS58 address to raw bytes\n  const beneficiaryRaw = decodeAddress('INSERT_DESTINATION_ADDRESS');\n\n  try {\n    // Create the transaction (XCM v4)\n    const tx = api.tx.polkadotXcm.transferAssets(\n      // Destination (V4)\n      {\n        V4: {\n          parents: 1,\n          interior: {\n            Here: null\n          }\n        }\n      },\n      // Beneficiary (V4)\n      {\n        V4: {\n          parents: 1,\n          interior: {\n            X1: [\n              {\n                AccountId32: {\n                  network: null,\n                  id: beneficiaryRaw\n                }\n              }\n            ]\n          }\n        }\n      },\n      // Assets (V4)\n      {\n        V4: [\n          {\n            fun: {\n              Fungible: 1000000000000n\n            },\n            id: {\n              parents: 1,\n              interior: {\n                Here: null\n              }\n            }\n          }\n        ]\n      },\n      0,           // feeAssetItem\n      'Unlimited'  // weightLimit\n    );\n\n    // Sign and send the transaction\n    const unsub = await tx.signAndSend(account, ({ status }) =&gt; {\n      if (status.isInBlock) {\n        console.log(`Transaction included in blockHash ${status.asInBlock}`);\n      } else if (status.isFinalized) {\n        console.log(`Transaction finalized in blockHash ${status.asFinalized}`);\n        unsub();\n        process.exit(0);\n      }\n    });\n  } catch (error) {\n    console.error('Error:', error);\n    process.exit(1);\n  }\n};\n\nmain().catch(console.error);\n</code></pre> <p>Note</p> <p>You can view an example of the above script, which sends 1 xcUNIT to Alice's account on the relay chain, on Polkadot.js Apps using the following encoded calldata: <code>0x1c0b0401000400010100d4620637e11439598c5fbae0506dc68b9fb1edb33b316761bf99987a1034a96b0404010000070010a5d4e80000000000</code>.</p> <p>Once the transaction is processed, the target account on the relay chain should have received the transferred amount minus a small fee that is deducted to execute the XCM on the destination chain. </p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xcm-pallet/#troubleshooting","title":"Troubleshooting","text":"<p>If you're having difficulty replicating the demo, take the following troubleshooting steps:</p> <ul> <li>Ensure your sending account is funded with DEV tokens </li> <li>Ensure your sending account is funded with xcUNIT tokens (or another XC-20 that you have specified)</li> <li>Check the Explorer on Polkadot.js Apps on Moonbase Alpha to ensure a successful transaction on the origin chain</li> <li>Check the Explorer on Polkadot.js Apps and review the XCM messages received on Moonbase Relay Chain</li> </ul>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/","title":"Using the X-Tokens Precompile To Send XC-20s","text":""},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#introduction","title":"Introduction","text":"<p>Building an XCM message for fungible asset transfers is not an easy task. Consequently, there are wrapper functions and pallets that developers can leverage to use XCM features on Polkadot and Kusama. One example of such wrappers is the Polkadot XCM Pallet, which provides different methods to transfer fungible assets via XCM.</p> <p>The Polkadot XCM Pallet is coded in Rust and is normally not accessible from the Ethereum API side of Moonbeam. However, the XCM Precompile and the X-Tokens Precompile allow you to interact directly with the Polkadot XCM pallet to send XC-20s from a Solidity interface.</p> <p>This guide will show you how to leverage the X-Tokens Precompile to send XC-20s from a Moonbeam-based network to other chains in the ecosystem (relay chain/parachains) using Ethereum libraries like Ethers and Web3.</p> <p>Developers must understand that sending incorrect XCM messages can result in the loss of funds. Consequently, it is essential to test XCM features on a TestNet before moving to a production environment.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#contract-address","title":"X-Tokens Precompile Contract Address","text":"<p>The X-Tokens Precompile is located at the following addresses:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000804\n</code></pre> <pre><code>0x0000000000000000000000000000000000000804\n</code></pre> <pre><code>0x0000000000000000000000000000000000000804\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#xtokens-solidity-interface","title":"The X-Tokens Solidity Interface","text":"<p>Xtokens.sol is an interface through which developers can interact with the X-Tokens Pallet using the Ethereum API.</p> Xtokens.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Xtokens contract's address.\naddress constant XTOKENS_ADDRESS = 0x0000000000000000000000000000000000000804;\n\n/// @dev The Xtokens contract's instance.\nXtokens constant XTOKENS_CONTRACT = Xtokens(XTOKENS_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Xtokens Interface\n/// @dev The interface through which solidity contracts will interact with xtokens pallet\n/// @custom:address 0x0000000000000000000000000000000000000804\ninterface Xtokens {\n    // A multilocation is defined by its number of parents and the encoded junctions (interior)\n    struct Multilocation {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    // A MultiAsset is defined by a multilocation and an amount\n    struct MultiAsset {\n        Multilocation location;\n        uint256 amount;\n    }\n\n    // A Currency is defined by address and the amount to be transferred\n    struct Currency {\n        address currencyAddress;\n        uint256 amount;\n    }\n\n    /// Transfer a token through XCM based on its currencyId\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param currencyAddress The ERC20 address of the currency we want to transfer\n    /// @param amount The amount of tokens we want to transfer\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector b9f813ff\n    function transfer(\n        address currencyAddress,\n        uint256 amount,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer a token through XCM based on its currencyId specifying fee\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param currencyAddress The ERC20 address of the currency we want to transfer\n    /// @param amount The amount of tokens we want to transfer\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector 3e506ef0\n    function transferWithFee(\n        address currencyAddress,\n        uint256 amount,\n        uint256 fee,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer a token through XCM based on its MultiLocation\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param asset The asset we want to transfer, defined by its multilocation.\n    /// Currently only Concrete Fungible assets\n    /// @param amount The amount of tokens we want to transfer\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector b4f76f96\n    function transferMultiasset(\n        Multilocation memory asset,\n        uint256 amount,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer a token through XCM based on its MultiLocation specifying fee\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param asset The asset we want to transfer, defined by its multilocation.\n    /// Currently only Concrete Fungible assets\n    /// @param amount The amount of tokens we want to transfer\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector 150c016a\n    function transferMultiassetWithFee(\n        Multilocation memory asset,\n        uint256 amount,\n        uint256 fee,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer several tokens at once through XCM based on its address specifying fee\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param currencies The currencies we want to transfer, defined by their address and amount.\n    /// @param feeItem Which of the currencies to be used as fee\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector ab946323\n    function transferMultiCurrencies(\n        Currency[] memory currencies,\n        uint32 feeItem,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n\n    /// Transfer several tokens at once through XCM based on its location specifying fee\n    ///\n    /// @dev The token transfer burns/transfers the corresponding amount before sending\n    /// @param assets The assets we want to transfer, defined by their location and amount.\n    /// @param feeItem Which of the currencies to be used as fee\n    /// @param destination The Multilocation to which we want to send the tokens\n    /// @param weight The weight we want to buy in the destination chain \n    /// (uint64::MAX means Unlimited weight)\n    /// @custom:selector 797b45fd\n    function transferMultiAssets(\n        MultiAsset[] memory assets,\n        uint32 feeItem,\n        Multilocation memory destination,\n        uint64 weight\n    ) external;\n}\n</code></pre> <p>The interface includes the following functions:</p> transfer(address currencyAddress, uint256 amount, Multilocation memory destination, uint64 weight) \u2014 transfer a currency, given the contract address of the currency Parameters <ul> <li><code>currencyAddress</code> - the address of the asset to transfer<ul> <li>For External XC-20s, provide the XC-20 precompile address</li> <li>For native tokens (i.e., GLMR, MOVR, and DEV), provide the ERC-20 precompile address, which is <code>0x0000000000000000000000000000000000000802</code></li> <li>For Local XC-20s, provide the token's address</li> </ul> </li> <li><code>amount</code> - the number of tokens that are going to be sent via XCM</li> <li><code>destination</code> - the multilocation of the destination address for the tokens being sent via XCM. It supports different address formats, such as 20- or 32-byte addresses (Ethereum or Substrate). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>weight</code> - the weight to be purchased to pay for XCM execution on the destination chain, which is charged from the transferred asset</li> </ul> transferWithFee(address currencyAddress, uint256 amount, uint256 fee, Multilocation memory destination, uint64 weight) \u2014 transfer a currency, defined as either the native token (self-reserved) or the asset ID, and specify the fee separately from the amount Parameters <ul> <li><code>currencyAddress</code> - the address of the asset to transfer<ul> <li>For External XC-20s, provide the XC-20 precompile address</li> <li>For native tokens (i.e., GLMR, MOVR, and DEV), provide the ERC-20 precompile address, which is <code>0x0000000000000000000000000000000000000802</code></li> <li>For Local XC-20s, provide the token's address</li> </ul> </li> <li><code>amount</code> - the number of tokens that are going to be sent via XCM</li> <li><code>fee</code> \u2014 the amount to be spent to pay for the XCM execution in the target (destination) chain. If this value is not high enough to cover execution costs, the assets will be trapped in the destination chain</li> <li><code>destination</code> - the multilocation of the destination address for the tokens being sent via XCM. It supports different address formats, such as 20- or 32-byte addresses (Ethereum or Substrate). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>weight</code> - the weight to be purchased to pay for XCM execution on the destination chain, which is charged from the transferred asset</li> </ul> transferMultiasset(Multilocation memory asset, uint256 amount, Multilocation memory destination, uint64 weight) \u2014 transfer a fungible asset, defined by its multilocation Parameters <ul> <li><code>asset</code> - the multilocation of the asset to transfer. The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>amount</code> - the number of tokens that are going to be sent via XCM</li> <li><code>destination</code> - the multilocation of the destination address for the tokens being sent via XCM. It supports different address formats, such as 20- or 32-byte addresses (Ethereum or Substrate). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>weight</code> - the weight to be purchased to pay for XCM execution on the destination chain, which is charged from the transferred asset</li> </ul> transferMultiassetWithFee(Multilocation memory asset, uint256 amount, uint256 fee, Multilocation memory destination, uint64 weight) \u2014 transfer a fungible asset, defined by its multilocation, and pay the fee with a different asset, also defined by its multilocation Parameters <ul> <li><code>asset</code> - the multilocation of the asset to transfer. The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>amount</code> - the number of tokens that are going to be sent via XCM</li> <li><code>fee</code> \u2014 the amount to be spent to pay for the XCM execution in the target (destination) chain. If this value is not high enough to cover execution costs, the assets will be trapped in the destination chain</li> <li><code>destination</code> - the multilocation of the destination address for the tokens being sent via XCM. It supports different address formats, such as 20- or 32-byte addresses (Ethereum or Substrate). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>weight</code> - the weight to be purchased to pay for XCM execution on the destination chain, which is charged from the transferred asset</li> </ul> transferMulticurrencies(Currency[] memory currencies, uint32 feeItem, Multilocation memory destination, uint64 weight) \u2014 transfer different currencies, specifying which is used as the fee. Each currency is defined as either the native token (self-reserved) or the asset ID Parameters <ul> <li><code>currencies</code> - an array of the currencies to send, which are identified by their currency address, and the amount to send</li> <li><code>feeItem</code> \u2014 an index to define the asset position of an array of assets being sent, used to pay for the XCM execution in the target chain. For example, if only one asset is being sent, the <code>feeItem</code> would be <code>0</code></li> <li><code>destination</code> - the multilocation of the destination address for the tokens being sent via XCM. It supports different address formats, such as 20- or 32-byte addresses (Ethereum or Substrate). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>weight</code> - the weight to be purchased to pay for XCM execution on the destination chain, which is charged from the transferred asset</li> </ul> transferMultiassets(MultiAsset[] memory assets, uint32 feeItem, Multilocation memory destination, uint64 weight) \u2014 transfer several fungible assets, defined by their multilocation, and pay the fee with one of the assets, also defined by its multilocation Parameters <ul> <li><code>assets</code> - an array of the multilocations of each asset to transfer. The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>feeItem</code> \u2014 an index to define the asset position of an array of assets being sent, used to pay for the XCM execution in the target chain. For example, if only one asset is being sent, the <code>feeItem</code> would be <code>0</code></li> <li><code>destination</code> - the multilocation of the destination address for the tokens being sent via XCM. It supports different address formats, such as 20- or 32-byte addresses (Ethereum or Substrate). The multilocation must be formatted in a particular way, which is described in the Building the Precompile Multilocation section</li> <li><code>weight</code> - the weight to be purchased to pay for XCM execution on the destination chain, which is charged from the transferred asset</li> </ul>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#building-the-precompile-multilocation","title":"Building the Precompile Multilocation","text":"<p>Multilocations define a specific point in the entire relay chain/parachain ecosystem relative to a given origin. They are frequently used by the X-Tokens Precompile to define the location of assets and destination chains and accounts.</p> <p>Multilocations need to be formatted in a specific way that precompiles can understand, which is different than the format seen when interacting with pallets. In the X-Tokens Precompile interface, the <code>Multilocation</code> structure is defined as follows:</p> <pre><code> struct Multilocation {\n    uint8 parents;\n    bytes[] interior;\n}\n</code></pre> <p>As with a standard multilocation, there are <code>parents</code> and <code>interior</code> elements. However, instead of defining the multilocation as an object, with Ethereum libraries, the struct is defined as an array, which contains a <code>uint8</code> for the <code>parents</code> as the first element and a bytes array for the <code>interior</code> as the second element.</p> <p>The normal values you would see for the <code>parents</code> element are:</p> Origin Destination Parents Value Parachain A Parachain A 0 Parachain A Relay Chain 1 Parachain A Parachain B 1 <p>For the <code>interior</code> element, the number of fields you need to drill down to in the target chain to reach the exact location of the target, such as the specific asset or account, represents the size of the bytes array:</p> Array Size Interior Value [] 0 Here [XYZ] 1 X1 [XYZ, ABC] 2 X2 [XYZ, ... N] N XN <p>Note</p> <p>Interior value <code>Here</code> is often used for the relay chain (either as a destination or to target the relay chain asset).</p> <p>Each field required to reach the exact location of the target needs to be defined as a hex string. The first byte (2 hexadecimal characters) corresponds to the selector of the field. For example:</p> Byte Value Selector Data Type 0x00 Parachain bytes4 0x01 AccountId32 bytes32 0x02 AccountIndex64 u64 0x03 AccountKey20 bytes20 0x04 PalletInstance byte 0x05 GeneralIndex u128 0x06 GeneralKey bytes[] <p>Next, depending on the selector and its data type, the following bytes correspond to the actual data being provided. Note that for <code>AccountId32</code>, <code>AccountIndex64</code>, and <code>AccountKey20</code>, the optional <code>network</code> field is appended at the end. For example:</p> Selector Data Value Represents Parachain \"0x00+000007E7\" Parachain ID 2023 AccountId32 \"0x01+AccountId32+00\" AccountId32, Network(Option) Null AccountId32 \"0x01+AccountId32+03\" AccountId32, Network Polkadot AccountKey20 \"0x03+AccountKey20+00\" AccountKey20, Network(Option) Null PalletInstance \"0x04+03\" Pallet Instance 3 <p>Note</p> <p>The <code>interior</code> data usually needs to be wrapped around quotes, or you might get an <code>invalid tuple value</code> error.</p> <p>The following code snippet goes through some examples of multilocation structures, as they would need to be fed into the X-Tokens Precompile functions:</p> <pre><code>// Multilocation targeting the relay chain or its asset from a parachain\n[\n  1, // parents = 1\n  [], // interior = here\n]\n\n// Multilocation targeting Moonbase Alpha DEV token from another parachain\n[\n  1, // parents = 1\n  [  // interior = X2 (the array has a length of 2)\n    '0x00000003E8', // Parachain selector + Parachain ID 1000 (Moonbase Alpha)\n    '0x0403', // Pallet Instance selector + Pallet Instance 3 (Balances Pallet)\n  ],\n]\n\n// Multilocation targeting Alice's account on the relay chain from Moonbase Alpha\n[\n  1, // parents = 1\n  [  // interior = X1 (the array has a length of 1)\n     // AccountKey32 selector + AccountId32 address in hex + Network(Option) Null\n    '0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300', \n  ],\n]\n</code></pre>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#build-xcm-xtokens-precompile","title":"Building an XCM Message","text":"<p>This guide covers the process of building an XCM message using the X-Tokens Precompile, more specifically, with the <code>transfer</code> and <code>transferMultiasset</code> functions. Nevertheless, these two cases can be extrapolated to the other functions of the precompile, especially once you become familiar with multilocations.</p> <p>You'll be transferring xcUNIT tokens, which are the XC-20 representation of the Alphanet relay chain token, UNIT. You can adapt this guide for any other XC-20.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#xtokens-check-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with the examples in this guide, you need to have the following:</p> <ul> <li> <p>The ABI of the X-Tokens Precompile</p> X-Tokens Precompile ABI <pre><code>export default [\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'currencyAddress',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transfer',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              {\n                internalType: 'uint8',\n                name: 'parents',\n                type: 'uint8',\n              },\n              {\n                internalType: 'bytes[]',\n                name: 'interior',\n                type: 'bytes[]',\n              },\n            ],\n            internalType: 'struct Xtokens.Multilocation',\n            name: 'location',\n            type: 'tuple',\n          },\n          {\n            internalType: 'uint256',\n            name: 'amount',\n            type: 'uint256',\n          },\n        ],\n        internalType: 'struct Xtokens.MultiAsset[]',\n        name: 'assets',\n        type: 'tuple[]',\n      },\n      {\n        internalType: 'uint32',\n        name: 'feeItem',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferMultiAssets',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'address',\n            name: 'currencyAddress',\n            type: 'address',\n          },\n          {\n            internalType: 'uint256',\n            name: 'amount',\n            type: 'uint256',\n          },\n        ],\n        internalType: 'struct Xtokens.Currency[]',\n        name: 'currencies',\n        type: 'tuple[]',\n      },\n      {\n        internalType: 'uint32',\n        name: 'feeItem',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferMultiCurrencies',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'asset',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferMultiasset',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'asset',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: 'fee',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferMultiassetWithFee',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'currencyAddress',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: 'fee',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'parents',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'interior',\n            type: 'bytes[]',\n          },\n        ],\n        internalType: 'struct Xtokens.Multilocation',\n        name: 'destination',\n        type: 'tuple',\n      },\n      {\n        internalType: 'uint64',\n        name: 'weight',\n        type: 'uint64',\n      },\n    ],\n    name: 'transferWithFee',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n</code></pre> </li> <li> <p>An account with funds.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</p> </li> <li> <p>Some xcUNIT tokens. You can swap DEV tokens (Moonbase Alpha's native token) for xcUNITs on Moonbeam-Swap, a demo Uniswap-V2 clone on Moonbase Alpha</p> <p>Note</p> <p>You can adapt this guide to transfer another external XC-20 or a local XC-20. For external XC-20s, you'll need the asset ID and the number of decimals the asset has. For local XC-20s, you'll need the contract address.</p> <p></p> <p>To check your xcUNIT balance, you can add the XC-20's precompile address to MetaMask with the following address:</p> <pre><code>0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080\n</code></pre> </li> </ul> <p>Note</p> <p>To test out the examples on Moonbeam or Moonriver, you can replace the RPC URL with your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#determining-weight","title":"Determining Weight Needed for XCM Execution","text":"<p>To determine the weight needed for XCM execution on the destination chain, you'll need to know which XCM instructions are executed on the destination chain. You can find an overview of the XCM instructions used in the XCM Instructions for Transfers via X-Tokens guide.</p> <p>Note</p> <p>Some weights include database reads and writes; for example, the <code>WithdrawAsset</code> and <code>DepositAsset</code> instructions include both one database read and one write. To get the total weight, you'll need to add the weight of any required database reads or writes to the base weight of the given instruction.</p> <p>For Westend-based relay chains, like Alphanet, you can get the weight cost for read and write database operations for Rocks DB (which is the default database) in the polkadot-sdk repository on GitHub.</p> <p>Since Alphanet is a Westend-based relay chain, you can refer to the instruction weights defined in the Westend runtime code, which are broken up into two types of instructions: fungible and generic.</p> <p>It's important to note that each chain defines its own weight requirements. To determine the weight required for each XCM instruction on a given chain, please refer to the chain's documentation or reach out to a member of their team. To learn how to find the weights required by Moonbeam, Polkadot, or Kusama, you can refer to our documentation on Weights and Fees.</p>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#precompile-transfer","title":"X-Tokens Precompile Transfer Function","text":"<p>To use the <code>transfer</code> function of the X-Tokens Precompile, you'll take these general steps:</p> <ol> <li>Create a provider using a Moonbase Alpha RPC endpoint</li> <li>Create a signer to send the transaction. This example uses a private key to create the signer and is for demo purposes only. Never store your private key in a JavaScript file</li> <li>Create a contract instance of the X-Tokens Precompile using the address and ABI of the precompile</li> <li> <p>Assemble the arguments for the <code>transfer</code> function:</p> <ul> <li><code>currencyAddress</code> - the address for xcUNIT: <code>0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080</code></li> <li><code>amount</code> - 1 xcUNIT. Since xcUNIT has 12 decimals, you can use: <code>1000000000000</code></li> <li><code>destination</code> - the multilocation of the destination, which targets Alice's account on the relay chain: <code>'0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'</code></li> <li><code>weight</code> - the weight to purchase for the XCM execution on the destination chain: <code>305,986,000</code></li> </ul> </li> <li> <p>Create the <code>transfer</code> function, passing in the arguments</p> </li> <li>Sign and send the transaction</li> </ol> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport abi from './xtokensABI.js'; // Import the X-Tokens ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n// Create X-Tokens contract instance\nconst xTokens = new ethers.Contract(\n  '0x0000000000000000000000000000000000000804',\n  abi,\n  signer\n);\n\n// Arguments for the transfer function\nconst currencyAddress = '0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080'; // xcUNIT address\nconst amount = 1000000000000;\nconst destination = [\n  // Target the relay chain from Moonbase Alpha\n  1,\n  // Target Alice's 32-byte relay chain account\n  ['0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'],\n];\nconst weight = 305986000;\n\n// Sends 1 xcUNIT to the relay chain using the transfer function\nasync function transferToAlice() {\n  // Creates, signs, and sends the transfer transaction\n  const transaction = await xTokens.transfer(\n    currencyAddress,\n    amount,\n    destination,\n    weight\n  );\n\n  // Waits for the transaction to be included in a block\n  await transaction.wait();\n  console.log(transaction);\n}\n\ntransferToAlice();\n</code></pre> <pre><code>import Web3 from 'web3'; // Import Web3 library\nimport abi from './xtokensABI.js'; // Import the X-Tokens ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Web3 provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n// Create contract instance\nconst xTokens = new web3.eth.Contract(\n  abi,\n  '0x0000000000000000000000000000000000000804',\n  { from: web3.eth.accounts.privateKeyToAccount(privateKey).address } // 'from' is necessary for gas estimation\n);\n\n// Arguments for the transfer function\nconst currencyAddress = '0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080'; // xcUNIT address\nconst amount = 1000000000000;\nconst destination = [\n  // Target the relay chain from Moonbase Alpha\n  1,\n  // Target Alice's 32-byte relay chain account\n  ['0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'],\n];\nconst weight = 305986000;\n\n// Sends 1 xcUNIT to the relay chain using the transfer function\nasync function transferToAlice() {\n  // Create transaction\n  const transferTx = xTokens.methods.transfer(\n    currencyAddress,\n    amount,\n    destination,\n    weight\n  );\n\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: '0x0000000000000000000000000000000000000804',\n      data: transferTx.encodeABI(),\n      gas: await transferTx.estimateGas(),\n    },\n    privateKey\n  );\n\n  // Send signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(sendTx);\n}\n\ntransferToAlice();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_XTOKENS_ABI\"  # Paste or import the x-tokens ABI\nprivate_key = \"INSERT_PRIVATE_KEY\"  # This is for demo purposes, never store your private key in plain text\naddress = \"INSERT_ADDRESS\"  # The wallet address that corresponds to your private key\n\n# Create Web3 provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create contract instance\nx_tokens = web3.eth.contract(\n    address=\"0x0000000000000000000000000000000000000804\", abi=abi\n)\n\n# Arguments for the transfer function\ncurrencyAddress = \"0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080\" # xcUNIT address\namount = 1000000000000\ndestination = [\n    # Target the relay chain from Moonbase Alpha\n    1,\n    # Target Alice's 32-byte relay chain account\n    [\"0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300\"],\n]\nweight = 305986000\n\n# Sends 1 xcUNIT to the relay chain using the transfer function\ndef transfer_to_alice():\n    # Create transaction\n    transferTx = x_tokens.functions.transfer(\n        currencyAddress, amount, destination, weight\n    ).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n\n    # Sign transaction\n    signedTx = web3.eth.account.sign_transaction(transferTx, private_key)\n\n    # Send tx and wait for receipt\n    hash = web3.eth.send_raw_transaction(signedTx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Tx successful with hash: { receipt.transactionHash.hex() }\")\n\n\ntransfer_to_alice()\n</code></pre>"},{"location":"builders/interoperability/xcm/xc20/send-xc20s/xtokens-precompile/#precompile-transfer-multiasset","title":"X-Tokens Precompile Transfer Multiasset Function","text":"<p>To use the <code>transfer</code> function of the X-Tokens Precompile, you'll take these general steps:</p> <ol> <li>Create a provider using a Moonbase Alpha RPC endpoint</li> <li>Create a signer to send the transaction. This example uses a private key to create the signer and is for demo purposes only. Never store your private key in a JavaScript file</li> <li>Create a contract instance of the X-Tokens Precompile using the address and ABI of the precompile</li> <li> <p>Assemble the arguments for the <code>transferMultiasset</code> function:</p> <ul> <li><code>asset</code> - the multilocation for xcUNIT: <code>[1, []]</code></li> <li><code>amount</code> - 1 xcUNIT. Since xcUNIT has 12 decimals, you can use: <code>1000000000000</code></li> <li><code>destination</code> - the multilocation of the destination, which targets Alice's account on the relay chain: <code>'0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'</code></li> <li><code>weight</code> - the weight to purchase for the XCM execution on the destination chain: <code>305986000</code></li> </ul> </li> <li> <p>Create the <code>transferMultiasset</code> function, passing in the arguments</p> </li> <li>Sign and send the transaction</li> </ol> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers'; // Import Ethers library\nimport abi from './xtokensABI.js'; // Import the X-Tokens ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Ethers provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  'https://rpc.api.moonbase.moonbeam.network'\n);\nconst signer = new ethers.Wallet(privateKey, provider);\n\n// Create X-Tokens contract instance\nconst xTokens = new ethers.Contract(\n  '0x0000000000000000000000000000000000000804',\n  abi,\n  signer\n);\n\n// Arguments for the transfer multiasset function\nconst asset = [1, []]; // Multilocation targeting the relay chain\nconst amount = 1000000000000;\nconst dest = [\n  // Target the relay chain from Moonbase Alpha\n  1,\n  // Target Alice's 32-byte relay chain account\n  ['0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'],\n];\nconst weight = 305986000;\n\n// Sends 1 xcUNIT to the relay chain using the transferMultiasset function\nasync function transferMultiassetToAlice() {\n  const transaction = await xTokens.transferMultiasset(\n    asset,\n    amount,\n    dest,\n    weight\n  );\n  await transaction.wait();\n  console.log(transaction);\n}\n\ntransferMultiassetToAlice();\n</code></pre> <pre><code>import Web3 from 'web3'; // Import Web3 library\nimport abi from './xtokensABI.js'; // Import the X-Tokens ABI\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n// Create Web3 provider\nconst web3 = new Web3('https://rpc.api.moonbase.moonbeam.network'); // Change to network of choice\n\n// Create contract instance\nconst xTokens = new web3.eth.Contract(\n  abi,\n  '0x0000000000000000000000000000000000000804',\n  { from: web3.eth.accounts.privateKeyToAccount(privateKey).address } // 'from' is necessary for gas estimation\n);\n\n// Arguments for the transfer multiasset function\nconst asset = [1, []]; // Multilocation targeting the relay chain\nconst amount = 1000000000000;\nconst dest = [\n  // Target the relay chain from Moonbase Alpha\n  1,\n  // Target Alice's 32-byte relay chain account\n  ['0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300'],\n];\nconst weight = 305986000;\n\n// Sends 1 xcUNIT to the relay chain using the transferMultiasset function\nasync function transferMultiassetToAlice() {\n  // Create transaction\n  const transferTx = xTokens.methods.transferMultiasset(\n    asset,\n    amount,\n    dest,\n    weight\n  );\n\n  // Sign transaction\n  const signedTx = await web3.eth.accounts.signTransaction(\n    {\n      to: '0x0000000000000000000000000000000000000804',\n      data: transferTx.encodeABI(),\n      gas: await transferTx.estimateGas(),\n    },\n    privateKey\n  );\n\n  // Send signed transaction\n  const sendTx = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(sendTx);\n}\n\ntransferMultiassetToAlice();\n</code></pre> <pre><code>from web3 import Web3\n\nabi = \"INSERT_XTOKENS_ABI\"  # Paste or import the x-tokens ABI\nprivate_key = \"INSERT_PRIVATE_KEY\"  # This is for demo purposes, never store your private key in plain text\naddress = \"INSERT_ADDRESS\"  # The wallet address that corresponds to your private key\n\n# Create Web3 provider\nweb3 = Web3(Web3.HTTPProvider(\"https://rpc.api.moonbase.moonbeam.network\"))\n\n# Create contract instance\nx_tokens = web3.eth.contract(\n    address=\"0x0000000000000000000000000000000000000804\", abi=abi\n)\n\n# Arguments for the transfer function\nasset = [1, []]  # Multilocation targeting the relay chain\namount = 1000000000000\ndest = [\n    # Target the relay chain from Moonbase Alpha\n    1,\n    # Target Alice's 32-byte relay chain account\n    [\"0x01c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300\"],\n]\nweight = 305986000\n\n\n# Sends 1 xcUNIT to the relay chain using the transferMultiasset function\ndef transfer_multiasset_to_alice():\n    # Create transaction\n    transferTx = x_tokens.functions.transferMultiasset(\n        asset, amount, dest, weight\n    ).build_transaction(\n        {\n            \"from\": address,\n            \"nonce\": web3.eth.get_transaction_count(address),\n        }\n    )\n\n    # Sign transaction\n    signedTx = web3.eth.account.sign_transaction(transferTx, private_key)\n\n    # Send tx and wait for receipt\n    hash = web3.eth.send_raw_transaction(signedTx.rawTransaction)\n    receipt = web3.eth.wait_for_transaction_receipt(hash)\n    print(f\"Tx successful with hash: { receipt.transactionHash.hex() }\")\n\n\ntransfer_multiasset_to_alice()\n</code></pre>"},{"location":"builders/substrate/dev-env/chopsticks/","title":"How to Use Chopsticks to Fork Moonbeam","text":""},{"location":"builders/substrate/dev-env/chopsticks/#introduction","title":"Introduction","text":"<p>Chopsticks provides a developer-friendly method of locally forking existing Substrate based chains. It allows for the replaying of blocks to easily examine how extrinsics affect state, the forking of multiple blocks for XCM testing, and more. This allows developers to test and experiment with their own custom blockchain configurations in a local development environment, without the need to deploy a live network.  </p> <p>Overall, Chopsticks aims to simplify the process of building blockchain applications on Substrate and make it accessible to a wider range of developers.</p>"},{"location":"builders/substrate/dev-env/chopsticks/#forking-moonbeam","title":"Forking Moonbeam with Chopsticks","text":"<p>To use Chopsticks, you can install it as a package with the Node package manager or Yarn:  </p> <pre><code>npm i @acala-network/chopsticks@latest\n</code></pre> <p>Once installed, you can run commands with the Node package executor. For example, this runs Chopstick's base command:  </p> <pre><code>npx @acala-network/chopsticks@latest\n</code></pre> <p>To run Chopsticks, you will need some sort of configuration, typically through a file. Chopsticks' source repository includes a set of YAML configuration files that can be used to create a local copy of a variety of Substrate chains. You can download the configuration files from the source repository's <code>configs</code> folder.  </p> <p>Moonbeam, Moonriver, and Moonbase Alpha all have default files available:  </p> MoonbeamMoonriverMoonbase Alpha <pre><code>endpoint: wss://wss.api.moonbeam.network\nmock-signature-host: true\ndb: ./db.sqlite\n\nimport-storage:\n  System:\n    Account:\n      -\n        -\n          - \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n        - data:\n            free: \"100000000000000000000000\"\n  TechCommitteeCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  CouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  TreasuryCouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  AuthorFilter:\n    EligibleRatio: 100\n    EligibleCount: 100\n</code></pre> <pre><code>endpoint: wss://wss.moonriver.moonbeam.network\nmock-signature-host: true\ndb: ./db.sqlite\n\nimport-storage:\n  System:\n    Account:\n      -\n        -\n          - \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n        - data:\n            free: \"100000000000000000000000\"\n  TechCommitteeCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  CouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  TreasuryCouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  AuthorFilter:\n    EligibleRatio: 100\n    EligibleCount: 100\n</code></pre> <pre><code>endpoint: wss://wss.api.moonbase.moonbeam.network\nmock-signature-host: true\ndb: ./db.sqlite\n\nimport-storage:\n  System:\n    Account:\n      -\n        -\n          - \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n        - data:\n            free: \"100000000000000000000000\"\n  TechCommitteeCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  CouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  TreasuryCouncilCollective:\n    Members: [\"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"]\n  Sudo:\n    Key: \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n  AuthorFilter:\n    EligibleRatio: 100\n    EligibleCount: 100\n</code></pre> <p>These are the settings that can be included in the config file:  </p> Option Description <code>genesis</code> The link to a parachain's raw genesis file to build the fork from, instead of an endpoint. <code>timestamp</code> Timestamp of the block to fork from. <code>endpoint</code> The endpoint of the parachain to fork. <code>block</code> Use to specify at which block hash or number to replay the fork. <code>wasm-override</code> Path of the WASM to use as the parachain runtime, instead of an endpoint's runtime. <code>db</code> Path to the name of the file that stores or will store the parachain's database. <code>config</code> Path or URL of the config file. <code>port</code> The port to expose an endpoint on. <code>build-block-mode</code> How blocks should be built in the fork: batch, manual, instant. <code>import-storage</code> A pre-defined JSON/YAML storage file path to override in the parachain's storage. <code>allow-unresolved-imports</code> Whether to allow WASM unresolved imports when using a WASM to build the parachain. <code>html</code> Include to generate storage diff preview between blocks. <code>mock-signature-host</code> Mock signature host so that any signature starts with <code>0xdeadbeef</code> and filled by <code>0xcd</code> is considered valid. <p>You can use the configuration file with the base command <code>npx @acala-network/chopsticks@latest</code> to fork assets by providing it with the <code>--config</code> flag.  </p> <p>You can use a raw GitHub URL of the default configuration files, a path to a local configuration file, or simply use the chain's name for the <code>--config</code> flag. For example, the following commands all use Moonbeam's configuration in the same way:  </p> Chain NameGitHub URLLocal File Path <pre><code>npx @acala-network/chopsticks@latest --config=moonbeam\n</code></pre> <pre><code>npx @acala-network/chopsticks@latest \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbeam.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks@latest --config=configs/moonbeam.yml\n</code></pre> <p>Note</p> <p>If using a file path, make sure you've downloaded the Moonbeam configuration file, or have created your own.</p> <p>A configuration file is not necessary, however. All of the settings (except <code>genesis</code> and <code>timestamp</code>) can also be passed as flags to configure the environment completely in the command line. For example, the following command forks Moonbase Alpha at block 100.</p> <pre><code>npx @acala-network/chopsticks@latest --endpoint wss://wss.api.moonbase.moonbeam.network --block 100\n</code></pre>"},{"location":"builders/substrate/dev-env/chopsticks/#quickstart","title":"Quickstart","text":"<p>The simplest way to fork Moonbeam is through the configuration files that are stored in the Chopsticks GitHub repository:  </p> MoonbeamMoonriverMoonbase Alpha <pre><code>npx @acala-network/chopsticks@latest \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbeam.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks@latest \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonriver.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks@latest \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbase-alpha.yml\n</code></pre>"},{"location":"builders/substrate/dev-env/chopsticks/#interacting-with-a-fork","title":"Interacting with a Fork","text":"<p>When running a fork, by default it will be accessible at:</p> <pre><code>ws://localhost:8000\n</code></pre> <p>You will be able to interact with the parachain via libraries such as Polkadot.js and its user interface, Polkadot.js Apps.  </p> <p>You can interact with Chopsticks via the Polkadot.js Apps hosted user interface. To do so, visit the page and take the following steps:  </p> <ol> <li>Click the icon in the top left</li> <li>Go to the bottom and open Development</li> <li>Select the Custom endpoint and enter <code>ws://localhost:8000</code></li> <li>Click the Switch button</li> </ol> <p> </p> <p>You should now be able to interact with the fork as you would an active parachain or relay chain.</p> <p>Note</p> <p>If your browser cannot connect to the WebSocket endpoint provided by Chopsticks, you might need to allow insecure connections for the Polkadot.js Apps URL. Another solution is to run the Docker version of Polkadot.js Apps.</p>"},{"location":"builders/substrate/dev-env/chopsticks/#replaying-blocks","title":"Replaying Blocks","text":"<p>In the case where you would like to replay a block and retrieve its information to dissect the effects of an extrinsic, you can use the <code>npx @acala-network/chopsticks@latest run-block</code> command. Its following flags are:  </p> Flag Description <code>endpoint</code> The endpoint of the parachain to fork. <code>block</code> Use to specify at which block hash or number to replay the fork. <code>wasm-override</code> Path of the WASM to use as the parachain runtime, instead of an endpoint's runtime. <code>db</code> Path to the name of the file that stores or will store the parachain's database. <code>config</code> Path or URL of the config file. <code>output-path=/[file_path]</code> Use to print out results to a JSON file instead of printing it out in the console. <code>html</code> Include to generate an HTML representation of the storage diff preview between blocks. <code>open</code> Whether to open the HTML representation. <p>For example, running the following command will re-run Moonbeam's block 1000, and write the storage diff and other data in a <code>moonbeam-output.json</code> file:  </p> <pre><code>npx @acala-network/chopsticks@latest run-block  \\\n--endpoint wss://wss.api.moonbeam.network  \\\n--output-path=./moonbeam-output.json  \\\n--block 1000\n</code></pre>"},{"location":"builders/substrate/dev-env/chopsticks/#xcm-testing","title":"XCM Testing","text":"<p>To test out XCM messages between networks, you can fork multiple parachains and a relay chain locally. For example, the following will fork Moonriver, Karura, and Kusama given that you've downloaded the <code>configs</code> directory from the source GitHub repository:  </p> <pre><code>npx @acala-network/chopsticks@latest xcm \\\n--r=kusama.yml \\\n--p=moonriver.yml \\\n--p=karura.yml\n</code></pre> <p>You should see something like the following output:  </p> <pre><code>[13:50:57.807] INFO (rpc/64805): Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonriver.yml\n[13:50:59.655] INFO (rpc/64805): Moonriver RPC listening on port 8000\n[13:50:59.656] INFO (rpc/64805): Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/karura.yml\n[13:51:03.275] INFO (rpc/64805): Karura RPC listening on port 8001\n[13:51:03.586] INFO (xcm/64805): Connected parachains [2000,2023]\n[13:51:03.586] INFO (rpc/64805): Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/kusama.yml\n[13:51:07.241] INFO (rpc/64805): Kusama RPC listening on port 8002\n[13:51:07.700] INFO (xcm/64805): Connected relaychain 'Kusama' with parachain 'Moonriver'\n[13:51:08.386] INFO (xcm/64805): Connected relaychain 'Kusama' with parachain 'Karura'\n</code></pre> <p>Including the <code>r</code> flag as the relay chain is optional, as Chopsticks will automatically mock a relay chain between networks. You can also use a raw GitHub URL or the name of a popular branch, similar to the base command.  </p>"},{"location":"builders/substrate/dev-env/chopsticks/#websocket-commands","title":"WebSocket Commands","text":"<p>Chopsticks' internal websocket server has special endpoints that allows the manipulation of the local Substrate chain. These are the methods that can be invoked:  </p> Method Parameters Description <code>dev_newBlock</code> <code>options</code> Generates one or more new blocks. <code>dev_setStorage</code> <code>values</code>, <code>blockHash</code> Create or overwrite the value of any storage. <code>dev_timeTravel</code> <code>date</code> Sets the timestamp of the block to the <code>date</code> value. <code>dev_setHead</code> <code>hashOrNumber</code> Sets the head of the blockchain to a specific hash or number. <p>The parameters above are formatted in the following ways:  </p> Parameter Format Example <code>options</code> <code>{ \"to\": number, \"count\": number }</code> <code>{ \"count\": 5 }</code> <code>values</code> <code>Object</code> <code>{ \"Sudo\": { \"Key\": \"0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b\" } }</code> <code>blockHash</code> <code>string</code> <code>\"0x1a34506b33e918a0106b100db027425a83681e2332fe311ee99d6156d2a91697\"</code> <code>date</code> <code>Date</code> <code>\"2030-08-15T00:00:00\"</code> <code>hashOrNumber</code> <code>number               |                                string</code> <ul> <li><code>options</code> { \"to\": number, \"count\": number } - a JSON object where <code>\"to\"</code> will create blocks up to a certain value, and <code>\"count\"</code> will increase by a certain number of blocks. Use only one entry at a time within the JSON object  </li> <li><code>values</code> Object - a JSON object resembling the path to a storage value, similar to what you would retrieve via Polkadot.js  </li> <li><code>blockHash</code> string - optional, the blockhash at which the storage value is changed  </li> <li><code>date</code> Date - a Date string (compatible with the JavaScript Date library) that will change the time stamp from which the next blocks being created will be at. All future blocks will be sequentially after that point in time  </li> <li><code>hashOrNumber</code> number | string - if found, the chain head will be set to the block with the block number or block hash of this value  </li> </ul> <p>Each method can be invoked by connecting to the websocket (<code>ws://localhost:8000</code> by default) and sending the data and parameters in the following format. Replace <code>METHOD_NAME</code> with the name of the method, and replace or delete <code>PARAMETER_1</code> and <code>PARAMETER_2</code> with the parameter data relevant to the method:  </p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"METHOD_NAME\",\n    \"params\": [\"PARAMETER_1\", \"PARAMETER_2\", \"...\"]\n}\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/substrate/libraries/polkadot-js-api/","title":"Polkadot.js API Library","text":""},{"location":"builders/substrate/libraries/polkadot-js-api/#introduction","title":"Introduction","text":"<p>Polkadot.js is a collection of tools that allow you to interact with Polkadot and its parachains, such as Moonbeam. The Polkadot.js API is one component of Polkadot.js and is a library that allows application developers to query a Moonbeam node and interact with the node's Substrate interfaces using JavaScript, enabling you to read and write data to the network.</p> <p>You can use the Polkadot.js API to query on-chain data and send extrinsics from the Substrate side of Moonbeam. You can query Moonbeam's runtime constants, chain state, events, transaction (extrinsic) data, and more.</p> <p>Here you will find an overview of the available functionalities and some commonly used code examples to get you started on interacting with Moonbeam networks using the Polkadot.js API library.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Installing and using Polkadot.js API library requires Node.js to be installed.</p> <p>You need to install Node.js (for this example, you can use v16.x) and the npm package manager. You can download directly from Node.js or in your terminal:</p> UbuntuMacOS <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n\nsudo apt install -y nodejs\n</code></pre> <pre><code># You can use homebrew (https://docs.brew.sh/Installation)\nbrew install node\n\n# Or you can use nvm (https://github.com/nvm-sh/nvm)\nnvm install node\n</code></pre> <p>You can verify that everything is installed correctly by querying the version for each package:</p> <pre><code>node -v\n</code></pre> <pre><code>npm -v\n</code></pre> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#installing-polkadot.js-api-library","title":"Install Polkadot.js API","text":"<p>First, you need to install the Polkadot.js API library for your project through a package manager such as <code>yarn</code>. Install it in your project directory with the following command:</p> npmyarn <pre><code>npm i @polkadot/api\n</code></pre> <pre><code>yarn add @polkadot/api\n</code></pre> <p>The library also includes other core components like Keyring for account management, or some utilities that are used throughout this guide.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#creating-an-API-provider-instance","title":"Create an API Provider Instance","text":"<p>Similar to Ethereum API libraries, you must first instantiate an API instance of the Polkadot.js API. Create the <code>WsProvider</code> using the WebSocket endpoint of the Moonbeam network you wish to interact with.</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_API_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n}\n\nmain();\n</code></pre> <pre><code>// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_API_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n}\n\nmain();\n</code></pre> <pre><code>// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n}\n\nmain();\n</code></pre> <pre><code>// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('ws://127.0.0.1:9944');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n}\n\nmain();\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#metadata-and-dynamic-api-decoration","title":"Metadata and Dynamic API Decoration","text":"<p>Before diving into the details of performing different tasks via the Polkadot.js API library, it's useful to understand some of the basic workings of the library.</p> <p>When the Polkadot.js API connects to a node, one of the first things it does is retrieve the metadata and decorate the API based on the metadata information. The metadata effectively provides data in the form of:</p> <pre><code>api.&lt;type&gt;.&lt;module&gt;.&lt;section&gt;\n</code></pre> <p>Where <code>&lt;type&gt;</code> can be either:</p> <ul> <li><code>query</code> - for endpoints to read all the state queries</li> <li><code>tx</code> - for endpoints related to transactions</li> <li><code>rpc</code> - for endpoints specific to RPC calls</li> <li><code>consts</code> - for endpoints specific to runtime constants</li> </ul> <p>And therefore, none of the information contained in the <code>api.{query, tx, rpc, consts}.&lt;module&gt;.&lt;method&gt;</code> endpoints is hard-coded in the API. This allows parachains like Moonbeam to have custom endpoints through its pallets that can be directly accessed via the Polkadot.js API library.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#querying-for-information","title":"Query On-Chain Data on Moonbeam","text":"<p>In this section, you will learn how to query for on-chain information using the Polkadot.js API library.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#state-queries","title":"Moonbeam Chain State Queries","text":"<p>This category of queries retrieves information related to the current state of the chain. These endpoints are generally of the form <code>api.query.&lt;module&gt;.&lt;method&gt;</code>, where the module and method decorations are generated through metadata. You can see a list of all available endpoints by examining the <code>api.query</code> object, for example via:</p> <pre><code>console.log(api.query);\n</code></pre> <p>Assuming you've initialized the API, here is a code sample for retrieving basic account information given its address :</p> <pre><code>// Define wallet address\nconst addr = 'INSERT_ADDRESS';\n\n// Retrieve the last timestamp\nconst now = await api.query.timestamp.now();\n\n// Retrieve the account balance &amp; current nonce via the system module\nconst { nonce, data: balance } = await api.query.system.account(addr);\n\nconsole.log(\n  `${now}: balance of ${balance.free} and a current nonce of ${nonce}`\n);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Define wallet address\n  const addr = 'INSERT_ADDRESS';\n\n  // Retrieve the last timestamp via the timestamp module\n  const now = await api.query.timestamp.now();\n\n  // Retrieve the account balance &amp; current nonce via the system module\n  const { nonce, data: balance } = await api.query.system.account(addr);\n\n  console.log(\n    `${now}: balance of ${balance.free} and a current nonce of ${nonce}`\n  );\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#rpc-queries","title":"Moonbeam RPC Queries","text":"<p>The RPC calls provide the backbone for the transmission of data to and from the node. This means that all API endpoints such as <code>api.query</code>, <code>api.tx</code> or <code>api.derive</code> just wrap RPC calls, providing information in the encoded format as expected by the node. You can see a list of all available endpoints by examining the <code>api.rpc</code> object, for example via:</p> <pre><code>console.log(api.rpc);\n</code></pre> <p>The <code>api.rpc</code> interface follows the a similar format to <code>api.query</code>, for instance:</p> <pre><code>// Retrieve the chain name\nconst chain = await api.rpc.system.chain();\n\n// Retrieve the latest header\nconst lastHeader = await api.rpc.chain.getHeader();\n\n// Log the information\nconsole.log(\n  `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain name\n  const chain = await api.rpc.system.chain();\n\n  // Retrieve the latest header\n  const lastHeader = await api.rpc.chain.getHeader();\n\n  // Log the information\n  console.log(\n    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n  );\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#query-subscriptions","title":"Query Subscriptions","text":"<p>The <code>rpc</code> API also provide endpoints for subscriptions. You can adapt the previous example to start using subscriptions to listen to new blocks. Note that you need to remove the API disconnect when using subscriptions, to avoid normal closures of the WSS connection.</p> <pre><code>// Retrieve the chain name\nconst chain = await api.rpc.system.chain();\n\n// Subscribe to the new headers\nawait api.rpc.chain.subscribeNewHeads((lastHeader) =&gt; {\n  console.log(\n    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n  );\n});\n// Remove await api.disconnect()!\n</code></pre> <p>The general pattern for <code>api.rpc.subscribe*</code> functions is to pass a callback into the subscription function, and this will be triggered on each new entry as they are imported.</p> <p>Other calls under <code>api.query.*</code> can be modified in a similar fashion to use subscription, including calls that have parameters. Here is an example of how to subscribe to balance changes in an account:</p> <pre><code>// Define wallet address\nconst addr = 'INSERT_ADDRESS';\n\n// Subscribe to balance changes for a specified account\nawait api.query.system.account(addr, ({ nonce, data: balance }) =&gt; {\n  console.log(\n    `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`\n  );\n});\n\n// Remove await api.disconnect()!\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain name\n  const chain = await api.rpc.system.chain();\n\n  // Subscribe to the new headers\n  await api.rpc.chain.subscribeNewHeads((lastHeader) =&gt; {\n    console.log(\n      `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n    );\n  });\n\n  // Define wallet address\n  const addr = 'INSERT_ADDRESS';\n\n  // Subscribe to balance changes for a specified account\n  await api.query.system.account(addr, ({ nonce, data: balance }) =&gt; {\n    console.log(\n      `free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`\n    );\n\n    // Handle API disconnect here if needed\n  });\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#keyrings","title":"Create a Keyring for a Moonbeam Account","text":"<p>The Keyring object is used for maintaining key pairs, and the signing of any data, whether it's a transfer, a message, or a contract interaction.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#creating-a-keyring-instance","title":"Create a Keyring Instance","text":"<p>You can create an instance by just creating an instance of the Keyring class, and specifying the default type of wallet address used. For Moonbeam networks, the default wallet type should be <code>ethereum</code>.</p> <pre><code>// Import the keyring as required\nimport Keyring from '@polkadot/keyring';\n\n// Create a keyring instance\nconst keyring = new Keyring({ type: 'ethereum' });\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#adding-accounts","title":"Add an Account to a Keyring","text":"<p>There are a number of ways to add an account to the keyring instance, including from the mnemonic phrase and from the shortform private key.</p> From MnemonicFrom Private Key <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\nimport { u8aToHex } from '@polkadot/util';\nimport { hdEthereum } from '@polkadot/util-crypto';\nimport { mnemonicToSeedSync } from 'bip39';\n\n// Import Ethereum account from mnemonic\nconst mnemonic = 'INSERT_MNEMONIC';\n\n// Use the exact EVM derivation path\nconst ethDerPath = \"m/44'/60'/0'/0/0\";\nconsole.log(`Mnemonic: ${mnemonic}`);\nconsole.log(`--------------------------\\n`);\n\n// Extract Ethereum address from mnemonic\nconst keyring = new Keyring();\nconst pair = keyring.createFromUri(\n  `${mnemonic}/${ethDerPath}`,\n  undefined,\n  'ethereum',\n  undefined,\n  2048\n);\nconsole.log(`Ethereum Derivation Path: ${ethDerPath}`);\nconsole.log(`Derived Ethereum Address from Mnemonic: ${pair.address}`);\n\n// Extract private key from mnemonic\nconst seed = mnemonicToSeedSync(mnemonic, '');   // Buffer\nconst node = hdEthereum(seed, ethDerPath);       // \"m/44'/60'/0'/0/0\"\nconst privateKey = u8aToHex(node.secretKey);\nconsole.log(`Derived Private Key from Mnemonic: ${privateKey}`);\n</code></pre> <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\n\n// Import Ethereum account from private key\nconst privateKeyInput = 'INSERT_PK';\n\n// Extract address from private key\nconst keyring = new Keyring();\nconst pairFromPk = keyring.createFromUri(\n  privateKeyInput,\n  undefined,\n  'ethereum'\n);\nconsole.log(`Derived Address from provided Private Key: ${pairFromPk.address}`);\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#dry-run-api","title":"Dry Run API","text":"<p>The Dry Run API is an easy and convenient way to test the integrity of a call without incurring any transaction fees. The Dry Run API can be accessed from the Runtime Calls tab of the Developer section of Polkadot.js Apps. While primarily intended for the testing of XCM messages, the Dry Run API can be used to test any arbitrary call.</p> <p>This method takes the origin and call data as parameters and returns an execution result and additional event data. </p> <pre><code>const testAccount = api.createType(\n  'AccountId20',\n  '0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798'\n);\nconst callData =\n  '0x030088bce0b038effa09e58fe6d24fde4b5af21aa79813000064a7b3b6e00d';\nconst callDataU8a = hexToU8a(callData);\n\nconst result = await api.call.dryRunApi.dryRunCall(\n  { system: { Signed: testAccount } },\n  callDataU8a\n);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { hexToU8a } from '@polkadot/util';\n\nconst main = async () =&gt; {\n  try {\n    // Construct API provider\n    const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n    const api = await ApiPromise.create({ provider: wsProvider });\n\n    console.log('Connected to the API. Preparing dry run call...');\n\n    // Create a test account (you should replace this with an actual account)\n    const testAccount = api.createType(\n      'AccountId20',\n      '0x88bcE0b038eFFa09e58fE6d24fDe4b5Af21aa798'\n    );\n\n    // The call data (replace with your actual call data)\n    const callData =\n      '0x030088bce0b038effa09e58fe6d24fde4b5af21aa79813000064a7b3b6e00d'; // Your hex-encoded call data\n\n    // Convert hex to Uint8Array\n    const callDataU8a = hexToU8a(callData);\n\n    // Perform the dry run call\n    const result = await api.call.dryRunApi.dryRunCall(\n      { system: { Signed: testAccount } }, // origin\n      callDataU8a // call\n    );\n\n    console.log(\n      'Dry run XCM result:',\n      JSON.stringify(result.toJSON(), null, 2)\n    );\n\n    // Disconnect the API\n    await api.disconnect();\n    console.log('Disconnected from the API.');\n  } catch (error) {\n    console.error('An error occurred:', error);\n  }\n};\n\nmain().catch(console.error);\n</code></pre> <p>Upon calling the Dry Run API, the method will tell you whether the call would be successful and returns the event data that would be emitted if the call were actually submitted on chain. You can view the initial output of the <code>dryRunCall</code> below.</p> View the complete output <pre><code>Dry run XCM result: {\n  \"ok\": {\n    \"executionResult\": {\n      \"ok\": {\n        \"actualWeight\": null,\n        \"paysFee\": \"Yes\"\n      }\n    },\n    \"emittedEvents\": [],\n    \"localXcm\": null,\n\n      // Additional data returned here\n      // Omitted for clarity \n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#transactions","title":"Send Transactions on Moonbeam","text":"<p>Transaction endpoints are exposed on endpoints generally of the form <code>api.tx.&lt;module&gt;.&lt;method&gt;</code>, where the module and method decorations are generated through metadata. These allow you to submit transactions for inclusion in blocks, be it transfers, interacting with pallets, or anything else Moonbeam supports. You can see a list of all available endpoints by examining the <code>api.tx</code> object, for example via:</p> <pre><code>console.log(api.tx);\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#sending-basic-transactions","title":"Send a Transaction","text":"<p>The Polkadot.js API library can be used to send transactions to the network. For example, assuming you've initialized the API and a keyring instance, you can use the following snippet to send a basic transaction (this code sample will also retrieve the encoded calldata of the transaction as well as the transaction hash after submitting):</p> <pre><code>// Initialize wallet key pairs\nconst alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\nconst bob = 'INSERT_BOBS_ADDRESS';\n\n// Form the transaction\nconst tx = await api.tx.balances.transferAllowDeath(bob, 12345n);\n\n// Retrieve the encoded calldata of the transaction\nconst encodedCalldata = tx.method.toHex();\nconsole.log(`Encoded calldata: ${encodedCallData}`);\n\n// Sign and send the transaction\nconst txHash = await tx\n  .signAndSend(alice);\n\n// Show the transaction hash\nconsole.log(`Submitted with hash ${txHash}`);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport Keyring from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Create a keyring instance (ECDSA)\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  // Initialize wallet key pairs\n  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n  const bob = 'INSERT_BOBS_ADDRESS';\n\n  // Form the transaction\n  const tx = await api.tx.balances.transferAllowDeath(bob, BigInt(12345));\n\n  // Retrieve the encoded calldata of the transaction\n  const encodedCalldata = tx.method.toHex();\n  console.log(`Encoded calldata: ${encodedCalldata}`);\n\n  // Sign and send the transaction\n  const txHash = await tx.signAndSend(alice);\n\n  // Show the transaction hash\n  console.log(`Submitted with hash ${txHash}`);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre> <p>Note</p> <p>Prior to client v0.35.0, the extrinsic used to perform a simple balance transfer was the <code>balances.transfer</code> extrinsic. It has since been deprecated and replaced with the <code>balances.transferAllowDeath</code> extrinsic.</p> <p>Note that the <code>signAndSend</code> function can also accept optional parameters, such as the <code>nonce</code>. For example, <code>signAndSend(alice, { nonce: aliceNonce })</code>. You can use the sample code from the State Queries section to retrieve the correct nonce, including transactions in the mempool.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#fees","title":"Fee Information","text":"<p>The transaction endpoint also offers a method to obtain weight information for a given <code>api.tx.&lt;module&gt;.&lt;method&gt;</code>. To do so, you'll need to use the <code>paymentInfo</code> function after having built the entire transaction with the specific <code>module</code> and <code>method</code>.</p> <p>The <code>paymentInfo</code> function returns weight information in terms of <code>refTime</code> and <code>proofSize</code>, which can be used to determine the transaction fee. This is extremely helpful when crafting remote execution calls via XCM.</p> <p>For example, assuming you've initialized the API, the following snippet shows how you can get the weight information for a simple balance transfer between two accounts:</p> <pre><code>// Transaction to get weight information\nconst tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(12345));\n\n// Get weight info\nconst { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');\n\nconsole.log(`Transaction weight: ${weight}`);\nconsole.log(`Transaction fee: ${partialFee.toHuman()}`);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Transaction to get weight information\n  const tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(12345));\n\n  // Get weight info\n  const { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');\n\n  console.log(`Transaction weight: ${weight}`);\n  console.log(`Transaction fee: ${partialFee.toHuman()}`);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/substrate/libraries/polkadot-js-api/#transaction-events","title":"Transaction Events","text":"<p>Any transaction will emit events, as a bare minimum this will always be either a <code>system.ExtrinsicSuccess</code> or <code>system.ExtrinsicFailed</code> event for the specific transaction. These provide the overall execution result for the transaction, i.e. execution has succeeded or failed.</p> <p>Depending on the transaction sent, some other events may however be emitted, for instance for a balance transfer event, this could include one or more <code>balance.Transfer</code> events.</p> <p>The Transfer API page includes an example code snippet for subscribing to new finalized block headers, and retrieving all <code>balance.Transfer</code> events.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#batching-transactions","title":"Batch Transactions","text":"<p>The Polkadot.js API allows transactions to be batch processed via the <code>api.tx.utility.batch</code> method. The batched transactions are processed sequentially from a single sender. The transaction fee can be estimated using the <code>paymentInfo</code> helper method.</p> <p>For example, assuming you've initialized the API, a keyring instance and added an account, the following example makes a couple of transfers and also uses the <code>api.tx.parachainStaking</code> module to schedule a request to decrease the bond of a specific collator candidate:</p> <pre><code>// Construct a list of transactions to batch\nconst collator = 'INSERT_COLLATORS_ADDRESS';\nconst txs = [\n  api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(12345)),\n  api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(12345)),\n  api.tx.parachainStaking.scheduleDelegatorBondLess(collator, BigInt(12345)),\n];\n\n// Estimate the fees as RuntimeDispatchInfo, using the signer (either\n// address or locked/unlocked keypair)\nconst info = await api.tx.utility.batch(txs).paymentInfo(alice);\n\nconsole.log(`Estimated fees: ${info}`);\n\n// Construct the batch and send the transactions\napi.tx.utility.batch(txs).signAndSend(alice, ({ status }) =&gt; {\n  if (status.isInBlock) {\n    console.log(`included in ${status.asInBlock}`);\n\n    // Disconnect API here!\n  }\n});\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport Keyring from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Create a keyring instance (ECDSA)\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  // Initialize wallet key pairs\n  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n\n  // Construct a list of transactions to batch\n  const collator = 'INSERT_COLLATORS_ADDRESS';\n  const txs = [\n    api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(12345)),\n    api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(12345)),\n    api.tx.parachainStaking.scheduleDelegatorBondLess(collator, BigInt(12345)),\n  ];\n\n  // Estimate the fees as RuntimeDispatchInfo, using the signer (either\n  // address or locked/unlocked keypair)\n  const info = await api.tx.utility.batch(txs).paymentInfo(alice);\n\n  console.log(`Estimated fees: ${info}`);\n\n  // Construct the batch and send the transactions\n  api.tx.utility.batch(txs).signAndSend(alice, async ({ status }) =&gt; {\n    if (status.isInBlock) {\n      console.log(`Included in ${status.asInBlock}`);\n\n      // Disconnect the API\n      await api.disconnect();\n    }\n  });\n};\n\nmain();\n</code></pre> <p>Note</p> <p>You can check out all of the available functions for the <code>parachainStaking</code> module by adding <code>console.log(api.tx.parachainStaking);</code> to your code.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#substrate-and-custom-json-rpc-endpoints","title":"Substrate and Custom JSON-RPC Endpoints","text":"<p>RPCs are exposed as a method on a specific module. This means that once available, you can call any RPC via <code>api.rpc.&lt;module&gt;.&lt;method&gt;(...params[])</code>. This also works for accessing Ethereum RPCs using the Polkadot.js API, in the form of <code>polkadotApi.rpc.eth.*</code>.</p> <p>Some of the methods available through the Polkadot.js API interface are also available as JSON-RPC endpoints on Moonbeam nodes. This section will provide some examples; you can check for a list of exposed RPC endpoints by calling <code>api.rpc.rpc.methods()</code> or the <code>rpc_methods</code> endpoint listed below.</p> <ul> <li> <p><code>methods()</code></p> <ul> <li>Interface -  <code>api.rpc.rpc.methods</code></li> <li>JSON-RPC - <code>rpc_methods</code></li> <li>Returns - The list of RPC methods that are exposed by the node</li> </ul> <pre><code>  curl --location --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"rpc_methods\",\n    \"params\": []\n  }'\n</code></pre> </li> <li> <p><code>getBlock(hash?: BlockHash)</code></p> <ul> <li>Interface - <code>api.rpc.chain.getBlock</code></li> <li>JSON-RPC - <code>chain_getBlock</code></li> <li>Returns - The header and body of a block as specified by the block hash parameter</li> </ul> <pre><code>  curl --location --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"chain_getBlock\",\n    \"params\": [\"0x870ad0935a27ed8684048860ffb341d469e091abc2518ea109b4d26b8c88dd96\"]\n  }'\n</code></pre> </li> <li> <p><code>getFinalizedHead()</code></p> <ul> <li>Interface <code>api.rpc.chain.getFinalizedHead</code></li> <li>JSON-RPC <code>chain_getFinalizedHead</code></li> <li>Returns The block hash of the last finalized block in the canonical chain</li> </ul> <pre><code>  curl --location --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"chain_getHeader\",\n    \"params\": []\n  }'\n</code></pre> </li> </ul> <p>The Consensus and Finality page has sample code for using the exposed custom and Substrate RPC calls to check the finality of a given transaction.</p>"},{"location":"builders/substrate/libraries/polkadot-js-api/#utilities","title":"Polkadot.js API Utility Functions","text":"<p>The Polkadot.js API also includes a number of utility libraries for computing commonly used cryptographic primitives and hash functions.</p> <p>The following example computes the deterministic transaction hash of a raw Ethereum legacy transaction by first computing its RLP (Recursive Length Prefix) encoding, then hashing the result with keccak256.</p> <pre><code>import { encode } from '@polkadot/util-rlp';\nimport { keccakAsHex } from '@polkadot/util-crypto';\nimport { numberToHex } from '@polkadot/util';\n\n// Define the raw signed transaction\nconst txData = {\n  nonce: numberToHex(1),\n  gasPrice: numberToHex(21000000000),\n  gasLimit: numberToHex(21000),\n  to: '0xc390cC49a32736a58733Cf46bE42f734dD4f53cb',\n  value: numberToHex(1000000000000000000),\n  data: '',\n  v: '0507',\n  r: '0x5ab2f48bdc6752191440ce62088b9e42f20215ee4305403579aa2e1eba615ce8',\n  s: '0x3b172e53874422756d48b449438407e5478c985680d4aaa39d762fe0d1a11683',\n};\n\n// Extract the values to an array\nvar txDataArray = Object.keys(txData).map(function (key) {\n  return txData[key];\n});\n\n// Calculate the RLP encoded transaction\nvar encoded_tx = encode(txDataArray);\n\n// Hash the encoded transaction using keccak256\nconsole.log(keccakAsHex(encoded_tx));\n</code></pre> <p>You can check the respective NPM repository page for a list of available methods in the <code>@polkadot/util-crypto</code> library and their descriptions.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/substrate/libraries/py-substrate-interface/","title":"Python Substrate Interface","text":""},{"location":"builders/substrate/libraries/py-substrate-interface/#introduction","title":"Introduction","text":"<p>Python Substrate Interface library allows application developers to query a Moonbeam node and interact with the node's Polkadot or Substrate features using a native Python interface. Here you will find an overview of the available functionalities and some commonly used code examples to get you started on interacting with Moonbeam networks using Python Substrate Interface.</p>"},{"location":"builders/substrate/libraries/py-substrate-interface/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds.   You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> <li>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers</li> <li>Have <code>pip</code> installed</li> </ul> <p>Note</p> <p>The examples in this guide assume you have a MacOS or Ubuntu 22.04-based environment and will need to be adapted accordingly for Windows.</p>"},{"location":"builders/substrate/libraries/py-substrate-interface/#installing-python-substrate-interface","title":"Installing Python Substrate Interface","text":"<p>You can install Python Substrate Interface library for your project through <code>pip</code>. Run the following command in your project directory:</p> <pre><code>pip install substrate-interface\n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#creating-an-API-provider-instance","title":"Creating an API Provider Instance","text":"<p>Similar to ETH API libraries, you must first instantiate an API instance of Python Substrate Interface API. Create the <code>WsProvider</code> using the websocket endpoint of the Moonbeam network you wish to interact with.</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"INSERT_WSS_API_ENDPOINT\",\n) \n</code></pre> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"INSERT_WSS_API_ENDPOINT\",\n)   \n</code></pre> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)   \n</code></pre> <pre><code># Import\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"ws://127.0.0.1:9944\",\n)   \n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#querying-for-information","title":"Querying for Information","text":"<p>In this section, you will learn how to query for on-chain information of Moonbeam networks using Python Substrate Interface library.</p>"},{"location":"builders/substrate/libraries/py-substrate-interface/#accessing-runtime-constants","title":"Accessing Runtime Constants","text":"<p>All runtime constants, such as <code>BlockWeights</code>, <code>DefaultBlocksPerRound</code> and <code>ExistentialDeposit</code>, are provided in the metadata. You can use the <code>get_metadata_constants</code> method to see a list of available runtime constants within Moonbeam network's metadata.</p> <p>Runtime constants available in the metadata can be queried through the <code>get_constant</code> method.</p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)   \n\n# List of available runtime constants in the metadata\nconstant_list = ws_provider.get_metadata_constants()\nprint(constant_list)\n\n# Retrieve the Existential Deposit constant on Moonbeam, which is 0\nconstant = ws_provider.get_constant(\"Balances\", \"ExistentialDeposit\")\nprint(constant.value)\n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#retrieving-blocks-and-extrinsics","title":"Retrieving Blocks and Extrinsics","text":"<p>You can retrieve basic information about Moonbeam networks, such as blocks and extrinsics, using the Python Substrate Interface API.</p> <p>To retrieve a block, you can use the <code>get_block</code> method. You can also access extrinsics and their data fields inside a block object, which is simply a Python dictionary.</p> <p>To retrieve a block header, you can use the <code>get_block_header</code> method.  </p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# Retrieve the latest block\nblock = ws_provider.get_block()\n\n# Retrieve the latest finalized block\nblock = ws_provider.get_block_header(finalized_only=True)\n\n# Retrieve a block given its Substrate block hash\nblock_hash = \"0xa499d4ebccdabe31218d232460c0f8b91bd08f72aca25f9b25b04b6dfb7a2acb\"\nblock = ws_provider.get_block(block_hash=block_hash)\n\n# Iterate through the extrinsics inside the block\nfor extrinsic in block[\"extrinsics\"]:\n    if \"address\" in extrinsic:\n        signed_by_address = extrinsic[\"address\"].value\n    else:\n        signed_by_address = None\n    print(\n        \"\\nPallet: {}\\nCall: {}\\nSigned by: {}\".format(\n            extrinsic[\"call\"][\"call_module\"].name,\n            extrinsic[\"call\"][\"call_function\"].name,\n            signed_by_address,\n        )\n    )\n</code></pre> <p>Note</p> <p>The block hash used in the above code sample is the Substrate block hash. The standard methods in Python Substrate Interface assume you are using the Substrate version of primitives, such as block or tx hashes.</p>"},{"location":"builders/substrate/libraries/py-substrate-interface/#subscribing-to-new-block-headers","title":"Subscribing to New Block Headers","text":"<p>You can also adapt the previous example to use a subscription based model to listen to new block headers.</p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n\ndef subscription_handler(obj, update_nr, subscription_id):\n    print(f\"New block #{obj['header']['number']}\")\n\n    if update_nr &gt; 10:\n        return {\n            \"message\": \"Subscription will cancel when a value is returned\",\n            \"updates_processed\": update_nr,\n        }\n\n\nresult = ws_provider.subscribe_block_headers(subscription_handler)\n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#querying-for-storage-information","title":"Querying for Storage Information","text":"<p>You can use the <code>get_metadata_storage_functions</code> to see a list of available storage functions within Moonbeam network's metadata.</p> <p>Chain states that are provided in the metadata through storage functions can be queried through the <code>query</code> method.</p> <p>The Substrate system modules, such as <code>System</code>, <code>Timestamp</code>, and <code>Balances</code>, can be queried to provide basic information such as account nonce and balance. The available storage functions are read from the metadata dynamically, so you can also query for storage information on Moonbeam custom modules, such as <code>ParachainStaking</code> and <code>Democracy</code>, for state information that's specific to Moonbeam.</p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# List of available storage functions in the metadata\nmethod_list = ws_provider.get_metadata_storage_functions()\nprint(method_list)\n\n# Query basic account information\naccount_info = ws_provider.query(\n    module=\"System\",\n    storage_function=\"Account\",\n    params=[\"0x578002f699722394afc52169069a1FfC98DA36f1\"],\n)\n# Log the account nonce\nprint(account_info.value[\"nonce\"])\n# Log the account free balance\nprint(account_info.value[\"data\"][\"free\"])\n\n# Query candidate pool information from Moonbeam's Parachain Staking module\ncandidate_pool_info = ws_provider.query(\n    module=\"ParachainStaking\", storage_function=\"CandidatePool\", params=[]\n)\nprint(candidate_pool_info)\n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#signing-and-transactions","title":"Signing and Transactions","text":""},{"location":"builders/substrate/libraries/py-substrate-interface/#creating-a-keypair","title":"Creating a Keypair","text":"<p>The keypair object in Python Substrate Interface is used in the signing of any data, whether it's a transfer, a message, or a contract interaction.  </p> <p>You can create a keypair instance from the shortform private key or from the mnemonic. For Moonbeam networks, you also need to specify the <code>KeypairType</code> to be <code>KeypairType.ECDSA</code>.</p> <pre><code># Imports\nfrom substrateinterface import Keypair, KeypairType\n\n# Define the shortform private key\nprivatekey = bytes.fromhex(\"INSERT_PRIVATE_KEY_WITHOUT_0X_PREFIX\")\n\n# Define the account mnemonic\nmnemonic = \"INSERT_MNEMONIC\"\n\n# Generate the keypair from shortform private key\nkeypair = Keypair.create_from_private_key(privatekey, crypto_type=KeypairType.ECDSA)\n\n# Generate the keypair from mnemonic\nkeypair = Keypair.create_from_mnemonic(mnemonic, crypto_type=KeypairType.ECDSA)\n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#forming-and-sending-a-transaction","title":"Forming and Sending a Transaction","text":"<p>The <code>compose_call</code> method can be used to compose a call payload which can be used as an unsigned extrinsic or a proposal.</p> <p>Then the payload can be signed using a keypair through the <code>create_signed_extrinsic</code> method.</p> <p>The signed extrinsic can then be submitted using the <code>submit_extrinsic</code> method.</p> <p>This method will also return an <code>ExtrinsicReceipt</code> object which contains information about the on-chain execution of the extrinsic. If you need to examine the receipt object, you can set the <code>wait_for_inclusion</code> to <code>True</code> when submitting the extrinsic to wait until the extrinsic is successfully included into the block.</p> <p>The following sample code will show a complete example for sending a transaction.</p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface, Keypair, KeypairType\nfrom substrateinterface.exceptions import SubstrateRequestException\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# Define the shortform private key of the sending account\nprivatekey = bytes.fromhex(\"INSERT_PRIVATE_KEY_WITHOUT_0X_PREFIX\")\n\n# Generate the keypair\nkeypair = Keypair.create_from_private_key(privatekey, crypto_type=KeypairType.ECDSA)\n\n# Form a transaction call\ncall = ws_provider.compose_call(\n    call_module=\"Balances\",\n    call_function=\"transfer_allow_death\",\n    call_params={\n        \"dest\": \"0x44236223aB4291b93EEd10E4B511B37a398DEE55\",\n        \"value\": 1 * 10**18,\n    },\n)\n\n# Form a signed extrinsic\nextrinsic = ws_provider.create_signed_extrinsic(call=call, keypair=keypair)\n\n# Submit the extrinsic\ntry:\n    receipt = ws_provider.submit_extrinsic(extrinsic, wait_for_inclusion=True)\n    print(\n        \"Extrinsic '{}' sent and included in block '{}'\".format(\n            receipt.extrinsic_hash, receipt.block_hash\n        )\n    )\nexcept SubstrateRequestException as e:\n    print(\"Failed to send: {}\".format(e))\n</code></pre>"},{"location":"builders/substrate/libraries/py-substrate-interface/#offline-signing","title":"Offline Signing","text":"<p>You can sign transaction payloads or any arbitrary data using a keypair object through the <code>sign</code> method. This can be used for offline signing of transactions.</p> <ol> <li> <p>First, generate the signature payload on an online machine:</p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# Construct a transaction call\ncall = ws_provider.compose_call(\n    call_module=\"Balances\",\n    call_function=\"transfer_allow_death\",\n    call_params={\n        \"dest\": \"0x44236223aB4291b93EEd10E4B511B37a398DEE55\",\n        \"value\": 1 * 10**18,\n    },\n)\n\n# Generate the signature payload\nsignature_payload = ws_provider.generate_signature_payload(call=call)\n</code></pre> </li> <li> <p>On an offline machine, create a keypair with the private key of the sending account, and sign the signature payload:</p> <pre><code># Imports\nfrom substrateinterface import Keypair, KeypairType\n\n# Define the signature payload from the offline machine\nsignature_payload = \"INSERT_SIGNATURE_PAYLOAD\"\n\n# Define the shortform private key of the sender account\nprivatekey = bytes.fromhex(\"INSERT_PRIVATE_KEY_WITHOUT_0X_PREFIX\")\n\n# Generate the keypair from shortform private key\nkeypair = Keypair.create_from_private_key(privatekey, crypto_type=KeypairType.ECDSA)\n\n# Sign the signature_payload \nsignature = keypair.sign(signature_payload)\n</code></pre> </li> <li> <p>On an online machine, create a keypair with the public key of the sending account, and submit the extrinsic with the generated signature from the offline machine:</p> <pre><code># Imports\nfrom substrateinterface import SubstrateInterface, Keypair, KeypairType\n\n# Construct the API provider\nws_provider = SubstrateInterface(\n    url=\"wss://wss.api.moonbase.moonbeam.network\",\n)\n\n# Define the signature from the offline machine\nsignature_payload = \"INSERT_SIGNATURE_PAYLOAD\"\n\n# Construct a keypair with the Ethereum style wallet address of the sending account\nkeypair = Keypair(public_key=\"INSERT_ADDRESS_WITHOUT_0X\", crypto_type=KeypairType.ECDSA)\n\n# Construct the same transaction call that was signed\ncall = ws_provider.compose_call(\n    call_module=\"Balances\",\n    call_function=\"transfer_allow_death\",\n    call_params={\n        \"dest\": \"0x44236223aB4291b93EEd10E4B511B37a398DEE55\",\n        \"value\": 1 * 10**18,\n    },\n)\n\n# Construct the signed extrinsic with the generated signature\nextrinsic = ws_provider.create_signed_extrinsic(\n    call=call, keypair=keypair, signature=signature\n)\n\n# Submit the signed extrinsic\nresult = ws_provider.submit_extrinsic(extrinsic=extrinsic)\n\n# Print the execution result\nprint(result.extrinsic_hash)\n</code></pre> </li> </ol>"},{"location":"builders/substrate/libraries/py-substrate-interface/#custom-rpc-requests","title":"Custom RPC Requests","text":"<p>You can also make custom RPC requests with the <code>rpc_request</code> method.</p> <p>This is particularly useful for interacting with Moonbeam's Ethereum JSON-RPC endpoints or Moonbeam's custom RPC endpoints.</p> <p>The Consensus and Finality page has examples for using the custom RPC calls through Python Substrate Interface to check the finality of a transaction given its transaction hash.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/substrate/libraries/sidecar/","title":"Using Substrate API Sidecar with Moonbeam","text":""},{"location":"builders/substrate/libraries/sidecar/#introduction","title":"Introduction","text":"<p>Substrate API Sidecar allows applications to access blocks, account balance, and other information of Substrate-based blockchains through a REST API. This can be useful for exchanges, wallets or other types of applications that need to keep track of account balance and other state changes on a Moonbeam network. This page will describe how to install and run a Substrate API Sidecar for Moonbeam, and the commonly used API endpoints.</p>"},{"location":"builders/substrate/libraries/sidecar/#installing-and-running-substrate-api-sidecar","title":"Installing and Running Substrate API Sidecar","text":"<p>There are multiple ways of installing and running the Substrate API Sidecar. This guide will describe the steps for installing and running it locally through NPM. For running Substrate API Sidecar through Docker, or building and running it from source, please refer to the Substrate API Sidecar Github Repository.</p>"},{"location":"builders/substrate/libraries/sidecar/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Running this service locally through NPM requires Node.js to be installed.</p> <p>You need to install Node.js (for this example, you can use v16.x) and the npm package manager. You can download directly from Node.js or in your terminal:</p> UbuntuMacOS <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n\nsudo apt install -y nodejs\n</code></pre> <pre><code># You can use homebrew (https://docs.brew.sh/Installation)\nbrew install node\n\n# Or you can use nvm (https://github.com/nvm-sh/nvm)\nnvm install node\n</code></pre> <p>You can verify that everything is installed correctly by querying the version for each package:</p> <pre><code>node -v\n</code></pre> <pre><code>npm -v\n</code></pre>"},{"location":"builders/substrate/libraries/sidecar/#installing-the-substrate-api-sidecar","title":"Installing the Substrate API Sidecar","text":"<p>To install the Substrate API Sidecar service locally in the current directory, run this from the command line:</p> <pre><code>npm install @substrate/api-sidecar@20.12.0\n</code></pre> <p>Note</p> <p>If the current folder does not already have a Node.js project structure, you need to manually create the <code>node_modules</code> directory by typing <code>mkdir node_modules</code>.</p> <p>Substrate API Sidecar v20.12.0 is the current stable version that has been tested to work with Moonbeam networks. You can verify the installation was successful by typing from the installation directory root:</p> <pre><code>node_modules/.bin/substrate-api-sidecar --version\n</code></pre>"},{"location":"builders/substrate/libraries/sidecar/#setting-up-the-substrate-api-sidecar","title":"Setting up the Substrate API Sidecar","text":"<p>In the terminal that Sidecar will run, export the environmental variable for the WS endpoint of the network. Examples:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>export SAS_SUBSTRATE_URL=wss://wss.api.moonbeam.network\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=wss://wss.api.moonriver.moonbeam.network\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=wss://wss.api.moonbase.moonbeam.network\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=ws://127.0.0.1:9944\n</code></pre> <p>Please reference the Public Endpoints page for a full list of Moonbeam network endpoints.</p> <p>After setting the environmental variable, you can use the <code>echo</code> command to check that the environmental variable has been set correctly, by typing:</p> <pre><code>echo $SAS_SUBSTRATE_URL\n</code></pre> <p>And it should display the network endpoint you have just set.</p>"},{"location":"builders/substrate/libraries/sidecar/#generating-the-types-bundle","title":"Generating the Types Bundle","text":"<p>Moonbeam introduces custom types that differ from the standard Substrate types. For API clients like Substrate API Sidecar to properly understand and decode these custom types, you must provide Substrate API Sidecar with the corresponding custom types bundle for the respective network you're interacting with. Generating and associating the custom types bundle with Substrate API Sidecar is quick. </p> <p>First, ensure that you installed Parity's <code>generate-types-bundle</code> package:</p> <pre><code>npm install -g @substrate/generate-type-bundle\n</code></pre> <p>Then, run the following command to generate the types bundle for the respective network:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>generate-type-bundle -p \"$(pwd)\" -s moonbeam\n</code></pre> <pre><code>generate-type-bundle -p \"$(pwd)\" -s moonriver\n</code></pre> <pre><code>generate-type-bundle -p \"$(pwd)\" -s moonbase\n</code></pre> <p>Note that running subsequent commands will overwrite the existing <code>typesBundle.json.</code> You'll then need to set the <code>SAS_SUBSTRATE_TYPES_BUNDLE</code> environment variable as shown below. If you've renamed the <code>typesBundle.json,</code> ensure you use the correct file name. </p> <pre><code>export SAS_SUBSTRATE_TYPES_BUNDLE=\"$(pwd)/typesBundle.json\"\n</code></pre> <p>After setting the environment variable, you can verify that you set it correctly by using the following <code>echo</code> command:</p> <pre><code>echo $SAS_SUBSTRATE_TYPES_BUNDLE\n</code></pre>"},{"location":"builders/substrate/libraries/sidecar/#running-substrate-api-sidecar","title":"Running Substrate API Sidecar","text":"<p>With the network endpoint environmental variable set, and from the installation directory root, run:</p> <pre><code>node_modules/.bin/substrate-api-sidecar \n</code></pre> <p>If the installation and configuration are successful, you should see this output in the console:</p> node_modules/.bin/substrate-api-sidecar v0.42.1: Pulling from moonbeamfoundation/moonbeam     SAS:         \ud83d\udce6 LOG:             \u2705 LEVEL: \"info\"             \u2705 JSON: false             \u2705 FILTER_RPC: false             \u2705 STRIP_ANSI: false             \u2705 WRITE: false             \u2705 WRITE_PATH: \"/temp/node_modules/@substrate/api-sidecar/build/src/logs\"             \u2705 WRITE_MAX_FILE_SIZE: 5242880             \u2705 WRITE_MAX_FILES: 5         \ud83d\udce6 SUBSTRATE:             \u2705 URL: \"wss://wss.api.moonbeam.network\"             \u2705 TYPES_BUNDLE: \"/Users/alice/sidecar/typesBundle.json\"             \u2705 TYPES_CHAIN: undefined             \u2705 TYPES_SPEC: undefined             \u2705 TYPES: undefined         \ud83d\udce6 EXPRESS:             \u2705 BIND_HOST: \"127.0.0.1\"             \u2705 PORT: 8080             \u2705 KEEP_ALIVE_TIMEOUT: 5000     2024-05-07 11:29:54 info: Version: 20.12.0     ...     2024-05-07 11:29:55 info: Connected to chain Moonbeam on the moonbeam client at wss://wss.api.moonbeam.network     2024-05-07 11:29:55 info: Listening on http://127.0.0.1:8080/     2024-05-07 11:29:55 info: Check the root endpoint (http://127.0.0.1:8080) to see the available endpoints for the current node"},{"location":"builders/substrate/libraries/sidecar/#substrate-api-sidecar-endpoints","title":"Substrate API Sidecar Endpoints","text":"<p>Some of the commonly used Substrate API Sidecar endpoints include:</p> <ul> <li>GET /blocks\u200b/head \u2014 Get the most recently finalized block. The optional parameter <code>finalized</code> can be set to <code>false</code> to the get the newest known block, which may not be finalized</li> <li>GET /blocks/head/header \u2014 Get the most recently finalized block header. The optional parameter <code>finalized</code> can be set to <code>false</code> to the get the newest known block header, which may not be finalized</li> <li>GET /blocks/{blockId} \u2014 Get a block by its height or hash</li> <li>GET /accounts/{accountId}/balance-info \u2014 Get balance information for an account</li> <li>GET /node/version \u2014 Get information about the Substrates node's implementation and versioning</li> <li>GET /runtime/metadata \u2014 Get the runtime metadata in decoded, JSON form.</li> </ul> <p>For a full list of API endpoints available on Substrate API Sidecar, please refer to the official documentation.</p>"},{"location":"builders/substrate/libraries/sidecar/#evm-fields-mapping-in-block-json-object","title":"EVM Field Mapping in Block JSON Object","text":"<p>Substrate API Sidecar returns Moonbeam blocks as a JSON object. Information related to EVM execution of Moonbeam transactions is under the <code>extrinsics</code> top level field, where individual extrinsics are organized numerically as nested JSON objects. The nesting structure is as following:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"ethereum\"\n                |--method: \"transact\"\n            |--signature\n            |--nonce \n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"ethereum\"\n                        |--method: \"Executed\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n                        |--3\n    ...\n</code></pre> <p>Moonbeam EVM transactions can be identify by the <code>method</code> field under the current extrinsic object, where it is set to:</p> <pre><code>{extrinsic_number}.method.pallet = \"ethereum\"\n{extrinsic_number}.method.method = \"transact\"\n</code></pre>"},{"location":"builders/substrate/libraries/sidecar/#transaction-types-and-payload","title":"Transaction Types and Payload","text":"<p>The Moonbeam EVM currently supports three transaction standards: <code>legacy</code>, <code>eip1559</code>, and <code>eip2930</code>. These correspond to the <code>transaction type</code> field in the above JSON object diagram. For each transaction type, the transaction payload contains the following fields:</p> EIP1559LegacyEIP2930 <pre><code>    ...\n    |--eip1559\n        |--chainId\n        |--nonce\n        |--maxPriorityFeePerGas\n        |--maxFeePerGas\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--accessList\n        |--oddYParity\n        |--r\n        |--s\n    ...\n</code></pre> <pre><code>    ...\n    |--legacy\n        |--nonce\n        |--gasPrice\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--signature\n    ...\n</code></pre> <pre><code>    ...\n    |--eip2930\n        |--chainId\n        |--nonce\n        |--gasPrice\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--accessList\n        |--oddYParity\n        |--r\n        |--s\n    ...\n</code></pre> <p>For more information on the new EIP1559 and EIP2930 transaction types and what each field means, please refer to the respective official Ethereum proposal specs.</p>"},{"location":"builders/substrate/libraries/sidecar/#transaction-field-mappings","title":"Transaction Field Mappings","text":"<p>To obtain the EVM sender address, recipient address, and EVM hash of any EVM transaction type, check the <code>events</code> field under the current extrinsic object, and identify the event where the <code>method</code> field is set to:</p> <pre><code>{event_number}.method.pallet: \"ethereum\"\n{event_number}.method.method: \"Executed\" \n</code></pre> <p>The EVM field mappings are then summarized as the following:</p> EIP1559LegacyEIP2930 EVM Field Block JSON Field Chain ID <code>extrinsics[extrinsic_number].args.transaction.eip1559.chainId</code> Nonce <code>extrinsics[extrinsic_number].args.transaction.eip1559.nonce</code> Max priority fee per gas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas</code> Max fee per gas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.eip1559.gasLimit</code> Access list <code>extrinsics[extrinsic_number].args.transaction.eip1559.accessList</code> Signature <code>extrinsics[extrinsic_number].args.transaction.eip1559.oddYParity/r/s</code> Sender address <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Recipient address <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> EVM hash <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> EVM execution status <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> EVM Field Block JSON Field Nonce <code>extrinsics[extrinsic_number].args.transaction.legacy.nonce</code> Gas price <code>extrinsics[extrinsic_number].args.transaction.legacy.gasPrice</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.legacy.gasLimit</code> Value <code>extrinsics[extrinsic_number].args.transaction.legacy.value</code> Signature <code>extrinsics[extrinsic_number].args.transaction.legacy.signature</code> Sender address <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Recipient address <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> EVM hash <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> EVM execution status <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> EVM Field Block JSON Field Chain ID <code>extrinsics[extrinsic_number].args.transaction.eip2930.chainId</code> Nonce <code>extrinsics[extrinsic_number].args.transaction.eip2930.nonce</code> Gas price <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasLimit</code> Value <code>extrinsics[extrinsic_number].args.transaction.eip2930.value</code> Access list <code>extrinsics[extrinsic_number].args.transaction.eip2930.accessList</code> Signature <code>extrinsics[extrinsic_number].args.transaction.eip2930.oddYParity/r/s</code> Sender address <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Recipient address <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> EVM hash <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> EVM execution status <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> <p>Note</p> <p>For Substrate transactions, the \"Nonce\" and \"Signature\" fields are under <code>extrinsics[extrinsic_number]</code>. For EVM transactions, the \"Nonce\" and \"Signature\" fields are under <code>extrinsics[extrinsic_number].args.transaction[transaction_type]</code>, leaving the \"Nonce\" and \"Signature\" under <code>extrinsics[extrinsic_number]</code> to be <code>null</code>.</p> <p>A successfully executed EVM transaction will return either <code>succeed: \"Stopped\"</code> or <code>succeed: \"Returned\"</code> under the \"EVM Execution Status\" field.</p>"},{"location":"builders/substrate/libraries/sidecar/#erc-20-token-transfers","title":"ERC-20 Token Transfers","text":"<p>Events emitted by smart contracts such as an ERC-20 token contract deployed on Moonbeam can be decoded from Sidecar block JSON objects. The nesting structure is as following:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"ethereum\"\n                |--method: \"transact\"\n            |--signature:\n            |--nonce: \n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"evm\"\n                        |--method: \"Log\"\n                    |--data\n                        |--0\n                            |-- address\n                            |-- topics\n                                |--0\n                                |--1\n                                |--2\n                            |-- data\n            ...\n    ...\n</code></pre> <p>Moonbeam ERC-20 token transfers will emit the <code>Transfer</code> event which can be decoded as the following:</p> Tx Information Block JSON Field ERC-20 contract address <code>extrinsics[extrinsic_number].events[event_number].data[0].address</code> Event signature hash <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[0]</code> Sender address <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[1]</code> Recipient address <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[2]</code> Amount <code>extrinsics[extrinsic_number].events[event_number].data[0].data</code> <p>Other events emitted by EVM smart contracts can be decoded in a similar fashion, but the content of the topics and data fields will change depending on the definition of the specific event.</p> <p>Note</p> <p>The amount transferred is given in Wei and in hexadecimal format.</p>"},{"location":"builders/substrate/libraries/sidecar/#sample-code-for-monitoring-native-token-transfers","title":"Sample Code for Monitoring Native Token Transfers","text":"<p>The Transfers API page has a code snippet demonstrating how to use Substrate API Sidecar to retrieve and decode native token transfers sent with both Substrate and Ethereum APIs on Moonbeam networks. You can reference that as a starting point to build out backends that utilize Sidecar to listen to transfers on Moonbeam networks.</p>"},{"location":"builders/substrate/libraries/sidecar/#calculating-transaction-fees","title":"Calculating Transaction Fees","text":"<p>For more detailed information and sample code on how to calculate the transaction fees of Moonbeam transactions using Substrate Sidecar API, please check the Calculating Transaction Fees on Moonbeam page.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"learn/dapp-directory/","title":"How to List your Project on the Moonbeam DApp Directory","text":""},{"location":"learn/dapp-directory/#introduction-to-state-of-the-dapps","title":"Introduction to the Moonbeam DApp Directory","text":"<p>The Moonbeam ecosystem comprises two distinct production networks: Moonbeam and Moonriver. Each network has its own dedicated DApp Directory, maintained by the Moonbeam Foundation: Moonbeam and Moonriver. These directories categorize projects spanning from DeFi to NFTs to gaming, providing users with comprehensive access to diverse applications.</p> <p>You'll supply core project details like name, description, and relevant links when adding your project. Depending on your project type, you may include additional data such as on-chain stats and token information.</p> <p>Despite the distinction between the Moonbeam and Moonriver DApp directories, the submission process remains the same. To list your project on the DApp Directory, you must submit a pull request to the Moonbeam Foundation's App Directory Data repository on GitHub. This guide outlines the necessary data and formatting specifics for your submission.</p> <p></p>"},{"location":"learn/dapp-directory/#overview-project-data","title":"Overview of the Project Data","text":"<p>There are four main sources of data that are used for a project's listing in the Moonbeam DApp Directory:</p> <ul> <li>Core project data: Core project data such as descriptions, logos, and screenshots. This data also includes IDs used to query data from external platforms.</li> <li>Active users and transaction volume: On-chain data based on smart contract activity for all of the contracts associated with the project. Data is discovered via the use of contract labeling in Moonscan and is indexed and consumed by the DApp Directory.</li> <li>TVL data: TVL data for the protocol, sourced from the project's listing on DefiLlama.</li> <li>Project token information: Token information, which is sourced from the project's listing on CoinGecko.</li> </ul>"},{"location":"learn/dapp-directory/#configuring-external-data-sources","title":"Prerequisites for Using External Data Sources","text":"<p>Before pulling data from the mentioned sources, certain prerequisites must be fulfilled. However, it's worth noting that these steps may not apply to all project types. For instance, in the case of wallets, where there are no smart contracts, the DApp Directory is currently unable to display user and transaction activity data.</p>"},{"location":"learn/dapp-directory/#configure-active-users","title":"Configure the Data Source for Active Users and Transaction Volume","text":"<p>For projects that have smart contracts deployed on Moonbeam or Moonriver, it is important that those contracts can be linked to the DApp Directory project data.</p> <p>The end-to-end flow for linking smart contract activity to the DApp Directory is as follows:</p> <ol> <li>The smart contract owner fills in the form to label contracts on Moonscan.</li> <li>The contracts become labeled in Moonscan.</li> <li>Labeled contracts can then be ingested by ecosystem analytics providers to index activity for your project.</li> <li>(Recommended) Register your project with FiDi so your activity can be indexed and publicly viewable. See the FiDi registration section below.</li> </ol> <p>To get your project's smart contracts properly labeled on Moonscan, submit the Moonscan contract labeling form with your project and contract details.</p>"},{"location":"learn/dapp-directory/#register-with-fidi","title":"Register with FiDi for Analytics (Recommended)","text":"<p>New and existing projects are encouraged to register with FiDi so your project's activity can be indexed and surfaced in public analytics. Submit your project using the FiDi Project Listing Form.</p> <p>After submission, Moonbeam FiDi analytics can be viewed on the Moonbeam FiDi Dashboard.</p> <p>Required Project Information:</p> <p>Where possible, include a short purpose description for each contract to improve completeness.</p> <ul> <li>Core smart contracts: Addresses of main contracts that define core functionality and interact significantly with the network. Optionally, include a brief description of each contract's purpose.</li> <li>Factory contracts: If applicable, addresses of any contracts that deploy other contracts as part of your dApp. Please also provide the creation topic (hash of the creation event) for each factory contract.</li> <li>Deployer wallets: If applicable, addresses of wallets used to deploy your project's contracts.</li> </ul> <p>Additional Project-Specific Information (Optional):</p> <ul> <li>Treasury/Admin wallets: Addresses of wallets with administrative control or funds. Optionally, include a brief description of each wallet's function.</li> <li>Oracle contracts: Addresses of any oracle contracts. Optionally, include a brief description of what data these oracles provide.</li> <li>Bridge contracts: Addresses of any bridge contracts and the list of connected chains.</li> <li>Governance contracts: Addresses of any contracts related to on-chain governance. Optionally, include a brief explanation of your governance model.</li> </ul> <p>Additional considerations:</p> <ul> <li>If your project batches transactions, consider using the Batch Precompile.</li> <li>Factory contracts should derive from or mimic the standard Uniswap factory.</li> <li>Diamond (multi-facet proxy) contracts are supported and will be indexed correctly.</li> <li>Typical listing time is 1\u20132 weeks; FiDi may reach out for clarifications.</li> </ul> <p>Once you've labeled your smart contracts and are ready to submit your project to the DApp Directory, configuring the Directory to utilize your smart contract data becomes straightforward. You'll only need the Project component of your labeled contracts.</p> <p>Consider the following example project with two smart contracts: a Comptroller and a Router recently updated to a new version.</p> Project Contract Name Contract Version Resulting Label My Project Comptroller V1 My Project: Comptroller V1 My Project Router V2 My Project: Router V2 <p>To submit your project to the Moonbeam DApp Directory, ensure you have your Project name ready, identified here as <code>My Project</code>.</p> <p>If you're ready to add your project to the DApp Directory, skip to the How to Submit Your Project Listing section.</p>"},{"location":"learn/dapp-directory/#configure-tvl","title":"Configure the Data Source for TVL","text":"<p>If the project represents a DeFi protocol with TVL (whereby value is locked in the protocol's smart contract), it is possible to display TVL in the Moonbeam DApp Directory.</p> <p>TVL data is pulled from DefiLlama, so you must list your project there. To get your project listed, please refer to DefiLlama's documentation on How to list a DeFi project.</p> <p>After listing your project, you can easily configure the DApp Directory to pull data from DefiLlama. To do so, you'll need the DefiLlama identifier, which you can find in the URL for your protocol's page. For example, the URL for Moonwell's page is <code>https://defillama.com/protocol/moonwell</code>, so the identifier is <code>moonwell</code>.</p> <p>If you have the identifier and are ready to submit your project to the Moonbeam DApp Directory, skip to the How to Submit Your Project Listing section.</p>"},{"location":"learn/dapp-directory/#project-token-information","title":"Configure the Data Source for Project Token Information","text":"<p>If a project has a token, it is possible to display the name of the token, current price, and contract in the DApp Directory.</p> <p>However, the data is pulled from CoinGecko, so the project's token must be listed there. If your token is not listed there, you can complete CoinGecko's Request Form to initiate the listing process.</p> <p>Assuming your project's token is listed there, you must obtain the CoinGecko API ID value. You can find the API ID value in the Information section of the token's page on CoinGecko. For example, the API ID on Moonwell's token page is <code>moonwell-artemis</code>.</p> <p>If you have the CoinGecko ID and are ready to submit your project to the Moonbeam DApp Directory, you can continue to the next section.</p>"},{"location":"learn/dapp-directory/#how-to-submit-your-project-listing","title":"How to Submit Your Project Listing","text":"<p>As mentioned, you must submit a pull request to the Moonbeam Foundation's GitHub repository that holds the DApp Directory's data. Before getting started, it's worth noting that to expedite the review process, the GitHub user who submits the pull request is recommended to be a major contributor to the project's GitHub so that the Moonbeam Foundation can quickly verify that they represent the project. You can check out the Review Process section for more information.</p> <p>To begin, you have two options for adding your project information to the <code>app-directory-data</code> repository on GitHub. You can utilize GitHub's browser-based editor, which offers a user-friendly interface.</p> <p></p> <p>Or you can clone the repository locally and make modifications using your preferred code editor, in which you can use the following command to clone the repository:</p> <pre><code>git clone https://github.com/moonbeam-foundation/app-directory-data.git\n</code></pre> <p>Once you've cloned the project, you can create a new branch to which you will add all of your changes. To do this on the browser-based editor, take the following steps:</p> <ol> <li>Click on the current branch name in the bottom left corner.</li> <li>A menu will appear at the top of the page. Enter the name of your branch.</li> <li>Click Create new branch....</li> </ol> <p></p> <p>The page will reload, and your branch name will now be displayed in the bottom left corner.</p>"},{"location":"learn/dapp-directory/#projects-with-deployments","title":"Projects with Deployments on Moonbeam and Moonriver","text":"<p>If a project is deployed to both Moonbeam and Moonriver, there are two different options available:</p> <ul> <li>Create a separate project structure for each deployment.</li> <li>Use a single project structure and modify the project data file for both projects.</li> </ul> <p>Separate project structures should be used if:</p> <ul> <li>The two deployments have distinct representations in DefiLlama (i.e., two distinct identifiers).</li> <li>The project has two different tokens, one native to Moonbeam and one native to Moonriver.</li> </ul> <p>Otherwise, either option may be used.</p>"},{"location":"learn/dapp-directory/#set-up-the-file-structure","title":"Set Up the Folder Structure for Your Project","text":"<p>All configurations for each project listed in the DApp Directory are stored in the <code>projects</code> folder.</p> <p>To get started, you must have a name that uniquely and properly identifies your project. Using your project name, you can take the following steps:</p> <ol> <li>Create a new directory for your project using your unique project name.</li> <li>In your project directory, you'll need to create:<ol> <li>A project data file is a JSON file that defines all your project data and contains references to the images stored in the <code>logos</code> and <code>screenshots</code> folders. The list of fields you can use to define your data, with descriptions, is outlined in the next section. The file must be named using your unique project name.</li> <li>A <code>logos</code> folder where your project logo images are stored.</li> <li>(Optional) A <code>screenshots</code> folder where screenshots for the project are stored.</li> </ol> </li> </ol> Example folder structure <pre><code>my-project\n\u251c\u2500\u2500 my-project.json\n\u251c\u2500\u2500 logos\n\u2502   \u251c\u2500\u2500 my-project-logo-small.jpeg\n\u2502   \u2514\u2500\u2500 my-project-logo-full.jpeg\n\u2514\u2500\u2500 screenshots\n    \u251c\u2500\u2500 my-project-screenshot1-small.jpeg\n    \u251c\u2500\u2500 my-project-screenshot1-full.jpeg\n    \u251c\u2500\u2500 my-project-screenshot2-small.jpeg\n    \u2514\u2500\u2500 my-project-screenshot2-full.jpeg\n</code></pre> <p></p> <p>With the foundational file structure in place, you're ready to populate the necessary information for your project submission.</p>"},{"location":"learn/dapp-directory/#add-information","title":"Add Information to the Project Data File","text":"<p>Your project's data file is where you'll add all the information for your project. The file permits the following top-level properties:</p> Property Type Description <code>id</code> String Unique identifier for the dApp in the Moonbeam DApp Directory. It should be a unique, human-readable string representing this project. E.g., <code>my-project</code> <code>slug</code> String Identifier used in certain third-party sources. In particular, if the project is listed in DefiLlama, this value should be set to the DefiLlama identifier. See the Configure the Data Source for TVL section for more information <code>name</code> String The project name as it will appear in the DApp Directory. E.g., <code>My Project</code> <code>category</code> String The category the project should be associated with. A project can only have one category, and it corresponds to the category list in the left-hand nav of the DApp Directory. See the Category and Tags section for the accepted list of values <code>coinGeckoId</code> String If the project has a token listed on CoinGecko, this property should have the API ID value corresponding to the given token. See the Configure the Data Source for Project Token Information section for more information <code>chains</code> Array of Strings List of Moonbeam ecosystem chains on which the project is deployed. Valid values are currently <code>moonbeam</code> and <code>moonriver</code> <code>logo</code> Map of Strings to JSON objects Map of logo image files associated with this project and stored in the <code>logos</code> directory. See the Logos section for more information <code>shortDescription</code> String A short description of the project used in the display card when browsing dapps in the directory. This should be kept to under 80 characters <code>description</code> String A longer description used in the project detail page. Markdown or similar formatting cannot be used. Line breaks can be used using <code>\\r\\n</code>. The text should be limited to a few paragraphs <code>tags</code> Array of Strings A list of applicable tags for this project. Tag values will show up in the project details. See the Category and Tags section for the accepted list of values <code>contracts</code> Array of contract JSON objects List of contracts for the project. Currently, this is used only for token contracts. The list of smart contracts which make up the protocol is externally sourced from Moonscan. See the Contracts section for more information <code>urls</code> Map of Strings (names) to Strings (URLs) Mapping of URLs for websites and socials associated with the project. See the URLs section for the accepted list of properties <code>screenshots</code> Array of Maps of Strings (size) to image JSON objects List of screenshot image files associated with this project and stored in the <code>screenshots</code> directory. See the Screenshots section for more information <code>projectCreationDate</code> int The date the project was created. Used for sorting purposes in the DApp Directory Example project data file <pre><code>{\n    \"id\": \"moonwell\",\n    \"slug\": \"moonwell\",\n    \"name\": \"Moonwell\",\n    \"category\": \"lending\",\n    \"coinGeckoId\": \"moonwell-artemis\",\n    \"chains\": [\n        \"moonbeam\"\n    ],\n    \"logo\": {\n        \"small\": {\n            \"fileName\": \"moonwell-logo-small.jpeg\",\n            \"width\": 40,\n            \"height\": 40,\n            \"mimeType\": \"image/jpeg\"\n        },\n        \"large\": {\n            \"fileName\": \"moonwell-logo-large.jpeg\",\n            \"width\": 400,\n            \"height\": 400,\n            \"mimeType\": \"image/jpeg\"\n        },\n        \"full\": {\n            \"fileName\": \"moonwell-logo-full.jpeg\",\n            \"width\": 3000,\n            \"height\": 3000,\n            \"mimeType\": \"image/jpeg\"\n        }\n    },\n    \"shortDescription\": \"Lending, borrowing, and DeFi protocol built on Moonbeam and Moonriver\",\n    \"description\": \"Moonwell is an open lending, borrowing, and decentralized finance protocol built on Moonbeam and Moonriver. Moonwell\u2019s composable design can accommodate a full range of DeFi applications in the greater Polkadot and Kusama (DotSama) ecosystem.\\r\\n\\r\\nOur first deployment will be on Kusama\u2019s Moonriver, the sister network of Polkadot\u2019s Moonbeam. Moonriver is where new products are expected to be incubated and developed prior to being deployed on Moonbeam.\",\n    \"tags\": [\n        \"Lending\",\n        \"DeFi\"\n    ],\n    \"contracts\": [\n        {\n            \"contract\": \"0x511ab53f793683763e5a8829738301368a2411e3\",\n            \"chain\": \"moonbeam\",\n            \"name\": \"WELL Token\"\n        }\n    ],\n    \"urls\": {\n        \"website\": \"https://moonwell.fi/\",\n        \"try\": \"https://moonwell.fi/\",\n        \"twitter\": \"https://twitter.com/MoonwellDeFi\",\n        \"medium\": \"https://moonwell.medium.com/\",\n        \"telegram\": \"https://t.me/moonwellfichat\",\n        \"github\": \"https://github.com/moonwell-open-source\",\n        \"discord\": \"https://discord.gg/moonwellfi\"\n    },\n    \"screenshots\": [\n        {\n            \"small\": {\n                \"fileName\": \"moonwell-screenshot-small1.png\",\n                \"width\": 429,\n                \"height\": 200,\n                \"mimeType\": \"image/png\"\n            },\n            \"full\": {\n                \"fileName\": \"moonwell-screenshot-full1.png\",\n                \"width\": 514,\n                \"height\": 300,\n                \"mimeType\": \"image/png\"\n            }\n        },\n        {\n            \"small\": {\n                \"fileName\": \"moonwell-screenshot-small2.png\",\n                \"width\": 429,\n                \"height\": 200,\n                \"mimeType\": \"image/png\"\n            },\n            \"full\": {\n                \"fileName\": \"moonwell-screenshot-full2.png\",\n                \"width\": 1716,\n                \"height\": 800,\n                \"mimeType\": \"image/png\"\n            }\n        },\n        {\n            \"small\": {\n                \"fileName\": \"moonwell-screenshot-small3.png\",\n                \"width\": 429,\n                \"height\": 200,\n                \"mimeType\": \"image/png\"\n            },\n            \"full\": {\n                \"fileName\": \"moonwell-screenshot-full3.png\",\n                \"width\": 1054,\n                \"height\": 637,\n                \"mimeType\": \"image/png\"\n            }\n        },\n        {\n            \"small\": {\n                \"fileName\": \"moonwell-screenshot-small4.png\",\n                \"width\": 429,\n                \"height\": 200,\n                \"mimeType\": \"image/png\"\n            },\n            \"full\": {\n                \"fileName\": \"moonwell-screenshot-full4.png\",\n                \"width\": 1365,\n                \"height\": 436,\n                \"mimeType\": \"image/png\"\n            }\n        }\n    ],\n    \"projectCreationDate\": 1644828523000\n}\n</code></pre>"},{"location":"learn/dapp-directory/#category-and-tags","title":"Category and Tags","text":"<p>A category is the primary classification for a project. A project can be categorized under only one category, but it can have multiple tags. Ensure you carefully select the most applicable category for your project to ensure it is easily found. Any secondary classifications can be included as a tag. </p> <p>The currently supported values for <code>category</code> are:</p> <pre><code>- Bridges\n- DAO\n- DEX\n- DeFi\n- Gaming\n- Lending\n- NFTs\n- Other\n- Social\n- Wallets\n</code></pre> <p>The currently supported values for <code>tag</code> are:</p> <pre><code>- Bridges\n- DAO\n- DEX\n- DeFi\n- DePIN\n- Developer Tools\n- Explorers\n- Files\n- GLMR Grants\n- Gaming\n- Infrastructure\n- IoT\n- Lending\n- MOVR Grants\n- Messaging\n- NFT\n- NFT Marketplaces\n- On-ramp\n- Other\n- Social\n- Tool\n- VPN\n- Wallets\n- ZeroTrust\n</code></pre>"},{"location":"learn/dapp-directory/#urls","title":"URLs","text":"<p>The <code>urls</code> property name/value pairs are used so a project can provide links to their website, socials, etc.</p> <p>The following table lists the supported <code>urls</code> properties:</p> Property Name Description Example <code>website</code> The main website for the project https://moonbeam.network/ <code>try</code> URL a user should visit if they want to try out the dApp. Typically, this page will have a link to launch the dApp https://moonbeam.network/ <code>twitter</code> The project's X (Twitter) profile https://x.com/MoonbeamNetwork <code>medium</code> The project's Medium site https://medium.com/moonbeam-network <code>telegram</code> The project's Telegram https://t.me/Moonbeam_Official <code>github</code> The project's GitHub repository https://github.com/moonbeam-foundation/moonbeam <code>discord</code> The project's Discord https://discord.com/invite/PfpUATX <p>The format of the property name/value pairs should follow the JSON standard, for example:</p> <pre><code>\"urls\": {\n    \"website\": \"https://moonbeam.network/\",\n    \"try\": \"https://docs.moonbeam.network/\",\n    \"twitter\": \"https://x.com/MoonbeamNetwork\"\n}\n</code></pre>"},{"location":"learn/dapp-directory/#logos","title":"Logos","text":"<p>The <code>logos</code> property of the main project data file is a map of image sizes (i.e., <code>small</code>, <code>large</code>, <code>full</code>) to corresponding image JSON objects. The image JSON object contains the display properties for the given image.</p> <p>The following table lists the properties of the image JSON object:</p> Property Type Description <code>fileName</code> String The name of the image file (unqualified) stored in the <code>logos</code> directory <code>width</code> int The width of the logo image in pixels <code>height</code> int The height of the logo image in pixels <code>mimeType</code> String The standard MIME type of the file. E.g., <code>\"image/jpeg\"</code> <p>Currently, only the <code>small</code> size is utilized, and the dimensions for small logos should be 40x40 pixels.</p> <p>Here is an example showing the structure of the <code>logo</code> property that supplies <code>small</code> and <code>full</code> logos:</p> <pre><code>\"logo\": {\n    \"small\": {\n        \"fileName\": \"my-project-logo-small.jpeg\",\n        \"width\": 40,\n        \"height\": 40,\n        \"mimeType\": \"image/jpeg\"\n    },\n    \"full\": {\n        \"fileName\": \"my-project-logo-full.jpeg\",\n        \"width\": 3000,\n        \"height\": 3000,\n        \"mimeType\": \"image/jpeg\"\n    }\n}\n</code></pre>"},{"location":"learn/dapp-directory/#screenshots","title":"Screenshots","text":"<p>The <code>screenshots</code> property of the main project data file is an array of maps. Each map in the array is for a specific screenshot.</p> <p>However, different-sized images for each screenshot should be supplied so that different sizes can be used in different contexts (e.g., thumbnails vs full-sized images). Thus, for each screenshot, there is a map of image sizes (i.e., <code>small</code>, <code>large</code>, <code>full</code>) to corresponding image JSON objects. The image JSON object contains the display properties for the given image.</p> <p>The following table lists the properties of the image JSON object:</p> Property Type Description <code>fileName</code> String The name of the image file (unqualified) stored in the <code>screenshots</code> directory <code>width</code> int The width of the logo image in pixels <code>height</code> int The height of the logo image in pixels <code>mimeType</code> String The standard MIME type of the file. E.g., <code>\"image/jpeg\"</code> <p>Here is an example showing the structure of the <code>screenshot</code> property for two screenshots (<code>screenshot1</code> and <code>screenshot2</code>):</p> <pre><code>\"screenshots\": [\n    {\n        \"small\": {\n            \"fileName\": \"my-project-screenshot1-small.png\",\n            \"width\": 429,\n            \"height\": 200,\n            \"mimeType\": \"image/png\"\n        },\n        \"full\": {\n            \"fileName\": \"my-project-screenshot1-full.png\",\n            \"width\": 514,\n            \"height\": 300,\n            \"mimeType\": \"image/png\"\n        }\n    },\n    {\n        \"small\": {\n            \"fileName\": \"my-project-screenshot2-small.png\",\n            \"width\": 429,\n            \"height\": 200,\n            \"mimeType\": \"image/png\"\n        },\n        \"full\": {\n            \"fileName\": \"my-project-screenshot2-full.png\",\n            \"width\": 1716,\n            \"height\": 800,\n            \"mimeType\": \"image/png\"\n        }\n    }\n]\n</code></pre>"},{"location":"learn/dapp-directory/#contracts","title":"Contracts","text":"<p>A list of contracts for the project. Currently, this is used only for token contracts.</p> <p>The smart contracts that make up the protocol are sourced from Moonscan based on tagging, so they do not need to be listed here. If you have not properly labeled your contracts or are unsure if they are labeled according to the Moonbeam community standard, please refer to the Configure the Data Source for Active Users and Transaction Volume section.</p> <p>The following table lists the properties found in the contract JSON object:</p> Property Type Description <code>contract</code> String The address for the smart contract <code>chain</code> String The chain on which the contract is deployed (i.e., <code>moonbeam</code> or <code>moonriver</code>) <code>name</code> String The name of the contract <p>Here is a <code>contracts</code> array with a single smart contract for the WGLMR token:</p> <pre><code>\"contracts\": [\n    {\n        \"contract\": \"0xAcc15dC74880C9944775448304B263D191c6077F\",\n        \"chain\": \"moonbeam\",\n        \"name\": \"Wrapped GLMR Token\"\n    }\n]\n</code></pre>"},{"location":"learn/dapp-directory/#submit-a-pull-request","title":"Submit a Pull Request","text":"<p>After you've populated the project data file and added your logos and screenshots, you should be ready to submit your pull request.</p> <p></p> <p>From the web-based editor, take the following steps to commit your changes to the <code>app-directory-data</code> repository:</p> <ol> <li>Click on the Source Control tab, which should show you how many pages have been added or changed.</li> <li>Review the files under the Changes section. Click the + button next to Changes, or as you review each file, click the + button next to the file name to add them to the list of Staged Changes.</li> </ol> <p></p> <p>All of your files should now be under the Staged Changes section. All you have to commit and push the changes are:</p> <ol> <li>Enter a descriptive commit message, such as \"Add My Project\", making sure to use your actual project name.</li> <li>Click Commit &amp; Push.</li> </ol> <p></p> <p>Now that you've committed the changes, you'll need to head over to the <code>app-directory-data</code> repository and open a pull request against the <code>develop</code> branch:</p> <ol> <li>At the top of the repository page, click Compare and Pull button displayed on the banner, or</li> <li>If the banner is not there anymore, you'll need to select your branch from the branches dropdown.</li> <li>Click the Contribute dropdown.</li> <li>Click the Open pull request button.</li> </ol> <p></p> <p>You'll be taken to the Comparing changes page, where you'll need to:</p> <ol> <li>Make sure that you are merging your branch into the <code>develop</code> branch, which is the base branch.</li> <li>Add a title.</li> <li>Add a description of the changes.</li> <li>Click Create pull request.</li> </ol> <p></p>"},{"location":"learn/dapp-directory/#review-process","title":"The Review Process","text":"<p>Submitted pull requests will be reviewed bi-weekly by the Moonbeam Foundation. During the review, and especially for new projects, the Foundation may have to verify that the GitHub user who created the pull request is a contributor and/or represents the specific project. One way projects can expedite this process is if the submitter's GitHub account is also a major contributor to the project itself on GitHub. Alternatively, teams should leave a note in the pull request comments indicating how we can get in touch with project team members to verify.</p> <p>A comment will be added to the pull request if any changes are requested. After your pull request has been approved, it will be merged, and your project will be added to the Moonbeam DApp Directory!</p>"},{"location":"learn/dapp-directory/#how-to-update-your-project-listing","title":"How to Update Your Project Listing","text":"<p>As your project evolves, you may need to update your project's listing or images related to your listing. You can create a new branch for your changes, find and modify your existing project's data from the root <code>projects</code> directory, and make the desired changes.</p> <p>If you are no longer using a logo or screenshot, please remember to remove it from the <code>logos</code> or <code>screenshots</code> directory.</p> <p>Once your changes have been made, you must follow the same instructions in the Submit a Pull Request section so the changes can be reviewed by the Moonbeam Foundation. Please note that pull requests are reviewed on a bi-weekly basis, so if the update is urgent, you can create a forum post asking for assistance.</p>"},{"location":"learn/dapp-directory/#dapp-directory-api","title":"DApp Directory API","text":"<p>The DApp Directory also features a queryable API that you can use to integrate data from Moonbeam's DApp Directory into your application. The API is public and currently does not require authentication. The base URL for the API is as follows:</p> <pre><code>https://apps.moonbeam.network/api/ds/v1/app-dir/\n</code></pre>"},{"location":"learn/dapp-directory/#query-a-project","title":"Query a Project","text":"<p>You can retrieve all the information for a particular project by appending <code>/projects/INSERT_PROJECT_NAME</code> to the base URL. If you need clarification on the project name, you can omit the project name as shown below to retrieve data for every listed project and find the project in the response. </p> <pre><code>https://apps.moonbeam.network/api/ds/v1/app-dir/projects\n</code></pre> <p>Here's an example of querying the API for StellaSwap, which returns the project description, social media information, user counts, relevant smart contract addresses, market data, images, and more. </p> <pre><code>https://apps.moonbeam.network/api/ds/v1/app-dir/projects/stellaswap\n</code></pre> <p>You can visit the query URL directory in the browser, using a tool like Postman, or directly from the command line with Curl as follows: </p> <pre><code>curl -H \"Content-Type: application/json\" -X GET 'https://apps.moonbeam.network/api/ds/v1/app-dir/projects/stellaswap'\n</code></pre> API Response to Querying StellaSwap <pre><code>{\n    \"project\":{\n        \"currentTx\":{\n            \"moonbeam\":2883079\n        },\n        \"web3goIDs\":[\n            \"StellaSwap\"\n        ],\n        \"name\":\"StellaSwap\",\n        \"currentTVL\":{\n            \"moonbeam\":5046832.23328\n        },\n        \"currentUsers\":{\n            \"moonbeam\":52455\n        },\n        \"coinGeckoId\":\"stellaswap\",\n        \"shortDescription\":\"The leading DEX and DeFi gateway on Moonbeam\",\n        \"id\":\"stellaswap\",\n        \"featured\":true,\n        \"tags\":[\n            \"DEX\",\n            \"DeFi\"\n        ],\n        \"tvlChange7d\":{\n            \"moonbeam\":-1.61482567543498\n        },\n        \"urls\":{\n            \"telegram\":\"https://t.me/stellaswap\",\n            \"website\":\"https://stellaswap.com/\",\n            \"try\":\"https://stellaswap.com/\",\n            \"twitter\":\"https://twitter.com/StellaSwap\",\n            \"github\":\"https://github.com/stellaswap\",\n            \"medium\":\"https://stellaswap.medium.com/\"\n        },\n        \"web3goContracts\":[\n            {\n                \"name\":\"StellaSwap: stDOT Oracle Master\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x3b23f0675ffc45153eca239664ccaefc5e816b9c\"\n            },\n            {\n                \"name\":\"StellaSwap: stDOT Token\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xbc7e02c4178a7df7d3e564323a5c359dc96c4db4\"\n            },\n            {\n                \"name\":\"StellaSwap: stDOT Controller\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x002d34d6a1b4a8e665fec43fd5d923f4d7cd254f\"\n            },\n            {\n                \"name\":\"StellaSwap: stDOT Proxy Admin\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xe8a5c0039226269313c89c093a6c3524c4d39fa4\"\n            },\n            {\n                \"name\":\"StellaSwap: madUSDC GLMR V2\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x2ad0e92461df950e2b1c72e2f7a865c81eaa3ce6\"\n            },\n            {\n                \"name\":\"StellaSwap: Dual ETH - GLMR Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x2ba130297d1966e077c2fb5e4b434e8802925277\"\n            },\n            {\n                \"name\":\"StellaSwap: BCMC Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x18e75887aa81e113636e18d5a78e3ff93787ec88\"\n            },\n            {\n                \"name\":\"StellaSwap: Pulsar Position Manager V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x1ff2adaa387dd27c22b31086e658108588eda03a\"\n            },\n            {\n                \"name\":\"StellaSwap: DualETH Pool LP Token V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xa3ee3a0a36dc915fdc93062e4b386df37d00217e\"\n            },\n            {\n                \"name\":\"StellaSwap: Interlay Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x3a7572220afaddc31a72a520642111776d92b2d2\"\n            },\n            {\n                \"name\":\"StellaSwap: Router V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xd0a01ec574d1fc6652edf79cb2f880fd47d34ab1\"\n            },\n            {\n                \"name\":\"StellaSwap: xStella - GLMR Rewarder 2nd V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb4dba7fe6fcc613963d64204fcf789e9e376679a\"\n            },\n            {\n                \"name\":\"StellaSwap: GLMR Rewarder First V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x69f9d134991e141c4244f397514ba05d67861cc0\"\n            },\n            {\n                \"name\":\"StellaSwap: CELER Rewarder 0 V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xbebd88782a1145b71df3f4986ef7686154ce01d9\"\n            },\n            {\n                \"name\":\"StellaSwap: MATICILO V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xfffa340944ff32f50c7935e2b5d22a7c3393b313\"\n            },\n            {\n                \"name\":\"StellaSwap: ETHmad - GLMR V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x9fe074a56ffa7f4079c6190be6e8452911b7e349\"\n            },\n            {\n                \"name\":\"StellaSwap: STELLA Token\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x0e358838ce72d5e61e0018a2ffac4bec5f4c88d2\"\n            },\n            {\n                \"name\":\"StellaSwap: SFL - 4pool Wormhole V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb1bc9f56103175193519ae1540a0a4572b1566f6\"\n            },\n            {\n                \"name\":\"StellaSwap: BICO Trusted Forwarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x3d08ce1f9609bb02f47192ff620634d9eb0e7b56\"\n            },\n            {\n                \"name\":\"StellaSwap: Gass Refund V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xee42d4861b56b32776e6fe9a2fe122af0e3f4a33\"\n            },\n            {\n                \"name\":\"StellaSwap: xcDOT - GLMR V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xe76215efea540ea87a2e1a4bf63b1af6942481f3\"\n            },\n            {\n                \"name\":\"StellaSwap: 4pool LP V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xda782836b65edc4e6811c7702c5e21786203ba9d\"\n            },\n            {\n                \"name\":\"StellaSwap: SFL LP V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xa0aa99f71033378864ed6e499eb03612264e319a\"\n            },\n            {\n                \"name\":\"StellaSwap: SFL - 4pool V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x422b5b7a15fb12c518aa29f9def640b4773427f8\"\n            },\n            {\n                \"name\":\"StellaSwap: Acala - GLMR Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x9de8171bebfa577d6663b594c60841fe096eff97\"\n            },\n            {\n                \"name\":\"StellaSwap: Zap V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x01834cf26717f0351d9762cc9cca7dc059d140df\"\n            },\n            {\n                \"name\":\"StellaSwap: GLMR Rewarder for UST - GLMR V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xc85ddcff71200f9673137e2f93ce504bdbf7db4e\"\n            },\n            {\n                \"name\":\"StellaSwap: xStella Token\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x06a3b410b681c82417a906993acefb91bab6a080\"\n            },\n            {\n                \"name\":\"StellaSwap: ETHmad - GLMR V2\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xa6ec79c97e533e7bddb00898e22c6908742e039b\"\n            },\n            {\n                \"name\":\"StellaSwap: WBTC - USDT Contract V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xcae51da6dceacd84f79df4b88d9f92035d1479e9\"\n            },\n            {\n                \"name\":\"StellaSwap: AVAXILO V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x96bef4719ae7c053113292e6aa7fc36e62b243e8\"\n            },\n            {\n                \"name\":\"StellaSwap: Swap For Gas V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb64dee2d182fed3dd6c273303fb08f11808c9c23\"\n            },\n            {\n                \"name\":\"StellaSwap: Farming Centre V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x0d4f8a55a5b2583189468ca3b0a32d972f90e6e5\"\n            },\n            {\n                \"name\":\"StellaSwap: FTMILO V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x096352f7ea415a336b41fc48b33142eff19a8ad8\"\n            },\n            {\n                \"name\":\"StellaSwap: Acala Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb7b5d3659ad213478bc8bfb94d064d0efdda8f7c\"\n            },\n            {\n                \"name\":\"StellaSwap: USDC Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xa52123adc0bc5c4c030d1ff4f5dad966366a646c\"\n            },\n            {\n                \"name\":\"StellaSwap: Vault V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x54e2d14df9348b3fba7e372328595b9f3ae243fe\"\n            },\n            {\n                \"name\":\"StellaSwap: CELER Rewarder 1 V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x70cbd76ed57393e0cd81e796de850080c775d24f\"\n            },\n            {\n                \"name\":\"StellaSwap: Stella Timelock V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xc6f73b028cd3154a5bb87f49aa43aa259a6522fb\"\n            },\n            {\n                \"name\":\"StellaSwap: GLMR - MAI Vault V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x3a82f4da24f93a32dc3c2a28cfa9d6e63ec28531\"\n            },\n            {\n                \"name\":\"StellaSwap: UST - GLMR V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x556d9c067e7a0534564d55f394be0064993d2d3c\"\n            },\n            {\n                \"name\":\"StellaSwap: SFL - axlUSDC - 4pool V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xa1ffdc79f998e7fa91ba3a6f098b84c9275b0483\"\n            },\n            {\n                \"name\":\"StellaSwap: Stable Router V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb0dfd6f3fddb219e60fcdc1ea3d04b22f2ffa9cc\"\n            },\n            {\n                \"name\":\"StellaSwap: ATOM - GLMR Rewarder New V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x5aa224966e302424ec13a4f51b80bcfc205984b6\"\n            },\n            {\n                \"name\":\"StellaSwap: CELR Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x05ad30253f0b20be35d84253d6aca8bd7ec0c66c\"\n            },\n            {\n                \"name\":\"StellaSwap: Router V3\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xe6d0ed3759709b743707dcfecae39bc180c981fe\"\n            },\n            {\n                \"name\":\"StellaSwap: xStella - GLMR Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x896135ff51debe8083a2e03f9d44b1d3c77a0324\"\n            },\n            {\n                \"name\":\"StellaSwap: XStella - MAI Vault V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x3756465c5b1c1c4cee473880c9726e20875284f1\"\n            },\n            {\n                \"name\":\"StellaSwap: ATOM - USDC Rewarder New V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x5546e272c67fac10719f1223b1c0212fa3e41a8f\"\n            },\n            {\n                \"name\":\"StellaSwap: SFL - athUSDC - 4pool V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x715d7721fa7e8616ae9d274704af77857779f6f0\"\n            },\n            {\n                \"name\":\"StellaSwap: IDO Locker V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x4b1381b5b959a8ba7f44414c7d758e53d500a8a9\"\n            },\n            {\n                \"name\":\"StellaSwap: Locker V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x8995066b7f1fb3abe3c88040b677d03d607a0b58\"\n            },\n            {\n                \"name\":\"StellaSwap: ATOM - USDC - GLMR Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xe06e720aaed5f5b817cb3743108ae0a12fe69e9b\"\n            },\n            {\n                \"name\":\"StellaSwap: Mistake in Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x168ceb7e49c21e3f37820a34590171214a765f5f\"\n            },\n            {\n                \"name\":\"StellaSwap: LP 4pool - Wormhole V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb326b5189aa42acaa3c649b120f084ed8f4dcaa6\"\n            },\n            {\n                \"name\":\"StellaSwap: Farms V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xedfb330f5fa216c9d2039b99c8ce9da85ea91c1e\"\n            },\n            {\n                \"name\":\"StellaSwap: Factory V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x68a384d826d3678f78bb9fb1533c7e9577dacc0e\"\n            },\n            {\n                \"name\":\"StellaSwap: anyETH-madETH Pool\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xb86271571c90ad4e0c9776228437340b42623402\"\n            },\n            {\n                \"name\":\"StellaSwap: Dual Farms V2\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xf3a5454496e26ac57da879bf3285fa85debf0388\"\n            },\n            {\n                \"name\":\"StellaSwap: CELER Rewarder 01 - 02 V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x713f76076283fcd81babe06c76ff51485edf9d5e\"\n            },\n            {\n                \"name\":\"StellaSwap: SCNFT Token\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x5f23a6a0b6b90fdeeb4816afbfb2ec0408fda59e\"\n            },\n            {\n                \"name\":\"StellaSwap: ATOM - GLMR - GLMR Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xe60c41de5537418fde05b804df077397dfa84d75\"\n            },\n            {\n                \"name\":\"StellaSwap: Timelock Main V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x9a8693c6f7bf0f44e885118f3f83e2cdb4e611b8\"\n            },\n            {\n                \"name\":\"StellaSwap: MAI - B4P - Wormhole V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xf0a2ae65342f143fc09c83e5f19b706abb37414d\"\n            },\n            {\n                \"name\":\"StellaSwap: LP Token V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x7b17122b941d2173192c7d8d68faabdc88421326\"\n            },\n            {\n                \"name\":\"StellaSwap: Multisig V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x4300e09284e3bb4d9044ddab31efaf5f3301daba\"\n            },\n            {\n                \"name\":\"StellaSwap: Router V2\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x70085a09d30d6f8c4ecf6ee10120d1847383bb57\"\n            },\n            {\n                \"name\":\"StellaSwap: DOTxc - GLMR V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x505b0a5458dd12605b84bb2928dd2bc5b44993b9\"\n            },\n            {\n                \"name\":\"StellaSwap: SFL - MAI - 4pool V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x7fbe3126c03444d43fc403626ec81e3e809e6b46\"\n            },\n            {\n                \"name\":\"StellaSwap: xStella - USDC Rewarder V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0xfa16d5b8bf03677945f0a750c8d2a30001b2fa93\"\n            },\n            {\n                \"name\":\"StellaSwap: madUSDC - GLMR V1\",\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x9200cb047a9c4b34a17ccf86334e3f434f948301\"\n            }\n        ],\n        \"slug\":\"stellaswap\",\n        \"createdAt\":1699292612617,\n        \"tvlChange1d\":{\n            \"moonbeam\":-0.748278690902012\n        },\n        \"logo\":{\n            \"small\":{\n                \"width\":36,\n                \"fileName\":\"stellaswap-logo-small.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":36\n            },\n            \"large\":{\n                \"width\":510,\n                \"fileName\":\"stellaswap-logo-large.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":510\n            },\n            \"full\":{\n                \"width\":3000,\n                \"fileName\":\"stellaswap-logo-full.jpeg\",\n                \"mimeType\":\"image/jpeg\",\n                \"height\":3000\n            }\n        },\n        \"chains\":[\n            \"moonbeam\"\n        ],\n        \"usersChange7d\":{\n            \"moonbeam\":-17.2727272727273\n        },\n        \"marketData\":{\n            \"symbol\":\"stella\",\n            \"marketCap\":808908,\n            \"marketCapRank\":2865,\n            \"priceChangePercentage1y\":-43.01356,\n            \"currentPrice\":0.01729378,\n            \"priceChangePercentage14d\":-17.23772,\n            \"contracts\":{\n                \"moonbeam\":\"0x0e358838ce72d5e61e0018a2ffac4bec5f4c88d2\"\n            },\n            \"priceChangePercentage60d\":-39.75633,\n            \"priceChangePercentage30d\":-26.13934,\n            \"priceChangePercentage24h\":-4.63782,\n            \"priceChangePercentage200d\":-74.57003,\n            \"marketCapChangePercentage24h\":-4.62971,\n            \"priceChange24h\":-0.0008410608839097,\n            \"marketCapChange24h\":-39268.122562502,\n            \"priceChangePercentage7d\":-7.91278\n        },\n        \"projectCreationDate\":1644828523000,\n        \"contracts\":[\n            {\n                \"chain\":\"moonbeam\",\n                \"contract\":\"0x0e358838ce72d5e61e0018a2ffac4bec5f4c88d2\"\n            }\n        ],\n        \"updatedAt\":1722544694830,\n        \"category\":\"dex\",\n        \"description\":\"StellaSwap is one of the first automated market-making (AMM), decentralized exchange (DEX) for the Moonbeam parachain network. The unique value proposition of StellaSwap is that we're committed in establishing a strong foundation with our native token, STELLA, as a governance token, diverse farms, a built in bridge and user-centered service. \\r\\n\\r\\nStellaSwap's main objective is to create a broader range of network effects to address the issues of liquidity in the DeFi space, instead of limiting ourselves to a single solution like many DEXs are doing now. This manifests itself in the diverse product suite of StellaSwap that will be explained in more details. Our products are structured in such a way that facilitates decentralized governance of STELLA holders, while continuing to innovate on the collective foundations by design.\",\n        \"usersChange1d\":{\n            \"moonbeam\":-6.18556701030928\n        }\n    }\n}\n</code></pre>"},{"location":"learn/dapp-directory/#query-a-category","title":"Query a Category","text":"<p>You can also query the API by category. For example, you can retrieve information about all NFT projects with the following query:</p> <pre><code>https://apps.moonbeam.network/api/ds/v1/app-dir/projects?category=nfts\n</code></pre> API Response to Querying NFT projects <pre><code>{\n    \"projects\":[\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/nfts2me\",\n                \"website\":\"https://nfts2me.com/\",\n                \"try\":\"https://nfts2me.com/\",\n                \"twitter\":\"https://twitter.com/nfts2me\",\n                \"medium\":\"https://nfts2me.medium.com/\",\n                \"discord\":\"https://nfts2me.com/discord/\"\n            },\n            \"slug\":\"nfts2me\",\n            \"createdAt\":1699292617117,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"nfts2me-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"nfts2me-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"nfts2me-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"NFTs2Me\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1673608509000,\n            \"shortDescription\":\"NFTs2Me is a toolkit for creating and managing NFT projects.\",\n            \"contracts\":[\n                {\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x2269bCeB3f4e0AA53D2FC43B1B7C5C5D13B119a5\"\n                }\n            ],\n            \"updatedAt\":1722498896566,\n            \"category\":\"nfts\",\n            \"description\":\"NFTs2Me is a tool for creating and managing NFT projects. It includes features such as an art generator, delayed reveal, minting widget, token gating, and support for multiple blockchain platforms. It also offers customization options, an affiliate system, automatic logo and banner generation, and support for redeemable NFTs. It is user-friendly and suitable for those new to the world of NFTs.\\n\\nIn addition to these features, NFTs2Me also offers a minting widget and free IPFS hosting to make it simple to mint and store your NFTs securely and efficiently. The minting widget allows you to easily create and mint new NFTs, while the free IPFS hosting provides a secure and decentralized way to store your NFTs.\",\n            \"id\":\"nfts2me\",\n            \"tags\":[\n                \"NFT\",\n                \"Tool\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/rmrkapp\",\n                \"website\":\"https://singular.app/\",\n                \"try\":\"https://singular.app/\",\n                \"twitter\":\"https://twitter.com/RmrkSingular\",\n                \"discord\":\"https://discord.gg/TjB6v5AGZz\"\n            },\n            \"slug\":\"singular-app\",\n            \"createdAt\":1699292616171,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"singular-app-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"singular-app-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"singular-app-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Singular App\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1686240710000,\n            \"shortDescription\":\"The home of NFTs by @RmrkApp. Create and trade your nestable, equippable, soulbound, and multi-asset NFTs with us - no coding required.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498914806,\n            \"category\":\"nfts\",\n            \"description\":\"Singular is an NFT 2.0 marketplace that allows users to buy, sell, and trade both regular and advanced NFTs. Users can create and/or connect a wallet, browse digital items, and securely conduct transactions using blockchain technology.\",\n            \"id\":\"singular-app\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https:/t.me/metacourtgg\",\n                \"website\":\"https://www.metacourt.gg/\",\n                \"try\":\"https://www.metacourt.gg/\",\n                \"twitter\":\"https://twitter.com/metacourtgg\",\n                \"medium\":\"https://metacourtgg.medium.com/\",\n                \"discord\":\"https://discord.gg/9AnnfKCb39\"\n            },\n            \"slug\":\"metacourt\",\n            \"createdAt\":1699292616238,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"metacourt-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"metacourt-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"metacourt-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Metacourt\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1663756794000,\n            \"shortDescription\":\"Metacourt created NFTdeals for anyone who wants to become an influencer and trade their social media\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498888422,\n            \"category\":\"nfts\",\n            \"description\":\"Influencer accelerator for anyone who wants to become an influencer in the space. We allow selling your social media through NFTs and joining influencer marketing campaigns.\",\n            \"id\":\"metacourt\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/tofuNFT\",\n                \"website\":\"https://tofunft.com/\",\n                \"try\":\"https://tofunft.com/\",\n                \"twitter\":\"https://twitter.com/tofuNFT\",\n                \"medium\":\"https://medium.com/tofunftofficial\",\n                \"discord\":\"https://discord.com/invite/3wFUTZmTm7\"\n            },\n            \"slug\":\"tofunft\",\n            \"createdAt\":1699292615874,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"tofunft-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"tofunft-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"tofunft-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"tofuNFT\",\n            \"chains\":[\n                \"moonbeam\",\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"The largest multichain NFT marketplace\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498924881,\n            \"category\":\"nfts\",\n            \"description\":\"tofuNFT.com is an NFT marketplace focused on GameFi and collectibles, rebranded from SCV\u2019s NFT market. Enjoy exploring &amp; trading with your buddies!\",\n            \"id\":\"tofunft\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://d-book.io\",\n                \"try\":\"https://d-book.io\",\n                \"twitter\":\"https://twitter.com/dbook_io\"\n            },\n            \"slug\":\"d-book.io\",\n            \"createdAt\":1699292617021,\n            \"logo\":{\n                \"small\":{\n                    \"width\":129,\n                    \"fileName\":\"d-book.io-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":129,\n                    \"fileName\":\"d-book.io-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"d-book.io-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"D-book.io\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1682016612000,\n            \"shortDescription\":\"Bu\u011fra Ayan is a speaker,and university lecturer in Turkey who founded the Web3 Association Turkey.\",\n            \"contracts\":[\n                {\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x8d4BA02D0973749ad7c646DcaAa60BDC66F6F6D2\"\n                }\n            ],\n            \"updatedAt\":1722498866417,\n            \"category\":\"nfts\",\n            \"description\":\"We are an NFT Book Platform that connects authors and the decentralized world, aiming for a transformation ecosystem.\",\n            \"id\":\"d-book.io\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/BcmHuntGroup\",\n                \"website\":\"https://bcmhunt.com/\",\n                \"try\":\"https://bcmhunt.com/\",\n                \"twitter\":\"https://twitter.com/bcmhunt\",\n                \"medium\":\"https://medium.com/bcmhunt\",\n                \"discord\":\"https://discord.com/invite/Ee9aJ287J2\"\n            },\n            \"slug\":\"blockchain-monster-hunt\",\n            \"createdAt\":1699292616780,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"blockchain-monster-hunt-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":510,\n                    \"fileName\":\"blockchain-monster-hunt-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":510\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"blockchain-monster-hunt-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Blockchain Monster Hunt\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"The First Multichain NFT Monster Hunt\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498855937,\n            \"category\":\"nfts\",\n            \"description\":\"Blockchain Monster Hunt (BCMH) is the world\u2019s first multi-chain game that runs entirely on the blockchain itself. Inspired by Pok\u00e9mon-GO,BCMH allows players  to continuously explore brand new places on the blockchain to hunt and battle monsters. Each block on the blockchain is a unique digital space where a limited number of monsters (of the same DNA gene and rarity) may exist.  Players and collectors can hunt or battle for a chance to capture these unique monsters and to earn coins.\",\n            \"id\":\"blockchain-monster-hunt\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\",\n                \"GLMR Grants\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://speedboat.studio/\",\n                \"try\":\"https://speedboat.studio/\",\n                \"twitter\":\"https://twitter.com/Speedboat_STDO\",\n                \"medium\":\"https://medium.com/@speedboat_studio\",\n                \"discord\":\"https://discord.gg/y7TQbtEWSV\"\n            },\n            \"slug\":\"speedboat.studio\",\n            \"createdAt\":1699292616328,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"speedboat.studio-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":190,\n                    \"fileName\":\"speedboat.studio-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":190\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"speedboat.studio-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Speedboat\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1657584952000,\n            \"shortDescription\":\"Your no-code Web3 toolkit\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498916466,\n            \"category\":\"nfts\",\n            \"description\":\"Speedboat is a Web3 toolkit for everyone. Built on the idea that NFTs are not just expensive JPEGs, but programmable experiences.\",\n            \"id\":\"speedboat.studio\",\n            \"tags\":[\n                \"NFT\",\n                \"Tool\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/+qGh0InPSPc1iMTNk\",\n                \"website\":\"https://www.glmrapes.com/\",\n                \"try\":\"https://www.glmrapes.com/\",\n                \"twitter\":\"https://twitter.com/GLMRApes\",\n                \"discord\":\"https://discord.com/invite/glmrapes\"\n            },\n            \"web3goContracts\":[\n                {\n                    \"name\":\"GLMR Apes: GLMR Ape\",\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x8fbe243d898e7c88a6724bb9eb13d746614d23d6\"\n                },\n                {\n                    \"name\":\"GLMR Apes: GLMR Jungle\",\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0xcb13945ca8104f813992e4315f8ffefe64ac49ca\"\n                }\n            ],\n            \"currentTx\":{\n                \"moonbeam\":7830\n            },\n            \"slug\":\"glmr-apes\",\n            \"web3goIDs\":[\n                \"GLMR Apes\"\n            ],\n            \"createdAt\":1699292616827,\n            \"logo\":{\n                \"small\":{\n                    \"width\":47,\n                    \"fileName\":\"glmr-apes-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":528,\n                    \"fileName\":\"glmr-apes-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":408\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"glmr-apes-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"GLMR APES\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"usersChange7d\":{\n                \"moonbeam\":-66.6666666666667\n            },\n            \"currentUsers\":{\n                \"moonbeam\":1531\n            },\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"The first NFT collection on GLMR by &amp; for the community\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722547408370,\n            \"category\":\"nfts\",\n            \"description\":\"GLIMMER APES is the first NFT collection on GLMR by &amp; for the community. The longer you\u2019re bonding with GLMR Apes and the friendlier their behavior. Join the troops as soon as possible to become an EARLY APE, take part in our giveaways and games and land in the GLMR APE VIP CLUB.\",\n            \"id\":\"glmr-apes\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\"\n            ],\n            \"usersChange1d\":{\n                \"moonbeam\":0\n            }\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://snakesoldiers.com\",\n                \"try\":\"https://snakesoldiers.com\",\n                \"twitter\":\"https://twitter.com/snakesoldiers\",\n                \"github\":\"https://github.com/steven2308/snake-soldiers-contracts\",\n                \"medium\":\"https://medium.com/@snakesoldiers/emoting-to-influence-the-hatch-df3eab7e45b8\",\n                \"discord\":\"http://discord.gg/A6zQSz4YU4\"\n            },\n            \"slug\":\"snake-soldiers\",\n            \"createdAt\":1699292616971,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"snake-soldiers-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"snake-soldiers-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"snake-soldiers-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Snake Soldiers\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1691439275000,\n            \"shortDescription\":\"NFT game collection divided in 3 categories: Generals, Commanders and Soldiers\ud83d\udc0d. Built on Moonbeam\",\n            \"contracts\":[\n                {\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x3ab955216BdD76f51fbe02A3fe237D6612BBD09F\"\n                }\n            ],\n            \"updatedAt\":1722498915320,\n            \"category\":\"nfts\",\n            \"description\":\"Snake Soldiers is an NFT collection with a supply of at most 5k units, all unique and distributed among 3 ranks. Each snake will be usable inside a play to own game, where snakes will be the main characters, necessary to interact with the SerpenTerra ecosystem. This metaverse will be based on the RMRK 2.0 standard, making forward compatible and giving super powers to the NFTs.\",\n            \"id\":\"snake-soldiers\",\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/+LqmDOeGUQdRmYjVh%60%60\",\n                \"website\":\"https://omni-x.io\",\n                \"try\":\"https://omni-x.io\",\n                \"twitter\":\"https://twitter.com/omnix_nft\",\n                \"github\":\"https://github.com/Omni-X-NFT\",\n                \"discord\":\"https://discord.gg/omni-x\"\n            },\n            \"slug\":\"omni-x\",\n            \"createdAt\":1699292617077,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"omni-x-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":107,\n                    \"fileName\":\"omni-x-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":108\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"omni-x-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Omni-X\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1673811786000,\n            \"shortDescription\":\"The first natively omnichain NFT platform\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498898538,\n            \"category\":\"nfts\",\n            \"description\":\"Omni X is an omnichain NFT protocol and marketplace that connects communities, creators, and enthusiasts across multiple blockchains. \\n\\nWe provide tooling for creating ONFT collections, bridging regular NFTs to ONFTs and grant access to unparalleled liquidity that allows users to buy and sell NFTs from any blockchain to any other blockchain.\",\n            \"id\":\"omni-x\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"Infrastructure\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://www.publicpressure.io/\",\n                \"try\":\"https://www.publicpressure.io/\",\n                \"twitter\":\"https://twitter.com/jointhepressure\",\n                \"discord\":\"https://discord.gg/publicpressure\"\n            },\n            \"slug\":\"publicpressure\",\n            \"createdAt\":1702283744356,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"publicpressure-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"publicpressure-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"publicpressure-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Public Pressure\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1651597275000,\n            \"shortDescription\":\"Support your favorite artists, own their music, get rewarded.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498907699,\n            \"category\":\"nfts\",\n            \"description\":\"We are the web3 music platform powered by artists, labels and fans\",\n            \"id\":\"publicpressure\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ]\n        },\n        {\n            \"currentTx\":{\n                \"moonbeam\":8409\n            },\n            \"web3goIDs\":[\n                \"Moonbeans\"\n            ],\n            \"name\":\"Moonbeans\",\n            \"currentUsers\":{\n                \"moonbeam\":1134\n            },\n            \"coinGeckoId\":\"moonbeans\",\n            \"shortDescription\":\"Galactic Co-Op &amp; Profit sharing NFT platform and soon to be Metaverse\",\n            \"id\":\"moonbeans\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ],\n            \"urls\":{\n                \"website\":\"https://moonbeans.io/\",\n                \"twitter\":\"https://twitter.com/moonbeansio\",\n                \"github\":\"https://github.com/m00nbeans\",\n                \"discord\":\"https://discord.com/invite/qqE9aBPzQ9\",\n                \"telegram\":\"https://t.me/moonbeansio\",\n                \"try\":\"https://moonbeans.io/\",\n                \"medium\":\"https://medium.com/@MoonBeans\"\n            },\n            \"web3goContracts\":[\n                {\n                    \"name\":\"Moonbeans: Beanie Distributor V2\",\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0xda6367c6510d8f2d20a345888f9dff3eb3226b02\"\n                },\n                {\n                    \"name\":\"Moonbeans: Marketplace V9\",\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x683724817a7d526d6256aec0d6f8ddf541b924de\"\n                },\n                {\n                    \"name\":\"Moonbeans: Storefront Ownership V1\",\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x971dfedd548f2269e515957404cbbee1f507cd01\"\n                }\n            ],\n            \"slug\":\"moonbeans\",\n            \"createdAt\":1699292615978,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"moonbeans-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"moonbeans-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"moonbeans-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"chains\":[\n                \"moonbeam\",\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"usersChange7d\":{\n                \"moonbeam\":0\n            },\n            \"marketData\":{\n                \"symbol\":\"beans\",\n                \"marketCap\":0,\n                \"priceChangePercentage1y\":-62.22489,\n                \"currentPrice\":0.062264,\n                \"priceChangePercentage14d\":-13.93552,\n                \"contracts\":{\n\n                },\n                \"priceChangePercentage60d\":-44.93764,\n                \"priceChangePercentage30d\":-33.587,\n                \"priceChangePercentage24h\":-0.05451,\n                \"priceChangePercentage200d\":-83.0363,\n                \"marketCapChangePercentage24h\":0,\n                \"priceChange24h\":-0.0000339560550113,\n                \"marketCapChange24h\":0,\n                \"priceChangePercentage7d\":-5.36696\n            },\n            \"projectCreationDate\":1644828523000,\n            \"contracts\":[\n                {\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x65b09ef8c5a096c5fd3a80f1f7369e56eb932412\"\n                },\n                {\n                    \"chain\":\"moonriver\",\n                    \"contract\":\"0xC2392DD3e3fED2c8Ed9f7f0bDf6026fcd1348453\"\n                }\n            ],\n            \"updatedAt\":1722548296818,\n            \"category\":\"nfts\",\n            \"description\":\"Moonbeans is an NFT marketplace launched on October 8, 2021, featuring 465 Beanies on the Moonriver network. The platform offers NFT trading with fees for artists, traders, and project developers. Multiple collections are available, including Beanies and RivrMaids.\",\n            \"usersChange1d\":{\n                \"moonbeam\":0\n            }\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/blocsport\",\n                \"website\":\"https://blocsport.one/\",\n                \"try\":\"https://blocsport.one/\",\n                \"twitter\":\"https://twitter.com/blocsport1\",\n                \"medium\":\"https://blocsport1.medium.com/\"\n            },\n            \"slug\":\"blocsport-one\",\n            \"createdAt\":1699292616637,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"blocsport-one-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"blocsport-one-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"blocsport-one-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Blocsport.one\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"Web 3.0 metaverse, smart sports money, athlete NFT launchpad &amp; assets tokenization\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498857332,\n            \"category\":\"nfts\",\n            \"description\":\"Blocsport.one is a Swiss sports tech company founded in 2019 that is transforming the sports business by building a transparent and reliable sports ecosystem uniting athletes, clubs, and fans based on blockchain. Company owns NFTdeals.io exclusive marketplace and has the biometric-enabled football scouting DApp live. Blocsport.one helps the young promising athletes get the money and exposure for their career development, which is nobody else doing in the world.\",\n            \"id\":\"blocsport-one\",\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/mintverse\",\n                \"website\":\"https://www.mintverse.com/\",\n                \"try\":\"https://www.mintverse.com/\",\n                \"twitter\":\"https://twitter.com/mintverse_\",\n                \"medium\":\"https://medium.com/mintverse\",\n                \"discord\":\"https://discord.com/invite/mhhnbvAaq9\"\n            },\n            \"slug\":\"mintverse\",\n            \"createdAt\":1702283733666,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"mintverse-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"mintverse-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"mintverse-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Mintverse\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1651597514000,\n            \"shortDescription\":\"Mint, Explore &amp; Trade Liquid NFT Assets Across Multiple Chains\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498889300,\n            \"category\":\"nfts\",\n            \"description\":\"Comprehensive NFT Aggregation Marketplace with a 0% trading fee\",\n            \"id\":\"mintverse\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/rmrkapp\",\n                \"website\":\"https://upgradooor.app\",\n                \"try\":\"https://upgradooor.app\",\n                \"twitter\":\"https://x.com/rmrkapp\",\n                \"github\":\"https://github.com/rmrk-team\",\n                \"medium\":\"https://medium.com/rmrkapp\"\n            },\n            \"slug\":\"upgradooor\",\n            \"createdAt\":1699292616895,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"upgradooor-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"upgradooor-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"upgradooor-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Upgradooor\",\n            \"chains\":[\n                \"moonbeam\",\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1692259742000,\n            \"shortDescription\":\"Upgrade your NFT 1.0 collections to NFT 2.0 by wrapping them into advanced functionality\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498927244,\n            \"category\":\"nfts\",\n            \"description\":\"As a collection issuer, use Upgradooor to initialize the process of upgrading your collection to NFT 2.0 if you are currently using ERC721.\\n\\nAs a holder, once the collection owner initiates the process, you can wrap any NFT you hold in that collection and instantly turn it into an equippable, multi-asset, composable NFT with no added risk.\\n\\nYou can always unwrap at will, and all the changes will still wait for you when you decide to re-claim the 2.0 wrapper again.\\n\\nUpgrading allows you to:\\n\\n- add more assets (outputs) to a legacy NFT, preventing needless airdrop spam\\n- airdrop NFTs into the NFT itself, preventing detachment of context, and saving tremendous amounts of gas by letting people transfer just the parent NFT\\n- define equippable settings and even achieve compatibility with other collections, for cross collection equippables and thus cross collection royalties and commissions\\n- see your NFTs on Singular, and use GBM auctions as a unique and novel listing mechanic\",\n            \"id\":\"upgradooor\",\n            \"tags\":[\n                \"NFT\",\n                \"Tool\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/moonfit_official_community\",\n                \"website\":\"https://moonfit.xyz/\",\n                \"try\":\"https://moonfit.xyz/\",\n                \"twitter\":\"https://twitter.com/MoonFitOfficial\",\n                \"discord\":\"https://discord.gg/hStdUVtHXp\"\n            },\n            \"slug\":\"moonfit\",\n            \"createdAt\":1702283734897,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"moonfit-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"moonfit-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"moonfit-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"MoonFit\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1654692249000,\n            \"shortDescription\":\"Web3 &amp; NFT Lifestyle App That Pays You Anytime You Burn Calories\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498891201,\n            \"category\":\"nfts\",\n            \"description\":\"MoonFit is a Web3 Lifestyle App that promotes active living by rewarding users with tokens and NFTs anytime they burn calories through physical activities.\",\n            \"id\":\"moonfit\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/rmrkapp\",\n                \"website\":\"https://rmrk.app/\",\n                \"try\":\"https://rmrk.app/\",\n                \"twitter\":\"https://twitter.com/rmrkapp\",\n                \"discord\":\"https://discord.com/invite/bV9kQbVC99\"\n            },\n            \"slug\":\"rmrk\",\n            \"createdAt\":1699292615938,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"rmrk-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"rmrk-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"rmrk-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"RMRK\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"marketData\":{\n                \"symbol\":\"rmrk\",\n                \"marketCap\":5985029,\n                \"marketCapRank\":1602,\n                \"priceChangePercentage1y\":-64.99216,\n                \"currentPrice\":0.62974,\n                \"priceChangePercentage14d\":-24.26661,\n                \"contracts\":{\n                    \"moonbeam\":\"0x524d524b4c9366be706d3a90dcf70076ca037ae3\"\n                },\n                \"priceChangePercentage60d\":-51.72181,\n                \"priceChangePercentage30d\":-30.11256,\n                \"priceChangePercentage24h\":-2.58554,\n                \"priceChangePercentage200d\":-75.55551,\n                \"marketCapChangePercentage24h\":-2.50147,\n                \"priceChange24h\":-0.01671434617594,\n                \"marketCapChange24h\":-153554.8536219,\n                \"priceChangePercentage7d\":-1.5052\n            },\n            \"coinGeckoId\":\"rmrk\",\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"Creators of NFTs 2.0 via ERC6059, ERC6220, ERC5773, EIP6381, and EIP6454.\\nNFT equippables, future compatibility, reputation, and token balances.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722548302467,\n            \"category\":\"nfts\",\n            \"description\":\"With the RMRK NFT Building Block System\\nOur ERC NFT standards allow you to unlock the true potential of NFTs.\\nTailored to work with each other, these EVM smart contracts will help you create your NFT projects of varying complexity.\",\n            \"id\":\"rmrk\",\n            \"tags\":[\n                \"NFT\",\n                \"Infrastructure\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://www.mynft.com/\",\n                \"try\":\"https://bridge.mynft.com/home\",\n                \"twitter\":\"https://twitter.com/mynft\"\n            },\n            \"slug\":\"mynft\",\n            \"createdAt\":1699292616578,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"mynft-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"mynft-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"mynft-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"myNFT\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"The marketplace that puts the power back in your hands\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498895020,\n            \"category\":\"nfts\",\n            \"description\":\"myNFT is the marketplace that puts the power back in your hands. It is a creative workshop, a trading platform and a discovery engine, helping you tell your story and share your passions, on your own terms. myNFT is built on decentralized technologies empowering you to create, trade, and discover. myNFT is built by Perpetual Altruism, a leader in the NFT space and the creator of charitable NFT publisher Cryptograph and the GBM auction system. Perpetual Altruism is backed by prominent investors and creators and is also the recipient of grants from the Web3 Foundation and the Moonbeam network for their work on the decentralized internet, which powers myNFT.\",\n            \"id\":\"mynft\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"GLMR Grants\",\n                \"MOVR Grants\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://readl.co/\",\n                \"try\":\"https://readl.co/\",\n                \"twitter\":\"https://twitter.com/readl_co\",\n                \"medium\":\"https://medium.com/@readlnetwork\",\n                \"discord\":\"https://discord.gg/XPTENepHqY\"\n            },\n            \"slug\":\"readl\",\n            \"createdAt\":1702283745749,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"readl-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"readl-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"readl-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Readl\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1655885161000,\n            \"shortDescription\":\"Bringing the publishing industry to web3\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498910044,\n            \"category\":\"nfts\",\n            \"description\":\"Readl is the protocol that provides publishers and storytellers with the infrastructure to publish their content on the blockchain, while providing a user-friendly platform to enjoy any story, in any format.\",\n            \"id\":\"readl\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"MOVR Grants\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/rmrkapp\",\n                \"website\":\"https://emotes.app\",\n                \"try\":\"https://emotes.app\",\n                \"twitter\":\"https://x.com/rmrkapp\",\n                \"github\":\"https://github.com/rmrk-team\",\n                \"medium\":\"https://medium.com/rmrkapp\"\n            },\n            \"slug\":\"emotes.app\",\n            \"createdAt\":1699292616951,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"emotes.app-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"emotes.app-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"emotes.app-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Emotes.app\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1692254489000,\n            \"shortDescription\":\"React on anyone's NFT - throw \ud83d\udca9 at those apes, give a \ud83e\udd17 to those Pudgies!\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498871347,\n            \"category\":\"nfts\",\n            \"description\":\"Emotes.app is a RMRK mini-app which allows you to send emotes / reactions to anyone's NFT. It utilizes RMRK's ERC7009 and is trivial to integrate into any project wanting to take advantage of the community's reactions to their NFTs.\\n\\nUse it to direct storylines, affect NFT egg hatching, or just do relative price comparison when influencers like one NFTs and dislike another!\",\n            \"id\":\"emotes.app\",\n            \"tags\":[\n                \"NFT\",\n                \"Social\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://twitter.com/PolkaPets\",\n                \"website\":\"https://www.polkapet.world/\",\n                \"try\":\"https://www.polkapet.world/\",\n                \"twitter\":\"https://twitter.com/PolkaPets\",\n                \"medium\":\"https://polkapetworld.medium.com/\"\n            },\n            \"slug\":\"polkapet-world\",\n            \"createdAt\":1702283743596,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"polkapet-world-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"polkapet-world-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"polkapet-world-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"PolkaPets\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"marketData\":{\n                \"priceChangePercentage60d\":1206.42918,\n                \"symbol\":\"pets\",\n                \"marketCap\":0,\n                \"priceChangePercentage30d\":619.39533,\n                \"priceChangePercentage200d\":135.91624,\n                \"priceChangePercentage1y\":355.00061,\n                \"currentPrice\":0.00515699,\n                \"priceChangePercentage14d\":-15.30948,\n                \"contracts\":{\n                    \"moonriver\":\"0x1e0f2a75be02c025bd84177765f89200c04337da\"\n                },\n                \"priceChangePercentage7d\":749.62625\n            },\n            \"coinGeckoId\":\"polkapet-world\",\n            \"projectCreationDate\":1651157216000,\n            \"shortDescription\":\"Welcome to PolkaPet World\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722548303208,\n            \"category\":\"nfts\",\n            \"description\":\"An immersive NFT collection created in partnership with the biggest and best PolkaDot projects \",\n            \"id\":\"polkapet-world\",\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://www.moonarines.com/\",\n                \"try\":\"https://www.moonarines.com/\",\n                \"discord\":\"https://discord.gg/bXhSyW8htW\"\n            },\n            \"slug\":\"moonarines\",\n            \"createdAt\":1702283733870,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"moonarines-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"moonarines-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"moonarines-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Moonarines\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1654792422000,\n            \"shortDescription\":\"Be part of the conquest of the digital space\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498889804,\n            \"category\":\"nfts\",\n            \"description\":\"The Moonarines are unique NFT characters starting soon on the Moonriver Network!\\nWith the Moonarines, the NFT owners will be taken to an unforgettable adventure to explore the Cryptoverse!\",\n            \"id\":\"moonarines\",\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/NFTrade\",\n                \"website\":\"https://nftrade.com/\",\n                \"try\":\"https://nftrade.com/\",\n                \"twitter\":\"https://twitter.com/NFTradeOfficial\",\n                \"medium\":\"https://medium.com/@NFTrade\",\n                \"discord\":\"https://discord.com/invite/SESqfsyw8k\"\n            },\n            \"slug\":\"nftrade\",\n            \"createdAt\":1699292616005,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"nftrade-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"nftrade-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"nftrade-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"NFTrade\",\n            \"chains\":[\n                \"moonbeam\",\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"marketData\":{\n                \"symbol\":\"nftd\",\n                \"marketCap\":234018,\n                \"marketCapRank\":3653,\n                \"priceChangePercentage1y\":-65.38449,\n                \"currentPrice\":0.00502075,\n                \"priceChangePercentage14d\":-7.09922,\n                \"contracts\":{\n\n                },\n                \"priceChangePercentage60d\":-27.37596,\n                \"priceChangePercentage30d\":-14.12267,\n                \"priceChangePercentage24h\":-2.22137,\n                \"priceChangePercentage200d\":-56.66993,\n                \"marketCapChangePercentage24h\":-2.16658,\n                \"priceChange24h\":-0.00011406326237191,\n                \"marketCapChange24h\":-5182.473845666,\n                \"priceChangePercentage7d\":-6.88049\n            },\n            \"coinGeckoId\":\"nftrade\",\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"Create, Buy, Sell, Swap and Farm NFTs\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722548304198,\n            \"category\":\"nfts\",\n            \"description\":\"NFTrade is a multi-chain platform for NFT creation and trading. Seamlessly launch, mint, and swap non-fungible tokens. Earn digital collectibles. NFTrade places you at the heart of the NFT economy. Create, Buy, Sell, Swap and Farm NFTs. All chains, All NFTs, One Platform.\",\n            \"id\":\"nftrade\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"MOVR Grants\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://www.pipcards.com/\",\n                \"try\":\"https://www.pipcards.com/\",\n                \"twitter\":\"https://twitter.com/pipcards\",\n                \"discord\":\"https://discord.com/invite/hnSC7QjTHj\"\n            },\n            \"slug\":\"pipcards\",\n            \"createdAt\":1699292616371,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"pipcards-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"pipcards-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"pipcards-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"PIP Cards\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1651149583000,\n            \"shortDescription\":\"Post-generated NFT playing card decks\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498904704,\n            \"category\":\"nfts\",\n            \"description\":\"PIPS is a first-of-its-kind NFT generative playing card project that will enable NFT holders to generate an entire deck of custom cards to be used cross-chain.\",\n            \"id\":\"pipcards\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://bithotel.io/\",\n                \"twitter\":\"https://twitter.com/playbithotel\",\n                \"github\":\"https://github.com/BitHotelOrg/bithotel-token-contracts\",\n                \"discord\":\"https://discord.gg/RFFZNwxY9n\",\n                \"telegram\":\"https://t.me/bithotelcommunity\",\n                \"try\":\"https://bithotel.io/\",\n                \"medium\":\"https://medium.com/@bithotelnftgame\"\n            },\n            \"slug\":\"bit-hotel\",\n            \"createdAt\":1702283710425,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"bit-hotel-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":500,\n                    \"fileName\":\"bit-hotel-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":500\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"bit-hotel-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Bit Hotel\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1658743551000,\n            \"shortDescription\":\"Bit Hotel is a Social-first Play 2 Earn NFT Gaming Metaverse set in a Pixel-art Hotel.\",\n            \"contracts\":[\n                {\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"Not deployed yet\"\n                },\n                {\n                    \"chain\":\"moonriver\",\n                    \"contract\":\"Not deployed yet\"\n                }\n            ],\n            \"updatedAt\":1722498854706,\n            \"category\":\"nfts\",\n            \"description\":\"In Bit Hotel users can compete to earn Bit Hotel tokens and acquire native NFTs. These NFTs have in-game utilities and consist of characters, hotel rooms, furniture and other assets that have their own unique perks. With over 250k Hotel Guests cross-channel, this nostalgic Hotel metaverse is taking people back to their 8bit upbringing.\",\n            \"id\":\"bit-hotel\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\"\n            ]\n        },\n        {\n            \"tvlChange7d\":{\n                \"moonriver\":0.00190215150271202\n            },\n            \"urls\":{\n                \"website\":\"https://www.moonbeamdao.com/\",\n                \"try\":\"https://www.moonbeamdao.com/\",\n                \"twitter\":\"https://twitter.com/moonbeam_dao\",\n                \"medium\":\"https://medium.com/@moonbeamdao\",\n                \"discord\":\"https://discord.gg/AevrFzwZjk\"\n            },\n            \"web3goContracts\":[\n                {\n                    \"name\":\"MoonDAO: MDAO Token\",\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0xc6342eab8b7cc405fc35eba7f7401fc400ac0709\"\n                }\n            ],\n            \"currentTx\":{\n                \"moonbeam\":972\n            },\n            \"slug\":\"moondao\",\n            \"web3goIDs\":[\n                \"MoonDAO\"\n            ],\n            \"createdAt\":1699292616416,\n            \"tvlChange1d\":{\n                \"moonriver\":-0.0349944884006391\n            },\n            \"logo\":{\n                \"small\":{\n                    \"width\":25,\n                    \"fileName\":\"moondao-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":330,\n                    \"fileName\":\"moondao-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":475\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"moondao-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"MoonDAO\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"currentTVL\":{\n                \"moonriver\":76.75665\n            },\n            \"currentUsers\":{\n                \"moonbeam\":229\n            },\n            \"projectCreationDate\":1648347145000,\n            \"shortDescription\":\"The first &amp; only community art dao on moonbeam\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722547637377,\n            \"category\":\"nfts\",\n            \"description\":\"MoonDao is the first community Art Collection DAO on the Moonbeam network!\\n\\nWe aim to utilize input from our community to select high-end NFT\u2019s. These NFT\u2019s will be acquired with the MoonDao treasury and stored in the MoonDao Vault.\\n\\nMoon ownership grants access to DAO voting rights, future events, and additional holder perks outlined below. Welcome to the moon, we hope you stay.\\n\\n\",\n            \"id\":\"moondao\",\n            \"tags\":[\n                \"NFT\",\n                \"DAO\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/raresama\",\n                \"website\":\"https://raresama.com/\",\n                \"try\":\"https://raresama.com/\",\n                \"twitter\":\"https://twitter.com/RaresamaNFT\",\n                \"discord\":\"https://discord.com/channels/938592318380982303/1010237900685840405\"\n            },\n            \"slug\":\"raresama\",\n            \"createdAt\":1699292615958,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"raresama-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"raresama-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"raresama-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Raresama\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1662528828000,\n            \"shortDescription\":\"Discover amazing Rare digital artwork\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498909462,\n            \"category\":\"nfts\",\n            \"description\":\"Raresama brings the magic of owning a piece of artwork to your fingertips. Create or browse NFT art collections and enjoy a diverse mix of artists, genres, styles and movements.\",\n            \"id\":\"raresama\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://gal.xyz/telegram\",\n                \"website\":\"https://galxe.com/\",\n                \"try\":\"https://galxe.com/\",\n                \"twitter\":\"https://twitter.com/Galxe\",\n                \"medium\":\"https://blog.galxe.com/\",\n                \"discord\":\"https://gal.xyz/discord\"\n            },\n            \"slug\":\"galxe\",\n            \"createdAt\":1699292616277,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"galxe-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"galxe-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"galxe-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Galxe\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1659868871000,\n            \"shortDescription\":\"Create Impactful Experiences With #Web3 Credentials. (Formerly Project Galaxy) \",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498876438,\n            \"category\":\"nfts\",\n            \"description\":\"Galxe is the leading Web3 credential data network in the world. A collaborative credential infrastructure enabling brands and developers to engage communities and build robust products in Web3.\",\n            \"id\":\"galxe\",\n            \"tags\":[\n                \"NFT\",\n                \"Social\",\n                \"Tool\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"http://t.me/MoonsamaNFT\",\n                \"website\":\"https://moonsama.com/\",\n                \"try\":\"https://moonsama.com/\",\n                \"twitter\":\"https://twitter.com/MoonsamaNFT\",\n                \"discord\":\"discord.gg/moonsama\"\n            },\n            \"slug\":\"moonsama\",\n            \"createdAt\":1702283735408,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"moonsama-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"moonsama-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"moonsama-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Moonsama\",\n            \"chains\":[\n                \"moonriver\",\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1651156798000,\n            \"shortDescription\":\"Let's build the multiverse\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498892389,\n            \"category\":\"nfts\",\n            \"description\":\"Moonsama\u2019s protocol for bi-directional bridging of on-chain digital assets and off-chain applications. This is how we connect web2.0 games, metaverses and blockchains. It enables new games, development and community fun from across the Kusamaverse and beyond!\",\n            \"id\":\"moonsama\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://smartstamp.com/\",\n                \"try\":\"https://smartstamp.com/\",\n                \"discord\":\"https://discord.gg/kajPqvZY\"\n            },\n            \"slug\":\"smartstamp\",\n            \"createdAt\":1699292617058,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"smartstamp-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":436,\n                    \"fileName\":\"smartstamp-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":436\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"smartstamp-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"SmartStamp\",\n            \"chains\":[\n                \"moonbeam\",\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1675081766000,\n            \"shortDescription\":\"SmartStamp is the pioneering new standard in identification and authentication for the art world.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498915044,\n            \"category\":\"nfts\",\n            \"description\":\"Developed over more than a decade, SmartStamp\u2019s app uses patented AI technology that is designed to read and record artworks\u2019 surface characteristics\u2013 offering artists, collectors, institutions, and all arts and culture stakeholders a way to securely and immutably link physical objects to their digital fingerprints on the blockchain. Using the SmartStamp app is as simple as taking a picture, making the groundbreaking security and timestamping power of blockchain technology accessible to anyone who can use a smartphone.\",\n            \"id\":\"smartstamp\",\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/yusernetwork\",\n                \"website\":\"https://yuser.network/\",\n                \"try\":\"https://yuser.network/\",\n                \"twitter\":\"https://twitter.com/yuser\",\n                \"medium\":\"https://medium.com/yuser\",\n                \"discord\":\"https://discord.com/invite/uRRxnfAjhY\"\n            },\n            \"slug\":\"yuser\",\n            \"createdAt\":1699292616605,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"yuser-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"yuser-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"yuser-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Yuser\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1644828523000,\n            \"shortDescription\":\"The first NFT social networking app- by creators, for creators\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498932483,\n            \"category\":\"nfts\",\n            \"description\":\"Yuser\u2019s mission is to build an ecosystem of interconnected applications that put power back into the hands of users by giving them full control over their content, data, and personal networks. Developers can connect via an API to instantly gain access to millions of users and incentivize them to try their product by paying them with a token.\",\n            \"id\":\"yuser\",\n            \"tags\":[\n                \"NFT Marketplaces\",\n                \"GLMR Grants\",\n                \"MOVR Grants\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/cryptosoots\",\n                \"website\":\"https://raregems.io/my#\",\n                \"try\":\"https://raregems.io/my#\",\n                \"twitter\":\"https://twitter.com/RareGems_io\"\n            },\n            \"slug\":\"rare-gems\",\n            \"createdAt\":1702283745336,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"rare-gems-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":360,\n                    \"fileName\":\"rare-gems-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":360\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"rare-gems-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Rare Gems\",\n            \"chains\":[\n                \"moonriver\",\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1652705611000,\n            \"shortDescription\":\"Multichain NFT marketplace.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498909205,\n            \"category\":\"nfts\",\n            \"description\":\"Multichain NFT marketplace\\nCreated by \\n@cryptosoots\",\n            \"id\":\"rare-gems\",\n            \"tags\":[\n                \"NFT Marketplaces\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/rmrkapp\",\n                \"website\":\"https://wizard.rmrk.dev\",\n                \"try\":\"https://wizard.rmrk.dev\",\n                \"twitter\":\"https://x.com/rmrkapp\",\n                \"github\":\"https://github.com/rmrk-team\",\n                \"medium\":\"https://medium.com/rmrkapp\"\n            },\n            \"slug\":\"rmrk-wizard\",\n            \"createdAt\":1699292616919,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"rmrk-wizard-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"rmrk-wizard-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"rmrk-wizard-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"RMRK Wizard\",\n            \"chains\":[\n                \"moonbeam\",\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1692255253000,\n            \"shortDescription\":\"A no-code-but-code wizard UI for building NFTs 2.0\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498911520,\n            \"category\":\"nfts\",\n            \"description\":\"A simple UI to put together NFT 2.0 legos created by the RMRK.app team. Use this tool to get started developing advanced NFT collections by picking from a set of functions you need, and the tool will compose code for you which only needs final tweaks before being deployed!\",\n            \"id\":\"rmrk-wizard\",\n            \"tags\":[\n                \"NFT\",\n                \"Tool\",\n                \"Developer Tools\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/evelonapp\",\n                \"website\":\"https://platform.evelon.app/\",\n                \"try\":\"https://www.evelon.app/\",\n                \"twitter\":\"https://twitter.com/EvelonApp\"\n            },\n            \"slug\":\"evelon-app\",\n            \"createdAt\":1699292616145,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"evelon-app-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"evelon-app-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"evelon-app-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Evelon.App\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1690486894000,\n            \"shortDescription\":\"Transform the way you create and bring to life your own unique DNFTs, with the revolutionary platform that combines cutting-edge AI technology.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498873048,\n            \"category\":\"nfts\",\n            \"description\":\"Evelon is a no code platform that allows you to create and deploy dynamic NFTs with ease. This project is a game changer in the world of NFTs and image generation. Evelon uses AI to generate high-quality images, making it possible to create NFTs with unique visuals that are both dynamic and engaging.\",\n            \"id\":\"evelon-app\",\n            \"tags\":[\n                \"NFT\",\n                \"Tool\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://mintlabz.io/\",\n                \"try\":\"https://app.mintlabz.io/\",\n                \"twitter\":\"https://twitter.com/mintlabz\",\n                \"medium\":\"https://blog.mintlabz.io/\",\n                \"discord\":\"https://discord.com/invite/BRF2PEetea\"\n            },\n            \"slug\":\"mintlabz\",\n            \"createdAt\":1712311518649,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"mintlabz-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"mintlabz-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"mintlabz-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Mintlabz\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1712189524,\n            \"shortDescription\":\"MintLabz is a complete crosschain NFT solution at zero cost.\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498889042,\n            \"category\":\"nfts\",\n            \"description\":\"MintLabz aims to establish a digital NFT minting platform for third party projects to create NFT collections with utilities to reward the NFT holder. Our mission is to become the number one choice for providing complete cross-chain NFT solutions to B2B customers.\",\n            \"id\":\"mintlabz\",\n            \"tags\":[\n                \"nfts\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/golempark\",\n                \"website\":\"https://golempark.com\",\n                \"try\":\"https://golempark.com\",\n                \"twitter\":\"https://twitter.com/golempark\",\n                \"discord\":\"https://discord.gg/rNvtdHN8q7\"\n            },\n            \"slug\":\"golem-park\",\n            \"createdAt\":1699292617039,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"golem-park-logo-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":512,\n                    \"fileName\":\"golem-park-logo-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":512\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"golem-park-logo-full.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Golem Park\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1676839105000,\n            \"shortDescription\":\"Golem Park is holders friendly NFT collection. P2E blockchain game, $GP Token, Staking Pools &amp; more\",\n            \"contracts\":[\n                {\n                    \"chain\":\"moonbeam\",\n                    \"contract\":\"0x74746524f5A31F08e0528FaA704C2c5d8d116506\"\n                }\n            ],\n            \"updatedAt\":1722498878088,\n            \"category\":\"nfts\",\n            \"description\":\"First Time In Crypto History Token Burning Campaign!\\n30% Of Total Token Supply Will Be Burned In 30 Days.\\n\\nAfter Minting We Are Going To Release Deflationary $GP Token &amp; 50% Of Total Supply Will Be Distributed To All $GP NFT Holders, 1 NFT = 5 000 000 Tokens. Then 30 Days Each Day We'll Burn 1% Of Total Token Supply To Ensure Token Price Will Go UP!\\n\\nWorld Of Golems is a decentralized Play-To-Earn blockchain game.\\nOnce You Become Golem Park NFT Holder You Will Be Able To Participate in the WoG Game, Own Countries And Display Your Message On Them.\\n\\nThe Leaderboard Shows Of TOP 5 Wealthiest Countries &amp; Every Month Owners Of These Countries Will Be Rewarded With $GLMR.\",\n            \"id\":\"golem-park\",\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/rarible\",\n                \"website\":\"https://rarible.com/\",\n                \"try\":\"https://rarible.com/\",\n                \"twitter\":\"https://x.com/rarible\",\n                \"discord\":\"https://discord.com/invite/rarible\"\n            },\n            \"slug\":\"rarible\",\n            \"createdAt\":1722498909701,\n            \"logo\":{\n                \"small\":{\n                    \"width\":429,\n                    \"fileName\":\"rarible-small.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":121\n                },\n                \"large\":{\n                    \"width\":858,\n                    \"fileName\":\"rarible-medium.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":242\n                },\n                \"full\":{\n                    \"width\":1716,\n                    \"fileName\":\"rarible-large.png\",\n                    \"mimeType\":\"image/png\",\n                    \"height\":485\n                }\n            },\n            \"name\":\"Rarible\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"shortDescription\":\"Rarible - NFT Marketplace for Brands, Communities and Traders\",\n            \"projectCreationDate\":1721872843,\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498909701,\n            \"category\":\"nfts\",\n            \"description\":\"Discover, sell and buy NFTs on Rarible! Our aggregated NFT marketplace for Ethereum NFTs and Polygon NFTs powers brands, collections and creator marketplaces.\",\n            \"id\":\"rarible\",\n            \"featured\":false,\n            \"tags\":[\n                \"NFT\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"website\":\"https://neoncrisis.io/\",\n                \"try\":\"https://neoncrisis.io/\",\n                \"twitter\":\"https://twitter.com/NeonCrisisNFT\",\n                \"discord\":\"https://discord.gg/MVVjT9k9eD\"\n            },\n            \"slug\":\"neoncrisis-io\",\n            \"createdAt\":1702283737907,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"neoncrisis-io-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":319,\n                    \"fileName\":\"neoncrisis-io-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":319\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"neoncrisis-io-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"Neon Crisis\",\n            \"chains\":[\n                \"moonriver\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1654792548000,\n            \"shortDescription\":\"6,008 heroes on the $MOVR network. A $RMRK powered metaverse featuring battle simulations, equipables, and more!\",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498896060,\n            \"category\":\"nfts\",\n            \"description\":\"\",\n            \"id\":\"neoncrisis-io\",\n            \"tags\":[\n                \"NFT\",\n                \"Gaming\"\n            ]\n        },\n        {\n            \"urls\":{\n                \"telegram\":\"https://t.me/xp_network\",\n                \"website\":\"https://xp.network/\",\n                \"try\":\"https://xp.network/\",\n                \"twitter\":\"https://twitter.com/xpnetwork_\",\n                \"discord\":\"https://discord.com/invite/g3vkcsmd38\"\n            },\n            \"slug\":\"xp-network\",\n            \"createdAt\":1699292615205,\n            \"logo\":{\n                \"small\":{\n                    \"width\":36,\n                    \"fileName\":\"xp-network-logo-small.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":36\n                },\n                \"large\":{\n                    \"width\":400,\n                    \"fileName\":\"xp-network-logo-large.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":400\n                },\n                \"full\":{\n                    \"width\":3000,\n                    \"fileName\":\"xp-network-logo-full.jpeg\",\n                    \"mimeType\":\"image/jpeg\",\n                    \"height\":3000\n                }\n            },\n            \"name\":\"XP Network\",\n            \"chains\":[\n                \"moonbeam\"\n            ],\n            \"defiLLamaTvlExist\":false,\n            \"projectCreationDate\":1673327644000,\n            \"shortDescription\":\"A powerful NFT bridge trusted by all major blockchains \",\n            \"contracts\":[\n\n            ],\n            \"updatedAt\":1722498932103,\n            \"category\":\"nfts\",\n            \"description\":\"We build software tools that enable experienced developers and non-coding blockchain community members to move their assets seamlessly and intuitively between versatile distributed ledgers. By doing so, we encourage unlimited growth of exchange and trade between otherwise isolated ecosystems. We enable them to enrich each other technologically with insights and discoveries. To gain access to new, previously inaccessible markets with users hungry for fresh ideas and technologies to invest in.\",\n            \"id\":\"xp-network\",\n            \"tags\":[\n                \"NFT\",\n                \"Bridges\"\n            ]\n        }\n    ],\n    \"count\":39\n}\n</code></pre> <p>Below are all possible categories and their respective parameters for querying the API. Ensure you query the API with the parameter formatted exactly as shown in lowercase.</p> Category API Parameter Bridges <code>bridges</code> DAO <code>dao</code> DEX <code>dex</code> DeFi <code>defi</code> Gaming <code>gaming</code> Lending <code>lending</code> NFTs <code>nfts</code> Other <code>other</code> Social <code>social</code> Wallets <code>wallets</code>"},{"location":"learn/dapp-directory/#query-a-chain","title":"Query a Chain","text":"<p>The following queries can be used to query all of the listed projects on Moonbeam or Moonriver. Note that Moonbase Alpha is not a supported network in the DApp Directory.</p> MoonbeamMoonriver <pre><code>https://apps.moonbeam.network/api/ds/v1/app-dir/projects?chain=moonbeam\n</code></pre> <pre><code>https://apps.moonbeam.network/api/ds/v1/app-dir/projects?chain=moonriver\n</code></pre>      You are responsible for checking and validating the accuracy and truthfulness of all content. You are also responsible for doing your own diligence to understand the applicable risks present, including selection, performance, security, accuracy, or use of any third-party information.  All information contained herein is subject to modification without notice."},{"location":"learn/core-concepts/balances/","title":"Moonbeam Account Balances","text":""},{"location":"learn/core-concepts/balances/#introduction","title":"Introduction","text":"<p>While Moonbeam strives to be compatible with Ethereum's Web3 API and EVM, there are some important Moonbeam differences that developers should know and understand in terms of account balances.</p> <p>One of the design goals of Moonbeam is to create an environment that is as close as possible to Ethereum, and to offer a set of Web3 RPC endpoints that are compatible with Ethereum. However, Moonbeam is also a Substrate based chain, which means that it exposes Substrate RPCs, and that it has integral functionality that is powered by Substrate such as Staking, Governance, and other features which are not part of the Ethereum API.</p> <p>Moonbeam unified accounts are one way that Moonbeam achieves Ethereum compatibility, by changing the underlying account type in the protocol to be Ethereum-like (H160 or 20 byte addresses starting with <code>0x</code>). Unified accounts are used by both the Substrate and Ethereum APIs, and map to the same underlying data storage on the blockchain. Nevertheless, there are important differences that users coming from Ethereum should understand when using Moonbeam accounts via the Ethereum API.</p> <p>This guide will outline some of these main differences and what to expect when using Moonbeam for the first time.</p>"},{"location":"learn/core-concepts/balances/#ethereum-account-balances","title":"Ethereum Account Balances","text":"<p>An account on Ethereum is an entity with a token balance (Ether or ETH in this case). Account-holders can send Ether transactions on Ethereum and accounts can be controlled by either users (with the private key for signing) or smart contracts.</p> <p>Therefore, Ethereum has two main types of accounts: user-owned and contract-owned. No matter the type, an Ethereum account has a single balance field that represents the number of Wei owned by this address, where Wei is a denomination of ETH (1 x 10^18 Wei per ETH).</p> <p></p>"},{"location":"learn/core-concepts/balances/#moonbeam-account-balances","title":"Moonbeam Account Balances","text":"<p>An account on Moonbeam is also an entity with a token balance (the token will depend on the network). Like on Ethereum, account holders can send token transactions on the Moonbeam Network they are connected to. In addition, accounts can be controlled by users (with the private key for signing) or smart contracts.</p> <p>As with Ethereum, there are two main types of accounts: user-owned and contract owned. However, on Moonbeam, within both account types, there are also proxy accounts, which can perform a limited number of actions on behalf of another account. In terms of balances, all of Moonbeam account types have five (5) different balance types:</p> <ul> <li>Free \u2014 refers to the balance that can be used (not locked/frozen) from the Substrate API. The concept of <code>free</code> balance depends on the action to be executed. For example, voting in democracy will not subtract the allocated balance to the vote from <code>free</code> balance, but token holders won't be able to transfer that balance</li> <li>Reducible \u2014 refers to the balance that can be used (not locked/frozen) through the Ethereum API on Moonbeam. For example, this is the balance displayed by MetaMask. It is the real spendable balance, accounting for all democracy locks (displayed as transferable in Polkadot.js Apps)</li> <li>Reserved \u2014 refers to the balance held due to on-chain requirements, and that can be freed by performing some on-chain action.  For example, bonds for creating a proxy account or setting an on-chain identity are shown as <code>reserved balance</code>. These funds are not transferable or accessible via the Ethereum API until they are freed</li> <li>Misc frozen \u2014 represents a balance that the <code>free</code> balance may not drop below when withdrawing funds, except for transaction fee payment. For example, funds being used to vote on a governance proposal are shown as <code>misc frozen</code>. These funds are not transferable or accessible via the Ethereum API until they are freed</li> <li>Fee frozen \u2014 represents a balance that the <code>free</code> balance may not drop below when specifically paying for transaction fees. These funds are not transferable or accessible via the Ethereum API until they are freed</li> </ul> <p></p>"},{"location":"learn/core-concepts/balances/#calculating-your-transferable-balance","title":"Calculating Your Transferable Balance","text":"<p>An account's transferable or spendable balance can be calculated as the free balance minus the maximum of <code>0</code> or the difference between frozen and reserved tokens: </p> <pre><code>Transferable = free - max(0, frozen - reserved )\n</code></pre> <p>Here are two examples of calculating transferable balances:</p> <p>An account has <code>1000</code> free tokens, <code>200</code> frozen tokens, and <code>50</code> reserved tokens. The transferable balance is calculated as:</p> <pre><code>Transferable = 1000 - max(0, 200 - 50) = 1000 - 150 = 850\n</code></pre> <p>If the frozen tokens are less than the reserved tokens, with <code>1000</code> free tokens, <code>100</code> frozen tokens, and <code>150</code> reserved tokens, the transferable balance would be:</p> <pre><code>Transferable = 1000 - max(0, 100 - 150) = 1000 - 0 = 1000\n</code></pre>"},{"location":"learn/core-concepts/balances/#retrieve-your-balance","title":"Retrieve Your Balance","text":"<p>You can check on your balances, including your free (or transferable) and reserved balances (if exists), using the Polkadot.js API.</p> <p>Note</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n\nconst main = async () =&gt; {\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n  });\n\n  const balances = await polkadotApi.query.system.account('INSERT_ADDRESS');\n  console.log(balances.toHuman());\n};\n\nmain();\n</code></pre> <p>Note</p> <p>As of runtime 4000, staking locks were replaced by balance freezes due to the <code>ParachainStaking</code> pallet migration from the deprecated <code>Currency</code> trait to the modern <code>Fungible</code> trait. Queries that previously read <code>Balances.Locks</code> with identifiers [<code>stkngcol</code>, <code>stkngdel</code>] must now read <code>Balances.Freezes</code> with freeze reasons [<code>StakingCollator</code>, <code>StakingDelegator</code>].</p> <p>You can retrieve your balance freezes using the Polkadot.js API as shown below.</p> <pre><code>// Query Balances.Freezes\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst wsProvider = new WsProvider('wss://wss.api.moonbase.moonbeam.network');\n\nconst main = async () =&gt; {\n  const api = await ApiPromise.create({ provider: wsProvider });\n  const freezes = await api.query.balances.freezes('INSERT_ADDRESS_HERE');\n  console.log(freezes.toHuman());\n};\n\nmain();\n</code></pre>"},{"location":"learn/core-concepts/balances/#main-differences","title":"Main Differences","text":"<p>The main difference between account balances on Ethereum and Moonbeam lies in the concept of locked and reserved balance on Moonbeam. These are tokens that are still owned by that account, but they are not spendable (yet).</p> <p>From the Ethereum's API perspective, an account might show that it has a certain balance (called <code>reducible</code> balance). However, after an on-chain action, this value might increase (or decrease) without an actual balance transfer.</p> <p>It is important to note that the account and behavior differences described here apply to account balances with the base asset (GLMR, MOVR) only and the balances of that asset that aren't interacting with smart contracts. As soon as a Moonbeam account balance is interacting with smart contracts, the behavior will be the same as Ethereum behavior. For example, if you wrap MOVR on Moonriver there is no way for the underlying balance to change via staking or governance actions, because that is part of the storage of the contract. In this case the reducible balance of that account has been committed to the wrapped MOVR smart contract and can't be modified by Substrate actions.</p>"},{"location":"learn/core-concepts/consensus-finality/","title":"Moonbeam Consensus &amp; Finality","text":""},{"location":"learn/core-concepts/consensus-finality/#introduction","title":"Introduction","text":"<p>While Moonbeam strives to be compatible with Ethereum's Web3 API and EVM, there are some important Moonbeam differences that developers should know and understand in terms of consensus and finality.</p> <p>In short, consensus is a way for different parties to agree on a shared state. As blocks are created, nodes in the network must decide which block will represent the next valid state. Finality defines when that valid state cannot be altered or reversed.</p> <p>Ethereum began by using a consensus protocol based on Proof-of-Work (PoW), which provides probabilistic finality. However, in 2022, Ethereum switched to Proof-of-Stake (PoS), which provides deterministic finality, and no longer uses PoW. In contrast, Moonbeam uses a hybrid consensus protocol based on Delegated Proof-of-Stake (DPoS), which also provides deterministic finality. DPoS is an evolution of Polkadot's Nominated Proof of Stake (NPoS) concept, that puts more power into the hands of token holders by allowing delegators to choose which collator candidate they want to support and in what magnitude.</p> <p>This guide will outline some of these main differences around consensus and finality, and what to expect when using Moonbeam for the first time.</p>"},{"location":"learn/core-concepts/consensus-finality/#ethereum-consensus-and-finality","title":"Ethereum Consensus and Finality","text":"<p>Ethereum currently uses a PoS consensus protocol, in which validators stake ETH in the network and are responsible for producing blocks and checking the validity of new blocks. The timing of block production is fixed and is divided into 12 second slots and 32 slot epochs. One validator per slot is randomly selected to produce a block and broadcast it to the network. There is a randomly selected committee of validators per slot that is responsible for determining the validity of the block. The greater the stake in the network, the greater the chance the validator will be chosen to produce or validate a block.</p> <p>Finality is deterministic in Ethereum's PoS consensus protocol and is achieved through \"checkpoint\" blocks. Validators agree on the state of a block at particular checkpoint blocks, which are always the first block in an epoch, and if two-thirds of the validators agree, the block is finalized. Block finality can be reverted; however, there are strong economic incentives in place so validators do not attempt to collude to revert a block. You can find out more information in Vitalik's On Settlement Finality blog, under the Finality in Casper section.</p>"},{"location":"learn/core-concepts/consensus-finality/#moonbeam-consensus-and-finality","title":"Moonbeam Consensus and Finality","text":"<p>In Polkadot, there are collators and validators. Collators maintain parachains (in this case, Moonbeam) by collecting transactions from users and producing state transition proofs for the relay chain validators. The collator set (nodes that produce blocks) is selected based on the stake they have in the network.</p> <p>For finality, Polkadot and Kusama rely on GRANDPA. GRANDPA provides deterministic finality for any given transaction (block). In other words, when a block or transaction is marked as final, it can't be reverted except via on-chain governance or forking. Moonbeam follows this deterministic finality.</p>"},{"location":"learn/core-concepts/consensus-finality/#main-differences","title":"Main Differences Between PoS and DPoS","text":"<p>In terms of consensus, Moonbeam is based on Delegated Proof-of-Stake, while Ethereum relies on a standard Proof-of-Stake system, which is slightly different. Although both mechanisms rely on the use of stake to validate and create new blocks, there are some key differences.</p> <p>With PoS on Ethereum, validators are selected to produce and validate blocks based on their own stake in the network. As long as a validator has placed a validator deposit, they can be selected to produce and validate blocks. However, as previously mentioned, the greater the stake in the network, the higher the chances a validator has to be selected to produce and validate blocks.</p> <p>On the other hand, with DPoS on Moonbeam, collators become eligible to produce blocks based on their own stake plus their delegated stake in the network. Any token holder can choose to delegate their stake to a collator candidate. The top collator candidates by stake, including delegations, join the active set. The number of candidates in the active set is subject to governance. Once in the active set, collators are randomly selected to produce blocks using the Nimbus Consensus Framework. It is important to note that once a collator is in the active set, their total stake does not impact their chances of being selected to produce blocks.</p> <p>In terms of finality, blocks on Ethereum can take quite a bit longer to finalize than on Moonbeam due to the checkpoint finality system it uses. In Ethereum, validators determine finality at checkpoint blocks, which are always the first block in an epoch. Since an epoch has 32 slots and each slot is 12 seconds, it'll take at least 384 seconds, or 6.4 minutes for a block to be finalized.</p> <p>Moonbeam does not use checkpoint blocks and instead relies on Polkadot's GRANDPA finality gadget, where the finality process is completed in parallel to block production. In addition, the finality process incorporates the blockchain's structure, which allows the relay chain validators to vote on the highest block that they think is valid. In this scenario, the vote would apply to all of the blocks leading up to the one that is finalized, which speeds up the finalization process. After a block has been included in the relay chain, a block can be finalized within one block on Moonbeam.</p>"},{"location":"learn/core-concepts/consensus-finality/#check-tx-finality-with-ethereum-rpc-endpoints","title":"Check Transaction Finality with Ethereum RPC Endpoints","text":"<p>Although the finality gadgets differ, you can use the same, fairly simple strategy to check for transaction finality on both Ethereum and Moonbeam:</p> <ol> <li>You ask the network for the hash of the latest finalized block</li> <li>You retrieve the block number using the hash</li> <li>You compare it with the block number of your transaction. If your transaction was included in a previous block, it is finalized</li> <li>As a safety check, retrieve the block by number and verify that the given transaction hash is in the block</li> </ol> <p>The snippets below follow this strategy to check transaction finality. It uses the <code>finalized</code> option for the default block parameter to get the latest finalized block.</p> <p>To test out the examples in this guide on Moonbeam or Moonriver, you will need to have your own endpoint and API key, which you can get from one of the supported Endpoint Providers.</p> <p>Note</p> <p>The code snippets presented in the following sections are not meant for production environments. Please make sure you adapt it for each use-case.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TX_HASH';\n\n// Define the RPC of the provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT',\n    chainId: 1284,\n  }\n};\n\n// Define the Web3 provider\nconst web3Provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n\nconst main = async () =&gt; {\n  // Get the last finalized block\n  const finalizedBlockHeader = await web3Provider.getBlock('finalized');\n  const finalizedBlockNumber = finalizedBlockHeader.number;\n\n  // Get the transaction receipt of the given transaction hash\n  const txReceipt = await web3Provider.getTransactionReceipt(txHash);\n\n  // If block number of receipt is not null, compare it against finalized head\n  if (txReceipt) {\n    const txBlockNumber = txReceipt.blockNumber;\n\n    // As a safety check, get given block to check if transaction is included\n    const txBlock = await web3Provider.getBlock(txBlockNumber);\n\n    console.log(`Current finalized block number is ${finalizedBlockNumber}`);\n    console.log(\n      `Your transaction in block ${txBlockNumber} is finalized? ${\n        finalizedBlockNumber &gt;= txBlockNumber\n      }`\n    );\n    console.log(\n      `Your transaction is indeed in block ${txBlockNumber}? ${txBlock.transactions.includes(\n        txHash\n      )}`\n    );\n  } else {\n    console.log(\n      'Your transaction has not been included in the canonical chain'\n    );\n  }\n};\n\nmain();\n</code></pre> <pre><code>import { Web3 } from 'web3';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TX_HASH';\n\n// Define the Web3 provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst web3Provider = new Web3('INSERT_RPC_API_ENDPOINT');\n\nconst main = async () =&gt; {\n  // Get the last finalized block\n  const finalizedBlockHeader = await web3Provider.eth.getBlock('finalized');\n  const finalizedBlockNumber = finalizedBlockHeader.number;\n\n  // Get the transaction receipt of the given transaction hash\n  const txReceipt = await web3Provider.eth.getTransactionReceipt(txHash);\n\n  // If block number of receipt is not null, compare it against finalized head\n  if (txReceipt) {\n    const txBlockNumber = txReceipt.blockNumber;\n\n    // As a safety check, get given block to check if transaction is included\n    const txBlock = await web3Provider.eth.getBlock(txBlockNumber);\n\n    console.log(`Current finalized block number is ${finalizedBlockNumber}`);\n    console.log(\n      `Your transaction in block ${txBlockNumber} is finalized? ${\n        finalizedBlockNumber &gt;= txBlockNumber\n      }`\n    );\n    console.log(\n      `Your transaction is indeed in block ${txBlockNumber}? ${txBlock.transactions.includes(\n        txHash\n      )}`\n    );\n  } else {\n    console.log(\n      'Your transaction has not been included in the canonical chain'\n    );\n  }\n};\n\nmain();\n</code></pre> <pre><code>from web3 import Web3\n\n# Define the transaction hash to check finality\ntx_hash = \"INSERT_TX_HASH\"\n\n# Define the Web3 provider for Moonbeam\n# This can be adapted for Moonriver or Moonbase Alpha\nweb3_provider = Web3(Web3.HTTPProvider(\"INSERT_RPC_API_ENDPOINT\"))\n\nif __name__ == \"__main__\":\n    # Get the latest finalized block\n    finalized_block_header = web3_provider.eth.get_block(\"finalized\")\n    finalized_block_number = finalized_block_header.number\n\n    # Get the transaction receipt of the given transaction hash\n    tx_receipt = web3_provider.eth.get_transaction_receipt(tx_hash)\n\n    # If block number of receipt is not null, compare it against finalized head\n    if tx_receipt is not None:\n        tx_block_number = tx_receipt.blockNumber\n\n        # As a safety check, get given block to check if transaction is included\n        tx_block = web3_provider.eth.get_block(tx_block_number)\n        is_in_block = False\n        for tx in tx_block.transactions:\n            if tx_hash == web3_provider.to_hex(tx):\n                is_in_block = True\n\n        print(f\"Current finalized block number is { str(finalized_block_number) }\")\n        print(\n            f\"Your transaction in block { str(tx_block_number) } is finalized? { str(finalized_block_number &gt;= tx_block_number) }\"\n        )\n        print(\n            f\"Your transaction is indeed in block { str(tx_block_number) }? { is_in_block }\"\n        )\n    else:\n        print(\"Your transaction has not been included in the canonical chain\")\n</code></pre>"},{"location":"learn/core-concepts/consensus-finality/#check-tx-finality-with-moonbeam-rpc-endpoints","title":"Check Transaction Finality with Moonbeam RPC Endpoints","text":"<p>Moonbeam has added support for two custom RPC endpoints, <code>moon_isBlockFinalized</code> and <code>moon_isTxFinalized</code>, that can be used to check whether an on-chain event is finalized. These methods are a bit more straightforward, as you don't need to compare block numbers to ensure your transaction is finalized.</p> <p>For more information, you can go to the Finality RPC Endpoints section of the Moonbeam Custom API page.</p> <p>You can modify the scripts from the Ethereum RPC section above to use <code>moon_isBlockFinalized</code> and <code>moon_isTxFinalized</code>. To do this, you can make custom calls to the Substrate JSON-RPC using the <code>send</code> method of both Web3.js and Ethers.js. Custom RPC requests are also possible using Web3.py with the <code>make_request</code> method. You'll need to pass in the method name and the parameters to the custom request, which you can find on the Moonbeam Custom API page.</p> moon_isBlockFinalized Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers';\n\n// Define the block hash to check finality\nconst blockHash = 'INSERT_BLOCK_HASH';\n\n// Define the RPC of the provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT',\n    chainId: 1284,\n  },\n};\n\n// Define the Web3 provider\nconst web3Provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n\n// Define the function for the custom web3 request\nconst customWeb3Request = async (web3Provider, method, params) =&gt; {\n  try {\n    return await web3Provider.send(method, params);\n  } catch (error) {\n    throw new Error(error.body);\n  }\n};\n\nconst main = async () =&gt; {\n  // Check if the block has been finalized\n  const isFinalized = await customWeb3Request(\n    web3Provider,\n    'moon_isBlockFinalized',\n    [blockHash]\n  );\n  console.log(`Block is finalized? ${isFinalized}`);\n};\n\nmain();\n</code></pre> <pre><code>import { Web3 } from 'web3';\n\n// Define the block hash to check finality\nconst blockHash = 'INSERT_BLOCK_HASH';\n\n// Define the Web3 provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst web3Provider = new Web3('INSERT_RPC_API_ENDPOINT');\n\n// Define the function for the custom Web3 request\nconst customWeb3Request = async (web3Provider, method, params) =&gt; {\n  try {\n    return await requestPromise(web3Provider, method, params);\n  } catch (error) {\n    throw new Error(error);\n  }\n};\n\n// In Web3.js you need to return a promise\nconst requestPromise = async (web3Provider, method, params) =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    web3Provider.send(\n      {\n        jsonrpc: '2.0',\n        id: 1,\n        method,\n        params,\n      },\n      (error, result) =&gt; {\n        if (error) {\n          reject(error.message);\n        } else {\n          if (result.error) {\n            reject(result.error.message);\n          }\n          resolve(result);\n        }\n      }\n    );\n  });\n};\n\nconst main = async () =&gt; {\n  // Check if the block has been finalized\n  const isFinalized = await customWeb3Request(\n    web3Provider.currentProvider,\n    'moon_isBlockFinalized',\n    [blockHash]\n  );\n\n  console.log(JSON.stringify(isFinalized));\n  console.log(`Block is finalized? ${isFinalized.result}`);\n};\n\nmain();\n</code></pre> <pre><code>from web3 import Web3\n\n# Define the block hash to check finality\nblock_hash = 'INSERT_BLOCK_HASH'\n\n# Set the RPC_address for Moonbeam\n# This can also be adapted for Moonriver or Moonbase Alpha\nRPC_address = 'INSERT_RPC_API_ENDPOINT'\n\n# Define the Web3 provider\nweb3_provider = Web3(Web3.HTTPProvider(RPC_address))\n\n# Asynchronous JSON-RPC API request\ndef custom_web3_request(method, params):\n    response = web3_provider.provider.make_request(method, params)\n    return response\n\nif __name__ == \"__main__\":\n    # Check if the block has been finalized\n    is_finalized = custom_web3_request(\n       'moon_isBlockFinalized', [block_hash])\n    print(\n        f'Block is finalized? { is_finalized[\"result\"] }')\n</code></pre> moon_isTxFinalized Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from 'ethers';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TRANSACTION_HASH';\n\n// Define the RPC of the provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: 'INSERT_RPC_API_ENDPOINT',\n    chainId: 1284,\n  },\n};\n\n// Define the Web3 provider\nconst web3Provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\n\n// Define the function for the custom web3 request\nconst customWeb3Request = async (web3Provider, method, params) =&gt; {\n  try {\n    return await web3Provider.send(method, params);\n  } catch (error) {\n    throw new Error(error.body);\n  }\n};\n\nconst main = async () =&gt; {\n  // Check if the transaction has been finalized\n  const isFinalized = await customWeb3Request(\n    web3Provider,\n    'moon_isTxFinalized',\n    [txHash]\n  );\n  console.log(`Transaction is finalized? ${isFinalized}`);\n};\n\nmain();\n</code></pre> <pre><code>import Web3 from 'web3';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TRANSACTION_HASH';\n\n// Define the Web3 provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst web3Provider = new Web3('INSERT_RPC_API_ENDPOINT');\n\n// Define the function for the custom Web3 request\nconst customWeb3Request = async (web3Provider, method, params) =&gt; {\n  try {\n    return await requestPromise(web3Provider, method, params);\n  } catch (error) {\n    throw new Error(error);\n  }\n};\n\n// In Web3.js you need to return a promise\nconst requestPromise = async (web3Provider, method, params) =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    web3Provider.send(\n      {\n        jsonrpc: '2.0',\n        id: 1,\n        method,\n        params,\n      },\n      (error, result) =&gt; {\n        if (error) {\n          reject(error.message);\n        } else {\n          if (result.error) {\n            reject(result.error.message);\n          }\n          resolve(result);\n        }\n      }\n    );\n  });\n};\n\nconst main = async () =&gt; {\n  // Check if the transaction has been finalized\n  const isFinalized = await customWeb3Request(\n    web3Provider.currentProvider,\n    'moon_isTxFinalized',\n    [txHash]\n  );\n\n  console.log(JSON.stringify(isFinalized));\n  console.log(`Transaction is finalized? ${isFinalized}`);\n};\n\nmain();\n</code></pre> <pre><code>from web3 import Web3\n\n# Define the transaction hash to check finality\ntx_hash = 'INSERT_BLOCK_HASH'\n\n# Set the RPC_address for Moonbeam\n# This can also be adapted for Moonriver or Moonbase Alpha\nRPC_address = 'INSERT_RPC_API_ENDPOINT'\n\n# Define the Web3 provider\nweb3_provider = Web3(Web3.HTTPProvider(RPC_address))\n\n# Asynchronous JSON-RPC API request\ndef custom_web3_request(method, params):\n    response = web3_provider.provider.make_request(method, params)\n    return response\n\nif __name__ == \"__main__\":\n    # Check if the transaction has been finalized\n    is_finalized = custom_web3_request(\n       'moon_isTxFinalized', [tx_hash])\n    print(\n        f'Transaction is finalized? { is_finalized[\"result\"] }')\n</code></pre>"},{"location":"learn/core-concepts/consensus-finality/#check-tx-finality-with-substrate-rpc-endpoints","title":"Check Transaction Finality with Substrate RPC Endpoints","text":"<p>Using the following three RPC requests from the Substrate JSON-RPC, you can fetch the current finalized block and compare it with the block number of the transaction you want to check finality for:</p> <ul> <li><code>chain_getFinalizedHead</code> - the first request gets the block hash of the last finalized block</li> <li><code>chain_getHeader</code> - the second request gets the block header for a given block hash</li> <li><code>eth_getTransactionReceipt</code> - this retrieves the transaction receipt given the transaction hash</li> </ul> <p>The Polkadot.js API package and Python Substrate Interface package provide developers with a way to interact with Substrate chains using JavaScript and Python.</p> <p>You can find more information about Polkadot.js and the Substrate JSON-RPC in the official Polkadot.js documentation site, and more about Python Substrate Interface in the official PySubstrate documentation site.</p> Polkadot.jspy-substrate-interface <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { types } from 'moonbeam-types-bundle';\n\n// Define the transaction hash to check finality\nconst txHash = 'INSERT_TX_HASH';\n\n// Define the provider for Moonbeam\n// This can be adapted for Moonriver or Moonbase Alpha\nconst wsProvider = new WsProvider('INSERT_WSS_API_ENDPOINT');\n\nconst main = async () =&gt; {\n  // Create the provider using Moonbeam types\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n    typesBundle: types,\n  });\n  await polkadotApi.isReady;\n\n  // Get the latest finalized block of the Substrate chain\n  const finalizedHeadHash = (\n    await polkadotApi.rpc.chain.getFinalizedHead()\n  ).toJSON();\n\n  // Get finalized block header to retrieve number\n  const finalizedBlockHeader = (\n    await polkadotApi.rpc.chain.getHeader(finalizedHeadHash)\n  ).toJSON();\n\n  // Get the transaction receipt of the given tx hash\n  const txReceipt = (\n    await polkadotApi.rpc.eth.getTransactionReceipt(txHash)\n  ).toJSON();\n\n  // You can not verify if the tx is in the block because polkadotApi.rpc.eth.getBlockByNumber\n  // does not return the list of tx hashes\n\n  // If block number of receipt is not null, compare it against finalized head\n  if (txReceipt) {\n    console.log(\n      `Current finalized block number is ${finalizedBlockHeader.number}`\n    );\n    console.log(\n      `Your transaction in block ${txReceipt.blockNumber} is finalized? ${\n        finalizedBlockHeader.number &gt;= txReceipt.blockNumber\n      }`\n    );\n  } else {\n    console.log(\n      'Your transaction has not been included in the canonical chain'\n    );\n  }\n\n  polkadotApi.disconnect();\n};\n\nmain();\n</code></pre> <pre><code>from substrateinterface import SubstrateInterface\n\n# Define the Ethereum transaction hash to check finality\ntx_hash = \"INSERT_TX_HASH\"\n\n# Point API provider to Moonbeam\n# This can be adapted for Moonriver or Moonbase Alpha\nmoonbeam_API_provider = SubstrateInterface(\n    url=\"INSERT_WSS_API_ENDPOINT\",\n)\n\nif __name__ == \"__main__\":\n    # Get the latest finalized block header of the chain\n    finalized_block_header = moonbeam_API_provider.get_block_header(finalized_only=True)\n    # Get the finalized block number from the block header\n    finalized_block_number = finalized_block_header[\"header\"][\"number\"]\n    # Get the transaction receipt of the given transaction hash through a\n    # custom RPC request\n    tx_receipt = moonbeam_API_provider.rpc_request(\n        \"eth_getTransactionReceipt\", [tx_hash]\n    )\n\n    # Check if tx_receipt is null\n    if tx_receipt is None:\n        print(\"The transaction hash cannot be found in the canonical chain.\")\n    else:\n        # Get the block number of the transaction\n        tx_block_number = int(tx_receipt[\"result\"][\"blockNumber\"], 16)\n        # Get the transaction block through a custom RPC request\n        tx_block = moonbeam_API_provider.rpc_request(\n            \"eth_getBlockByNumber\", [tx_block_number, False]\n        )\n\n        print(f\"Current finalized block number is { str(finalized_block_number) }\")\n        print(\n            f\"Your transaction in block { str(tx_block_number) } is finalized? { str(finalized_block_number &gt;= tx_block_number) }\"\n        )\n        print(\n            f'Your transaction is indeed in block { str(tx_block_number) }? { str(tx_hash in tx_block[\"result\"][\"transactions\"]) }'\n        )\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"learn/core-concepts/glossary/","title":"Glossary","text":"<p>There's a great deal of terminology that's specific to Polkadot, Substrate, and the emerging Parity/Web3 ecosystem. We've compiled a list of terms we think you'll want to know as you review the Moonbeam documentation, plans, and tutorials.</p>"},{"location":"learn/core-concepts/glossary/#collators","title":"Collators","text":"<p>One of the key network participants needed to support parachains within the Polkadot Network. In Moonbeam, collators are the nodes that are responsible for block production and for submitting produced blocks up to the Polkadot relay chain for finalization.</p>"},{"location":"learn/core-concepts/glossary/#delegators","title":"Delegators","text":"<p>Moonbeam token holders who stake tokens, vouching for specific collator candidates on the parachain. Any user that holds a minimum amount of tokens as free balance can become a delegator by staking their tokens.</p>"},{"location":"learn/core-concepts/glossary/#nominators","title":"Nominators","text":"<p>Relay chain token holders who select to \"back\" a validator. They can receive part of the validator's reward, but are subject to slashing of their staked tokens in case the validator misbehaves. A nominator can back up to 16 validators, and their bond is fully distributed between the backed validators that were selected for the validator set.</p>"},{"location":"learn/core-concepts/glossary/#nominated-proof-of-stake","title":"Nominated Proof of Stake","text":"<p>The mechanism used by Polkadot for selecting its block validator set to maximize chain security. At its core, it is a Proof-of-Stake system (PoS) in which nominators back validators. The latter with the highest backing are selected to be part of the validator set for a session. The stake of a validator is slashed in case of misbehavior. Thus, nominators are expected to do due diligence on the validators they nominate.</p>"},{"location":"learn/core-concepts/glossary/#parachains","title":"Parachains","text":"<p>A blockchain which has a slot and is connected to Polkadot. Parachains receive shared security from Polkadot and the ability to interact with other parachains on the Polkadot network. They must lock DOT, the native relay chain token, to secure a slot for a specific period (up two years).</p>"},{"location":"learn/core-concepts/glossary/#parathreads","title":"Parathreads","text":"<p>A blockchain which can connect to Polkadot. Parathreads are able to interact with other members of the Polkadot network, but they bid for block finalization (in DOT) on a block-to-block basis. They compete with other parathreads for block finalization, meaning that the block with the highest bid is selected to be finalize in that round.</p>"},{"location":"learn/core-concepts/glossary/#polkadot","title":"Polkadot","text":"<p>A network of connected blockchains that provides shared security and the ability to interact between chains. Polkadot is built using the Substrate development framework. Chains that connect to Polkadot are called parachains.</p>"},{"location":"learn/core-concepts/glossary/#relay-chain","title":"Relay Chain","text":"<p>The backbone blockchain supporting the Polkadot network. Parachains connect to the relay chain and use it for shared security and message passing. Validators on the relay chain help secure the parachains.</p>"},{"location":"learn/core-concepts/glossary/#smart-contract","title":"Smart Contract","text":"<p>A smart contract is a computer program or a transaction protocol that is intended to automatically execute, control, or document legally relevant events and actions according to the terms of a contract or an agreement. Smart contracts intend to reduce the need for trusted intermediators, arbitrations, and enforcement costs, as well as reduce fraud losses and malicious and accidental exceptions.</p>"},{"location":"learn/core-concepts/glossary/#substrate","title":"Substrate","text":"<p>A Rust-based blockchain development framework created by Parity Technologies based on their experience implementing multiple blockchain clients. Substrate comes with many modules and functionalities that are needed when building a blockchain, including P2P networking, consensus mechanisms, staking, cryptocurrency, on-chain governance modules, and more. It reduces the time and engineering effort required to implement a blockchain. Substrate is part of the Polkadot SDK.</p>"},{"location":"learn/core-concepts/glossary/#substrate-frame-pallets","title":"Substrate Frame Pallets","text":"<p>Substrate Frame Pallets are a collection of Rust-based modules, providing the functionality required for building a blockchain.</p>"},{"location":"learn/core-concepts/glossary/#validators","title":"Validators","text":"<p>A node that secures the Polkadot relay chain by staking DOT in the network, which is slashed if they misbehave. They finalize blocks from collators on parachains and also participate on consensus for the next relay chain block with other validators.</p>"},{"location":"learn/core-concepts/glossary/#webassemblywasm","title":"WebAssembly/Wasm","text":"<p>WebAssembly is an open standard that defines a portable binary code format. It is supported by different programming languages, compilers, and browsers.</p>"},{"location":"learn/core-concepts/security/","title":"Security Considerations","text":""},{"location":"learn/core-concepts/security/#introduction","title":"Introduction","text":"<p>When developing smart contracts on Moonbeam, there are some security considerations to be aware of that do not apply when developing on Ethereum. Moonbeam has several precompiled contracts, which are Solidity interfaces that enable developers to access Substrate-based functionality through the Ethereum API, but circumventing the EVM. Although the precompiled contracts are designed to improve the developer experience, there can be some unintended consequences that must be considered.</p> <p>This guide will outline and provide examples of some security considerations to be cognizant of when developing on Moonbeam.</p>"},{"location":"learn/core-concepts/security/#arbitrary-code-execution","title":"Arbitrary Code Execution","text":"<p>Arbitrary code execution in Solidity is the ability to execute code and call functions of other contracts using an arbitrary number of arguments of any type.</p> <p>A smart contract allows arbitrary execution of another contract when it allows a user to influence its own <code>call()</code> and pass in arbitrary call data and/or the <code>call()</code>s target. The <code>call()</code> function is made available through the address data type in Solidity. When the <code>call()</code> function is invoked, the target contract is called using the arbitrary call data.</p> <p>Arbitrary code execution follows the pattern in the diagram below when Contract A allows a user to influence its call to Contract B.</p> <p></p> <p>As previously mentioned, one major concern of arbitrarily executing code on Moonbeam is that Moonbeam has precompile contracts that can be called, which can be used to get around some protections that are typically available on Ethereum. To safely use arbitrary code execution on Moonbeam, you should consider the following, which only applies to contracts that allow arbitrary code execution:</p> <ul> <li>Moonbeam precompiled contracts such as the Native ERC-20 precompile, XC-20 precompiles, and XCM-related precompiles allow users to manage and transfer assets without requiring access to the EVM. Instead, these actions are done using native Substrate code. So, if your contract holds native tokens or XC-20s and allows arbitrary code execution, these precompiles can be used to drain the balance of the contract, bypassing any security checks that are normally enforced by the EVM</li> <li>Setting the value attribute of the transaction object to a fixed amount when using the <code>call()</code> function (for example, <code>call{value: 0}(...)</code>) can be bypassed by calling the native asset precompile and specifying an amount to transfer in the encoded call data</li> <li>Allowing users that consume your contract to pass in arbitrary call data that will execute any function on the target contract, especially if the contract being targeted is a precompile, is not safe. To be safe, you can hard code the function selector for a safe function that you want to allow to be executed</li> <li>Blacklisting target contracts (including precompiles) in the function that executes arbitrary call data is not considered safe, as other precompiles might be added in the future. Providing whitelisted target contracts in the function that executes the arbitrary call data is considered safe, assuming that the contracts being called are not precompiles, or that in the case they are, the contract making the call does not hold the native token or any XC-20</li> </ul> <p>In the following sections, you'll learn about each of these security considerations through examples.</p>"},{"location":"learn/core-concepts/security/#setting-a-value","title":"Precompiles Can Override a Set Value","text":"<p>On Ethereum, a smart contract that allows for arbitrary code execution could force the value of a call to be a specific amount (for example, <code>{value: 0}</code>), guaranteeing that only that amount of native currency would be sent with the transaction. Whereas on Moonbeam, the native ERC-20 precompile contract enables you to interact with the native currency on Moonbeam as an ERC-20 through the Substrate API. As a result, you can transfer the Moonbeam native asset from a smart contract by setting the <code>value</code> of a call, as well as through the native ERC-20 precompile. If you set the <code>value</code> of an arbitrary call, it can be overridden by targeting the native ERC-20 precompile contract and passing in call data to transfer the native asset. Since ERC-20s and XC-20s are not native assets, setting the value attribute doesn't provide any protection for these types of assets on Ethereum or Moonbeam.</p> <p>For example, if you have a contract that allows arbitrary code execution and you pass it encoded call data that transfers the balance of a contract to another address, you could essentially drain the given contract of its balance.</p> <p>To get the encoded call data, you can use any of the ABI encoding functions outlined in the Solidity docs, including <code>abi.encodeWithSelector</code> as seen in the following function:</p> <pre><code>function getBytes(address _erc20Contract, address _arbitraryCallContract, address _to) public view returns (bytes memory) {\n    // Load ERC-20 interface of contract\n    IERC20 erc20 = IERC20(_erc20Contract);\n    // Get amount to transfer\n    uint256 amount = erc20.balanceOf(_arbitraryCallContract);\n    // Build the encoded call data\n    return abi.encodeWithSelector(IERC20.transfer.selector, _to, amount);\n}\n</code></pre> <p>Once you have the encoded call data, you could make an arbitrary call to the native ERC-20 precompile contract, set the value of the call to <code>0</code>, and pass in the call data in bytes:</p> <pre><code>function makeArbitraryCall(address _target, bytes calldata _bytes) public {\n    // Value: 0 does not protect against native ERC-20 precompile calls or XCM precompiles\n    (bool success,) = _target.call{value: 0}(_bytes);\n    require(success);\n}\n</code></pre> <p>The value of <code>0</code> will be overridden by the amount to be transferred as specified in the encoded call data, which in this example is the balance of the contract.</p>"},{"location":"learn/core-concepts/security/#whitelisting-function-selectors","title":"Whitelisting Safe Function Selectors","text":"<p>By whitelisting a specific function selector, you can control what functions can be executed and ensure only functions that are considered safe and do not call precompiles are allowed to be called.</p> <p>To get the function selector to whitelist, you can keccack256 hash the signature of the function.</p> <p>Once you have the whitelisted function selector, you can use inline assembly to get the function selector from the encoded call data and compare the two selectors using the require function. If the function selector from the encoded call data matches the whitelisted function selector, you can make the call. Otherwise, an exception will be thrown.</p> <pre><code>function makeArbitraryCall(address _target, bytes calldata _bytes) public {\n    // Get the function selector from the encoded call data\n    bytes4 selector;\n    assembly {\n        selector := calldataload(_bytes.offset)\n    }\n\n    // Ensure the call data calls an approved and safe function\n    require(selector == INSERT_WHITELISTED_FUNCTION_SELECTOR);\n\n    // Arbitrary call\n    (bool success,) = _target.call(_bytes);\n    require(success);\n}\n</code></pre>"},{"location":"learn/core-concepts/security/#whitelisting-safe-contracts","title":"Whitelisting Safe Contracts","text":"<p>By whitelisting a specific target contract address in the function that can execute arbitrary call data, you can ensure that the call is considered safe, as the EVM will enforce that only whitelisted contracts can be called. This assumes that the contracts being called are not precompiles. If they are precompiles, you'll want to make sure that the contract making the call does not hold the native token or any XC-20.</p> <p>Blacklisting contracts from arbitrary code execution is not considered safe, as other precompiles might be added in the future.</p> <p>To whitelist a given contract, you can use the require function, which will compare the target contract address to the whitelisted contract address. If the addresses match, the call can be executed. Otherwise, an exception will be thrown.</p> <pre><code>function makeArbitraryCall(address _target, bytes calldata _bytes) public {\n    // Ensure the contract address is safe\n    require(_target == INSERT_CONTRACT_ADDRESS);\n\n    // Arbitrary call\n    (bool success,) = _target.call(_bytes);\n    require(success);\n}\n</code></pre>"},{"location":"learn/core-concepts/security/#bypass-sender-origin-checks","title":"Precompiles Can Bypass Sender vs Origin Checks","text":"<p>The transaction origin, or <code>tx.origin</code>, is the address of the externally owned account (EOA) the transaction originated from. Whereas the <code>msg.sender</code> is the address that has initiated the current call. The <code>msg.sender</code> can be an EOA or a contract. The two can be different values if one contract calls another contract, as opposed to directly calling a contract from an EOA. In this case, the <code>msg.sender</code> will be the calling contract and the <code>tx.origin</code> will be the EOA that initially called the calling contract.</p> <p>For example, if Alice calls a function in contract A that then calls a function in contract B, when looking at the call to contract B, the <code>tx.origin</code> is Alice and the <code>msg.sender</code> is contract A.</p> <p>Note</p> <p>As a best practice, <code>tx.origin</code> should not be used for authorization. Instead, you should use <code>msg.sender</code>.</p> <p>You can use the require function to compare the <code>tx.origin</code> and <code>msg.sender</code>. If they are the same address, you're ensuring that only EOAs can call the function. If the <code>msg.sender</code> is a contract address, an exception will be thrown.</p> <pre><code>function transferFunds(address payable _target) payable public {\n    require(tx.origin == msg.sender);\n    _target.call{value: msg.value};\n}\n</code></pre> <p>On Ethereum, you can use this check to ensure that a given contract function can only be called once by an EOA. This is because on Ethereum, EOAs can only interact with a contract once per transaction. However, this is not the case on Moonbeam, as EOAs can interact with a contract multiple times at once by using precompiled contracts, such as the batch and call permit precompiles.</p> <p>With the batch precompile, users can perform multiple calls to a contract atomically. The caller of the batch function will be the <code>msg.sender</code> and <code>tx.origin</code>, enabling multiple contract interactions at once.</p> <p>With the call permit precompile, if a user wants to interact with a contract multiple times in one transaction, they can do so by signing a permit for each contract interaction and dispatching all of the permits in a single function call. This will only bypass the <code>tx.origin == msg.sender</code> check if the dispatcher is the same account as the permit signer. Otherwise, the <code>msg.sender</code> will be the permit signer and the <code>tx.origin</code> will be the dispatcher, causing an exception to be thrown.</p>"},{"location":"learn/core-concepts/transfers-api/","title":"Balance Transfers on Moonbeam","text":""},{"location":"learn/core-concepts/transfers-api/#introduction","title":"Introduction","text":"<p>While Moonbeam strives to be compatible with Ethereum's Web3 API and EVM, there are some important Moonbeam differences that developers should know and understand in terms of balance transfers of the base network token (for example, GLMR and MOVR).</p> <p>Token holders have two ways of initiating a balance transfer on Moonbeam. On the one hand, users can use the Ethereum API via apps like MetaMask, MathWallet, or any other tools that use the Ethereum JSON-RPC. On the other hand, users can use the Substrate API via the Polkadot.js Apps website or directly using the Substrate RPC.</p> <p>Developers need to be aware that token holders can leverage both APIs to transfer the base-layer network token. Note that these comments do not apply to transfers of other assets, like ERC-20 based assets in the Moonriver or Moonbeam EVMs. Transfers of these assets are only done via the Ethereum APIs since these are smart contract interactions.</p> <p>This guide will outline some of the main differences between both APIs for base-layer network token balance transfers and what to expect when using Moonbeam for the first time.</p>"},{"location":"learn/core-concepts/transfers-api/#ethereum-transfers","title":"Ethereum Transfers","text":"<p>A simple balance transfer using the Ethereum API relies on the <code>eth_sendRawTransaction</code> JSON-RPC. This can be done directly from one account to another or via a smart contract.</p> <p>There are different strategies to listen for transfers or balance changes on Ethereum, which are not covered in this documentation. But they are all focused on different strategies using the Ethereum JSON-RPC.</p>"},{"location":"learn/core-concepts/transfers-api/#moonbeam-transfers","title":"Moonbeam Transfers","text":"<p>As stated before, Moonbeam enables token holders to execute base-layer network token transfers via both the Ethereum and Substrate API. There are multiple scenarios to trigger token transfers on Moonbeam. Consequently, to monitor all transfers, you should use the Polkadot.js SDK (Substrate API).</p> <p>Before going over the different scenarios, there are two different elements associated with a block:</p> <ul> <li>Extrinsic \u2014 refers to state changes that originated outside of the system itself. The most common form of extrinsic is a transaction. They are ordered by execution</li> <li>Events \u2014 refers to logs generated from the extrinsic. There can be multiple events per extrinsic. They are ordered by execution</li> </ul> <p>The different transfer scenarios are:</p> <ul> <li>Substrate transfer \u2014 it will create an extrinsic, either <code>balances.transferAllowDeath</code> or <code>balances.transferKeepAlive</code>. It will trigger one <code>balances.Transfer</code> event</li> <li>Substrate feature \u2014 some native Substrate features can create extrinsic that would send tokens to an address. For example, Treasury can create an extrinsic such as <code>treasury.proposeSend</code>, which will trigger one or multiple <code>balances.Transfer</code> events</li> <li>Ethereum transfer \u2014 it will create an <code>ethereum.transact</code> extrinsic with an empty input. It will trigger one <code>balances.Transfer</code> event</li> <li>Ethereum transfers via smart contracts \u2014 it will create an <code>ethereum.transact</code> extrinsic with some data as input. It will trigger one or multiple <code>balances.Transfer</code> events</li> </ul> <p>All the scenarios described above will effectively transfer base-layer network tokens. The easiest way to monitor them all is to rely on the <code>balances.Transfer</code> event.</p>"},{"location":"learn/core-concepts/transfers-api/#monitor-transfers","title":"Monitor Native Token Balance Transfers","text":"<p>The following code samples will demonstrate how to listen to both types of native token transfers, sent via the Substrate or Ethereum API, using either the Polkadot.js API library or Substrate API Sidecar. The following code snippets are for demo purposes only and should not be used without modification and further testing in a production environment.</p>"},{"location":"learn/core-concepts/transfers-api/#using-polkadotjs-api","title":"Using Polkadot.js API","text":"<p>The Polkadot.js API package provides developers a way to interact with Substrate chains using JavaScript.</p> <p>The following code snippet uses <code>subscribeFinalizedHeads</code> to subscribe to new finalized block headers, loops through extrinsics fetched from the block, and retrieves the events of each extrinsic. Then, it checks if any event corresponds to a <code>balances.Transfer</code> event. If so, it will extract the <code>from</code>, <code>to</code>, <code>amount</code>, and the <code>tx hash</code> of the transfer and display it on the console. Note that the <code>amount</code> is shown in the smallest unit (Wei).  You can find all the available information about Polkadot.js and the Substrate JSON-RPC on their official documentation site.</p> <pre><code>import { typesBundlePre900 } from 'moonbeam-types-bundle';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\n// This script will listen to all GLMR transfers (Substrate &amp; Ethereum) and extract the tx hash\n// It can be adapted for Moonriver or Moonbase Alpha\n\nconst main = async () =&gt; {\n  // Define the provider for Moonbeam\n  const wsProvider = new WsProvider('wss://wss.api.moonbeam.network');\n  // Create the provider using Moonbeam types\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n    typesBundle: typesBundlePre900 as any,\n  });\n\n  // Subscribe to finalized blocks\n  await polkadotApi.rpc.chain.subscribeFinalizedHeads(\n    async (lastFinalizedHeader) =&gt; {\n      const [{ block }, records] = await Promise.all([\n        polkadotApi.rpc.chain.getBlock(lastFinalizedHeader.hash),\n        polkadotApi.query.system.events.at(lastFinalizedHeader.hash),\n      ]);\n\n      block.extrinsics.forEach((extrinsic, index) =&gt; {\n        const {\n          method: { args, method, section },\n        } = extrinsic;\n\n        const isEthereum = section == 'ethereum' &amp;&amp; method == 'transact';\n\n        // Gets the transaction object\n        const tx = args[0] as any;\n\n        // Convert to the correct Ethereum Transaction format\n        const ethereumTx =\n          isEthereum &amp;&amp;\n          ((tx.isLegacy &amp;&amp; tx.asLegacy) ||\n            (tx.isEip1559 &amp;&amp; tx.asEip1559) ||\n            (tx.isEip2930 &amp;&amp; tx.asEip2930));\n\n        // Check if the transaction is a transfer\n        const isEthereumTransfer =\n          ethereumTx &amp;&amp;\n          ethereumTx.input.length === 0 &amp;&amp;\n          ethereumTx.action.isCall;\n\n        // Retrieve all events for this extrinsic\n        const events = records.filter(\n          ({ phase }) =&gt;\n            phase.isApplyExtrinsic &amp;&amp; phase.asApplyExtrinsic.eq(index)\n        );\n\n        // This hash will only exist if the transaction was executed through Ethereum.\n        let ethereumHash = '';\n\n        if (isEthereum) {\n          // Search for Ethereum execution\n          events.forEach(({ event }) =&gt; {\n            if (event.section == 'ethereum' &amp;&amp; event.method == 'Executed') {\n              ethereumHash = event.data[2].toString();\n            }\n          });\n        }\n\n        // Search if it is a transfer\n        events.forEach(({ event }) =&gt; {\n          if (event.section == 'balances' &amp;&amp; event.method == 'Transfer') {\n            const from = event.data[0].toString();\n            const to = event.data[1].toString();\n            const balance = (event.data[2] as any).toBigInt();\n\n            const substrateHash = extrinsic.hash.toString();\n\n            console.log(\n              `Transfer from ${from} to ${to} of ${balance} (block #${lastFinalizedHeader.number})`\n            );\n            console.log(`  - Triggered by extrinsic: ${substrateHash}`);\n            if (isEthereum) {\n              console.log(\n                `  - Ethereum (isTransfer: ${isEthereumTransfer}) hash: ${ethereumHash}`\n              );\n            }\n          }\n        });\n      });\n    }\n  );\n};\n\nmain();\n</code></pre> <p>In addition, you can find more sample code snippets related to more specific cases around balance transfers on this GitHub page.</p>"},{"location":"learn/core-concepts/transfers-api/#using-substrate-api-sidecar","title":"Using Substrate API Sidecar","text":"<p>Developers can also retrieve Moonbeam blocks and monitor transactions sent via both the Substrate and Ethereum APIs using Substrate API Sidecar, a REST API service for interacting with blockchains built with the Substrate framework.</p> <p>The following code snippet uses the Axios HTTP client to query the Sidecar endpoint <code>/blocks/head</code> for the latest finalized block and then decodes the block for the <code>from</code>, <code>to</code>, <code>value</code>, <code>tx hash</code>, and <code>transaction status</code> of native token transfers at both the EVM and Substrate API level.</p> <pre><code>import axios from 'axios';\n\n// This script will decode all native token transfers (Substrate &amp; Ethereum) in a given Sidecar block, and extract the tx hash. It can be adapted for any Moonbeam network.\n\n// Endpoint to retrieve the latest block\nconst endpoint = 'http://127.0.0.1:8080/blocks/head';\n\nasync function main() {\n  try {\n    // Retrieve the block from the Sidecar endpoint\n    const response = await axios.get(endpoint);\n    // Retrieve the block height of the current block\n    console.log('Block Height: ' + response.data.number);\n\n    // Iterate through all extrinsics in the block\n    response.data.extrinsics.forEach((extrinsic) =&gt; {\n      // Retrieve Ethereum Transfers\n      if (\n        extrinsic.method.pallet === 'ethereum' &amp;&amp;\n        extrinsic.method.method === 'transact'\n      ) {\n        // Get the value for any of the three EIP transaction standards supported\n        const value =\n          (extrinsic.args.transaction.legacy &amp;&amp;\n            extrinsic.args.transaction.legacy.value) ||\n          (extrinsic.args.transaction.eip1559 &amp;&amp;\n            extrinsic.args.transaction.eip1559.value) ||\n          (extrinsic.args.transaction.eip2930 &amp;&amp;\n            extrinsic.args.transaction.eip2930.value);\n\n        // Iterate through the events to get transaction details\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'ethereum' &amp;&amp;\n            event.method.method === 'Executed'\n          ) {\n            console.log('From: ' + event.data[0]);\n            console.log('To: ' + event.data[1]);\n            console.log('Tx Hash: ' + event.data[2]);\n            console.log('Value: ' + value);\n            // Check the execution status\n            if (event.data[3].succeed) {\n              console.log('Status: Success');\n            } else {\n              console.log('Status: Failed');\n            }\n          }\n        });\n      }\n\n      // Retrieve Substrate Transfers\n      if (\n        extrinsic.method.pallet === 'balances' &amp;&amp;\n        (extrinsic.method.method === 'transferKeepAlive' ||\n          extrinsic.method.method === 'transferAllowDeath')\n      ) {\n        // Iterate through the events to get transaction details\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'balances' &amp;&amp;\n            event.method.method === 'Transfer'\n          ) {\n            console.log('From: ' + event.data[0]);\n            console.log('To: ' + event.data[1]);\n            console.log('Tx Hash: ' + extrinsic.hash);\n            console.log('Value: ' + event.data[2]);\n            // Check the execution status\n            if (extrinsic.success) {\n              console.log('Status: Success');\n            } else {\n              console.log('Status: Failed');\n            }\n          }\n        });\n      }\n    });\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nmain();\n</code></pre> <p>You can reference the Substrate API Sidecar page for information on installing and running your own Sidecar service instance, as well as more details on how to decode Sidecar blocks for Moonbeam transactions.</p>"},{"location":"learn/core-concepts/tx-fees/","title":"Calculating Transaction Fees on Moonbeam","text":""},{"location":"learn/core-concepts/tx-fees/#introduction","title":"Introduction","text":"<p>Similar to the Ethereum and Substrate APIs for sending transfers on Moonbeam, the Substrate and EVM layers on Moonbeam also have distinct transaction fee models that developers should be aware of when they need to calculate and keep track of transaction fees for their transactions.</p> <p>For starters, Ethereum transactions consume gas units based on their computational complexity and data storage requirements. On the other hand, Substrate transactions use the concept of \"weight\" to determine fees. In this guide, you'll learn how to calculate the transaction fees for both Substrate and Ethereum transactions. In terms of Ethereum transactions, you'll also learn about the key differences between how transaction fees are calculated on Moonbeam and Ethereum.</p>"},{"location":"learn/core-concepts/tx-fees/#key-differences-with-ethereum","title":"Key Differences with Ethereum","text":"<p>There are some key differences between the transaction fee model on Moonbeam and the one on Ethereum that developers should be mindful of when developing on Moonbeam:</p> <ul> <li> <p>The dynamic fee mechanism resembles that of EIP-1559 but the implementation is different</p> </li> <li> <p>The amount of gas used in Moonbeam's transaction fee model is mapped from the transaction's Substrate extrinsic <code>refTime</code> component of the transaction weight via a fixed factor of <code>25000</code> and <code>proofSize</code> component of the transaction weight via a fixed factor of <code>8</code>. The transaction weight vector is then multiplied with the unit gas price to calculate the transaction fee. This fee model means it can potentially be significantly cheaper to send transactions such as basic balance transfers via the Ethereum API than the Substrate API.</p> </li> <li> <p>The EVM is designed to solely have capacity for gas and Moonbeam requires additional metrics outside of gas. In particular, Moonbeam needs the ability to record proof size, which is the amount of storage required on Moonbeam for a relay chain validator to verify a state transition. When the capacity limit for proof size has been reached for the current block, which is 25% of the block limit, an \"Out of Gas\" error will be thrown. This can happen even if there is remaining legacy gas in the gasometer. This additional metric also impacts refunds. Refunds are based on the more consumed resource after the execution. In other words, if more proof size has been consumed proportionally than legacy gas, the refund will be calculated using proof size</p> </li> <li> <p>Moonbeam has implemented a new mechanism defined in MBIP-5 that limits block storage and increases gas usage for transactions that result in an increase in storage</p> </li> </ul>"},{"location":"learn/core-concepts/tx-fees/#overview-of-mbip-5","title":"Overview of MBIP-5","text":"<p>MBIP-5 introduced changes to Moonbeam's fee mechanism that account for storage growth on the network, which deviates from the way Ethereum handles fees. By raising the gas needed to execute transactions that increase chain state and by establishing a block storage limit, it controls storage growth.</p> <p>This impacts contract deployments that add to the chain state, transactions that create new storage entries, and precompiled contract calls that result in the creation of new accounts.</p> <p>The block storage limit prevents transactions in a single block from collectively increasing the storage state by more than the limit. The limit for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>160KB\n</code></pre> <pre><code>160KB\n</code></pre> <pre><code>160KB\n</code></pre> <p>To determine the amount of gas for storage in bytes, there is a ratio that is defined as:</p> <pre><code>Ratio = Block Gas Limit / (Block Storage Limit * 1024 Bytes)\n</code></pre> <p>The block gas limit for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>60,000,000\n</code></pre> <pre><code>60,000,000\n</code></pre> <pre><code>60,000,000\n</code></pre> <p>Knowing the block gas and storage limits, the ratio of gas to storage is computed as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>Ratio = 60000000 / (160 * 1024)\nRatio = 366 \n</code></pre> <pre><code>Ratio = 60000000 / (160 * 1024)\nRatio = 366 \n</code></pre> <pre><code>Ratio = 60000000 / (160 * 1024)\nRatio = 366 \n</code></pre> <p>Then, you can take the storage growth in bytes for a given transaction and multiply it by the gas-to-storage growth ratio to determine how many units of gas to add to the transaction. For example, if you execute a transaction that increases the storage by 500 bytes, the following calculation is used to determine the units of gas to add:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>Additional Gas = 500 * 366\nAdditional Gas = 183000\n</code></pre> <pre><code>Additional Gas = 500 * 366\nAdditional Gas = 183000\n</code></pre> <pre><code>Additional Gas = 500 * 366\nAdditional Gas = 183000\n</code></pre> <p>To see how this MBIP differentiates Moonbeam from Ethereum firsthand, you can estimate the gas for two different contract interactions on both networks: one that modifies an item in the chain state and one that doesn't. For example, you can use a greeting contract that allows you to store a name and then use the name to say \"Hello\".</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ncontract SayHello {\n    mapping(address =&gt; string) public addressToName;\n\n    constructor(string memory _name) {\n        addressToName[msg.sender] = _name;\n    }\n\n    // Store a name associated to the address of the sender\n    function setName(string memory _name) public {\n        addressToName[msg.sender] = _name;\n    } \n\n    // Use the name in storage associated to the sender\n    function sayHello() external view returns (string memory) {\n        return string(abi.encodePacked(\"Hello \", addressToName[msg.sender]));\n    }\n}\n</code></pre> <p>You can deploy this contract on both Moonriver and Ethereum, or on Moonbeam's TestNet, Moonbase Alpha, and Ethereum's TestNet, Sepolia. The above contract has already been deployed to Moonbase Alpha and Sepolia. You can feel free to access these contracts at the following addresses:</p> Moonbase AlphaSepolia <pre><code>0xDFF8E772A9B212dc4FbA19fa650B440C5c7fd7fd\n</code></pre> <pre><code>0x8D0C059d191011E90b963156569A8299d7fE777d\n</code></pre> <p>Next, you can use the <code>eth_estimateGas</code> method to check the gas estimate for calling the <code>setName</code> and <code>sayHello</code> functions on each network. To do so, you'll need the bytecode for each transaction, which includes the function selector, and for the <code>setName</code> function, the name to be set. This example bytecode sets the name to \"Chloe\":</p> Set NameSay Hello <pre><code>0xc47f00270000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000543686c6f65000000000000000000000000000000000000000000000000000000\n</code></pre> <pre><code>0xef5fb05b\n</code></pre> <p>Now, you can use the following curl commands on Moonbase Alpha to return the gas estimate:</p> Set NameSay Hello <pre><code>curl https://rpc.api.moonbase.moonbeam.network -H \"Content-Type:application/json;charset=utf-8\" -d \\\n'{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"eth_estimateGas\",\n    \"params\":[{\n        \"to\": \"0xDFF8E772A9B212dc4FbA19fa650B440C5c7fd7fd\",\n        \"data\": \"0xc47f00270000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000543686c6f65000000000000000000000000000000000000000000000000000000\"\n    }]\n}'\n</code></pre> <pre><code>curl https://rpc.api.moonbase.moonbeam.network -H \"Content-Type:application/json;charset=utf-8\" -d \\\n'{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"eth_estimateGas\",\n    \"params\":[{\n        \"to\": \"0xDFF8E772A9B212dc4FbA19fa650B440C5c7fd7fd\",\n        \"data\": \"0xef5fb05b\"\n    }]\n}'\n</code></pre> <p>Then on Sepolia, you can use the same bytecode for the <code>data</code> and modify the RPC URL and contract address to target the contract deployed to Sepolia:</p> Set NameSay Hello <pre><code>curl https://sepolia.publicgoods.network -H \"Content-Type:application/json;charset=utf-8\" -d \\\n'{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"eth_estimateGas\",\n    \"params\":[{\n        \"to\": \"0x8D0C059d191011E90b963156569A8299d7fE777d\",\n        \"data\": \"0xc47f00270000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000543686c6f65000000000000000000000000000000000000000000000000000000\"\n    }]\n}'\n</code></pre> <pre><code>curl https://sepolia.publicgoods.network -H \"Content-Type:application/json;charset=utf-8\" -d \\\n'{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"eth_estimateGas\",\n    \"params\":[{\n        \"to\": \"0x8D0C059d191011E90b963156569A8299d7fE777d\",\n        \"data\": \"0xef5fb05b\"\n    }]\n}'\n</code></pre> <p>At the time of writing, the gas estimates for both networks are as follows:</p> Moonbase AlphaSepolia Method Gas Estimate <code>setName</code> 45977 <code>sayHello</code> 25938 Method Gas Estimate <code>setName</code> 21520 <code>sayHello</code> 21064 <p>You'll see that on Sepolia, the gas estimates for both calls are very similar, whereas on Moonbase Alpha, there is a noticeable difference between the calls and that the <code>setName</code> call, which modifies the storage, uses more gas than the <code>sayHello</code> call.</p>"},{"location":"learn/core-concepts/tx-fees/#ethereum-api-transaction-fees","title":"Ethereum API Transaction Fees","text":"<p>To calculate the fee incurred on a Moonbeam transaction sent via the Ethereum API, the following formula can be used:</p> EIP-1559LegacyEIP-2930 <pre><code>GasPrice = BaseFee + MaxPriorityFeePerGas &lt; MaxFeePerGas ? \n            BaseFee + MaxPriorityFeePerGas : \n            MaxFeePerGas;\nTransaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <pre><code>Transaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <pre><code>Transaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <p>Note</p> <p>EIP-1559 transaction fees on Moonbeam are calculated using the previous block's base fee.</p> <p>The following sections describe in more detail each of the components needed to calculate the transaction fee.</p>"},{"location":"learn/core-concepts/tx-fees/#base-fee","title":"Base Fee","text":"<p>The <code>BaseFee</code> is the minimum amount charged to send a transaction and is a value set by the network itself. It was introduced in EIP-1559. Moonbeam has its own dynamic fee mechanism for calculating the base fee, which is adjusted based on block congestion. As of runtime 2300, the dynamic fee mechanism has been rolled out to all of the Moonbeam-based networks.</p> <p>The minimum gas price for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Minimum Gas Price 31.25 Gwei Variable Value Minimum Gas Price 0.3125 Gwei Variable Value Minimum Gas Price 0.03125 Gwei <p>To calculate the dynamic base fee, the following calculation is used:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>BaseFee = NextFeeMultiplier * 31250000000 / 10^18\n</code></pre> <pre><code>BaseFee = NextFeeMultiplier * 312500000 / 10^18\n</code></pre> <pre><code>BaseFee = NextFeeMultiplier * 31250000 / 10^18\n</code></pre> <p>The value of <code>NextFeeMultiplier</code> can be retrieved from the Substrate Sidecar API, via the following endpoint:</p> <pre><code>GET /pallets/transaction-payment/storage/nextFeeMultiplier?at={blockId}\n</code></pre> <p>The pallets endpoints for Sidecar returns data relevant to a pallet, such as data in a pallet's storage. You can read more about the pallets endpoint in the official Sidecar documentation. The data at hand that's required from storage is the <code>nextFeeMultiplier</code>, which can be found in the <code>transaction-payment</code> pallet. The stored <code>nextFeeMultiplier</code> value can be read directly from the Sidecar storage schema. Read as a JSON object, the relevant nesting structure is as follows:</p> <pre><code>RESPONSE JSON Storage Object:\n    |--at\n        |--hash\n        |--height\n    |--pallet\n    |--palletIndex\n    |--storageItem\n    |--keys\n    |--value\n</code></pre> <p>The relevant data will be stored in the <code>value</code> key of the JSON object. This value is a fixed point data type, hence the real value is found by dividing the <code>value</code> by <code>10^18</code>. This is why the calculation of <code>BaseFee</code> includes such an operation.</p>"},{"location":"learn/core-concepts/tx-fees/#gasprice-maxfeepergas-maxpriorityfeepergas","title":"GasPrice, MaxFeePerGas, and MaxPriorityFeePerGas","text":"<p>The <code>GasPrice</code> is used to specify the gas price of legacy transactions prior to EIP-1559. The <code>MaxFeePerGas</code> and <code>MaxPriorityFeePerGas</code> were both introduced in EIP-1559 alongside the <code>BaseFee</code>. The <code>MaxFeePerGas</code> defines the maximum fee permitted to be paid per unit of gas and is the sum of the <code>BaseFee</code> and the <code>MaxPriorityFeePerGas</code>. The <code>MaxPriorityFeePerGas</code> is the maximum priority fee configured by the sender of a transaction that is used to incentivize the prioritization of a transaction in a block.</p> <p>Although Moonbeam is Ethereum-compatible, it is also a Substrate-based chain at its core, and priorities work differently in Substrate than in Ethereum. In Substrate, transactions are not prioritized by gas price. To address this, Moonbeam uses a modified prioritization system that reprioritizes Substrate transactions using an Ethereum-first solution. A Substrate transaction still goes through the validity process, where it is assigned transaction tags, longevity, and a priority. The original priority is then overwritten with a new priority based on the transaction's fee per gas, which is derived from the transaction's tip and weight. If the transaction is an Ethereum transaction, the priority is set according to the priority fee.</p> <p>It's important to note that priority is not the sole component responsible for determining the order of transactions in a block. Other components, such as the longevity of a transaction, also play a role in the sorting process.</p> <p>The values of <code>GasPrice</code>, <code>MaxFeePerGas</code> and <code>MaxPriorityFeePerGas</code> for the applicable transaction types can be read from the block JSON object according to the structure described in the Sidecar API page.</p> <p>The data for an Ethereum transaction in a particular block can be extracted from the following block endpoint:</p> <pre><code>GET /blocks/{blockId}\n</code></pre> <p>The paths to the relevant values have also been truncated and reproduced below:</p> EIP1559LegacyEIP2930 EVM Field Block JSON Field MaxFeePerGas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas</code> MaxPriorityFeePerGas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas</code> EVM Field Block JSON Field GasPrice <code>extrinsics[extrinsic_number].args.transaction.legacy.gasPrice</code> EVM Field Block JSON Field GasPrice <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice</code>"},{"location":"learn/core-concepts/tx-fees/#transaction-weight","title":"Transaction Weight","text":"<p><code>TransactionWeight</code> is a Substrate mechanism used to measure the execution time a given transaction takes to be executed within a block. A transaction's weight is a vector of two components: <code>refTime</code> and <code>proofSize</code>. <code>refTime</code> refers to the amount of computational time that can be used for execution. <code>proofSize</code> refers to the size of the PoV (Proof of Validity) of the Moonbeam block that gets submitted to the Polkadot Relay Chain for validation. Since both <code>refTime</code> and <code>proofSize</code> are integral components of determining a weight, it is impossible to obtain an accurate weight value with just one of these values.</p> <p>For all transactions types, <code>TransactionWeight</code> can be retrieved under the event of the relevant extrinsic where the <code>method</code> field is set to:</p> <pre><code>pallet: \"system\", method: \"ExtrinsicSuccess\" \n</code></pre> <p>And then <code>TransactionWeight</code> is mapped to the following two fields of the block JSON object. <code>proofSize</code> is mapped as follows:</p> <pre><code>extrinsics[extrinsic_number].events[event_number].data[0].weight.proof_size \n</code></pre> <p>And <code>refTime</code> is mapped as follows:</p> <pre><code>extrinsics[extrinsic_number].events[event_number].data[0].weight.ref_time \n</code></pre>"},{"location":"learn/core-concepts/tx-fees/#eth-feehistory-endpoint","title":"Fee History Endpoint","text":"<p>Moonbeam networks implement the <code>eth_feeHistory</code> JSON-RPC endpoint as a part of the support for EIP-1559.</p> <p><code>eth_feeHistory</code> returns a collection of historical gas information from which you can reference and calculate what to set for the <code>MaxFeePerGas</code> and <code>MaxPriorityFeePerGas</code> fields when submitting EIP-1559 transactions.</p> <p>The following curl example will return the gas information of the last 10 blocks starting from the latest block on the respective Moonbeam network using <code>eth_feeHistory</code>:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>curl --location \\\n     --request POST 'INSERT_RPC_API_ENDPOINT' \\\n     --header 'Content-Type: application/json' \\\n     --data-raw '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"eth_feeHistory\",\n        \"params\": [\"0xa\", \"latest\"]\n     }'\n</code></pre> <pre><code>curl --location \\\n     --request POST 'INSERT_RPC_API_ENDPOINT' \\\n     --header 'Content-Type: application/json' \\\n     --data-raw '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"eth_feeHistory\",\n        \"params\": [\"0xa\", \"latest\"]\n     }'\n</code></pre> <pre><code>curl --location \\\n     --request POST 'https://rpc.api.moonbase.moonbeam.network' \\\n     --header 'Content-Type: application/json' \\\n     --data-raw '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"eth_feeHistory\",\n        \"params\": [\"0xa\", \"latest\"]\n     }'\n</code></pre> <pre><code>curl --location \\\n     --request POST 'http://127.0.0.1:9944' \\\n     --header 'Content-Type: application/json' \\\n     --data-raw '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"eth_feeHistory\",\n        \"params\": [\"0xa\", \"latest\"]\n     }'\n</code></pre>"},{"location":"learn/core-concepts/tx-fees/#sample-code","title":"Sample Code for Calculating Transaction Fees","text":"<p>The following code snippet uses the Axios HTTP client to query the Sidecar endpoint <code>/blocks/head</code> for the latest finalized block. It then calculates the transaction fees of all transactions in the block according to the transaction type (for Ethereum API: legacy, EIP-1559 or EIP-2930 standards, and for Substrate API), as well as calculating the total transaction fees in the block.</p> <p>Note</p> <p>EIP-1559 transaction fees on Moonbeam are calculated using the previous block's base fee.</p> <p>The following code sample is for demo purposes only and should not be used without modification and further testing in a production environment.</p> <p>You can use the following snippet for any Moonbeam-based network, but you'll need to modify the <code>baseFee</code> accordingly. You can refer back to the Base Fee section to get the calculation for each network.</p> <pre><code>import axios from 'axios';\n\n// This script calculates the transaction fees of all transactions in a block\n// according to the transaction type (for Ethereum API: legacy, EIP-1559 or\n// EIP-2930 standards, and Substrate API) using the dynamic fee mechanism.\n// It also calculates the total fees in the block\n\n// Endpoint to retrieve the latest block\nconst endpointBlock = 'http://127.0.0.1:8080/blocks/head';\n// Endpoint to retrieve the latest nextFeeMultiplier\nconst endpointPallet =\n  'http://127.0.0.1:8080/pallets/transaction-payment/storage/nextFeeMultiplier?at=';\n// Endpoint to retrieve the node client's information\nconst endpointNodeVersion = 'http://127.0.0.1:8080/node/version';\n\n// Define the minimum base fee for each network\nconst baseFee = {\n  moonbeam: 31250000000n,\n  moonriver: 312500000n,\n  moonbase: 31250000n,\n};\n\nasync function main() {\n  try {\n    // Create a variable to sum the transaction fees in the whole block\n    let totalFees = 0n;\n\n    // Find which Moonbeam network the Sidecar is pointing to\n    const responseClient = await axios.get(endpointNodeVersion);\n    const network = responseClient.data.clientImplName;\n\n    // Retrieve the block from the Sidecar endpoint\n    const responseBlock = await axios.get(endpointBlock);\n    // Retrieve the block height of the current block\n    console.log('Block Height: ' + responseBlock.data.number);\n\n    // Use the previous block's base fee to match the on-chain data\n    // Find the block's nextFeeMultiplier\n    const prevBlock = Number(responseBlock.data.number) - 1;\n    const responsePallet = await axios.get(endpointPallet + prevBlock);\n\n    // Iterate through all extrinsics in the block\n    responseBlock.data.extrinsics.forEach((extrinsic) =&gt; {\n      // Create an object to store transaction information\n      let transactionData = new Object();\n      // Set the network field\n      transactionData['network'] = network;\n\n      // Filter for Ethereum Transfers\n      if (\n        extrinsic.method.pallet === 'ethereum' &amp;&amp;\n        extrinsic.method.method === 'transact'\n      ) {\n        // Iterate through the events to get non type specific parameters\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'ethereum' &amp;&amp;\n            event.method.method === 'Executed'\n          ) {\n            // Get Transaction Hash\n            transactionData['hash'] = event.data[2];\n          }\n          if (\n            event.method.pallet === 'system' &amp;&amp;\n            event.method.method === 'ExtrinsicSuccess'\n          ) {\n            // Add correction weight if needed to Transaction Weight!\n            transactionData['weight'] = BigInt(event.data[0].weight.refTime);\n          }\n        });\n\n        // Get the transaction type and type specific parameters and compute the\n        // transaction fee\n        if (extrinsic.args.transaction.legacy) {\n          transactionData['txType'] = 'legacy';\n          transactionData['gasPrice'] = BigInt(\n            extrinsic.args.transaction.legacy.gasPrice\n          );\n          transactionData['txFee'] =\n            (transactionData['gasPrice'] * transactionData['weight']) / 25000n;\n        } else if (extrinsic.args.transaction.eip1559) {\n          transactionData['txType'] = 'eip1599';\n          transactionData['maxFeePerGas'] = BigInt(\n            extrinsic.args.transaction.eip1559.maxFeePerGas\n          );\n          transactionData['maxPriorityFeePerGas'] = BigInt(\n            extrinsic.args.transaction.eip1559.maxPriorityFeePerGas\n          );\n          // Update based on the network you're getting tx fees for\n          transactionData['baseFee'] =\n            (BigInt(responsePallet.data.value) * baseFee.moonbeam) /\n            BigInt('1000000000000000000');\n\n          // Gas price dependes on the MaxFeePerGas and MaxPriorityFeePerGas set\n          transactionData['gasPrice'] =\n            transactionData['baseFee'] +\n              transactionData['maxPriorityFeePerGas'] &lt;\n            transactionData['maxFeePerGas']\n              ? transactionData['baseFee'] +\n                transactionData['maxPriorityFeePerGas']\n              : transactionData['maxFeePerGas'];\n\n          transactionData['txFee'] =\n            (transactionData['gasPrice'] * transactionData['weight']) / 25000n;\n        } else if (extrinsic.args.transaction.eip2930) {\n          transactionData['txType'] = 'eip2930';\n          transactionData['gasPrice'] = BigInt(\n            extrinsic.args.transaction.eip2930.gasPrice\n          );\n          transactionData['txFee'] =\n            (transactionData['gasPrice'] * transactionData['weight']) / 25000n;\n        }\n\n        // Increment totalFees\n        totalFees += transactionData['txFee'];\n\n        // Display the tx information to console\n        console.log(transactionData);\n      }\n      // Filter for Substrate transactions, check if the extrinsic has a\n      // 'TransactionFeePaid' event\n      else {\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'transactionPayment' &amp;&amp;\n            event.method.method === 'TransactionFeePaid'\n          ) {\n            transactionData['txType'] = 'substrate';\n            transactionData['txFee'] = event.data[1];\n            transactionData['tip'] = event.data[1];\n          }\n          if (\n            event.method.pallet === 'system' &amp;&amp;\n            event.method.method === 'ExtrinsicSuccess'\n          ) {\n            transactionData['weight'] = event.data[0].weight.refTime;\n          }\n        });\n      }\n    });\n\n    // Output the total amount of fees in the block\n    console.log('Total fees in block: ' + totalFees);\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nmain();\n</code></pre>"},{"location":"learn/core-concepts/tx-fees/#substrate-api-transaction-fees","title":"Substrate API Transaction Fees","text":"<p>This section of the guide assumes you are interacting with Moonbeam blocks via the Substrate API Sidecar service. There are other ways of interacting with Moonbeam blocks, such as using the Polkadot.js API library. The logic is identical once the blocks are retrieved.</p> <p>You can reference the Substrate API Sidecar page for information on installing and running your own Sidecar service instance, as well as more details on how to decode Sidecar blocks for Moonbeam transactions.</p> <p>Note that the information in this section assumes you are running version 20.12.0 of the Substrate Sidecar REST API.</p> <p>All the information around fee data for transactions sent via the Substrate API can be extracted from the following block endpoint:</p> <pre><code>GET /blocks/{blockId}\n</code></pre> <p>The block endpoints will return data relevant to one or more blocks. You can read more about the block endpoints on the official Sidecar documentation. Read as a JSON object, the relevant nesting structure is as follows:  </p> <pre><code>RESPONSE JSON Block Object:\n    ...\n    |--number\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n            |--signature\n            |--nonce\n            |--args\n            |--tip           \n            |--hash\n            |--info\n            |--era\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"transactionPayment\"\n                        |--method: \"TransactionFeePaid\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n    ...\n</code></pre> <p>The object mappings are summarized as follows:</p> Tx Information Block JSON Field Fee paying account <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Total fees paid <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> Tip <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> <p>The transaction fee related information can be retrieved under the event of the relevant extrinsic where the <code>method</code> field is set to:</p> <pre><code>pallet: \"transactionPayment\", method: \"TransactionFeePaid\" \n</code></pre> <p>And then the total transaction fee paid for this extrinsic is mapped to the following field of the block JSON object:</p> <pre><code>extrinsics[extrinsic_number].events[event_number].data[1]\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"learn/core-concepts/unified-accounts/","title":"Unified Accounts","text":""},{"location":"learn/core-concepts/unified-accounts/#introduction","title":"Introduction","text":"<p>As Moonbeam is designed to be an Ethereum-compatible parachain on Polkadot, the underlying account system replaces the default Substrate-style accounts and keys with Ethereum-style accounts and keys. As a result, you can interact with your Moonbeam account using MetaMask and Ethereum tools you may already be familiar with, such as Remix and Hardhat.</p> <p>You can also interact with your Moonbeam account using Polkadot.js Apps as it natively supports H160 addresses and ECDSA keys. For more information on this integration, you can check out the Interacting with Moonbeam Using Polkadot.js Apps guide.</p>"},{"location":"learn/core-concepts/unified-accounts/#substrate-evm-compatible-blockchain","title":"Substrate EVM Compatible Blockchain","text":"<p>Any parachain in the Polkadot ecosystem can offer a full EVM implementation, which provides the possibility of executing Solidity-based smart contracts with minimal to no changes. Substrate makes this integration possible - just plug the EVM pallet into your runtime for EVM support, and the Ethereum Pallet with Frontier to have Ethereum RPC compatibility. The availability of these open-source modules that Moonbeam has developed with Parity has led multiple parachains to offer Ethereum compatibility on their chains.</p> <p>But there is an important catch. With the configuration described above, a user, for example, Alice, can have an Ethereum-style address (H160 format), which is 40+2 hex-characters long, in a Substrate based chain. This address matches a private key, which can be used to sign transactions in the Ethereum side of the chain. Furthermore, the address is mapped into a storage slot inside the Substrate Balance pallet to a Substrate-style address (H256 format).</p> <p>However, Alice only knows the private key of the H160 address, and not of the mapped version. Therefore, she is unable to send transactions with her H256 address and is limited only to do read-only operations through Substrate\u2019s API. As a consequence, Alice needs another H256 address matching a different private key to be able to operate in the Substrate side of the chain, which include, among others, staking, balances, and governance.</p> <p>The following diagram illustrates this configuration.</p> <p></p> <p>This can creates friction and a poor user experience for Alice. First, she has to move tokens to her H160 mapped H256 address to be able to make transactions and deploy contracts through the EVM. Second, she also needs to hold a balance in her other H256 address (which she has a different private key for) to use Substrate-based features. So in short, Alice needs a minimum of two private keys to have the best of both worlds.</p>"},{"location":"learn/core-concepts/unified-accounts/#moonbeam-unified-accounts","title":"Moonbeam Unified Accounts","text":"<p>Moonbeam\u2019s focus is to create a fully Ethereum-compatible environment on Polkadot with the best user experience possible. This extends beyond the base Ethereum feature set, with additional features such as on-chain governance, staking, and cross-chain integrations.</p> <p>With unified accounts, a user, for example, Bob, will only need a single H160 address, with its corresponding private key, to do everything we mentioned above, including both EVM and Substrate functions.</p> <p>The diagram for this new configuration looks as follows.</p> <p></p> <p>That is it, Bob only holds one private key that matches one address. He does not need to move balances between 2 different accounts and is able to access all the features with a single account and private key. We have standardized this single account to conform to the Ethereum-style H160 address and ECDSA key standards.</p>"},{"location":"learn/features/eth-compatibility/","title":"Ethereum Compatibility","text":"<p>Moonbeam bridges the Ethereum and Polkadot ecosystems, offering developers the familiarity of Ethereum's tooling and infrastructure while leveraging Polkadot's scalability and interoperability.</p> <p>This documentation overviews Moonbeam's Ethereum compatibility features and highlights its key components. It also covers some critical differences between Moonbeam and Ethereum so Ethereum developers know what to expect.</p>"},{"location":"learn/features/eth-compatibility/#key-components","title":"Key Components","text":""},{"location":"learn/features/eth-compatibility/#evm","title":"EVM Compatibility","text":"<p>Moonbeam incorporates a fully compatible EVM to execute smart contracts in Solidity or other EVM-compatible languages. This enables developers to deploy existing Ethereum smart contracts on Moonbeam with minimal modifications.</p>"},{"location":"learn/features/eth-compatibility/#ethereum-style-accounts","title":"Ethereum-style Accounts","text":"<p>Moonbeam employs H160 Ethereum-style accounts and ECDSA keys, ensuring compatibility with existing Ethereum wallets and facilitating a smooth end-user experience. This is possible due to Moonbeam's unified accounts system, which modifies the underlying Substrate account system to use Ethereum accounts by default.</p> <p>Learn more:</p> <ul> <li>Moonbeam's unified accounts system</li> </ul>"},{"location":"learn/features/eth-compatibility/#json-rpc-support","title":"JSON-RPC Support","text":"<p>Moonbeam offers full JSON-RPC compatibility with Ethereum, allowing developers to interact with Moonbeam nodes using familiar Ethereum tools and libraries. This compatibility extends to methods for account management, transaction submission, smart contract deployment, and event monitoring.</p> <p>In addition to standard Ethereum RPC methods, Moonbeam supports non-standard Debug and Trace modules, providing developers with enhanced debugging and tracing capabilities for smart contract execution. The Debug module allows developers to inspect internal state transitions and execution traces, enabling efficient debugging of complex smart contracts. The Trace module provides detailed transaction traces, including opcode-level execution information and gas consumption, facilitating performance analysis and optimization.</p> <p>Learn more:</p> <ul> <li>Supported Ethereum RPC methods</li> <li>Subscribe to events with Ethereum JSON-RPC methods</li> <li>Debug and trace transactions with non-standard RPC methods</li> </ul>"},{"location":"learn/features/eth-compatibility/#ethereum-dev-tools","title":"Ethereum Developer Tools and Libraries","text":"<p>With the underlying support for Ethereum JSON-RPC methods, Moonbeam leverages Ethereum's rich ecosystem of developer libraries and environments. With seamless integration of popular Ethereum libraries and development environments, developers can leverage their existing knowledge and tooling to build and deploy decentralized applications (DApps) on Moonbeam.</p> <p>Learn more:</p> <ul> <li>Ethereum libraries</li> <li>Ethereum development environments</li> </ul>"},{"location":"learn/features/eth-compatibility/#precompiled-contracts","title":"Precompiled Contracts","text":"<p>Moonbeam provides precompiled contracts that allow Ethereum smart contracts to seamlessly access Substrate functionality. These precompiled contracts expose Substrate features such as on-chain governance, staking, and identity management to Ethereum-based DApps on Moonbeam. This integration ensures that Ethereum developers can harness the full potential of Moonbeam's features, expanding the possibilities for dApp development on Moonbeam.</p> <p>In addition, developers can leverage Ethereum MainNet precompiles seamlessly within their smart contracts on Moonbeam. These precompiled contracts, widely used on the Ethereum network, offer optimized and efficient execution of common cryptographic operations and complex computations. By supporting Ethereum MainNet precompiles, Moonbeam ensures compatibility with Ethereum-based dApps while enabling developers to utilize familiar tools and libraries to build on its platform.</p> <p>Learn more:</p> <ul> <li>Overview of the precompiled contracts on Moonbeam</li> </ul>"},{"location":"learn/features/eth-compatibility/#ethereum-token-standards","title":"Ethereum Token Standards","text":"<p>Moonbeam supports Ethereum token standards, allowing developers to deploy and interact with tokens that adhere to popular standards such as ERC-20, ERC-721, and ERC-1155. By supporting these standards, Moonbeam enables developers to deploy existing Ethereum tokens without modification.</p> <p>Due to Moonbeam's native interoperability, ERC-20s can be sent cross-chain to other chains within the Polkadot ecosystem via Cross-Consensus Messaging (XCM).</p> <p>Learn more:</p> <ul> <li>XCM-enabled ERC-20s (also referred to as local XC-20s)</li> </ul>"},{"location":"learn/features/eth-compatibility/#key-differences","title":"Key Differences","text":""},{"location":"learn/features/eth-compatibility/#consensus-mechanisms","title":"Consensus Mechanisms","text":"<p>Moonbeam uses a Delegated Proof-of-Stake (DPoS) consensus mechanism, where token holders in the network can delegate candidates to become block producers, known as collators. On the other hand, Ethereum uses a Proof-of-Stake (PoS) system in which validators are selected based on their stake in the network to produce and validate blocks.</p> <p>Learn more:</p> <ul> <li>Differences between PoS and DPoS</li> </ul>"},{"location":"learn/features/eth-compatibility/#finality","title":"Finality","text":"<p>Moonbeam and Ethereum have different finality processes. On Ethereum, there is a checkpoint system where validators determine finality at checkpoint blocks, which takes at least 6.4 minutes for a block to be finalized. Moonbeam relies on Polkadot's GRANDPA finality gadget, which expedites finality by completing the process parallel to block production and allowing relay chain validators to vote on the highest block, finalizing all blocks leading up to that block.</p> <p>Learn more:</p> <ul> <li>Consensus and finality on Moonbeam</li> </ul>"},{"location":"learn/features/eth-compatibility/#proxy-accounts","title":"Proxy Accounts","text":"<p>On both Moonbeam and Ethereum, accounts can be controlled by two main types of accounts: Externally Owned Accounts (EOA) or smart contracts. However, on Moonbeam, within both account types, there are also proxy accounts, which can perform a limited number of actions on behalf of another account.</p> <p>Learn more:</p> <ul> <li>An overview of proxy accounts</li> <li>How to set up a proxy account</li> </ul>"},{"location":"learn/features/eth-compatibility/#account-balances","title":"Account Balances","text":"<p>Balances on Ethereum are fairly straightforward; if an account holds tokens, that account has a token balance. On Moonbeam, different balance types exist to support various Substrate functionality. There are five types: free, reducible, reserved, miscellaneous frozen, and fee frozen. When using Ethereum tools, accounts show the reducible balance and don't include locked or frozen balances.</p> <p>Learn more:</p> <ul> <li>Moonbeam account balances</li> </ul>"},{"location":"learn/features/eth-compatibility/#balance-transfers","title":"Balance Transfers","text":"<p>Since Moonbeam is a Substrate-based chain, balance transfers of the native asset (GLMR, MOVR, and DEV) can occur through the Ethereum and Substrate APIs. Like Ethereum, transfers sent through the Ethereum API rely on the <code>eth_sendRawTransaction</code>. Transfers sent through the Substrate API are done using the Balances Pallet, a built-in module in the Substrate framework that provides functionality for managing accounts and balances.</p> <p>Learn more:</p> <ul> <li>Balance transfers on Moonbeam</li> </ul>"},{"location":"learn/features/eth-compatibility/#transaction-fees","title":"Transaction Fees","text":"<p>Moonbeam and Ethereum calculate transaction fees differently due to variations in their underlying architectures and consensus mechanisms. The fundamental difference in how transaction fees are calculated is that Ethereum uses a gas-based fee system, and Moonbeam uses a weight-based system that maps to the gas used. Moonbeam also implements additional metrics in the underlying gas calculations, including proof size and storage costs.</p> <p>Learn more:</p> <ul> <li>Calculating transaction fees on Moonbeam</li> </ul>"},{"location":"learn/features/governance/","title":"Governance on Moonbeam","text":""},{"location":"learn/features/governance/#introduction","title":"Introduction","text":"<p>The goal of Moonbeam\u2019s governance mechanism is to advance the protocol according to the desires of the community. In that shared mission, the governance process seeks to include all token holders. Any and all changes to the protocol must go through a referendum so that all token holders, weighted by stake, can have input on the decision.</p> <p>Governance forums like the Moonbeam Community Forum and Polkassembly enable open discussion and allow proposals to be refined based on community input. Autonomous enactments and forkless upgrades unite the community towards a shared mission to advance the protocol.</p> <p>With the rollout of OpenGov (originally referred to as Gov2), the second phase of governance in Polkadot, several modifications have been introduced to the governance process. You can read the OpenGov: What is Polkadot Gov2 blog post, which provides an overview of all of the changes made in OpenGov.</p> <p>As of runtime 2400, all Moonbeam networks use OpenGov as their governance system.</p>"},{"location":"learn/features/governance/#principles","title":"Principles","text":"<p>Guiding \"soft\" principles for engagement with Moonbeam's governance process include:</p> <ul> <li>Being inclusive to token holders that want to engage with Moonbeam and that are affected by governance decisions</li> <li>Favoring token holder engagement, even with views contrary to our own, versus a lack of engagement</li> <li>A commitment to openness and transparency in the decision-making process</li> <li>Working to keep the greater good of the network above personal gain</li> <li>Acting at all times as a moral agent that considers the consequences of action (or inaction) from a moral standpoint</li> <li>Being patient and generous in our interactions with other token holders, but not tolerating abusive or destructive language, actions, and behavior, and abiding by Moonbeam\u2019s Code of Conduct</li> </ul> <p>These points were heavily inspired by Vlad Zamfir\u2019s writings on governance. Refer to his articles, especially the How to Participate in Blockchain Governance in Good Faith (and with Good Manners) Medium article.</p>"},{"location":"learn/features/governance/#on-chain-governance-mechanics","title":"On-Chain Governance Mechanics","text":"<p>The \"hard\" governance process for Moonbeam will be driven by an on-chain process that allows the majority of tokens on the network to determine the outcomes of key decisions around the network. These decision points come in the form of stake-weighted voting on proposed referenda.</p> <p>Some of the main components of this governance model include:</p> <ul> <li>Referenda \u2014 a stake-based voting scheme where each referendum is tied to a specific proposal for a change to the Moonbeam system including values for key parameters, code upgrades, or changes to the governance system itself</li> <li>Voting \u2014 referenda will be voted on by token holders on a stake-weighted basis. Referenda which pass are subject to delayed enactment so that people who disagree with the direction of the decision have time to exit the network</li> <li>Council &amp; Technical Committee Governance V1 \u2014 a group of community members who have special voting rights within the system. With the deprecation and removal of Governance v1, both of these committees were dissolved as of the runtime 2800 release</li> <li>OpenGov Technical Committee \u2014 a group of community members who can add certain proposals to the Whitelisted Track</li> </ul> <p>For more details on how these Substrate frame pallets implement on-chain governance, you can check out the Polkadot Governance Wiki.</p>"},{"location":"learn/features/governance/#opengov","title":"Governance v2: OpenGov","text":"<p>This section will cover everything you need to know about OpenGov on Moonbeam.</p>"},{"location":"learn/features/governance/#general-definitions-gov2","title":"General Definitions","text":"<ul> <li>Proposal \u2014 an action or item, defined by the preimage hash, being proposed by a token holder and open for consideration and discussion by token holders</li> <li> <p>Referendum \u2014 a proposal that is up for token-holder voting. Each referendum is tied to a specific proposal for a change to the Moonbeam system including values for key parameters, code upgrades, or changes to the governance system itself</p> </li> <li> <p>Preimage hash \u2014 hash of the proposal to be enacted. The first step to make a proposal is to submit a preimage. The hash is just its identifier. The proposer of the preimage can be different than the user that proposes that preimage as a formal proposal</p> </li> <li> <p>Preimage deposit \u2014 amount of tokens that the proposer needs to bond when submitting a preimage. It is calculated as the sum of a base deposit per network plus a fee per byte of the preimage being proposed</p> </li> <li> <p>Origin - an authorization-based dispatch source for an operation, which is used to determine the Track that a referendum is posted under</p> </li> <li> <p>Track - an Origin-specific pipeline that outlines the life cycle of proposals. Currently, there are five Tracks:</p> Origin Track Description Referendum Examples Root Highest privilege Runtime upgrades, Technical Committee management Whitelisted Proposals to be whitelisted by the Technical Committee before being dispatched Fast-tracked operations General Admin For general on-chain decisions Changes to XCM fees, Orbiter program, Staking parameters, Registrars Emergency Canceller For cancellation of a referendum. Decision Deposit is refunded Wrongly constructed referendum Emergency Killer For killing of bad/malicious referendum. Decision Deposit is slashed Malicious referendum Fast General Admin For faster general on-chain decisions HRMP channel management </li> </ul> <p>Tracks have different criteria parameters that are proportional to their level of Origin class. For example, more dangerous and privileged referenda will have more safeguards, higher thresholds, and longer consideration periods for approval. Please refer to the Governance Parameters section for more information.</p> <ul> <li> <p>Voting \u2014 a mechanism for token holders to support (Aye), oppose (Nay), or remain neutral (Abstain) on a proposal. For Aye and Nay, the voting weight is determined by both the number of tokens locked and the lock duration (Conviction). Abstain votes do not receive additional weighting</p> <ul> <li>Conviction \u2014 the time that token holders voluntarily lock their tokens when voting; the longer they are locked, the more weight their vote has</li> <li>Lock balance \u2014 the number of tokens that a user commits to a vote (note, this is not the same as a user's total account balance) Moonbeam uses the concept of voluntary locking, which allows token holders to increase their voting power by locking tokens for a longer period of time. Specifying no Lock Period means a user's vote is valued at 10% of their lock balance. Specifying a greater Conviction increases voting power. For each increase in Conviction (vote multiplier), the Lock Periods double</li> </ul> </li> <li> <p>Approval \u2014 minimum \"Aye\" votes as a percentage of overall Conviction-weighted votes needed for approval</p> </li> <li> <p>Support \u2014 the minimum portion of Aye and Abstain votes (ignoring conviction) needed as a percentage of the total active supply for a proposal to pass. Nay votes do not count toward Support</p> </li> <li> <p>Lead-in Period \u2014 the initial proposal voting and discussion period. At this stage, proposals are in an undecided state until they pass some criteria for the given Track. The criteria include:</p> <ul> <li>Prepare Period \u2014 the minimum time the referendum needs to wait before it can progress to the next phase after submission</li> <li>Capacity \u2014 limit for the number of referenda on a given Track that can be decided at once</li> <li>Decision Deposit \u2014 the minimum deposit amount required for a referendum to progress to the decision phase after the end of the Lead-in Period. Since each Track has a defined Capacity, this deposit is larger than the submission deposit, and its goal is to mitigate spam </li> </ul> </li> <li> <p>Decide Period - token holders continue to vote on the referendum. If a referendum does not pass by the end of the period, it will be rejected, and the Decision Deposit will be refunded</p> </li> <li>Confirm Period - a period of time within the Decide Period where the referendum needs to have maintained enough Approval and Support to be approved and move to the Enactment Period</li> <li> <p>Enactment Period - a specified time, which is defined at the time the proposal was created, that an approved referendum waits before it can be dispatched. There is a minimum amount of time for each Track</p> </li> <li> <p>Vote Delegation \u2014 a voter can give their voting power, including Conviction voting, to another token holder (delegate), who may be more knowledgeable and able to make specific decisions</p> </li> <li>Multirole Delegation \u2014 the ability to delegate voting power on a Track-by-Track basis, where a token holder can specify different delegates for each Track</li> </ul>"},{"location":"learn/features/governance/#governance-parameters-v2","title":"Governance Parameters","text":"MoonbeamMoonriverMoonbase Alpha Variable Value Preimage base deposit 500 GLMR Preimage deposit per byte 0.01 GLMR Proposal Submission Deposit 1000 GLMR Variable Value Preimage base deposit 5 MOVR Preimage deposit per byte 0.0001 MOVR Proposal Submission Deposit 10 MOVR Variable Value Preimage base deposit 5 DEV Preimage deposit per byte 0.0001 DEV Proposal Submission Deposit 10 DEV"},{"location":"learn/features/governance/#general-parameters-by-track","title":"General Parameters by Track","text":"MoonbeamMoonriverMoonbase Alpha Track Track ID Capacity DecisionDeposit Root 0 5 proposals 2000000 GLMR Whitelisted 1 100 proposals 200000 GLMR General Admin 2 10 proposals 10000 GLMR EmergencyCanceller 3 20 proposals 200000 GLMR EmergencyKiller 4 100 proposals 400000 GLMR Fast General Admin 5 10 proposals 10000 GLMR Track Track ID Capacity DecisionDeposit Root 0 5 proposals 100000 MOVR Whitelisted 1 100 proposals 10000 MOVR General Admin 2 10 proposals 500 MOVR EmergencyCanceller 3 20 proposals 10000 MOVR EmergencyKiller 4 100 proposals 20000 MOVR Fast General Admin 5 10 proposals 500 MOVR Track Track ID Capacity DecisionDeposit Root 0 5 proposals 100000 DEV Whitelisted 1 100 proposals 10000 DEV General Admin 2 10 proposals 500 DEV EmergencyCanceller 3 20 proposals 10000 DEV EmergencyKiller 4 100 proposals 20000 DEV Fast General Admin 5 10 proposals 500 DEV"},{"location":"learn/features/governance/#period-parameters-by-track","title":"Period Parameters by Track","text":"MoonbeamMoonriverMoonbase Alpha Track PreparePeriod DecidePeriod ConfirmPeriod MinimumEnactment Period Root 14400 blocks (1 day) 201600 blocks (14 days) 14400 blocks (1 day) 14400 blocks (1 day) Whitelisted 100 blocks (10 minutes) 201600 blocks (14 days) 100 blocks (10 minutes) 300 blocks (30 minutes) General Admin 600 blocks (1 hour) 201600 blocks (14 days) 14400 blocks (1 day) 14400 blocks (1 day) EmergencyCanceller 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) EmergencyKiller 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) Fast General Admin 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) Track PreparePeriod DecidePeriod ConfirmPeriod MinimumEnactment Period Root 14400 blocks (1 day) 201600 blocks (14 days) 14400 blocks (1 day) 14400 blocks (1 day) Whitelisted 100 blocks (10 minutes) 201600 blocks (14 days) 100 blocks (10 minutes) 300 blocks (30 minutes) General Admin 600 blocks (1 hour) 201600 blocks (14 days) 14400 blocks (1 day) 14400 blocks (1 day) EmergencyCanceller 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) EmergencyKiller 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) Fast General Admin 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) Track PreparePeriod DecidePeriod ConfirmPeriod MinimumEnactment Period Root 14400 blocks (1 day) 201600 blocks (14 days) 14400 blocks (1 day) 14400 blocks (1 day) Whitelisted 100 blocks (10 minutes) 201600 blocks (14 days) 100 blocks (10 minutes) 300 blocks (30 minutes) General Admin 600 blocks (1 hour) 201600 blocks (14 days) 14400 blocks (1 day) 14400 blocks (1 day) EmergencyCanceller 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) EmergencyKiller 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) Fast General Admin 600 blocks (1 hour) 201600 blocks (14 days) 1800 blocks (3 hours) 100 blocks (10 minutes) <p>Note</p> <p>As of runtime 3000, asynchronous backing has been enabled on all Moonbeam networks. As a result, the target block time was reduced from 12 seconds to 6 seconds, which may break some timing-based assumptions.</p>"},{"location":"learn/features/governance/#support-and-approval-parameters-by-track","title":"Support and Approval Parameters by Track","text":"MoonbeamMoonriverMoonbase Alpha Track Approval Curve Approval Parameters Support Curve Support Parameters Root Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Linear Day 0: 25%Day 14: 0.5% Whitelisted Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 2%Hour 1: 1%Day 14: 0% General Admin Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Reciprocal Day 0: 50%Day 7: 10%Day 14: 0% EmergencyCanceller Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 10%Day 1: 1%Day 14: 0% EmergencyKiller Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 10%Day 1: 1%Day 14: 0% Fast General Admin Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Reciprocal Day 0: 50%Day 5: 1%Day 14: 0% Track Approval Curve Approval Parameters Support Curve Support Parameters Root Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Linear Day 0: 25%Day 14: 0.5% Whitelisted Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 2%Hour 1: 1%Day 14: 0% General Admin Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Reciprocal Day 0: 50%Day 7: 10%Day 14: 0% EmergencyCanceller Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 10%Day 1: 1%Day 14: 0% EmergencyKiller Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 10%Day 1: 1%Day 14: 0% Fast General Admin Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Reciprocal Day 0: 50%Day 5: 1%Day 14: 0% Track Approval Curve Approval Parameters Support Curve Support Parameters Root Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Linear Day 0: 25%Day 14: 0.5% Whitelisted Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 2%Hour 1: 1%Day 14: 0% General Admin Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Reciprocal Day 0: 50%Day 7: 10%Day 14: 0% EmergencyCanceller Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 50%Day 1: 1%Day 14: 0% EmergencyKiller Reciprocal Day 0: 100%Day 1: 96%Day 14: 50% Reciprocal Day 0: 10%Day 1: 1%Day 14: 0% Fast General Admin Reciprocal Day 0: 100%Day 4: 80%Day 14: 50% Reciprocal Day 0: 50%Day 5: 1%Day 14: 0%"},{"location":"learn/features/governance/#conviction-multiplier-v2","title":"Conviction Multiplier","text":"<p>The Conviction multiplier is related to the number of Enactment Periods the tokens will be locked for after the referenda is enacted (if approved). Consequently, the longer you are willing to lock your tokens, the stronger your vote will be weighted. You also have the option of not locking tokens at all, but vote weight is drastically reduced (tokens are still locked during the duration of the referendum).</p> <p>If you were to vote 1000 tokens with a 6x Conviction, your weighted vote would be 6000 units. That is, 1000 locked tokens multiplied by the Conviction, which in this scenario would be 6. On the other hand, if you decided you didn't want to have your tokens locked after enactment, you could vote your 1000 tokens with a 0.1x Conviction. In this case, your weighted vote would only be 100 units.</p> <p>The Conviction multiplier values for each network are:</p> MoonbeamMoonriverMoonbase Alpha Lock Periods After Enactment Conviction Multiplier Approx. Lock Time 0 0.1 None 1 1 1 day 2 2 2 days 4 3 4 days 8 4 8 days 16 5 16 days 32 6 32 days Lock Periods After Enactment Conviction Multiplier Approx. Lock Time 0 0.1 None 1 1 1 day 2 2 2 days 4 3 4 days 8 4 8 days 16 5 16 days 32 6 32 days Lock Periods After Enactment Conviction Multiplier Approx. Lock Time 0 0.1 None 1 1 1 day 2 2 2 days 4 3 4 days 8 4 8 days 16 5 16 days 32 6 32 days <p>Note</p> <p>The lock time approximations are based upon regular 6-second block times. Block production may vary and thus the displayed lock times should not be deemed exact.</p>"},{"location":"learn/features/governance/#roadmap-of-a-proposal-v2","title":"Roadmap of a Proposal","text":"<p>Before a proposal is submitted, the author of the proposal can submit their proposal idea to the designated Democracy Proposals section of the Moonbeam Governance discussion forum for feedback from the community for at least five days. From there, the author can make adjustments to the proposal based on the feedback they've collected.</p> <p>Once the author is ready, they can submit their proposal on-chain. To do so, first, they need to submit the preimage of the proposal. The submitter needs to bond a fee to store the preimage on-chain. The bond is returned once the submitter unnotes the preimage. Next, they can submit the actual proposal and pay the Submission Deposit, which is enough to cover the on-chain storage cost of the proposal. Then the Lead-in Period begins and the community can begin voting \"Aye\" or \"Nay\" on the proposal by locking tokens. In order for the referendum to advance and move out of the Lead-in Period to the Decide period, the following criteria must be met:</p> <ul> <li>The referendum must wait the duration of the Prepare Period, which allows for adequate time to discuss the proposal before it progresses to the next phase</li> <li>There is enough Capacity in the chosen Track</li> <li>A Decision Deposit has been made that meets the minimum requirements for the Track</li> </ul> <p>If a referendum meets the above criteria, it moves to the Decide Period and takes up one of the spots in its designated Track. In the Decide Period, voting continues and the referendum has a set amount of days to reach the Approval and Support requirements needed for it to progress to the Confirm Period.</p> <p>Once in the Confirm Period, a referendum must continuously meet the Approval and Support requirements for the duration of the period. If a referendum fails to meet the requirements at any point, it is returned to the Decide Period. If the referendum meets the Approval and Support requirements again, it can progress to the Confirm Period again and the Decide Period will be delayed until the end of the Confirm Period. If the Decide Period ends and not enough Approval and Support was received, the referendum will be rejected and the Decision Deposit will be returned. The proposal can be proposed again at any time.</p> <p>If a referendum continuously receives enough Approval and Support during the Confirm Period, it will be approved and move to the Enactment Period. It will wait the duration of the Enactment Period before it gets dispatched.</p> <p>The happy path for a proposal is shown in the following diagram:</p> <p></p>"},{"location":"learn/features/governance/#proposal-example-walkthrough","title":"Proposal Example Walkthrough","text":"<p>A proposal (with its preimage) is submitted for the General Admin Track on Moonriver would have the following characteristics:</p> <ul> <li>The Approval curve starts at 100% on Day 0, goes to 80% on Day 4</li> <li>The Support curve starts at 50% on Day 0, goes to 10% on Day 7</li> <li>A referendum starts the Decide Period with 0% \"Aye\" votes (nobody voted in the Lead-in Period)</li> <li>Token holders begin to vote and the Approval increases to a value above 80% by Day 4</li> <li>If the Approval and Support thresholds are met for the duration of the Confirm Period (14400 blocks, approximately 1 day), the referendum is approved</li> <li>If the Approval and Support thresholds are not met during the Decision Period, the proposal is rejected. Note that the thresholds need to be met for the duration of the Confirm Period. Consequently, if they are met but the Decision Period expires before the completion of the Confirm Period, the proposal is rejected</li> </ul> <p>The Approval and Support percentages can be calculated using the following:</p> ApprovalSupport <pre><code>Approval = 100 * ( Total Conviction-weighted \"Aye\" votes / Total Conviction-weighted votes ) \n</code></pre> <pre><code>Support = 100 * ( Total Aye + Abstain votes, ignoring conviction / Total supply )\n</code></pre>"},{"location":"learn/features/governance/#proposal-cancellations","title":"Proposal Cancellations","text":"<p>In the event that a proposal already in the voting stage is found to have an issue, it may be necessary to prevent its approval. These instances may involve malicious activity or technical issues that make the changes impossible to implement due to recent upgrades to the network.</p> <p>Cancellations must be voted on by the network to be executed. Cancellation proposals are faster than a typical proposal because they must be decided before the enactment of the proposal they seek to cancel, but they follow the same process as other referenda.</p> <p>There is a cancellation Origin for use against referenda that contain an unforeseen problem, called the Emergency Canceller. The Emergency Canceller Origin and the Root Origin are allowed to cancel referenda. Regardless of the Origin, if a proposal is cancelled, it gets rejected and the Decision Deposit gets refunded.</p> <p>In addition, there is a Kill Origin, which is for bad referenda intending to harm the network, called Emergency Killer. The Emergency Killer Origin and the Root Origin have the ability to kill referenda. In this case, a proposal is cancelled and the Decision Deposit is slashed, meaning the deposit amount is burned regardless of the Origin.</p>"},{"location":"learn/features/governance/#rights-of-the-opengov-technical-committee","title":"Rights of the OpenGov Technical Committee","text":"<p>On Polkadot, the Technical Committee from Governance v1 was replaced by the Fellowship, a self-governing expert body composed of members with deep technical knowledge of the Kusama and Polkadot networks protocols.</p> <p>For Moonbeam's implementation of OpenGov, instead of the Fellowship, there is a community OpenGov Technical Committee that has very similar power to that of the Fellowship. Their power in governance resides in their ability to whitelist a proposal. OpenGov Technical Committee members may only vote to whitelist a proposal if whitelisting that proposal would protect against a security vulnerability to the network. The passing threshold of the OpenGov Technical Committee members on whether to whitelist a proposal is determined by governance. As such, the OpenGov Technical Committee has very limited power over the network. Its purpose is to provide technical review of urgent security issues that are proposed by token holders.</p> <p>While still subject to governance, the idea behind the Whitelist track is that it will have different parameters to make it faster for proposals to pass. The Whitelist Track parameters, including approval, support, and voting, are determined by the Moonriver or Moonbeam token holders through governance and cannot be changed by the OpenGov Technical Committee.</p> <p>The OpenGov Technical Committee is made up of members of the community who have technical knowledge and expertise in Moonbeam-based networks.</p>"},{"location":"learn/features/governance/#try-it-out","title":"Related Guides on OpenGov","text":"<p>For related guides on submitting and voting on referenda on Moonbeam with OpenGov, please check the following guides:</p> <ul> <li>How to Submit a Proposal</li> <li>How to Vote on a Proposal</li> <li>Interact with the Preimages Precompiled Contract (Solidity Interface)</li> <li>Interact with the Referenda Precompiled Contract (Solidity Interface)</li> <li>Interact with the Conviction Voting Precompiled Contract (Solidity Interface)</li> </ul>"},{"location":"learn/features/randomness/","title":"Randomness on Moonbeam","text":""},{"location":"learn/features/randomness/#introduction","title":"Introduction","text":"<p>Randomness is necessary for a variety of blockchain applications to create unbiased, unpredictable, and unique outcomes. However, obtaining a reliable source of randomness is a challenge. Computers are deterministic, meaning given the same input, the same output will always be produced. Therefore, random values generated by computers are referred to as pseudo-random as they appear to be statistically random, but given the same input, the output can easily be repeated.</p> <p>Moonbeam utilizes verifiable random functions (VRF) to generate randomness that can be verified on-chain. A VRF is a cryptographic function that takes some input and produces random values, along with a proof of authenticity that they were generated by the submitter. The proof can be verified by anyone to ensure that the random values were generated correctly.</p> <p>There are two available sources of randomness that provide random inputs based on block producers' VRF keys and past randomness results: local VRF and BABE epoch randomness. Local VRF is determined directly within Moonbeam using the collator of the block's VRF key and the last block's VRF output. On the other hand, BABE epoch randomness is based on all the VRF produced by the relay chain validators during a complete epoch.</p> <p>You can interact with and request on-chain randomness using the Randomness Precompile contract, a Solidity interface that enables smart contract developers to access the randomness functionality through the Ethereum API. For more information, please check out the Interacting with the Randomness Precompile guide.</p>"},{"location":"learn/features/randomness/#general-definitions","title":"General Definitions","text":"<ul> <li>Epoch - a time duration in the BABE protocol that is broken into smaller time slots. Slots are discrete units of time six seconds in length. On Polkadot, one epoch lasts approximately 2,400 slots or 4 hours. On Kusama, one epoch lasts approximately 600 slots or 1 hour.</li> <li>Deposit - an amount of funds required to request random words. There is one deposit per request. Once the request has been fulfilled, the deposit will be returned to the account that requested the randomness</li> <li>Block expiration delay - the number of blocks that must pass before a local VRF request expires and can be purged</li> <li>Epoch expiration delay - the number of epochs that must pass before a BABE request expires and can be purged</li> <li>Minimum block delay - the minimum number of blocks before a request can be fulfilled for local VRF requests</li> <li>Maximum block delay - the maximum number of blocks before a request can be fulfilled for local VRF requests</li> <li>Maximum random words - the maximum number of random words being requested</li> <li>Epoch fulfillment delay - the delay in epochs before a request can be fulfilled for a BABE request</li> </ul>"},{"location":"learn/features/randomness/#quick-reference","title":"Quick Reference","text":"MoonbeamMoonriverMoonbase Alpha Variable Value Deposit 100 GLMR Block expiration delay 10000 blocks Epoch expiration delay 10000 epochs Minimum block delay 2 blocks Maximum block delay 2000 blocks Maximum random words 100 words Epoch fulfillment delay 2 epochs (following the current one) Variable Value Deposit 1 MOVR Block expiration delay 10000 blocks Epoch expiration delay 10000 epochs Minimum block delay 2 blocks Maximum block delay 2000 blocks Maximum random words 100 words Epoch fulfillment delay 2 epochs (following the current one) Variable Value Deposit 1 DEV Block expiration delay 10000 blocks Epoch expiration delay 10000 epochs Minimum block delay 2 blocks Maximum block delay 2000 blocks Maximum random words 100 words Epoch fulfillment delay 2 epochs (following the current one)"},{"location":"learn/features/randomness/#local-vrf","title":"Local VRF","text":"<p>Local VRF randomness is generated on a block-by-block basis at the beginning of the block using the previous block's VRF output along with the public key of the current block author's VRF key. The generated randomness result is stored and used to fulfill all randomness requests for the current block.</p> <p>You can request local VRF randomness using the <code>requestLocalVRFRandomWords</code> method of the Randomness Precompile.</p> <p>If your contract could have concurrent requests open, you can use the <code>requestId</code> returned from the <code>requestLocalVRFRandomWords</code> method to track which response is associated with which randomness request.</p>"},{"location":"learn/features/randomness/#babe-epoch-randomness","title":"BABE Epoch Randomness","text":"<p>BABE epoch randomness is based on a hash of the VRF values from the blocks produced in the relay chain epoch before last. On Polkadot, an epoch lasts for roughly 4 hours, and on Kusama, an epoch lasts for roughly 1 hour. The hashing is completed on the relay chain, and as such, it is not possible for a collator on Moonbeam to influence the randomness value unless they are also a validator on the relay chain and were responsible for producing the last output included in an epoch.</p> <p>The randomness remains constant during an epoch. If a collator skips block production, the next eligible collator can fulfill the request using the same random value.</p> <p>You can request BABE epoch randomness using the <code>requestRelayBabeEpochRandomWords</code> method of the Randomness Precompile. In order to generate unique randomness, a different salt must be provided to the <code>requestRelayBabeEpochRandomWords</code> function.</p> <p>At the beginning of each relay chain epoch change, the randomness from one epoch ago is read from the relay chain state proof and used to fulfill all randomness requests that are due in the current block.</p>"},{"location":"learn/features/randomness/#request-and-fulfill-process","title":"Request &amp; Fulfill Process","text":"<p>In general, the request and fulfill process for randomness is as follows:</p> <ol> <li>Pay the deposit required to request random words</li> <li> <p>Request the randomness either using the local VRF or BABE epoch source of randomness. When requesting randomness you'll need to specify a few things:</p> <ul> <li>a refund address where any excess fees will be sent to</li> <li>the amount of fees which will be set aside to pay for fulfillment. If the specified amount is not enough you can always increase the request fees later, or if it's more than enough you'll be refunded the excess fees to the specified address after fulfillment</li> <li>a unique salt that will be used to generate different random words</li> <li>the number of random words you would like to request</li> <li>for local VRF, the delay period in blocks, which is used to increase unpredictability. It must be between the minimum and maximum number of blocks as listed above. For BABE epoch randomness, you do not need to specify a delay but can fulfill the request after the epoch delay has passed</li> </ul> </li> <li> <p>Wait for the delay period to pass</p> </li> <li>Fulfill the randomness request, which triggers the random words to be computed using the current block's randomness result and the given salt. This can manually be done by anyone using the fee that was initially set aside for the request</li> <li>For fulfilled requests, the random words are returned and the cost of execution will be refunded from the request fee to the address that initiated the fulfillment. Then any excess fees and the request deposit are transferred to the specified refund address</li> </ol> <p>If a request expires it can be purged by anyone. When this happens, the request fee is paid out to the address that initiated the purge and the deposit is returned to the original requester.</p> <p>The happy path for a randomness request is shown in the following diagram:</p> <p></p>"},{"location":"learn/features/randomness/#security-considerations","title":"Security Considerations","text":"<p>A method with the ability to call your <code>fulfillRandomness</code> method directly could spoof a VRF response with any random value, so it's critical that it can only be directly called by the <code>RandomnessConsumer.sol</code> contract's <code>rawFulfillRandomness</code> method.</p> <p>For your users to trust that your contract's random behavior is free from malicious interference, it's best if you can write it so that all behaviors implied by a VRF response are executed during your <code>fulfillRandomness</code> method. If your contract must store the response (or anything derived from it) and use it later, you must ensure that any user-significant behavior which depends on that stored value cannot be manipulated by a subsequent VRF request.</p> <p>Similarly, the collators have some influence over the order in which VRF responses appear on the blockchain, so if your contract could have multiple VRF requests in flight simultaneously, you must ensure that the order in which the VRF responses arrive cannot be used to manipulate your contract's user-significant behavior.</p> <p>Since the output of the random words generated for <code>requestLocalVRFRandomWords</code> is dependent on the collator producing the block at fulfillment, the collator could skip its block, forcing the fulfillment to be executed by a different collator and therefore generating a different VRF. However, such an attack would incur the cost of losing the block reward to the collator. It is also possible for a collator to be able to predict some of the possible outcome of the VRF if the delay between the request and the fulfillment is too short. It is for this reason that you can choose to provide a higher delay.</p> <p>Since the output of the random words generated for <code>requestRelayBabeEpochRandomWords</code> is dependent on the relay chain validator producing the blocks during an epoch, it is possible for the last validator of an epoch to choose between two possible VRF outputs by skipping the production of a block. However, such an attack would incur the cost of losing the block reward to the validator. It is not possible for a parachain collator to predict or influence the output of the relay chain VRF, not to censor the fulfillment, as long as there is one honest collator.</p>"},{"location":"learn/features/staking/","title":"Staking on Moonbeam","text":""},{"location":"learn/features/staking/#introduction","title":"Introduction","text":"<p>Moonbeam uses a block production mechanism based on Polkadot's Proof-of-Stake model, where there are collators and validators. Collators maintain parachains (in this case, Moonbeam) by collecting transactions from users and producing state transition proofs for the relay chain validators.</p> <p>The candidates in the active set of collators (nodes that produce blocks) are selected based on their stake in the network. And here is where staking comes in.</p> <p>Collator candidates (and token holders if they delegate) have a stake in the network. The top N candidates by staked amount are chosen to produce blocks with a valid set of transactions, where N is a configurable parameter. Part of each block reward goes to the collators that produced the block, who then share it with the delegators considering their percental contributions towards the collator's stake. In such a way, network members are incentivized to stake tokens to improve the overall security. Since staking is done at a protocol level through the staking interface, if you choose to delegate, the collators you delegate to do not have access to your tokens.</p> <p>To easily manage staking related actions, you can visit the Moonbeam DApp and use the network tabs at the top of the page to easily switch between Moonbeam networks. To learn how to use the DApp, you can check out the How to Stake MOVR Tokens guide or video tutorial, both of which can be adapted for the Moonbeam and the Moonbase Alpha TestNet.</p>"},{"location":"learn/features/staking/#general-definitions","title":"General Definitions","text":"<p>Some important parameters to understand in relation to the staking system on Moonbeam include:</p> <ul> <li>Round \u2014 a specific number of blocks around which staking actions are enforced. For example, new delegations are enacted when the next round starts. When bonding less or revoking delegations, funds are returned after a specified number of rounds</li> <li>Candidates - node operators that are eligible to become block producers if they can acquire enough stake to be in the active set</li> <li>Collators \u2014 active set of candidates that are selected to be block producers. They collect transactions from users and produce state transition proofs for the relay chain to validate</li> <li>Delegators \u2014 token holders who stake tokens, vouching for specific collator candidates. Any user that holds a minimum amount of tokens as free balance can become a delegator</li> <li>Minimum delegation per candidate \u2014 minimum amount of tokens to delegate candidates once a user is in the set of delegators</li> <li>Maximum delegators per candidate \u2014 maximum number of delegators, by staked amount, that a candidate can have which are eligible to receive staking rewards</li> <li>Maximum delegations \u2014 maximum number of candidates a delegator can delegate</li> <li>Exit delay - an exit delay is the amount of rounds before a candidate or delegator can execute a scheduled request to decrease or revoke a bond, or leave the set of candidates or delegators</li> <li>Reward payout delay - a certain amount of rounds must pass before staking rewards are distributed automatically to the free balance</li> <li>Reward pool - a portion of the annual inflation that is set aside for collators and delegators</li> <li>Collator commission - default fixed percent a collator takes off the top of the due staking rewards. Not related to the reward pool</li> <li>Delegator rewards \u2014 the aggregate delegator rewards distributed over all eligible delegators, taking into account the relative size of stakes (read more)</li> <li>Auto-compounding - a setting that automatically applies a percentage of a delegator's rewards to their total amount delegated</li> <li>Slashing \u2014 a mechanism to discourage collator misbehavior, where typically the collator and their delegators get slashed by losing a percentage of their stake. Currently, there is no slashing but this can be changed through governance. Collators who produce blocks that are not finalized by the relay chain won't receive rewards</li> </ul>"},{"location":"learn/features/staking/#quick-reference","title":"Quick Reference","text":"MoonbeamMoonriverMoonbase Alpha Variable Value Round duration 1800 blocks (6 hours) Minimum delegation per candidate 50 GLMR Maximum delegators per candidate 300 Maximum delegations 100 Reward payout delay 2 rounds (12 hours) Add or increase delegation takes effect in the next round (funds are withdrawn immediately) Decrease delegation delay 28 rounds (168 hours) Revoke delegations delay 28 rounds (168 hours) Leave delegators delay 28 rounds (168 hours) Variable Value Round duration 600 blocks (2 hours) Minimum delegation per candidate 5 MOVR Maximum delegators per candidate 300 Maximum delegations 100 Reward payout delay 2 rounds (4 hours) Add or increase delegation takes effect in the next round (funds are withdrawn immediately) Decrease delegation delay 24 rounds (48 hours) Revoke delegations delay 24 rounds (48 hours) Leave delegators delay 24 rounds (48 hours) Variable Value Round duration 1200 blocks (2 hours) Minimum delegation per candidate 1 DEV Maximum delegators per candidate 300 Maximum delegations 100 Reward payout delay 2 rounds (4 hours) Add or increase delegation takes effect in the next round (funds are withdrawn immediately) Decrease delegation delay 2 rounds (4 hours) Revoke delegations delay 2 rounds (4 hours) Leave delegators delay 2 rounds (4 hours) <p>Note</p> <p>As of runtime 3000, asynchronous backing has been enabled on all Moonbeam networks. As a result, the target block time was reduced from 12 seconds to 6 seconds, which may break some timing-based assumptions.</p> <p>To learn how to get the current value of any of the parameters around staking, check out the Retrieving Staking Parameters section of the How to Stake your Tokens guide.</p> <p>If you're looking for candidate or collator-specific requirements and information, you can take a look at the Collators guide.</p>"},{"location":"learn/features/staking/#resources-for-selecting-a-collator","title":"Resources for Selecting a Collator","text":"<p>There are a few resources you can check out to help you select a collator to delegate:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Stake GLMR Dashboard Stake GLMR Collators Leaderboard Moonscan Collator Dashboard DappLooker Variable Value Stake MOVR Dashboard Stake MOVR Collators Leaderboard Moonscan Collator Dashboard DappLooker Variable Value List of candidates Moonbase Alpha Subscan"},{"location":"learn/features/staking/#general-tips","title":"General Tips","text":"<ul> <li>To optimize your staking rewards, you should generally choose a collator with a lower total amount bonded. In that case, your delegation amount will represent a larger portion of the collator\u2019s total stake and you will earn proportionally higher rewards. However, there is a higher risk of the collator being kicked out of the active set and not earning rewards at all</li> <li>The minimum bond for each collator tends to increase over time, so if your delegation is close to the minimum, there is a higher chance you might fall below the minimum and not receive rewards</li> <li>Spreading delegations between multiple collators is more efficient in terms of rewards, but only recommended if you have enough to stay above the minimum bond of each collator</li> <li>You can consider collator performance by reviewing the number of blocks each collator has produced recently</li> <li>You can set up auto-compounding which will automatically restake a specified percentage of your delegation rewards</li> </ul>"},{"location":"learn/features/staking/#reward-distribution","title":"Reward Distribution","text":"<p>Rewards for collators and their delegators are calculated at the start of every round for their work prior to the reward payout delay. For example, on Moonriver the rewards are calculated for the collators work from 2 rounds ago.</p> <p>The calculated rewards are then paid out on a block-by-block basis starting at the second block of the round. For every block, one collator will be chosen to receive their entire reward payout from the prior round, along with their delegators, until all rewards have been paid out for that round. For example, if there are 72 collators who produced blocks in the prior round, all of the collators and their delegators will be paid by block 73 of the new round.</p> <p>You can choose to auto-compound your delegation rewards so you no longer have to manually delegate rewards. If you choose to set up auto-compounding, you can specify the percentage of rewards to be auto-compounded. These rewards will then be automatically added to your delegation.</p>"},{"location":"learn/features/staking/#annual-inflation","title":"Annual Inflation","text":"<p>The distribution of the annual inflation goes as follows:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Annual inflation 5% Rewards pool for collators and delegators 50% of the annual inflation Collator commission 20% of the annual inflation Parachain bond reserve 30% of the annual inflation Variable Value Annual inflation 5% Rewards pool for collators and delegators 50% of the annual inflation Collator commission 20% of the annual inflation Parachain bond reserve 30% of the annual inflation Variable Value Annual inflation 5% Rewards pool for collators and delegators 50% of the annual inflation Collator commission 20% of the annual inflation Parachain bond reserve 30% of the annual inflation <p>From the rewards pool, collators get the rewards corresponding to their stake in the network. The rest are distributed among delegators by stake.</p>"},{"location":"learn/features/staking/#calculating-rewards","title":"Calculating Rewards","text":"<p>Mathematically speaking, for collators, the reward distribution per block proposed and finalized would look like this:</p> <p></p> <p>Where <code>amount_due</code> is the corresponding inflation being distributed in a specific block, the <code>stake</code> corresponds to the number of tokens bonded by the collator in respect to the total stake of that collator (accounting delegations).</p> <p>For each delegator, the reward distribution (per block proposed and finalized by the delegated collator) would look like this:</p> <p></p> <p>Where <code>amount_due</code> is the corresponding inflation being distributed in a specific block, the <code>stake</code> corresponds to the amount of tokens bonded by each delegator in respect to the total stake of that collator.</p>"},{"location":"learn/features/staking/#risks","title":"Risks","text":"<p>Holders of MOVR/GLMR tokens should perform careful due diligence on collators before delegating. Being listed as a collator is not an endorsement or recommendation from the Moonbeam Network, the Moonriver Network, or Moonbeam Foundation. Neither the Moonbeam Network, Moonriver Network, nor Moonbeam Foundation has vetted the list collators and assumes no responsibility with regard to the selection, performance, security, accuracy, or use of any third-party offerings.  You alone are responsible for doing your own diligence to understand the applicable fees and all risks present, including actively monitoring the activity of your collators.</p> <p>You agree and understand that neither the Moonbeam Network, the Moonriver Network, nor Moonbeam Foundation guarantees that you will receive staking rewards and any applicable percentage provided (i) is an estimate only and not guaranteed, (ii) may change at any time and (iii) may be more or less than the actual staking rewards you receive. The Moonbeam Foundation makes no representations as to the monetary value of any rewards at any time.</p> <p>Staking MOVR/GLMR tokens is not free of risk. Staked MOVR/GLMR tokens are locked up, and retrieving them requires a 2 day/7 day waiting period . Additionally, if a collator fails to perform required functions or acts in bad faith, a portion of their total stake can be slashed (i.e. destroyed). This includes the stake of their delegators. If a collators behaves suspiciously or is too often offline, delegators can choose to unbond from them or switch to another collator. Delegators can also mitigate risk by electing to distribute their stake across multiple collators.</p>"},{"location":"learn/features/treasury/","title":"Treasury on Moonbeam","text":""},{"location":"learn/features/treasury/#introduction","title":"Introduction","text":"<p>The Moonbeam Treasury is an on-chain collection of funds launched at the network's genesis. Initially pre-funded with 0.5% of the token supply, the Treasury continues to accumulate GLMR as 80% of the parachain bond reserve inflation goes to the Treasury. For more information about Moonbeam inflation figures, see GLMR Tokenomics.</p> <p>The Moonbeam Treasury funds initiatives that support and grow the network. Stakeholders can propose spending requests for Treasury Council review, focusing on efforts like integrations, collaborations, community events, and outreach. Treasury spend proposers must submit their proposals to the Moonbeam Forum. For submission details, see How to Propose a Treasury Spend.</p> <p>The Treasury Council oversees the spending of the Moonbeam Treasury and votes on funding proposals. It comprises two members from the Moonbeam Foundation and three external community members. The three external members are elected to terms of 6 months. The same Treasury Council oversees Treasury requests for both Moonbeam and Moonriver. The Council meets monthly to review proposals submitted on the Moonbeam Forum. Once a proposal is agreed upon, the Council members must complete the on-chain approval process.</p>"},{"location":"learn/features/treasury/#general-definitions","title":"General Definitions","text":"<p>Some important terminology to understand regarding treasuries:</p> <ul> <li>Treasury Council \u2014 a group of Moonbeam Foundation representatives and external community members. The Council reviews funding proposals, ensures alignment with the community, and ultimately authorizes Treasury spending</li> <li>Proposal \u2014 a plan or suggestion submitted by stakeholders to further the network to be approved by the Treasury Council</li> </ul>"},{"location":"learn/features/treasury/#treasury-addresses","title":"Treasury Addresses","text":"<p>The Treasury address for each respective network can be found below:</p> MoonbeamMoonriverMoonbase Alpha <p>0x6d6F646c70632f74727372790000000000000000</p> <p>0x6d6f646C70792f74727372790000000000000000</p> <p>0x6d6F646c70632f74727372790000000000000000</p>"},{"location":"learn/features/treasury/#roadmap-of-a-treasury-proposal","title":"Roadmap of a Treasury Proposal","text":"<p>The happy path of a Treasury spend request is as follows:</p> <ol> <li> <p>Proposal submission - the user submits a proposal to the Moonbeam Forum</p> </li> <li> <p>Forum discussion - the proposal is discussed by the community on the Forum. The ultimate Aye/Nay decision is determined by the Treasury council</p> </li> <li> <p>Treasury approval and action - if the Treasury Council agrees, it authorizes the Treasury spending and moves the process forward</p> </li> </ol>"},{"location":"learn/features/treasury/#treasury-council-voting-process","title":"Treasury Council Voting Process","text":"<p>A member of the Treasury Council will submit a <code>treasury.spend</code> call. This call requires specifying the amount, the asset type, and the beneficiary account to receive the funds. The Treasury supports spending various token types beyond GLMR, including native USDT/USDC. Once this extrinsic is submitted, a new Treasury Council collective proposal will be created and made available for council members to vote on. Once approved through the Treasury Council's internal voting process, the funds will be released automatically to the beneficiary account through the <code>treasury.payout</code> extrinsic.</p> <p>Note</p> <p>There is no on-chain action for the proposer or beneficiary of the Treasury spend request. All Treasury spend actions will be completed by members of the Treasury Council.</p> <p>Note that this process has changed significantly from prior Treasury processes, where tokenholders could submit Treasury proposals with bonds attached. Now, no on-chain action is necessary to submit a Treasury proposal. Rather, all that is needed is to raise a Treasury Council request on the Moonbeam Forum and the Treasury Council will take care of the on-chain components. </p> <p>For more information, see How to Propose a Treasury Spend</p>"},{"location":"node-operators/networks/tracing-node/","title":"Run a Tracing Node","text":""},{"location":"node-operators/networks/tracing-node/#introduction","title":"Introduction","text":"<p>Geth's <code>debug</code> and <code>txpool</code> APIs and OpenEthereum's <code>trace</code> module provide non-standard RPC methods for getting a deeper insight into transaction processing. As part of Moonbeam's goal of providing a seamless Ethereum experience for developers, there is support for some of these non-standard RPC methods. Supporting these RPC methods is an important milestone because many projects, such as The Graph, rely on them to index blockchain data.</p> <p>To use the supported RPC methods, you need to run a tracing node, which is slightly different than running a full node. There is a different Docker image, called <code>moonbeamfoundation/moonbeam-tracing</code> that needs to be used for tracing. Additional flags will also need to be used to tell the node which of the non-standard features to support.</p> <p>This guide will show you how to get started running a tracing node on Moonbeam with the <code>debug</code>, <code>txpool</code>, and <code>tracing</code> flags enabled.</p>"},{"location":"node-operators/networks/tracing-node/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Similarly to running a regular node, you can spin up a tracing node using Docker or Systemd. If you choose to use Docker, you must install Docker if you haven't already. At the time of writing, the Docker version used was 19.03.6.</p>"},{"location":"node-operators/networks/tracing-node/#tracing-node-flags","title":"Tracing Node Flags","text":"<p>Spinning up a <code>debug</code>, <code>txpool</code>, or <code>tracing</code> node is similar to running a full node, but requires additional flags to enable the non-standard Ethereum RPC modules. These flags control tracing depth, caching, and runtime configuration.</p> <ul> <li><code>--ethapi debug</code>: Enables the <code>debug</code> module with RPC methods such as <code>debug_traceTransaction</code>, <code>debug_traceBlockByNumber</code>, <code>debug_traceBlockByHash</code>, and <code>debug_traceCall</code>.</li> <li><code>--ethapi trace</code>: Enables the <code>trace</code> module and its associated RPC methods like <code>trace_filter</code>.</li> <li><code>--ethapi txpool</code>: Enables the <code>txpool</code> module, which provides <code>txpool_content</code>, <code>txpool_inspect</code>, and <code>txpool_status</code>.</li> <li><code>--wasm-runtime-overrides &lt;path/to/overrides&gt;</code>: Required for tracing. Specifies the path where local Wasm runtimes are stored.  </li> <li>For Docker setups, use <code>/moonbeam/&lt;network&gt;-substitutes-tracing</code>, where <code>&lt;network&gt;</code> is <code>moonbeam</code>, <code>moonriver</code>, or <code>moonbase</code> (for Moonbase Alpha or dev nodes).</li> <li><code>--runtime-cache-size 64</code>: Required. Configures the number of different runtime versions preserved in the in-memory cache to <code>64</code>.</li> <li><code>--ethapi-max-permits &lt;uint&gt;</code>: Sets the number of concurrent tracing tasks shared by tracing modules (<code>debug</code>, <code>trace</code>). Default: <code>10</code>.</li> <li><code>--ethapi-trace-max-count &lt;uint&gt;</code>: Sets the maximum number of trace entries that a single <code>trace_filter</code> request can return. Default: <code>500</code>.</li> <li><code>--ethapi-trace-cache-duration &lt;uint&gt;</code>: Duration (in seconds) after which cached <code>trace_filter</code> results for a block are discarded. Default: <code>300</code>.</li> <li><code>--eth-log-block-cache &lt;bytes&gt;</code>: Size of the LRU cache (in bytes) used for storing block data. Default: <code>300000000</code>.</li> <li><code>--eth-statuses-cache &lt;bytes&gt;</code>: Size of the LRU cache (in bytes) used for storing transaction status data. Default: <code>300000000</code>.</li> <li><code>--fee-history-limit &lt;uint&gt;</code>: Sets the maximum fee history cache size for <code>eth_feeHistory</code> requests. Default: <code>2048</code>.</li> <li><code>--max-past-logs &lt;uint&gt;</code>: Maximum number of logs returned by a single log query. Default: <code>10000</code>.</li> <li><code>--max-block-range &lt;uint&gt;</code>: Maximum block span allowed in a single log query. Default: <code>1024</code>.</li> <li><code>--tracing-raw-max-memory-usage &lt;bytes&gt;</code>: Upper bound for memory used by raw tracing requests (stack, storage, and memory data). Default: <code>20000000</code>.</li> </ul> <p>Note</p> <p>If you want to run an RPC endpoint to connect to Polkadot.js Apps or your own dApp, use the <code>--unsafe-rpc-external</code> flag to allow external access to RPC ports. More details are available by running <code>moonbeam --help</code>.</p>"},{"location":"node-operators/networks/tracing-node/#run-a-tracing-node-with-docker","title":"Run a Tracing Node with Docker","text":"<p>If you haven't previously run a standard full Moonbeam node, you will need to setup a directory to store chain data:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>mkdir /var/lib/moonbeam-data\n</code></pre> <pre><code>mkdir /var/lib/moonriver-data\n</code></pre> <pre><code>mkdir /var/lib/alphanet-data\n</code></pre> <p>Before getting started, you'll need to set the necessary permissions either for a specific or current user (replace <code>INSERT_DOCKER_USER</code> for the actual user that will run the <code>docker</code> command):</p> MoonbeamMoonriverMoonbase Alpha <pre><code># chown to a specific user\nchown INSERT_DOCKER_USER /var/lib/moonbeam-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/moonbeam-data\n</code></pre> <pre><code># chown to a specific user\nchown INSERT_DOCKER_USER /var/lib/moonriver-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/moonriver-data\n</code></pre> <pre><code># chown to a specific user\nchown INSERT_DOCKER_USER /var/lib/alphanet-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/alphanet-data\n</code></pre> <p>Instead of the standard <code>moonbeamfoundation/moonbeam</code> docker image, you will need to use <code>moonbeamfoundation/moonbeam-tracing</code> image. The latest supported version can be found on the Docker Hub for the <code>moonbeam-tracing</code> image.</p> <p>Now, execute the docker run command. Note that you have to:</p> <ul> <li>Replace <code>INSERT_YOUR_NODE_NAME</code> in two different places</li> <li>Replace <code>INSERT_RAM_IN_MB</code> for 50% of the actual RAM your server has. For example, for 32 GB RAM, the value must be set to <code>16000</code>. The minimum value is <code>2000</code>, but it is below the recommended specs</li> </ul> <p>Note</p> <p>As of client v0.33.0, the <code>--ws-port</code> and <code>--ws-max-connections</code> flags have been deprecated and removed in favor of the <code>--rpc-port</code> and <code>--rpc-max-connections</code> flags for both RPC and WSS connections. The default port is <code>9944</code>, and the default maximum number of connections is set to 100.</p> <p>The complete command for running a tracing node is as follows:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam-tracing:v0.49.2-4101-4c40 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--ethapi debug,trace,txpool \\\n--wasm-runtime-overrides /moonbeam/moonbeam-substitutes-tracing \\\n--runtime-cache-size 64 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam-tracing:v0.49.2-4101-4c40 \\\n--base-path /data \\\n--chain moonriver \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--ethapi debug,trace,txpool \\\n--wasm-runtime-overrides /moonbeam/moonriver-substitutes-tracing \\\n--runtime-cache-size 64 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam-tracing:v0.49.2-4101-4c40 \\\n--base-path /data \\\n--chain alphanet \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--ethapi debug,trace,txpool \\\n--wasm-runtime-overrides /moonbeam/moonbase-substitutes-tracing \\\n--runtime-cache-size 64 \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n</code></pre> <pre><code>docker run --network=\"host\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam-tracing:v0.49.2-4101-4c40 \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--ethapi debug,trace,txpool \\\n--wasm-runtime-overrides /moonbeam/moonbase-substitutes-tracing \\\n--runtime-cache-size 64 \\\n--dev\n</code></pre> <p>You should see a terminal log similar to the following if you spun up a Moonbase Alpha tracing node:</p> docker run --network host  \\     -u $(id -u ${USER}):$(id -g ${USER}) \\         moonbeamfoundation/moonbeam-tracing:v0.49.2-4100-4d7b \\     --name=\"Moonbeam-Tracing-Tutorial\" \\     --unsafe-rpc-external \\     --ethapi=debug,trace,txpool \\     --wasm-runtime-overrides=/moonbeam/moonbase-substitutes-tracing \\     --runtime-cache-size 64 \\     --dev     2025-07-10 09:04:26 Moonbeam Parachain Collator      2025-07-10 09:04:26 \u270c\ufe0f  version 0.49.2      2025-07-10 09:04:26 \u2764\ufe0f  by PureStake, 2019-2025      2025-07-10 09:04:26 \ud83d\udccb Chain specification: Moonbase Development Testnet      2025-07-10 09:04:26 \ud83c\udff7  Node name: Moonbeam-Tracing-Tutorial      2025-07-10 09:04:26 \ud83d\udc64 Role: AUTHORITY      2025-07-10 09:04:26 \ud83d\udcbe Database: RocksDb at /tmp/substrateO3YeRz/chains/moonbase_dev/db/full      2025-07-10 09:04:26 Found wasm override. version=moonbase-300 (moonbase-0.tx2.au3) file=/moonbeam/moonbase-substitutes-tracing/moonbase-runtime-300-substitute-tracing.wasm      ...      2025-07-10 09:04:26 \ud83d\udca4 Idle (0 peers), best: #0 (0x18e6\u20262eb1), finalized #0 (0x18e6\u20262eb1), \u2b07 0 \u2b06 0"},{"location":"node-operators/networks/tracing-node/#run-a-tracing-node-with-systemd","title":"Run a Tracing Node with Systemd","text":"<p>When you run a node using Systemd, you'll need to start off by setting up the Moonbeam binary. To do so you'll need to follow the instructions on the Run a Node on Moonbeam Using Systemd page. In general, you'll need to:</p> <ol> <li>Setup the Moonbeam binary by following the Release Binary instructions. Or if you want to compile the binary yourself, you can follow the Compile the Binary instructions</li> <li>Follow the instructions in the Setup the Service instructions</li> </ol> <p>Once you've finished going through the instructions in those specific sections, you can continue on to the below instructions.</p>"},{"location":"node-operators/networks/tracing-node/#setup-the-wasm-overrides","title":"Setup the Wasm Overrides","text":"<p>You'll need to create a directory for the Wasm runtime overrides and obtain them from the Moonbeam Runtime Overrides repository on GitHub.</p> <p>You can clone the repository to any location on your local machine. For simplicity, you can use the directory where you're storing on-chain data. To set up the Wasm override files, you can take the following steps:</p> <ol> <li> <p>Clone the Moonbeam Runtime Overrides repository</p> <pre><code>git clone https://github.com/moonbeam-foundation/moonbeam-runtime-overrides.git\n</code></pre> </li> <li> <p>Move the Wasm overrides into your on-chain data directory:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>mv moonbeam-runtime-overrides/wasm /var/lib/moonbeam-data\n</code></pre> <pre><code>mv moonbeam-runtime-overrides/wasm /var/lib/moonriver-data\n</code></pre> <pre><code>mv moonbeam-runtime-overrides/wasm /var/lib/alphanet-data\n</code></pre> </li> <li> <p>Delete the override files for the networks that you aren't running</p> MoonbeamMoonriverMoonbase Alpha <pre><code>rm /var/lib/moonbeam-data/wasm/moonriver-runtime-* &amp;&amp;  rm /var/lib/moonbeam-data/wasm/moonbase-runtime-*\n</code></pre> <pre><code>rm /var/lib/moonriver-data/wasm/moonbeam-runtime-* &amp;&amp;  rm /var/lib/moonriver-data/wasm/moonbase-runtime-*\n</code></pre> <pre><code>rm /var/lib/alphanet-data/wasm/moonbeam-runtime-* &amp;&amp;  rm /var/lib/alphanet-data/wasm/moonriver-runtime-*\n</code></pre> </li> <li> <p>Set user permissions for the overrides:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>chmod +x /var/lib/moonbeam-data/wasm/*\nchown moonbeam_service /var/lib/moonbeam-data/wasm/*\n</code></pre> <pre><code>chmod +x /var/lib/moonriver-data/wasm/*\nchown moonriver_service /var/lib/moonriver-data/wasm/*\n</code></pre> <pre><code>chmod +x /var/lib/alphanet-data/wasm/*\nchown moonbase_service /var/lib/alphanet-data/wasm/*\n</code></pre> </li> </ol>"},{"location":"node-operators/networks/tracing-node/#create-the-configuration-file","title":"Create the Configuration File","text":"<p>The next step is to create the systemd configuration file, you'll need to:</p> <ul> <li>Replace <code>INSERT_YOUR_NODE_NAME</code> in two different places</li> <li>Replace <code>INSERT_RAM_IN_MB</code> for 50% of the actual RAM your server has. For example, for 32 GB RAM, the value must be set to <code>16000</code>. The minimum value is <code>2000</code>, but it is below the recommended specs</li> <li>Double-check that the binary is in the proper path as described below (ExecStart)</li> <li>Double-check the base path if you've used a different directory</li> <li>Name the file <code>/etc/systemd/system/moonbeam.service</code></li> </ul> <p>Note</p> <p>As of client v0.33.0, the <code>--ws-port</code> and <code>--ws-max-connections</code> flags have been deprecated and removed in favor of the <code>--rpc-port</code> and <code>--rpc-max-connections</code> flags for both RPC and WSS connections. The default port is <code>9944</code>, and the default maximum number of connections is set to 100.</p> MoonbeamMoonriverMoonbase Alpha <pre><code>[Unit]\nDescription=\"Moonbeam systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbeam_service\nSyslogIdentifier=moonbeam\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonbeam-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonbeam-data \\\n     --ethapi debug,trace,txpool \\\n     --wasm-runtime-overrides /var/lib/moonbeam-data/wasm \\\n     --runtime-cache-size 64 \\\n     --chain moonbeam \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Moonriver systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonriver_service\nSyslogIdentifier=moonriver\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonriver-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonriver-data \\\n     --ethapi debug,trace,txpool \\\n     --wasm-runtime-overrides /var/lib/moonriver-data/wasm \\\n     --runtime-cache-size 64 \\\n     --chain moonriver \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Moonbase Alpha systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbase_service\nSyslogIdentifier=moonbase\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/alphanet-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/alphanet-data \\\n     --ethapi debug,trace,txpool \\\n     --wasm-runtime-overrides /var/lib/alphanet-data/wasm \\\n     --runtime-cache-size 64 \\\n     --chain alphanet \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\"\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Note</p> <p>If you want to run an RPC endpoint, to connect polkadot.js.org, or to run your own application, use the <code>--unsafe-rpc-external</code> flag to run the full node with external access to the RPC ports. More details are available by running <code>moonbeam --help</code>.</p>"},{"location":"node-operators/networks/tracing-node/#run-the-service","title":"Run the Service","text":"<p>Register and start the service by running:</p> <pre><code>systemctl enable moonbeam.service\nsystemctl start moonbeam.service\n</code></pre> <p>And lastly, verify that the service is running:</p> <pre><code>systemctl status moonbeam.service\n</code></pre> systemctl status moonbeam.service \u25cf moonbeam.service - \"Moonbase Alpha systemd service\"     Loaded: loaded (/etc/systemd/system/moonbeam.service; enabled; vendor preset: enabled)     Active: active (running) since Fri 2022-06-03 12:45:08 EDT; 10min ago     Main PID: 2115 (moonbeam)     Tasks: 43 (limit: 19141)     Memory: 9.5G     CGroup:/system.slice/moonbeam.service     --2115 /var/lib/alphanet-data/moonbeam --port 30334 --rpc-port 9944    Jun 03 12:55:07 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:07 [\ud83c\udf17] &gt;     Jun 03 12:55:08 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:08 [Rela&gt;     Jun 03 12:55:12 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:12 [\ud83c\udf17] &gt;     Jun 03 12:55:13 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:13 [Rela&gt;     Jun 03 12:55:17 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:17 [\ud83c\udf17] &gt;     Jun 03 12:55:18 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:18 [Rela&gt;     Jun 03 12:55:19 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:19 [Rela&gt;     Jun 03 12:55:19 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:19 [Rela&gt;     Jun 03 12:55:19 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:19 [Rela&gt;     Jun 03 12:55:19 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:55:19 [Rela&gt;    <p>You can also run the following command to see logs of the tracing node spinning up:</p> <pre><code>journalctl -f -u moonbeam.service\n</code></pre> <p>Your terminal should display logs similar to the following:</p> asm override. version=moonbase-400 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/moo nbase-runtime-400-substitute-tracing.wasm     Jun 03 12:45:55 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:45:55 [\ud83c\udf17] Found w asm override. version-moonbase-155 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/moo     nbase-runtime-155-substitute-tracing. wasm     Jun 03 12:45:56 vmi719182. contaboserver.net moonbase [2115]: 2022-06-03 12:45:56 [\ud83c\udf17] Found w asm override. version-moonbase-501 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/moo nbase-runtime-501-substitute-tracing.wasm     Jun 03 12:45:57 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:45:57 [\ud83c\udf17] Found w asm override. version-moonbase-1200 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/mo onbase-runtime-1200-substitute-tracing.wasm     Jun 03 12:45:58 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:45:58 [\ud83c\udf17] Found w asm override. version-moonbase-47 (moonbase-1.tx2.au3) file=/var/lib/alphanet-data/wasm/moon base-runtime-47-substitute-tracing.wasm     Jun 03 12:46:00 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:46:00 [\ud83c\udf17] Found w asm override. version=moonbase-1501 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/mo onbase-runtime-1501-substitute-tracing.wasm     Jun 03 12:46:01 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:46:01 [\ud83c\udf17] Found w asm override. version-moonbase-900 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/moo nbase-runtime-900-substitute-tracing.wasm     Jun 03 12:46:04 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:46:04 [\ud83c\udf17] Found w asm override. version-moonbase-1504 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/mo onbase-runtime-1504-substitute-tracing.wasm     Jun 03 12:46:05 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:46:05 [\ud83c\udf17] Found w asm override. version-moonbase-1101 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/mo onbase-runtime-1101-substitute-tracing.wasm     Jun 03 12:46:07 vmi719182.contaboserver.net moonbase [2115]: 2022-06-03 12:46:07 [\ud83c\udf17] Found w asm override. version-moonbase-800 (moonbase-0.tx2.au3) file=/var/lib/alphanet-data/wasm/moo nbase-runtime-800-substitute-tracing.wasm"},{"location":"node-operators/networks/tracing-node/#using-a-tracing-node","title":"Using a Tracing Node","text":"<p>To explore the different non-standard RPC methods available on Moonbeam, and how to use these methods with a tracing node, check out the Debug &amp; Trace guide.</p>"},{"location":"node-operators/networks/collators/account-management/","title":"Collator Account Management","text":""},{"location":"node-operators/networks/collators/account-management/#introduction","title":"Introduction","text":"<p>When running a collator node on Moonbeam-based networks, there are some account management activities that you will need to be aware of. First and foremost you will need to create session keys for your primary and backup servers which will be used to determine block production and sign blocks.</p> <p>In addition, there are some optional account management activities that you can consider such as setting an on-chain identity or setting up proxy accounts.</p> <p>This guide will cover how to manage your collator account including generating and rotating your session keys, registering and updating your session keys, setting an identity, and creating proxy accounts.</p>"},{"location":"node-operators/networks/collators/account-management/#process","title":"Process to Add and Update Session Keys","text":"<p>The process for adding your session keys for the first time is the same as it would be for rotating your session keys. The process to create/rotate session keys is as follows:</p> <ol> <li>Generate session keys using the <code>author_rotateKeys</code> RPC method. The response to calling this method will be a 128 hexadecimal character string containing a Nimbus ID and the public key of a VRF session key</li> <li>Join the candidate pool if you haven't already</li> <li>Map the session keys to your candidate account using the Author Mapping Pallet's <code>setKeys(keys)</code> extrinsic, which accepts the entire 128 hexadecimal character string as the input. When you call <code>setKeys</code> for the first time, you'll be required to submit a mapping bond. If you're rotating your keys and you've previously submitted a mapping bond, no new bond is required</li> </ol> <p>Each step of the process is outlined in the following sections.</p>"},{"location":"node-operators/networks/collators/account-management/#session-keys","title":"Generate Session Keys","text":"<p>To match the Substrate standard, Moonbeam collator's session keys are SR25519. This guide will show you how you can create/rotate your session keys associated with your collator node.</p> <p>First, make sure you're running a collator node. Once you have your collator node running, your terminal should print similar logs:</p> 2025-02-25 20:00:52 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12706 (0x1d51.3042), finalized #12704 (0xf74b.aa44), 1 0.4kiB/s 1 0.6kiB/s 2025-02-25 20:00:52 \ud83d\udca4 Idle (6 peers), best: #5751 (Oxc5alesb5), finalized #5750 (0x9dc..e bad), 1 9.6kiB/s 1 3.5kiB/s 2025-02-25 20:00:53 [Relaychain] \u2728 Imported #12707 (0x77ea.4299) 2025-02-25 20:00:57 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12707 (0x77ea..4299), finalized #12704 (0xf74b..aa44), | 16.4kiB/s 1 12.2kiB/s 2025-02-25 20:00:57 \ud83d\udca4 Idle (6 peers), best: #5751 (0xc5a1e8b5), finalized #5750 (0x9fdc...e bad), 1 1.6kiB/s 1 0.4kiB/s 2025-02-25 20:00:59 [Relaychain] \u2728 Imported #12708 (0x009f...3bbf) 2025-02-25 20:01:00 \u2728 Imported #5753 (0x8981.6c81) 2025-02-25 20:01:00 \u2728 Imported #5753 (0x33a...b5e3) 2025-02-25 20:01:02 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12708 (0x009f...3bbf), finalized #12706 (0x1d51.3042), 1 1.5kiB/s 1 1.3kiB/s 2025-02-25 20:01:02 \ud83d\udca4 Idle (6 peers), best: #5752 (0x7036.569e), finalized #5751 (0xc5a1..e8b5), 1 3.3kiB/s 1 5.8kiB/s 2025-02-25 20:01:05 [Relaychain] \u2728 Imported #12709 (0x76b9...bf65) 2025-02-25 20:01:07 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12709 (0x76b9..bf65), finalized #12706 (0x1d51.3042), | 2.0kiB/s | 0.9kiB/s 2025-02-25 20:01:07 \ud83d\udca4 Idle (6 peers), best: #5752 (0x7036.569e), finalized #5751 (0xc5a1..e8b5), 1 0 1 0 <p>Next, session keys can be created/rotated by sending an RPC call to the HTTP endpoint with the <code>author_rotateKeys</code> method. When you call <code>author_rotateKeys</code>, the result is the size of two keys. The response will contain a concatenated Nimbus ID and VRF key. The Nimbus ID will be used to sign blocks and the VRF key is required for block production. The concatenated keys will be used to create an association to your H160 account for block rewards to be paid out.</p> <p>For reference, if your collator's HTTP endpoint is at port <code>9944</code>, the JSON-RPC call might look like this:</p> <pre><code>curl http://127.0.0.1:9944 -H \\\n\"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n  }'\n</code></pre> <p>The collator node should respond with the concatenated public keys of your new session keys. The first 64 hexadecimal characters after the <code>0x</code> prefix represent your Nimbus ID and the last 64 hexadecimal characters are the public key of your VRF session key. You'll use the concatenated public keys when mapping your Nimbus ID and setting the session keys in the next section.</p> curl http://127.0.0.1:9933-H\\ \"Content-Type: application/json;charset=utf-8\" -d \\ '{ \"jsonrpc\": \"2.0\", \"id\" :1, \"method\": \"author_rotatekeys\", \"params\": [] }' {\"jsonrpc\": \"2.0\", \"result\":\"0x72c7ca7ef0794103caeb520806576b52cb085f7577cc12cd36c2d64dbf73757a789407ec0f401a8792ac57c4fb7dabd4da6cc74d9ac9b8dd8c4faf770255403f\", \"id\" :1} <p>Make sure you write down the concatenated public keys. Each of your servers, your primary and backup, should have their own unique keys. Since the keys never leave your servers, you can consider them a unique ID for that server.</p> <p>Next, you'll need to register your session keys and map them to an H160 Ethereum-styled address to which the block rewards are paid.</p>"},{"location":"node-operators/networks/collators/account-management/#manage-session-keys","title":"Manage Session Keys","text":"<p>Once you've created or rotated your session keys, you'll be able to manage your session keys using the extrinsics in the Author Mapping Pallet. You can map your session keys, verify the on-chain mappings, and remove session keys.</p>"},{"location":"node-operators/networks/collators/account-management/#author-mapping-interface","title":"Author Mapping Pallet Interface","text":"<p>The <code>authorMapping</code> module has the following extrinsics:</p> <ul> <li>setKeys(keys) \u2014 accepts the result of calling <code>author_rotateKeys</code>, which is the concatenated public keys of your Nimbus and VRF keys, and sets the session keys at once. Useful after a key rotation or migration. Calling <code>setKeys</code> requires a bond. Replaces the deprecated <code>addAssociation</code> and <code>updateAssociation</code> extrinsics</li> <li>removeKeys() - removes the session keys. This is only required if you intend to stop collating and leave the candidate pool. Replaces the deprecated <code>clearAssociation</code> extrinsic</li> </ul> <p>The module also adds the following RPC calls (chain state):</p> <ul> <li>mappingWithDeposit(NimbusPrimitivesNimbusCryptoPublic | string | Uint8Array) \u2014 displays all mappings stored on-chain, or only that related to the Nimbus ID if provided</li> <li>nimbusLookup(AccountId20) - displays a reverse mapping of account IDs to Nimbus IDs for all collators or for a given collator address</li> </ul>"},{"location":"node-operators/networks/collators/account-management/#mapping-extrinsic","title":"Map Session Keys","text":"<p>With your newly generated session keys in hand, the next step is to map your session keys to your H160 account (an Ethereum-style address). Make sure you hold the private keys to this account, as this is where the block rewards are paid out to.</p> <p>To map your session keys to your account, you need to be inside the candidate pool. Once you are a candidate, you need to send a mapping extrinsic, which requires a mapping bond.</p>"},{"location":"node-operators/networks/collators/account-management/#mapping-bonds","title":"Mapping Bonds","text":"<p>The mapping bond is per session keys registered. The bond for mapping your session keys to your account is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>10000 GLMR\n</code></pre> <pre><code>100 MOVR\n</code></pre> <pre><code>100 DEV\n</code></pre>"},{"location":"node-operators/networks/collators/account-management/#use-polkadotjs-apps","title":"Use Polkadot.js Apps to Map Session Keys","text":"<p>In this section, you'll learn how to map session keys from Polkadot.js Apps. To learn how to create the mapping through the author mapping precompiled contract, you can refer to the page on Interacting with the Author Mapping Precompile.</p> <p>To create the mapping from Polkadot.js Apps (make sure you're connected to the correct network), click on Developer at the top of the page, choose the Extrinsics option from the dropdown, and take the following steps:</p> <ol> <li>Choose the account that you want to map your author ID to be associated with, from which you'll sign this transaction</li> <li>Select the authorMapping extrinsic</li> <li>Set the method to setKeys()</li> <li>Enter the keys. It is the response obtained via the RPC call <code>author_rotateKeys</code> in the previous section, which is the concatenated public keys of your Nimbus ID and VRF key</li> <li>Click on Submit Transaction</li> </ol> <p></p> <p>Note</p> <p>If you receive the following error, you may need to try rotating and mapping your keys again: <code>VRF PreDigest was not included in the digests (check rand key is in keystore)</code>.</p> <p>If the transaction is successful, you will see a confirmation notification on your screen. If not, make sure you've joined the candidate pool.</p>"},{"location":"node-operators/networks/collators/account-management/#checking-the-mappings","title":"Check Mappings","text":"<p>You can check the current on-chain mappings by verifying the chain state. You can do this one of two ways: via the <code>mappingWithDeposit</code> method or the <code>nimbusLookup</code> method. Both methods can be used to query the on-chain data for all of the collators or for a specific collator.</p> <p>You can check the current on-chain mappings for a specific collator or you can also check all of the mappings stored on-chain.</p>"},{"location":"node-operators/networks/collators/account-management/#using-mapping-with-deposit","title":"Using the Mapping with Deposit Method","text":"<p>To use the <code>mappingWithDeposit</code> method to check the mapping for a specific collator, you'll need to get the Nimbus ID. To do so, you can take the first 64 hexadecimal characters of the concatenated public keys to get the Nimbus ID. To verify that the Nimbus ID is correct, you can run the following command with the first 64 characters passed into the <code>params</code> array:</p> <pre><code>curl http://127.0.0.1:9944 -H \"Content-Type:application/json;charset=utf-8\" -d   '{\n  \"jsonrpc\":\"2.0\",\n  \"id\":1,\n  \"method\":\"author_hasKey\",\n  \"params\": [\"72c7ca7ef07941a3caeb520806576b52cb085f7577cc12cd36c2d64dbf73757a\", \"nmbs\"]\n}'\n</code></pre> <p>If it's correct the response should return <code>\"result\": true</code>.</p> curl http://127.0.0.1:9933 -H \"Content-Type:application/json;char set=utf-8\" -d '{ \"jsonrpc\":\"2.0\" \"id\" :1, \"method\": \"author_hasKey\", \"params\": [\"72c7ca7ef07941a3caeb520806576b52cb085f7577c12c36c2d64dbf73757a\", \"nmbs\"] }' {\"jsonrpc\":\"2.0\", \"result\" :true, \"id\" :1} <p>From Polkadot.js Apps, click on Developer at the top of the page, then choose Chain State from the dropdown, and take the following steps:</p> <ol> <li>Choose authorMapping as the state to query</li> <li>Select the mappingWithDeposit method</li> <li>Provide a Nimbus ID to query. Optionally, you can disable the slider to retrieve all mappings </li> <li>Click on the + button to send the RPC call</li> </ol> <p></p> <p>You should be able to see the H160 account associated with the Nimbus ID provided and the deposit paid. If no Nimbus ID was included, this would return all the mappings stored on-chain.</p>"},{"location":"node-operators/networks/collators/account-management/#using-nimbus-lookup","title":"Using the Nimbus Lookup Method","text":"<p>To use the <code>nimbusLookup</code> method to check the mapping for a specific collator, you'll need the collator's address. If you do not pass an argument to the method, you can retrieve all of the on-chain mappings.</p> <p>From Polkadot.js Apps, click on Developer at the top of the page, then choose Chain State from the dropdown, and take the following steps:</p> <ol> <li>Choose authorMapping as the state to query</li> <li>Select the nimbusLookup method</li> <li>Provide a collator's address to query. Optionally, you can disable the slider to retrieve all mappings</li> <li>Click on the + button to send the RPC call</li> </ol> <p></p> <p>You should be able to see the nimbus ID associated with the H160 account provided. If no account was provided, this would return all the mappings stored on-chain.</p>"},{"location":"node-operators/networks/collators/account-management/#removing-session-keys","title":"Remove Session Keys","text":"<p>Before removing your session keys, you'll want to make sure that you've stopped collating and left the candidate pool. To stop collating, you'll need to schedule a request to leave the candidate pool, wait a delay period, and then execute the request. For step-by-step instructions, please refer to the Stop Collating section of the Moonbeam Collator Activities page.</p> <p>Once you have left the candidate pool, you can remove your session keys. After which, the mapping bond you deposited will be returned to your account.</p> <p>From Polkadot.js Apps, click on Developer at the top of the page, then choose Extrinsics from the dropdown, and take the following steps:</p> <ol> <li>Select your account</li> <li>Choose the authorMapping pallet and the removeKeys extrinsic</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>Once the transaction goes through, the mapping bond will be returned to you. To make sure that the keys were removed, you can follow the steps in the Check Mappings section.</p>"},{"location":"node-operators/networks/collators/account-management/#setting-an-identity","title":"Setting an Identity","text":"<p>Setting an on-chain identity enables your collator node to be easily identifiable. As opposed to showing your account address, your chosen display name will be displayed instead.</p> <p>There are a couple of ways you can set your identity, to learn how to set an identity for your collator node please check out the Managing your Account Identity page of our documentation.</p>"},{"location":"node-operators/networks/collators/account-management/#proxy-accounts","title":"Proxy Accounts","text":"<p>Proxy accounts are accounts that can be enabled to perform a limited number of actions on your behalf. Proxies allow users to keep a primary account securely in cold storage while using the proxy to actively participate in the network on behalf of the primary account. You can remove authorization of the proxy account at any time. As an additional layer of security, you can setup your proxy with a delay period. This delay period would provide you time to review the transaction, and cancel if needed, before it automatically gets executed.</p> <p>To learn how to setup a proxy account, please refer to the Setting up a Proxy Account page of our documentation.</p>"},{"location":"node-operators/networks/collators/activities/","title":"Collator Activities","text":""},{"location":"node-operators/networks/collators/activities/#introduction","title":"Introduction","text":"<p>Becoming a collator on Moonbeam-based networks requires you to meet bonding requirements and join the candidate pool. Once you're in the candidate pool, you can adjust your self-bond amount or decide to leave the pool at any time.</p> <p>If you wish to reduce your self-bond amount or leave the candidate pool, it requires you to first schedule a request to leave and then execute upon the request after a delay period has passed.</p> <p>This guide will take you through important timings to be aware of when leaving or reducing your self-bond amount, how to join and leave the candidate pool, and how to adjust your self-bond.</p>"},{"location":"node-operators/networks/collators/activities/#collator-timings","title":"Collator Timings","text":"<p>Before getting started, it's important to note some of the timing of different actions related to collator activities:</p> MoonbeamMoonriverMoonbase Alpha Variable Value Round duration 1800 blocks (6 hours) Leave candidates 28 rounds (168 hours) Revoke delegation 28 rounds (168 hours) Reduce self-delegation 28 rounds (168 hours) Rewards payouts (after current round) 2 rounds (12 hours) Maximum offline rounds 1 rounds (6 hours) Variable Value Round duration 600 blocks (2 hours) Leave candidates 24 rounds (48 hours) Revoke delegation 24 rounds (48 hours) Reduce self-delegation 24 rounds (48 hours) Rewards payouts (after current round) 2 rounds (4 hours) Maximum offline rounds 2 rounds (4 hours) Variable Value Round duration 1200 blocks (2 hours) Leave candidates 2 rounds (4 hours) Revoke delegation 2 rounds (4 hours) Reduce self-delegation 2 rounds (4 hours) Rewards payouts (after current round) 2 rounds (4 hours) Maximum offline rounds 2 rounds (4 hours) <p>Note</p> <p>The values presented in the previous table are subject to change in future releases.</p> <p>Note</p> <p>As of runtime 3000, asynchronous backing has been enabled on all Moonbeam networks. As a result, the target block time was reduced from 12 seconds to 6 seconds, which may break some timing-based assumptions.</p>"},{"location":"node-operators/networks/collators/activities/#become-a-candidate","title":"Become a Candidate","text":""},{"location":"node-operators/networks/collators/activities/#get-the-size-of-the-candidate-pool","title":"Get the Size of the Candidate Pool","text":"<p>First, you need to get the <code>candidatePool</code> size (this can change through governance), as you'll need to submit this parameter in a later transaction. To do so, you'll have to run the following JavaScript code snippet from within Polkadot.js:</p> <pre><code>// Simple script to get candidate pool size\nconst candidatePool = await api.query.parachainStaking.candidatePool();\nconsole.log(`Candidate pool size is: ${candidatePool.length}`);\n</code></pre> <p>Head to the Developer tab, select JavaScript from the dropdown, and take the following steps:</p> <ol> <li>Copy the code from the previous snippet and paste it inside the code editor box. (Optional) Click the save icon and set a name for the code snippet, for example, \"Get candidatePool size\". This will save the code snippet locally</li> <li>To execute the code, click on the run button</li> <li>Copy the result, as you'll need it when joining the candidate pool</li> </ol> <p></p>"},{"location":"node-operators/networks/collators/activities/#join-the-candidate-pool","title":"Join the Candidate Pool","text":"<p>Once your node is running and in sync with the network, you become a candidate and join the candidate pool. Depending on which network you are connected to, head to Polkadot.js, click on the Developer tab, select Extrinsics from the dropdown, and take the following steps:</p> <ol> <li>Select the account you want to become a collator. Confirm your account is funded with at least the minimum stake required plus some extra for transaction fees</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Open the drop-down menu, which lists all the possible extrinsics related to staking, and select the joinCandidates function</li> <li>Set the bond to at least the minimum amount to be considered a candidate. You'll need to enter this amount in <code>Wei</code>. As an example, the minimum bond of 500 DEV on Moonbase Alpha would be <code>500000000000000000000</code> in Wei (500 + 18 extra zeros). Only the candidate bond counts for this check. Additional delegations do not count</li> <li>Set the candidate count as the candidate pool size. To learn how to retrieve this value, check the Get the Size of the Candidate Pool section</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p> <p>Note</p> <p>Function names and the minimum bond requirement are subject to change in future releases.</p> <p>As mentioned before, only the top candidates by delegated stake will be in the active set of collators. The exact number of candidates in the top for each network and the minimum bond amount can be found in the Minimum Collator Bond section.</p>"},{"location":"node-operators/networks/collators/activities/#stop-collating","title":"Stop Collating","text":"<p>To stop collating and leave the candidate pool, you must first schedule a request to leave the pool. Scheduling a request automatically removes you from the active set, so you will no longer be eligible to produce blocks or earn rewards. You must wait for the duration of the exit delay before you can execute the request to leave. After the request has been executed, you will be removed from the candidate pool.</p> <p>Similar to Polkadot's <code>chill()</code> functionality, you can temporarily leave the candidate pool without unbonding your tokens.</p>"},{"location":"node-operators/networks/collators/activities/#schedule-request-to-leave-candidates","title":"Schedule Request to Leave Candidates","text":"<p>To get started and schedule a request, navigate to the Developer tab, click on Extrinsics, and take the following steps:</p> <ol> <li>Select your candidate account</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the scheduleLeaveCandidates extrinsic</li> <li>Enter the <code>candidateCount</code> which you should have retrieved in the Get the Size of the Candidate Pool section</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p>"},{"location":"node-operators/networks/collators/activities/#execute-request-to-leave-candidates","title":"Execute Request to Leave Candidates","text":"<p>After the waiting period has passed, you'll be able to execute the request. To execute the request to leave the candidate pool, you'll first need to obtain the number of delegations the candidate has. To do so, you can query the candidate information, which will include the delegation count. To get started, click on the Developer tab, select Chain state, and take the following steps:</p> <ol> <li>From the selected state query dropdown, choose parachainStaking</li> <li>Select the candidateInfo extrinsic</li> <li>Choose the candidate account to get the information for</li> <li>Click the + button to submit the extrinsic</li> <li>Copy the <code>delegationCount</code> to be used for executing the leave candidates request</li> </ol> <p></p> <p>Now that you have the delegation count, you can execute the request. Switch back to the Extrinsics tab and follow these steps:</p> <ol> <li>Select your candidate account</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the executeLeaveCandidates extrinsic</li> <li>Select the target candidate account (anyone can execute the request after the exit delay has passed after submitting the <code>scheduleLeaveCandidates</code> extrinsic)</li> <li>Enter the candidate's delegation count</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p>"},{"location":"node-operators/networks/collators/activities/#cancel-request-to-leave-candidates","title":"Cancel Request to Leave Candidates","text":"<p>If you scheduled a request to leave the candidate pool but changed your mind, as long as the request has not been executed, you can cancel the request and remain in the candidate pool. To cancel the request, make sure you've clicked on  Extrinsics from the Developer tab, and then follow these steps:</p> <ol> <li>Select your candidate account</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the cancelLeaveCandidates extrinsic</li> <li>Provide the <code>candidateCount</code> which you should have retrieved in the Get the Size of the Candidate Pool section</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p>"},{"location":"node-operators/networks/collators/activities/#temporarily-leave-the-candidate-pool","title":"Temporarily Leave the Candidate Pool","text":"<p>If you want to temporarily leave the candidate pool, you can easily do so using the <code>goOffline</code> method. This can be useful, for example, if you need to temporarily leave to perform maintenance operations. Once you're done, you can then rejoin the pool using the <code>goOnline</code> method.</p> <p>To temporarily leave, you can take the following steps:</p> <ol> <li>Navigate to the Developer tab</li> <li>Click on Extrinsics</li> <li>Select your candidate account</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the goOffline extrinsic</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p> <p>Then, whenever you wish to rejoin, you can use the <code>goOnline</code> method by following the same steps outlined above, and then in step 5, choose the <code>goOnline</code> extrinsic. Please note that you can only call <code>goOnline</code> if you have previously called <code>goOffline</code>.</p>"},{"location":"node-operators/networks/collators/activities/#change-self-bond-amount","title":"Change Self-Bond Amount","text":"<p>As a candidate, changing your self-bond amount varies slightly depending on whether you're bonding more or less. If you're bonding more, it is a straightforward process where you can increase your stake via the <code>candidateBondMore()</code> extrinsic. You do not have to wait for any delays, and you do not need to schedule a request and then execute it; instead, your request will be executed instantly and automatically.</p> <p>If you wish to bond less, you have to schedule a request, wait for an exit delay, and then you will be able to execute the request and get a specified amount of tokens back into your free balance. In other words, scheduling the request doesn't decrease the bond instantly or automatically; it will only decrease once the request has been executed.</p>"},{"location":"node-operators/networks/collators/activities/#bond-more","title":"Bond More","text":"<p>As a candidate, there are two options for increasing one's stake. The first and recommended option is to send the funds to be staked to another owned address and delegate to your collator. Alternatively, collators that already have at least the minimum self-bond amount staked can increase their bond from Polkadot.js Apps. Navigate to the Developer tab, click on Extrinsics, and follow these steps:</p> <ol> <li>Select your collator account (and verify it contains the additional funds to be bonded)</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Open the drop-down menu, which lists all the possible extrinsics related to staking, and select the candidateBondMore function</li> <li>Specify the additional amount to be bonded in the more: BalanceOf field</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p>"},{"location":"node-operators/networks/collators/activities/#bond-less","title":"Bond Less","text":"<p>As a collator or collator candidate, you may decrease your amount bonded as long as you have more than the minimum self-bond amount after the decrease.</p> <p>In order to bond less, you have to first schedule a request, wait for the duration of the exit delay, and then execute the request. You can cancel a request at any time, as long as the request hasn't been executed yet.</p>"},{"location":"node-operators/networks/collators/activities/#schedule-bond-less","title":"Schedule Bond Less Request","text":"<p>To schedule a request to bond less, make sure you've clicked on the Developer tab and clicked on Extrinsics, then you can follow these steps:</p> <ol> <li>Select your candidate account</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Open the drop-down menu and select the scheduleCandidateBondLess function</li> <li>Specify the amount to decrease the bond by in the  less: BalanceOf field</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p> <p>Once the transaction is confirmed, you must wait the duration of the exit delay and then you will be able to execute and decrease the bond amount. If you try to execute the request before the exit delay, your extrinsic will fail, and you'll see an error in Polkadot.js for <code>parachainStaking.PendingDelegationRequest</code>.</p>"},{"location":"node-operators/networks/collators/activities/#execute-bond-less-request","title":"Execute Bond Less Request","text":"<p>After the exit delay has passed from scheduling a request to decrease your bond, you can execute the request to actually decrease the bond amount. Head to the Developer tab, select Extrinsics, and follow these steps:</p> <ol> <li>Select an account to execute the request with</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the executeCandidateBondLess extrinsic</li> <li>Select the target candidate account (anyone can execute the request after the exit delay has passed since the <code>scheduleCandidateBondLess</code> was submitted)</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p> <p>Once the transaction has been confirmed, you can check your free and reserved balances from the Accounts tab and notice that, now that the execution has gone through, your balances have been updated.</p>"},{"location":"node-operators/networks/collators/activities/#cancel-bond-less-request","title":"Cancel Bond Less Request","text":"<p>If you scheduled a request to bond more or less but changed your mind, as long as the request has not been executed, you can cancel the request at any time and keep your bond amount as is. To cancel the request, head to the Developer tab, select Extrinsics, and follow these steps:</p> <ol> <li>Select your candidate account (and verify it contains the additional funds to be bonded)</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the cancelCandidateBondRequest extrinsic</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p>"},{"location":"node-operators/networks/collators/activities/#mark-collator-as-inactive","title":"Mark a Collator as Inactive","text":"<p>If there is an inactive collator that has not produced blocks for a consecutive number of rounds, you can mark a collator as inactive. The maximum number of rounds a collator can be offline before they can be marked as inactive is as follows:</p> MoonbeamMoonriverMoonbase Alpha <p>1 round (6 hours)</p> <p>2 rounds (4 hours)</p> <p>2 rounds (4 hours)</p> <p>To mark a collator as inactive, you can use the <code>notifyInactiveCollator</code> extrinsic, which will notify the runtime when a collator is inactive and, by default, mark the collator as offline. To do so, you can head to  Polkadot.js Apps, make sure that you are connected to the correct network, then click on the Developer tab, select Extrinsics from the dropdown, and take the following steps:</p> <ol> <li>Select your account</li> <li>Select parachainStaking pallet under the submit the following extrinsic menu</li> <li>Select the notifyInactiveCollator extrinsic</li> <li>Specify the collator to mark as inactive</li> <li>Submit the transaction. Follow the wizard and sign the transaction using the password you set for the account</li> </ol> <p></p> <p>The collator will temporarily be removed from the candidate pool, and they can rejoin at any time by calling the <code>goOnline</code> extrinsic.</p>"},{"location":"node-operators/networks/collators/author-mapping/","title":"Interacting with the Author Mapping Precompile","text":""},{"location":"node-operators/networks/collators/author-mapping/#introduction","title":"Introduction","text":"<p>The author mapping precompiled contract on Moonbeam allows collator candidates to map session keys to a Moonbeam address where block rewards are paid out, through a familiar and easy-to-use Solidity interface. This enables candidates to complete author mapping with a Ledger or any other Ethereum wallet compatible with Moonbeam. However, it is recommended to generate your keys on an air-gapped machine. You can find out more information by referring to the account requirements section of the Collator Requirements page.</p> <p>To become a collator candidate, you must be running a collator node. You'll also need to join the candidate pool fully sync your node and submit the required bonds before generating your session keys and mapping them to your account. There is an additional bond that must be paid when mapping your session keys.</p> <p>The precompile is located at the following address:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>0x0000000000000000000000000000000000000807\n</code></pre> <pre><code>0x0000000000000000000000000000000000000807\n</code></pre> <pre><code>0x0000000000000000000000000000000000000807\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using the precompiled contracts on Moonbeam. Please refer to the Security Considerations page for more information.</p>"},{"location":"node-operators/networks/collators/author-mapping/#the-solidity-interface","title":"The Author Mapping Solidity Interface","text":"<p><code>AuthorMappingInterface.sol</code> is a Solidity interface that allows developers to interact with the precompile's methods.</p> <ul> <li>removeKeys() - removes the author ID and session keys. Replaces the deprecated <code>clearAssociation</code> extrinsic</li> <li>setKeys(bytes memory keys) \u2014 accepts the result of calling <code>author_rotateKeys</code>, which is the concatenated public keys of your Nimbus and VRF keys, and sets the author ID and the session keys at once. Useful after a key rotation or migration. Calling <code>setKeys</code> requires a bond. Replaces the deprecated <code>addAssociation</code> and <code>updateAssociation</code> extrinsics</li> <li>nimbusIdOf(address who) - retrieves the Nimbus ID of the given address. If no Nimbus ID exists for the given address, it returns <code>0</code></li> <li>addressOf(bytes32 nimbusId) - retrieves the address associated to a given Nimbus ID. If the Nimbus ID is unknown, it returns <code>0</code></li> <li>keysOf(bytes32 nimbusId) - retrieves the keys associated to the given Nimbus ID. If the Nimbus ID is unknown, it returns empty bytes</li> </ul>"},{"location":"node-operators/networks/collators/author-mapping/#bonds","title":"Required Bonds","text":"<p>To follow along with this tutorial, you'll need to join the candidate pool and map your session keys to your H160 Ethereum-style account. Two bonds are required to perform both of these actions.</p> <p>The minimum bond to join the candidate pool is set as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>100000 GLMR\n</code></pre> <pre><code>500 MOVR\n</code></pre> <pre><code>500 DEV\n</code></pre> <p>There is a bond that is sent when mapping your session keys with your account. This bond is per session keys registered. The bond set is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>10000 GLMR\n</code></pre> <pre><code>100 MOVR\n</code></pre> <pre><code>100 DEV\n</code></pre>"},{"location":"node-operators/networks/collators/author-mapping/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"node-operators/networks/collators/author-mapping/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The below example is demonstrated on Moonbase Alpha, however, similar steps can be taken for Moonbeam and Moonriver. You should:  </p> <ul> <li>Have MetaMask installed and connected to Moonbase Alpha</li> <li>Have an account with DEV tokens. You should have enough to cover the candidate and mapping bonds plus gas fees to send the transaction and map your session keys to your account. To get enough DEV tokens to follow along with this guide, you can contact a moderator directly via the Moonbeam Discord server</li> <li>Make sure you're running a collator node and it's fully synced</li> <li>Make sure you've joined the candidate pool</li> </ul> <p>As previously mentioned, you can use a Ledger by connecting it to MetaMask. Please refer to the Ledger guide to import your Ledger to MetaMask. Note that Ledger is not recommended for production use. For more information, see the account requirements in the Collator Requirements.</p>"},{"location":"node-operators/networks/collators/author-mapping/#generate-session-keys","title":"Generate Session Keys","text":"<p>To match the Substrate standard, Moonbeam collator's session keys are SR25519. This guide will show you how you can create/rotate your session keys associated with your collator node.</p> <p>First, make sure you're running a collator node. Once you have your collator node running, your terminal should print similar logs:</p> 2025-02-25 20:00:52 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12706 (0x1d51.3042), finalized #12704 (0xf74b.aa44), 1 0.4kiB/s 1 0.6kiB/s 2025-02-25 20:00:52 \ud83d\udca4 Idle (6 peers), best: #5751 (Oxc5alesb5), finalized #5750 (0x9dc..e bad), 1 9.6kiB/s 1 3.5kiB/s 2025-02-25 20:00:53 [Relaychain] \u2728 Imported #12707 (0x77ea.4299) 2025-02-25 20:00:57 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12707 (0x77ea..4299), finalized #12704 (0xf74b..aa44), | 16.4kiB/s 1 12.2kiB/s 2025-02-25 20:00:57 \ud83d\udca4 Idle (6 peers), best: #5751 (0xc5a1e8b5), finalized #5750 (0x9fdc...e bad), 1 1.6kiB/s 1 0.4kiB/s 2025-02-25 20:00:59 [Relaychain] \u2728 Imported #12708 (0x009f...3bbf) 2025-02-25 20:01:00 \u2728 Imported #5753 (0x8981.6c81) 2025-02-25 20:01:00 \u2728 Imported #5753 (0x33a...b5e3) 2025-02-25 20:01:02 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12708 (0x009f...3bbf), finalized #12706 (0x1d51.3042), 1 1.5kiB/s 1 1.3kiB/s 2025-02-25 20:01:02 \ud83d\udca4 Idle (6 peers), best: #5752 (0x7036.569e), finalized #5751 (0xc5a1..e8b5), 1 3.3kiB/s 1 5.8kiB/s 2025-02-25 20:01:05 [Relaychain] \u2728 Imported #12709 (0x76b9...bf65) 2025-02-25 20:01:07 [Relaychain] \ud83d\udca4 Idle (6 peers), best: #12709 (0x76b9..bf65), finalized #12706 (0x1d51.3042), | 2.0kiB/s | 0.9kiB/s 2025-02-25 20:01:07 \ud83d\udca4 Idle (6 peers), best: #5752 (0x7036.569e), finalized #5751 (0xc5a1..e8b5), 1 0 1 0 <p>Next, session keys can be created/rotated by sending an RPC call to the HTTP endpoint with the <code>author_rotateKeys</code> method. When you call <code>author_rotateKeys</code>, the result is the size of two keys. The response will contain a concatenated Nimbus ID and VRF key. The Nimbus ID will be used to sign blocks and the VRF key is required for block production. The concatenated keys will be used to create an association to your H160 account for block rewards to be paid out.</p> <p>For reference, if your collator's HTTP endpoint is at port <code>9944</code>, the JSON-RPC call might look like this:</p> <pre><code>curl http://127.0.0.1:9944 -H \\\n\"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n  }'\n</code></pre> <p>The collator node should respond with the concatenated public keys of your new session keys. The first 64 hexadecimal characters after the <code>0x</code> prefix represent your Nimbus ID and the last 64 hexadecimal characters are the public key of your VRF session key. You'll use the concatenated public keys when mapping your Nimbus ID and setting the session keys in the next section.</p> curl http://127.0.0.1:9933-H\\ \"Content-Type: application/json;charset=utf-8\" -d \\ '{ \"jsonrpc\": \"2.0\", \"id\" :1, \"method\": \"author_rotatekeys\", \"params\": [] }' {\"jsonrpc\": \"2.0\", \"result\":\"0x72c7ca7ef0794103caeb520806576b52cb085f7577cc12cd36c2d64dbf73757a789407ec0f401a8792ac57c4fb7dabd4da6cc74d9ac9b8dd8c4faf770255403f\", \"id\" :1} <p>Make sure you write down the concatenated public keys. Each of your servers, your primary and backup, should have their own unique keys. Since the keys never leave your servers, you can consider them a unique ID for that server.</p> <p>Next, you'll need to register your session keys and map them to an H160 Ethereum-styled address to which the block rewards are paid.</p>"},{"location":"node-operators/networks/collators/author-mapping/#remix-set-up","title":"Remix Set Up","text":"<p>To get started, get a copy of <code>AuthorMappingInterface.sol</code> and take the following steps:</p> <ol> <li>Click on the File explorer tab</li> <li>Copy and paste the file contents into a Remix file named <code>AuthorMappingInterface.sol</code></li> </ol> <p></p>"},{"location":"node-operators/networks/collators/author-mapping/#compile-the-contract","title":"Compile the Contract","text":"<ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile AuthorMappingInterface.sol</li> </ol>"},{"location":"node-operators/networks/collators/author-mapping/#access-the-contract","title":"Access the Contract","text":"<ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure AuthorMappingInterface.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract there is no need to deploy, instead you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the author mapping precompile for Moonbase Alpha: <code>0x0000000000000000000000000000000000000807</code> and click At Address</li> </ol> <p>The author mapping precompile will appear in the list of Deployed Contracts.</p>"},{"location":"node-operators/networks/collators/author-mapping/#map-session-keys","title":"Map Session Keys","text":"<p>The next step is to map your session keys to your H160 account (an Ethereum-style address). Make sure you hold the private keys to this account, as this is where the block rewards are paid out to.</p> <p>To map your session keys to your account, you need to be inside the candidate pool. Once you are a candidate, you need to send a mapping extrinsic. Note that this will bond tokens per author ID registered.</p> <p>Before getting started, ensure you're connected to the account that you want to map your session keys to. This will be the account where you will receive block rewards.</p> <ol> <li>Expand the AUTHORMAPPING contract</li> <li>Expand the setKeys method</li> <li>Enter your session keys</li> <li>Click transact</li> <li>Confirm the MetaMask transaction that appears by clicking Confirm</li> </ol> <p></p> <p>To verify you have mapped your session keys successfully, you can use either the <code>mappingWithDeposit</code> method or the <code>nimbusLookup</code> method of the author mapping pallet. To do so, please refer to the Check Mappings section of the Collator Account Management guide.</p>"},{"location":"node-operators/networks/collators/faq/","title":"Frequently Asked Questions","text":""},{"location":"node-operators/networks/collators/faq/#introduction","title":"Introduction","text":"<p>Collators are an integral part of the parachains they take part in. They receive transactions and create state transition proofs for the relay chain validators.</p> <p>Running a Moonbeam collator requires Linux systems administration skills, careful monitoring, and an attention to detail. Below are some tips and tricks that have been accumulated which should help you get up and running quickly.</p>"},{"location":"node-operators/networks/collators/faq/#q-a","title":"Q &amp; A","text":"<p>Q: Where can I get help?</p> <p>A: There is an active and friendly Discord community for collators. Join the server and introduce yourself even before you need help. Send gilmouta or artkaseman a DM and let them know who you are, and they can reach out to you if they see any issues with your node.</p> <p>Q: How do I stay up to date?</p> <p>A: All upgrades and important technical information are announced on Discord, in the #tech-upgrades-announcements channel. Join and follow this channel. You can set up integrations to Slack or Telegram if those are your preferred communication channels.</p> <p>Q: How do I register my node?</p> <p>A: There is a questionnaire, in which you will be able to provide your contact information as well as some basic hardware specs. You must be running a collator node on Moonbase Alpha to fill out the questionnaire.</p> <p>Q: What are the hardware requirements?</p> <p>A: Running a collator requires top of the line hardware to be able to process transactions and maximize your rewards. This is a very important factor in block production and rewards.</p> <p>Run a systemd service on a top of the line bare-metal machine (i.e. run a physical server, not a cloud VM, or a docker container). You can run your own, or select a provider to manage the server for you.</p> <p>Run only one service at a time per bare-metal machine. Do not run multiple instances.</p> <p>Q: What is the recommended hardware to run a collator?</p> <p>A:</p> <p>Hardware recommendations:</p> <ul> <li>Top of the line CPU:<ul> <li>Ryzen 9 5950x or 5900x</li> <li>Intel Xeon E-2386 or E-2388</li> </ul> </li> <li>Primary and backup bare metal servers in different data centers and countries (Hetzner is OK for one of them)</li> <li>Dedicated server for Moonbeam that isn't shared with any other apps</li> <li>1 TB NVMe SSD</li> <li>32 GB RAM</li> </ul> <p>Q: What about backup nodes?</p> <p>A: Run two bare-metal machines of the same specifications, in different countries and service providers. If your primary fails you can quickly resume services on your backup and continue to produce blocks and earn rewards. Please refer to the Q&amp;A on failovers below.</p> <p>Q: What are the different networks?</p> <p>A: There are three networks, and each requires dedicated hardware. The Moonbase Alpha TestNet is free and should be used to familiarize yourself with the setup.</p> <ul> <li>Moonbeam - production network on Polkadot</li> <li>Moonriver - production network on Kusama</li> <li>Moonbase Alpha TestNet - development network</li> </ul> <p>Q: What ports do I allow on my firewall?</p> <p>A:</p> <ul> <li>Allow all incoming requests on TCP ports 30333 and 30334</li> <li>Allow requests from your management IPs on TCP port 22</li> <li>Drop all other ports</li> </ul> <p>Q: Is there a CPU optimized binary?</p> <p>A: On each release page are CPU optimized binaries. Select the binary for your CPU architecture.</p> <ul> <li>Moonbeam-znver3 - Ryzen 9</li> <li>Moonbeam-skylake - Intel</li> <li>Moonbeam - generic can be used for all others</li> </ul> <p>Q: What are the recommendations on monitoring my node?</p> <p>A: Monitoring is very important for the health of the network and to maximize your rewards. We recommend using Grafana Labs. They have a free tier which should handle 6+ moonbeam servers.</p> <p>Q: What are the KPIs I should be monitoring?</p> <p>A: The main key performance indicator is blocks produced. The prometheus metric for this is called <code>substrate_proposer_block_constructed_count</code>.  </p> <p>Q: How should I setup alerting?</p> <p>A: Alerting is critical to keeping your moonbeam node producing blocks and earning rewards. We recommend pagerduty.com, which is supported by Grafana Labs. Use the KPI query above and set an alert when this drops below 1. The alert should page the person on-call 24/7.  </p> <p>Q: What are Nimbus keys?</p> <p>A: Nimbus keys are just like session keys in Polkadot. You should have unique keys on your primary and backup servers. Save the key output somewhere safe where you can access it in the middle of the night if you receive an alert. To create your keys, please refer to the Session Keys section of the documentation.</p> <p>Q: What is the failover process if my primary node is down?</p> <p>A: When the primary server is down, the best way to perform a failover to the backup server is to perform a key association update. Each server should have a unique set of keys already. Run the <code>setKeys</code> author mapping extrinsic. You can follow the Mapping Extrinsic instructions and modify the instructions to use the <code>setKeys</code> extrinsic.</p> <p>Q: Should I set up centralized logging?</p> <p>A: Grafana Labs can also be configured for centralized logging and is recommended. You can see all your nodes in one place. Kibana has a more robust centralized logging offering, but Grafana is simple and good enough to start.</p> <p>Q: What should I look for in the logs?</p> <p>A: Logs are very useful to determine if you are in sync and ready to join the collators pool. Look at the tail end of the logs to determine if: </p> <ol> <li>Your Relay chain is in sync</li> <li>Your parachain is in sync</li> </ol> <p>You should see Idle in your logs when your node is in sync.</p> <p></p> <p>A common issue is joining the pool before your node is in sync. You will be unable to produce any blocks or receive any rewards. Wait until you are in sync and idle before joining the candidate pool.</p> moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f 10 Syncing 137.9 bps, target=#12325010 (8 peers), best: #21001 (0x25d9...57d8), finalized #20992 (0x1ebb..fd23), # 214.4kiB/s 11.7kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f * Syncing 182.7 bps, target=#5219905 (8 peers), best: #22472 (0x875f..aed7), finalized #9625 (0x601b...e64f), # 371.0kiB/s 113.3kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f I Syncing 186.6 bps, target=#12325011 (8 peers), best: #21935 (0x58f8...d312), finalized #21585 (0x1d73...13c8), #271.9kiB/s T1.3kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f @ Syncing 193.4 bps, target=#5219905 (8 peers), best: #23440 (0xdce6...8ea6), finalized #9922 (0x07c9...1fdf), # 383.3kiB/s 17.5kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f \u00d6 Syncing 189.5 bps, target=#12325012 (8 peers), best: #22883 (0x6531.2281), finalized #22528 (0x0f21.0855), # 290.8kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f @ Syncing 206.4 bps, target=#5219905 (8 peers), best: #24474 (0x09dd...6700), finalized #10393 (0x3efc...8a40), #428.7kiB/s 12.4kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f . Syncing 171.6 bps, target=#12325013 (8 peers), best: #23744 (0x4ced...cdae), finalized #23552 (0x1773..09d9), # 252.4kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f Syncing 212.3 bps, target=#5219905 (8 peers), best: #25536 (0x7bc0...e9b7), finalized #10905 (0x5c70...3063), 1427.1kiB/s 11.4kiB/s <p>The relay chain takes much longer to sync than the parachain. You will not see any finalized blocks until the relay chain has synced.</p> <p>Q: How much is the bond to become a collator?</p> <p>A: There are two bonds you need to be aware of. Make sure your node is configured and in sync before proceeding with these steps.</p> <p>The first is the bond to join the collators pool:</p> <ul> <li>Moonbeam - minimum of 100000 GLMR</li> <li>Moonriver - minimum of 500 MOVR</li> <li>Moonbase Alpha - minimum of 500 DEV</li> </ul> <p>The second is the bond for key association:</p> <ul> <li>Moonbeam - minimum of 10000 GLMR</li> <li>Moonriver - minimum of 100 MOVR</li> <li>Moonbase Alpha - minimum of 100 DEV</li> </ul> <p>Q: How do I set an identity on my collator account? </p> <p>A: Setting an identity on chain will help to identify your node and attract delegations. You can set an identity by following the instructions on the Managing an Identity page of our documentation.</p>"},{"location":"node-operators/networks/collators/orbiter/","title":"Moonbeam Orbiter Program","text":""},{"location":"node-operators/networks/collators/orbiter/#introduction","title":"Introduction","text":"<p>The Moonbeam Foundation is announcing a limited trial of the orbiter program. Similar to Decentralized Nodes, this program allows collators to participate in the diversity and security of the network even if they do not have enough funds or backing to otherwise be in the active set. This program was developed with the input from the community.</p> <p>The Moonbeam Foundation will maintain orbiter pools in the active set, and will assign authority to produce blocks to each of the members in the program, who are called orbiters. </p> <p>The active orbiter will rotate on a regular fixed basis to maintain a fair distribution of active rounds. The orbiters\u2019 performance will be monitored and payouts for each round will be redirected to each orbiter based on their blocks produced that round. Rewards overall will be shared with all other orbiters assigned to each specific collator account. </p> <p>As long as an orbiter\u2019s performance is within a range of their peers, they will maintain their position in the rotation. If they fall below this threshold, they will be removed from the pool and demoted to the back of the waiting list for Moonbase Alpha. A new orbiter from the waiting list will take their slot. </p>"},{"location":"node-operators/networks/collators/orbiter/#duration","title":"Duration","text":"<p>As the program progresses, the Moonbeam Foundation will assess the results and make adjustments. There is no specific end date, but the program may come to an end or materially change. Participants are both encouraged to give feedback throughout the program as well as be aware that it may change from the concept explained here.</p>"},{"location":"node-operators/networks/collators/orbiter/#eligibility","title":"Eligibility","text":"<p>To participate in the orbiter program, you must meet the following eligibility criteria:</p> <ul> <li>Due to the nature of the program, each orbiter must pass an identity verification check, and cannot be a resident of certain jurisdictions</li> <li>Each orbiter must post a bond. This bond is posted to protect against bad behavior and will be subject to slashing</li> <li>Each entity (person or group) may only run one orbiter per network (i.e., one on Moonriver and one on Moonbeam)</li> <li>Orbiters cannot run another active collator on the same network as their orbiter. They can, however, run an active collator on Moonbeam and an orbiter on Moonriver, or vice versa, as long as they do not also have both on the same network</li> </ul>"},{"location":"node-operators/networks/collators/orbiter/#communication","title":"Communication","text":"<p>A private discord group will be created for this program, and most communication will happen over this channel or through DM. Once you've filled out your application, you'll be added to the group.</p>"},{"location":"node-operators/networks/collators/orbiter/#configuration","title":"Orbiters and Orbiter Pool Configurations","text":"<p>Orbiter pools are maintained by the Moonbeam Foundation, and will assign block production authority to each orbiter. The maximum number of orbiters per orbiter pool for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>6 orbiters per pool\n</code></pre> <pre><code>3 orbiters per pool\n</code></pre> <pre><code>8 orbiters per pool\n</code></pre> <p>For Moonbeam and Moonriver there is also a maximum number of orbiter pools that will be allowed in the active set. For Moonbase Alpha, there will be as many orbiter pools as needed. The maximum is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>5 orbiter pools\n</code></pre> <pre><code>8 orbiter pools\n</code></pre> <pre><code>Unlimited orbiter pools\n</code></pre> <p>Each orbiter will be active for a certain number of rounds before the next orbiter will take over. The number of active rounds for each network is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>1 round (~6 hours)\n</code></pre> <pre><code>3 rounds (~6 hours)\n</code></pre> <pre><code>3 rounds (~6 hours)\n</code></pre>"},{"location":"node-operators/networks/collators/orbiter/#application-and-onboarding-process","title":"Application and Onboarding Process","text":"<p>To join the orbiter program, you'll need to start by filling out an application where you'll need to submit contact information, social media handles, and collator and node details. At the end of the form, you'll also need to follow the instructions to complete identity verification.</p> Moonbeam Orbiter Program Application <p>Once you've passed identity verification and have been accepted into the program, you'll be notified and then the onboarding process will begin. New orbiters must run a Moonbase Alpha node for two weeks to be eligible to run a Moonriver node. Orbiters then must run a Moonriver node for four weeks to be eligible to run a Moonbeam node. Once you are eligible, you are not required to run orbiters on any network. You can leave other networks at any time by unregistering and you will receive your bond back. To join again on that network you will need to re-register and will be at the end of the queue.</p> <p>An outline of the onboarding process is as follows:</p> <ul> <li>Prepare your node by syncing it</li> <li>Once fully synced, you can generate your session keys</li> <li>Register your session keys and post the associated mapping bond</li> <li>Once you are ready, register as an orbiter via the <code>moonbeamOrbiters.orbiterRegister()</code> extrinsic and post the associated orbiter bond</li> <li>Orbiters will be placed in a waiting list for each network until a slot is available</li> <li>Once a slot opens up, you'll begin producing blocks and receiving rewards on the respective network</li> </ul>"},{"location":"node-operators/networks/collators/orbiter/#bond","title":"Bonds","text":""},{"location":"node-operators/networks/collators/orbiter/#mapping-bond","title":"Mapping Bond","text":"<p>There is a bond that is sent when mapping your author ID with your account. This bond is per author ID registered. The bond set is as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>10000 GLMR\n</code></pre> <pre><code>100 MOVR\n</code></pre> <pre><code>100 DEV\n</code></pre>"},{"location":"node-operators/networks/collators/orbiter/#orbiter-bond","title":"Orbiter Bond","text":"<p>As previously mentioned, each orbiter must submit a bond to join the program. This bond differs from the one for the active set as it does not earn any delegation rewards while bonded. The current bonds are as follows:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>30000 GLMR\n</code></pre> <pre><code>400 MOVR\n</code></pre> <pre><code>100 DEV\n</code></pre>"},{"location":"node-operators/networks/collators/orbiter/#rewards","title":"Rewards","text":"<p>Rewards for orbiters will be split between the other orbiters assigned to the same orbiter pool. The maximum orbiters per orbiter pool is described in the configuration section. In the case of Moonriver it\u2019s 3, so the rewards will be approximately 1/3 of a collator\u2019s rewards. The blocks produced by each orbiter while active are tracked, and rewards are proportionally distributed.</p>"},{"location":"node-operators/networks/collators/orbiter/#performance-metrics","title":"Performance Metrics","text":"<p>Each orbiter\u2019s performance will be assessed over a period of time to determine they are active and producing blocks, and if their performance is within a range of all other orbiter pool collators. Orbiters are expected to run top tier hardware to stay within range. For more information on hardware requirements, please check out the Collator Requirements page. </p> <p>Metrics will be assessed over seven day periods. The performance metrics are as follows:</p> <ul> <li>Orbiter has produced a block within the last three rounds they were active </li> <li>Orbiter\u2019s block production is within two standard deviation of the seven day program mean</li> <li>Orbiter\u2019s transactions per block is within two standard deviation of the seven day program mean </li> <li>Orbiter\u2019s block weight is within two standard deviation of the seven day program mean</li> </ul> <p>Note</p> <p>These factors are subject to change as the program progresses.</p>"},{"location":"node-operators/networks/collators/orbiter/#leaving-the-program","title":"Leaving the Program","text":"<p>An orbiter may leave the program and receive their bond back without any delay. The only limitation is that if the orbiter is currently active, they cannot leave. Once they are no longer active (i.e. once their assigned active round ends and block production authority rotates to another orbiter), they can leave at any time by following these steps: </p> <ol> <li> <p>In Polkadot.js Apps, open the Developer tab, click Chain state, select <code>moonbeamOrbiters</code>, and submit <code>collatorsPool()</code> with no arguments, making sure to disable include option. Look for your orbiter's address beneath the collator pool address. Copy the collator pool address as you'll need it in a subsequent step.      </p> </li> <li> <p>From the same Polkadot.js Apps Chain State page, select <code>moonbeamOrbiters</code>, and submit the <code>counterForCollatorsPool()</code> query. Make a note of that number as you'll need it in the final step.     </p> </li> <li> <p>In Polkadot.js Apps, open the Developer tab, click Extrinsics, and submit the <code>moonbeamOrbiters.orbiterLeaveCollatorPool(collator)</code> extrinsic using the collator pool address from step 1 for the <code>collator</code> parameter.     </p> </li> <li> <p>Stay on the Developer tab with Extrinsics selected and submit <code>moonbeamOrbiters.orbiterUnregister(collatorsPoolCount)</code> with the pool count captured in step 2.     </p> </li> </ol>"},{"location":"node-operators/networks/collators/overview/","title":"Run a Collator on Moonbeam","text":""},{"location":"node-operators/networks/collators/overview/#introduction","title":"Introduction","text":"<p>Collators are members of the network that maintain the parachains they take part in. They run a full node (for both their particular parachain and the relay chain), and they produce the state transition proof for relay chain validators.</p> <p>There are some requirements that need to be considered prior to becoming a collator candidate including machine, bonding, account, and community requirements.</p> <p>Candidates will need a minimum amount of tokens bonded (self-bonded) to be considered eligible. Only a certain number of the top collator candidates by total stake, including self-bonded and delegated stake, will be in the active set of collators. Otherwise, the collator will remain in the candidate pool.</p> <p>Once a candidate is selected to be in the active set of collators, they are eligible to produce blocks.</p> <p>Moonbeam uses the Nimbus Parachain Consensus Framework. This provides a two-step filter to allocate candidates to the active set of collators, then assign collators to a block production slot:</p> <ul> <li>The parachain staking filter selects the top candidates in terms of tokens staked in each network. For the exact number of top candidates per each network and the minimum bond amount, you can check out the Minimum Collator Bond section of our documentation. This filtered pool is called selected candidates (also known as the active set), which are rotated every round</li> <li>The fixed size subset filter picks a pseudo-random subset of the previously selected candidates for each block production slot</li> </ul> <p>Users can spin up full nodes on Moonbeam, Moonriver, and Moonbase Alpha and activate the <code>collate</code> feature to participate in the ecosystem as collator candidates. To do this, you can checkout the Run a Node section of the documentation and spin up a node using either Docker or Systemd.</p>"},{"location":"node-operators/networks/collators/overview/#join-discord","title":"Join the Discord","text":"<p>As a collator, it is important to keep track of updates and changes to configuration. It is also important to be able to easily contact us and vice versa in case there is any issue with your node, as that will not only negatively affect collator and delegator rewards, it will also negatively affect the network.</p> <p>For this purpose, we use Discord. The most relevant Discord channels for collators are the following:</p> <ul> <li>tech-upgrades-announcements \u2014 here we will publish any updates or changes in configuration changes collators will be required to follow. We will also announce any technical issues to monitor, such as network stalls</li> <li>collators \u2014 this is the general collator discussion channel. We are proud of having an active and friendly collator community so if you have any questions, this is the place to ask. We will also ping collators here for any issues that require their attention.</li> <li>meet-the-collators \u2014 in this channel you can introduce yourself to potential delegators</li> </ul> <p>After you join Discord, feel free to DM gilmouta or artkaseman and introduce yourself. This will help the team identify who to contact if issues arise with your node and will enable assignment of the relevant Discord collator role, allowing you to post in meet-the-collators.</p>"},{"location":"node-operators/networks/collators/requirements/","title":"Collator Requirements","text":""},{"location":"node-operators/networks/collators/requirements/#introduction","title":"Introduction","text":"<p>There are some requirements to keep in mind before diving into running a collator node. Primarily, you need to follow the community guidelines and meet the technical requirements. You should have top of the line hardware, securely created and stored accounts, meet bonding requirements, and fill out a collator questionnaire.</p> <p>It is recommended to go through all of the necessary requirements on the Moonbase Alpha TestNet before collating on a production network like Moonbeam or Moonriver.</p> <p>This guide will help you to get started fulfilling the collator requirements so you can get your node up and running in no time.</p>"},{"location":"node-operators/networks/collators/requirements/#community-guidelines","title":"Community Guidelines","text":"<p>Collators have a responsibility to the network to act honorably. If any of the following forbidden offenses occur, action may be taken via on-chain governance:</p> <ul> <li>An entity is running more than four collators in either network</li> <li>A collator is running multiple nodes using the same Nimbus key causing equivocation. Equivocation is the action of submitting multiple blocks at the same block height, which forks the network. It is strictly forbidden due to the network degradation that it implies. This can be done by a malicious actor (trying to get more blocks included/produced) or by mistake (having a backup node running with the same key). Each node needs to have its own unique keys and any backup solutions need to ensure there can be no possibility of equivocation</li> <li>A collator acts in a nefarious manner that is uncharitable to the community or other collators</li> </ul> <p>There is a level of commitment to the community and the network that is necessary to gain trust from the community of delegators and attract more delegations. The following contains some suggestions for contributing to the community:</p> <ul> <li>Be active in the community<ul> <li>Join the Discord and introduce yourself, provide updates as needed, and help support community members or other collators</li> </ul> </li> <li>Create tutorials and educational content</li> <li>Become a Moonbeam Ambassador</li> <li>Contribute to open-source software relating to the ecosystem</li> <li>Actively participate in governance and vote on proposals</li> </ul>"},{"location":"node-operators/networks/collators/requirements/#hardware-requirements","title":"Hardware Requirements","text":"<p>Collators must have a full node running with the collation options. To do so, follow the Run a Node tutorial and installation steps for Using Systemd. Make sure you use the specific code snippets for collators.</p> <p>Note</p> <p>Running a collator node has higher CPU requirements than the ones provided in the above tutorial. In order for your collator node to be able to keep up with a high transaction throughput a CPU with high clock speed and single-core performance is important, as the block production/import process is almost entirely single-threaded. Running your collator node in Docker is also not recommended, as it will have a significant impact in performance.</p> <p>From a hardware perspective, it is important to have top of the line hardware to maximize block production and rewards. The following are some hardware recommendations that have performed well and provided the best results:</p> <ul> <li>Recommended CPUs - Intel Xeon E-2386/2388 or Ryzen 9 5950x/5900x</li> <li>Recommended NVMe - 1 TB NVMe</li> <li>Recommended RAM - 32 GB RAM</li> </ul> <p>In addition, you should take into account the following considerations:</p> <ul> <li>As most cloud providers focus on multi-thread rather than single-thread performance, using a bare-metal provider is recommended</li> <li>You should have primary and backup bare metal servers in different data centers and countries. Hetzner is OK for one of these servers, but shouldn't be used for both</li> <li>Your Moonbeam server should be dedicated for Moonbeam only, please do not use the same server for other apps</li> </ul>"},{"location":"node-operators/networks/collators/requirements/#account-requirements","title":"Account Requirements","text":"<p>Similar to Polkadot validators, you need to create an account. For Moonbeam, this is an H160 account or an Ethereum-style account from which you hold the private keys. As a collator, you are responsible for correctly managing your own keys. Incorrectly doing so can result in a loss of funds.</p> <p>There are many Ethereum wallets that can be used, but for production purposes it is recommended to generate keys as securely as possible. It is also recommended to generate backup keys. You can actually generate keys using the Moonbeam binary through a tool called Moonkey. It can be used to generate both Ethereum-style accounts and Substrate-style accounts.</p> <p>To generate keys securely it is recommended to do so on an air-gapped machine. Once you generate your keys, make sure you store them safely. To securely store your keys, here are some recommendations, from least to most secure:</p> <ul> <li>Write down and laminate your keys</li> <li>Engrave your keys into a metal plate</li> <li>Shard your keys using a tool like Horcrux</li> </ul> <p>As always, it is recommended to do your own research and use tools that you vet as trustworthy.</p>"},{"location":"node-operators/networks/collators/requirements/#getting-started-with-moonkey","title":"Getting Started with Moonkey","text":"<p>The first step is to fetch the moonkey binary file hosted on GitHub. To do so, you can download a binary file (tested on Linux/Ubuntu):</p> <p><code>https://github.com/moonbeam-foundation/moonbeam/releases/download/v0.8.0/moonkey</code></p> <p>Once you\u2019ve downloaded the tool, ensure you have the correct access permissions to execute the binary file. Next, check that you have the right version by checking the downloaded file hash.</p> <p>For Linux-based systems such as Ubuntu, open the terminal and head to the folder where the moonkey binary file is located. Once there, you can use the sha256sum tool to calculate the SHA256 hash:</p> <pre><code>019c3de832ded3fccffae950835bb455482fca92714448cc0086a7c5f3d48d3e\n</code></pre> <p>After you\u2019ve verified the hash, it is recommended to move the binary file to an air-gapped machine (no network interfaces). You can also check the hash of the file in the air-gapped device directly.</p>"},{"location":"node-operators/networks/collators/requirements/#generating-an-account-with-moonkey","title":"Generating an Account with Moonkey","text":"<p>Using the moonkey binary file is very straightforward. Every time you execute the binary, the information related to a newly created account is displayed.</p> <p>This information includes:</p> <ul> <li>Mnemonic seed - a 24-word mnemonic that represents your account in readable words. This gives direct access to your funds, so you need to store these words securely</li> <li>Private key - the private key associated with your account, used for signing. This is derived from the mnemonic seed. This gives direct access to your funds, so you need to store it securely</li> <li>Public address - your account\u2019s address</li> <li>Derivation path - tells the Hierarchical Deterministic (HD) wallet how to derive the specific key</li> </ul> <p>Note</p> <p>Please safely store the private key/mnemonic and do not share it with anyone. Private keys/mnemonics provide direct access to your funds.</p> <p>It is recommended that you use the binary file in an air-gapped machine.</p>"},{"location":"node-operators/networks/collators/requirements/#other-moonkey-features","title":"Other Moonkey Features","text":"<p>Moonkey provides some additional functionalities. The following flags can be provided:</p> <ul> <li><code>-help</code> \u2013 prints help information</li> <li><code>-version</code> \u2013 prints version of moonkey you are running</li> <li><code>-w12</code> \u2013 generates a 12 words mnemonic seed (default is 24)</li> </ul> <p>The following options are available:</p> <ul> <li><code>-account-index</code> \u2013 provide as input the account index to use in the derivation path</li> <li><code>-mnemonic</code> \u2013 provide as input the mnemonic</li> </ul>"},{"location":"node-operators/networks/collators/requirements/#bonding-requirements","title":"Bonding Requirements","text":"<p>There are two bonds for you to be aware of: a bond to join the collator pool and a bond for key association.</p>"},{"location":"node-operators/networks/collators/requirements/#minimum-collator-bond","title":"Minimum Collator Bond","text":"<p>First, you will need a minimum amount of tokens staked (self-bonded) to be considered eligible and become a candidate. Only a certain number of the top collator candidates by total stake, including self-bonded and delegated stake (total bonded), will be in the active set of collators.</p> MoonbeamMoonriverMoonbase Alpha Variable Value Minimum self-bond amount 100000 GLMR Active set size 64 collators Variable Value Minimum self-bond amount 500 MOVR Active set size 72 collators Variable Value Minimum self-bond amount 500 DEV Active set size 8 collators"},{"location":"node-operators/networks/collators/requirements/#key-association-bond","title":"Key Association Bond","text":"<p>Secondly, you will need a bond for key association. This bond is required when mapping your author ID (session keys) with your account for block rewards, and is per author ID registered.</p> MoonbeamMoonriverMoonbase Alpha Variable Value Minimum bond 10000 GLMR Variable Value Minimum bond 100 MOVR Variable Value Minimum bond 100 DEV"},{"location":"node-operators/networks/collators/requirements/#collator-questionnaire","title":"Collator Questionnaire","text":"<p>There is a Collator Questionnaire, that aims to assess the state of all collators on Moonbase Alpha. You should be running a collator node on Moonbase Alpha before filling out this form. You will be able to provide your contact information as well as some basic hardware specs. It provides a way to open the lines of communication between you and the Moonbeam team in case any problems with your node arise.</p>"},{"location":"node-operators/networks/run-a-node/compile-binary/","title":"Manually Compile the Moonbeam Binary","text":""},{"location":"node-operators/networks/run-a-node/compile-binary/#introduction","title":"Introduction","text":"<p>Running a full node on a Moonbeam-based network allows you to connect to the network, sync with a boot node, obtain local access to RPC endpoints, author blocks on the parachain, and more.</p> <p>This guide is meant for people with experience compiling Substrate-based blockchain nodes. A parachain node is similar to a typical Substrate node, but there are some differences. A Substrate parachain node will be a bigger build because it contains code to run the parachain itself as well as code to sync the relay chain and facilitate communication between the two. This build is quite large, may take over 30 minutes, and requires at least 32 GB of memory.</p> <p>To get started quickly without the hassle of compiling the binary yourself, you can use The Release Binary.</p>"},{"location":"node-operators/networks/run-a-node/compile-binary/#compile-the-binary","title":"Compile the Binary","text":"<p>Manually compiling the binary can take around 30 minutes and requires 32GB of memory.</p> <p>The following commands will build the latest release of the Moonbeam parachain.</p> <ol> <li> <p>Clone the Moonbeam repo.</p> <pre><code>git clone https://github.com/moonbeam-foundation/moonbeam\ncd moonbeam\n</code></pre> </li> <li> <p>Check out the latest release.</p> <pre><code>git checkout tags/$(git describe --tags)\n</code></pre> </li> <li> <p>Skip the next two steps if you already have Rust installed. Otherwise, install Rust and its prerequisites via Rust's recommended method.</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> </li> <li> <p>Update your <code>PATH</code> environment variable.</p> <pre><code>source $HOME/.cargo/env\n</code></pre> </li> <li> <p>Build the parachain binary.</p> <p>Note</p> <p>If you are using Ubuntu 20.04 or 22.04, then you will need to install these additional dependencies before building the binary:</p> <pre><code>apt install clang protobuf-compiler libprotobuf-dev pkg-config libssl-dev -y \n</code></pre> <pre><code>cargo build --release\n</code></pre> </li> </ol> <p></p> <p>If a cargo not found error shows up in the terminal, manually add Rust to your system path or restart your system:</p> <pre><code>source $HOME/.cargo/env\n</code></pre> <p>Now you can use the Moonbeam binary to run a Systemd service. To set up the service and run it, please refer to the Run a Node on Moonbeam Using Systemd guide.</p>"},{"location":"node-operators/networks/run-a-node/docker/","title":"Run a Node on Moonbeam Using Docker","text":""},{"location":"node-operators/networks/run-a-node/docker/#introduction","title":"Introduction","text":"<p>Running a full node on a Moonbeam-based network allows you to connect to the network, sync with a bootnode, obtain local access to RPC endpoints, author blocks on the parachain, and more.</p> <p>In this guide, you'll learn how to quickly spin up a Moonbeam node using Docker and how to maintain and purge your node.</p>"},{"location":"node-operators/networks/run-a-node/docker/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you'll need to:</p> <ul> <li>Install Docker. At the time of writing, the Docker version used was 24.0.6</li> <li>Make sure that your system meets the requirements. When connecting to Moonriver on Kusama or Moonbeam on Polkadot, it will take a few days to completely sync the embedded relay chain</li> </ul>"},{"location":"node-operators/networks/run-a-node/docker/#storage-chain-data","title":"Set up Storage for Chain Data","text":"<p>To set up the directory for storing chain data, you'll need to:</p> <ol> <li> <p>Create a local directory</p> MoonbeamMoonriverMoonbase Alpha <pre><code>mkdir /var/lib/moonbeam-data\n</code></pre> <pre><code>mkdir /var/lib/moonriver-data\n</code></pre> <pre><code>mkdir /var/lib/alphanet-data\n</code></pre> </li> <li> <p>Set the ownership and permissions for the local directory that stores the chain data. You can set the permissions either for a specific or current user (replace <code>INSERT_DOCKER_USER</code> for the actual user that will run the <code>docker</code> command)</p> MoonbeamMoonriverMoonbase Alpha <pre><code># chown to a specific user\nchown INSERT_DOCKER_USER /var/lib/moonbeam-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/moonbeam-data\n</code></pre> <pre><code># chown to a specific user\nchown INSERT_DOCKER_USER /var/lib/moonriver-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/moonriver-data\n</code></pre> <pre><code># chown to a specific user\nchown INSERT_DOCKER_USER /var/lib/alphanet-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/alphanet-data\n</code></pre> </li> </ol>"},{"location":"node-operators/networks/run-a-node/docker/#start-up-commands","title":"Start-up Commands","text":"<p>To spin up your node, you'll need to execute the <code>docker run</code> command. If you're setting up a collator node, make sure to follow the code snippets for collators.</p> <p>Note that in the following start-up command, you have to:</p> <ul> <li>Replace <code>INSERT_YOUR_NODE_NAME</code> with your node name of choice. You'll have to do this in two places: one for the parachain and one for the relay chain</li> <li>Replace <code>INSERT_RAM_IN_MB</code> for 50% of the actual RAM your server has. For example, for 32GB of RAM, the value must be set to <code>16000</code>. The minimum value is <code>2000</code>, but it is below the recommended specs</li> </ul> <p>For an overview of the flags used in the following start-up commands, plus additional commonly used flags, please refer to the Flags page of our documentation.</p> <p>For Apple Silicon users</p> <p>If Docker commands fail or behave unexpectedly on Apple Silicon, enable Use Rosetta for x86_64/amd64 emulation on Apple Silicon in Docker Desktop settings and use the <code>amd64</code> platform for both pull and run commands. For example:</p> <pre><code>docker pull --platform=linux/amd64 moonbeamfoundation/moonbeam:v0.49.2\n</code></pre> <pre><code>docker run --platform=linux/amd64 ...\n</code></pre>"},{"location":"node-operators/networks/run-a-node/docker/#full-node","title":"Full Node","text":"Linux snippets MoonbeamMoonriverMoonbase Alpha <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--pool-type=fork-aware \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain moonriver \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--pool-type=fork-aware \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain alphanet \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--pool-type=fork-aware \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> MacOS snippets MoonbeamMoonriverMoonbase Alpha <pre><code>docker run -p 9944:9944 -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--pool-type=fork-aware \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run -p 9944:9944 -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain moonriver \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--pool-type=fork-aware \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run -p 9944:9944 -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain alphanet \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--pool-type=fork-aware \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre>"},{"location":"node-operators/networks/run-a-node/docker/#allow-external-access","title":"Allow External Access to Your Node","text":"<p>If you want to run an RPC endpoint, connect to Polkadot.js Apps, or run your own application, you can use the <code>--unsafe-rpc-external</code> flag to run the full node with external access to the RPC ports.</p> Example start-up command for Moonbeam LinuxMacOS <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--pool-type=fork-aware \\\n--unsafe-rpc-external \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run -p 9944:9944 -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--pool-type=fork-aware \\\n--unsafe-rpc-external \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre>"},{"location":"node-operators/networks/run-a-node/docker/#use-sql","title":"Use a SQL Backend for Frontier","text":"<p>The default Frontier database, which comes standard with Moonbeam nodes and contains all of the Ethereum-related elements, such as transactions, blocks, and logs, can be modified to use a SQL backend. Since <code>eth_getLogs</code> is a very resource-intensive method, the SQL backend aims to provide a more performant alternative for indexing and querying Ethereum logs in comparison to the default RocksDB database.</p> <p>To spin up a node with a Frontier SQL backend, you'll need to add the <code>--frontier-backend-type sql</code> flag to your start-up command.</p> <p>There are additional flags you can use to configure the pool size, query timeouts, and more for your SQL backend; please refer to the Flags page for more information.</p> Example start-up command for Moonbeam LinuxMacOS <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n# This is a comment\n--db-cache INSERT_RAM_IN_MB \\\n--pool-type=fork-aware \\\n--frontier-backend-type sql \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run -p 9944:9944 -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--state-pruning archive \\\n--trie-cache-size 1073741824 \\\n--pool-type=fork-aware \\\n--frontier-backend-type sql \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre>"},{"location":"node-operators/networks/run-a-node/docker/#collator-node","title":"Collator Node","text":"<p>Beginning with v0.39.0, new Moonbeam collator nodes will no longer generate session keys automatically on start-up. Nodes in existence prior to v0.39.0 do not need to make changes to how they handle session keys. </p> <p>When setting up a new node, run the following command to generate and store on disk the session keys that will be referenced in the start-up command: </p> MoonbeamMoonriverMoonbase Alpha <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n moonbeamfoundation/moonbeam:v0.49.2 key generate-node-key --base-path /var/lib/moonbeam-data --chain moonbeam \n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n moonbeamfoundation/moonbeam:v0.49.2 key generate-node-key --base-path /var/lib/moonriver-data --chain moonriver \n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n moonbeamfoundation/moonbeam:v0.49.2 key generate-node-key --base-path /var/lib/alphanet-data --chain alphanet &amp;&amp; sudo chown -R moonbase_service  /var/lib/alphanet-data\n</code></pre> <p>Note</p> <p>You need to change ownership of the newly created folder to the specific user or current user for Docker. Node key generation steps can be bypassed using the <code>--unsafe-force-node-key-generation</code> parameter in the start-up command, although this is not the recommended practice.</p> <p>Now you can run your Docker start up commands:</p> Linux snippets MoonbeamMoonriverMoonbase Alpha <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--collator \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--pool-type=fork-aware \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain moonriver \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--collator \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--pool-type=fork-aware \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain alphanet \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--collator \\\n--trie-cache-size 1073741824 \\\n--db-cache INSERT_RAM_IN_MB \\\n--pool-type=fork-aware \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> MacOS snippets MoonbeamMoonriverMoonbase Alpha <pre><code>docker run -p 9944:9944 -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain moonbeam \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--collator \\\n--trie-cache-size 1073741824 \\\n--pool-type=fork-aware \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run -p 9944:9944 -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain moonriver \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--collator \\\n--trie-cache-size 1073741824 \\\n--pool-type=fork-aware \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre> <pre><code>docker run -p 9944:9944 -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--base-path /data \\\n--chain alphanet \\\n--name \"INSERT_YOUR_NODE_NAME\" \\\n--collator \\\n--trie-cache-size 1073741824 \\\n--pool-type=fork-aware \\\n-- \\\n--name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n--sync fast\n</code></pre>"},{"location":"node-operators/networks/run-a-node/docker/#syncing-your-node","title":"Syncing Your Node","text":"<p>Once Docker pulls the necessary images, your full node will start, displaying lots of information, such as the chain specification, node name, role, genesis state, and more.</p> docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" -u $(id -u ${USER}):$(id -g ${USER}) moonbeam-foundation/moonbeam:v0.49.2 --base-path=/data --chain alphanet --name=\"TestNode\" --state-pruning archive --trie-cache-size 1073741824 --db-cache 8000 --name=\"TestNode (Embedded Relay)\" 2025-07-10 09:04:26 Moonbeam Parachain Collator  2025-07-10 09:04:26 \u270c\ufe0f  version 0.49.2  2025-07-10 09:04:26 \u2764\ufe0f  by PureStake, 2019-2025  2025-07-10 09:04:26 \ud83d\udccb Chain specification: Moonbase Development Testnet  2025-07-10 09:04:26 \ud83c\udff7  Node name: TestNode  2025-07-10 09:04:26 \ud83d\udc64 Role: FULL  2025-07-10 09:04:26 \ud83d\udcbe Database: RocksDb at /data/chains/moonbase_alpha/db/full  2025-07-10 09:04:26 Database: RocksDb at  2025-07-10 09:04:26 &amp; Native runtime: moonbase-3501 (moonbase-0.tx2.au4) 2025-07-10 09:04:26 Parachain id: Id(1000) 2025-07-10 09:04:26 Parachain Account: 5Ec4AhPZk8STuex8Wsi9TwDtJQxKqzPJRCH7348Xtcs9vZLJ 2025-07-10 09:04:26 Parachain genesis state: 0x0000000000000000000000000000000000000000000000000000000000000000006505bc9a20d69f14620b2417b6d777c398ceb3e32119b9a53507111d1880927c03170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131400 2025-07-10 09:04:26 Is collating: no 2025-07-10 09:04:26 [ 1 ^ Initializing Genesis block/state (state: 0xb505..927c, header-hash: 0x91bc...9527) 2025-07-10 09:04:26 \uff3bRelaychain\uff3d ^ Initializing Genesis block/state (state: 0x96a6..9426, header-hash: 0xelea..9443) <p>During the syncing process, you will see logs from both the embedded relay chain ([Relaychain]) and the parachain ([\ud83c\udf17]). These logs display a target block (live network state) and a best block (local node synced state).</p> moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f 10 Syncing 137.9 bps, target=#12325010 (8 peers), best: #21001 (0x25d9...57d8), finalized #20992 (0x1ebb..fd23), # 214.4kiB/s 11.7kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f * Syncing 182.7 bps, target=#5219905 (8 peers), best: #22472 (0x875f..aed7), finalized #9625 (0x601b...e64f), # 371.0kiB/s 113.3kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f I Syncing 186.6 bps, target=#12325011 (8 peers), best: #21935 (0x58f8...d312), finalized #21585 (0x1d73...13c8), #271.9kiB/s T1.3kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f @ Syncing 193.4 bps, target=#5219905 (8 peers), best: #23440 (0xdce6...8ea6), finalized #9922 (0x07c9...1fdf), # 383.3kiB/s 17.5kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f \u00d6 Syncing 189.5 bps, target=#12325012 (8 peers), best: #22883 (0x6531.2281), finalized #22528 (0x0f21.0855), # 290.8kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f @ Syncing 206.4 bps, target=#5219905 (8 peers), best: #24474 (0x09dd...6700), finalized #10393 (0x3efc...8a40), #428.7kiB/s 12.4kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f . Syncing 171.6 bps, target=#12325013 (8 peers), best: #23744 (0x4ced...cdae), finalized #23552 (0x1773..09d9), # 252.4kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 \ud83c\udf17 \u2699\ufe0f Syncing 212.3 bps, target=#5219905 (8 peers), best: #25536 (0x7bc0...e9b7), finalized #10905 (0x5c70...3063), 1427.1kiB/s 11.4kiB/s <p>If you followed the installation instructions for Moonbase Alpha, once synced, you will have a node of the Moonbase Alpha TestNet running locally! For Moonbeam or Moonriver, once synced, you will be connected to peers and see blocks being produced on the network!</p> <p>Note</p> <p>It may take a few days to completely sync the embedded relay chain. Make sure that your system meets the requirements.</p>"},{"location":"node-operators/networks/run-a-node/docker/#maintain-your-node","title":"Maintain Your Node","text":"<p>As Moonbeam development continues, it will sometimes be necessary to upgrade your node software. Node operators will be notified on our Discord channel when upgrades are available and whether they are necessary (some client upgrades are optional). The upgrade process is straightforward and is the same for a full node or collator.</p> <ol> <li> <p>Stop the Docker container:</p> <pre><code>sudo docker stop INSERT_CONTAINER_ID\n</code></pre> </li> <li> <p>Get the latest version of Moonbeam from the Moonbeam GitHub Release page</p> </li> <li>Use the latest version to spin up your node. To do so, replace the version in the start-up command with the latest and run it</li> </ol> <p>Once your node is running again, you should see logs in your terminal.</p>"},{"location":"node-operators/networks/run-a-node/docker/#purge-your-node","title":"Purge Your Node","text":"<p>If you need a fresh instance of your Moonbeam node, you can purge your node by removing the associated data directory.</p> <p>You'll first need to stop the Docker container:</p> <pre><code>  sudo docker stop INSERT_CONTAINER_ID\n</code></pre> <p>If you did not use the <code>-v</code> flag to specify a local directory for storing your chain data when you spun up your node, then the data folder is related to the Docker container itself. Therefore, removing the Docker container will remove the chain data.</p> <p>If you did spin up your node with the <code>-v</code> flag, you will need to purge the specified directory. For example, for the suggested data directly, you can run the following command to purge your parachain and relay chain data:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/*\n</code></pre> <p>To only remove the parachain data for a specific chain, you can run:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/chains/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/chains/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/chains/*\n</code></pre> <p>Similarly, to only remove the relay chain data, you can run:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/polkadot/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/polkadot/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/polkadot/*\n</code></pre> <p>Now that your chain data has been purged, you can start a new node with a fresh data directory. You can install the newest version by repeating the instructions in this guide. Make sure you are using the latest tag available, which you can find on the Moonbeam GitHub Release page.</p>"},{"location":"node-operators/networks/run-a-node/docker/#purge-frontier-database","title":"Purge Your Frontier Database","text":"<p>To purge only the Frontier database of your Moonbeam node, follow these steps:</p> <ol> <li> <p>Stop the Docker container:</p> <pre><code>sudo docker stop INSERT_CONTAINER_ID\n</code></pre> </li> <li> <p>Remove the Frontier database folder:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/chains/moonbeam/frontier/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/chains/moonriver/frontier/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/chains/alphanet/frontier/*\n</code></pre> </li> <li> <p>Start the Docker container again using the start-up command for your node type</p> </li> </ol>"},{"location":"node-operators/networks/run-a-node/flags/","title":"Helpful Flags for Running a Node on Moonbeam","text":""},{"location":"node-operators/networks/run-a-node/flags/#introduction","title":"Introduction","text":"<p>When spinning up your own Moonbeam node, there are some required and optional flags that can be used. This guide will cover some of the most common flags and show you how to access all of the available flags.</p>"},{"location":"node-operators/networks/run-a-node/flags/#common-flags","title":"Common Flags","text":"<ul> <li><code>--collator</code>: Enables collator mode for collator candidates and, if eligible, allows the node to actively participate in block production.</li> <li><code>--port</code>: Specifies the peer-to-peer protocol TCP port. The default port for parachains is <code>30333</code> and <code>30334</code> for the embedded relay chain.</li> <li><code>--rpc-port</code>: Sets the unified port for both HTTP and WS connections. The default port for parachains is <code>9944</code> and <code>9945</code> for the embedded relay chain.</li> <li><code>--ws-port</code>: deprecated as of client v0.33.0, use <code>--rpc-port</code> for HTTP and WS connections instead - Sets the unified port for both HTTP and WS connections. The default port for parachains is <code>9944</code>  and <code>9945</code> for the embedded relay chain.</li> <li><code>--rpc-max-connections</code>: Specifies the maximum number of HTTP and WS server connections. The default is 100.</li> <li><code>--rpc-external</code> \u2014 Listen on all interfaces for JSON-RPC (HTTP &amp; WS). Use a proxy to filter unsafe methods on public endpoints. Use <code>--unsafe-rpc-external</code> to suppress the safety warning if you accept the risk.</li> <li><code>--rpc-methods</code> \u2014 Which RPC methods to expose. Options: <code>auto</code> (default), <code>safe</code>, <code>unsafe</code>.</li> <li><code>--rpc-cors</code> \u2014 Comma-separated allowed browser origins (<code>protocol://domain</code>) or <code>all</code> to disable validation. In <code>--dev</code>, default allows all origins.</li> <li><code>--rpc-rate-limit &lt;calls/min&gt;</code> \u2014 Per-connection rate limit. Disabled by default.  </li> <li><code>--rpc-rate-limit-whitelisted-ips &lt;CIDR&gt;...</code> \u2014 CIDR ranges exempt from the limit.  </li> <li><code>--rpc-rate-limit-trust-proxy-headers</code> \u2014 Trust <code>X-Forwarded-For</code> / <code>X-Real-IP</code> when behind a reverse proxy.</li> <li><code>--rpc-max-request-size &lt;MB&gt;</code> / <code>--rpc-max-response-size &lt;MB&gt;</code> \u2014 Max payload sizes (default <code>15</code> / <code>15</code>).</li> <li><code>--rpc-max-subscriptions-per-connection &lt;N&gt;</code> \u2014 Max concurrent subscriptions per connection (default <code>1024</code>).</li> <li><code>--rpc-message-buffer-capacity-per-connection &lt;N&gt;</code> \u2014 Per-connection queued message capacity before back-pressure (default <code>64</code>).</li> <li><code>--rpc-disable-batch-requests</code> and <code>--rpc-max-batch-request-len &lt;N&gt;</code> \u2014 Disable batch RPC or cap batch length.</li> <li><code>--ws-max-connections</code>: deprecated as of client v0.33.0, use <code>--rpc-max-connections</code> to adjust the combined HTTP and WS connection limit instead - Specifies the maximum number of HTTP and WS server connections. The default is 100.</li> <li><code>--wasm-execution</code>: Specifies the method for executing Wasm runtime code. The available options are:<ul> <li><code>compiled</code>: This is the default and uses the Wasmtime compiled runtime.</li> <li><code>interpreted-i-know-what-i-do</code>: Uses the wasmi interpreter.</li> </ul> </li> <li><code>--wasmtime-instantiation-strategy</code>: Controls WASM instantiation. Default is <code>pooling-copy-on-write</code> (fastest). Options include <code>recreate-instance-copy-on-write</code>, <code>pooling</code>, <code>recreate-instance</code>. CoW variants fall back where unsupported.</li> <li><code>--max-runtime-instances &lt;N&gt;</code>: Size of the runtime instances cache per runtime. Default <code>8</code>, max <code>32</code>.</li> <li><code>--runtime-cache-size &lt;N&gt;</code>: Max number of distinct runtimes cached simultaneously. Default <code>2</code>.  </li> <li><code>--wasmtime-precompiled &lt;PATH&gt;</code> / <code>--wasm-runtime-overrides &lt;PATH&gt;</code>: Use precompiled runtimes or local WASM overrides when version matches. Advanced/ops use only.</li> <li><code>--state-pruning</code>: Specifies the state pruning mode. For client versions prior to v0.27.0, the <code>--state-pruning</code> flag was named <code>--pruning</code>. If running a node with the <code>--collator</code> flag, the default is to keep the full state of all blocks. Otherwise, the state is only kept for the last 256 blocks. The available options are:<ul> <li><code>archive</code>: Keeps the full state of all blocks.</li> <li><code>&lt;number-of-blocks&gt;</code>: Specifies a custom number of blocks to keep the state for.</li> </ul> </li> <li><code>--trie-cache-size</code>: Specifies the size of the internal state cache in bytes. The default is <code>1073741824</code> (1 GB). Providing <code>0</code> disables the cache. For performance on collators and RPC nodes, values around 1\u20134 GB are common, depending on hardware. (Prior to client v0.27.0 this was <code>--state-cache-size</code>.)</li> <li><code>--db-cache</code>: Specifies the memory the database cache is limited to use. It is recommended to set it to 50% of the actual RAM your server has. For example, for 32 GB RAM, the value should be set to <code>16000</code>. The minimum value is <code>2000</code>, but it is below the recommended specs.</li> <li><code>--database</code>: Selects the DB backend. Options: <code>auto</code> (detect or create ParityDb), <code>paritydb</code>, <code>paritydb-experimental</code>, <code>rocksdb</code>. For most operators, <code>auto</code> is fine; RocksDB may be preferred by some for tooling familiarity.</li> <li><code>--blocks-pruning</code>: Prunes block bodies/justifications separately from state. Options:  </li> <li><code>archive</code>: keep all blocks,  </li> <li><code>archive-canonical</code>: keep finalized blocks only (default),  </li> <li><code>&lt;NUMBER&gt;</code>: keep the last <code>&lt;NUMBER&gt;</code> finalized blocks.</li> <li><code>--base-path</code>: Specifies the base path where your chain data is stored.</li> <li><code>--chain</code>: Specifies the chain specification to use. It can be a predefined chainspec such as <code>moonbeam</code>, <code>moonriver</code>, or <code>alphanet</code>. Or it can be a path to a file with the chainspec (such as the one exported by the <code>build-spec</code> command).</li> <li><code>--network-backend</code>: Select the P2P stack. Options:  </li> <li><code>litep2p</code> (default) \u2014 lightweight, lower CPU usage, ecosystem is migrating here.  </li> <li><code>libp2p</code> \u2014 legacy backend kept for compatibility.</li> <li><code>--name</code>: Specifies a human-readable name for the node, which can be seen on telemetry, if enabled.</li> <li><code>--telemetry-url</code>: Specifies the URL of the telemetry server to connect to. This flag can be passed multiple times as a means to specify multiple telemetry endpoints. This flag takes two parameters: the URL and the verbosity level. Verbosity levels range from 0-9, with 0 denoting the least verbosity. Expected format is '', e.g. <code>--telemetry-url 'wss://foo/bar 0'</code>. <li><code>--no-telemetry</code>: Disable telemetry entirely (it is on by default on global chains).</li> <li><code>--prometheus-external</code>: Expose Prometheus metrics on all interfaces (default is local).</li> <li><code>--no-prometheus</code>: Disable the Prometheus endpoint.</li> <li><code>--no-prometheus-prefix</code>: Remove the <code>moonbeam</code> prefix from metric names.</li> <li><code>--in-peers</code>: Specifies the maximum number of inbound full-node peers. The default is <code>32</code>.</li> <li><code>--out-peers</code>: Specifies the target number of outbound peers to maintain. The default is <code>8</code>.</li> <li><code>--reserved-nodes &lt;ADDR&gt;...</code> / <code>--reserved-only</code>: Pin to a set of peers and (optionally) sync only with them. Useful for private clusters or RPC nodes behind sentry/topology.</li> <li><code>--no-hardware-benchmarks</code>: Skip automatic CPU/memory/disk benchmarks at startup (also suppresses sending these to telemetry if enabled).</li> <li><code>--public-addr &lt;MULTIADDR&gt;...</code> / <code>--listen-addr &lt;MULTIADDR&gt;...</code>: Advertised vs listen multiaddresses for P2P. Use when behind NAT/proxies.</li> <li><code>--no-private-ip</code> / <code>--allow-private-ip</code>: Forbid/allow private address peering depending on environment.</li> <li><code>--in-peers-light &lt;N&gt;</code>: Max inbound light-client peers (default <code>100</code>).</li> <li><code>--max-parallel-downloads &lt;N&gt;</code>: How many peers to request the same announced blocks from in parallel. Default <code>5</code>.</li> <li><code>--runtime-cache-size 64</code>: Configures the number of different runtime versions preserved in the in-memory cache to 64.</li> <li><code>--eth-log-block-cache</code>: Size in bytes the LRU cache for block data is limited to use. This flag mostly pertains to RPC providers. The default is <code>300000000</code>.</li> <li><code>--eth-statuses-cache</code>: Size in bytes the LRU cache for transaction statuses data is limited to use. This flag mostly pertains to RPC providers. The default is <code>300000000</code>.</li> <li><code>--sync</code>: Sets the blockchain syncing mode, which can allow for the blockchain to be synced faster. The available options are:<ul> <li><code>full</code>: Downloads and validates the full blockchain history.</li> <li><code>fast</code>: Downloads blocks without executing them and downloads the latest state with proofs.</li> <li><code>fast-unsafe</code>: Same as <code>fast</code>, but skips downloading the state proofs.</li> <li><code>warp</code>: Downloads the latest state and proof.</li> </ul> </li> <li><code>--prometheus-port</code>: Specifies a custom Prometheus port.</li> <li><code>--lazy-loading-remote-rpc</code>: Allows lazy loading by relying on a specified RPC endpoint for network state until the node is fully synchronized e.g. <code>--lazy-loading-remote-rpc 'https://moonbeam.unitedbloc.com'</code>, as long as the specified RPC endpoint has sufficient rate limits to handle the expected load. Private (API key) endpoints are strongly recommended over public endpoints.</li> <li><code>--lazy-loading-block</code>: Optional parameter to specify the block hash for lazy loading. This parameter allows you to specify a block hash from which to start loading data. If not provided, the latest block will be used.</li> <li><code>--lazy-loading-state-overrides</code>: Optional parameter to specify state overrides during lazy loading. This parameter allows you to provide a path to a file containing state overrides. The file can contain any custom state modifications that should be applied.</li> <li><code>--lazy-loading-runtime-override</code>: Optional parameter to specify a runtime override when starting the lazy loading. If not provided, it will fetch the runtime from the block being forked.</li> <li><code>--lazy-loading-delay-between-requests</code>: The delay (in milliseconds) between RPC requests when using lazy loading. This parameter controls the amount of time to wait between consecutive RPC requests. This can help manage request rate and avoid overwhelming the server. Default value is <code>100</code> milliseconds.</li> <li><code>--lazy-loading-max-retries-per-request</code>: The maximum number of retries for an RPC request when using lazy loading. Default value is <code>10</code> retries.</li> <li><code>--pool-type</code>: Selects the transaction pool implementation. The available options are:<ul> <li><code>fork-aware</code>: Tracks pending transactions across competing forks (\"views\"), which reduces dropped/re-validated transactions and nonce/order glitches during brief reorgs. This is the default on current Moonbeam builds (Polkadot SDK change; default from ~RT3600+) and is recommended on collators and RPC nodes.</li> <li><code>single-state</code>: Uses the legacy single-view pool. On older binaries, explicitly set <code>--pool-type=fork-aware</code> to opt in to the improved implementation.</li> </ul> </li> <li><code>--pool-limit &lt;N&gt;</code>: Max number of transactions in the pool. Default <code>8192</code>.</li> <li><code>--pool-kbytes &lt;KB&gt;</code>: Max total size of pending transactions. Default <code>20480</code> (\u224820 MB).</li> <li><code>--tx-ban-seconds &lt;S&gt;</code>: How long to ban invalid transactions. Default <code>1800</code> seconds.</li> <li><code>--relay-chain-rpc-urls &lt;URL&gt;...</code>: Reduce resource usage by fetching relay-chain data from remote RPC(s). The node will try the URLs in order and fall back if a connection fails. Still connects to the relay chain network but with lower bandwidth.</li> <li><code>--relay-chain-light-client</code> (experimental, full nodes only): Embed a relay-chain light client. Uses the specified relay-chain chainspec.</li> <li><code>--offchain-worker &lt;mode&gt;</code>: Enable offchain workers. Options: <code>always</code>, <code>never</code>, <code>when-authority</code> (default).</li> <li><code>--enable-offchain-indexing &lt;true|false&gt;</code>: Allow the runtime to write directly to the offchain workers DB during block import. Default <code>false</code>.</li>"},{"location":"node-operators/networks/run-a-node/flags/#execution-strategy","title":"Execution Strategy Flags","text":"<p>These tune how the runtime executes in different contexts:</p> <ul> <li><code>--execution</code>: Global default for all contexts. Options: <code>native</code>, <code>wasm</code>, <code>both</code>, <code>native-else-wasm</code>.</li> <li><code>--execution-syncing</code>, <code>--execution-import-block</code>, <code>--execution-block-construction</code>, <code>--execution-offchain-worker</code>, <code>--execution-other</code>: Override per-context behavior with the same option set as above.</li> </ul> <p><code>Native-else-wasm</code> and <code>both</code> can help diagnose native/wasm divergence during upgrades; <code>wasm</code> is safest but slower.</p>"},{"location":"node-operators/networks/run-a-node/flags/#flags-for-sql-backend","title":"Flags for Configuring a SQL Backend","text":"<ul> <li><code>--frontier-backend-type</code>: Sets the Frontier backend type to one of the following options:<ul> <li><code>key-value</code>: Uses either RocksDB or ParityDB as per inherited from the global backend settings. This is the default option and RocksDB is the default backend.</li> <li><code>sql</code>: Uses a SQL database with custom log indexing.</li> </ul> </li> <li><code>frontier-sql-backend-pool-size</code>: Sets the Frontier SQL backend's maximum number of database connections that a connection pool can simultaneously handle. The default is <code>100</code>.</li> <li><code>frontier-sql-backend-num-ops-timeout</code>: Sets the Frontier SQL backend's query timeout in number of VM operations. The default is <code>10000000</code>.</li> <li><code>frontier-sql-backend-thread-count</code>: Sets the Frontier SQL backend's auxiliary thread limit. The default is <code>4</code>.</li> <li><code>frontier-sql-backend-cache-size</code>: Sets the Frontier SQL backend's cache size in bytes. The default value is 200MB, which is <code>209715200</code> bytes.</li> </ul>"},{"location":"node-operators/networks/run-a-node/flags/#how-to-access-all-of-the-available-flags","title":"How to Access All of the Available Flags","text":"<p>For a complete list of the available flags, you can spin up your Moonbeam node with <code>--help</code> added to the end of the command. The command will vary depending on how you choose to spin up your node, and if you're using Docker or Systemd.</p>"},{"location":"node-operators/networks/run-a-node/flags/#docker","title":"Docker","text":"MoonbeamMoonriverMoonbase Alpha <pre><code>docker run --network=\"host\" -v \"/var/lib/moonbeam-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--help\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/moonriver-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--help\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/alphanet-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoonbeamfoundation/moonbeam:v0.49.2 \\\n--help\n</code></pre>"},{"location":"node-operators/networks/run-a-node/flags/#systemd","title":"Systemd","text":"MoonbeamMoonriverMoonbase Alpha <pre><code># If you used the release binary\n./moonbeam --help\n\n# Or if you compiled the binary\n./target/release/moonbeam --help\n</code></pre> <pre><code># If you used the release binary\n./moonbeam --help\n\n# Or if you compiled the binary\n./target/release/moonbeam --help\n</code></pre> <pre><code># If you used the release binary\n./moonbeam --help\n\n# Or if you compiled the binary\n./target/release/moonbeam --help\n</code></pre>"},{"location":"node-operators/networks/run-a-node/overview/","title":"Run a Node on Moonbeam","text":""},{"location":"node-operators/networks/run-a-node/overview/#introduction","title":"Introduction","text":"<p>Running a full node on a Moonbeam-based network allows you to connect to the network, sync with a bootnode, obtain local access to RPC endpoints, author blocks on the parachain, and more.</p> <p>There are multiple deployments of Moonbeam, including the Moonbase Alpha TestNet, Moonriver on Kusama, and Moonbeam on Polkadot. Here's how these environments are named and their corresponding chain specification file names:</p> Network Hosted By Chain Name Moonbase Alpha Moonbeam Foundation alphanet Moonriver Kusama moonriver Moonbeam Polkadot moonbeam <p>Note</p> <p>Moonbase Alpha is still considered an Alphanet, and as such will not have 100% uptime. The parachain might be purged as needed. During the development of your application, make sure you implement a method to redeploy your contracts and accounts to a fresh parachain quickly. If a chain purge is required, it will be announced via our Discord channel at least 24 hours in advance.</p>"},{"location":"node-operators/networks/run-a-node/overview/#requirements","title":"Requirements","text":"<p>Running a parachain node is similar to a typical Substrate node, but there are some differences. A Substrate parachain node is a bigger build because it contains code to run the parachain itself, as well as code to sync the relay chain and facilitate communication between the two. As such, this build is quite large and may take over 30 min and require 32GB of memory.</p> <p>The minimum specs recommended to run a node are shown in the following table. For our Kusama and Polkadot MainNet deployments, disk requirements will be higher as the network grows.</p> MoonbeamMoonriverMoonbase Alpha Component Requirement CPU 8 Cores (Fastest per core speed) RAM 16 GB SSD 3 TB (recommended) Firewall P2P port must be open to incoming traffic:\u00a0 \u00a0 - Source: Any\u00a0 \u00a0 - Destination: 30333, 30334 TCP Component Requirement CPU 8 Cores (Fastest per core speed) RAM 16 GB SSD 2 TB (recommended) Firewall P2P port must be open to incoming traffic:\u00a0 \u00a0 - Source: Any\u00a0 \u00a0 - Destination: 30333, 30334 TCP Component Requirement CPU 8 Cores (Fastest per core speed) RAM 16 GB SSD 2 TB (recommended) Firewall P2P port must be open to incoming traffic:\u00a0 \u00a0 - Source: Any\u00a0 \u00a0 - Destination: 30333, 30334 TCP <p>Note</p> <p>If you don't see an <code>Imported</code> message (without the <code>[Relaychain]</code> tag) when running a node, you might need to double-check your port configuration.</p>"},{"location":"node-operators/networks/run-a-node/overview/#running-ports","title":"Running Ports","text":"<p>As stated before, the relay/parachain nodes will listen on multiple ports. The default Substrate ports are used in the parachain, while the relay chain will listen on the next higher port.</p> <p>The only ports that need to be open for incoming traffic are those designated for P2P. Collators must not have RPC or WS ports opened.</p> <p>Note</p> <p>As of client v0.33.0, the <code>--ws-port</code> and <code>--ws-max-connections</code> flags have been deprecated and removed in favor of the <code>--rpc-port</code> and <code>--rpc-max-connections</code> flags for both RPC and WSS connections. The default port is <code>9944</code>, and the default maximum number of connections is set to 100.</p>"},{"location":"node-operators/networks/run-a-node/overview/#default-ports-for-a-parachain-full-node","title":"Default Ports for a Parachain Full-Node","text":"Description Port P2P 30333 (TCP) RPC &amp; WS 9944 Prometheus 9615"},{"location":"node-operators/networks/run-a-node/overview/#default-ports-of-embedded-relay-chain","title":"Default Ports of Embedded Relay Chain","text":"Description Port P2P 30334 (TCP) RPC &amp; WS 9945 Prometheus 9616"},{"location":"node-operators/networks/run-a-node/overview/#installation","title":"Installation","text":"<p>There are a couple different guides to help you get started running a Moonbeam-based node:</p> <ul> <li>Using Docker - this method provides a quick and easy way to get started with a Docker container</li> <li>Using Systemd - this method is recommended for those with experience compiling a Substrate node</li> </ul>"},{"location":"node-operators/networks/run-a-node/overview/#debug-trace-txpool-apis","title":"Debug, Trace and TxPool APIs","text":"<p>You can also gain access to some non-standard RPC methods by running a tracing node, which allow developers to inspect and debug transactions during runtime. Tracing nodes use a different Docker image than a standard Moonbase Alpha, Moonriver, or Moonbeam node. Check out the Run a Tracing Node guide and be sure to switch to the right network tab throughout the instructions. Then to interact with your tracing node, check out the Debug &amp; Trace guide.</p>"},{"location":"node-operators/networks/run-a-node/overview/#lazy-loading","title":"Lazy Loading","text":"<p>Lazy loading lets a Moonbeam node operate while downloading network state in the background, eliminating the need to wait for full synchronization before use. You can activate lazy loading with the following flag:</p> <ul> <li><code>--lazy-loading-remote-rpc</code> - allows lazy loading by relying on a specified RPC for network state until the node is fully synchronized e.g. <code>--lazy-loading-remote-rpc 'INSERT-RPC-URL'</code></li> </ul> <p>Upon spooling up a node with this feature, you'll see output like the following:</p> [Lazy loading \ud83c\udf17]     You are now running the Moonbeam client in lazy loading mode, where data is retrieved     from a live RPC node on demand.     Using remote state from: https://moonbeam.unitedbloc.com     Forking from block: 8482853     To ensure the client works properly, please note the following:         1. *Avoid Throttling*: Ensure that the backing RPC node is not limiting the number of         requests, as this can prevent the lazy loading client from functioning correctly;         2. *Be Patient*: As the client may take approximately 20 times longer than normal to         retrieve and process the necessary data for the requested operation.     The service will start in 10 seconds... <p>Note</p> <p>Lazy loading a Moonbeam requires a large number of RPC requests. To avoid being rate-limited by a public endpoint, it's highly recommended to use a dedicated endpoint.  </p> <p>You can further customize your use of the lazy loading functionality with the following optional parameters:</p> <ul> <li><code>--lazy-loading-block</code> - specifies a block hash from which to start loading data. If not provided, the latest block will be used</li> <li><code>--lazy-loading-delay-between-requests</code> - the delay (in milliseconds) between RPC requests when using lazy loading. This parameter controls the amount of time to wait between consecutive RPC requests. This can help manage request rate and avoid overwhelming the server. Default value is <code>100</code> milliseconds</li> <li><code>--lazy-loading-max-retries-per-request</code> - the maximum number of retries for an RPC request when using lazy loading. Default value is <code>10</code> retries</li> <li><code>--lazy-loading-runtime-override</code> - path to a WASM file to override the runtime when forking. If not provided, it will fetch the runtime from the block being forked</li> <li><code>--lazy-loading-state-overrides</code> - path to a JSON file containing state overrides to be applied when forking </li> </ul> <p>The state overrides file should define the respective pallet, storage item, and value that you seek to override as follows:</p> <pre><code>[\n {\n     \"pallet\": \"System\",\n     \"storage\": \"SelectedCandidates\",\n     \"value\": \"0x04f24ff3a9cf04c71dbc94d0b566f7a27b94566cac\"\n }\n]\n</code></pre>"},{"location":"node-operators/networks/run-a-node/overview/#logs-and-troubleshooting","title":"Logs and Troubleshooting","text":"<p>You will see logs from both the relay chain and the parachain. The relay chain will be prefixed by <code>[Relaychain]</code>, while the parachain has no prefix.</p>"},{"location":"node-operators/networks/run-a-node/overview/#p2p-ports-not-open","title":"P2P Ports Not Open","text":"<p>If you don't see an <code>Imported</code> message (without the <code>[Relaychain]</code> tag), you need to check the P2P port configuration. P2P port must be open to incoming traffic.</p>"},{"location":"node-operators/networks/run-a-node/overview/#in-sync","title":"In Sync","text":"<p>Both chains must be in sync at all times, and you should see either <code>Imported</code> or <code>Idle</code> messages and have connected peers.</p>"},{"location":"node-operators/networks/run-a-node/overview/#genesis-mismatching","title":"Genesis Mismatching","text":"<p>The Moonbase Alpha TestNet may need to be purged and upgraded once in a while. Consequently, you may see the following message:</p> <pre><code>DATE [Relaychain] Bootnode with peer id `ID` is on a different\nchain (our genesis: GENESIS_ID theirs: OTHER_GENESIS_ID)\n</code></pre> <p>This typically means that you are running an older version and will need to upgrade.</p> <p>We announce the upgrades (and corresponding chain purge) via our Discord channel at least 24 hours in advance.</p> <p>Instructions for purging chain data will vary slightly depending on how you spun up your node:</p> <ul> <li>For Docker, you can check out the Purge Your Node section of the Using Docker page</li> <li>For Systemd, you can take a look at the Purge Your Node section of the Using Systemd page</li> </ul>"},{"location":"node-operators/networks/run-a-node/systemd/","title":"Run a Node on Moonbeam Using Systemd","text":""},{"location":"node-operators/networks/run-a-node/systemd/#introduction","title":"Introduction","text":"<p>Running a full node on a Moonbeam-based network allows you to connect to the network, sync with a bootnode, obtain local access to RPC endpoints, author blocks on the parachain, and more.</p> <p>In this guide, you'll learn how to spin up a Moonbeam node using Systemd and how to maintain and purge your node.</p> <p>If you're interested in compiling the binary yourself, which may take over 30 min and require 32GB of memory, you can check out the Manually Compile the Moonbeam Binary guide.</p>"},{"location":"node-operators/networks/run-a-node/systemd/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>The following sections go through the process of using the binary and running a Moonbeam full node as a systemd service. To get started, you'll need to:</p> <ul> <li>Make sure you're running Ubuntu 18.04, 20.04, or 22.04. Moonbeam may work with other Linux flavors, but Ubuntu is currently the only tested version</li> <li>Make sure that your system meets the requirements. When connecting to Moonriver on Kusama or Moonbeam on Polkadot, it will take a few days to completely sync the embedded relay chain</li> </ul>"},{"location":"node-operators/networks/run-a-node/systemd/#the-release-binary","title":"Download the Latest Release Binary","text":"<p>To download the latest release binary, take the following steps:</p> <ol> <li> <p>Create a directory to store the binary and chain data (you might need <code>sudo</code>)</p> MoonbeamMoonriverMoonbase Alpha <pre><code>mkdir /var/lib/moonbeam-data\n</code></pre> <pre><code>mkdir /var/lib/moonriver-data\n</code></pre> <pre><code>mkdir /var/lib/alphanet-data\n</code></pre> </li> <li> <p>Use <code>wget</code> to grab the latest release binary and output it to the directory created in the previous step</p> MoonbeamMoonriverMoonbase Alpha <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/v0.49.2/moonbeam \\\n-O /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/v0.49.2/moonbeam \\\n-O /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/v0.49.2/moonbeam \\\n-O /var/lib/alphanet-data/moonbeam\n</code></pre> </li> <li> <p>To verify that you have downloaded the correct version, you can run the following command in your terminal</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sha256sum /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>sha256sum /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>sha256sum /var/lib/alphanet-data/moonbeam\n</code></pre> <p>You should receive the following output:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>88fd7e94f257c5bff7a2b4fbe3dc1c00fd24fcc4943440a03e059778dfcb266d\n</code></pre> <pre><code>88fd7e94f257c5bff7a2b4fbe3dc1c00fd24fcc4943440a03e059778dfcb266d\n</code></pre> <pre><code>88fd7e94f257c5bff7a2b4fbe3dc1c00fd24fcc4943440a03e059778dfcb266d\n</code></pre> </li> </ol>"},{"location":"node-operators/networks/run-a-node/systemd/#set-up-the-service","title":"Set Up the Service","text":"<p>The following commands will set up everything regarding running the service:</p> <ol> <li> <p>Create a service account to run the service</p> MoonbeamMoonriverMoonbase Alpha <pre><code>adduser moonbeam_service --system --no-create-home\n</code></pre> <pre><code>adduser moonriver_service --system --no-create-home\n</code></pre> <pre><code>adduser moonbase_service --system --no-create-home\n</code></pre> </li> <li> <p>Ensure that you properly configure the ownership and permissions for the local directory housing the chain data, and also remember to grant execute permission to the binary file</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo chown -R moonbeam_service /var/lib/moonbeam-data\nsudo chmod +x /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>sudo chown -R moonriver_service /var/lib/moonriver-data\nsudo chmod +x /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>sudo chown -R moonbase_service /var/lib/alphanet-data\nsudo chmod +x /var/lib/alphanet-data/moonbeam\n</code></pre> </li> </ol>"},{"location":"node-operators/networks/run-a-node/systemd/#create-the-configuration-file","title":"Create the Configuration File","text":"<p>Next, create the systemd service file. If you're configuring a collator node, use the collator-specific configuration snippets below.</p> <p>First, you'll need to create a file named <code>/etc/systemd/system/moonbeam.service</code> to store the configurations.</p> <p>Note that in the following start-up configurations, you have to:</p> <ul> <li>Replace <code>INSERT_YOUR_NODE_NAME</code> with your node name of choice. You'll have to do this in two places: one for the parachain and one for the relay chain</li> <li>Replace <code>INSERT_RAM_IN_MB</code> for 50% of the actual RAM your server has. For example, for 32GB of RAM, the value must be set to <code>16000</code>. The minimum value is <code>2000</code>, but it is below the recommended specs</li> <li>Double-check that the binary is in the proper path as described below (ExecStart)</li> <li>Double-check the base path if you've used a different directory</li> </ul> <p>For an overview of the flags used in the following start-up commands, plus additional commonly used flags, please refer to the Flags page of our documentation.</p>"},{"location":"node-operators/networks/run-a-node/systemd/#full-node","title":"Full Node","text":"MoonbeamMoonriverMoonbase Alpha <pre><code>[Unit]\nDescription=\"Moonbeam systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbeam_service\nSyslogIdentifier=moonbeam\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonbeam-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonbeam-data \\\n     --chain moonbeam \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Moonriver systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonriver_service\nSyslogIdentifier=moonriver\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonriver-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonriver-data \\\n     --chain moonriver \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Moonbase Alpha systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbase_service\nSyslogIdentifier=moonbase\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/alphanet-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/alphanet-data \\\n     --chain alphanet \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/networks/run-a-node/systemd/#allow-external-access","title":"Allow External Access to Your Node","text":"<p>If you want to run an RPC endpoint, connect to Polkadot.js Apps, or run your own application, you can use the <code>--unsafe-rpc-external</code> flag to run the full node with external access to the RPC ports.</p> Example start-up command for Moonbeam <pre><code>[Unit]\nDescription=\"Moonbeam systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbeam_service\nSyslogIdentifier=moonbeam\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonbeam-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonbeam-data \\\n     --chain moonbeam \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     --unsafe-rpc-external \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/networks/run-a-node/systemd/#use-sql","title":"Use a SQL Backend for Frontier","text":"<p>The default Frontier database, which comes standard with Moonbeam nodes and contains all of the Ethereum-related elements, such as transactions, blocks, and logs, can be modified to use a SQL backend. Since <code>eth_getLogs</code> is a very resource-intensive method, the SQL backend aims to provide a more performant alternative for indexing and querying Ethereum logs in comparison to the default RocksDB database.</p> <p>To spin up a node with a Frontier SQL backend, you'll need to add the <code>--frontier-backend-type sql</code> flag to your start-up command.</p> <p>There are additional flags you can use to configure the pool size, query timeouts, and more for your SQL backend; please refer to the Flags page for more information.</p> Example start-up command for Moonbeam <pre><code>[Unit]\nDescription=\"Moonbeam systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbeam_service\nSyslogIdentifier=moonbeam\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonbeam-data/moonbeam \\\n     --state-pruning archive \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonbeam-data \\\n     --chain moonbeam \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     --frontier-backend-type sql \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/networks/run-a-node/systemd/#collator","title":"Collator","text":"<p>Beginning with v0.39.0, new Moonbeam collator nodes will no longer generate session keys automatically on start-up. Nodes in existence prior to v0.39.0 do not need to make changes to how they handle session keys.</p> <p>When setting up a new node, run the following command to generate and store on disk the session keys that will be referenced in the start-up command:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>/var/lib/moonbeam-data/moonbeam key generate-node-key --base-path /var/lib/moonbeam-data --chain moonbeam &amp;&amp; sudo chown -R moonbeam_service /var/lib/moonbeam-data\n</code></pre> <pre><code>/var/lib/moonriver-data/moonbeam key generate-node-key --base-path /var/lib/moonriver-data --chain moonriver &amp;&amp; sudo chown -R moonriver_service /var/lib/moonriver-data\n</code></pre> <pre><code>/var/lib/alphanet-data/moonbeam key generate-node-key --base-path /var/lib/alphanet-data --chain alphanet  &amp;&amp; sudo chown -R moonbase_service  /var/lib/alphanet-data\n</code></pre> <p>Note</p> <p>This step can be bypassed using the <code>--unsafe-force-node-key-generation</code> parameter in the start-up command, although this is not the recommended practice.</p> <p>Now you can create the systemd configuration file:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>[Unit]\nDescription=\"Moonbeam systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbeam_service\nSyslogIdentifier=moonbeam\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonbeam-data/moonbeam \\\n     --collator \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonbeam-data \\\n     --chain moonbeam \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Moonriver systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonriver_service\nSyslogIdentifier=moonriver\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/moonriver-data/moonbeam \\\n     --collator \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/moonriver-data \\\n     --chain moonriver \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Moonbase Alpha systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=moonbase_service\nSyslogIdentifier=moonbase\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/alphanet-data/moonbeam \\\n     --collator \\\n     --trie-cache-size 1073741824 \\\n     --db-cache INSERT_RAM_IN_MB \\\n     --base-path /var/lib/alphanet-data \\\n     --chain alphanet \\\n     --name \"INSERT_YOUR_NODE_NAME\" \\\n     -- \\\n     --name \"INSERT_YOUR_NODE_NAME (Embedded Relay)\" \\\n     --sync fast\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/networks/run-a-node/systemd/#run-the-service","title":"Run the Service","text":"<p>Register and start the service by running:</p> <pre><code>systemctl enable moonbeam.service\nsystemctl start moonbeam.service\n</code></pre> <p>And lastly, verify that the service is running:</p> <pre><code>systemctl status moonbeam.service\n</code></pre>  systemctl status moonbeam.service \u2022 moonbeam.service - \"Moonbase Alpha systemd service\"    Loaded: loaded (/etc/systemd/system/moonbeam.service; enabled; vendor preset:&gt;    Active: active (running) since Tue 2025-07-10 09:04:26 UTC; 45 ago    Main PID: 52847 (moonbeam)    Tasks: 13 (limit: 4662)    Memory: 113.7M    CPU: 6.9995    CGroup: /system.slice/moonbeam.service        \u2514\u250052847 /var/lib/alphanet-data/moonbeam --state-pruning=archive --tri&gt; lines 1-9/9 (END) <p>You can also check the logs by executing:</p> <pre><code>journalctl -f -u moonbeam.service\n</code></pre> moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f @ Syncing 158.7 bps, target=#12361301 (9 peers), best: #35487 (0x527e...c72b), finalized #35328 (0xfcd2...828), # 239.9kiB/s 15.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 Syncing 150.7 bps, target=#5236155 (9 peers), best: #40870 (0x3659...c530), finalized #16793 (0x815...578), # 299.7kiB/s 10.6kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f Syncing 162.5 bps, target=#12361302 (9 peers), best: #36300 (0x9edb..b2c2), finalized #35985 (0x7345..e874), +256.6kiB/s 19.6kiB/s moonbase[52847]: 2025-07-10 09:04:26  Syncing 168.8 bps, target=#5236155 (9 peers), best: #41714 (0x2feb...3f10), finalized #17122 (0x4954...8161), +353.2kiB/s 11.4kB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f @ Syncing 181.3 bps, target=#12361303 (9 peers), best: #37208 (0xbad2...6c2d), finalized #36864 (0x3015..bd42), # 288.4kiB/s 14.8kiB/s moonbase[52847]: 2025-07-10 09:04:26 Syncing 161.9 bps, target=#5236155 (9 peers), best: #42525 (0x9711...0de7), finalized #17561 (0x56f4...ad20), # 310.0kiB/s 11.0kiB/s moonbase[52847]: 2025-07-10 09:04:26 [Relaychain] \ud83c\udf17 \u2699\ufe0f @ Syncing 166.0 bps, target=#12361303 (9 peers), best: #38039 (0xb19f445c), finalized #37888 (0x68bb...6900), +176.9kiB/s 13.1kiB/s moonbase[52847]: 2025-07-10 09:04:26 Syncing 183.7 bps, target=#5236155 (9 peers), best: #43444 (0xccd0...a18f), finalized #18073 (0xe474...2032), #357.3kiB/s 10.3kiB/s <p>During the syncing process, you will see logs from both the embedded relay chain ([Relaychain]) and the parachain ([\ud83c\udf17]). These logs display a target block (live network state) and a best block (local node synced state).</p> <p>Note</p> <p>It may take a few days to completely sync the embedded relay chain. Make sure that your system meets the requirements.</p> <p>If you need to stop the service for any reason, you can run:</p> <pre><code>systemctl stop moonbeam.service\n</code></pre>"},{"location":"node-operators/networks/run-a-node/systemd/#maintain-your-node","title":"Maintain Your Node","text":"<p>As Moonbeam development continues, it will sometimes be necessary to upgrade your node software. Node operators will be notified on our Discord channel when upgrades are available and whether they are necessary (some client upgrades are optional). The upgrade process is straightforward and is the same for a full node or collator.</p> <p>If you want to update your client, you can keep your existing chain data in tact, and only update the binary by following these steps:</p> <ol> <li> <p>Stop the systemd service</p> <pre><code>sudo systemctl stop moonbeam.service\n</code></pre> </li> <li> <p>Remove the old binary file</p> MoonbeamMoonriverMoonbase Alpha <pre><code>rm /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>rm /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>rm /var/lib/alphanet-data/moonbeam\n</code></pre> </li> <li> <p>Get the latest version of the Moonbeam release binary on GitHub and run the following command to update to that version</p> MoonbeamMoonriverMoonbase Alpha <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/INSERT_NEW_VERSION_TAG/moonbeam \\\n-O /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/INSERT_NEW_VERSION_TAG/moonbeam \\\n-O /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>wget https://github.com/moonbeam-foundation/moonbeam/releases/download/INSERT_NEW_VERSION_TAG/moonbeam \\\n-O /var/lib/alphanet-data/moonbeam\n</code></pre> <p>Note</p> <p>If you compiled the binary manually, you'll need to move the binary from <code>./target/release/moonbeam</code> to the data directory.</p> </li> <li> <p>Update permissions</p> MoonbeamMoonriverMoonbase Alpha <pre><code>chmod +x /var/lib/moonbeam-data/moonbeam\nchown moonbeam_service /var/lib/moonbeam-data/moonbeam\n</code></pre> <pre><code>chmod +x /var/lib/moonriver-data/moonbeam\nchown moonriver_service /var/lib/moonriver-data/moonbeam\n</code></pre> <pre><code>chmod +x /var/lib/alphanet-data/moonbeam\nchown moonbase_service /var/lib/alphanet-data/moonbeam\n</code></pre> </li> <li> <p>Start your service</p> <pre><code>systemctl start moonbeam.service\n</code></pre> </li> </ol> <p>To check the status of the service and/or logs, you can refer to the commands from before.</p>"},{"location":"node-operators/networks/run-a-node/systemd/#purge-your-node","title":"Purge Your Node","text":"<p>If you need a fresh instance of your Moonbeam node, you can purge your node by removing the associated data directory.</p> <p>You'll first need to stop the systemd service:</p> <pre><code>sudo systemctl stop moonbeam\n</code></pre> <p>To purge your parachain and relay chain data, you can run the following command:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/*\n</code></pre> <p>To only remove the parachain data for a specific chain, you can run:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/chains/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/chains/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/chains/*\n</code></pre> <p>Similarly, to only remove the relay chain data, you can run:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/polkadot/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/polkadot/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/polkadot/*\n</code></pre> <p>Now that your chain data has been purged, you can start a new node with a fresh data directory. You can install the newest version by repeating the instructions in this guide. Make sure you are using the latest tag available, which you can find on the Moonbeam GitHub Release page.</p>"},{"location":"node-operators/networks/run-a-node/systemd/#purge-frontier-database","title":"Purge Your Frontier Database","text":"<p>To purge only the Frontier database of your Moonbeam node, follow these steps:</p> <ol> <li> <p>Stop the systemd service:</p> <pre><code>sudo systemctl stop moonbeam.service\n</code></pre> </li> <li> <p>Remove the Frontier database folder:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>sudo rm -rf /var/lib/moonbeam-data/chains/moonbeam/frontier/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/moonriver-data/chains/moonriver/frontier/*\n</code></pre> <pre><code>sudo rm -rf /var/lib/alphanet-data/chains/alphanet/frontier/*\n</code></pre> </li> <li> <p>Start the systemd service:</p> <pre><code>sudo systemctl start moonbeam.service\n</code></pre> </li> </ol>"},{"location":"tokens/connect/ledger/","title":"Interacting with Moonbeam Using Ledger and the Ethereum App","text":""},{"location":"tokens/connect/ledger/#introduction","title":"Introduction","text":"<p>Hardware wallets provide a safer way to store crypto funds because the private key (used for signing transactions) is stored offline. Ledger offers two hardware wallet solutions at the time of writing: Ledger Nano S and Ledger Nano X.</p> <p>For Moonbeam, Moonriver, and the Moonbase Alpha TestNet, you can use the Ethereum app on Ledger Live by setting the chain ID. For Moonbeam, the chain ID is 1284, for Moonriver it's 1285, and for Moonbase Alpha it's 1287. The Ethereum app covers all supported Moonbeam-based networks and can be used to connect a Ledger device.</p> <p>In this tutorial, you will learn how to get started with your Ledger hardware wallet on Moonbeam using the Ethereum app. This guide only illustrates the steps for a Ledger Nano X device, but you can follow along with a Ledger Nano S as well. </p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/ledger/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before you get started, update Ledger Live to the latest version available. Also, make sure you've your Ledger hardware wallet device running the latest firmware. The Ledger support website offers tutorials on how to update the firmware.</p> <p>At the time of writing, the following versions were used:</p> <ul> <li>Ledger Live 2.35.1</li> <li>Ledger Nano S firmware v2.0.0</li> <li>Ledger Nano X firmware v2.0.1</li> </ul> <p>As of November 29, 2022, the Moonbeam and Ledger Live integration was released, allowing you to send and receive GLMR tokens with your Ledger device directly in Ledger Live. With this integration, you'll no longer need to connect your Ledger to MetaMask. If you prefer this method, please skip ahead to the Use Ledger Live to Send &amp; Receive GLMR section of this guide.</p> <p>If you prefer to use MetaMask as an intermediary between your Ledger device and Moonbeam, make sure that your MetaMask is connected to Moonbeam.</p> <p>As of MetaMask version 10.5.0, connecting your Ledger device with MetaMask on Chrome is easy again. You just need to have the latest version of MetaMask installed.</p>"},{"location":"tokens/connect/ledger/#install-the-ledger-live-app","title":"Install the Ledger Live App","text":"<p>If you want to connect to Moonbeam, Moonriver, or the Moonbase Alpha TestNet you can do so by installing the Ethereum app, and later on you'll need to specify a chain ID.</p> <p>To get started, open up Ledger Live and:</p> <ol> <li>Select Manager from the menu</li> <li>Connect and unlock your device (this must be done before installation)</li> <li>In the App catalog search for Ethereum (ETH) and click Install. Your Ledger device will show Processing and once the installation is complete, the app will appear on your Ledger device</li> </ol> <p>In the Ledger Live app, depending on which app(s) you installed you should see them listed under the Apps installed tab on the Manager page. After the app(s) have been successfully installed, you can close out of Ledger Live. </p> <p></p>"},{"location":"tokens/connect/ledger/#import-your-ledger-account-to-metamask","title":"Import your Ledger Account to MetaMask","text":"<p>Now that you've installed the app(s) on Ledger Live, you can connect your Ledger to the computer and unlock it, and open the Ethereum app. </p> <p>Then import your Ledger account to MetaMask using the following steps:</p> <ol> <li>Click on the top-right logo to expand the menu</li> <li>Select Connect Hardware Wallet</li> </ol> <p></p> <p>In the next screen, you are prompted to select which hardware wallet you'll like to use in MetaMask. At the moment of writing, only Ledger and Trezor hardware wallets are supported. Here, take the following steps:</p> <ol> <li>Select the Ledger logo</li> <li>Click on Continue</li> </ol> <p></p> <p>If you're using Chrome or a Chrome-based browser like Brave, you'll be prompted to select your Ledger device to connect via WebHID:</p> <ol> <li>Select your Ledger device from the pop-up</li> <li>Click Connect</li> </ol> <p></p> <p>If a pop-up doesn't appear, you may need to change your MetaMask settings to enable a WebHID connection. You can check and update your MetaMask settings by following these steps:</p> <ol> <li>Expand the top-right menu and go to Settings </li> <li>Navigate to Advanced</li> <li>Scroll down to Preferred Ledger Connection Type and select WebHID from the dropdown</li> </ol> <p>Note</p> <p>The Preferred Ledger Connection Type setting is only available on Chrome and Chrome-based browsers. This setting doesn't exist on other browsers such as Firefox.</p> <p>If MetaMask was able to connect successfully to your Ledger device, you should see a list of five Moonbeam/Ethereum-styled accounts. If not, double-check that Ledger Live is closed, you've connected your Ledger device to the computer, and unlocked it, and make sure the Ethereum app is open.</p>"},{"location":"tokens/connect/ledger/#import-accounts-and-view-balances","title":"Import Accounts and View Balances","text":"<p>From the list of accounts, take the following steps:</p> <ol> <li>Select the accounts you would like to import from your Ledger device</li> <li>Click on Unlock</li> </ol> <p></p> <p>If you've imported your Ledger account successfully, you should see your account and balance displayed in the main MetaMask screen like shown in the following image:</p> <p></p> <p>You can switch accounts in MetaMask at any time to view the balance of your other imported Ledger accounts.</p> <p>You've now successfully imported a Moonbeam compatible account from your Ledger device and are now ready to start interacting with your Ledger device.</p>"},{"location":"tokens/connect/ledger/#receive-tokens","title":"Receive Tokens","text":"<p>To get started interacting with your Ledger device, you will need to send some funds to it. Copy your address from MetaMask by clicking on your account name and address in MetaMask.</p> <p></p> <p>Next, you will need to obtain some GLMR, MOVR, or DEV tokens and using the address you just copied, send the tokens to your account. After the transaction has successfully gone through, you will see your balance update.</p> <p>You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet.</p>"},{"location":"tokens/connect/ledger/#send-tokens","title":"Send Tokens","text":"<p>Next up is sending and signing transactions on Moonbeam using your Ledger device. To get started sending a transaction, click on the Send button:</p> <p></p> <p>As you would in a standard transaction, set the recipient address, enter the number of tokens to send, review transaction details and confirm it. This will initiate the transaction signature wizard in your Ledger device. Here, take the following steps:</p> <ol> <li>Click the button to proceed to the next screen. Your Ledger device is only warning you to review the transaction</li> <li>Check the number of tokens being sent then proceed to the next screen</li> <li>Check the recipient's address and proceed to the next screen</li> <li>Check the chain ID of the network. This information confirms which network MetaMask is connected to. For Moonbeam the chain ID is 1284 (hex: 0x504), Moonriver is 1285 (hex: 0x505), and Moonbase Alpha is 1287 (hex: 0x507). When ready, proceed to the next screen</li> <li>Check the max fees applicable to this transaction. This is the gas price multiplied by the gas limit you've set on MetaMask. When ready, proceed to the next screen</li> <li>If you agree with all the transaction details, approve it. This will sign the transaction and will trigger MetaMask to send it. If you don't agree with all the transaction details, reject it. This will cancel the transaction, and MetaMask will mark it as failed</li> </ol> <p></p> <p>Right after you've approved the transaction, MetaMask sends it to the network. Once the transaction is confirmed, it will be displayed as Send on the Activity tab in MetaMask.</p> <p></p> <p>And that is it! You've signed a transaction and sent some tokens on Moonbeam using your Ledger hardware wallet!</p>"},{"location":"tokens/connect/ledger/#interact-with-contracts-using-your-ledger","title":"Interact with Contracts Using your Ledger","text":"<p>By default, Ledger devices don't admit a <code>data</code> field in the transaction object. Consequently, users can't deploy or interact with smart contracts.</p> <p>However, if you want to use your Ledger hardware wallet for transactions related to smart contracts, you need to change a configuration parameter inside the app on your device. To do so, take the following steps:</p> <ol> <li>On your Ledger, open the Moonriver or Ethereum app</li> <li>Navigate to Settings</li> <li>Find the Blind signing page. It should state NOT Enabled at the bottom</li> <li>Select/validate the option to change its value to Enabled</li> </ol> <p>Note</p> <p>This option is necessary to use your Ledger device to interact with ERC-20 token contracts that might live inside the Moonbeam ecosystem.</p> <p></p>"},{"location":"tokens/connect/ledger/#use-ledger-live","title":"Use Ledger Live to Send &amp; Receive GLMR","text":"<p>You can also use your Ledger device to send and receive GLMR tokens securely from within Ledger Live. This enables you to manage your GLMR tokens without connecting your device to MetaMask.</p> <p>When you open up the Ledger Live app, make sure that you've installed the latest updates. If there are any pending updates that need to be installed, there will be a banner at the top of the screen that prompts you to install the updates.</p> <p>To get started, you'll need to login to your Ledger device to unlock it. From Ledger Live, click on My Ledger. On your device, you'll be prompted to allow Ledger manager; you can click both buttons on your device to allow it.</p> <p>Once on the Ledger manager, you'll need to make sure that your firmware is up to date, and if the Moonbeam and/or Ethereum apps need to be updated, go ahead and install the latest versions.</p> <p>Next, you'll need to add an account to your Ledger Live app. To do so, you can take the following steps:</p> <ol> <li>Click on Accounts from the left-side menu</li> <li>Select Add account</li> <li>A dropdown will appear. Search for GLMR and Moonbeam (GLMR) should appear for you to select</li> <li>Click Continue</li> </ol> <p></p> <p>Next, you'll be able to enter an account name and click Add account. If your account was successfully added, you can click Done and your account will appear in your list of accounts.</p>"},{"location":"tokens/connect/ledger/#receive-tokens_1","title":"Receive Tokens","text":"<p>To receive GLMR to your Ledger device, you can take the following steps from Ledger Live:</p> <ol> <li>Click on Receive from the left-side menu</li> <li>A pop-up will appear. You can select your Moonbeam account where you want to receive tokens from the Account to credit dropdown</li> <li>Click Continue</li> </ol> <p></p> <p>Next, your address should appear on Ledger Live, and you'll be prompted to verify your address on your Ledger device. On your device, you can take the following steps:</p> <ol> <li>You should see Verify Address on your device's screen. Click the right button to start verifying your address</li> <li>On the next screen, you should see your address. Compare the address on your device to the one displayed on Ledger Live and verify it matches. At this time, you'll want to copy the address from Ledger Live so you can send a transaction to it. Click the right button to continue</li> <li>Now, you should see the Approve screen. If the addresses match, you can click both buttons on your device to approve the verification. Otherwise, click the right button again to get to the Reject screen where you can click both buttons to reject the verification</li> </ol> <p></p> <p>Over on Ledger Live, you'll see that your address has been shared securely, and you can click Done. Now, you can send some GLMR to your Ledger account.</p>"},{"location":"tokens/connect/ledger/#send-tokens_1","title":"Send Tokens","text":"<p>To send GLMR from your Ledger device, you can take the following steps from Ledger Live:</p> <ol> <li>Click on Send from the left-side menu</li> <li>A pop-up will appear. From the Account to debit dropdown, you can select your Moonbeam account that you want to send tokens from</li> <li>Enter an address in the Receipient address field</li> <li>Click Continue</li> </ol> <p></p> <p>On the next screen, you can enter the amount of GLMR that you would like to send and click Continue.</p> <p></p> <p>The last step on Ledger Live is to verify that the transaction details are correct. If everything looks good, you can click Continue. Then you'll be prompted to confirm the transaction on your Ledger device:</p> <ol> <li>The first screen will be the Review transaction screen. Click the right button to proceed to the next screen</li> <li>Verify the amount of GLMR you're sending and click the right button to proceed</li> <li>Verify the address you're sending the GLMR to and click the right button to proceed</li> <li>The Network screen should show Moonbeam. Click the right button to proceed</li> <li>Review the Max Fees and click the right button to proceed</li> <li>If everything looks good, you can click both buttons to Accept and send the transaction. Otherwise, you can click the right button to get to the Reject screen where you can click both buttons to reject the transaction</li> </ol> <p></p> <p>On Ledger Live, you should see that your transaction was sent, and you can view the details of the transaction. Once the transaction has been confirmed, your GLMR balance will update.</p> <p>You've successfully used the Moonbeam Ledger Live integration to receive and send tokens with your Ledger device directly from Ledger Live.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/metamask/","title":"Interacting with Moonbeam Using MetaMask","text":""},{"location":"tokens/connect/metamask/#introduction","title":"Introduction","text":"<p>Developers can leverage Moonbeam's Ethereum compatibility features to integrate tools, such as MetaMask, into their dApps. By doing so, they can use the injected library MetaMask provides to interact with the blockchain.</p> <p>Currently, MetaMask can be configured to connect to a few networks: Moonbeam, Moonriver, the Moonbase Alpha TestNet, and a Moonbeam development node.</p> <p>If you already have MetaMask installed, you can easily connect MetaMask to the network of your choice:</p> Connect to Moonbeam Connect to Moonriver Connect to Moonbase Alpha <p>Note</p> <p>MetaMask will pop up asking for permission to add a custom network. Once you approve permissions, MetaMask will switch your current network.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/metamask/#install-the-metamask-extension","title":"Install the MetaMask Extension","text":"<p>First, you'll start with a fresh and default MetaMask installation from the Chrome store. After downloading, installing, and initializing the extension, follow the Get Started guide. In there, you need to create a wallet, set a password, and store your secret backup phrase (this gives direct access to your funds, so make sure to store these in a secure place).</p>"},{"location":"tokens/connect/metamask/#setup-a-wallet","title":"Setup a Wallet","text":"<p>After installing MetaMask, the setup will automatically open a new task with a welcome screen. Here, you are offered two options:</p> <ul> <li>Create a new wallet - you'll go through some steps to get a new seed phrase. Ensure you store this phrase securely and you don't share it publicly</li> <li>Import an existing wallet - you already have a seed phrase stored, and you want to restore an account from that recovery phrase</li> </ul> <p></p> <p>Once you've selected the option that fits your needs, follow the steps, and you should be all set.</p> <p>Note</p> <p>Multiple accounts can be derived from a seed phrase by changing what is known as the address index. By default, when creating or importing an account from the seed phrase, you get the account with the address index 0. You can get the other indexes by just adding new accounts in the main Metamask screen.</p>"},{"location":"tokens/connect/metamask/#import-accounts","title":"Import Accounts","text":"<p>Once you've created a wallet or imported an existing one, you can also import any account into MetaMask if you hold the private keys.</p> <p>For this example, you'll use private keys from the development account. Click the account switcher button to import an account using its private keys. That is where it says Account 1.</p> <p></p> <p>Next, click on Import Account.</p> <p></p> <p>Finally, enter the private keys of the account you are trying to import. For example, you can use one of the accounts prefunded in the Moonbeam development node. This guide uses Gerald's key. Once you've entered the private key, click on Import.</p> Development account addresses and private keys <ul> <li> <p>Alith:</p> <ul> <li>Public Address: <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>Private Key: <code>0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133</code></li> </ul> </li> <li> <p>Baltathar:</p> <ul> <li>Public Address: <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>Private Key: <code>0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b</code></li> </ul> </li> <li> <p>Charleth:</p> <ul> <li>Public Address: <code>0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</code></li> <li>Private Key: <code>0x0b6e18cafb6ed99687ec547bd28139cafdd2bffe70e6b688025de6b445aa5c5b</code></li> </ul> </li> <li> <p>Dorothy:</p> <ul> <li>Public Address: <code>0x773539d4Ac0e786233D90A233654ccEE26a613D9</code></li> <li>Private Key: <code>0x39539ab1876910bbf3a223d84a29e28f1cb4e2e456503e7e91ed39b2e7223d68</code></li> </ul> </li> <li> <p>Ethan:</p> <ul> <li>Public Address: <code>0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB</code></li> <li>Private Key: <code>0x7dce9bc8babb68fec1409be38c8e1a52650206a7ed90ff956ae8a6d15eeaaef4</code></li> </ul> </li> <li> <p>Faith:</p> <ul> <li>Public Address: <code>0xC0F0f4ab324C46e55D02D0033343B4Be8A55532d</code></li> <li>Private Key: <code>0xb9d2ea9a615f3165812e8d44de0d24da9bbd164b65c4f0573e1ce2c8dbd9c8df</code></li> </ul> </li> <li> <p>Goliath:</p> <ul> <li>Public Address: <code>0x7BF369283338E12C90514468aa3868A551AB2929</code></li> <li>Private Key: <code>0x96b8a38e12e1a31dee1eab2fffdf9d9990045f5b37e44d8cc27766ef294acf18</code></li> </ul> </li> <li> <p>Heath: </p> <ul> <li>Public Address: <code>0x931f3600a299fd9B24cEfB3BfF79388D19804BeA</code></li> <li>Private Key: <code>0x0d6dcaaef49272a5411896be8ad16c01c35d6f8c18873387b71fbc734759b0ab</code></li> </ul> </li> <li> <p>Ida: </p> <ul> <li>Public Address: <code>0xC41C5F1123ECCd5ce233578B2e7ebd5693869d73</code></li> <li>Private Key: <code>0x4c42532034540267bf568198ccec4cb822a025da542861fcb146a5fab6433ff8</code></li> </ul> </li> <li> <p>Judith: </p> <ul> <li>Public Address: <code>0x2898FE7a42Be376C8BC7AF536A940F7Fd5aDd423</code></li> <li>Private Key: <code>0x94c49300a58d576011096bcb006aa06f5a91b34b4383891e8029c21dc39fbb8b</code></li> </ul> </li> <li>Gerald:<ul> <li>Public Address: <code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code></li> <li>Private Key: <code>0x99b3c12287537e38c90a9219d4cb074a89a16e9cdb20bf85728ebd97c343e342</code></li> </ul> </li> </ul> <p></p> <p>You should end up with an imported Account 2 that looks like this:</p> <p></p>"},{"location":"tokens/connect/metamask/#connect-metamask-to-moonbeam","title":"Connect MetaMask to Moonbeam","text":"<p>Once you have MetaMask installed and have created or imported an account, you can connect it to any Moonbeam-based network. To do so, take the following steps:</p> <ol> <li>Click in the upper left network selector menu</li> <li>Select Add Network</li> </ol> <p></p> <p>Next, go to the bottom of the page and click on Add a network manually:</p> <p></p> <p>Here, you can configure MetaMask for the following networks:</p> MoonbeamMoonriverMoonbase AlphaMoonbeam Dev Node Variable Value Network Name <code>Moonbeam</code> RPC URL <code>https://rpc.api.moonbeam.network</code> Chain ID <code>1284</code> (hex: <code>0x504</code>) Symbol (Optional) <code>GLMR</code> Block Explorer (Optional) <code>https://moonscan.io</code> Variable Value Network Name <code>Moonriver</code> RPC URL <code>https://rpc.api.moonriver.moonbeam.network</code> Chain ID <code>1285</code> (hex: <code>0x505</code>) Symbol (Optional) <code>MOVR</code> Block Explorer (Optional) <code>https://moonriver.moonscan.io/</code> Variable Value Network Name <code>Moonbase Alpha</code> RPC URL <code>https://rpc.api.moonbase.moonbeam.network</code> Chain ID <code>1287</code> (hex: <code>0x507</code>) Symbol (Optional) <code>DEV</code> Block Explorer (Optional) <code>https://moonbase.moonscan.io/</code> Variable Value Network Name <code>Moonbeam Dev</code> RPC URL <code>http://127.0.0.1:9944</code> Chain ID <code>1281</code> (hex: <code>0x501</code>) Symbol (Optional) <code>DEV</code> Block Explorer (Optional) <code>https://moonbeam-explorer.netlify.app/</code> <p>To do so, fill in the following information:</p> <ol> <li>Network name - name that represents the network you are connecting to</li> <li>RPC URL - RPC endpoint of the network</li> <li>Chain ID - chain ID of the Ethereum compatible network</li> <li>Symbol - (optional) symbol of the native token of the network. For example, for Moonbeam, the value would be GLMR</li> <li>Block Explorer - (optional) URL of the block explorer</li> <li>Once you've verified all the information, click on Save</li> </ol> <p></p> <p>Once you've added the network, you'll be redirected to a screen stating that you've successfully added a network. Furthermore, you'll be prompted to Switch to Moonbase Alpha, the network added in this example.</p> <p></p>"},{"location":"tokens/connect/metamask/#interact-with-the-network","title":"Interact with the Network","text":"<p>Once you've connected Metamask to any Moonbeam-based network, you can start using your wallet by:</p> <ul> <li>Sending a token transfer to another address</li> <li>Adding ERC-20s to Metamask and interacting with them</li> <li>Adding ERC-721s to Metamask and interacting with them</li> </ul>"},{"location":"tokens/connect/metamask/#initiate-a-transfer","title":"Initiate a Transfer","text":"<p>This section showcases how to do a simple token transfer to another address as an example of using Metamask with Moonbeam.</p> <p>To do so, take the following steps:</p> <ol> <li>Ensure you are connected to the correct network</li> <li>Ensure you have selected the account you want to use for the transfer</li> <li>On the main screen of your Metamask wallet, click on Send</li> </ol> <p></p> <p>Next, you can enter the address to which you want to send the tokens. For this example, a wallet that has already been imported to Metamask is selected, known as Bob.</p> <p></p> <p>On the next screen, take the following steps:</p> <ol> <li>Enter the number of tokens you want to send</li> <li>Verify that all the information is correct, and click on Next</li> </ol> <p></p> <p>Lastly, confirm that all the gas-related parameters and fees are correct. After you've verified that everything is OK, click Confirm. At this point, your transaction has been sent to the network!</p> <p></p> <p>Once you've confirmed your transaction, you are taken back to the main screen of your wallet, where you'll see the transaction as Pending. After less than a minute, the transaction should be Confirmed. If you click on your transaction, you can check more details and view it in a block explorer.</p> <p></p>"},{"location":"tokens/connect/metamask/#add-an-erc20-token","title":"Add an ERC-20 Token","text":"<p>To add an ERC-20 to your MetaMask wallet, you'll need to import the token using its address:</p> <ol> <li>Make sure you've switched to the Tokens tab in MetaMask</li> <li>Click Import tokens</li> <li>Enter the contract address of the token you want to import. The Token symbol and Token decimal fields will automatically be populated, but you can edit the Token symbol if needed</li> <li>Click Next</li> </ol> <p></p> <p>Next, you'll be able to review the token import details. To finalize the import, you can click Import.</p> <p></p> <p>Under the Tokens tab, you'll be able to see the token and the account balance for the token.</p> <p></p>"},{"location":"tokens/connect/metamask/#add-an-erc721-token","title":"Add an ERC-721 Token","text":"<p>To add an ERC-721 to your MetaMask wallet, you'll need the token's address:</p> <ol> <li>Make sure you've switched to the NFTs tab in MetaMask</li> <li>Click Import NFT</li> <li>Enter the Address of the NFT you want to import and the Token ID</li> <li>Click Import</li> </ol> <p></p> <p>Once you've imported your NFT, you'll be able to see a preview of your NFT in the NFTs tab. You can click on the NFT to see more details.</p> <p></p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/on-ramps/","title":"Fiat On-Ramp Services to Acquire GLMR for Moonbeam","text":""},{"location":"tokens/connect/on-ramps/#introduction","title":"Introduction","text":"<p>Interacting with dApps or deploying smart contracts on Moonbeam requires users to hold GLMR tokens, which are used to pay for network transaction fees (gas). To help users acquire GLMR, there are several reliable on-ramp services available to convert local currency (fiat) into GLMR. This guide covers two popular options - Transak and Onramp - each offering different payment methods and features to suit individual needs. Supporting bank transfers, credit cards, and mobile payment solutions, these platforms provide secure and regulated ways to acquire GLMR tokens. </p> <p>You can find a current list of supported on-ramps on the Moonbeam dApp. Please be aware that the availability of these services may vary by jurisdiction. For more information, please visit the website of the respective on-ramp. </p>"},{"location":"tokens/connect/on-ramps/#transak","title":"Transak","text":"<p>Using Transak is a straightforward way to purchase GLMR tokens for the Moonbeam network. The process begins at Transak with selecting GLMR as the desired cryptocurrency. Users select their local currency and purchase amount, then review the associated fees and processing time details. The next step requires entering the destination Moonbeam wallet address. For bank transfers and other fiat payment methods, a one-time KYC verification process must be completed by providing valid identification documents. After payment completion through the selected method (bank transfer, credit card, or other supported options), Transak processes the transaction and sends the GLMR tokens directly to the specified wallet address. Delivery time varies depending on the payment method selected, ranging from near-instant for card payments to up to 2 business days for bank transfers.</p>"},{"location":"tokens/connect/on-ramps/#onramp","title":"Onramp","text":"<p>Onramp offers a seamless fiat-to-crypto gateway for purchasing GLMR tokens, supporting over 400 different cryptocurrencies through their platform. The process begins with a straightforward phone-based OTP login system for verification. After login, the platform displays transaction details, including the GLMR amount and current market rates, for confirmation. Based on geographical location, Onramp displays relevant bank account details and available payment methods. Once payment is completed through the selected method, Onramp handles all aspects of the conversion - from payment processing to regulatory compliance and wallet management. Upon confirmation of the deposit, the platform automatically purchases GLMR at the current market price and then initiates an automatic withdrawal to the specified Moonbeam wallet address. Additional KYC verification may be required for larger transactions, but the platform manages all compliance requirements internally to ensure a smooth experience.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/polkadotjs/","title":"How to use Polkadot.js Apps to Interact with Moonbeam","text":""},{"location":"tokens/connect/polkadotjs/#introduction","title":"Introduction","text":"<p>As a Polkadot parachain, Moonbeam uses a unified account structure that allows you to interact with Substrate (Polkadot) functionality and Moonbeam's EVM, all from a single Ethereum-style address. This unified account structure means that you don't need to maintain both a Substrate and an Ethereum account to interact with Moonbeam - instead, you can do it all with a single Ethereum private key.</p> <p>The Polkadot.js Apps interface natively supports H160 addresses and ECDSA keys. So, in this tutorial, you can check out this integration of Ethereum-based accounts on Polkadot.js Apps.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/).  <p>Note</p> <p>Polkadot.js Apps is phasing out support for accounts stored locally in the browser's cache. Instead, it is recommended that you use a browser extension like Talisman to inject your accounts into Polkadot.js Apps.</p>"},{"location":"tokens/connect/polkadotjs/#connect-polkadotjs-apps","title":"Connect Polkadot.js Apps to Moonbeam","text":"<p>When launching Polkadot.js Apps for the first time, you may or may not be connected to the desired network.</p> <p>You can change the selected network by clicking the logo in the top left corner, where you'll find a list of networks organized by MainNets, TestNets, and local networks. Each network can be found under the following sections:</p> Network Section Moonbeam Polkadot &amp; Parachains Moonriver Kusama &amp; Parachains Moonbase Alpha Test Networks Moonbeam Development Node Development <p>Once you've selected the correct network, you can scroll back to the top and click Switch.</p> <p></p> <p>After switching, the Polkadot.js site will not only connect to the chosen network, but the logo and styling will change for each network.</p> <p></p>"},{"location":"tokens/connect/polkadotjs/#creating-or-importing-an-h160-account","title":"Create or Import an H160 Account into Polkadot.js Apps","text":"<p>Note</p> <p>For security purposes, it is recommended that you do not store accounts locally in the browser. A more secure method is using a browser extension like Talisman to inject your accounts into Polkadot.js Apps.</p> <p>In this section, you'll learn how you can create a new account or import a preexisting MetaMask account to Polkadot.js Apps. First, there is one prerequisite step. As part of the process of phasing out support for accounts stored locally in the browser's cache, you'll need to enable support for local storage of accounts in the Settings tab. To do so, take the following steps:</p> <ol> <li>Navigate to the Settings tab</li> <li>Select Allow local in-browser account storage under the in-browser account creation heading</li> <li>Press Save</li> </ol> <p></p> <p>You can now head back to the Accounts page of Polkadot.js Apps and proceed with the next steps:</p> <ol> <li>Navigate to the Accounts section</li> <li>Click on the Add account button</li> </ol> <p></p> <p>This will open a wizard pop-up that will guide you through the process of adding an account to the Polkadot.js Apps interface:</p> <ol> <li>Click on the drop-down menu</li> <li>Change the selection from Mnemonic to Private Key, this allows you to add an account through a private key</li> </ol> <p>Note</p> <p>Currently, you can only create or import accounts in Polkadot.js via a private key. Doing so with the mnemonic will result in a different public address if you later try to import this account to an Ethereum wallet such as MetaMask. This is because Polkadot.js uses BIP39, whereas Ethereum uses BIP32 or BIP44.</p> <p></p> <p>Next, if you want to create a new account, make sure you store the private key displayed by the wizard. If you want to import an existing account, enter your private key that you can export from MetaMask.</p> <p>Note</p> <p>Never reveal your private keys as they give direct access to your funds. The steps in this guide are for demonstration purposes only.</p> <p>Make sure to include the prefix in the private key, i.e., <code>0x</code>. If you entered the information correctly, the corresponding public address should appear in the upper left corner of the window, and then click Next.</p> <p></p> <p>To finish the wizard, you can set an account name and password. After a confirmation message, you should see in the main Accounts tab the address with the corresponding balance: in this case, Bob's address. Moreover, you can overlay the MetaMask extension to see that both balances are the same.</p> <p></p>"},{"location":"tokens/connect/polkadotjs/#sending-a-transaction-through-substrates-api","title":"Send a Transaction Through Substrate's API","text":"<p>Now, to demonstrate the potential of Moonbeam's unified accounts scheme, you can make a transfer through the Substrate API using Polkadot.js Apps. Remember that you are interacting with Substrate using an Ethereum-style H160 address. To do so, you can import another account.</p> <p>Next, click on Bob's send button, which opens another wizard that guides you through the process of sending a transaction.</p> <ol> <li>Set the send to address</li> <li>Enter the amount to send, which for this example is 1 DEV token</li> <li>When ready, click on the Make Transfer button</li> </ol> <p></p> <p>Then you'll be prompted to enter your password and sign and submit the transaction. Once the transaction is confirmed, you should see the balances updated for each account.</p> <p></p> <p>And that is it! We are excited about being able to support H160 accounts in Polkadot.js Apps, as we believe this will greatly enhance the user experience on the Moonbeam Network and its Ethereum compatibility features.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/subwallet/","title":"Interacting with Moonbeam Using SubWallet","text":""},{"location":"tokens/connect/subwallet/#introduction","title":"Introduction","text":"<p>Developers and users of Moonbeam have a variety of options when it comes to wallets. Thanks to Moonbeam's seamless Ethereum compatibility, Moonbeam supports a great variety of popular wallets, including SubWallet.</p> <p>SubWallet is a comprehensive Web3 wallet that natively supports Substrate and Ethereum accounts. Although Moonbeam is a Substrate-based blockchain, it has a unified account system that replaces the default Substrate-style accounts and keys with Ethereum-style accounts and keys. Since SubWallet supports Ethereum-style accounts, you can interact with your Moonbeam account using SubWallet.</p> <p>This guide takes you through all the necessary steps, from installing SubWallet to setting up a wallet, connecting it to Moonbeam, and sending funds.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/subwallet/#install-subwallet","title":"Install SubWallet","text":"<p>There are several ways you can interact with SubWallet: they have a browser extension, a mobile app, and a web-accessible dashboard.</p> <p>You can get started by heading to SubWallet's download page and downloading SubWallet for the platform of your choice.</p> <p>If you choose to use the web-accessible dashboard, you won't need to download anything. You can access the dashboard at web.subwallet.app.</p> <p>The interfaces for the mobile app, browser extension, and web dashboard are quite similar, so you can adapt the following instructions, which focus on the browser extension, for the mobile app and web dashboard.</p>"},{"location":"tokens/connect/subwallet/#setup-a-wallet","title":"Setup a Wallet","text":"<p>Once you've downloaded the SubWallet Browser Extension, you'll be prompted to set up your wallet. You'll be able to choose from the following options:</p> <ul> <li>Create a new account - allows you to create an entirely new account by creating a password and generating a seed phrase</li> <li>Import an account - allows you to import an existing account using the seed phrase, JSON file, private key, or by QR code</li> <li> <p>Attach an account - allows you to connect to an account without the private key. You can use this method to connect to a cold storage wallet, like Keystone, or a watch-only account. With a watch-only account, you will not be able to transfer funds or interact with your account; you'll only be able to view account balances</p> <p>Note</p> <p>Ledger is supported on the browser extension but is not yet available on the mobile app. Support for Ledger on the mobile app is coming soon!</p> </li> <li> <p>Connect wallet - only available on the web dashboard - allows you to connect to a browser extension wallet. You can use this method to easily connect to an account you've created using the SubWallet browser extension or another wallet, such as MetaMask</p> </li> </ul> <p>The following sections will provide step-by-step instructions for creating a new account and importing an existing account with SubWallet.</p> <p>If you're attaching an account, you can find step-by-step instructions on SubWallet's Account management documentation. Similarly, if you're connecting a wallet on the web dashboard, you can find instructions on SubWallet's Connect extension documentation.</p>"},{"location":"tokens/connect/subwallet/#create-a-new-account","title":"Create a New Account","text":"<p>Creating a new account will generate a seed phrase that can derive multiple Ethereum and Substrate accounts. By default, SubWallet will generate a single Ethereum and a single Substrate account, but you can easily derive more from the same seed phrase. To interact with Moonbeam, you will need to use an Ethereum account. Click Create a new account to get started.</p> <p></p> <p>On the following screen, you'll be prompted to create a password to secure your new wallet:</p> <ol> <li>Enter a password that has at least 8 characters</li> <li>Confirm the password by entering it again</li> <li>Click Continue</li> </ol> <p></p> <p>You'll then be prompted to back up your seed phrase. This is an important step, especially because you have the option to later derive additional accounts from this seed phrase.</p> <ol> <li> <p>View your seed phrase and save it in a safe place</p> <p>Remember</p> <p>You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.</p> </li> <li> <p>Once you've safely stored your seed phrase, click I have kept it somewhere safe</p> </li> </ol> <p></p> <p>Note</p> <p>If you're creating a new account on the mobile app, you'll have to re-enter your seed phrase to verify that you have stored it. The words have to be entered in the correct order.</p> <p>After you've created a password and saved your seed phrase, you'll be connected to your account. You can add additional accounts at any time.</p>"},{"location":"tokens/connect/subwallet/#import-an-account","title":"Import an Account","text":"<p>To import an existing account into SubWallet, you can select Import an account.</p> <p></p> <p>On the following screen, select the method by which you would like to import the existing account. You can choose from Import from seed phrase, Import from Polkadot.{js}, Import by MetaMask private key, and Import by QR code.</p> <p>If you select Import from seed phrase, there are some incompatibility issues that can arise when importing an account from seed phrase. For example, Trust Wallet and SafePal are among the wallets not compatible with SubWallet. If you run into incompatibility issues, SubWallet recommends creating a new wallet.</p> <p>If you select Import from Polkadot.{js}, you'll need to make sure that the account was created in Polkadot.js via private key. If it was created with a seed phrase and you attempt to import it to SubWallet, a different public address will be used. This is because Polkadot.js uses BIP39, whereas Ethereum uses BIP32 or BIP44.</p> <p></p> <p>If you import your account via seed phrase, you can select your account type as either Substrate (Polkadot) or EVM (Ethereum), or both. Moonbeam uses Ethereum-style accounts, so you'll need to select Ethereum to import an account for Moonbeam-based networks.</p> <p></p> <p>Once you've completed the import process, you'll be prompted to enter a password to secure your new wallet:</p> <ol> <li>Enter a password that has at least 8 characters</li> <li>Confirm the password by entering it again</li> <li>Click Continue</li> </ol> <p></p> <p>Next, you'll be able to provide the relevant seed phrase, private key, JSON file, or QR code, and you can begin using your new account right away. You can add additional accounts at any time.</p>"},{"location":"tokens/connect/subwallet/#add-additional-accounts","title":"Add Additional Accounts","text":"<p>After you have created a new account or imported an existing account to SubWallet, you can add additional accounts by taking the following steps:</p> <ol> <li>Click on the account dropdown</li> <li>Select one of the options from the bottom of the screen. You can click Create a new account, the import button to import an existing account, or the attach button to attach to an existing cold storage wallet or watch-only account</li> </ol> <p></p> <p>If you're creating a new account, you can then choose Create with new seed phrase or Derive from an existing account. If you're creating a new account with a new seed phrase, you'll need to select the account type and back up the account, similar to the instructions in the Create a New Account section. If you choose to derive a new account, you'll be prompted to select the existing account that you want to derive the account from.</p> <p>If you're importing a new account, you'll need to choose whether to import using a seed phrase, JSON file, MetaMask private key or QR code, then repeat the process outlined in the Import an Account section.</p> <p>If you're attaching an account, you can find out step-by-step instructions on SubWallet's Account management documentation.</p>"},{"location":"tokens/connect/subwallet/#connect-subwallet-to-moonbeam","title":"Connect SubWallet to Moonbeam","text":"<p>To configure SubWallet for Moonbeam, select the Customize your asset display icon next to the Search a token icon.</p> <p></p> <p>To add Moonbeam, you can:</p> <ol> <li>Search for \"Moon\" to view all Moonbeam-based networks, or search for a specific network</li> <li>Toggle the switch to connect to the network</li> </ol> <p></p> <p>If you're trying to connect to a local Moonbeam development node, you can select the hamburger menu from the top left corner, which will take you to the settings page.</p> <p></p> <p>From the settings menu, click Manage networks.</p> <p></p> <p>Click the + icon in the top right corner and enter in the network configurations. You can also manage and connect to other networks from this menu.</p> <p></p> <p>By default, all balances are hidden in SubWallet, but if you press the Show balance icon, you can toggle balance visibility.</p> <p></p>"},{"location":"tokens/connect/subwallet/#interact-with-the-network","title":"Interact with the Network","text":"<p>Once you've connected SubWallet to any Moonbeam-based network, you can start using your wallet by:</p> <ul> <li>Receiving a token from another address</li> <li>Sending a token to another address</li> <li>Adding tokens to SubWallet and interacting with them</li> </ul>"},{"location":"tokens/connect/subwallet/#receive-a-token","title":"Receive a Token","text":"<p>To receive a token from another account, you would need to show your wallet address to your counterparty, and they can send their assets to such address.</p> <p>To copy your address, click on the Get address icon.</p> <p></p> <p>If you have multiple accounts and have selected All accounts from the account dropdown menu, you'll need to select the receiving account you want to send the assets to. Otherwise, make sure that the account you're connected to (which is displayed at the top of the screen) is the account you want to send the assets to. This should be your Moonbeam account, which is an Ethereum-style address.</p> <p></p> <p>Next, you can search for and choose the token that you would like to receive. For this example, DEV is chosen.</p> <p></p> <p>Note</p> <p>SubWallet supports receiving cross-chain tokens, so please be sure to check that the chain logo under the token name matches your desired chain.</p> <p>You will be shown the QR code and the address linked to your account. Double-check that the address shown is an Ethereum-style account.</p> <p></p> <p>Now you just need to show the QR code or address to the sender.</p>"},{"location":"tokens/connect/subwallet/#send-a-transaction","title":"Send a Transaction","text":"<p>To get started with a simple token transfer to another address on Moonbeam, you can click the Send icon.</p> <p></p> <p>Next, you can take the following steps:</p> <ol> <li> <p>Specify the asset to send and the destination chain</p> <p>Note</p> <p>Some tokens are allowed to be transferred cross-chain, so when choosing the destination network, you can choose the dropdown menu to see the available options.</p> </li> <li> <p>Enter the destination address, which can also be done using the address book or by scanning the recipient's QR code</p> <p>Note</p> <p>If you're using the mobile app, click Next to proceed.</p> </li> <li> <p>Enter the amount of tokens to send</p> </li> <li>Look over the transaction details, then press Transfer</li> </ol> <p></p> <p>On the next screen, you'll be able to review the transaction details and submit the transaction. If the transaction details look good, you can click Approve to send the transaction.</p> <p></p> <p>After you send the transaction, you'll be able to review the transaction details.</p> <p>And that's it! For more information on how to use SubWallet, please refer to SubWallet's documentation.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/talisman/","title":"Interacting with Moonbeam Using Talisman","text":""},{"location":"tokens/connect/talisman/#introduction","title":"Introduction","text":"<p>As a Polkadot parachain, Moonbeam uses a unified account structure that allows you to interact with Substrate (Polkadot) functionality and Moonbeam's EVM, all from a single Ethereum-style address. This unified account structure means that you don't need to maintain both a Substrate and an Ethereum account to interact with Moonbeam - instead, you can do it all with a single Ethereum private key.</p> <p>Polkadot.js Apps supports H160 accounts injected into the browser via an extension like Talisman. Note, Polkadot.js Apps is phasing out support for accounts stored locally in the browser's cache. While you can continue to use any accounts that you've imported and stored in your browser locally via Polkadot.js Apps, you won't be able to add any new ones. This means that you'll need to use an extension like Talisman. Furthermore, injecting your account from an extension like Talisman is generally regarded to be safer than storing the account directly in the browser.</p> <p>This guide will include all of the steps for setting up an account in Talisman and using it to interact with Moonbeam through Polkadot.js Apps.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/talisman/#setting-up-talisman","title":"Setting up Talisman","text":"<p>Talisman is a crypto-wallet that natively supports Substrate (Polkadot) and Ethereum accounts. The Talisman wallet browser extension is available on Google Chrome and Brave, and a corresponding asset dashboard is accessible at app.talisman.xyz</p> <p>First, download and install the Talisman extension. Once the extension opens up, you'll be prompted to either create a new wallet or import an existing one. For the purposes of this demo, you'll create a new wallet. On the following screen you'll be prompted to create a password to secure the new wallet.  </p> <p></p> <p>Remember</p> <p>Talisman does not require you to back up your seed phrase but will nudge you with a reminder at the bottom of the screen. If you don't back up your seed phrase, you could lose all of your assets.</p> <p>To back up your newly created wallet, take the following steps:</p> <ol> <li>Press Backup Now</li> <li>Enter the password to your Talisman wallet</li> <li>Press View Recovery Phrase and store it in a secure place</li> </ol> <p></p>"},{"location":"tokens/connect/talisman/#setting-up-talisman-to-connect-to-testnets","title":"Setting up Talisman to Connect to Testnets","text":"<p>Talisman works with all Moonbeam networks after you enable Ethereum accounts. You can also see your balances across all networks in the Portfolio tab by clicking on the extension's Talisman logo in the upper left-hand corner. By default, Talisman hides your testnet account balances. However, you can change this by taking the following steps:</p> <ol> <li>Open the Talisman extension and click on the Talisman logo</li> <li>Select Settings</li> <li>Select Ethereum Networks</li> <li>Click Enable Testnets</li> </ol> <p></p>"},{"location":"tokens/connect/talisman/#connecting-talisman-to-moonbase-alpha-polkadot.js-apps","title":"Connecting Talisman to Moonbeam and Polkadot.js Apps","text":"<p>Connecting Talisman to a Moonbeam-based network in Polkadot.js Apps is straightforward. Remember that you need to enable testnets if you want to connect to Moonbase Alpha.</p> <p>To connect to a Moonbeam-based network, the Moonbase Alpha testnet in this example, head to Moonbase Alpha Polkadot.js Apps. The Talisman extension will prompt you to select the accounts you'd like to use with Polkadot.js Apps. If it doesn't automatically pop up, you can open the Talisman extension and press the Connected / Not Connected button at the top. To configure Talisman to correctly interface with Moonbeam networks on Polkadot.js Apps, you should take the following steps:</p> <ol> <li>Check the box next to Show Ethereum Accounts</li> <li>Select the accounts you want to connect to Polkadot.js Apps. In this example, it is only My Ethereum Account. This is the default name assigned by Talisman which you can rename if you'd like</li> <li>Press Connect 1. The value will change depending on the number of accounts you are connecting</li> </ol> <p></p> <p>Your Talisman wallet is now connected to Polkadot.js Apps. After refreshing Polkadot.js Apps, you should see your Talisman account in the Accounts page of Polkadot.js Apps. When launching Polkadot.js Apps for the first time, you may or may not be connected to the desired network. You can change your selected network to the Moonbase Alpha TestNet by clicking the logo in the top left corner, then scroll down to the Test Networks section, select Moonbase Alpha, and scroll back to the top and click Switch.</p> <p></p> <p>After switching, the Polkadot.js site will not only connect to Moonbase Alpha, but also change its styling to make a perfect match.</p> <p></p>"},{"location":"tokens/connect/talisman/#adding-a-new-account-to-talisman","title":"Adding a New Account to Talisman","text":"<p>In this section, you'll learn how you can create a new account, or import an already existing MetaMask account to Polkadot.js Apps.</p> <ol> <li>Open the Talisman extension and click on the Talisman logo in the upper left hand corner</li> <li>Select Add Account</li> <li>Select New Account</li> <li>Select Ethereum as the account type</li> <li>Give your new account a name</li> <li>Press Create</li> </ol> <p></p> <p>Although our new account has been successfully created, Polkadot.js Apps isn't aware of it yet. To connect the new account to Polkadot.js Apps, take the following steps from Polkadot.js Apps:</p> <ol> <li>Open the Talisman extension and Press the Connected / Not-connected button</li> <li>Ensure Show Eth accounts is checked</li> <li>Click on the account you'd like to connect. The green dot next to the account will light up if it is selected</li> </ol> <p></p>"},{"location":"tokens/connect/talisman/#sending-a-transaction-through-substrates-api","title":"Sending a Transaction Through Substrate's API","text":"<p>Now, to demonstrate the potential of Moonbeam's unified accounts scheme you can make a transfer through the Substrate API using Polkadot.js Apps. Remember that you are interacting with Substrate using an Ethereum-style H160 address. To do so, you can add another account. The accounts in Talisman have been renamed to the familiar Alice and Bob accounts. To send some DEV funds from Alice to Bob, take the following steps:</p> <p>Click on Alice's send button, which opens another wizard that guides you through the process of sending a transaction.</p> <ol> <li>Set the send to address</li> <li>Enter the amount to send, which is 4 DEV tokens in this example</li> <li>When ready, click on the Make Transfer button</li> <li>Approve the transaction in the Talisman pop up</li> </ol> <p></p> <p>After the transaction is confirmed, you should see the balances updated for each account.</p> <p></p> <p>And that is it! These steps have demonstrated the ease coupled with the robust security of interacting with injected H160 accounts in Polkadot.js Apps with Talisman. All of this is possible because of Moonbeam's unified account structure, a great example of Moonbeam's commitment to providing the best user experience.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/connect/trezor/","title":"Interacting with Moonbeam Using Trezor Hardware Wallet","text":""},{"location":"tokens/connect/trezor/#introduction","title":"Introduction","text":"<p>Hardware wallets provide a safer way to store crypto funds because the private key (used for signing transactions) is stored offline. Trezor offers two hardware wallet solutions at the time of writing: Trezor One and Trezor Model T.</p> <p>Because Moonbeam is fully Ethereum compatible, you can use your Trezor device to sign transactions on Moonbeam!</p> <p>This tutorial shows you how to get started with your Trezor hardware wallet on Moonbase Alpha. The guide only illustrates the steps for a Trezor Model T device, but you can follow along with a Trezor One as well.</p> <p>Please note that your Trezor device will sign transactions in whichever MetaMask network is connected to.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/connect/trezor/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before you get started, update Trezor Suite to the latest version available. Also, make sure your Trezor hardware wallet is running the latest firmware. The Trezor wiki offers tutorials on how to update the firmware of both Trezor One and Trezor Model T devices.</p> <p>At the time of writing, the following versions were used:</p> <ul> <li>Trezor Suite 21.5.1</li> <li>Trezor One firmware v1.10.0</li> <li>Trezor Model T firmware v2.4.0</li> </ul> <p>In addition, you'll need MetaMask as an intermediary between your Trezor device and Moonbase Alpha. Make sure that your MetaMask is connected to Moonbase Alpha. Please note that your Trezor device will sign transactions in whichever MetaMask network is connected to.</p>"},{"location":"tokens/connect/trezor/#importing-your-trezor-account-to-metamask","title":"Importing your Trezor Account to MetaMask","text":"<p>To get started, you need to have set up a wallet (either standard or a hidden wallet). Once you've connected your Trezor device, unlocked it, and set up a wallet in Trezor Suite. Next, to import your Trezor Ethereum account to MetaMask, take the following steps:</p> <ol> <li>Click on the top-right logo to expand the menu</li> <li>Select Connect Hardware Wallet</li> </ol> <p></p> <p>Right after, you are prompted to select which hardware wallet you'll like to use in MetaMask. At the moment of writing, only Ledger and Trezor hardware wallets are supported. If you have your Trezor device ready to go, take the following steps:</p> <ol> <li>Select the Trezor logo</li> <li>Click on Continue</li> </ol> <p></p> <p>After clicking the button, a new tab named TrezorConnect should show up, where you'll need to pair your device. This is not required if you've Trezor Suite opened and your device is connected. Here, click on Pair devices.</p> <p></p> <p>On the next screen, take the following steps:</p> <ol> <li>Click on Check for devices. This will open a menu showing which Trezor device (if available) you want to connect to</li> <li>Select the Trezor device you want to use</li> <li>Click on Connect</li> </ol> <p></p> <p>Once your device is connected, you need to allow MetaMask to read its public keys. Therefore, click on Allow once for this session. Optionally, you can also check the Don't ask me again box.</p> <p></p> <p>Next, you are asked if you want to export the public key of your Ethereum account (tab was cropped and labeled as 1 in the following image). Right after, you are prompted with an option to use Trezor's passphrase option (tab cropped and labeled as 2 in the image). If you want to use the default wallet, just click on Enter. If not, please see Trezor's guide article on passphrase wallets.</p> <p></p> <p>If MetaMask was able to connect successfully to your Trezor device, you should see a list of five Ethereum-styled accounts. If not, please double-check that you've properly connected your Trezor device to the computer and it is unlocked. You can also repeat the process with the Trezor Suite app opened.</p> <p>From this list of five Ethereum accounts, take the following steps:</p> <ol> <li>Select the accounts you would like to import from your Trezor device</li> <li>Click on Unlock</li> </ol> <p></p> <p>If you've imported your Trezor Ethereum-styled account successfully, you should see it displayed in the main MetaMask screen like shown in the following image:</p> <p></p> <p>You've now successfully imported a Moonbeam compatible account from your Trezor device and are now ready to start signing transactions using your hardware wallet.</p>"},{"location":"tokens/connect/trezor/#signing-a-transaction-using-your-trezor","title":"Signing a Transaction Using your Trezor","text":"<p>If you've successfully imported your Trezor account to MetaMask, you are ready to sign transactions on Moonbeam using your Trezor device. This tutorial will show you how to send a simple transaction on the Moonbase Alpha TestNet, but it applies to other Moonbeam ecosystem networks.</p> <p>First, make sure your Trezor account is funded with DEV tokens. Next, click on the Send button.</p> <p></p> <p>A <code>TrezorConnect</code> tab should pop up, asking permission to read public keys from your device and prepare your Trezor for transaction and data signing. Once you are ready, click on Allow once for this session. Optionally, you can also check the Don't ask me again box.</p> <p></p> <p>As you would in a standard transaction, set the recipient address, enter the number of tokens to send, review transaction details and confirm it. This will initiate the transaction signature wizard in your Trezor device. Here, take the following steps:</p> <ol> <li>Review all transaction details. Please note that the token corresponds to the network MetaMask is connected to. In this case, it is DEV tokens and not UNKN!</li> <li>Once all details have been checked, hold the button to confirm</li> </ol> <p>Note</p> <p>At the time of writing, the token name for all Moonbeam-related networks is always shown as <code>UNKN</code>. Please note that the token being handled is the one corresponding to the network MetaMask is connected to.</p> <p></p> <p>Right after you've approved the transaction, MetaMask sends it to the network. Once the transaction is confirmed, it will be displayed as Send on MetaMask's main screen.</p> <p></p> <p>And that is it! You've signed a transaction on Moonbase Alpha using your Trezor hardware wallet.</p> <p>The process of interacting with smart contracts using your Trezor device is similar. Make sure to double-check the data being signed on your Trezor device before confirming the transaction.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/governance/proposals/","title":"How to Propose an Action in OpenGov (Governance v2)","text":""},{"location":"tokens/governance/proposals/#introduction","title":"Introduction","text":"<p>A proposal is a submission to the chain in which a token holder suggests for an action to be enacted by the system. Proposals are one of the core elements of the governance system because they are the main tool for community members to propose actions/changes, which other token holders then vote on.</p> <p>In Moonbeam, users are able to create and vote on proposals using their H160 address and private key, that is, their regular Ethereum account!</p> <p>This guide will outline the process, with step-by-step instructions, of how to submit a proposal for other token holders to vote on in OpenGov (Governance v2). This guide will show you how to submit the proposal on Moonbase Alpha, but it can be easily adapted for Moonbeam and Moonriver. There is a separate guide on How to Vote on a Proposal in OpenGov.</p> <p>For more information on Moonbeam's governance system, please refer to the Governance on Moonbeam overview page.</p>"},{"location":"tokens/governance/proposals/#definitions","title":"Definitions","text":"<p>Some of the key parameters for this guide are the following:</p> <ul> <li>Proposal \u2014 an action or item, defined by the preimage hash, being proposed by a token holder and open for consideration and discussion by token holders</li> <li> <p>Referendum \u2014 a proposal that is up for token-holder voting. Each referendum is tied to a specific proposal for a change to the Moonbeam system including values for key parameters, code upgrades, or changes to the governance system itself</p> </li> <li> <p>Preimage hash \u2014 hash of the proposal to be enacted. The first step to make a proposal is to submit a preimage. The hash is just its identifier. The proposer of the preimage can be different than the user that proposes that preimage as a formal proposal</p> </li> <li> <p>Preimage deposit \u2014 amount of tokens that the proposer needs to bond when submitting a preimage. It is calculated as the sum of a base deposit per network plus a fee per byte of the preimage being proposed</p> </li> <li> <p>Submission Deposit - the minimum deposit amount for submitting a public referendum proposal</p> </li> <li> <p>Lead-in Period \u2014 the initial proposal voting and discussion period. At this stage, proposals are in an undecided state until they pass some criteria for the given Track. The criteria include:</p> <ul> <li>Prepare Period \u2014 the minimum time the referendum needs to wait before it can progress to the next phase after submission</li> <li>Capacity \u2014 limit for the number of referenda on a given Track that can be decided at once</li> <li>Decision Deposit \u2014 the minimum deposit amount required for a referendum to progress to the decision phase after the end of the Lead-in Period. Since each Track has a defined Capacity, this deposit is larger than the submission deposit, and its goal is to mitigate spam </li> </ul> </li> </ul> <p>Make sure you check the Governance Parameters for each network and track.</p>"},{"location":"tokens/governance/proposals/#roadmap-of-a-proposal","title":"Roadmap of a Proposal","text":"<p>This guide will cover the first few steps outlined in the proposal roadmap, as highlighted in the diagram below. You'll learn how to submit your proposal idea to the Moonbeam Community Forum, submit a preimage, and submit your proposal on-chain using the preimage hash.</p> <p>You can find a full explanation in the Roadmap of a Proposal section on the Governance overview page.</p> <p></p>"},{"location":"tokens/governance/proposals/#submitting-your-idea-to-the-forum","title":"Submit your Idea to the Community Forum","text":"<p>Before diving into the steps for submitting a proposal, you'll want to get familiar with Moonbeam's Community Forum. It's highly recommended that you preface any proposal with a post on the forum to solicit feedback. You should allow a period of five days for the community to discuss and provide feedback on the Moonbeam Forum post before proceeding to submit the preimage and proposal.</p> <p>To access the Moonbeam Community Forum, you must be a member of the Moonbeam Discord community. You can then sign up to get access to the forum using your Discord credentials.</p> <p>Once you\u2019re logged in, you can explore the latest discussions, join conversations, and create your own discussion for a proposal idea you may have. Before posting or commenting for the first time, be sure to familiarize yourself with the FAQ to learn about the community guidelines.</p> <p></p> <p>When you're ready to create a post with the details of your proposal, you can head to the Governance page and click on Democracy Proposals.</p> <p></p> <p>From there, you can click on Open Draft and begin to draft your proposal using the template provided. Make sure to update the title of the post and add any of the optional tags, such as Moonbeam if the proposal is for the Moonbeam network. The title should follow the format as the pre-populated title: [Proposal: XX][Status: Idea] proposal title. For example, [Proposal: XX][Status: Idea] Register XC-20 xcMYTOK. The XX will need to be updated with the proposal ID once the proposal has been formally submitted on-chain.</p> <p></p> <p>After you've filled out your proposal details, you can click Create Topic to save it to the forum and open the discussion on your idea. Based on the feedback you receive, you can update the proposal before proceeding to submit it.</p>"},{"location":"tokens/governance/proposals/#proposing-an-action","title":"Proposing an Action","text":"<p>This section goes over the process of creating a proposal with OpenGov (Governance v2) on Moonbase Alpha. These steps can be adapted for Moonbeam and Moonriver.</p> <p>To make a proposal in the network, you can use the Polkadot.js Apps interface. To do so, you need to import an Ethereum-style account first (H160 address), which you can do following the Creating or Importing an H160 Account guide. For this example, three accounts were imported and named with super original names: Alice, Bob, and Charlie.</p> <p></p> <p>For the proposal, you can choose anything you would like to propose, just make sure that you assign it to the right Origin and Track, so that it has the right privileges to execute the action.</p> <p>For the purposes of this guide, the action will be to set an on-chain remark using the General Admin Origin and Track.</p>"},{"location":"tokens/governance/proposals/#submitting-a-preimage-of-the-proposal","title":"Submitting a Preimage of the Proposal","text":"<p>The first step is to submit a preimage of the proposal. This is because the storage cost of large preimages can be pretty hefty, as the preimage contains all the information regarding the proposal itself. With this configuration, one account with more funds can submit a preimage and another account can submit the proposal.</p> <p>First, navigate to Moonbase Alpha's Polkadot.js Apps interface. Everything related to governance lives under the Governance tab, including preimages. So, from the Governance dropdown, you can select Preimages. Once there, click on the Add preimage button.</p> <p></p> <p>Here, you need to provide the following information:</p> <ol> <li>Select the account from which you want to submit the preimage</li> <li>Choose the pallet you want to interact with and the dispatchable function (or action) to propose. The action you choose will determine the fields that need to fill in the following steps. In this case, it is the system pallet and the remark extrinsic</li> <li>Enter any additional fields required for the extrinsic to be dispatched. For this example, you can enter the remark in hex or ascii format</li> <li>Copy the preimage hash. This represents the proposal. You will use this hash when submitting the actual proposal</li> <li>Click the Submit preimage button and sign the transaction</li> </ol> <p></p> <p>Note</p> <p>Make sure you copy the preimage hash, as it is necessary to submit the proposal.</p> <p>Note that the storage cost of the preimage can be calculated as the base fee (per network) plus the fee per byte of the preimage being proposed.</p> <p>After the transaction is submitted, you will see some confirmations on the top right corner of the Polkadot.js Apps interface and the preimage will be added to the list of preimages.</p>"},{"location":"tokens/governance/proposals/#submitting-a-proposal-v2","title":"Submitting a Proposal","text":"<p>Once you have committed the preimage (check the previous section), the roadmap's next major milestone is to submit the proposal related to it. To do so, select Referenda from the Governance dropdown, and click on Submit proposal.</p> <p>In order to submit a proposal, you'll need to choose which Origin class you want your proposal to be executed with. Choosing the wrong Track/Origin might result in your proposal failing at execution. For more information on each Origin class, please refer to the General Definitions section on the Governance on Moonbeam overview page.</p> <p></p> <p>Here, you need to provide the following information:</p> <ol> <li>Select the account from which you want to submit the proposal (in this case, Alice)</li> <li>Choose the Track to submit the proposal to. The Origin associated with the Track will need to have enough authority to execute the proposed action. For this example, to add an on-chain remark, you can select 2 / General Admin from the submission track dropdown</li> <li>In the origin dropdown, choose Origins</li> <li>In the Origins dropdown, select the Origin, which in this case is GeneralAdmin</li> <li>Enter the preimage hash related to the proposal. In this example, it is the hash of the <code>system.remark</code> preimage from the previous section</li> <li>Choose the moment of enactment, either after a specific number of blocks, or at a specific block. It must meet the minimum Enactment Period, which you can find in OpenGov's Governance Parameters</li> <li>Enter the number of blocks or the specific block to enact the proposal at</li> <li>Click Submit proposal and sign the transaction</li> </ol> <p></p> <p>Note</p> <p>Tokens might be locked for an indeterminate amount of time because it is unknown when a proposal may become a referendum (if ever).</p> <p>After the transaction is submitted, you will see some confirmations on the top right corner of the Polkadot.js Apps interface. You should also see the proposal listed in the associated Origin section, displaying the proposed action, proposer, and more.</p> <p>If you login to Polkassembly with the same account that you used to create the proposal, you'll be able to edit the description of the proposal to include a link to the proposal discussion on the Moonbeam Community Forum. This is a helpful step because while Polkassembly auto-generates a post for each proposal, it doesn't provide context information on the contents of the proposal.</p> <p>The proposal is now in the Lead-in Period and is ready to be voted on! In order for your proposal to progress out of the Lead-in Period to the next phase, at a minimum the Prepare Period will need to pass so there is enough time for the proposal to be discussed, there will need to be enough Capacity in the chosen Track, and the Decision Deposit will need to be submitted. The deposit can be paid by any token holder. If there isn't enough Capacity or the Decision Deposit hasn't been submitted, but the Prepare Period has passed, the proposal will remain in the Lead-in Period until all of the criteria is met.</p> <p>To learn how to vote on a proposal, please refer to the How to Vote on a Proposal in OpenGov guide.</p>"},{"location":"tokens/governance/treasury-spend/","title":"How to Propose a Treasury Spend","text":""},{"location":"tokens/governance/treasury-spend/#introduction","title":"Introduction","text":"<p>Treasury spending proposals enable community members to request funding for projects that benefit the Moonbeam network, such as infrastructure improvements, resources, events, and ecosystem tools. The Treasury Council reviews proposals and weighs community feedback received in the Moonbeam Forum. However, the ultimate Aye/Nay decision rests with the Council. For more information about the structure of the Treasury Council, see the Treasury page.</p> <p>In this guide, you'll learn how to prepare and submit a Treasury spending proposal and understand the full lifecycle of a Treasury proposal. </p>"},{"location":"tokens/governance/treasury-spend/#definitions","title":"Definitions","text":"<p>Some of the key parameters for this guide are the following:</p> <ul> <li>Treasury address \u2014 the address where Treasury funds accrue and are disbursed from</li> <li>Beneficiary \u2014 the address, such as a Moonbeam Safe multisig, that will receive the funds of the Treasury proposal if enacted</li> <li>Value \u2014 the amount that is being asked for and will be allocated to the beneficiary address if the Treasury proposal is passed</li> </ul>"},{"location":"tokens/governance/treasury-spend/#treasury-addresses","title":"Treasury Addresses","text":"<p>The Treasury address for each respective network can be found below:</p> MoonbeamMoonriverMoonbase Alpha <p>0x6d6F646c70632f74727372790000000000000000</p> <p>0x6d6f646C70792f74727372790000000000000000</p> <p>0x6d6F646c70632f74727372790000000000000000</p>"},{"location":"tokens/governance/treasury-spend/#roadmap-of-a-treasury-proposal","title":"Roadmap of a Treasury Proposal","text":"<p>The happy path of a Treasury spend request is as follows:</p> <ol> <li> <p>Proposal submission - the user submits a proposal to the Moonbeam Forum</p> </li> <li> <p>Forum discussion - the proposal is discussed by the community on the Forum. The ultimate Aye/Nay decision is determined by the Treasury council</p> </li> <li> <p>Treasury approval and action - if the Treasury Council agrees, it authorizes the Treasury spending and moves the process forward</p> </li> </ol> <p></p>"},{"location":"tokens/governance/treasury-spend/#submitting-your-idea-to-the-forum","title":"Submit Your Idea to the Forum","text":"<p>As mentioned in the happy path above, the first step of a Treasury proposal is to submit the proposal to the Moonbeam Forum. You'll need to have an account on the Moonbeam Forum and be logged in before submitting a Treasury spend proposal. To submit a Treasury spend proposal, follow these steps:</p> <ol> <li>From the Governance section, click New Topic. By starting the topic in the Governance section, the proposal will come pre-filled with a template to ensure you cover all the necessary points </li> <li>Provide a title for the proposal</li> <li>Enter the contents of the proposal, covering: the Title and Proposal Status, a brief Abstract, the Motivation, a Project Overview and Team Experience, the Rationale, any Key Terms, the Overall Cost, the Use of Treasury Funds, the Technical Specifications, and the Steps to Implement</li> <li>Choose either Moonbeam or Moonriver as a tag to indicate which network your Treasury proposal applies to</li> <li>Press Create Topic</li> </ol> <p></p>"},{"location":"tokens/governance/treasury-spend/#next-steps","title":"Next Steps","text":"<p>No further steps are required after proposing the spend. Members of the Treasury Council will complete all on-chain actions. If approved by the Treasury Council, the delivery of the Treasury payment to the designated beneficiary will happen automatically. For more information about the Treasury Council voting process, see the Treasury page.</p>"},{"location":"tokens/governance/voting/","title":"How to Vote on a Proposal in Governance v2: OpenGov","text":""},{"location":"tokens/governance/voting/#introduction","title":"Introduction","text":"<p>Referenda are simple, inclusive, and stake-based voting schemes. Each referendum has a proposal associated with it that suggests an action to take place. In OpenGov, each referendum will have a specified Origin class that the proposal will be executed with, and each Origin has its own Track that proposals will process through. Although referenda are completed by a common process, the requirements for approval are Track-specific.</p> <p>Token holders can vote on referenda using their own tokens, including those that are locked in staking. The weight of a vote is defined by two factors: the number of tokens locked and the lock duration (called Conviction). This is to ensure that there is an economic buy-in to prevent vote-selling. Consequently, the longer you are willing to lock your tokens, the stronger your vote will be weighted. You also have the option of not locking tokens at all, but the vote weight is drastically reduced.</p> <p>In Moonbeam, users are able to create and vote on proposals using their H160 address and private key, that is, their regular Ethereum account!</p> <p>This guide will outline the process, with step-by-step instructions, of how to vote on referenda in Governance v2: OpenGov. This guide will show you how to vote on Moonbase Alpha, but it can be easily adapted for Moonbeam and Moonriver.</p> <p>Note</p> <p>This page goes through the mechanics of how to vote at a more technical level. Token holders can leverage platforms such as Polkassembly to vote using a more friendly user interface.</p>"},{"location":"tokens/governance/voting/#definitions","title":"Definitions","text":"<p>Some of the key parameters for this guide are the following:</p> <ul> <li> <p>Voting \u2014 a mechanism for token holders to support (Aye), oppose (Nay), or remain neutral (Abstain) on a proposal. For Aye and Nay, the voting weight is determined by both the number of tokens locked and the lock duration (Conviction). Abstain votes do not receive additional weighting</p> <ul> <li>Conviction \u2014 the time that token holders voluntarily lock their tokens when voting; the longer they are locked, the more weight their vote has</li> <li>Lock balance \u2014 the number of tokens that a user commits to a vote (note, this is not the same as a user's total account balance) Moonbeam uses the concept of voluntary locking, which allows token holders to increase their voting power by locking tokens for a longer period of time. Specifying no Lock Period means a user's vote is valued at 10% of their lock balance. Specifying a greater Conviction increases voting power. For each increase in Conviction (vote multiplier), the Lock Periods double</li> </ul> </li> <li> <p>Maximum number of votes \u2014 the maximum number of concurrent votes per account</p> MoonbeamMoonriverMoonbase Alpha <pre><code>512 votes\n</code></pre> <pre><code>512 votes\n</code></pre> <pre><code>512 votes\n</code></pre> </li> <li> <p>Approval \u2014 minimum \"Aye\" votes as a percentage of overall Conviction-weighted votes needed for approval</p> </li> <li> <p>Support \u2014 the minimum portion of Aye and Abstain votes (ignoring conviction) needed as a percentage of the total active supply for a proposal to pass. Nay votes do not count toward Support</p> </li> <li> <p>Lead-in Period \u2014 the initial proposal voting and discussion period. At this stage, proposals are in an undecided state until they pass some criteria for the given Track. The criteria include:</p> <ul> <li>Prepare Period \u2014 the minimum time the referendum needs to wait before it can progress to the next phase after submission</li> <li>Capacity \u2014 limit for the number of referenda on a given Track that can be decided at once</li> <li>Decision Deposit \u2014 the minimum deposit amount required for a referendum to progress to the decision phase after the end of the Lead-in Period. Since each Track has a defined Capacity, this deposit is larger than the submission deposit, and its goal is to mitigate spam </li> </ul> </li> <li> <p>Decide Period - token holders continue to vote on the referendum. If a referendum does not pass by the end of the period, it will be rejected, and the Decision Deposit will be refunded</p> </li> <li>Confirm Period - a period of time within the Decide Period where the referendum needs to have maintained enough Approval and Support to be approved and move to the Enactment Period</li> <li> <p>Enactment Period - a specified time, which is defined at the time the proposal was created, that meets at least the minimum amount of time that an approved referendum waits before it can be dispatched</p> </li> <li> <p>Vote Delegation \u2014 a voter can give their voting power, including Conviction voting, to another token holder (delegate), who may be more knowledgeable and able to make specific decisions</p> </li> <li>Multirole Delegation \u2014 the ability to delegate voting power on a Track-by-Track basis, where a token holder can specify different delegates for each Track</li> </ul> <p>For an overview of the Track-specific parameters such as the length of the Decide, Confirm, and Enactment Period, the Approval and Support requirements, and more, please refer to the Governance Parameters for OpenGov (Governance v2) section of the governance overview page.</p>"},{"location":"tokens/governance/voting/#roadmap-of-a-proposal","title":"Roadmap of a Proposal","text":"<p>This guide will cover how to vote on public referenda, as seen in the steps highlighted in the proposal roadmap diagram below. In addition to learning how to vote on referenda, you'll also learn how the proposal progresses through the Lead-in Period, the Decide and Confirm Period, and the Enactment Period.</p> <p>You can find a full explanation of the happy path for an OpenGov proposal on the Governance overview page.</p> <p></p>"},{"location":"tokens/governance/voting/#forum-discussion","title":"Forum Discussion","text":"<p>A vote on a democracy referendum is a binary outcome. However, a token holder's opinion is often more nuanced than yes or no, which is why it's strongly recommended that you preface any proposal with a post on Moonbeam's Community Forum.</p> <p>The forum serves the critical role of providing a platform for discussion and allowing proposers to receive feedback from the community prior to an on-chain action. Creating a post on the forum is quick and easy, as shown in the Using the Moonbeam Community Forum guide. There are categories corresponding to each type of proposal, including democracy, treasury, and grant proposals. While this step is optional, explaining the details of the proposal and following up with any questions raised may increase the chances of the initiative being accepted and subsequently passed by the community.</p> <p></p>"},{"location":"tokens/governance/voting/#voting-on-a-referendum","title":"Voting on a Referendum","text":"<p>This section goes over the process of voting on a public referendum in OpenGov (Governance v2) on Moonbase Alpha. These steps can be adapted for Moonbeam and Moonriver. The guide assumes that there is one already taking place. If there is an open referendum that you want to vote on, you can adapt these instructions to learn how to vote on it.</p> <p>To vote on a proposal on the network, you need to use the Polkadot.js Apps interface. To do so, you need to import an Ethereum-style account first (H160 address), which you can do by following the Creating or Importing an H160 Account guide. For this example, three accounts were imported and named with super original names: Alice, Bob, and Charlie.</p> <p></p> <p>To get started, you'll need to navigate to Moonbase Alpha's Polkadot.js Apps interface. Everything related to governance lives under the Governance tab. To view all of the referenda, you can choose Referenda from the Governance dropdown. On the Referenda page, you'll see a list of referenda organized by Track. To view the details of a specific referendum, you can click on the arrow next to the description. The number next to the action and description is called the referendum index.</p>"},{"location":"tokens/governance/voting/#submit-decision-deposit","title":"How to Support a Proposal by Contributing to the Decision Deposit","text":"<p>In order for a referendum to move out of the Lead-in Period into the Decide Period, the Decision Deposit must be submitted. This deposit can be submitted by the author of the proposal or any other token holder. The deposit varies depending on the Track of the proposal.</p> <p>For example, a referendum that is in the General Admin Track has a Decision Deposit of 500 on Moonbase Alpha.</p> <p>From the list of referenda on Polkadot.js Apps, you may notice that some proposals are in the Preparing state. If a referendum requires the Decision Deposit to be submitted, you'll see a Decision deposit button. To submit the deposit, you can go ahead and click on this button.</p> <p></p> <p>Then take the following steps to submit the deposit from a specific account:</p> <ol> <li>Select the deposit from account. This account does not need to be the author of the proposal; it can be from any token holder. However, if the proposal is deemed malicious, the Decision Deposit will be burned. So, before placing the deposit, it is advised to do your due diligence to ensure the proposal is not malicious</li> <li>The referendum id and decision deposit fields will automatically be populated for you based on the referendum and Track it belongs to</li> <li>Click Place deposit and sign the transaction</li> </ol> <p></p> <p>Once the deposit has been placed, Polkadot.js Apps will update and display the account that paid the Decision Deposit along with the amount of the deposit. Now this referendum is one step closer to meeting the criteria of the Lead-in Period.</p> <p>If the Prepare Period has passed and there is enough space for a referendum in the General Admin Track, this proposal will move on to the Decide Period.</p>"},{"location":"tokens/governance/voting/#how-to-vote","title":"How to Vote","text":"<p>As you may have noticed, voting is not required in the Lead-in Period. However, it is essential in the Decide Period. The steps in this section will apply to referenda in both the Lead-in Period and the Decide Period.</p> <p>To vote and lock tokens either in favor of or against a referendum, you can get started by clicking on the Vote button next to the referendum you want to vote on.</p> <p></p> <p>Then you can take the following steps to fill in the details of the vote:</p> <ol> <li>Select the vote with account</li> <li>Choose how you would like to vote on the referendum. You can choose Aye in favor of the referendum, Nay in opposition to it, or Split if you want to specify an \"Aye\" vote value and a \"Nay\" vote value</li> <li>Enter the vote value</li> <li>Set the vote conviction, which determines the weight of your vote (<code>vote_weight = tokens * conviction_multiplier</code>). Please refer to the Conviction multiplier docs for more information</li> <li>Click Vote and sign the transaction</li> </ol> <p></p> <p>Note</p> <p>The lockup periods shown in the previous image are not to be taken as references as they are subject to change.</p> <p>To see how your vote and all of the other votes for a referendum impacted the Approval and Support curves, you can click on the arrow next to the Vote button. You'll notice there are two charts, one for each curve. If you hover over the charts, you can see the minimum Approval or Support required for a specific block along with the current Approval or Support.</p> <p></p> <p>A proposal in the General Admin Track on Moonbase Alpha would have the following characteristics:</p> <ul> <li>The Approval curve starts at 100% on Day 0 and goes to 80% on Day 4</li> <li>The Support curve starts at 50% on Day 0 and goes to 10% on Day 7</li> <li>A referendum starts the Decide Period with 0% \"Aye\" votes (nobody voted in the Lead-in Period)</li> <li>Token holders begin to vote, and the Approval increases to a value above 80% by Day 4</li> <li>If the Approval and Support thresholds are met for the duration of the Confirm Period (14400 blocks, approximately 1 day), the referendum is approved</li> <li>If the Approval and Support thresholds are not met during the Decision Period, the proposal is rejected. Note that the thresholds need to be met for the duration of the Confirm Period. Consequently, if they are met but the Decision Period expires before the completion of the Confirm Period, the proposal is rejected</li> </ul> <p>In the following image, you'll notice enough Approval and Support have been received, so the Confirm Period is underway. If the referendum maintains the Approval and Support levels, at block 124,962, the Confirm Period will end, and then the Enactment Period will begin. You can hover over the charts to find out more information on each of these periods. Assuming this referendum maintains the levels of Approval and Support it has received, the Enactment Period will end at block 132,262, and the proposal action will be dispatched.</p> <p></p> <p>If the referendum doesn't continuously receive enough Approval and Support during the Confirm Period, it still has a chance to pass as long as the Approval and Support requirements are met again and continuously for the duration of the Confirm Period. If a referendum enters the Confirm Period but the Decide Period is set to end before the Confirm Period is over, the Decide Period will actually be extended until the end of the Confirm Period. If the Decide Period ends and the referendum still hasn't received enough Approval and Support, the referendum will be rejected, and the Decision Deposit can be refunded.</p> <p>The Enactment Period is defined by the author of the proposal at the time it was initially submitted, but it needs to be at least the minimum Enactment Period.</p>"},{"location":"tokens/governance/voting/#delegate-voting","title":"Delegate Voting","text":"<p>Token holders have the option to delegate their vote to another account whose opinion they trust. The account being delegated does not need to take any particular action. When they vote, the vote weight (that is, tokens times the Conviction multiplier chosen by the delegator) is added to their vote.</p> <p>With the introduction of OpenGov (Governance v2), token holders can even delegate their vote on a Track-by-Track basis and specify different delegates for each Track, which is referred to as Multirole Delegation.</p> <p>From the referenda page on Polkadot.js Apps, you can click Delegate to get started.</p> <p></p> <p>Then you can take the following steps to fill in the details of the delegation:</p> <ol> <li>Enter the delegate from account, which should be the account that you wish to delegate your vote from</li> <li>Select the submission track or switch the apply delegation to all tracks slider to on if you want the other account to vote on your behalf on any of the Tracks</li> <li>Enter the delegated vote value</li> <li>Set the vote conviction, which determines the weight of your vote (<code>vote_weight = tokens * conviction_multiplier</code>). Please refer to the Conviction Multiplier docs for more information</li> <li>Click Next</li> <li>On the next screen, select the delegate to address, which should be the account that you wish to delegate your vote to</li> <li>Click Delegate and sign the transaction</li> </ol> <p></p> <p>Now the account you selected to delegate your vote to will be able to vote on your behalf. Once this account votes, the total vote weight delegated will be allocated to the option that the account selected. For this example, Baltahar can vote in favor of a referendum with a total weight of 20000 (10000 tokens with an x2 Conviction factor) using the vote weight that Charleth delegated to him.</p> <p>You can continue the above process for each Track and delegate a different account with varying vote weights.</p> <p>To undelegate a delegation, you'll need to head to the Developer tab and click on Extrinsics. From there, you can take the following steps:</p> <ol> <li>Select the account you have delegated from</li> <li>Choose the convictionVoting pallet and the undelegate extrinsic</li> <li>Enter the class of the Origin. For the General Admin Track, it is <code>2</code>. For a complete list of Track IDs, refer to the OpenGov section of the governance overview page</li> <li>Click Submit transaction and sign the transaction</li> </ol> <p></p>"},{"location":"tokens/governance/voting/#refund-the-decision-deposit","title":"Refunding the Decision Deposit","text":"<p>If a referendum has been approved or rejected, the Decision Deposit will be eligible to be refunded, as long as it was not rejected due to it being a malicious proposal. Malicious proposals will result in the Decision Deposit being slashed. Any token holder can trigger the refund of the deposit back to the original account that placed the deposit. To refund the deposit, you can take the following steps on the referenda page on Polkadot.js Apps. If the referendum is eligible and the deposit hasn't already been refunded, you'll see a Refund deposit button. So, you can go ahead and click that button to get started.</p> <p></p> <p>Then, to submit the refund transaction, you can:</p> <ol> <li>Choose the account for which you want to trigger the refund. This does not need to be the account that initially placed the deposit</li> <li>Click Refund deposit and sign the transaction</li> </ol> <p></p>"},{"location":"tokens/governance/voting/#unlocking-locked-tokens","title":"Unlocking Locked Tokens","text":"<p>When token holders vote, the tokens used are locked and cannot be transferred. You can verify if you have any locked tokens in the Accounts tab by expanding the address's account details. There, you will see different types of balances. If you have any tokens locked in referenda, you'll see referenda listed in your balance details, and you can hover over it to find out details about which referendum your tokens are locked for. Different lock statuses include:</p> <ul> <li>Locked because of an ongoing referendum, meaning that you've used your tokens and have to wait until the referendum finishes, even if you've voted with a no-lock Conviction factor</li> <li>Locked because of the Conviction multiplier selected, displaying the number of blocks and time left</li> <li>Lock expired, meaning that you can now get your tokens back</li> </ul> <p></p> <p>Once the lock has expired, you can request your tokens back. To do so, navigate to the Extrinsics menu under the Developers tab. Here, two different extrinsics need to be sent. First, you need to provide the following information:</p> <ol> <li>Select the account from which you want to recover your tokens</li> <li>Choose the pallet you want to interact with. In this case, it is the <code>convictionVoting</code> pallet and the extrinsic to use for the transaction. This will determine the fields that you need to fill in the following steps. In this case, it is <code>removeVote</code> extrinsic. This step is necessary to unlock the tokens. This extrinsic can also be used to remove your vote from a referendum</li> <li>Optionally, you can specify the Track ID to remove votes for. To do so, simply toggle the include option slider and enter the Track ID in the class u16 field</li> <li>Enter the referendum index. This is the number that appeared on the left-hand side of the Referenda tab</li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p> <p>For the next extrinsic, you need to provide the following information:</p> <ol> <li>Select the account from which you want to recover your tokens</li> <li>Choose the pallet you want to interact with. In this case, it is the <code>convictionVoting</code> pallet</li> <li>Choose the extrinsic method to use for the transaction. This will determine the fields that need to be filled out in the following steps. In this case, it is the <code>unlock</code> extrinsic</li> <li>Enter the Track ID to remove the voting lock for</li> <li>Enter the target account that will receive the unlocked tokens. In this case, the tokens will be returned to Alice</li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p> <p>Once the transaction goes through, the locked tokens should be unlocked. To double-check, you can go back to the Accounts tab and see that your full balance is now transferable.</p>"},{"location":"tokens/manage/identity/","title":"Managing your Account Identity","text":""},{"location":"tokens/manage/identity/#introduction","title":"Introduction","text":"<p>The Substrate Identity pallet is an out-of-the-box solution for adding personal information to your on-chain account. Personal information can include default fields such as your legal name, display name, website, Twitter handle, Riot (now known as Element) name. You can also take advantage of custom fields to include any other relevant information.</p> <p>Once your identity information is on-chain, you can request verification of your identity from a registrar. A registrar will perform proper due diligence to verify the submitted identity information and based on their findings will provide their judgement on-chain and a green check mark will appear next to your account.</p> <p>This guide will show you how to set an identity, clear it, and request judgement on the Moonbase Alpha TestNet. This guide can also be adapted to be used on Moonbeam and Moonriver.</p>"},{"location":"tokens/manage/identity/#general-definitions","title":"General Definitions","text":"<p>To store your information on-chain, you must bond some funds, which eventually will be returned once the identity has been cleared. There are two categories of fields: default and custom. If custom fields are used, you will be required to submit an additional deposit for each field.</p> <ul> <li> <p>Default fields include - your legal name, display name, website, Twitter handle, Riot (now known as Element) name</p> </li> <li> <p>Custom fields include - any other relevant information. For example, you could include your Discord handle</p> </li> </ul> MoonbeamMoonriverMoonbase Alpha Variable Definition Value Basic deposit The amount held on deposit for setting an identity 1.0258 GLMR Field deposit The amount held on deposit per additional field for setting an identity 0.0066 GLMR Max additional fields Maximum number of additional fields that may be stored in an ID 100 Variable Definition Value Basic deposit The amount held on deposit for setting an identity 1.0258 MOVR Field deposit The amount held on deposit per additional field for setting an identity 0.0066 MOVR Max additional fields Maximum number of additional fields that may be stored in an ID 100 Variable Definition Value Basic deposit The amount held on deposit for setting an identity 1.0258 DEV Field deposit The amount held on deposit per additional field for setting an identity 0.0066 DEV Max additional fields Maximum number of additional fields that may be stored in an ID 100"},{"location":"tokens/manage/identity/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For this guide, you will need the following:</p> <ul> <li>To connect to the Moonbase Alpha TestNet on the Polkadot.js Apps explorer. You can also follow along and adapt the instructions for Moonbeam or Moonriver.</li> <li>To create or import an account into Polkadot.js Apps</li> <li>Make sure you have funded your account.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul>"},{"location":"tokens/manage/identity/#get-started","title":"Get Started","text":"<p>There are a couple different ways to set and clear an identity using the Polkadot.js Apps, depending on the information to be included. If you intend to register your identity using only the default fields, you can follow the instructions for Managing an Identity via the Accounts UI. This is the recommended way to set and manage your identity.</p> <p>If you are looking for a more customizable experience and want to add custom fields beyond the default fields, you can follow the instructions for Managing an Identity via the Extrinsics UI.</p> <p>Note</p> <p>Please note that it is recommended to use the Accounts UI on Polkadot.js Apps to manage your identity as it provides an easy-to-use interface that enforces character limits. If you use the Extrinsics UI, please be aware that your input for each field (i.e, name, email, etc.) must be 32 characters or less, otherwise, your information will be cut off.</p>"},{"location":"tokens/manage/identity/#manage-via-accounts","title":"Manage an Identity via Accounts","text":""},{"location":"tokens/manage/identity/#set-identity-accounts","title":"Set an Identity","text":"<p>To get started with setting an identity using the Accounts UI, head to the Accounts tab on the Polkadot.js Apps explorer.</p> <p>You should already have an account connected, so you can go ahead and click on your account name to verify and take note of your balances. After you send the transaction to set an identity, the deposit(s) you submitted will be moved from your transferable balance to your reserved balance.</p> <p></p> <p>To set your identity, you'll need to:</p> <ol> <li>Click on the 3 vertical dots next to the account you would like to set an identity for</li> <li>A menu will pop up. Click Set on-chain identity</li> </ol> <p></p> <p>Next, the menu to register and set your identity will pop-up and you can start filling in your information. You are not required to enter information for every single field, you can choose to fill in just one field or all of them, it's up to you. For this example:</p> <ol> <li>Set your display name</li> <li>Click on the include field toggle for email and then enter in your email</li> <li>Click on the include field toggle for Twitter and then enter in your Twitter handle</li> <li>After you're done filling in your information and the deposit amount looks alright to you, click Set Identity</li> </ol> <p></p> <p>You will then be prompted to sign the transaction. If everything looks good, you can enter your password and click Sign and Submit to sign and send the transaction.</p> <p>You should see status notifications pop-up in the top right hand corner. Once the transaction has been confirmed, you can click on your account name again and the panel will slide out on the right side of the page. Your balances will have changed, and you\u2019ll also see your new identity information.</p> <p></p> <p>If the identity information matches what you entered, you\u2019ve successfully set an identity!</p> <p>Once you clear your identity, the deposit in your reserved balance will get transferred back to your transferable balance. If you need to make changes to your identity, you can go through the process of setting your identity again. Please note that you will need to ensure all fields are re-entered, even if only one field needs to be changed, or they will be overwritten. You will not need to pay another deposit, unless custom fields are used, but you will need to pay gas fees.</p>"},{"location":"tokens/manage/identity/#clear-identity-accounts","title":"Clear an Identity","text":"<p>To clear your identity from the Accounts tab of the Polkadot.js Apps UI, you'll need to:</p> <ol> <li>Click on the 3 vertical dots next to the account you would like to add identity information for</li> <li>A menu will pop up. Click Set on-chain identity</li> </ol> <p></p> <p>The identity menu will pop-up with your information already filled out. You'll need to click Clear Identity.</p> <p></p> <p>You will then be prompted to sign the transaction. If everything looks good, you can enter your password and click Sign and Submit to sign and send the transaction.</p> <p>You should see status notifications pop-up in the top right hand corner. Once the transaction has been confirmed, you can click on your account name again and the panel will slide out on the right side of the page. You can see your reserved balance was transferred back to your transferable balance, and your identity information has been removed.</p> <p>That\u2019s it! You\u2019ve successfully cleared your identity. If you want to add a new identity, you can do so at any time.</p>"},{"location":"tokens/manage/identity/#manage-via-extrinsics","title":"Manage an Identity via Extrinsics","text":""},{"location":"tokens/manage/identity/#set-identity-extrinsics","title":"Set an Identity","text":"<p>To register an identity using the extrinsics UI, navigate to the Extrinsics page on Polkadot.js Apps. Then, you'll need to:</p> <ol> <li>Select your account</li> <li>Select identity from the submit the following extrinsic dropdown</li> <li>Then select the setIdentity(info) function</li> <li>Start filling in your identity information. Please make sure that for each field, your input does not exceed 32 characters<ol> <li>Select the format of the data. For this example, you can use Raw data but you also have the option of entering your data in BlackTwo256, Sha256, Keccak256, and ShaThree256 hashed format</li> <li>Enter the data in that format</li> </ol> </li> </ol> <p></p> <p>Optionally, if you would like to enter custom fields, you can do so by:</p> <ol> <li>Scrolling to the top and clicking on Add item</li> <li>Two fields will appear: the first for the field name and the second for the value. Please make sure that for each field and value, your input does not exceed 32 characters. Fill in the field name<ol> <li>Select the format of the data for the field name. Again, you can use Raw data</li> <li>Enter the field name in the selected format</li> </ol> </li> <li>Fill in the value<ol> <li>Select the format of the data for the value. Again, you can use Raw data</li> <li>Enter the value in the selected format</li> </ol> </li> </ol> <p></p> <p>Finally, once all of your identity information has been added, you can scroll to the bottom of the page and click Submit Transaction.</p> <p></p> <p>You will then be prompted to sign the transaction. Remember, there is an additional deposit required for each additional custom field. If everything looks good, you can enter your password and click Sign and Submit to sign and send the transaction.</p> <p>You should see status notifications pop-up in the top right hand corner confirming the transaction. If successful, you\u2019ve set an identity! Congratulations! To make sure everything went through and your identity information looks good, next you can confirm your identity.</p>"},{"location":"tokens/manage/identity/#confirm-identity-extrinsics","title":"Confirm an Identity","text":"<p>To verify the addition of your identity information, you can click on the Developer tab and then navigate to Chain state.</p> <p>On the Chain State UI, make sure Storage is selected. Then you can start to request your identity information:</p> <ol> <li>Set selected state query to identity</li> <li>Select the identityOf(AccountId) function</li> <li>Select your account</li> <li>Click the + button to get your identity information</li> </ol> <p></p> <p>You can see now that you\u2019ve successfully set an identity! Once you clear your identity, the deposit in your reserved balance will get transferred back to your transferable balance. If you need to make changes to your identity, you can go through the process of setting your identity again. Please note that you will need to ensure all fields are re-entered, even if only one field needs to be changed, or they will be overwritten. You will not need to pay another deposit, unless custom fields are used, but you will need to pay gas fees.</p>"},{"location":"tokens/manage/identity/#clear-identity-extrinsics","title":"Clear an Identity","text":"<p>To clear your identity from the Extrinsics tab of the Polkadot.js Apps UI, you'll need to:</p> <ol> <li>Select your account from the using the selected account dropdown</li> <li>Select identity from the submit the following extrinsic dropdown</li> <li>Then select the clearIdentity() function</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>You will then be prompted to sign the transaction. If everything looks good, you can enter your password and click Sign and Submit to sign and send the transaction.</p> <p>You should see status notifications pop-up in the top right hand corner confirming the transaction.</p> <p>To verify the removal of your identity information, you can follow the steps in the Confirm an Identity section again. Instead of seeing your identity information, this time you'll get a response of none. Meaning, you no longer have any identity information associated with your account. If you check your balances, you should see that the initial deposit for setting your identity has been returned to your transferable balance. That\u2019s it! Your identity has been cleared.</p>"},{"location":"tokens/manage/identity/#identity-judgement","title":"Identity Judgement","text":"<p>After submitting your identity information, you can request verification of your identity from a registrar. Registrars are tasked with verifying the submitted identity information and can set a fee for their services. When you request judgement, you'll need to specify the registrar you want to verify your information and the maximum fee that you're willing to pay them for providing judgement. The request will only be processed if the selected registrar charges less than the maximum fee that you specified, otherwise the transaction will fail. The fee will be locked until the registrar completes the judgement process and only then will the fee be transferred to the registrar. The registrar fee is in addition to the deposit paid when you initially created your identity.</p> <p>Registrar applicants are appointed via on-chain democracy. If an appointed registrar issues incorrect judgements or proves to be untrustworthy, they can be removed through democracy.</p> <p>A registrar will perform proper due diligence to verify the submitted identity information and based on their findings will provide judgement and assign up to seven levels of confidence:</p> <ul> <li>Unknown - no judgement made yet. This is the default value</li> <li>Fee Paid - indicates a user has requested judgement and it is in progress</li> <li>Reasonable - the information appears reasonable, but no in-depth checks were performed using legal identity documents</li> <li>Known Good - the information is correct and is based upon review of legal identity documents</li> <li>Out of Date - the information used to be good, but is now out of date</li> <li>Low Quality - the information is low quality or imprecise, but can be updated as needed</li> <li>Erroneous - the information is erroneous and may indicate malicious intent. This state cannot be modified and can only be removed if the entire identity has been removed</li> </ul>"},{"location":"tokens/manage/identity/#current-registrars","title":"Current Registrars","text":"<p>When requesting identity judgement, you'll need to provide the index of the registrar you want to complete your request.</p> <p>The current registrars are as follows:</p> MoonbeamMoonriverMoonbase Alpha Registrar Operator Address Index Registrar #0 Moonbeam Foundation 0xbE6E642b25Fa7925AFA1600C48Ab9aA3461DC7f1 0 Registrar #1 Chevdor 0xeaB597B91b66d9C3EA5E3a39e22C524c287d61a5 1 Registrar Operator Address Index Registrar #0 Moonbeam Foundation 0x031590D13434CC554f7257A89B2E0B10d67CCCBa 0 Registrar #1 Chevdor 0x2d18250E01312A155E81381F938B8bA8bb4d97B3 1 Registrar Operator Address Index Registrar #1 Chevdor 0x4aD549e07E96BaD335A8b99C8fd32e95EE538904 1 <p>You can get a complete list of the current registrars, including the fees that each registrar charges, by heading to Polkadot.js Apps, selecting the Developer tab, choosing Chain State from the dropdown, and taking the following steps:</p> <ol> <li>Select the identity pallet</li> <li>Choose the registrars extrinsic</li> <li>Click the + button</li> </ol> <p></p>"},{"location":"tokens/manage/identity/#request-judgement","title":"Request Identity Judgement","text":"<p>To request identity judgement, from the Extrinsics page, you can take the following steps:</p> <ol> <li>Select your account from the using the selected account dropdown</li> <li>Select identity from the submit the following extrinsic dropdown</li> <li>Then select the requestJudgement() function</li> <li>Enter the index of the registrar you want to review and provide judgement on your identity information</li> <li>Enter the maximum fee you're willing to pay in Wei. This must be higher than the fee set by the registrar, otherwise the transaction will fail</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>Once the transaction goes through, the fee will be taken from your free balance and locked until the judgement is complete.</p> <p>After the judgement is complete and you've been successfully verified, a green check mark will appear next to your account. If successful, your identity will be assigned one of these three levels of confidence: low quality, reasonable, or known good. From the Accounts page, you can click on your account name to review your identity information and your identity judgement results.</p> <p></p>"},{"location":"tokens/manage/identity/#cancel-judgement-request","title":"Cancel Identity Judgement Request","text":"<p>If the registrar hasn't completed your judgement, you can cancel the request and receive the locked fee back. To do so, from the Extrinsics page, take the following steps:</p> <ol> <li>Select your account from the using the selected account dropdown</li> <li>Select identity from the submit the following extrinsic dropdown</li> <li>Then select the cancelRequest() function</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>You'll then be prompted to sign and send the transaction. Once it goes through, your locked funds will be returned to you.</p>"},{"location":"tokens/manage/multisig-safe/","title":"Interacting with Moonbeam Safe","text":""},{"location":"tokens/manage/multisig-safe/#introduction","title":"Introduction","text":"<p>A single-signature wallet, or singlesig for short, is a wallet in which only one owner holds the private key, and therefore has control over all the assets that account holds. Moreover, if the private key is lost, then access to the wallet and the funds are lost forever. </p> <p>To solve this problem, multi-signature wallets, or multisig for short, have been introduced. With a multisig wallet there is more than one owner, so one owner could lose their keys and the others would still have access to the wallet and funds. In addition, multisig wallets can require threshold signing, where a proposal is only executed as a transaction if a certain amount of approvals are attained. Therefore creating an extra layer of security.</p> <p>To help manage singlesig and multisig wallets, Gnosis Safe was forked to create Moonbeam Safe. The Safe can be configured as a multisig contract that allows two or more owners to hold and transfer funds to and from the Safe. You can also configure the Safe to be a singlesig contract with only one owner. </p> <p>This guide will show you how to create a multisig Safe on the Moonbase Alpha TestNet. You will also learn how to send DEV and ERC-20 tokens to and from the Safe, and how to interact with smart contracts using the Safe. This guide can be adapted for Moonbeam and Moonriver.</p>    The information presented herein is for informational purposes only and has been provided by third parties. Moonbeam does not endorse any project listed and described on the Moonbeam docs website (https://docs.moonbeam.network/)."},{"location":"tokens/manage/multisig-safe/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before diving into the guide, you'll need to have a few MetaMask accounts loaded up with funds, some ERC-20 tokens on hand to send to the Safe, and a deployed smart contract to interact with.</p>"},{"location":"tokens/manage/multisig-safe/#metamask-accounts","title":"MetaMask Accounts","text":"<p>For this guide, you will be creating a Safe on Moonbase Alpha to interact and manage your funds with. To connect to the Safe, you will need to have:</p> <ul> <li>MetaMask installed and connected to Moonbase Alpha</li> <li>At least two accounts each loaded with funds.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul> <p>You will need at least two accounts because you will be setting up a multisig Safe with 3 owners, and 2/3 confirmations for any transaction to get executed. Therefore, throughout this guide you will need to switch back and forth between at least two of the accounts to be able to confirm and send transactions. </p> <p>This guide will use the following accounts:</p> <ul> <li>Alice \u2014 0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</li> <li>Bob \u2014 0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</li> <li>Charlie \u2014 0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</li> </ul>"},{"location":"tokens/manage/multisig-safe/#erc20-tokens","title":"ERC-20 Tokens","text":"<p>Later on in this guide, you will be learning how to send and receive ERC-20 tokens to and from the Safe. So you will need to have deployed some ERC-20 tokens and added them to your MetaMask account. To do so, you can check out the Using Remix to Deploy to Moonbeam guide, in particular the Deploying a Contract to Moonbeam and Interact with a Moonbeam-based ERC-20 sections will show you how to deploy an ERC-20 token and import it into MetaMask.</p>"},{"location":"tokens/manage/multisig-safe/#deployed-smart-contract","title":"Deployed Smart Contract","text":"<p>Towards the end of this guide, you will be learning how to interact with a smart contract using the Safe. So you will need to have a smart contract deployed to interact with. If you would like detailed instructions, you can refer to the Deploying a Contract to Moonbeam using Remix guide.</p> <p>You can head to Remix and create a new file for the following <code>SetText.sol</code> contract:</p> <pre><code>pragma solidity ^0.8.30;\n\ncontract SetText {\n    string public text;\n\n    function setTextData(string calldata _text) public {\n        text = _text;\n    }\n}\n</code></pre> <p>This is a simple contract with a single function, <code>setTextData</code>, that accepts a string and uses it to set the <code>text</code> variable.</p> <p>You will need the contract address and the ABI, so make sure you have copied those somewhere or have access to them for later on.</p>"},{"location":"tokens/manage/multisig-safe/#create-a-safe","title":"Create a Safe","text":"<p>To get started creating a Safe, navigate to the Moonbeam Safe. For the purpose of this guide, you'll create a Safe on Moonbase Alpha, but you can also adapt the instructions to create a Safe on Moonbeam or Moonriver. To switch networks, simply click the network dropdown in the top right hand corner of the page. </p>"},{"location":"tokens/manage/multisig-safe/#connect-metamask","title":"Connect MetaMask","text":"<p>Once on the Moonbase Alpha page, you can begin to create a Safe by first connecting your wallet:</p> <ol> <li>Click Connect Wallet</li> <li>Select a wallet to connect to Moonbeam Safe. For this example you can use MetaMask. If MetaMask doesn't appear in the list of options, click Show More and select MetaMask</li> </ol> <p></p> <p>If you're not already signed into MetaMask, you will be prompted to sign in. You will then be guided through adding and connecting your accounts, and adding and switching to the Moonbase Alpha network:</p> <ol> <li>Select an account and connect to the Safe. You'll want to select at least 2 of the 3 owner accounts and then click Next. For this example, Alice, Bob, and Charlie's accounts have all been selected </li> <li>Connect to the selected accounts by clicking Connect</li> <li>If you are not connected to Moonbase Alpha, nor do you have the network added to your MetaMask, add Moonbase Alpha as a custom network by clicking Approve</li> <li>Switch the network to Moonbase Alpha by click Switch Network</li> </ol> <p></p> <p>Now, in the top right hand corner, you can confirm you are connected to your MetaMask account on the Moonbase Alpha network. If you're using the development accounts, you should see Alice's account address. If not, double check your MetaMask and switch to Alice's account.</p>"},{"location":"tokens/manage/multisig-safe/#create-new-safe","title":"Create New Safe","text":"<p>To create a new Safe on Moonbase Alpha, click Create new Safe. You will be taken to a wizard that will walk you through creating your new Safe. By going through these steps and creating your Safe, you are consenting to the terms of use and the privacy policy. So, feel free to look those over before getting started.</p> <p></p> <p>You will need to give your Safe a name:</p> <ol> <li>Enter the name of your new Safe, you can use <code>moonbeam-tutorial</code></li> <li>Click Start</li> </ol> <p></p> <p>Next up is the owners and confirmations section of the wizard. In this section, you will add the owners of the Safe and specify the threshold. The threshold determines how many of the owners are required to confirm a transaction before the transaction gets executed. </p> <p>There are many different setups that can be used when creating a Safe. There can be 1 or more owners of the Safe as well as varying threshold levels. Please note that it is not advised to create a Safe with just 1 owner as it creates the possibility of a single point of failure.</p> <p>For this guide, you will create a multisig setup that has 3 owners and requires a threshold of 2, so at least 2 out of the 3 owners keys are required to execute transactions through the Safe.</p> <p>Your account will automatically be prefilled in as the first owner, however this can be changed if you would like to use different accounts. For this example, Alice's account has been prefilled. In addition to Alice, you can also add Bob and Charlie as owners:</p> <ol> <li>Click Add another owner</li> <li>Enter Bob as the second owner, along with his address: <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li> <li>Enter Charlie as the third owner, along with his address: <code>0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</code></li> <li>Set the confirmation threshold to 2 out of 3 owners</li> <li>Click Review to go to the last step in the wizard</li> </ol> <p></p> <p>Finally, you can review all of the Safe and owner details and if everything looks ok:</p> <ol> <li>Click Submit to create your new Safe. The creation of the Safe will cost approximately less than .001 DEV tokens on Moonbase Alpha. MetaMask will pop-up and prompt you to confirm the transaction</li> <li>Click Confirm to send the transaction and create the Safe</li> </ol> <p></p> <p>It could take a few minutes to process the transaction and create the Safe, but once it has been created you should see a message saying \"Your Safe was created successfully\". From there, you can click Get Started to load your Safe and start interacting with it.</p> <p></p>"},{"location":"tokens/manage/multisig-safe/#configure-safe","title":"Configure Safe","text":"<p>You can always manage your Safe and change some of the parameters set when creating it. To do so, you can click on the Settings option on the left-hand side menu. </p> <p></p> <p>In there you have the following options:</p> <ul> <li>Safe Details \u2014 allows you to change the Safe name. This is a local action that requires no on-chain interaction</li> <li>Owners \u2014 allows you to initiate a on-chain proposal to add/remove owners to the Safe</li> <li>Policies \u2014 allows you to initiate a on-chain proposal to change the multisig threshold to execute the proposal as a transaction</li> <li>Advanced \u2014 allows you to check other parameters from the Safe, such as the nonce, modules, and transaction guard</li> </ul>"},{"location":"tokens/manage/multisig-safe/#receive-and-send-tokens","title":"Receive and Send Tokens","text":""},{"location":"tokens/manage/multisig-safe/#receive-tokens","title":"Receive Tokens","text":"<p>Now that you have created your Safe, you can start interacting with it. First, load up the Safe by sending some DEV tokens to it. You can send funds to the Safe from any account with DEV tokens. For this example, you can use Alice's account. Hover over DEV in the list of assets to reveal the Send and Receive buttons. Then click Receive.</p> <p></p> <p>A pop-up will appear with the address of the Safe. Copy the address and click Done. </p> <p></p> <p>Next, open up your MetaMask to initiate a transaction:</p> <ol> <li>Click Send to send a transaction</li> <li>Paste in the address of the Safe</li> <li>Enter the amount of DEV tokens you would like to send to the Safe. For this example, you can use 2 DEV tokens</li> <li>Click Next</li> <li>Review the details of the transaction and click Confirm</li> </ol> <p></p> <p>The transaction will be sent and your balance for DEV tokens will be updated on the Safe. </p>"},{"location":"tokens/manage/multisig-safe/#send-tokens","title":"Send Tokens","text":"<p>Now that you have funds in the Safe, you can send funds from the Safe to another account. For this example, you can send 1 DEV token to Bob's address. Hover over DEV in the list of assets, and this time click on Send.</p> <p></p> <p>A pop-up will appear where you can enter the recipient and the amount of DEV tokens to send:</p> <ol> <li>Enter Bob's Address</li> <li>Select DEV from the list of assets</li> <li>Enter 1 DEV token</li> <li>Click Review</li> </ol> <p></p> <ol> <li>Review the details and click Submit. MetaMask will pop-up and you'll notice that instead of sending a transaction, you're sending a message</li> <li>Click Sign to sign the message</li> </ol> <p></p> <p>Now, if you go back to the Safe, under the Transactions tab, you should be able to see that there has been a transaction proposal initiated to send 1 DEV tokens to Bob's address. However, you should also see that only 1 out of 2 confirmations have been received and that 1 more owner is required to confirm the transaction before it gets executed. </p> <p></p>"},{"location":"tokens/manage/multisig-safe/#transaction-confirmation","title":"Transaction Confirmation","text":"<p>The process of confirming (or rejecting) a transaction proposal is similar for all the use cases of a multisig Safe. One of the owners initiates the proposal to execute an action. The other owners can approve or reject the proposal. Once the signature threshold is reached, any owner can execute the transaction proposal if approved, or discard the transaction proposal if rejected.</p> <p>In this example, if 2 of the 3 owners decided to reject the proposal, then the assets would remain in the Safe. However, in this case, you can confirm the transaction from either Bob's or Charlie's account.</p> <p>Switch accounts in MetaMask to Bob's account (or Charlie's). Then go back to the Safe connected as Bob. The Confirm button should now be enabled. As Bob, go ahead and click Confirm to meet the threshold and send the transaction. A pop-up will appear for you to approve the transaction:</p> <ol> <li>Check the Execute transaction box to execute the transaction immediately after confirmation. You can un-check it for the transaction to be executed manually at a later time</li> <li>Click Submit</li> <li>MetaMask will pop-up and ask you to confirm the transaction, if everything looks good, you can click Confirm</li> </ol> <p>Note</p> <p>If you receive an error stating the transaction might fail, you may need to increase the gas limit. You can do so either in the Advanced options or in MetaMask. </p> <p></p> <p>The transaction will be removed from the QUEUE tab and a record of the transaction can now be found under the HISTORY tab. In addition, Bob's balance has now increased by 1 DEV token, and the Safe's balance for DEV tokens has decreased.</p> <p></p> <p>Congratulations, you've successfully received and sent DEV tokens to and from the Safe!</p>"},{"location":"tokens/manage/multisig-safe/#receive-and-send-erc20-tokens","title":"Receive and Send ERC-20 Tokens","text":""},{"location":"tokens/manage/multisig-safe/#receive-erc20-tokens","title":"Receive ERC-20 Tokens","text":"<p>Next up is to receive and send ERC-20s to and from the Safe. You should already have loaded up your MetaMask with MYTOK ERC-20 tokens. If not, please refer back to the ERC-20 Tokens section of the prerequisites.</p> <p>You should still be connected to Bob's account for this example. So, you'll be sending MYTOK tokens from Bob's account to the Safe.</p> <p>You'll need to get the Safe's address again, you can do so by clicking on the Copy to clipboard icon in the top left hand corner. Once you've got your Safe's address copied, open up MetaMask:</p> <ol> <li>Switch to the Assets tab and select MYTOK from the list</li> <li>Click Send </li> <li>Paste in the Safe's address</li> <li>Enter amount of MYTOKs to send. You should have minted 8M MYTOK tokens in the Using Remix to Deploy to Moonbeam guide. So for this example, you can enter 1000 MYTOKs for the amount to send</li> <li>Click Next</li> <li>Review the transaction details and then click Confirm to send the transaction.</li> </ol> <p></p> <p>If you navigate back to the Safe, in the list of Assets you should now see MyToken and a balance of 1000 MYTOKs. It could take a few minutes for MyToken to appear, but there is nothing for you to do to add the asset, it will appear on it's own.</p>"},{"location":"tokens/manage/multisig-safe/#send-erc20-tokens","title":"Send ERC-20 Tokens","text":"<p>Now that you have loaded your Safe with MYTOKs, you can send some from the Safe to another account. For this example, you can send 10 MYTOKs to Charlie.  </p> <p>Hover over MyToken in the list of assets, and this time click on Send.</p> <p></p> <p>A pop-up will appear where you can enter the recipient and the amount of MYTOK tokens to send:</p> <ol> <li>Enter Charlies's Address</li> <li>Select MyToken from the list of assets</li> <li>Enter 10 MYTOK tokens</li> <li>Click Review and review the details</li> </ol> <p></p> <p>If everything looks ok, you can: </p> <ol> <li>Click Submit. MetaMask will pop-up and you'll notice that instead of sending a transaction, you're sending a message</li> <li>Click Sign to sign the message</li> </ol> <p></p> <p>Now, if you go back to the Safe, under the Transactions tab, you should be able to see that there has been a transaction proposal initiated to send 10 MYTOK tokens to Charlie's address. However, you should also see that only 1 out of 2 confirmations have been received and that 1 more owner is required to confirm the transaction before it gets executed.</p> <p></p> <p>You will need to switch accounts to Alice or Charlie and confirm the transaction to execute it. You can follow the same steps outlined in the above Transaction Confirmation section.</p> <p>Once the transaction has been confirmed from one of the other two accounts, the transaction will be moved to the HISTORY tab. </p> <p></p> <p>Congratulations! You've successfully received and sent ERC-20 tokens to and from the Safe!</p>"},{"location":"tokens/manage/multisig-safe/#interact-with-a-smart-contract","title":"Interact with a Smart Contract","text":"<p>For this section, you will be interacting with a smart contract using the Safe. You should have already deployed the <code>SetText.sol</code> contract using Remix, if not please refer back to the Deployed Smart Contract section of the prerequisites.</p> <p>You should still be connected to Alice's account for this section of the guide.</p> <p>From the Safe:</p> <ol> <li>On the left hand side click on New Transaction</li> <li>Then select Contract interaction</li> </ol> <p></p> <p>The Contract interaction pop-up will appear and you can fill in the contract details:</p> <ol> <li>Enter the contract address into the Contract address field</li> <li>In the ABI text box, paste the ABI</li> <li>A Method dropdown will appear. Select the <code>setTextData</code> function</li> <li>Then a <code>_text</code> input field will appear. You can enter anything you would like, for this example, you can use <code>polkadots and moonbeams</code></li> <li>Click Review</li> </ol> <p></p> <p>If the details look ok, go ahead and:</p> <ol> <li>Click Submit. MetaMask will pop-up and you'll notice that instead of sending a transaction, you're sending a message</li> <li>Click Sign to sign the message</li> </ol> <p></p> <p>Now, if you go back to the Safe, under the Transactions tab, you should be able to see that there has been a transaction proposal initiated for a Contract interaction. However, you should also see that only 1 out of 2 confirmations have been received and that 1 more owner is required to confirm the transaction before it gets executed.</p> <p></p> <p>You will need to switch accounts to Bob or Charlie and confirm the transaction to execute it. You can follow the same steps outlined in the above Transaction Confirmation section.</p> <p>Once the transaction has been confirmed from one of the other two accounts, the transaction will be moved to the HISTORY tab.</p> <p></p> <p>To double check that the correct text was set, you can go through the process again except instead of selecting setTextData from the Method dropdown, you can select text to read the <code>text</code> value. This will be a call instead of a transaction, so a Call button will appear. Click on it and directly within the pop-up, you should see the result of the call, <code>polkadots and moonbeams</code>.</p> <p></p> <p>Congratulations, you've successfully interacted with a smart contract using the Safe!</p>"},{"location":"tokens/manage/multisig-safe/#using-moonbeam-safe-apis","title":"Using Moonbeam Safe APIs","text":"<p>There are APIs available to read from and interact with Moonbeam Safes for Moonbeam, Moonriver, and Moonbase Alpha.</p> MoonbeamMoonriverMoonbase Alpha <pre><code>https://transaction.multisig.moonbeam.network/\n</code></pre> <pre><code>https://transaction.moonriver.multisig.moonbeam.network/\n</code></pre> <pre><code>https://transaction.moonbase.multisig.moonbeam.network/\n</code></pre> <p>As an example of using the API, try retrieving information about Safes from the Moonbeam Safe API. From the Safe page, copy the address of your Safe:</p> <p></p> <p>Now you can use the API:</p> <ol> <li>Open the API page for the corresponding network</li> <li>Scroll down to the safes section and click on the /safes/{address}/ endpoint section to expand its panel</li> <li>Click the Try it out button on the right</li> </ol> <p></p> <p>A large Execute button should appear in the panel.</p> <ol> <li>Paste the address of your Safe into the address input</li> <li>Press Execute</li> <li>Information about your safe will appear below</li> </ol> <p></p> <p>Congratulations! You have successfully used the API for Moonbeam Safes. There are still many other endpoints to use, either for convenience or to add into your own app.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tokens/manage/proxy-accounts/","title":"Setting up a Proxy Account","text":""},{"location":"tokens/manage/proxy-accounts/#introduction","title":"Introduction","text":"<p>Proxy accounts can be set up to perform a limited number of actions on behalf of users and are useful for keeping the underlying accounts safe. They allow users to keep their primary account secured safely in cold storage while enabling the proxy to actively perform functions and participate in the network with the weight of the tokens in the primary account.</p> <p>Proxy accounts can be set up to perform specific Substrate functions such as author mapping, staking, balances, and more. This can allow you to, for example, grant a trusted individual access to perform collator or delegator functions on your behalf. A proxy could also be used to keep a staking account safe in cold storage.</p> <p>This guide will show you how to set up a proxy account on the Moonbase Alpha TestNet for balance transfers and how to execute a proxy transaction.</p>"},{"location":"tokens/manage/proxy-accounts/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>Polkadot.js Apps open and connected to Moonbase Alpha</li> <li>Create or have two accounts on Moonbase Alpha</li> <li>At least one of the accounts must be funded with <code>DEV</code> tokens.  You can get DEV tokens for testing on Moonbase Alpha once every 24 hours from the Moonbase Alpha Faucet</li> </ul> <p>If you need help importing your accounts into Polkadot.js Apps, please check out the Interacting with Moonbeam using Polkadot.js Apps guide.</p>"},{"location":"tokens/manage/proxy-accounts/#general-definitions","title":"General Definitions","text":"<p>When setting up a proxy account, a bond for the proxy is taken out of your free balance and moved to your reserved balance. The bond is required as adding a proxy requires on-chain storage space, and it is recalculated for each proxy you add or remove. After all proxies are removed from your account, the bond is returned to your free balance.</p> <p>The deposit is calculated based on a deposit base and a deposit factor:</p> <ul> <li>Deposit base - the amount to be reserved for an account to have a proxy list</li> <li>Deposit factor - the additional amount to be reserved for every proxy the primary account has</li> </ul> <p>The equation for calculating the deposit is:</p> <pre><code>deposit base + deposit factor * number of proxies\n</code></pre> MoonbeamMoonriverMoonbase Alpha Variable Value Deposit base 10.08 GLMR Deposit factor 0.21 GLMR Max proxies 32 proxies Variable Value Deposit base 1.0008 MOVR Deposit factor 0.0021 MOVR Max proxies 32 proxies Variable Value Deposit base 1.0008 DEV Deposit factor 0.0021 DEV Max proxies 32 proxies"},{"location":"tokens/manage/proxy-accounts/#proxy-types","title":"Proxy Types","text":"<p>When creating a proxy account, you must choose a type of proxy which will define how the proxy can be used. The available options are:</p> <ul> <li><code>AuthorMapping</code> - this type of proxy account is used by collators to migrate services from one server to another</li> <li><code>CancelProxy</code> - allows the proxy account to reject and remove any announced proxy calls</li> <li><code>Staking</code> - allows the proxy account to perform staking-related transactions, such as collator or delegator functions, including <code>authorMapping()</code></li> <li><code>Governance</code> - allows the proxy account to make transactions related to governance, such as voting or proposing democracy proposals</li> <li><code>NonTransfer</code> - this type of proxy account is allowed to submit any type of transaction with the exception of balance transfers</li> <li><code>Balances</code> - allows the proxy account to only make transactions related to sending funds</li> <li><code>IdentityJudgement</code> - allows the proxy account to request judgement on an account's identity from a registrar. The following judgements can be issued:<ul> <li>unknown - (default) no judgement has been made yet</li> <li>fee paid - to indicate a user has requested judgement and it is in progress</li> <li>reasonable - the information appears reasonable, but no in-depth checks (i.e. formal KYC process) were performed</li> <li>known good - the information has been certified as correct</li> <li>out of date - the information used to be good, but is now out of date</li> <li>low quality - the information is low quality or imprecise, but can be fixed with an update</li> <li>erroneous - the information is erroneous and may indicate malicious intent</li> </ul> </li> <li><code>Any</code> - allows the proxy account to use any function supported by the proxy pallet</li> </ul> <p>For the purposes of this guide, you will be setting up a proxy account using the balances proxy type. Since this type enables the proxy to spend funds on behalf of the primary account, you should exercise caution and only provide access to accounts you trust. The proxy will have access to transfer all of the funds within the primary account, and if not trusted, the proxy could drain the primary account. Also make sure not to forget to remove the proxy as needed.</p>"},{"location":"tokens/manage/proxy-accounts/#creating-a-proxy-account","title":"Creating a Proxy Account","text":""},{"location":"tokens/manage/proxy-accounts/#create-via-the-moonbeam-dapp","title":"Via the Moonbeam DApp","text":"<p>It's easy to create a proxy account on the Moonbeam dApp. To do so, take the following steps:</p> <ol> <li>Toggle the network switcher button to select your desired network</li> <li>Navigate to the Proxy page</li> <li>Ensure you're connected with the primary account that you wish to add a proxy of  </li> <li>Enter the address you want to delegate proxy control to</li> <li>From the proxyType dropdown, choose the desired proxy type, such as a balances proxy</li> <li>Optionally, you can add a time delay using a specified number of blocks, which could allow time for the primary account to review the pending transaction</li> <li>Click Add Proxy and confirm the transaction in your wallet</li> </ol> <p></p>"},{"location":"tokens/manage/proxy-accounts/#create-via-polkadot-js-apps","title":"Via Polkadot.js Apps","text":"<p>There are a couple of ways you can create proxy accounts in Polkadot.js Apps, either from the Extrinsics page or the Accounts page. However, to create a time-delayed proxy, you will need to use the Extrinsics page. A time delay provides an additional layer of security to proxies by specifying a delay period based on a number of blocks. This will prevent the proxy account from executing a transaction until the delay period ends. The delay allows time for the primary account that controls the proxy to review pending transactions, potentially for malicious actions, and cancel if necessary before execution.</p> <p>To get started creating your proxy account, head to the Developer tab and select Extrinsics from the dropdown. Next, you will need to take the following steps:</p> <ol> <li>Select the primary account</li> <li>From the submit the following extrinsic dropdown, select proxy</li> <li>Choose the addProxy extrinsic</li> <li>Select the delegate account for the proxy</li> <li>From the proxyType dropdown, choose Balances</li> <li>Optionally, you can add a time delay using a specified number of blocks, which could allow time for the primary account to review the pending transaction</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>You will then be prompted to authorize and sign the transaction. Go ahead and click Sign and Submit to create the proxy relationship.</p> <p>Once the transaction has been successfully submitted, you will receive some notifications confirming the transaction.</p> <p>As previously mentioned, you can also create a proxy from the Accounts page. To do so, navigate to the Accounts page, and take the following steps:</p> <ol> <li>Select the 3 vertical dots next to the primary account</li> <li>Select Add proxy</li> </ol> <p></p> <p>Note</p> <p>If the account already has a proxy, Manage proxies will be displayed as an option instead of Add proxy.</p> <p>A pop-up will appear and you will be able to enter in the required information, such as the proxied/primary account, the proxy account, and type of proxy in order to create a proxy account. First click Add Proxy.</p> <p></p> <p>Then take the following steps:</p> <ol> <li>Select the account you would like to set as a proxy</li> <li>Select the proxy type</li> <li>Click Submit and sign the transaction</li> </ol> <p></p> <p>In the next section, you will learn how to verify that your proxy account was set up successfully.</p>"},{"location":"tokens/manage/proxy-accounts/#verifying-your-proxy-account","title":"Verifying your Proxy Account","text":""},{"location":"tokens/manage/proxy-accounts/#verify-via-the-moonbeam-dapp","title":"Via the Moonbeam DApp","text":"<p>When connected to the Moonbeam dApp with your primary account, you can see a list of accounts with proxy control over your connected primary account in the Your Proxies section.</p> <p></p> <p>Alternatively, by connecting the proxy account to the Moonbeam dApp, you can see a list of accounts over which the connected account has proxy control in the Proxied accounts to you section.</p> <p></p>"},{"location":"tokens/manage/proxy-accounts/#verify-via-polkadot-js-apps","title":"Via Polkadot.js Apps","text":"<p>There are a couple of ways that you can verify your proxy account has been successfully set up. Either through the Accounts page or via the Chain state page.</p> <p>To check your proxy accounts from the Chain state page, you can take the following steps:</p> <ol> <li>From the selected state query dropdown, select proxy</li> <li>Choose the proxies extrinsic</li> <li>Select your primary (proxied) account</li> <li>Click on the + button to send the query</li> </ol> <p></p> <p>The result will appear on the page showing you information about all of your proxies, including the delegate/proxy account address, the proxy type, the delay period if one was specified, and the total bond amount for all of your proxies in Wei.</p> <p>As previously mentioned, you can also check your proxy accounts from the Accounts page. To do so, you can navigate to the Accounts page and there should be a Proxy symbol next to the primary account. Hover over the icon and click on Manage proxies to review your proxies.</p> <p></p> <p>A pop-up will appear where you can view an overview of all of your proxy accounts.</p> <p></p>"},{"location":"tokens/manage/proxy-accounts/#executing-a-proxy-transaction","title":"Executing a Proxy Transaction","text":"<p>Now that you have created a proxy account and verified that it was successfully set up, you can execute a transaction using the proxy account on behalf of the primary account.</p> <p>To execute a transaction, navigate back to the Extrinsics page and take the following steps:</p> <ol> <li>Select the proxy account to submit the transaction from the using the select account dropdown</li> <li>From the submit the following extrinsic menu, select proxy</li> <li>Choose the proxy extrinsic</li> <li>Select the primary account from the real dropdown</li> <li>Select the balances call</li> <li>Choose the transfer extrinsic</li> <li>In the dest field, enter the address you would like to send funds to</li> <li>In the value field, enter the amount of funds to send in Wei. For this example, you can send 2 DEV tokens, which will be <code>2000000000000000000</code> in Wei</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>A pop-up will appear for you to authorize and sign the transaction. Enter your password for the proxy account and click Sign and Submit.</p> <p>If the transaction successfully went through, you should see a couple of notifications pop-up and if you head over to the Accounts page, you'll see that the balance of your primary account has decreased. If you check the balance of the account where you sent the funds to, you'll notice the balance there has increased.</p> <p>That's it! You've successfully executed a transaction using a proxy account on behalf of your primary account.</p>"},{"location":"tokens/manage/proxy-accounts/#removing-a-proxy-account","title":"Removing a Proxy Account","text":""},{"location":"tokens/manage/proxy-accounts/#remove-via-the-moonbeam-dapp","title":"Via the Moonbeam DApp","text":"<p>To remove a proxy account, connect your primary account to the Moonbeam dApp and press Remove next to the proxy account that you want to remove. Alternatively, you can remove all proxy accounts of the primary account with Remove All Proxies. In either case, you must confirm the transaction in your wallet. </p> <p></p>"},{"location":"tokens/manage/proxy-accounts/#remove-via-polkadot-js-apps","title":"Via Polkadot.js Apps","text":"<p>Similarly to adding a proxy account, there are a couple of ways that you can remove a proxy account, either from the Extrinsics page or the Accounts page. Regardless of which page you use, you can elect to remove a single proxy account or all proxies associated with your primary account.</p> <p>To remove a proxy from the Extrinsics page, you can take the following steps:</p> <ol> <li>From the using the selected account dropdown, select your primary account</li> <li>Then select proxy</li> <li>Choose removeProxy to remove a single proxy or removeProxies to remove all associated proxies</li> <li>If removing a single proxy, enter the proxy account to remove in the delegate field</li> <li>Select the proxyType to remove, in this case choose Balances</li> <li>Optionally, select a delay period in block numbers</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>A pop-up will appear for you to authorize and sign the transaction. While either account can sign transactions generally, removing a proxy must be performed by the primary account. Enter your password and click Sign and Submit.</p> <p>You can follow the steps in the Verifying your Proxy Account section to check that the proxy or proxies have been removed.</p> <p>As previously mentioned, you can also remove a proxy from the Accounts page. To do so, on the Accounts page, select the 3 vertical dots next to the primary account and select Manage Proxies.</p> <p></p> <p>A pop-up will appear showing an overview of your proxy accounts. To remove a single proxy you can select the X button next to the proxy to remove. The proxy will disappear from the list, then you will need to click Submit. Next you will be able to enter your password and submit the transaction. Or to remove all proxies you can click on Clear all, then you will automatically be prompted to enter your password and submit the transaction.</p> <p></p> <p>Once the transaction has successfully been submitted, you can review your current proxies or if you removed all proxies you will notice the proxy icon is no longer being displayed next to the primary account.</p> <p>And that's it! You've successfully created a proxy, reviewed all proxy accounts associated with your primary account, executed a proxy transaction, and removed a proxy account!</p>"},{"location":"tokens/staking/stake/","title":"How to Stake your Tokens","text":""},{"location":"tokens/staking/stake/#introduction","title":"Introduction","text":"<p>Collator candidates with the highest stake in the network join the active pool of collators (block producers), from which they are selected to offer a block to the relay chain.</p> <p>Token holders can add to candidates' stake using their tokens, a process called delegation (also referred to as staking). When they do so, they are vouching for that specific candidate, and their delegation is a signal of trust. When delegating, tokens are deducted instantly and added to the total amount staked by the user. Exiting a position is divided into a two step operation: scheduling and execution. First, token holders must schedule a request to exit their position, and wait for a given delay or unbonding period, which depends on the network. Once the unbonding period has expired, users can execute their scheduled action.</p> <p>Once a candidate joins the active set of collators, they are eligible to produce blocks and receive partial block rewards as part of the token inflationary model. They share these as staking rewards with their delegators, considering their proportional contribution toward their stake in the network. Delegators can choose to auto-compound their rewards so that a set percentage of their rewards are automatically applied to their total delegation amount.</p> <p>This guide will show you how to stake on Moonbase Alpha via Polkadot.js Apps, but similar steps can be taken for any of the Moonbeam and Moonriver. Token holders that want to easily stake their tokens can use the Moonbeam dApp to do so.</p> <p>For more general information on staking, please check out the Staking on Moonbeam overview.</p>"},{"location":"tokens/staking/stake/#extrinsics-definitions","title":"Extrinsics Definitions","text":"<p>There are many extrinsics related to the staking pallet; you can explore the full list directly in Polkadot.js Apps or by reviewing the chain metadata.</p> <p>The following list covers the extrinsics that you'll use in this guide and are associated with the delegation process.</p> <p>Note</p> <p>Extrinsics might change in the future as the staking pallet is updated.</p>"},{"location":"tokens/staking/stake/#join-or-leave-the-delegator-set","title":"Join the Delegator Set","text":"<ul> <li>delegateWithAutoCompound(address candidate, uint256 amount, uint8 autoCompound, uint256 candidateDelegationCount, uint256 candidateAutoCompoundingDelegationCount, uint256 delegatorDelegationCount) - extrinsic to delegate a given amount to a collator. The amount needs to be greater than the minimum delegation stake. This also sets the percentage of rewards to be auto-compounded</li> </ul>"},{"location":"tokens/staking/stake/#bond-more-or-less","title":"Bond More or Less","text":"<ul> <li>delegatorBondMore(address candidate, uint256 more) - extrinsic to request to increase the amount of staked tokens for an already delegated collator</li> <li>scheduleDelegatorBondLess(address candidate, uint256 less) - extrinsic to request to reduce the amount of staked tokens for an already delegated collator. The amount must not decrease your overall total staked below the minimum delegation stake. There will be a bond less delay before you can execute the request via the <code>executeDelegationRequest</code> extrinsic</li> <li>executeDelegationRequest(address delegator, address candidate) - extrinsic to execute and pending delegation requests. This extrinsic should only be used after a request has been scheduled and the exit delay has passed</li> <li>scheduleCandidateBondLess(uint256 less) - extrinsic that allows a collator candidate to request to decrease their self bond by a given amount. There will be a bond less delay before you can execute the request via the <code>executeCandidateBondLess</code> extrinsic</li> <li>executeCandidateBondLess(address candidate) - extrinsic to execute a decrease a candidate's self bond amount. This extrinsic should only be used after a bond request has been scheduled and the exit delay has passed</li> <li>cancelCandidateBondLess() - extrinsic to cancel a scheduled request to increase or decrease the bond for a specific candidate</li> </ul>"},{"location":"tokens/staking/stake/#revoke-delegations","title":"Revoke Delegations","text":"<ul> <li>scheduleRevokeDelegation(address collator) - extrinsic to schedule to remove an existing delegation entirely. There will be a revoke delegation delay before you can execute the request via the <code>executeDelegationRequest</code> extrinsic</li> <li>cancelDelegationRequest(address candidate) - extrinsic to cancel a scheduled request to revoke a delegation</li> </ul>"},{"location":"tokens/staking/stake/#set-change-auto-compounding","title":"Set or Change Auto-Compounding Percentage","text":"<ul> <li>setAutoCompound(address candidate, uint8 value, uint256 candidateAutoCompoundingDelegationCount, uint256 delegatorDelegationCount) - sets an auto-compound value for an existing delegation</li> </ul>"},{"location":"tokens/staking/stake/#retrieving-staking-parameters","title":"Retrieve Staking Values","text":"<p>You can check out any of the constant staking values using Polkadot.js Apps, such as the maximum number of delegations, minimum stake requirements, exit delays for delegation requests, and more.</p> <p>To do so, you can navigate to Polkadot.js Apps Chain state UI, and for the purposes of this guide, connect to Moonbase Alpha. Alternatively, you can connect to Moonbeam or Moonriver.</p> <p>Then to retrieve the various staking parameters, select the Constants tab on the Chain state UI, and take the following steps:</p> <ol> <li>From the selected constant query dropdown, choose parachainStaking</li> <li>Choose any function you would like to get data for. For this example, you can use maxDelegationsPerDelegator. This will return the maximum number of candidates you can delegate</li> <li>Click + to return the current value</li> </ol> <p></p> <p>You should then see the maximum delegations per delegator, which can also be found in the Staking on Moonbeam overview.</p>"},{"location":"tokens/staking/stake/#how-to-delegate-a-candidate","title":"How to Stake &amp; Auto-Compound Rewards via Polkadot.js Apps","text":"<p>This section goes over the process of delegating collator candidates. The address of the collator candidate on Moonbase Alpha that is used throughout this guide is <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>.</p> <p>Before staking via Polkadot.js Apps, you need to retrieve some important parameters such as the list of candidates, the delegation count of the candidate you want to delegate, and your number of delegations. To auto-compound your delegation rewards, you'll also need the auto-compounding delegation count of the candidate you want to delegate.</p>"},{"location":"tokens/staking/stake/#retrieving-the-list-of-candidates","title":"Retrieve the List of Candidates","text":"<p>Before starting to stake tokens, it is important to retrieve the list of collator candidates available in the network. To do so, head to the Developer tab, click on Chain State, and take the following steps:</p> <ol> <li>Choose the pallet to interact with. In this case, it is the parachainStaking pallet</li> <li>Choose the state to query. In this case, it is the selectedCandidates or candidatePool state</li> <li>Send the state query by clicking on the + button</li> </ol> <p>Each extrinsic provides a different response:</p> <ul> <li>selectedCandidates \u2014 returns the current active set of collators, that is, the top collator candidates by total tokens staked (including delegations). For example, on Moonbase Alpha it is the top 8 candidates</li> <li>candidatePool \u2014 returns the current list of all the candidates, including those that are not in the active set</li> </ul> <p></p>"},{"location":"tokens/staking/stake/#get-the-candidate-delegation-count","title":"Get the Candidate Delegation Count","text":"<p>First, you need to get the <code>candidateInfo</code>, which will contain the delegator count, as you'll need to submit this parameter in a later transaction. To retrieve the parameter, make sure you're still on the Chain State tab of the Developer page, and then take the following steps:</p> <ol> <li>Choose the parachainStaking pallet to interact with</li> <li>Choose the candidateInfo state to query</li> <li>Make sure the include option slider is enabled</li> <li>Enter the collator candidate's address</li> <li>Send the state query by clicking on the + button</li> <li>Copy the result as you'll need it when initiating a delegation</li> </ol> <p></p>"},{"location":"tokens/staking/stake/#get-candidate-auto-compounding-count","title":"Get the Candidate Auto-Compounding Delegation Count","text":"<p>The auto-compounding delegation count is the amount of delegations that have auto-compounding configured. To determine the number of delegations that have auto-compounding set up, you can query the auto-compounding delegations for the candidate on Polkadot.js Apps using the following snippet:</p> <pre><code>// Simple script to get the number of auto-compounding delegations for a given candidate.\n// Remember to replace INSERT_CANDIDATE_ADDRESS with the candidate's address you want to delegate.\nconst candidateAccount = 'INSERT_CANDIDATE_ADDRESS';\nconst autoCompoundingDelegations =\n  await api.query.parachainStaking.autoCompoundingDelegations(candidateAccount);\nconsole.log(autoCompoundingDelegations.toHuman().length);\n</code></pre> <p>To run the snippet, make sure you're on the JavaScript page of Polkadot.js Apps (which can be selected from the Developer dropdown), and take the following steps:</p> <ol> <li>Copy the code from the previous snippet and paste it inside the code editor box</li> <li>(Optional) Click the save icon and set a name for the code snippet, for example, Get auto-compounding delegation count. This will save the code snippet locally</li> <li>To execute the code, click on the run button</li> <li>Copy the result as you'll need it when initiating a delegation</li> </ol> <p></p>"},{"location":"tokens/staking/stake/#get-your-number-of-existing-delegations","title":"Get your Number of Existing Delegations","text":"<p>If you've never made a delegation from your address you can skip this section. However, if you're unsure how many existing delegations you have, you'll want to run the following JavaScript code snippet to get <code>delegationCount</code> from within Polkadot.js:</p> <pre><code>// Simple script to get your number of existing delegations.\n// Remember to replace INSERT_YOUR_ADDRESS with your delegator address.\nconst yourDelegatorAccount = 'INSERT_YOUR_ADDRESS'; \nconst delegatorInfo = \n  await api.query.parachainStaking.delegatorState(yourDelegatorAccount);\n\nif (delegatorInfo.toHuman()) {\n  console.log(delegatorInfo.toHuman()['delegations'].length);\n} else {\n  console.log(0);\n}\n</code></pre> <p>Head to the Developer tab and click on JavaScript. Then take the following steps:</p> <ol> <li>Copy the code from the previous snippet and paste it inside the code editor box</li> <li>(Optional) Click the save icon and set a name for the code snippet, for example, Get delegation count. This will save the code snippet locally</li> <li>To execute the code, click on the run button</li> <li>Copy the result as you'll need it when initiating a delegation</li> </ol> <p></p>"},{"location":"tokens/staking/stake/#staking-your-tokens","title":"Stake your Tokens","text":"<p>To access staking features, you need to use the Polkadot.js Apps interface. To do so, you need to import/create an Ethereum-style account first (H160 address), which you can do by following the Creating or Importing an H160 Account section of the Polkadot.js guide.</p> <p>For this example, an account was imported and named with a super original name: Alice. Alice's address is <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code>.</p> <p>To delegate a candidate and set up auto-compounding for your staking rewards, take the following steps:</p> <ol> <li>Select the account from which you want to stake your tokens</li> <li>Choose the parachainStaking pallet</li> <li>Choose the delegateWithAutoCompound extrinsic</li> <li>Set the candidate's address to delegate. In this case, it is set to <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>Set the number of tokens you want to stake</li> <li>Set the percentage of rewards to auto-compound by entering a number 0-100</li> <li>Input the <code>candidateDelegationCount</code> you retrieved previously from querying <code>candidateInfo</code></li> <li>Input the <code>candidateAutoCompoundingDelegationCount</code> you retrieved previously from querying <code>autoCompoundingDelegations</code></li> <li>Input the <code>delegationCount</code> you retrieved from the JavaScript console. This is <code>0</code> if you haven't yet delegated a candidate</li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p> <p>Note</p> <p>The parameters used in steps 7-9 are for gas estimation purposes and do not need to be exact. However, they should not be lower than the actual values.</p>"},{"location":"tokens/staking/stake/#verifying-delegations","title":"Verify Delegations","text":"<p>Once the transaction is confirmed, you can verify your delegation by navigating to Chain state under the Developer tab. Here, provide the following information:</p> <ol> <li>Choose the pallet you want to interact with. In this case, it is the parachainStaking pallet</li> <li>Choose the state to query. In this case, it is the delegatorState</li> <li>Verify the selected address is correct. In this case, you are looking at Alice's account</li> <li>Make sure to enable the include option slider</li> <li>Send the state query by clicking on the + button</li> </ol> <p></p> <p>In the response, you should see your account (in this case, Alice's account) with a list of the delegations. Each delegation contains the target address of the candidate and the amount.</p> <p>You can follow the same steps as described to delegate other candidates in the network.</p>"},{"location":"tokens/staking/stake/#verifying-auto-compounding-percentage","title":"Verify Auto-Compounding Percentage","text":"<p>If you want to verify the percentage of rewards that are set to auto-compound for a specific delegation, you can use the following script that will query the <code>autoCompoundingDelegations</code> extrinsic and filter the results based on the delegator's address:</p> <pre><code>// Simple script to verify your auto-compounding percentage for a given candidate.\n// Remember to replace INSERT_CANDIDATE_ADDRESS with the candidate's address you\n// want to delegate and replace INSERT_DELEGATOR_ADDRESS with the address used to \n// delegate with\nconst candidateAccount = 'INSERT_CANDIDATE_ADDRESS';\nconst delegationAccount = 'INSERT_DELEGATOR_ADDRESS';\nconst autoCompoundingDelegations =\n  await api.query.parachainStaking.autoCompoundingDelegations(candidateAccount);\nconst delegation = autoCompoundingDelegations.find(\n  (del) =&gt; del.delegator == delegationAccount\n);\n\nconsole.log(`${delegation.value}%`);\n</code></pre> <p>In Polkadot.js Apps, you can head to the Developer tab and select JavaScript from the dropdown. Then you can take the following steps:</p> <ol> <li>Copy the code from the previous snippet and paste it inside the code editor box</li> <li>(Optional) Click the save icon and set a name for the code snippet, for example, Get auto-compounding percentage. This will save the code snippet locally</li> <li>To execute the code, click on the run button</li> <li>The result is returned in the terminal on the right side</li> </ol> <p></p>"},{"location":"tokens/staking/stake/#set-or-change-auto-compounding","title":"Set or Change the Auto-Compounding Percentage","text":"<p>If you initially set up your delegation without auto-compounding or if you want to update the percentage on an existing delegation with auto-compounding set up, you can use the <code>setAutoCompound</code> function of the Solidity interface.</p> <p>You'll need to get the number of delegations with auto-compounding set up for the candidate you want to set or update auto-compounding for. You'll also need to retrieve your own delegation count. Once you have the necessary information, you can click on the Developer tab, select Extrinsics from the dropdown, and take the following steps:</p> <ol> <li>Select the account from which you initially delegated from and want to set or update auto-compounding for</li> <li>Choose the parachainStaking pallet</li> <li>Choose the setAutoCompound extrinsic</li> <li>Set the candidate's address that you delegated. For this example, it is set to <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>Set the percentage of rewards to auto-compound by entering a number 0-100</li> <li>For the candidateAutoCompoundingDelegationHint field, enter the candidate's number of delegations with auto-compounding configured</li> <li>For the delegationCountHint field, enter your number of delegations</li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p>"},{"location":"tokens/staking/stake/#how-to-stop-delegations","title":"How to Stop Delegations","text":"<p>As of runtime version 1001, there have been significant changes to the way users can interact with various staking features. Including the way staking exits are handled.</p> <p>If you want to make an exit and stop a delegation, you have to first schedule it, wait an exit delay, and then execute the exit request. If you are already a delegator, you can request to stop your delegations using the <code>scheduleRevokeDelegation</code> extrinsic to request to unstake your tokens from a specific collator candidate. Scheduling a request does not automatically revoke your delegations, you must wait an exit delay and then execute the request by using the <code>executeDelegationRequest</code> method.</p>"},{"location":"tokens/staking/stake/#schedule-request-to-stop-delegations","title":"Schedule Request to Stop Delegations","text":"<p>To schedule a request to revoke your delegation from a specific candidate, navigate to the Extrinsics menu under the Developer tab. Here, provide the following information:</p> <ol> <li>Select the account from which you want to remove your delegation</li> <li>Choose the <code>parachainStaking</code> pallet</li> <li>Choose the <code>scheduleRevokeDelegation</code> extrinsic</li> <li>Set the candidate's address you want to remove your delegation from. In this case, it is set to <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p> <p>Note</p> <p>There can only be one pending scheduled request per candidate.</p> <p>Once you have scheduled an exit, you must wait an exit delay before you can then execute it. If you try to execute it before the exit delay is up the extrinsic will fail and you'll see an error from Polkadot.js Apps for <code>parachainStaking.PendingDelegationRequest</code>.</p>"},{"location":"tokens/staking/stake/#execute-request-to-stop-delegations","title":"Execute Request to Stop Delegations","text":"<p>After the exit delay has passed after initiating the scheduled request, you can go back to the Developer tab of the Extrinsics menu and follow these steps to execute the request:</p> <ol> <li>Select the account to execute the revocation</li> <li>Choose the parachainStaking pallet</li> <li>Choose the executeDelegationRequest extrinsic</li> <li>Set the delegator's address you want to remove the delegation for. For this example, it will be Alice's address <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>Set the candidate's address you want to remove your delegation from. In this case, it is set to <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code></li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p> <p>Once the transaction is confirmed, you can verify that your delegation was removed by going to the Chain state option under the Developer tab. Here, provide the following information:</p> <ol> <li>Choose the parachainStaking pallet</li> <li>Choose the delegatorState state to query</li> <li>Select your account</li> <li>Make sure to enable the include options slider</li> <li>Send the state query by clicking on the + button</li> </ol> <p></p> <p>In the response, you should see your account (in this case, Alice's account) with a list of the remaining delegations. Each delegation contains the target address of the candidate, and the amount. There should no longer be an entry for <code>0x12E7BCCA9b1B15f33585b5fc898B967149BDb9a5</code>. If you no longer have any delegations, <code>&lt;none&gt;</code> will be returned.</p> <p>To ensure the revocation went through as expected, you can follow the steps in the Verifying Delegations section above.</p>"},{"location":"tokens/staking/stake/#cancel-request-to-stop-delegations","title":"Cancel Request to Stop Delegations","text":"<p>If you scheduled a request to stop delegations but changed your mind, as long as the request has not been executed, you can cancel the request at any time and all of your delegations will remain as is. To cancel the request you can follow these steps:</p> <ol> <li>Select the account to cancel the scheduled request for</li> <li>Choose the parachainStaking pallet</li> <li>Choose the cancelDelegationRequest extrinsic</li> <li>Enter the candidates address that corresponds to the due request you would like to cancel</li> <li>Click the Submit Transaction button and sign the transaction</li> </ol> <p></p>"},{"location":"tokens/staking/stake/#staking-rewards","title":"Staking Rewards","text":"<p>As candidates in the active set of collators receive rewards from block production, delegators get rewards as well. A brief overview on how the rewards are calculated can be found in the Reward Distribution section of the Staking on Moonbeam overview page.</p> <p>In summary, delegators will earn rewards based on their stake of the total delegations for the collator being rewarded (including the collator's stake as well).</p> <p>Delegators can choose to auto-compound their rewards so that their rewards are automatically applied to their total delegation amount. If a delegator has multiple delegations, auto-compounding will need to be set for each delegation.</p>"},{"location":"tokens/staking/stake/#risks","title":"Risks","text":"<p>Holders of MOVR/GLMR tokens should perform careful due diligence on collators before delegating. Being listed as a collator is not an endorsement or recommendation from the Moonbeam Network, the Moonriver Network, or Moonbeam Foundation. Neither the Moonbeam Network, Moonriver Network, nor Moonbeam Foundation has vetted the list collators and assumes no responsibility with regard to the selection, performance, security, accuracy, or use of any third-party offerings.  You alone are responsible for doing your own diligence to understand the applicable fees and all risks present, including actively monitoring the activity of your collators.</p> <p>You agree and understand that neither the Moonbeam Network, the Moonriver Network, nor Moonbeam Foundation guarantees that you will receive staking rewards and any applicable percentage provided (i) is an estimate only and not guaranteed, (ii) may change at any time and (iii) may be more or less than the actual staking rewards you receive. The Moonbeam Foundation makes no representations as to the monetary value of any rewards at any time.</p> <p>Staking MOVR/GLMR tokens is not free of risk. Staked MOVR/GLMR tokens are locked up, and retrieving them requires a 2 day/7 day waiting period . Additionally, if a collator fails to perform required functions or acts in bad faith, a portion of their total stake can be slashed (i.e. destroyed). This includes the stake of their delegators. If a collators behaves suspiciously or is too often offline, delegators can choose to unbond from them or switch to another collator. Delegators can also mitigate risk by electing to distribute their stake across multiple collators.</p>"},{"location":"tutorials/eth-api/using-tenderly/","title":"Using Tenderly to Simulate and Debug Transactions","text":""},{"location":"tutorials/eth-api/using-tenderly/#introduction","title":"Introduction","text":"<p>Tenderly is an all-in-one development platform for EVM networks that enables Web3 developers to build, test, monitor, and operate their smart contracts. Tenderly has a full suite of product offerings to help you as a developer throughout the lifecycle of a smart contract, from the earliest stages of development to maintenance and alerting on a live production dApp.</p> <p>Most services offered by Tenderly are free to use, but you'll need to subscribe to a paid plan for advanced features like real-time alerting and war room functionality. Tenderly supports Moonbeam and Moonriver but does not support Moonbase Alpha at this time. For more information about Tenderly's product offerings, be sure to familiarize yourself with the Introduction to Tenderly.</p> <p>In this tutorial, we're going to explore two of Tenderly's most powerful features, the debugger and the simulator.</p>"},{"location":"tutorials/eth-api/using-tenderly/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you will need the following:</p> <ul> <li>Have a free Tenderly Account. You do not need a paid plan to complete this tutorial</li> </ul>"},{"location":"tutorials/eth-api/using-tenderly/#create-a-tenderly-project","title":"Create a Tenderly Project","text":"<p>Although not strictly required, it's a good idea to create a Tenderly project to keep things organized and access more of Tenderly's available features. Underneath the Select Project dropdown, you can press Create Project or head directly to the Create Project page of the dashboard.</p> <p>Give your project a name, and then press Create Project. Although you can change your project name at a later point, the URL will remain the original one you created.</p> <p></p> <p>There is a limit of one project with a free account; however, you can have multiple smart contracts under the purview of a single project.</p>"},{"location":"tutorials/eth-api/using-tenderly/#add-smart-contracts","title":"Add Smart Contracts","text":"<p>Adding a smart contract to your Tenderly project is akin to bookmarking it. While not required, adding a contract will unlock additional Tenderly features over simply searching for the contract on the Tenderly platform.</p> <p>To add a smart contract to your Tenderly project, click on the Contracts tab under the Inspect heading, then click Add Contracts. Then, take the following steps:</p> <ol> <li>Enter the address of the contract. For this tutorial, we'll be using the FRAX stablecoin contract <code>0x322E86852e492a7Ee17f28a78c663da38FB33bfb</code></li> <li>Select the network the contract is deployed to. We'll select Moonbeam in this case</li> <li>Give the contract a name to help you recognize it on the dashboard</li> <li>Press Add Contract</li> </ol> <p></p>"},{"location":"tutorials/eth-api/using-tenderly/#simulate-a-transaction","title":"Simulate a Transaction","text":"<p>Simulations allow you to see how a transaction will execute without actually sending it on the blockchain. You can simulate a transaction against any point in time or simply the latest block.</p> <p>Head over to the Simulator tab, and let's craft a transaction to simulate against the Moonbeam network by taking the following steps:</p> <ol> <li>Select the contract that you'd like to interact with. The name displayed here is the nickname that you gave the contract when adding it to your Tenderly workspace</li> <li>Select the contract function you'd like to call. <code>Transfer</code> is selected for demonstration purposes</li> <li>Next, we'll input the relevant function parameters. For destination address, you can input any address, such as Alith's address: <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li> <li>For amount, you can also specify any amount, such as <code>10000000000</code></li> <li>Select Pending Block to run the simulation against the latest Moonbeam block produced</li> <li>Specify the from address as Baltathar: <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code> or another address of your choice</li> <li>Press Simulate Transaction</li> </ol> <p></p> <p>Clearly, this simulated transaction is going to fail because we're trying to send 10,000 FRAX that we don't have. But, with the Tenderly Simulator, we can tinker with the blockchain state and run simulations that assume different conditions. For example, let's run the simulation assuming that Baltathar actually holds a balance of 10,000 FRAX. Press Re-Simulate in the upper right corner, then take the following steps:</p> <ol> <li>Expand the State Overrides section</li> <li>Press Add State Override</li> <li>Select the relevant contract, in this case the FRAX one</li> <li>Under the Storage Variables section, we're going to override the mapping that holds the balance of Baltathar by specifying the key as: <code>balanceOf[0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0]</code> and the value as: <code>10000000000</code>. Pay careful attention that you are performing this step in the Storage Variables section and not the Balance section</li> <li>Press Add to confirm adding the state override</li> <li>Press Simulate Transaction</li> </ol> <p></p> <p>Note</p> <p>Remember that the Alith and Baltathar accounts are part of the list of public developer accounts with known private keys. You will lose any funds sent to these addresses.</p> <p>If you correctly added the state override, you should now see a transaction simulation success screen upon running the simulation. If you get an error, you can press Re-Simulate and verify that you have configured the state override correctly.</p> <p></p> <p>You can also access Tenderly's transaction simulator via the Simulations API.</p>"},{"location":"tutorials/eth-api/using-tenderly/#debugging","title":"Debugging","text":"<p>The Debugger is one of the most powerful and acclaimed features of Tenderly. It's also quite fast and requires minimal setup. In fact, if the contract you're investigating is already verified on chain, firing up the debugger is as easy as searching for the transaction hash on Tenderly. Let's try it out.</p> <p>In the upper search bar, you can paste a contract address or a transaction hash. Recall that Tenderly supports Moonbeam and Moonriver but does not currently support Moonbase Alpha. Here's an example transaction hash of a GLMR / FRAX swap on StellaSwap:</p> <pre><code>0x80c87ab47e077ca491045047389e6bd88a748ca24971a288d09608834a3bda07\n</code></pre> <p>After finding the transaction hash, you're greeted at the top with all of the typical statistics about the transaction, such as status, gas price, gas used, etc. Following that, you'll see a breakdown of the tokens transferred. And at the bottom you'll see a long list of every function call. Given that a swap is a relatively complex interaction, and given that StellaSwap uses upgradable proxy contracts, you'll see quite a long list in this example.</p> <p></p> <p>If you click on Contracts on the left-hand navigation bar, you'll see a list of every contract the transaction interacted with. You can click on a contract to see more details and view the entire source code if the contract is verified.</p> <p></p> <p>Heading down the left-hand navigation bar, you'll see an Events tab followed by a State Changes tab, which shows a visual representation of each change to the chain state that occurred as a result of this transaction.</p> <p></p> <p>If you scroll down to the Debugger tab, you'll be able to step through the contracts line by line and see key state information at the bottom, allowing you to pinpoint the source of any error.</p> <p></p> <p>Finally, you'll see a Gas Profiler, which will give you a visual representation of where and how the gas was spent throughout the course of the transaction. You can click on any of the function calls (represented by the blue rectangles) to see how much gas was spent in each call.</p> <p></p> <p>For a more detailed look, be sure to check out the How to Use Tenderly Debugger guide. And that's it! You're well on your way to mastering Tenderly, which is sure to save you time and simplify your development experience building dApps on Moonbeam.</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"tutorials/integrations/0xgasless/","title":"Enabling Gasless Transactions with 0xGasless","text":""},{"location":"tutorials/integrations/0xgasless/#why-gasless-transactions","title":"Why Gasless Transactions?","text":"<p>One of the primary challenges in blockchain development has been the requirement for users to hold native tokens (like ETH or GLMR) to pay transaction fees. This traditional EOA-based model creates unnecessary friction, particularly when onboarding users who expect Web2-like experiences.</p> <p>Gasless transactions can help solve this through Account Abstraction (ERC-4337), implementing meta-transactions that separate user actions from fee payment. This architecture allows dApps or third-party paymasters to cover gas costs on behalf of users while smart contract wallets handle the transaction execution. 0xGasless leverages these principles in its SDK, enabling Moonbeam developers to implement sophisticated features like social logins, transaction batching, and custom wallet controls \u2013 all while abstracting away the complexity of gas management from end users.</p> <p>In the following tutorial, we'll go through the end-to-end steps of setting up a paymaster on 0xGasless and dispatching a gasless transaction to modify the state of a smart contract on Moonbeam.</p>"},{"location":"tutorials/integrations/0xgasless/#create-and-fund-a-paymaster","title":"Create and Fund a Paymaster","text":"<p>First, you'll need to register for an account on 0xGasless. Then, create a Paymaster for the Moonbeam Network by pressing Create Paymaster and then taking the following steps:</p> <ol> <li>Enter a name for your paymaster</li> <li>Select Moonbeam as the chain</li> <li>Press Create</li> </ol> <p></p> <p>Your paymaster needs funds to cover gas fees for sponsored transactions. To deposit GLMR into your paymaster, take the following steps:</p> <ol> <li>Enter the amount you would like to deposit</li> <li>Press Deposit and confirm the transaction in your wallet</li> </ol> <p></p> <p>Your deposited funds remain flexible - use them to sponsor gasless transactions or withdraw them whenever needed.</p>"},{"location":"tutorials/integrations/0xgasless/#dispatching-a-gasless-transaction","title":"Dispatching a Gasless Transaction","text":"<p>In the following section, we'll create a script demonstrating how to dispatch a gasless transaction. </p>"},{"location":"tutorials/integrations/0xgasless/#prerequisites","title":"Prerequisites","text":"<p>Create a <code>.env</code> file in your project's root directory with the following:</p> <pre><code>PRIVATE_KEY=INSERT_PRIVATE_KEY\nRPC_URL=https://rpc.api.moonbeam.network\n</code></pre> <p>Why are we specifying a private key in the <code>.env</code>? While this transaction will be gasless, you still need a private key to sign the transaction. The account associated with this private key:</p> <ul> <li>Does not need any GLMR tokens</li> <li>Will not pay for gas fees</li> <li>Is only used for transaction signing</li> </ul> <p>Note</p> <p>Never commit your .env file or share your private key. Add .env to your .gitignore file.</p> <p>Also, make sure you have installed the 0xGasless SDK and supporting <code>ethers</code> and <code>dotenv</code> packages:</p> <pre><code>npm install ethers dotenv @0xgasless/smart-account\n</code></pre> <p>First, we'll import the required packages as follows:</p> <pre><code>require('dotenv').config();\nconst ethers = require('ethers');\nconst {\n  PaymasterMode,\n  createSmartAccountClient,\n} = require('@0xgasless/smart-account');\n</code></pre> <p>Next, we'll set the critical constants. We must define the <code>CHAIN_ID</code>, <code>BUNDLER_URL</code>, and <code>PAYMASTER_URL</code>. You can get your unique paymaster URL from the paymaster on your 0xGasless Dashboard.</p> <p>The contract address we've defined here is the address of an Incrementer contract on Moonbeam, on which we'll call the increment function specified by the function selector. This simple contract will allow us to easily see if the gasless transaction has been dispatched successfully. </p> <pre><code>const CHAIN_ID = 1284; // Moonbeam mainnet\nconst BUNDLER_URL = `https://bundler.0xgasless.com/${CHAIN_ID}`;\nconst PAYMASTER_URL =\n  'https://paymaster.0xgasless.com/v1/1284/rpc/INSERT_API_KEY';\nconst CONTRACT_ADDRESS = '0x3aE26f2c909EB4F1EdF97bf60B36529744b09213';\nconst FUNCTION_SELECTOR = '0xd09de08a';\n</code></pre> <p>Warning</p> <p>The Paymaster URL format has recently changed. Use:</p> <pre><code>https://paymaster.0xgasless.com/v1/1284/rpc/INSERT_API_KEY\n</code></pre> <p>Do not use the deprecated format:</p> <pre><code>https://paymaster.0xgasless.com/api/v1/1284/rpc/INSERT_API_KEY\n</code></pre> <p>The difference is that <code>/api</code> has been removed from the path. Make sure your code uses the current format.</p>"},{"location":"tutorials/integrations/0xgasless/#sending-the-transaction","title":"Sending the Transaction","text":"<p>To send a gasless transaction using the 0xGasless smart account, you can call <code>smartWallet.sendTransaction()</code> with two parameters:</p> <ul> <li>The <code>transaction</code> object containing the contract interaction details</li> <li>A configuration object specifying <code>paymasterServiceData</code> with <code>SPONSORED</code> mode. This indicates that the 0xGasless paymaster will use the gas tank to pay for the gas. </li> </ul> <p>The function returns a UserOperation response containing a hash. Wait for the transaction receipt using the <code>waitForUserOpReceipt()</code> helper function, which polls for completion with a configurable timeout (default 60 seconds).</p> <pre><code>const userOpResponse = await smartWallet.sendTransaction(transaction, {\n  paymasterServiceData: { mode: PaymasterMode.SPONSORED },\n});\n\nconst receipt = await waitForUserOpReceipt(userOpResponse, 60000);\n</code></pre> <p>Putting it all together and adding plenty of logging and error handling for easy debugging, the full script is as follows:</p> Dispatch a gasless transaction <pre><code>require('dotenv').config();\nconst ethers = require('ethers');\nconst {\n  PaymasterMode,\n  createSmartAccountClient,\n} = require('@0xgasless/smart-account');\n\nconst CHAIN_ID = 1284; // Moonbeam mainnet\nconst BUNDLER_URL = `https://bundler.0xgasless.com/${CHAIN_ID}`;\nconst PAYMASTER_URL =\n  'https://paymaster.0xgasless.com/v1/1284/rpc/INSERT_API_KEY';\nconst CONTRACT_ADDRESS = '0x3aE26f2c909EB4F1EdF97bf60B36529744b09213';\nconst FUNCTION_SELECTOR = '0xd09de08a';\n\nasync function main() {\n  console.log('Starting the script...');\n  try {\n    // Set up provider and wallet\n    console.log('Setting up provider and wallet...');\n    const provider = new ethers.providers.JsonRpcProvider(process.env.RPC_URL);\n    const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);\n\n    // Check connection and balance\n    console.log('Checking network connection...');\n    const network = await provider.getNetwork();\n    console.log(\n      `Connected to network: ${network.name} (Chain ID: ${network.chainId})`\n    );\n    const balance = await provider.getBalance(wallet.address);\n    console.log(`Wallet balance: ${ethers.utils.formatEther(balance)} GLMR`);\n\n    // Initialize smart account\n    console.log('Initializing smart account...');\n    const smartWallet = await createSmartAccountClient({\n      signer: wallet,\n      paymasterUrl: PAYMASTER_URL,\n      bundlerUrl: BUNDLER_URL,\n      chainId: CHAIN_ID,\n    });\n    const smartWalletAddress = await smartWallet.getAddress();\n    console.log('Smart Account Address:', smartWalletAddress);\n\n    // Create a transaction for contract interaction\n    console.log('Creating contract transaction...');\n    const transaction = {\n      to: CONTRACT_ADDRESS,\n      value: '0', // No native token transfer\n      data: FUNCTION_SELECTOR, // The function selector for the method we want to call\n    };\n\n    // Send the transaction\n    console.log('Sending transaction...');\n    const userOpResponse = await smartWallet.sendTransaction(transaction, {\n      paymasterServiceData: { mode: PaymasterMode.SPONSORED },\n    });\n    console.log('UserOp Hash:', userOpResponse.hash);\n\n    console.log('Waiting for transaction receipt...');\n    const userOpReceipt = await waitForUserOpReceipt(userOpResponse, 60000); // Wait for up to 60 seconds\n\n    if (userOpReceipt.success) {\n      console.log('Transaction successful!');\n      console.log('Transaction hash:', userOpReceipt.receipt.transactionHash);\n    } else {\n      console.log('Transaction failed');\n      console.log('Receipt:', userOpReceipt);\n    }\n  } catch (error) {\n    console.error('An error occurred:');\n    console.error(error);\n  }\n}\n\nasync function waitForUserOpReceipt(userOpResponse, timeoutMs = 60000) {\n  return new Promise((resolve, reject) =&gt; {\n    const startTime = Date.now();\n    const checkReceipt = async () =&gt; {\n      try {\n        const receipt = await userOpResponse.wait();\n        resolve(receipt);\n      } catch (error) {\n        if (Date.now() - startTime &gt; timeoutMs) {\n          reject(new Error(`Transaction wait timeout after ${timeoutMs}ms`));\n        } else {\n          setTimeout(checkReceipt, 5000); // Retry every 5 seconds\n        }\n      }\n    };\n    checkReceipt();\n  });\n}\n\nmain().catch((error) =&gt; {\n  console.error('Unhandled error in main function:');\n  console.error(error);\n});\n</code></pre>"},{"location":"tutorials/integrations/0xgasless/#verifying-completion","title":"Verifying Completion","text":"<p>Upon running the script, you'll see output that looks like the following: </p> 0xgasless % node dispatch.js Starting the script... Setting up provider and wallet... Checking network connection... Connected to network: unknown (Chain ID: 1284) Wallet balance: 8.781249287153010128 GLMR Initializing smart account... Smart Account Address: 0xbBf77D3B43d81D426c4c3D200a76F4D3a914ccE3 Creating contract transaction... Sending transaction... UserOp Hash: undefined Waiting for transaction receipt... Transaction successful! Transaction hash: 0x9cb49cc0acc21abc364c13dd52b3f65c206ec61c57a13c23b635f59e1919cf7c <p>Since the gasless transaction we initiated interacts with an Incrementer smart contract on Moonbeam, it's easy to check to see if the transaction was initiated successfully. You can return to Read Contract section of the Incrementer contract on Moonscan and check the number stored in the contract. Alternatively, you can head to the Internal Transactions tab and toggle advanced mode ON to see the contract call incrementing the contract. </p> <p>For more information about integrating support for gasless transactions into your dApp, be sure to check out the 0xGasless docs.</p>      This tutorial is for educational purposes only. As such, any contracts or code created in this tutorial should not be used in production.     The information presented herein has been provided by third parties and is made available solely for general information purposes. Moonbeam does not endorse any project listed and described on the Moonbeam Doc Website (https://docs.moonbeam.network/). Moonbeam Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Moonbeam Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Moonbeam Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Moonbeam Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Moonbeam Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."}]}